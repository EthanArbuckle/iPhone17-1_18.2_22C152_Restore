llvm::raw_ostream *mlir::mps::PaddingModeAttr::print(mlir::mps::PaddingModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  unsigned char *v5;
  unsigned int v6;
  char v7;
  char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  unsigned char *v13;
  uint64_t vars8;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6 > 3)
    {
LABEL_6:
      v9 = 0;
      v8 = &byte_211F4AA5D;
      v7 = 1;
      goto LABEL_9;
    }
  }
  else
  {
    *v5 = 60;
    ++*((void *)v4 + 4);
    v6 = *(_DWORD *)(*(void *)this + 8);
  }
  v7 = 0;
  v8 = "constant";
  v9 = 8;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "reflect";
      v9 = 7;
      break;
    case 2u:
      v7 = 0;
      v8 = "symmetric";
      v9 = 9;
      break;
    case 3u:
      v7 = 0;
      v8 = "clampToEdge";
      v9 = 11;
      break;
    default:
      goto LABEL_6;
  }
LABEL_9:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  v11 = (void *)*((void *)v10 + 4);
  if (v9 <= *((void *)v10 + 3) - (void)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((void *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    *v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::SamplingModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::SamplingModeAttrStorage,mlir::mps::SamplingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23SamplingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16SamplingModeAttrEJNS2_12SamplingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::SamplingModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v96 = *MEMORY[0x263EF8340];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    uint64_t v73 = 0;
    uint64_t v74 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v73))
    {
LABEL_43:
      uint64_t v42 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v88) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v78, a1, v42, v86);
      if (v78[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v78);
      }
      if (v85)
      {
        v43 = __p;
        if (__p)
        {
          v44 = v84;
          v45 = __p;
          if (v84 != __p)
          {
            do
              v44 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v44 - 1);
            while (v44 != v43);
            v45 = __p;
          }
          v84 = v43;
          operator delete(v45);
        }
        v46 = v81;
        if (v81)
        {
          v47 = v82;
          v48 = v81;
          if (v82 != v81)
          {
            do
            {
              uint64_t v50 = *--v47;
              uint64_t v49 = v50;
              void *v47 = 0;
              if (v50) {
                MEMORY[0x21667D390](v49, 0x1000C8077774924);
              }
            }
            while (v47 != v46);
            v48 = v81;
          }
          v82 = v46;
          operator delete(v48);
        }
        if (v79 != &v80) {
          free(v79);
        }
      }
      return 0;
    }
    if (v74 == 8)
    {
      if (*(void *)v73 != 0x7261656E696C6962)
      {
LABEL_12:
        __int16 v72 = 257;
        (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v86, a1, v2, v71);
        if (v86[0])
        {
          int v75 = 3;
          v76 = "expected ";
          uint64_t v77 = 9;
          unsigned int v5 = &v75;
          v6 = v87;
          if (v88 >= v89)
          {
            unint64_t v54 = v88 + 1;
            if (v87 <= &v75 && &v87[6 * v88] > &v75)
            {
              int64_t v65 = (char *)&v75 - (char *)v87;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v54, 24);
              v6 = v87;
              unsigned int v5 = (int *)((char *)v87 + v65);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v54, 24);
              unsigned int v5 = &v75;
              v6 = v87;
            }
          }
          v7 = &v6[6 * v88];
          long long v8 = *(_OWORD *)v5;
          *((void *)v7 + 2) = *((void *)v5 + 2);
          *(_OWORD *)v7 = v8;
          uint64_t v9 = ++v88;
          if (v86[0])
          {
            int v75 = 3;
            v76 = "::mlir::mps::SamplingMode";
            uint64_t v77 = 25;
            v10 = &v75;
            v11 = v87;
            if (v9 >= v89)
            {
              unint64_t v55 = v9 + 1;
              BOOL v56 = &v87[6 * v9] > &v75;
              if (v87 <= &v75 && v56)
              {
                int64_t v66 = (char *)&v75 - (char *)v87;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v55, 24);
                v11 = v87;
                v10 = (int *)((char *)v87 + v66);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v55, 24);
                v10 = &v75;
                v11 = v87;
              }
            }
            v12 = &v11[6 * v88];
            long long v13 = *(_OWORD *)v10;
            *((void *)v12 + 2) = *((void *)v10 + 2);
            *(_OWORD *)v12 = v13;
            uint64_t v14 = ++v88;
            if (v86[0])
            {
              int v75 = 3;
              v76 = " to be one of: ";
              uint64_t v77 = 15;
              v15 = &v75;
              v16 = v87;
              if (v14 >= v89)
              {
                unint64_t v57 = v14 + 1;
                BOOL v58 = &v87[6 * v14] > &v75;
                if (v87 <= &v75 && v58)
                {
                  int64_t v67 = (char *)&v75 - (char *)v87;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v57, 24);
                  v16 = v87;
                  v15 = (int *)((char *)v87 + v67);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v57, 24);
                  v15 = &v75;
                  v16 = v87;
                }
              }
              v17 = &v16[6 * v88];
              long long v18 = *(_OWORD *)v15;
              *((void *)v17 + 2) = *((void *)v15 + 2);
              *(_OWORD *)v17 = v18;
              uint64_t v19 = ++v88;
              if (v86[0])
              {
                int v75 = 3;
                v76 = "nearest";
                uint64_t v77 = 7;
                v20 = &v75;
                v21 = v87;
                if (v19 >= v89)
                {
                  unint64_t v59 = v19 + 1;
                  BOOL v60 = &v87[6 * v19] > &v75;
                  if (v87 <= &v75 && v60)
                  {
                    int64_t v68 = (char *)&v75 - (char *)v87;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v59, 24);
                    v21 = v87;
                    v20 = (int *)((char *)v87 + v68);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v59, 24);
                    v20 = &v75;
                    v21 = v87;
                  }
                }
                v22 = &v21[6 * v88];
                long long v23 = *(_OWORD *)v20;
                *((void *)v22 + 2) = *((void *)v20 + 2);
                *(_OWORD *)v22 = v23;
                uint64_t v24 = ++v88;
                if (v86[0])
                {
                  int v75 = 3;
                  v76 = ", ";
                  uint64_t v77 = 2;
                  v25 = &v75;
                  v26 = v87;
                  if (v24 >= v89)
                  {
                    unint64_t v61 = v24 + 1;
                    BOOL v62 = &v87[6 * v24] > &v75;
                    if (v87 <= &v75 && v62)
                    {
                      int64_t v69 = (char *)&v75 - (char *)v87;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v61, 24);
                      v26 = v87;
                      v25 = (int *)((char *)v87 + v69);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v61, 24);
                      v25 = &v75;
                      v26 = v87;
                    }
                  }
                  v27 = &v26[6 * v88];
                  long long v28 = *(_OWORD *)v25;
                  *((void *)v27 + 2) = *((void *)v25 + 2);
                  *(_OWORD *)v27 = v28;
                  uint64_t v29 = ++v88;
                  if (v86[0])
                  {
                    int v75 = 3;
                    v76 = "bilinear";
                    uint64_t v77 = 8;
                    v30 = &v75;
                    v31 = v87;
                    if (v29 >= v89)
                    {
                      unint64_t v63 = v29 + 1;
                      BOOL v64 = &v87[6 * v29] > &v75;
                      if (v87 <= &v75 && v64)
                      {
                        int64_t v70 = (char *)&v75 - (char *)v87;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v63, 24);
                        v31 = v87;
                        v30 = (int *)((char *)v87 + v70);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v63, 24);
                        v30 = &v75;
                        v31 = v87;
                      }
                    }
                    v32 = &v31[6 * v88];
                    long long v33 = *(_OWORD *)v30;
                    *((void *)v32 + 2) = *((void *)v30 + 2);
                    *(_OWORD *)v32 = v33;
                    ++v88;
                  }
                }
              }
            }
          }
        }
        mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v86);
        if (v86[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v86);
        }
        if (v95)
        {
          v34 = v93;
          if (v93)
          {
            v35 = v94;
            v36 = v93;
            if (v94 != v93)
            {
              do
                v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
              while (v35 != v34);
              v36 = v93;
            }
            v94 = v34;
            operator delete(v36);
          }
          v37 = v91;
          if (v91)
          {
            v38 = v92;
            v39 = v91;
            if (v92 != v91)
            {
              do
              {
                uint64_t v41 = *--v38;
                uint64_t v40 = v41;
                void *v38 = 0;
                if (v41) {
                  MEMORY[0x21667D390](v40, 0x1000C8077774924);
                }
              }
              while (v38 != v37);
              v39 = v91;
            }
            v92 = v37;
            operator delete(v39);
          }
          if (v87 != (int *)v90) {
            free(v87);
          }
        }
        goto LABEL_43;
      }
      unsigned int v4 = 1;
    }
    else
    {
      if (v74 != 7) {
        goto LABEL_12;
      }
      if (*(_DWORD *)v73 != 1918985582 || *(_DWORD *)(v73 + 3) != 1953719666) {
        goto LABEL_12;
      }
      unsigned int v4 = 0;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v71[0] = v4;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v86[0] = &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id;
      v86[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::SamplingModeAttrStorage,mlir::mps::SamplingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23SamplingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16SamplingModeAttrEJNS2_12SamplingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v86, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id, v71);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::SamplingModeAttr::print(mlir::mps::SamplingModeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    *unsigned int v5 = 60;
    ++*((void *)v4 + 4);
  }
  int v6 = *(_DWORD *)(*(void *)this + 8);
  v7 = &byte_211F4AA5D;
  uint64_t v8 = 8;
  if (v6 == 1) {
    v7 = "bilinear";
  }
  else {
    uint64_t v8 = 0;
  }
  if (v6) {
    BOOL v9 = v6 != 1;
  }
  else {
    BOOL v9 = 0;
  }
  if (v6) {
    size_t v10 = v8;
  }
  else {
    size_t v10 = 7;
  }
  if (v6) {
    v11 = v7;
  }
  else {
    v11 = "nearest";
  }
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (void *)*((void *)v12 + 4);
  if (v10 <= *((void *)v12 + 3) - (void)v13)
  {
    if (!v9)
    {
      memcpy(v13, v11, v10);
      *((void *)v12 + 4) += v10;
    }
  }
  else
  {
    llvm::raw_ostream::write(v12, v11, v10);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  v15 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v15)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v15 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::NearestRoundingModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::NearestRoundingModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::NearestRoundingModeAttrStorage,mlir::mps::NearestRoundingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail30NearestRoundingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_23NearestRoundingModeAttrEJNS2_19NearestRoundingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::NearestRoundingModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::NearestRoundingModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v160 = *MEMORY[0x263EF8340];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1)) {
    return 0;
  }
  uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  uint64_t v137 = 0;
  uint64_t v138 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v137))
  {
LABEL_53:
    uint64_t v85 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    LOWORD(v152) = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v142, a1, v85, v150);
    if (v142[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v142);
    }
    if (v149)
    {
      v86 = __p;
      if (__p)
      {
        v87 = v148;
        unsigned int v88 = __p;
        if (v148 != __p)
        {
          do
            v87 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v87 - 1);
          while (v87 != v86);
          unsigned int v88 = __p;
        }
        v148 = v86;
        operator delete(v88);
      }
      unsigned int v89 = v145;
      if (v145)
      {
        v90 = v146;
        v91 = v145;
        if (v146 != v145)
        {
          do
          {
            uint64_t v93 = *--v90;
            uint64_t v92 = v93;
            void *v90 = 0;
            if (v93) {
              MEMORY[0x21667D390](v92, 0x1000C8077774924);
            }
          }
          while (v90 != v89);
          v91 = v145;
        }
        v146 = v89;
        operator delete(v91);
      }
      if (v143 != &v144) {
        free(v143);
      }
    }
    return 0;
  }
  uint64_t v3 = mlir::mps::symbolizeNearestRoundingMode(v137, v138);
  if ((v3 & 0xFF00000000) == 0)
  {
    __int16 v136 = 257;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v150, a1, v2, v135);
    if (v150[0])
    {
      int v139 = 3;
      v140 = "expected ";
      uint64_t v141 = 9;
      uint64_t v8 = &v139;
      BOOL v9 = v151;
      if (v152 >= v153)
      {
        unint64_t v94 = v152 + 1;
        if (v151 <= &v139 && &v151[6 * v152] > &v139)
        {
          int64_t v121 = (char *)&v139 - (char *)v151;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          BOOL v9 = v151;
          uint64_t v8 = (int *)((char *)v151 + v121);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          uint64_t v8 = &v139;
          BOOL v9 = v151;
        }
      }
      size_t v10 = &v9[6 * v152];
      long long v11 = *(_OWORD *)v8;
      *((void *)v10 + 2) = *((void *)v8 + 2);
      *(_OWORD *)size_t v10 = v11;
      uint64_t v12 = ++v152;
      if (v150[0])
      {
        int v139 = 3;
        v140 = "mlir::mps::NearestRoundingMode";
        uint64_t v141 = 30;
        long long v13 = &v139;
        uint64_t v14 = v151;
        if (v12 >= v153)
        {
          unint64_t v95 = v12 + 1;
          BOOL v96 = &v151[6 * v12] > &v139;
          if (v151 <= &v139 && v96)
          {
            int64_t v122 = (char *)&v139 - (char *)v151;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            uint64_t v14 = v151;
            long long v13 = (int *)((char *)v151 + v122);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            long long v13 = &v139;
            uint64_t v14 = v151;
          }
        }
        v15 = &v14[6 * v152];
        long long v16 = *(_OWORD *)v13;
        *((void *)v15 + 2) = *((void *)v13 + 2);
        *(_OWORD *)v15 = v16;
        uint64_t v17 = ++v152;
        if (v150[0])
        {
          int v139 = 3;
          v140 = " to be one of: ";
          uint64_t v141 = 15;
          long long v18 = &v139;
          uint64_t v19 = v151;
          if (v17 >= v153)
          {
            unint64_t v97 = v17 + 1;
            BOOL v98 = &v151[6 * v17] > &v139;
            if (v151 <= &v139 && v98)
            {
              int64_t v123 = (char *)&v139 - (char *)v151;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              uint64_t v19 = v151;
              long long v18 = (int *)((char *)v151 + v123);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              long long v18 = &v139;
              uint64_t v19 = v151;
            }
          }
          v20 = &v19[6 * v152];
          long long v21 = *(_OWORD *)v18;
          *((void *)v20 + 2) = *((void *)v18 + 2);
          *(_OWORD *)v20 = v21;
          uint64_t v22 = ++v152;
          if (v150[0])
          {
            int v139 = 3;
            v140 = "round_prefer_ceil";
            uint64_t v141 = 17;
            long long v23 = &v139;
            uint64_t v24 = v151;
            if (v22 >= v153)
            {
              unint64_t v99 = v22 + 1;
              BOOL v100 = &v151[6 * v22] > &v139;
              if (v151 <= &v139 && v100)
              {
                int64_t v124 = (char *)&v139 - (char *)v151;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                uint64_t v24 = v151;
                long long v23 = (int *)((char *)v151 + v124);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                long long v23 = &v139;
                uint64_t v24 = v151;
              }
            }
            v25 = &v24[6 * v152];
            long long v26 = *(_OWORD *)v23;
            *((void *)v25 + 2) = *((void *)v23 + 2);
            *(_OWORD *)v25 = v26;
            uint64_t v27 = ++v152;
            if (v150[0])
            {
              int v139 = 3;
              v140 = ", ";
              uint64_t v141 = 2;
              long long v28 = &v139;
              uint64_t v29 = v151;
              if (v27 >= v153)
              {
                unint64_t v101 = v27 + 1;
                BOOL v102 = &v151[6 * v27] > &v139;
                if (v151 <= &v139 && v102)
                {
                  int64_t v125 = (char *)&v139 - (char *)v151;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  uint64_t v29 = v151;
                  long long v28 = (int *)((char *)v151 + v125);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  long long v28 = &v139;
                  uint64_t v29 = v151;
                }
              }
              v30 = &v29[6 * v152];
              long long v31 = *(_OWORD *)v28;
              *((void *)v30 + 2) = *((void *)v28 + 2);
              *(_OWORD *)v30 = v31;
              uint64_t v32 = ++v152;
              if (v150[0])
              {
                int v139 = 3;
                v140 = "round_prefer_floor";
                uint64_t v141 = 18;
                long long v33 = &v139;
                v34 = v151;
                if (v32 >= v153)
                {
                  unint64_t v103 = v32 + 1;
                  BOOL v104 = &v151[6 * v32] > &v139;
                  if (v151 <= &v139 && v104)
                  {
                    int64_t v126 = (char *)&v139 - (char *)v151;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    v34 = v151;
                    long long v33 = (int *)((char *)v151 + v126);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    long long v33 = &v139;
                    v34 = v151;
                  }
                }
                v35 = &v34[6 * v152];
                long long v36 = *(_OWORD *)v33;
                *((void *)v35 + 2) = *((void *)v33 + 2);
                *(_OWORD *)v35 = v36;
                uint64_t v37 = ++v152;
                if (v150[0])
                {
                  int v139 = 3;
                  v140 = ", ";
                  uint64_t v141 = 2;
                  v38 = &v139;
                  v39 = v151;
                  if (v37 >= v153)
                  {
                    unint64_t v105 = v37 + 1;
                    BOOL v106 = &v151[6 * v37] > &v139;
                    if (v151 <= &v139 && v106)
                    {
                      int64_t v127 = (char *)&v139 - (char *)v151;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      v39 = v151;
                      v38 = (int *)((char *)v151 + v127);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      v38 = &v139;
                      v39 = v151;
                    }
                  }
                  uint64_t v40 = &v39[6 * v152];
                  long long v41 = *(_OWORD *)v38;
                  *((void *)v40 + 2) = *((void *)v38 + 2);
                  *(_OWORD *)uint64_t v40 = v41;
                  uint64_t v42 = ++v152;
                  if (v150[0])
                  {
                    int v139 = 3;
                    v140 = "ceil";
                    uint64_t v141 = 4;
                    v43 = &v139;
                    v44 = v151;
                    if (v42 >= v153)
                    {
                      unint64_t v107 = v42 + 1;
                      BOOL v108 = &v151[6 * v42] > &v139;
                      if (v151 <= &v139 && v108)
                      {
                        int64_t v128 = (char *)&v139 - (char *)v151;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        v44 = v151;
                        v43 = (int *)((char *)v151 + v128);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        v43 = &v139;
                        v44 = v151;
                      }
                    }
                    v45 = &v44[6 * v152];
                    long long v46 = *(_OWORD *)v43;
                    *((void *)v45 + 2) = *((void *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    uint64_t v47 = ++v152;
                    if (v150[0])
                    {
                      int v139 = 3;
                      v140 = ", ";
                      uint64_t v141 = 2;
                      v48 = &v139;
                      uint64_t v49 = v151;
                      if (v47 >= v153)
                      {
                        unint64_t v109 = v47 + 1;
                        BOOL v110 = &v151[6 * v47] > &v139;
                        if (v151 <= &v139 && v110)
                        {
                          int64_t v129 = (char *)&v139 - (char *)v151;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          uint64_t v49 = v151;
                          v48 = (int *)((char *)v151 + v129);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          v48 = &v139;
                          uint64_t v49 = v151;
                        }
                      }
                      uint64_t v50 = &v49[6 * v152];
                      long long v51 = *(_OWORD *)v48;
                      *((void *)v50 + 2) = *((void *)v48 + 2);
                      *(_OWORD *)uint64_t v50 = v51;
                      uint64_t v52 = ++v152;
                      if (v150[0])
                      {
                        int v139 = 3;
                        v140 = "floor";
                        uint64_t v141 = 5;
                        v53 = &v139;
                        unint64_t v54 = v151;
                        if (v52 >= v153)
                        {
                          unint64_t v111 = v52 + 1;
                          BOOL v112 = &v151[6 * v52] > &v139;
                          if (v151 <= &v139 && v112)
                          {
                            int64_t v130 = (char *)&v139 - (char *)v151;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            unint64_t v54 = v151;
                            v53 = (int *)((char *)v151 + v130);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            v53 = &v139;
                            unint64_t v54 = v151;
                          }
                        }
                        unint64_t v55 = &v54[6 * v152];
                        long long v56 = *(_OWORD *)v53;
                        *((void *)v55 + 2) = *((void *)v53 + 2);
                        *(_OWORD *)unint64_t v55 = v56;
                        uint64_t v57 = ++v152;
                        if (v150[0])
                        {
                          int v139 = 3;
                          v140 = ", ";
                          uint64_t v141 = 2;
                          BOOL v58 = &v139;
                          unint64_t v59 = v151;
                          if (v57 >= v153)
                          {
                            unint64_t v113 = v57 + 1;
                            BOOL v114 = &v151[6 * v57] > &v139;
                            if (v151 <= &v139 && v114)
                            {
                              int64_t v131 = (char *)&v139 - (char *)v151;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              unint64_t v59 = v151;
                              BOOL v58 = (int *)((char *)v151 + v131);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              BOOL v58 = &v139;
                              unint64_t v59 = v151;
                            }
                          }
                          BOOL v60 = &v59[6 * v152];
                          long long v61 = *(_OWORD *)v58;
                          *((void *)v60 + 2) = *((void *)v58 + 2);
                          *(_OWORD *)BOOL v60 = v61;
                          uint64_t v62 = ++v152;
                          if (v150[0])
                          {
                            int v139 = 3;
                            v140 = "round_to_even";
                            uint64_t v141 = 13;
                            unint64_t v63 = &v139;
                            BOOL v64 = v151;
                            if (v62 >= v153)
                            {
                              unint64_t v115 = v62 + 1;
                              BOOL v116 = &v151[6 * v62] > &v139;
                              if (v151 <= &v139 && v116)
                              {
                                int64_t v132 = (char *)&v139 - (char *)v151;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                BOOL v64 = v151;
                                unint64_t v63 = (int *)((char *)v151 + v132);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                unint64_t v63 = &v139;
                                BOOL v64 = v151;
                              }
                            }
                            int64_t v65 = &v64[6 * v152];
                            long long v66 = *(_OWORD *)v63;
                            *((void *)v65 + 2) = *((void *)v63 + 2);
                            *(_OWORD *)int64_t v65 = v66;
                            uint64_t v67 = ++v152;
                            if (v150[0])
                            {
                              int v139 = 3;
                              v140 = ", ";
                              uint64_t v141 = 2;
                              int64_t v68 = &v139;
                              int64_t v69 = v151;
                              if (v67 >= v153)
                              {
                                unint64_t v117 = v67 + 1;
                                BOOL v118 = &v151[6 * v67] > &v139;
                                if (v151 <= &v139 && v118)
                                {
                                  int64_t v133 = (char *)&v139 - (char *)v151;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  int64_t v69 = v151;
                                  int64_t v68 = (int *)((char *)v151 + v133);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  int64_t v68 = &v139;
                                  int64_t v69 = v151;
                                }
                              }
                              int64_t v70 = &v69[6 * v152];
                              long long v71 = *(_OWORD *)v68;
                              *((void *)v70 + 2) = *((void *)v68 + 2);
                              *(_OWORD *)int64_t v70 = v71;
                              uint64_t v72 = ++v152;
                              if (v150[0])
                              {
                                int v139 = 3;
                                v140 = "round_to_odd";
                                uint64_t v141 = 12;
                                uint64_t v73 = &v139;
                                uint64_t v74 = v151;
                                if (v72 >= v153)
                                {
                                  unint64_t v119 = v72 + 1;
                                  BOOL v120 = &v151[6 * v72] > &v139;
                                  if (v151 <= &v139 && v120)
                                  {
                                    int64_t v134 = (char *)&v139 - (char *)v151;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    uint64_t v74 = v151;
                                    uint64_t v73 = (int *)((char *)v151 + v134);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    uint64_t v73 = &v139;
                                    uint64_t v74 = v151;
                                  }
                                }
                                int v75 = &v74[6 * v152];
                                long long v76 = *(_OWORD *)v73;
                                *((void *)v75 + 2) = *((void *)v73 + 2);
                                *(_OWORD *)int v75 = v76;
                                ++v152;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v150);
    if (v150[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v150);
    }
    if (v159)
    {
      uint64_t v77 = v157;
      if (v157)
      {
        v78 = v158;
        v79 = v157;
        if (v158 != v157)
        {
          do
            v78 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v78 - 1);
          while (v78 != v77);
          v79 = v157;
        }
        v158 = v77;
        operator delete(v79);
      }
      uint64_t v80 = v155;
      if (v155)
      {
        v81 = v156;
        v82 = v155;
        if (v156 != v155)
        {
          do
          {
            uint64_t v84 = *--v81;
            uint64_t v83 = v84;
            void *v81 = 0;
            if (v84) {
              MEMORY[0x21667D390](v83, 0x1000C8077774924);
            }
          }
          while (v81 != v80);
          v82 = v155;
        }
        v156 = v80;
        operator delete(v82);
      }
      if (v151 != (int *)v154) {
        free(v151);
      }
    }
    goto LABEL_53;
  }
  unsigned int v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v135[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v150[0] = &mlir::detail::TypeIDResolver<mlir::mps::NearestRoundingModeAttr,void>::id;
    v150[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::NearestRoundingModeAttrStorage,mlir::mps::NearestRoundingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail30NearestRoundingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_23NearestRoundingModeAttrEJNS2_19NearestRoundingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v150, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::NearestRoundingModeAttr,void>::id, v135);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::NearestRoundingModeAttr::print(mlir::mps::NearestRoundingModeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6 > 5)
    {
LABEL_6:
      size_t v9 = 0;
      uint64_t v8 = &byte_211F4AA5D;
      char v7 = 1;
      goto LABEL_11;
    }
  }
  else
  {
    *unsigned int v5 = 60;
    ++*((void *)v4 + 4);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
  }
  char v7 = 0;
  uint64_t v8 = "round_prefer_ceil";
  size_t v9 = 17;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      char v7 = 0;
      uint64_t v8 = "round_prefer_floor";
      size_t v9 = 18;
      break;
    case 2u:
      char v7 = 0;
      uint64_t v8 = "ceil";
      size_t v9 = 4;
      break;
    case 3u:
      char v7 = 0;
      uint64_t v8 = "floor";
      size_t v9 = 5;
      break;
    case 4u:
      char v7 = 0;
      uint64_t v8 = "round_to_even";
      size_t v9 = 13;
      break;
    case 5u:
      char v7 = 0;
      uint64_t v8 = "round_to_odd";
      size_t v9 = 12;
      break;
    default:
      goto LABEL_6;
  }
LABEL_11:
  size_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v11 = (void *)*((void *)v10 + 4);
  if (v9 <= *((void *)v10 + 3) - (void)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((void *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    *long long v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::SparseTensorStorageAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::SparseTensorStorageAttrStorage,mlir::mps::SparseTensorStorage>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail30SparseTensorStorageAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_23SparseTensorStorageAttrEJNS2_19SparseTensorStorageEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id, &v5);
}

uint64_t mlir::mps::SparseTensorStorageAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v112 = *MEMORY[0x263EF8340];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    uint64_t v89 = 0;
    uint64_t v90 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v89))
    {
LABEL_52:
      uint64_t v54 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v104) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v94, a1, v54, v102);
      if (v94[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v94);
      }
      if (v101)
      {
        unint64_t v55 = __p;
        if (__p)
        {
          long long v56 = v100;
          uint64_t v57 = __p;
          if (v100 != __p)
          {
            do
              long long v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
            while (v56 != v55);
            uint64_t v57 = __p;
          }
          BOOL v100 = v55;
          operator delete(v57);
        }
        BOOL v58 = v97;
        if (v97)
        {
          unint64_t v59 = v98;
          BOOL v60 = v97;
          if (v98 != v97)
          {
            do
            {
              uint64_t v62 = *--v59;
              uint64_t v61 = v62;
              *unint64_t v59 = 0;
              if (v62) {
                MEMORY[0x21667D390](v61, 0x1000C8077774924);
              }
            }
            while (v59 != v58);
            BOOL v60 = v97;
          }
          BOOL v98 = v58;
          operator delete(v60);
        }
        if (v95 != &v96) {
          free(v95);
        }
      }
      return 0;
    }
    if (v90 != 3)
    {
LABEL_16:
      __int16 v88 = 257;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v102, a1, v2, v87);
      if (v102[0])
      {
        int v91 = 3;
        uint64_t v92 = "expected ";
        uint64_t v93 = 9;
        unsigned int v6 = &v91;
        char v7 = v103;
        if (v104 >= v105)
        {
          unint64_t v66 = v104 + 1;
          if (v103 <= &v91 && &v103[6 * v104] > &v91)
          {
            int64_t v79 = (char *)&v91 - (char *)v103;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            char v7 = v103;
            unsigned int v6 = (int *)((char *)v103 + v79);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            unsigned int v6 = &v91;
            char v7 = v103;
          }
        }
        uint64_t v8 = &v7[6 * v104];
        long long v9 = *(_OWORD *)v6;
        *((void *)v8 + 2) = *((void *)v6 + 2);
        *(_OWORD *)uint64_t v8 = v9;
        uint64_t v10 = ++v104;
        if (v102[0])
        {
          int v91 = 3;
          uint64_t v92 = "::mlir::mps::SparseTensorStorage";
          uint64_t v93 = 32;
          long long v11 = &v91;
          uint64_t v12 = v103;
          if (v10 >= v105)
          {
            unint64_t v67 = v10 + 1;
            BOOL v68 = &v103[6 * v10] > &v91;
            if (v103 <= &v91 && v68)
            {
              int64_t v80 = (char *)&v91 - (char *)v103;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              uint64_t v12 = v103;
              long long v11 = (int *)((char *)v103 + v80);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              long long v11 = &v91;
              uint64_t v12 = v103;
            }
          }
          long long v13 = &v12[6 * v104];
          long long v14 = *(_OWORD *)v11;
          *((void *)v13 + 2) = *((void *)v11 + 2);
          *(_OWORD *)long long v13 = v14;
          uint64_t v15 = ++v104;
          if (v102[0])
          {
            int v91 = 3;
            uint64_t v92 = " to be one of: ";
            uint64_t v93 = 15;
            long long v16 = &v91;
            uint64_t v17 = v103;
            if (v15 >= v105)
            {
              unint64_t v69 = v15 + 1;
              BOOL v70 = &v103[6 * v15] > &v91;
              if (v103 <= &v91 && v70)
              {
                int64_t v81 = (char *)&v91 - (char *)v103;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                uint64_t v17 = v103;
                long long v16 = (int *)((char *)v103 + v81);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                long long v16 = &v91;
                uint64_t v17 = v103;
              }
            }
            long long v18 = &v17[6 * v104];
            long long v19 = *(_OWORD *)v16;
            *((void *)v18 + 2) = *((void *)v16 + 2);
            *(_OWORD *)long long v18 = v19;
            uint64_t v20 = ++v104;
            if (v102[0])
            {
              int v91 = 3;
              uint64_t v92 = "COO";
              uint64_t v93 = 3;
              long long v21 = &v91;
              uint64_t v22 = v103;
              if (v20 >= v105)
              {
                unint64_t v71 = v20 + 1;
                BOOL v72 = &v103[6 * v20] > &v91;
                if (v103 <= &v91 && v72)
                {
                  int64_t v82 = (char *)&v91 - (char *)v103;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  uint64_t v22 = v103;
                  long long v21 = (int *)((char *)v103 + v82);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  long long v21 = &v91;
                  uint64_t v22 = v103;
                }
              }
              long long v23 = &v22[6 * v104];
              long long v24 = *(_OWORD *)v21;
              *((void *)v23 + 2) = *((void *)v21 + 2);
              *(_OWORD *)long long v23 = v24;
              uint64_t v25 = ++v104;
              if (v102[0])
              {
                int v91 = 3;
                uint64_t v92 = ", ";
                uint64_t v93 = 2;
                long long v26 = &v91;
                uint64_t v27 = v103;
                if (v25 >= v105)
                {
                  unint64_t v73 = v25 + 1;
                  if (v103 <= &v91 && &v103[6 * v25] > &v91)
                  {
                    int64_t v83 = (char *)&v91 - (char *)v103;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    uint64_t v27 = v103;
                    long long v26 = (int *)((char *)v103 + v83);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    long long v26 = &v91;
                    uint64_t v27 = v103;
                  }
                }
                long long v28 = &v27[6 * v104];
                long long v29 = *(_OWORD *)v26;
                *((void *)v28 + 2) = *((void *)v26 + 2);
                *(_OWORD *)long long v28 = v29;
                uint64_t v30 = ++v104;
                if (v102[0])
                {
                  int v91 = 3;
                  uint64_t v92 = "CSC";
                  uint64_t v93 = 3;
                  long long v31 = &v91;
                  uint64_t v32 = v103;
                  if (v30 >= v105)
                  {
                    unint64_t v74 = v30 + 1;
                    if (v103 <= &v91 && &v103[6 * v30] > &v91)
                    {
                      int64_t v84 = (char *)&v91 - (char *)v103;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      uint64_t v32 = v103;
                      long long v31 = (int *)((char *)v103 + v84);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      long long v31 = &v91;
                      uint64_t v32 = v103;
                    }
                  }
                  long long v33 = &v32[6 * v104];
                  long long v34 = *(_OWORD *)v31;
                  *((void *)v33 + 2) = *((void *)v31 + 2);
                  *(_OWORD *)long long v33 = v34;
                  uint64_t v35 = ++v104;
                  if (v102[0])
                  {
                    int v91 = 3;
                    uint64_t v92 = ", ";
                    uint64_t v93 = 2;
                    long long v36 = &v91;
                    uint64_t v37 = v103;
                    if (v35 >= v105)
                    {
                      unint64_t v75 = v35 + 1;
                      BOOL v76 = &v103[6 * v35] > &v91;
                      if (v103 <= &v91 && v76)
                      {
                        int64_t v85 = (char *)&v91 - (char *)v103;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        uint64_t v37 = v103;
                        long long v36 = (int *)((char *)v103 + v85);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        long long v36 = &v91;
                        uint64_t v37 = v103;
                      }
                    }
                    v38 = &v37[6 * v104];
                    long long v39 = *(_OWORD *)v36;
                    *((void *)v38 + 2) = *((void *)v36 + 2);
                    *(_OWORD *)v38 = v39;
                    uint64_t v40 = ++v104;
                    if (v102[0])
                    {
                      int v91 = 3;
                      uint64_t v92 = "CSR";
                      uint64_t v93 = 3;
                      long long v41 = &v91;
                      uint64_t v42 = v103;
                      if (v40 >= v105)
                      {
                        unint64_t v77 = v40 + 1;
                        BOOL v78 = &v103[6 * v40] > &v91;
                        if (v103 <= &v91 && v78)
                        {
                          int64_t v86 = (char *)&v91 - (char *)v103;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          uint64_t v42 = v103;
                          long long v41 = (int *)((char *)v103 + v86);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          long long v41 = &v91;
                          uint64_t v42 = v103;
                        }
                      }
                      v43 = &v42[6 * v104];
                      long long v44 = *(_OWORD *)v41;
                      *((void *)v43 + 2) = *((void *)v41 + 2);
                      *(_OWORD *)v43 = v44;
                      ++v104;
                    }
                  }
                }
              }
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v102);
      if (v102[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v102);
      }
      if (v111)
      {
        v45 = v109;
        if (v109)
        {
          long long v46 = v110;
          uint64_t v47 = v109;
          if (v110 != v109)
          {
            do
              long long v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
            while (v46 != v45);
            uint64_t v47 = v109;
          }
          BOOL v110 = v45;
          operator delete(v47);
        }
        v48 = v107;
        if (v107)
        {
          uint64_t v49 = v108;
          uint64_t v50 = v107;
          if (v108 != v107)
          {
            do
            {
              uint64_t v52 = *--v49;
              uint64_t v51 = v52;
              *uint64_t v49 = 0;
              if (v52) {
                MEMORY[0x21667D390](v51, 0x1000C8077774924);
              }
            }
            while (v49 != v48);
            uint64_t v50 = v107;
          }
          BOOL v108 = v48;
          operator delete(v50);
        }
        if (v103 != (int *)v106) {
          free(v103);
        }
      }
      goto LABEL_52;
    }
    if (*(_WORD *)v89 == 20291 && *(unsigned char *)(v89 + 2) == 79)
    {
      unsigned int v53 = 0;
    }
    else if (*(_WORD *)v89 == 21315 && *(unsigned char *)(v89 + 2) == 67)
    {
      unsigned int v53 = 1;
    }
    else
    {
      if (*(_WORD *)v89 != 21315 || *(unsigned char *)(v89 + 2) != 82) {
        goto LABEL_16;
      }
      unsigned int v53 = 2;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v87[0] = v53;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v102[0] = &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id;
      v102[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::SparseTensorStorageAttrStorage,mlir::mps::SparseTensorStorage>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail30SparseTensorStorageAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_23SparseTensorStorageAttrEJNS2_19SparseTensorStorageEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v102, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id, v87);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::SparseTensorStorageAttr::print(mlir::mps::SparseTensorStorageAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) != v5)
  {
    *unsigned int v5 = 60;
    ++*((void *)v4 + 4);
    int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6) {
      goto LABEL_3;
    }
LABEL_11:
    BOOL v7 = 0;
    long long v9 = "COO";
LABEL_13:
    size_t v8 = 3;
    goto LABEL_14;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  int v6 = *(_DWORD *)(*(void *)this + 8);
  if (!v6) {
    goto LABEL_11;
  }
LABEL_3:
  if (v6 == 2)
  {
    BOOL v7 = 0;
    long long v9 = "CSR";
    goto LABEL_13;
  }
  BOOL v7 = v6 != 1;
  if (v6 == 1) {
    size_t v8 = 3;
  }
  else {
    size_t v8 = 0;
  }
  if (v6 == 1) {
    long long v9 = "CSC";
  }
  else {
    long long v9 = &byte_211F4AA5D;
  }
LABEL_14:
  uint64_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v11 = (void *)*((void *)v10 + 4);
  if (v8 <= *((void *)v10 + 3) - (void)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((void *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    *long long v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::MetalPixelFormatAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::MetalPixelFormatAttrStorage,mlir::mps::MetalPixelFormat>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27MetalPixelFormatAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20MetalPixelFormatAttrEJNS2_16MetalPixelFormatEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id, &v5);
}

uint64_t mlir::mps::MetalPixelFormatAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v224 = *MEMORY[0x263EF8340];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1)) {
    return 0;
  }
  uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  v201 = 0;
  uint64_t v202 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v201))
  {
LABEL_69:
    uint64_t v125 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    LOWORD(v216) = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v206, a1, v125, v214);
    if (v206[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v206);
    }
    if (v213)
    {
      int64_t v126 = __p;
      if (__p)
      {
        int64_t v127 = v212;
        int64_t v128 = __p;
        if (v212 != __p)
        {
          do
            int64_t v127 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v127 - 1);
          while (v127 != v126);
          int64_t v128 = __p;
        }
        v212 = v126;
        operator delete(v128);
      }
      int64_t v129 = v209;
      if (v209)
      {
        int64_t v130 = v210;
        int64_t v131 = v209;
        if (v210 != v209)
        {
          do
          {
            uint64_t v133 = *--v130;
            uint64_t v132 = v133;
            *int64_t v130 = 0;
            if (v133) {
              MEMORY[0x21667D390](v132, 0x1000C8077774924);
            }
          }
          while (v130 != v129);
          int64_t v131 = v209;
        }
        v210 = v129;
        operator delete(v131);
      }
      if (v207 != &v208) {
        free(v207);
      }
    }
    return 0;
  }
  uint64_t v3 = mlir::mps::symbolizeMetalPixelFormat(v201, v202);
  if ((v3 & 0xFF00000000) == 0)
  {
    __int16 v200 = 257;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v214, a1, v2, v199);
    if (v214[0])
    {
      int v203 = 3;
      v204 = "expected ";
      uint64_t v205 = 9;
      size_t v8 = &v203;
      long long v9 = v215;
      if (v216 >= v217)
      {
        unint64_t v134 = v216 + 1;
        if (v215 <= &v203 && &v215[6 * v216] > &v203)
        {
          int64_t v167 = (char *)&v203 - (char *)v215;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v134, 24);
          long long v9 = v215;
          size_t v8 = (int *)((char *)v215 + v167);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v134, 24);
          size_t v8 = &v203;
          long long v9 = v215;
        }
      }
      uint64_t v10 = &v9[6 * v216];
      long long v11 = *(_OWORD *)v8;
      *((void *)v10 + 2) = *((void *)v8 + 2);
      *(_OWORD *)uint64_t v10 = v11;
      uint64_t v12 = ++v216;
      if (v214[0])
      {
        int v203 = 3;
        v204 = "::mlir::mps::MetalPixelFormat";
        uint64_t v205 = 29;
        long long v13 = &v203;
        long long v14 = v215;
        if (v12 >= v217)
        {
          unint64_t v135 = v12 + 1;
          BOOL v136 = &v215[6 * v12] > &v203;
          if (v215 <= &v203 && v136)
          {
            int64_t v170 = (char *)&v203 - (char *)v215;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v135, 24);
            long long v14 = v215;
            long long v13 = (int *)((char *)v215 + v170);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v135, 24);
            long long v13 = &v203;
            long long v14 = v215;
          }
        }
        uint64_t v15 = &v14[6 * v216];
        long long v16 = *(_OWORD *)v13;
        *((void *)v15 + 2) = *((void *)v13 + 2);
        *(_OWORD *)uint64_t v15 = v16;
        uint64_t v17 = ++v216;
        if (v214[0])
        {
          int v203 = 3;
          v204 = " to be one of: ";
          uint64_t v205 = 15;
          long long v18 = &v203;
          long long v19 = v215;
          if (v17 >= v217)
          {
            unint64_t v137 = v17 + 1;
            BOOL v138 = &v215[6 * v17] > &v203;
            if (v215 <= &v203 && v138)
            {
              int64_t v173 = (char *)&v203 - (char *)v215;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v137, 24);
              long long v19 = v215;
              long long v18 = (int *)((char *)v215 + v173);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v137, 24);
              long long v18 = &v203;
              long long v19 = v215;
            }
          }
          uint64_t v20 = &v19[6 * v216];
          long long v21 = *(_OWORD *)v18;
          *((void *)v20 + 2) = *((void *)v18 + 2);
          *(_OWORD *)uint64_t v20 = v21;
          uint64_t v22 = ++v216;
          if (v214[0])
          {
            int v203 = 3;
            v204 = "R8Unorm";
            uint64_t v205 = 7;
            long long v23 = &v203;
            long long v24 = v215;
            if (v22 >= v217)
            {
              unint64_t v139 = v22 + 1;
              BOOL v140 = &v215[6 * v22] > &v203;
              if (v215 <= &v203 && v140)
              {
                int64_t v176 = (char *)&v203 - (char *)v215;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v139, 24);
                long long v24 = v215;
                long long v23 = (int *)((char *)v215 + v176);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v139, 24);
                long long v23 = &v203;
                long long v24 = v215;
              }
            }
            uint64_t v25 = &v24[6 * v216];
            long long v26 = *(_OWORD *)v23;
            *((void *)v25 + 2) = *((void *)v23 + 2);
            *(_OWORD *)uint64_t v25 = v26;
            uint64_t v27 = ++v216;
            if (v214[0])
            {
              int v203 = 3;
              v204 = ", ";
              uint64_t v205 = 2;
              long long v28 = &v203;
              long long v29 = v215;
              if (v27 >= v217)
              {
                unint64_t v141 = v27 + 1;
                BOOL v142 = &v215[6 * v27] > &v203;
                if (v215 <= &v203 && v142)
                {
                  int64_t v179 = (char *)&v203 - (char *)v215;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v141, 24);
                  long long v29 = v215;
                  long long v28 = (int *)((char *)v215 + v179);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v141, 24);
                  long long v28 = &v203;
                  long long v29 = v215;
                }
              }
              uint64_t v30 = &v29[6 * v216];
              long long v31 = *(_OWORD *)v28;
              *((void *)v30 + 2) = *((void *)v28 + 2);
              *(_OWORD *)uint64_t v30 = v31;
              uint64_t v32 = ++v216;
              if (v214[0])
              {
                int v203 = 3;
                v204 = "RG8Unorm";
                uint64_t v205 = 8;
                long long v33 = &v203;
                long long v34 = v215;
                if (v32 >= v217)
                {
                  unint64_t v143 = v32 + 1;
                  BOOL v144 = &v215[6 * v32] > &v203;
                  if (v215 <= &v203 && v144)
                  {
                    int64_t v182 = (char *)&v203 - (char *)v215;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v143, 24);
                    long long v34 = v215;
                    long long v33 = (int *)((char *)v215 + v182);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v143, 24);
                    long long v33 = &v203;
                    long long v34 = v215;
                  }
                }
                uint64_t v35 = &v34[6 * v216];
                long long v36 = *(_OWORD *)v33;
                *((void *)v35 + 2) = *((void *)v33 + 2);
                *(_OWORD *)uint64_t v35 = v36;
                uint64_t v37 = ++v216;
                if (v214[0])
                {
                  int v203 = 3;
                  v204 = ", ";
                  uint64_t v205 = 2;
                  v38 = &v203;
                  long long v39 = v215;
                  if (v37 >= v217)
                  {
                    unint64_t v145 = v37 + 1;
                    BOOL v146 = &v215[6 * v37] > &v203;
                    if (v215 <= &v203 && v146)
                    {
                      int64_t v183 = (char *)&v203 - (char *)v215;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v145, 24);
                      long long v39 = v215;
                      v38 = (int *)((char *)v215 + v183);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v145, 24);
                      v38 = &v203;
                      long long v39 = v215;
                    }
                  }
                  uint64_t v40 = &v39[6 * v216];
                  long long v41 = *(_OWORD *)v38;
                  *((void *)v40 + 2) = *((void *)v38 + 2);
                  *(_OWORD *)uint64_t v40 = v41;
                  uint64_t v42 = ++v216;
                  if (v214[0])
                  {
                    int v203 = 3;
                    v204 = "RGBA8Unorm";
                    uint64_t v205 = 10;
                    v43 = &v203;
                    long long v44 = v215;
                    if (v42 >= v217)
                    {
                      unint64_t v147 = v42 + 1;
                      BOOL v148 = &v215[6 * v42] > &v203;
                      if (v215 <= &v203 && v148)
                      {
                        int64_t v184 = (char *)&v203 - (char *)v215;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v147, 24);
                        long long v44 = v215;
                        v43 = (int *)((char *)v215 + v184);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v147, 24);
                        v43 = &v203;
                        long long v44 = v215;
                      }
                    }
                    v45 = &v44[6 * v216];
                    long long v46 = *(_OWORD *)v43;
                    *((void *)v45 + 2) = *((void *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    uint64_t v47 = ++v216;
                    if (v214[0])
                    {
                      int v203 = 3;
                      v204 = ", ";
                      uint64_t v205 = 2;
                      v48 = &v203;
                      uint64_t v49 = v215;
                      if (v47 >= v217)
                      {
                        unint64_t v149 = v47 + 1;
                        BOOL v150 = &v215[6 * v47] > &v203;
                        if (v215 <= &v203 && v150)
                        {
                          int64_t v185 = (char *)&v203 - (char *)v215;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v149, 24);
                          uint64_t v49 = v215;
                          v48 = (int *)((char *)v215 + v185);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v149, 24);
                          v48 = &v203;
                          uint64_t v49 = v215;
                        }
                      }
                      uint64_t v50 = &v49[6 * v216];
                      long long v51 = *(_OWORD *)v48;
                      *((void *)v50 + 2) = *((void *)v48 + 2);
                      *(_OWORD *)uint64_t v50 = v51;
                      uint64_t v52 = ++v216;
                      if (v214[0])
                      {
                        int v203 = 3;
                        v204 = "BGRA8Unorm";
                        uint64_t v205 = 10;
                        unsigned int v53 = &v203;
                        uint64_t v54 = v215;
                        if (v52 >= v217)
                        {
                          unint64_t v151 = v52 + 1;
                          BOOL v152 = &v215[6 * v52] > &v203;
                          if (v215 <= &v203 && v152)
                          {
                            int64_t v186 = (char *)&v203 - (char *)v215;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v151, 24);
                            uint64_t v54 = v215;
                            unsigned int v53 = (int *)((char *)v215 + v186);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v151, 24);
                            unsigned int v53 = &v203;
                            uint64_t v54 = v215;
                          }
                        }
                        unint64_t v55 = &v54[6 * v216];
                        long long v56 = *(_OWORD *)v53;
                        *((void *)v55 + 2) = *((void *)v53 + 2);
                        *(_OWORD *)unint64_t v55 = v56;
                        uint64_t v57 = ++v216;
                        if (v214[0])
                        {
                          int v203 = 3;
                          v204 = ", ";
                          uint64_t v205 = 2;
                          BOOL v58 = &v203;
                          unint64_t v59 = v215;
                          if (v57 >= v217)
                          {
                            unint64_t v153 = v57 + 1;
                            BOOL v154 = &v215[6 * v57] > &v203;
                            if (v215 <= &v203 && v154)
                            {
                              int64_t v187 = (char *)&v203 - (char *)v215;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v153, 24);
                              unint64_t v59 = v215;
                              BOOL v58 = (int *)((char *)v215 + v187);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v153, 24);
                              BOOL v58 = &v203;
                              unint64_t v59 = v215;
                            }
                          }
                          BOOL v60 = &v59[6 * v216];
                          long long v61 = *(_OWORD *)v58;
                          *((void *)v60 + 2) = *((void *)v58 + 2);
                          *(_OWORD *)BOOL v60 = v61;
                          uint64_t v62 = ++v216;
                          if (v214[0])
                          {
                            int v203 = 3;
                            v204 = "R16Float";
                            uint64_t v205 = 8;
                            unint64_t v63 = &v203;
                            BOOL v64 = v215;
                            if (v62 >= v217)
                            {
                              unint64_t v155 = v62 + 1;
                              BOOL v156 = &v215[6 * v62] > &v203;
                              if (v215 <= &v203 && v156)
                              {
                                int64_t v188 = (char *)&v203 - (char *)v215;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v155, 24);
                                BOOL v64 = v215;
                                unint64_t v63 = (int *)((char *)v215 + v188);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v155, 24);
                                unint64_t v63 = &v203;
                                BOOL v64 = v215;
                              }
                            }
                            int64_t v65 = &v64[6 * v216];
                            long long v66 = *(_OWORD *)v63;
                            *((void *)v65 + 2) = *((void *)v63 + 2);
                            *(_OWORD *)int64_t v65 = v66;
                            uint64_t v67 = ++v216;
                            if (v214[0])
                            {
                              int v203 = 3;
                              v204 = ", ";
                              uint64_t v205 = 2;
                              BOOL v68 = &v203;
                              unint64_t v69 = v215;
                              if (v67 >= v217)
                              {
                                unint64_t v157 = v67 + 1;
                                BOOL v158 = &v215[6 * v67] > &v203;
                                if (v215 <= &v203 && v158)
                                {
                                  int64_t v189 = (char *)&v203 - (char *)v215;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v157, 24);
                                  unint64_t v69 = v215;
                                  BOOL v68 = (int *)((char *)v215 + v189);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v157, 24);
                                  BOOL v68 = &v203;
                                  unint64_t v69 = v215;
                                }
                              }
                              BOOL v70 = &v69[6 * v216];
                              long long v71 = *(_OWORD *)v68;
                              *((void *)v70 + 2) = *((void *)v68 + 2);
                              *(_OWORD *)BOOL v70 = v71;
                              uint64_t v72 = ++v216;
                              if (v214[0])
                              {
                                int v203 = 3;
                                v204 = "RG16Float";
                                uint64_t v205 = 9;
                                unint64_t v73 = &v203;
                                unint64_t v74 = v215;
                                if (v72 >= v217)
                                {
                                  unint64_t v159 = v72 + 1;
                                  BOOL v160 = &v215[6 * v72] > &v203;
                                  if (v215 <= &v203 && v160)
                                  {
                                    int64_t v190 = (char *)&v203 - (char *)v215;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v159, 24);
                                    unint64_t v74 = v215;
                                    unint64_t v73 = (int *)((char *)v215 + v190);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v159, 24);
                                    unint64_t v73 = &v203;
                                    unint64_t v74 = v215;
                                  }
                                }
                                unint64_t v75 = &v74[6 * v216];
                                long long v76 = *(_OWORD *)v73;
                                *((void *)v75 + 2) = *((void *)v73 + 2);
                                *(_OWORD *)unint64_t v75 = v76;
                                uint64_t v77 = ++v216;
                                if (v214[0])
                                {
                                  int v203 = 3;
                                  v204 = ", ";
                                  uint64_t v205 = 2;
                                  BOOL v78 = &v203;
                                  int64_t v79 = v215;
                                  if (v77 >= v217)
                                  {
                                    unint64_t v161 = v77 + 1;
                                    BOOL v162 = &v215[6 * v77] > &v203;
                                    if (v215 <= &v203 && v162)
                                    {
                                      int64_t v191 = (char *)&v203 - (char *)v215;
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v161, 24);
                                      int64_t v79 = v215;
                                      BOOL v78 = (int *)((char *)v215 + v191);
                                    }
                                    else
                                    {
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v161, 24);
                                      BOOL v78 = &v203;
                                      int64_t v79 = v215;
                                    }
                                  }
                                  int64_t v80 = &v79[6 * v216];
                                  long long v81 = *(_OWORD *)v78;
                                  *((void *)v80 + 2) = *((void *)v78 + 2);
                                  *(_OWORD *)int64_t v80 = v81;
                                  uint64_t v82 = ++v216;
                                  if (v214[0])
                                  {
                                    int v203 = 3;
                                    v204 = "RGBA16Float";
                                    uint64_t v205 = 11;
                                    int64_t v83 = &v203;
                                    int64_t v84 = v215;
                                    if (v82 >= v217)
                                    {
                                      unint64_t v163 = v82 + 1;
                                      BOOL v164 = &v215[6 * v82] > &v203;
                                      if (v215 <= &v203 && v164)
                                      {
                                        int64_t v192 = (char *)&v203 - (char *)v215;
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v163, 24);
                                        int64_t v84 = v215;
                                        int64_t v83 = (int *)((char *)v215 + v192);
                                      }
                                      else
                                      {
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v163, 24);
                                        int64_t v83 = &v203;
                                        int64_t v84 = v215;
                                      }
                                    }
                                    int64_t v85 = &v84[6 * v216];
                                    long long v86 = *(_OWORD *)v83;
                                    *((void *)v85 + 2) = *((void *)v83 + 2);
                                    *(_OWORD *)int64_t v85 = v86;
                                    uint64_t v87 = ++v216;
                                    if (v214[0])
                                    {
                                      int v203 = 3;
                                      v204 = ", ";
                                      uint64_t v205 = 2;
                                      __int16 v88 = &v203;
                                      uint64_t v89 = v215;
                                      if (v87 >= v217)
                                      {
                                        unint64_t v165 = v87 + 1;
                                        BOOL v166 = &v215[6 * v87] > &v203;
                                        if (v215 <= &v203 && v166)
                                        {
                                          int64_t v193 = (char *)&v203 - (char *)v215;
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v165, 24);
                                          uint64_t v89 = v215;
                                          __int16 v88 = (int *)((char *)v215 + v193);
                                        }
                                        else
                                        {
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v165, 24);
                                          __int16 v88 = &v203;
                                          uint64_t v89 = v215;
                                        }
                                      }
                                      uint64_t v90 = &v89[6 * v216];
                                      long long v91 = *(_OWORD *)v88;
                                      *((void *)v90 + 2) = *((void *)v88 + 2);
                                      *(_OWORD *)uint64_t v90 = v91;
                                      uint64_t v92 = ++v216;
                                      if (v214[0])
                                      {
                                        int v203 = 3;
                                        v204 = "R32Float";
                                        uint64_t v205 = 8;
                                        uint64_t v93 = &v203;
                                        unint64_t v94 = v215;
                                        if (v92 >= v217)
                                        {
                                          unint64_t v168 = v92 + 1;
                                          BOOL v169 = &v215[6 * v92] > &v203;
                                          if (v215 <= &v203 && v169)
                                          {
                                            int64_t v194 = (char *)&v203 - (char *)v215;
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v168, 24);
                                            unint64_t v94 = v215;
                                            uint64_t v93 = (int *)((char *)v215 + v194);
                                          }
                                          else
                                          {
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v168, 24);
                                            uint64_t v93 = &v203;
                                            unint64_t v94 = v215;
                                          }
                                        }
                                        unint64_t v95 = &v94[6 * v216];
                                        long long v96 = *(_OWORD *)v93;
                                        *((void *)v95 + 2) = *((void *)v93 + 2);
                                        *(_OWORD *)unint64_t v95 = v96;
                                        uint64_t v97 = ++v216;
                                        if (v214[0])
                                        {
                                          int v203 = 3;
                                          v204 = ", ";
                                          uint64_t v205 = 2;
                                          BOOL v98 = &v203;
                                          unint64_t v99 = v215;
                                          if (v97 >= v217)
                                          {
                                            unint64_t v171 = v97 + 1;
                                            BOOL v172 = &v215[6 * v97] > &v203;
                                            if (v215 <= &v203 && v172)
                                            {
                                              int64_t v195 = (char *)&v203 - (char *)v215;
                                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v171, 24);
                                              unint64_t v99 = v215;
                                              BOOL v98 = (int *)((char *)v215 + v195);
                                            }
                                            else
                                            {
                                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v171, 24);
                                              BOOL v98 = &v203;
                                              unint64_t v99 = v215;
                                            }
                                          }
                                          BOOL v100 = &v99[6 * v216];
                                          long long v101 = *(_OWORD *)v98;
                                          *((void *)v100 + 2) = *((void *)v98 + 2);
                                          *(_OWORD *)BOOL v100 = v101;
                                          uint64_t v102 = ++v216;
                                          if (v214[0])
                                          {
                                            int v203 = 3;
                                            v204 = "RG32Float";
                                            uint64_t v205 = 9;
                                            unint64_t v103 = &v203;
                                            unsigned int v104 = v215;
                                            if (v102 >= v217)
                                            {
                                              unint64_t v174 = v102 + 1;
                                              BOOL v175 = &v215[6 * v102] > &v203;
                                              if (v215 <= &v203 && v175)
                                              {
                                                int64_t v196 = (char *)&v203 - (char *)v215;
                                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v174, 24);
                                                unsigned int v104 = v215;
                                                unint64_t v103 = (int *)((char *)v215 + v196);
                                              }
                                              else
                                              {
                                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v174, 24);
                                                unint64_t v103 = &v203;
                                                unsigned int v104 = v215;
                                              }
                                            }
                                            unsigned int v105 = &v104[6 * v216];
                                            long long v106 = *(_OWORD *)v103;
                                            *((void *)v105 + 2) = *((void *)v103 + 2);
                                            *(_OWORD *)unsigned int v105 = v106;
                                            uint64_t v107 = ++v216;
                                            if (v214[0])
                                            {
                                              int v203 = 3;
                                              v204 = ", ";
                                              uint64_t v205 = 2;
                                              BOOL v108 = &v203;
                                              unint64_t v109 = v215;
                                              if (v107 >= v217)
                                              {
                                                unint64_t v177 = v107 + 1;
                                                BOOL v178 = &v215[6 * v107] > &v203;
                                                if (v215 <= &v203 && v178)
                                                {
                                                  int64_t v197 = (char *)&v203 - (char *)v215;
                                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v177, 24);
                                                  unint64_t v109 = v215;
                                                  BOOL v108 = (int *)((char *)v215 + v197);
                                                }
                                                else
                                                {
                                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v177, 24);
                                                  BOOL v108 = &v203;
                                                  unint64_t v109 = v215;
                                                }
                                              }
                                              BOOL v110 = &v109[6 * v216];
                                              long long v111 = *(_OWORD *)v108;
                                              *((void *)v110 + 2) = *((void *)v108 + 2);
                                              *(_OWORD *)BOOL v110 = v111;
                                              uint64_t v112 = ++v216;
                                              if (v214[0])
                                              {
                                                int v203 = 3;
                                                v204 = "RGBA32Float";
                                                uint64_t v205 = 11;
                                                unint64_t v113 = &v203;
                                                BOOL v114 = v215;
                                                if (v112 >= v217)
                                                {
                                                  unint64_t v180 = v112 + 1;
                                                  BOOL v181 = &v215[6 * v112] > &v203;
                                                  if (v215 <= &v203 && v181)
                                                  {
                                                    int64_t v198 = (char *)&v203 - (char *)v215;
                                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v180, 24);
                                                    BOOL v114 = v215;
                                                    unint64_t v113 = (int *)((char *)v215 + v198);
                                                  }
                                                  else
                                                  {
                                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v180, 24);
                                                    unint64_t v113 = &v203;
                                                    BOOL v114 = v215;
                                                  }
                                                }
                                                unint64_t v115 = &v114[6 * v216];
                                                long long v116 = *(_OWORD *)v113;
                                                *((void *)v115 + 2) = *((void *)v113 + 2);
                                                *(_OWORD *)unint64_t v115 = v116;
                                                ++v216;
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v214);
    if (v214[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v214);
    }
    if (v223)
    {
      unint64_t v117 = v221;
      if (v221)
      {
        BOOL v118 = v222;
        unint64_t v119 = v221;
        if (v222 != v221)
        {
          do
            BOOL v118 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v118 - 1);
          while (v118 != v117);
          unint64_t v119 = v221;
        }
        v222 = v117;
        operator delete(v119);
      }
      BOOL v120 = v219;
      if (v219)
      {
        int64_t v121 = v220;
        int64_t v122 = v219;
        if (v220 != v219)
        {
          do
          {
            uint64_t v124 = *--v121;
            uint64_t v123 = v124;
            *int64_t v121 = 0;
            if (v124) {
              MEMORY[0x21667D390](v123, 0x1000C8077774924);
            }
          }
          while (v121 != v120);
          int64_t v122 = v219;
        }
        v220 = v120;
        operator delete(v122);
      }
      if (v215 != (int *)v218) {
        free(v215);
      }
    }
    goto LABEL_69;
  }
  unsigned int v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v199[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v214[0] = &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id;
    v214[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::MetalPixelFormatAttrStorage,mlir::mps::MetalPixelFormat>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27MetalPixelFormatAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20MetalPixelFormatAttrEJNS2_16MetalPixelFormatEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v214, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id, v199);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::MetalPixelFormatAttr::print(mlir::mps::MetalPixelFormatAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6 > 9)
    {
LABEL_6:
      size_t v9 = 0;
      size_t v8 = &byte_211F4AA5D;
      char v7 = 1;
      goto LABEL_16;
    }
  }
  else
  {
    *unsigned int v5 = 60;
    ++*((void *)v4 + 4);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
  }
  char v7 = 0;
  size_t v8 = "R8Unorm";
  size_t v9 = 7;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      char v7 = 0;
      size_t v8 = "RG8Unorm";
      size_t v9 = 8;
      break;
    case 2u:
      char v7 = 0;
      size_t v8 = "RGBA8Unorm";
      size_t v9 = 10;
      break;
    case 3u:
      char v7 = 0;
      size_t v8 = "BGRA8Unorm";
      size_t v9 = 10;
      break;
    case 4u:
      char v7 = 0;
      size_t v8 = "R16Float";
      size_t v9 = 8;
      break;
    case 5u:
      char v7 = 0;
      size_t v8 = "RG16Float";
      goto LABEL_15;
    case 6u:
      char v7 = 0;
      size_t v8 = "RGBA16Float";
      size_t v9 = 11;
      break;
    case 7u:
      char v7 = 0;
      size_t v8 = "R32Float";
      size_t v9 = 8;
      break;
    case 8u:
      char v7 = 0;
      size_t v8 = "RG32Float";
LABEL_15:
      size_t v9 = 9;
      break;
    case 9u:
      char v7 = 0;
      size_t v8 = "RGBA32Float";
      size_t v9 = 11;
      break;
    default:
      goto LABEL_6;
  }
LABEL_16:
  uint64_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v11 = (void *)*((void *)v10 + 4);
  if (v9 <= *((void *)v10 + 3) - (void)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((void *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    *long long v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::NormalSamplingMethodAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::NormalSamplingMethodAttrStorage,mlir::mps::NormalSamplingMethod>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail31NormalSamplingMethodAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_24NormalSamplingMethodAttrEJNS2_20NormalSamplingMethodEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id, &v5);
}

uint64_t mlir::mps::NormalSamplingMethodAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v97 = *MEMORY[0x263EF8340];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    uint64_t v74 = 0;
    uint64_t v75 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v74))
    {
LABEL_46:
      uint64_t v43 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v89) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v79, a1, v43, v87);
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
      if (v86)
      {
        long long v44 = __p;
        if (__p)
        {
          v45 = v85;
          long long v46 = __p;
          if (v85 != __p)
          {
            do
              v45 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v45 - 1);
            while (v45 != v44);
            long long v46 = __p;
          }
          int64_t v85 = v44;
          operator delete(v46);
        }
        uint64_t v47 = v82;
        if (v82)
        {
          v48 = v83;
          uint64_t v49 = v82;
          if (v83 != v82)
          {
            do
            {
              uint64_t v51 = *--v48;
              uint64_t v50 = v51;
              void *v48 = 0;
              if (v51) {
                MEMORY[0x21667D390](v50, 0x1000C8077774924);
              }
            }
            while (v48 != v47);
            uint64_t v49 = v82;
          }
          int64_t v83 = v47;
          operator delete(v49);
        }
        if (v80 != &v81) {
          free(v80);
        }
      }
      return 0;
    }
    if (v75 == 10)
    {
      if (*(void *)v74 != 0x6C6C756D5F786F62 || *(_WORD *)(v74 + 8) != 29285) {
        goto LABEL_15;
      }
      unsigned int v4 = 1;
    }
    else
    {
      if (v75 != 7 || (*(_DWORD *)v74 == 1601597033 ? (BOOL v3 = *(_DWORD *)(v74 + 3) == 1717855071) : (BOOL v3 = 0), !v3))
      {
LABEL_15:
        __int16 v73 = 257;
        (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v87, a1, v2, v72);
        if (v87[0])
        {
          int v76 = 3;
          uint64_t v77 = "expected ";
          uint64_t v78 = 9;
          unsigned int v6 = &v76;
          char v7 = v88;
          if (v89 >= v90)
          {
            unint64_t v55 = v89 + 1;
            if (v88 <= &v76 && &v88[6 * v89] > &v76)
            {
              int64_t v66 = (char *)&v76 - (char *)v88;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v55, 24);
              char v7 = v88;
              unsigned int v6 = (int *)((char *)v88 + v66);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v55, 24);
              unsigned int v6 = &v76;
              char v7 = v88;
            }
          }
          size_t v8 = &v7[6 * v89];
          long long v9 = *(_OWORD *)v6;
          *((void *)v8 + 2) = *((void *)v6 + 2);
          *(_OWORD *)size_t v8 = v9;
          uint64_t v10 = ++v89;
          if (v87[0])
          {
            int v76 = 3;
            uint64_t v77 = "::mlir::mps::NormalSamplingMethod";
            uint64_t v78 = 33;
            long long v11 = &v76;
            uint64_t v12 = v88;
            if (v10 >= v90)
            {
              unint64_t v56 = v10 + 1;
              BOOL v57 = &v88[6 * v10] > &v76;
              if (v88 <= &v76 && v57)
              {
                int64_t v67 = (char *)&v76 - (char *)v88;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v56, 24);
                uint64_t v12 = v88;
                long long v11 = (int *)((char *)v88 + v67);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v56, 24);
                long long v11 = &v76;
                uint64_t v12 = v88;
              }
            }
            long long v13 = &v12[6 * v89];
            long long v14 = *(_OWORD *)v11;
            *((void *)v13 + 2) = *((void *)v11 + 2);
            *(_OWORD *)long long v13 = v14;
            uint64_t v15 = ++v89;
            if (v87[0])
            {
              int v76 = 3;
              uint64_t v77 = " to be one of: ";
              uint64_t v78 = 15;
              long long v16 = &v76;
              uint64_t v17 = v88;
              if (v15 >= v90)
              {
                unint64_t v58 = v15 + 1;
                BOOL v59 = &v88[6 * v15] > &v76;
                if (v88 <= &v76 && v59)
                {
                  int64_t v68 = (char *)&v76 - (char *)v88;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v58, 24);
                  uint64_t v17 = v88;
                  long long v16 = (int *)((char *)v88 + v68);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v58, 24);
                  long long v16 = &v76;
                  uint64_t v17 = v88;
                }
              }
              long long v18 = &v17[6 * v89];
              long long v19 = *(_OWORD *)v16;
              *((void *)v18 + 2) = *((void *)v16 + 2);
              *(_OWORD *)long long v18 = v19;
              uint64_t v20 = ++v89;
              if (v87[0])
              {
                int v76 = 3;
                uint64_t v77 = "inv_cdf";
                uint64_t v78 = 7;
                long long v21 = &v76;
                uint64_t v22 = v88;
                if (v20 >= v90)
                {
                  unint64_t v60 = v20 + 1;
                  BOOL v61 = &v88[6 * v20] > &v76;
                  if (v88 <= &v76 && v61)
                  {
                    int64_t v69 = (char *)&v76 - (char *)v88;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v60, 24);
                    uint64_t v22 = v88;
                    long long v21 = (int *)((char *)v88 + v69);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v60, 24);
                    long long v21 = &v76;
                    uint64_t v22 = v88;
                  }
                }
                long long v23 = &v22[6 * v89];
                long long v24 = *(_OWORD *)v21;
                *((void *)v23 + 2) = *((void *)v21 + 2);
                *(_OWORD *)long long v23 = v24;
                uint64_t v25 = ++v89;
                if (v87[0])
                {
                  int v76 = 3;
                  uint64_t v77 = ", ";
                  uint64_t v78 = 2;
                  long long v26 = &v76;
                  uint64_t v27 = v88;
                  if (v25 >= v90)
                  {
                    unint64_t v62 = v25 + 1;
                    BOOL v63 = &v88[6 * v25] > &v76;
                    if (v88 <= &v76 && v63)
                    {
                      int64_t v70 = (char *)&v76 - (char *)v88;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v62, 24);
                      uint64_t v27 = v88;
                      long long v26 = (int *)((char *)v88 + v70);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v62, 24);
                      long long v26 = &v76;
                      uint64_t v27 = v88;
                    }
                  }
                  long long v28 = &v27[6 * v89];
                  long long v29 = *(_OWORD *)v26;
                  *((void *)v28 + 2) = *((void *)v26 + 2);
                  *(_OWORD *)long long v28 = v29;
                  uint64_t v30 = ++v89;
                  if (v87[0])
                  {
                    int v76 = 3;
                    uint64_t v77 = "box_muller";
                    uint64_t v78 = 10;
                    long long v31 = &v76;
                    uint64_t v32 = v88;
                    if (v30 >= v90)
                    {
                      unint64_t v64 = v30 + 1;
                      BOOL v65 = &v88[6 * v30] > &v76;
                      if (v88 <= &v76 && v65)
                      {
                        int64_t v71 = (char *)&v76 - (char *)v88;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v64, 24);
                        uint64_t v32 = v88;
                        long long v31 = (int *)((char *)v88 + v71);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v64, 24);
                        long long v31 = &v76;
                        uint64_t v32 = v88;
                      }
                    }
                    long long v33 = &v32[6 * v89];
                    long long v34 = *(_OWORD *)v31;
                    *((void *)v33 + 2) = *((void *)v31 + 2);
                    *(_OWORD *)long long v33 = v34;
                    ++v89;
                  }
                }
              }
            }
          }
        }
        mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v87);
        if (v87[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v87);
        }
        if (v96)
        {
          uint64_t v35 = v94;
          if (v94)
          {
            long long v36 = v95;
            uint64_t v37 = v94;
            if (v95 != v94)
            {
              do
                long long v36 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v36 - 1);
              while (v36 != v35);
              uint64_t v37 = v94;
            }
            unint64_t v95 = v35;
            operator delete(v37);
          }
          v38 = v92;
          if (v92)
          {
            long long v39 = v93;
            uint64_t v40 = v92;
            if (v93 != v92)
            {
              do
              {
                uint64_t v42 = *--v39;
                uint64_t v41 = v42;
                void *v39 = 0;
                if (v42) {
                  MEMORY[0x21667D390](v41, 0x1000C8077774924);
                }
              }
              while (v39 != v38);
              uint64_t v40 = v92;
            }
            uint64_t v93 = v38;
            operator delete(v40);
          }
          if (v88 != (int *)v91) {
            free(v88);
          }
        }
        goto LABEL_46;
      }
      unsigned int v4 = 0;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v72[0] = v4;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v87[0] = &mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id;
      v87[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::NormalSamplingMethodAttrStorage,mlir::mps::NormalSamplingMethod>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail31NormalSamplingMethodAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_24NormalSamplingMethodAttrEJNS2_20NormalSamplingMethodEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v87, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id, v72);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::NormalSamplingMethodAttr::print(mlir::mps::NormalSamplingMethodAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    *unsigned int v5 = 60;
    ++*((void *)v4 + 4);
  }
  int v6 = *(_DWORD *)(*(void *)this + 8);
  char v7 = &byte_211F4AA5D;
  uint64_t v8 = 10;
  if (v6 == 1) {
    char v7 = "box_muller";
  }
  else {
    uint64_t v8 = 0;
  }
  if (v6) {
    BOOL v9 = v6 != 1;
  }
  else {
    BOOL v9 = 0;
  }
  if (v6) {
    size_t v10 = v8;
  }
  else {
    size_t v10 = 7;
  }
  if (v6) {
    long long v11 = v7;
  }
  else {
    long long v11 = "inv_cdf";
  }
  uint64_t v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (void *)*((void *)v12 + 4);
  if (v10 <= *((void *)v12 + 3) - (void)v13)
  {
    if (!v9)
    {
      memcpy(v13, v11, v10);
      *((void *)v12 + 4) += v10;
    }
  }
  else
  {
    llvm::raw_ostream::write(v12, v11, v10);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v15 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v15)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v15 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::PaddingStyleAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v5);
}

uint64_t mlir::mps::PaddingStyleAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v144 = *MEMORY[0x263EF8340];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1)) {
    return 0;
  }
  uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  uint64_t v121 = 0;
  uint64_t v122 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v121))
  {
LABEL_49:
    uint64_t v75 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    LOWORD(v136) = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v126, a1, v75, v134);
    if (v126[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v126);
    }
    if (v133)
    {
      int v76 = __p;
      if (__p)
      {
        uint64_t v77 = v132;
        uint64_t v78 = __p;
        if (v132 != __p)
        {
          do
            uint64_t v77 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v77 - 1);
          while (v77 != v76);
          uint64_t v78 = __p;
        }
        uint64_t v132 = v76;
        operator delete(v78);
      }
      int64_t v79 = v129;
      if (v129)
      {
        int64_t v80 = v130;
        uint64_t v81 = v129;
        if (v130 != v129)
        {
          do
          {
            uint64_t v83 = *--v80;
            uint64_t v82 = v83;
            *int64_t v80 = 0;
            if (v83) {
              MEMORY[0x21667D390](v82, 0x1000C8077774924);
            }
          }
          while (v80 != v79);
          uint64_t v81 = v129;
        }
        int64_t v130 = v79;
        operator delete(v81);
      }
      if (v127 != &v128) {
        free(v127);
      }
    }
    return 0;
  }
  uint64_t v3 = mlir::mps::symbolizePaddingStyle(v121, v122);
  if ((v3 & 0xFF00000000) == 0)
  {
    __int16 v120 = 257;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v134, a1, v2, v119);
    if (v134[0])
    {
      int v123 = 3;
      uint64_t v124 = "expected ";
      uint64_t v125 = 9;
      uint64_t v8 = &v123;
      BOOL v9 = v135;
      if (v136 >= v137)
      {
        unint64_t v84 = v136 + 1;
        if (v135 <= &v123 && &v135[6 * v136] > &v123)
        {
          int64_t v107 = (char *)&v123 - (char *)v135;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v84, 24);
          BOOL v9 = v135;
          uint64_t v8 = (int *)((char *)v135 + v107);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v84, 24);
          uint64_t v8 = &v123;
          BOOL v9 = v135;
        }
      }
      size_t v10 = &v9[6 * v136];
      long long v11 = *(_OWORD *)v8;
      *((void *)v10 + 2) = *((void *)v8 + 2);
      *(_OWORD *)size_t v10 = v11;
      uint64_t v12 = ++v136;
      if (v134[0])
      {
        int v123 = 3;
        uint64_t v124 = "::mlir::mps::PaddingStyle";
        uint64_t v125 = 25;
        long long v13 = &v123;
        long long v14 = v135;
        if (v12 >= v137)
        {
          unint64_t v85 = v12 + 1;
          BOOL v86 = &v135[6 * v12] > &v123;
          if (v135 <= &v123 && v86)
          {
            int64_t v108 = (char *)&v123 - (char *)v135;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v85, 24);
            long long v14 = v135;
            long long v13 = (int *)((char *)v135 + v108);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v85, 24);
            long long v13 = &v123;
            long long v14 = v135;
          }
        }
        uint64_t v15 = &v14[6 * v136];
        long long v16 = *(_OWORD *)v13;
        *((void *)v15 + 2) = *((void *)v13 + 2);
        *(_OWORD *)uint64_t v15 = v16;
        uint64_t v17 = ++v136;
        if (v134[0])
        {
          int v123 = 3;
          uint64_t v124 = " to be one of: ";
          uint64_t v125 = 15;
          long long v18 = &v123;
          long long v19 = v135;
          if (v17 >= v137)
          {
            unint64_t v87 = v17 + 1;
            BOOL v88 = &v135[6 * v17] > &v123;
            if (v135 <= &v123 && v88)
            {
              int64_t v109 = (char *)&v123 - (char *)v135;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v87, 24);
              long long v19 = v135;
              long long v18 = (int *)((char *)v135 + v109);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v87, 24);
              long long v18 = &v123;
              long long v19 = v135;
            }
          }
          uint64_t v20 = &v19[6 * v136];
          long long v21 = *(_OWORD *)v18;
          *((void *)v20 + 2) = *((void *)v18 + 2);
          *(_OWORD *)uint64_t v20 = v21;
          uint64_t v22 = ++v136;
          if (v134[0])
          {
            int v123 = 3;
            uint64_t v124 = "EXPLICIT";
            uint64_t v125 = 8;
            long long v23 = &v123;
            long long v24 = v135;
            if (v22 >= v137)
            {
              unint64_t v89 = v22 + 1;
              BOOL v90 = &v135[6 * v22] > &v123;
              if (v135 <= &v123 && v90)
              {
                int64_t v110 = (char *)&v123 - (char *)v135;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v89, 24);
                long long v24 = v135;
                long long v23 = (int *)((char *)v135 + v110);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v89, 24);
                long long v23 = &v123;
                long long v24 = v135;
              }
            }
            uint64_t v25 = &v24[6 * v136];
            long long v26 = *(_OWORD *)v23;
            *((void *)v25 + 2) = *((void *)v23 + 2);
            *(_OWORD *)uint64_t v25 = v26;
            uint64_t v27 = ++v136;
            if (v134[0])
            {
              int v123 = 3;
              uint64_t v124 = ", ";
              uint64_t v125 = 2;
              long long v28 = &v123;
              long long v29 = v135;
              if (v27 >= v137)
              {
                unint64_t v91 = v27 + 1;
                BOOL v92 = &v135[6 * v27] > &v123;
                if (v135 <= &v123 && v92)
                {
                  int64_t v111 = (char *)&v123 - (char *)v135;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v91, 24);
                  long long v29 = v135;
                  long long v28 = (int *)((char *)v135 + v111);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v91, 24);
                  long long v28 = &v123;
                  long long v29 = v135;
                }
              }
              uint64_t v30 = &v29[6 * v136];
              long long v31 = *(_OWORD *)v28;
              *((void *)v30 + 2) = *((void *)v28 + 2);
              *(_OWORD *)uint64_t v30 = v31;
              uint64_t v32 = ++v136;
              if (v134[0])
              {
                int v123 = 3;
                uint64_t v124 = "TF_VALID";
                uint64_t v125 = 8;
                long long v33 = &v123;
                long long v34 = v135;
                if (v32 >= v137)
                {
                  unint64_t v93 = v32 + 1;
                  BOOL v94 = &v135[6 * v32] > &v123;
                  if (v135 <= &v123 && v94)
                  {
                    int64_t v112 = (char *)&v123 - (char *)v135;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v93, 24);
                    long long v34 = v135;
                    long long v33 = (int *)((char *)v135 + v112);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v93, 24);
                    long long v33 = &v123;
                    long long v34 = v135;
                  }
                }
                uint64_t v35 = &v34[6 * v136];
                long long v36 = *(_OWORD *)v33;
                *((void *)v35 + 2) = *((void *)v33 + 2);
                *(_OWORD *)uint64_t v35 = v36;
                uint64_t v37 = ++v136;
                if (v134[0])
                {
                  int v123 = 3;
                  uint64_t v124 = ", ";
                  uint64_t v125 = 2;
                  v38 = &v123;
                  long long v39 = v135;
                  if (v37 >= v137)
                  {
                    unint64_t v95 = v37 + 1;
                    BOOL v96 = &v135[6 * v37] > &v123;
                    if (v135 <= &v123 && v96)
                    {
                      int64_t v113 = (char *)&v123 - (char *)v135;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v95, 24);
                      long long v39 = v135;
                      v38 = (int *)((char *)v135 + v113);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v95, 24);
                      v38 = &v123;
                      long long v39 = v135;
                    }
                  }
                  uint64_t v40 = &v39[6 * v136];
                  long long v41 = *(_OWORD *)v38;
                  *((void *)v40 + 2) = *((void *)v38 + 2);
                  *(_OWORD *)uint64_t v40 = v41;
                  uint64_t v42 = ++v136;
                  if (v134[0])
                  {
                    int v123 = 3;
                    uint64_t v124 = "TF_SAME";
                    uint64_t v125 = 7;
                    uint64_t v43 = &v123;
                    long long v44 = v135;
                    if (v42 >= v137)
                    {
                      unint64_t v97 = v42 + 1;
                      BOOL v98 = &v135[6 * v42] > &v123;
                      if (v135 <= &v123 && v98)
                      {
                        int64_t v114 = (char *)&v123 - (char *)v135;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v97, 24);
                        long long v44 = v135;
                        uint64_t v43 = (int *)((char *)v135 + v114);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v97, 24);
                        uint64_t v43 = &v123;
                        long long v44 = v135;
                      }
                    }
                    v45 = &v44[6 * v136];
                    long long v46 = *(_OWORD *)v43;
                    *((void *)v45 + 2) = *((void *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    uint64_t v47 = ++v136;
                    if (v134[0])
                    {
                      int v123 = 3;
                      uint64_t v124 = ", ";
                      uint64_t v125 = 2;
                      v48 = &v123;
                      uint64_t v49 = v135;
                      if (v47 >= v137)
                      {
                        unint64_t v99 = v47 + 1;
                        BOOL v100 = &v135[6 * v47] > &v123;
                        if (v135 <= &v123 && v100)
                        {
                          int64_t v115 = (char *)&v123 - (char *)v135;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v99, 24);
                          uint64_t v49 = v135;
                          v48 = (int *)((char *)v135 + v115);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v99, 24);
                          v48 = &v123;
                          uint64_t v49 = v135;
                        }
                      }
                      uint64_t v50 = &v49[6 * v136];
                      long long v51 = *(_OWORD *)v48;
                      *((void *)v50 + 2) = *((void *)v48 + 2);
                      *(_OWORD *)uint64_t v50 = v51;
                      uint64_t v52 = ++v136;
                      if (v134[0])
                      {
                        int v123 = 3;
                        uint64_t v124 = "EXPLICIT_OFFSET";
                        uint64_t v125 = 15;
                        unsigned int v53 = &v123;
                        uint64_t v54 = v135;
                        if (v52 >= v137)
                        {
                          unint64_t v101 = v52 + 1;
                          BOOL v102 = &v135[6 * v52] > &v123;
                          if (v135 <= &v123 && v102)
                          {
                            int64_t v116 = (char *)&v123 - (char *)v135;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v101, 24);
                            uint64_t v54 = v135;
                            unsigned int v53 = (int *)((char *)v135 + v116);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v101, 24);
                            unsigned int v53 = &v123;
                            uint64_t v54 = v135;
                          }
                        }
                        unint64_t v55 = &v54[6 * v136];
                        long long v56 = *(_OWORD *)v53;
                        *((void *)v55 + 2) = *((void *)v53 + 2);
                        *(_OWORD *)unint64_t v55 = v56;
                        uint64_t v57 = ++v136;
                        if (v134[0])
                        {
                          int v123 = 3;
                          uint64_t v124 = ", ";
                          uint64_t v125 = 2;
                          unint64_t v58 = &v123;
                          BOOL v59 = v135;
                          if (v57 >= v137)
                          {
                            unint64_t v103 = v57 + 1;
                            BOOL v104 = &v135[6 * v57] > &v123;
                            if (v135 <= &v123 && v104)
                            {
                              int64_t v117 = (char *)&v123 - (char *)v135;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v103, 24);
                              BOOL v59 = v135;
                              unint64_t v58 = (int *)((char *)v135 + v117);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v103, 24);
                              unint64_t v58 = &v123;
                              BOOL v59 = v135;
                            }
                          }
                          unint64_t v60 = &v59[6 * v136];
                          long long v61 = *(_OWORD *)v58;
                          *((void *)v60 + 2) = *((void *)v58 + 2);
                          *(_OWORD *)unint64_t v60 = v61;
                          uint64_t v62 = ++v136;
                          if (v134[0])
                          {
                            int v123 = 3;
                            uint64_t v124 = "ONNX_SAME_LOWER";
                            uint64_t v125 = 15;
                            BOOL v63 = &v123;
                            unint64_t v64 = v135;
                            if (v62 >= v137)
                            {
                              unint64_t v105 = v62 + 1;
                              BOOL v106 = &v135[6 * v62] > &v123;
                              if (v135 <= &v123 && v106)
                              {
                                int64_t v118 = (char *)&v123 - (char *)v135;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v105, 24);
                                unint64_t v64 = v135;
                                BOOL v63 = (int *)((char *)v135 + v118);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v105, 24);
                                BOOL v63 = &v123;
                                unint64_t v64 = v135;
                              }
                            }
                            BOOL v65 = &v64[6 * v136];
                            long long v66 = *(_OWORD *)v63;
                            *((void *)v65 + 2) = *((void *)v63 + 2);
                            *(_OWORD *)BOOL v65 = v66;
                            ++v136;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v134);
    if (v134[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v134);
    }
    if (v143)
    {
      int64_t v67 = v141;
      if (v141)
      {
        int64_t v68 = v142;
        int64_t v69 = v141;
        if (v142 != v141)
        {
          do
            int64_t v68 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v68 - 1);
          while (v68 != v67);
          int64_t v69 = v141;
        }
        BOOL v142 = v67;
        operator delete(v69);
      }
      int64_t v70 = v139;
      if (v139)
      {
        int64_t v71 = v140;
        uint64_t v72 = v139;
        if (v140 != v139)
        {
          do
          {
            uint64_t v74 = *--v71;
            uint64_t v73 = v74;
            *int64_t v71 = 0;
            if (v74) {
              MEMORY[0x21667D390](v73, 0x1000C8077774924);
            }
          }
          while (v71 != v70);
          uint64_t v72 = v139;
        }
        BOOL v140 = v70;
        operator delete(v72);
      }
      if (v135 != (int *)v138) {
        free(v135);
      }
    }
    goto LABEL_49;
  }
  unsigned int v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v119[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v134[0] = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
    v134[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v134, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, v119);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::PaddingStyleAttr::print(mlir::mps::PaddingStyleAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6 > 4)
    {
LABEL_6:
      size_t v9 = 0;
      uint64_t v8 = &byte_211F4AA5D;
      char v7 = 1;
      goto LABEL_11;
    }
  }
  else
  {
    *unsigned int v5 = 60;
    ++*((void *)v4 + 4);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
  }
  char v7 = 0;
  uint64_t v8 = "EXPLICIT";
  size_t v9 = 8;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      char v7 = 0;
      uint64_t v8 = "TF_VALID";
      size_t v9 = 8;
      break;
    case 2u:
      char v7 = 0;
      uint64_t v8 = "TF_SAME";
      size_t v9 = 7;
      break;
    case 3u:
      char v7 = 0;
      uint64_t v8 = "EXPLICIT_OFFSET";
      goto LABEL_10;
    case 4u:
      char v7 = 0;
      uint64_t v8 = "ONNX_SAME_LOWER";
LABEL_10:
      size_t v9 = 15;
      break;
    default:
      goto LABEL_6;
  }
LABEL_11:
  size_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v11 = (void *)*((void *)v10 + 4);
  if (v9 <= *((void *)v10 + 3) - (void)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((void *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    *long long v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::PoolIndicesModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::PoolIndicesModeAttrStorage,mlir::mps::PoolIndicesMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail26PoolIndicesModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_19PoolIndicesModeAttrEJNS2_15PoolIndicesModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::PoolIndicesModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v192 = *MEMORY[0x263EF8340];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1)) {
    return 0;
  }
  uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  BOOL v169 = 0;
  uint64_t v170 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v169))
  {
LABEL_61:
    uint64_t v105 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    LOWORD(v184) = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v174, a1, v105, v182);
    if (v174[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v174);
    }
    if (v181)
    {
      BOOL v106 = __p;
      if (__p)
      {
        int64_t v107 = v180;
        int64_t v108 = __p;
        if (v180 != __p)
        {
          do
            int64_t v107 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v107 - 1);
          while (v107 != v106);
          int64_t v108 = __p;
        }
        unint64_t v180 = v106;
        operator delete(v108);
      }
      int64_t v109 = v177;
      if (v177)
      {
        int64_t v110 = v178;
        int64_t v111 = v177;
        if (v178 != v177)
        {
          do
          {
            uint64_t v113 = *--v110;
            uint64_t v112 = v113;
            *int64_t v110 = 0;
            if (v113) {
              MEMORY[0x21667D390](v112, 0x1000C8077774924);
            }
          }
          while (v110 != v109);
          int64_t v111 = v177;
        }
        BOOL v178 = v109;
        operator delete(v111);
      }
      if (v175 != &v176) {
        free(v175);
      }
    }
    return 0;
  }
  uint64_t v3 = mlir::mps::symbolizePoolIndicesMode(v169, v170);
  if ((v3 & 0xFF00000000) == 0)
  {
    __int16 v168 = 257;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v182, a1, v2, v167);
    if (v182[0])
    {
      int v171 = 3;
      BOOL v172 = "expected ";
      uint64_t v173 = 9;
      uint64_t v8 = &v171;
      size_t v9 = v183;
      if (v184 >= v185)
      {
        unint64_t v114 = v184 + 1;
        if (v183 <= &v171 && &v183[6 * v184] > &v171)
        {
          int64_t v147 = (char *)&v171 - (char *)v183;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v114, 24);
          size_t v9 = v183;
          uint64_t v8 = (int *)((char *)v183 + v147);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v114, 24);
          uint64_t v8 = &v171;
          size_t v9 = v183;
        }
      }
      size_t v10 = &v9[6 * v184];
      long long v11 = *(_OWORD *)v8;
      *((void *)v10 + 2) = *((void *)v8 + 2);
      *(_OWORD *)size_t v10 = v11;
      uint64_t v12 = ++v184;
      if (v182[0])
      {
        int v171 = 3;
        BOOL v172 = "::mlir::mps::PoolIndicesMode";
        uint64_t v173 = 28;
        long long v13 = &v171;
        long long v14 = v183;
        if (v12 >= v185)
        {
          unint64_t v115 = v12 + 1;
          BOOL v116 = &v183[6 * v12] > &v171;
          if (v183 <= &v171 && v116)
          {
            int64_t v150 = (char *)&v171 - (char *)v183;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v115, 24);
            long long v14 = v183;
            long long v13 = (int *)((char *)v183 + v150);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v115, 24);
            long long v13 = &v171;
            long long v14 = v183;
          }
        }
        uint64_t v15 = &v14[6 * v184];
        long long v16 = *(_OWORD *)v13;
        *((void *)v15 + 2) = *((void *)v13 + 2);
        *(_OWORD *)uint64_t v15 = v16;
        uint64_t v17 = ++v184;
        if (v182[0])
        {
          int v171 = 3;
          BOOL v172 = " to be one of: ";
          uint64_t v173 = 15;
          long long v18 = &v171;
          long long v19 = v183;
          if (v17 >= v185)
          {
            unint64_t v117 = v17 + 1;
            BOOL v118 = &v183[6 * v17] > &v171;
            if (v183 <= &v171 && v118)
            {
              int64_t v151 = (char *)&v171 - (char *)v183;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v117, 24);
              long long v19 = v183;
              long long v18 = (int *)((char *)v183 + v151);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v117, 24);
              long long v18 = &v171;
              long long v19 = v183;
            }
          }
          uint64_t v20 = &v19[6 * v184];
          long long v21 = *(_OWORD *)v18;
          *((void *)v20 + 2) = *((void *)v18 + 2);
          *(_OWORD *)uint64_t v20 = v21;
          uint64_t v22 = ++v184;
          if (v182[0])
          {
            int v171 = 3;
            BOOL v172 = "Global_Flatten1D";
            uint64_t v173 = 16;
            long long v23 = &v171;
            long long v24 = v183;
            if (v22 >= v185)
            {
              unint64_t v119 = v22 + 1;
              BOOL v120 = &v183[6 * v22] > &v171;
              if (v183 <= &v171 && v120)
              {
                int64_t v152 = (char *)&v171 - (char *)v183;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v119, 24);
                long long v24 = v183;
                long long v23 = (int *)((char *)v183 + v152);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v119, 24);
                long long v23 = &v171;
                long long v24 = v183;
              }
            }
            uint64_t v25 = &v24[6 * v184];
            long long v26 = *(_OWORD *)v23;
            *((void *)v25 + 2) = *((void *)v23 + 2);
            *(_OWORD *)uint64_t v25 = v26;
            uint64_t v27 = ++v184;
            if (v182[0])
            {
              int v171 = 3;
              BOOL v172 = ", ";
              uint64_t v173 = 2;
              long long v28 = &v171;
              long long v29 = v183;
              if (v27 >= v185)
              {
                unint64_t v121 = v27 + 1;
                BOOL v122 = &v183[6 * v27] > &v171;
                if (v183 <= &v171 && v122)
                {
                  int64_t v153 = (char *)&v171 - (char *)v183;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v121, 24);
                  long long v29 = v183;
                  long long v28 = (int *)((char *)v183 + v153);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v121, 24);
                  long long v28 = &v171;
                  long long v29 = v183;
                }
              }
              uint64_t v30 = &v29[6 * v184];
              long long v31 = *(_OWORD *)v28;
              *((void *)v30 + 2) = *((void *)v28 + 2);
              *(_OWORD *)uint64_t v30 = v31;
              uint64_t v32 = ++v184;
              if (v182[0])
              {
                int v171 = 3;
                BOOL v172 = "Global_Flatten2D";
                uint64_t v173 = 16;
                long long v33 = &v171;
                long long v34 = v183;
                if (v32 >= v185)
                {
                  unint64_t v123 = v32 + 1;
                  BOOL v124 = &v183[6 * v32] > &v171;
                  if (v183 <= &v171 && v124)
                  {
                    int64_t v154 = (char *)&v171 - (char *)v183;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v123, 24);
                    long long v34 = v183;
                    long long v33 = (int *)((char *)v183 + v154);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v123, 24);
                    long long v33 = &v171;
                    long long v34 = v183;
                  }
                }
                uint64_t v35 = &v34[6 * v184];
                long long v36 = *(_OWORD *)v33;
                *((void *)v35 + 2) = *((void *)v33 + 2);
                *(_OWORD *)uint64_t v35 = v36;
                uint64_t v37 = ++v184;
                if (v182[0])
                {
                  int v171 = 3;
                  BOOL v172 = ", ";
                  uint64_t v173 = 2;
                  v38 = &v171;
                  long long v39 = v183;
                  if (v37 >= v185)
                  {
                    unint64_t v125 = v37 + 1;
                    BOOL v126 = &v183[6 * v37] > &v171;
                    if (v183 <= &v171 && v126)
                    {
                      int64_t v155 = (char *)&v171 - (char *)v183;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v125, 24);
                      long long v39 = v183;
                      v38 = (int *)((char *)v183 + v155);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v125, 24);
                      v38 = &v171;
                      long long v39 = v183;
                    }
                  }
                  uint64_t v40 = &v39[6 * v184];
                  long long v41 = *(_OWORD *)v38;
                  *((void *)v40 + 2) = *((void *)v38 + 2);
                  *(_OWORD *)uint64_t v40 = v41;
                  uint64_t v42 = ++v184;
                  if (v182[0])
                  {
                    int v171 = 3;
                    BOOL v172 = "Global_Flatten3D";
                    uint64_t v173 = 16;
                    uint64_t v43 = &v171;
                    long long v44 = v183;
                    if (v42 >= v185)
                    {
                      unint64_t v127 = v42 + 1;
                      BOOL v128 = &v183[6 * v42] > &v171;
                      if (v183 <= &v171 && v128)
                      {
                        int64_t v156 = (char *)&v171 - (char *)v183;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v127, 24);
                        long long v44 = v183;
                        uint64_t v43 = (int *)((char *)v183 + v156);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v127, 24);
                        uint64_t v43 = &v171;
                        long long v44 = v183;
                      }
                    }
                    v45 = &v44[6 * v184];
                    long long v46 = *(_OWORD *)v43;
                    *((void *)v45 + 2) = *((void *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    uint64_t v47 = ++v184;
                    if (v182[0])
                    {
                      int v171 = 3;
                      BOOL v172 = ", ";
                      uint64_t v173 = 2;
                      v48 = &v171;
                      uint64_t v49 = v183;
                      if (v47 >= v185)
                      {
                        unint64_t v129 = v47 + 1;
                        BOOL v130 = &v183[6 * v47] > &v171;
                        if (v183 <= &v171 && v130)
                        {
                          int64_t v157 = (char *)&v171 - (char *)v183;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v129, 24);
                          uint64_t v49 = v183;
                          v48 = (int *)((char *)v183 + v157);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v129, 24);
                          v48 = &v171;
                          uint64_t v49 = v183;
                        }
                      }
                      uint64_t v50 = &v49[6 * v184];
                      long long v51 = *(_OWORD *)v48;
                      *((void *)v50 + 2) = *((void *)v48 + 2);
                      *(_OWORD *)uint64_t v50 = v51;
                      uint64_t v52 = ++v184;
                      if (v182[0])
                      {
                        int v171 = 3;
                        BOOL v172 = "Global_Flatten4D";
                        uint64_t v173 = 16;
                        unsigned int v53 = &v171;
                        uint64_t v54 = v183;
                        if (v52 >= v185)
                        {
                          unint64_t v131 = v52 + 1;
                          BOOL v132 = &v183[6 * v52] > &v171;
                          if (v183 <= &v171 && v132)
                          {
                            int64_t v158 = (char *)&v171 - (char *)v183;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v131, 24);
                            uint64_t v54 = v183;
                            unsigned int v53 = (int *)((char *)v183 + v158);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v131, 24);
                            unsigned int v53 = &v171;
                            uint64_t v54 = v183;
                          }
                        }
                        unint64_t v55 = &v54[6 * v184];
                        long long v56 = *(_OWORD *)v53;
                        *((void *)v55 + 2) = *((void *)v53 + 2);
                        *(_OWORD *)unint64_t v55 = v56;
                        uint64_t v57 = ++v184;
                        if (v182[0])
                        {
                          int v171 = 3;
                          BOOL v172 = ", ";
                          uint64_t v173 = 2;
                          unint64_t v58 = &v171;
                          BOOL v59 = v183;
                          if (v57 >= v185)
                          {
                            unint64_t v133 = v57 + 1;
                            BOOL v134 = &v183[6 * v57] > &v171;
                            if (v183 <= &v171 && v134)
                            {
                              int64_t v159 = (char *)&v171 - (char *)v183;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v133, 24);
                              BOOL v59 = v183;
                              unint64_t v58 = (int *)((char *)v183 + v159);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v133, 24);
                              unint64_t v58 = &v171;
                              BOOL v59 = v183;
                            }
                          }
                          unint64_t v60 = &v59[6 * v184];
                          long long v61 = *(_OWORD *)v58;
                          *((void *)v60 + 2) = *((void *)v58 + 2);
                          *(_OWORD *)unint64_t v60 = v61;
                          uint64_t v62 = ++v184;
                          if (v182[0])
                          {
                            int v171 = 3;
                            BOOL v172 = "Local_Flatten1D";
                            uint64_t v173 = 15;
                            BOOL v63 = &v171;
                            unint64_t v64 = v183;
                            if (v62 >= v185)
                            {
                              unint64_t v135 = v62 + 1;
                              BOOL v136 = &v183[6 * v62] > &v171;
                              if (v183 <= &v171 && v136)
                              {
                                int64_t v160 = (char *)&v171 - (char *)v183;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v135, 24);
                                unint64_t v64 = v183;
                                BOOL v63 = (int *)((char *)v183 + v160);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v135, 24);
                                BOOL v63 = &v171;
                                unint64_t v64 = v183;
                              }
                            }
                            BOOL v65 = &v64[6 * v184];
                            long long v66 = *(_OWORD *)v63;
                            *((void *)v65 + 2) = *((void *)v63 + 2);
                            *(_OWORD *)BOOL v65 = v66;
                            uint64_t v67 = ++v184;
                            if (v182[0])
                            {
                              int v171 = 3;
                              BOOL v172 = ", ";
                              uint64_t v173 = 2;
                              int64_t v68 = &v171;
                              int64_t v69 = v183;
                              if (v67 >= v185)
                              {
                                unint64_t v137 = v67 + 1;
                                BOOL v138 = &v183[6 * v67] > &v171;
                                if (v183 <= &v171 && v138)
                                {
                                  int64_t v161 = (char *)&v171 - (char *)v183;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v137, 24);
                                  int64_t v69 = v183;
                                  int64_t v68 = (int *)((char *)v183 + v161);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v137, 24);
                                  int64_t v68 = &v171;
                                  int64_t v69 = v183;
                                }
                              }
                              int64_t v70 = &v69[6 * v184];
                              long long v71 = *(_OWORD *)v68;
                              *((void *)v70 + 2) = *((void *)v68 + 2);
                              *(_OWORD *)int64_t v70 = v71;
                              uint64_t v72 = ++v184;
                              if (v182[0])
                              {
                                int v171 = 3;
                                BOOL v172 = "Local_Flatten2D";
                                uint64_t v173 = 15;
                                uint64_t v73 = &v171;
                                uint64_t v74 = v183;
                                if (v72 >= v185)
                                {
                                  unint64_t v139 = v72 + 1;
                                  BOOL v140 = &v183[6 * v72] > &v171;
                                  if (v183 <= &v171 && v140)
                                  {
                                    int64_t v162 = (char *)&v171 - (char *)v183;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v139, 24);
                                    uint64_t v74 = v183;
                                    uint64_t v73 = (int *)((char *)v183 + v162);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v139, 24);
                                    uint64_t v73 = &v171;
                                    uint64_t v74 = v183;
                                  }
                                }
                                uint64_t v75 = &v74[6 * v184];
                                long long v76 = *(_OWORD *)v73;
                                *((void *)v75 + 2) = *((void *)v73 + 2);
                                *(_OWORD *)uint64_t v75 = v76;
                                uint64_t v77 = ++v184;
                                if (v182[0])
                                {
                                  int v171 = 3;
                                  BOOL v172 = ", ";
                                  uint64_t v173 = 2;
                                  uint64_t v78 = &v171;
                                  int64_t v79 = v183;
                                  if (v77 >= v185)
                                  {
                                    unint64_t v141 = v77 + 1;
                                    BOOL v142 = &v183[6 * v77] > &v171;
                                    if (v183 <= &v171 && v142)
                                    {
                                      int64_t v163 = (char *)&v171 - (char *)v183;
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v141, 24);
                                      int64_t v79 = v183;
                                      uint64_t v78 = (int *)((char *)v183 + v163);
                                    }
                                    else
                                    {
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v141, 24);
                                      uint64_t v78 = &v171;
                                      int64_t v79 = v183;
                                    }
                                  }
                                  int64_t v80 = &v79[6 * v184];
                                  long long v81 = *(_OWORD *)v78;
                                  *((void *)v80 + 2) = *((void *)v78 + 2);
                                  *(_OWORD *)int64_t v80 = v81;
                                  uint64_t v82 = ++v184;
                                  if (v182[0])
                                  {
                                    int v171 = 3;
                                    BOOL v172 = "Local_Flatten3D";
                                    uint64_t v173 = 15;
                                    uint64_t v83 = &v171;
                                    unint64_t v84 = v183;
                                    if (v82 >= v185)
                                    {
                                      unint64_t v143 = v82 + 1;
                                      BOOL v144 = &v183[6 * v82] > &v171;
                                      if (v183 <= &v171 && v144)
                                      {
                                        int64_t v164 = (char *)&v171 - (char *)v183;
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v143, 24);
                                        unint64_t v84 = v183;
                                        uint64_t v83 = (int *)((char *)v183 + v164);
                                      }
                                      else
                                      {
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v143, 24);
                                        uint64_t v83 = &v171;
                                        unint64_t v84 = v183;
                                      }
                                    }
                                    unint64_t v85 = &v84[6 * v184];
                                    long long v86 = *(_OWORD *)v83;
                                    *((void *)v85 + 2) = *((void *)v83 + 2);
                                    *(_OWORD *)unint64_t v85 = v86;
                                    uint64_t v87 = ++v184;
                                    if (v182[0])
                                    {
                                      int v171 = 3;
                                      BOOL v172 = ", ";
                                      uint64_t v173 = 2;
                                      BOOL v88 = &v171;
                                      unint64_t v89 = v183;
                                      if (v87 >= v185)
                                      {
                                        unint64_t v145 = v87 + 1;
                                        BOOL v146 = &v183[6 * v87] > &v171;
                                        if (v183 <= &v171 && v146)
                                        {
                                          int64_t v165 = (char *)&v171 - (char *)v183;
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v145, 24);
                                          unint64_t v89 = v183;
                                          BOOL v88 = (int *)((char *)v183 + v165);
                                        }
                                        else
                                        {
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v145, 24);
                                          BOOL v88 = &v171;
                                          unint64_t v89 = v183;
                                        }
                                      }
                                      BOOL v90 = &v89[6 * v184];
                                      long long v91 = *(_OWORD *)v88;
                                      *((void *)v90 + 2) = *((void *)v88 + 2);
                                      *(_OWORD *)BOOL v90 = v91;
                                      uint64_t v92 = ++v184;
                                      if (v182[0])
                                      {
                                        int v171 = 3;
                                        BOOL v172 = "Local_Flatten4D";
                                        uint64_t v173 = 15;
                                        unint64_t v93 = &v171;
                                        BOOL v94 = v183;
                                        if (v92 >= v185)
                                        {
                                          unint64_t v148 = v92 + 1;
                                          BOOL v149 = &v183[6 * v92] > &v171;
                                          if (v183 <= &v171 && v149)
                                          {
                                            int64_t v166 = (char *)&v171 - (char *)v183;
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v148, 24);
                                            BOOL v94 = v183;
                                            unint64_t v93 = (int *)((char *)v183 + v166);
                                          }
                                          else
                                          {
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v148, 24);
                                            unint64_t v93 = &v171;
                                            BOOL v94 = v183;
                                          }
                                        }
                                        unint64_t v95 = &v94[6 * v184];
                                        long long v96 = *(_OWORD *)v93;
                                        *((void *)v95 + 2) = *((void *)v93 + 2);
                                        *(_OWORD *)unint64_t v95 = v96;
                                        ++v184;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v182);
    if (v182[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v182);
    }
    if (v191)
    {
      unint64_t v97 = v189;
      if (v189)
      {
        BOOL v98 = v190;
        unint64_t v99 = v189;
        if (v190 != v189)
        {
          do
            BOOL v98 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v98 - 1);
          while (v98 != v97);
          unint64_t v99 = v189;
        }
        int64_t v190 = v97;
        operator delete(v99);
      }
      BOOL v100 = v187;
      if (v187)
      {
        unint64_t v101 = v188;
        BOOL v102 = v187;
        if (v188 != v187)
        {
          do
          {
            uint64_t v104 = *--v101;
            uint64_t v103 = v104;
            *unint64_t v101 = 0;
            if (v104) {
              MEMORY[0x21667D390](v103, 0x1000C8077774924);
            }
          }
          while (v101 != v100);
          BOOL v102 = v187;
        }
        int64_t v188 = v100;
        operator delete(v102);
      }
      if (v183 != (int *)v186) {
        free(v183);
      }
    }
    goto LABEL_61;
  }
  unsigned int v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v167[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v182[0] = &mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id;
    v182[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::PoolIndicesModeAttrStorage,mlir::mps::PoolIndicesMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail26PoolIndicesModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_19PoolIndicesModeAttrEJNS2_15PoolIndicesModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v182, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id, v167);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::PoolIndicesModeAttr::print(mlir::mps::PoolIndicesModeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6 > 7)
    {
LABEL_6:
      size_t v9 = 0;
      uint64_t v8 = &byte_211F4AA5D;
      char v7 = 1;
      goto LABEL_14;
    }
  }
  else
  {
    *unsigned int v5 = 60;
    ++*((void *)v4 + 4);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
  }
  char v7 = 0;
  uint64_t v8 = "Global_Flatten1D";
  size_t v9 = 16;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      char v7 = 0;
      uint64_t v8 = "Global_Flatten2D";
      size_t v9 = 16;
      break;
    case 2u:
      char v7 = 0;
      uint64_t v8 = "Global_Flatten3D";
      size_t v9 = 16;
      break;
    case 3u:
      char v7 = 0;
      uint64_t v8 = "Global_Flatten4D";
      size_t v9 = 16;
      break;
    case 4u:
      char v7 = 0;
      uint64_t v8 = "Local_Flatten1D";
      goto LABEL_13;
    case 5u:
      char v7 = 0;
      uint64_t v8 = "Local_Flatten2D";
      goto LABEL_13;
    case 6u:
      char v7 = 0;
      uint64_t v8 = "Local_Flatten3D";
      goto LABEL_13;
    case 7u:
      char v7 = 0;
      uint64_t v8 = "Local_Flatten4D";
LABEL_13:
      size_t v9 = 15;
      break;
    default:
      goto LABEL_6;
  }
LABEL_14:
  size_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v11 = (void *)*((void *)v10 + 4);
  if (v9 <= *((void *)v10 + 3) - (void)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((void *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    *long long v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::RNNActivationAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v5);
}

uint64_t mlir::mps::RNNActivationAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v160 = *MEMORY[0x263EF8340];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1)) {
    return 0;
  }
  uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  unint64_t v137 = 0;
  uint64_t v138 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v137))
  {
LABEL_53:
    uint64_t v85 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    LOWORD(v152) = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v142, a1, v85, v150);
    if (v142[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v142);
    }
    if (v149)
    {
      long long v86 = __p;
      if (__p)
      {
        uint64_t v87 = v148;
        BOOL v88 = __p;
        if (v148 != __p)
        {
          do
            uint64_t v87 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v87 - 1);
          while (v87 != v86);
          BOOL v88 = __p;
        }
        unint64_t v148 = v86;
        operator delete(v88);
      }
      unint64_t v89 = v145;
      if (v145)
      {
        BOOL v90 = v146;
        long long v91 = v145;
        if (v146 != v145)
        {
          do
          {
            uint64_t v93 = *--v90;
            uint64_t v92 = v93;
            void *v90 = 0;
            if (v93) {
              MEMORY[0x21667D390](v92, 0x1000C8077774924);
            }
          }
          while (v90 != v89);
          long long v91 = v145;
        }
        BOOL v146 = v89;
        operator delete(v91);
      }
      if (v143 != &v144) {
        free(v143);
      }
    }
    return 0;
  }
  uint64_t v3 = mlir::mps::symbolizeRNNActivation(v137, v138);
  if ((v3 & 0xFF00000000) == 0)
  {
    __int16 v136 = 257;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v150, a1, v2, v135);
    if (v150[0])
    {
      int v139 = 3;
      BOOL v140 = "expected ";
      uint64_t v141 = 9;
      uint64_t v8 = &v139;
      size_t v9 = v151;
      if (v152 >= v153)
      {
        unint64_t v94 = v152 + 1;
        if (v151 <= &v139 && &v151[6 * v152] > &v139)
        {
          int64_t v121 = (char *)&v139 - (char *)v151;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          size_t v9 = v151;
          uint64_t v8 = (int *)((char *)v151 + v121);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          uint64_t v8 = &v139;
          size_t v9 = v151;
        }
      }
      size_t v10 = &v9[6 * v152];
      long long v11 = *(_OWORD *)v8;
      *((void *)v10 + 2) = *((void *)v8 + 2);
      *(_OWORD *)size_t v10 = v11;
      uint64_t v12 = ++v152;
      if (v150[0])
      {
        int v139 = 3;
        BOOL v140 = "::mlir::mps::RNNActivation";
        uint64_t v141 = 26;
        long long v13 = &v139;
        long long v14 = v151;
        if (v12 >= v153)
        {
          unint64_t v95 = v12 + 1;
          BOOL v96 = &v151[6 * v12] > &v139;
          if (v151 <= &v139 && v96)
          {
            int64_t v122 = (char *)&v139 - (char *)v151;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            long long v14 = v151;
            long long v13 = (int *)((char *)v151 + v122);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            long long v13 = &v139;
            long long v14 = v151;
          }
        }
        uint64_t v15 = &v14[6 * v152];
        long long v16 = *(_OWORD *)v13;
        *((void *)v15 + 2) = *((void *)v13 + 2);
        *(_OWORD *)uint64_t v15 = v16;
        uint64_t v17 = ++v152;
        if (v150[0])
        {
          int v139 = 3;
          BOOL v140 = " to be one of: ";
          uint64_t v141 = 15;
          long long v18 = &v139;
          long long v19 = v151;
          if (v17 >= v153)
          {
            unint64_t v97 = v17 + 1;
            BOOL v98 = &v151[6 * v17] > &v139;
            if (v151 <= &v139 && v98)
            {
              int64_t v123 = (char *)&v139 - (char *)v151;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              long long v19 = v151;
              long long v18 = (int *)((char *)v151 + v123);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              long long v18 = &v139;
              long long v19 = v151;
            }
          }
          uint64_t v20 = &v19[6 * v152];
          long long v21 = *(_OWORD *)v18;
          *((void *)v20 + 2) = *((void *)v18 + 2);
          *(_OWORD *)uint64_t v20 = v21;
          uint64_t v22 = ++v152;
          if (v150[0])
          {
            int v139 = 3;
            BOOL v140 = "none";
            uint64_t v141 = 4;
            long long v23 = &v139;
            long long v24 = v151;
            if (v22 >= v153)
            {
              unint64_t v99 = v22 + 1;
              BOOL v100 = &v151[6 * v22] > &v139;
              if (v151 <= &v139 && v100)
              {
                int64_t v124 = (char *)&v139 - (char *)v151;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                long long v24 = v151;
                long long v23 = (int *)((char *)v151 + v124);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                long long v23 = &v139;
                long long v24 = v151;
              }
            }
            uint64_t v25 = &v24[6 * v152];
            long long v26 = *(_OWORD *)v23;
            *((void *)v25 + 2) = *((void *)v23 + 2);
            *(_OWORD *)uint64_t v25 = v26;
            uint64_t v27 = ++v152;
            if (v150[0])
            {
              int v139 = 3;
              BOOL v140 = ", ";
              uint64_t v141 = 2;
              long long v28 = &v139;
              long long v29 = v151;
              if (v27 >= v153)
              {
                unint64_t v101 = v27 + 1;
                BOOL v102 = &v151[6 * v27] > &v139;
                if (v151 <= &v139 && v102)
                {
                  int64_t v125 = (char *)&v139 - (char *)v151;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  long long v29 = v151;
                  long long v28 = (int *)((char *)v151 + v125);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  long long v28 = &v139;
                  long long v29 = v151;
                }
              }
              uint64_t v30 = &v29[6 * v152];
              long long v31 = *(_OWORD *)v28;
              *((void *)v30 + 2) = *((void *)v28 + 2);
              *(_OWORD *)uint64_t v30 = v31;
              uint64_t v32 = ++v152;
              if (v150[0])
              {
                int v139 = 3;
                BOOL v140 = "relu";
                uint64_t v141 = 4;
                long long v33 = &v139;
                long long v34 = v151;
                if (v32 >= v153)
                {
                  unint64_t v103 = v32 + 1;
                  BOOL v104 = &v151[6 * v32] > &v139;
                  if (v151 <= &v139 && v104)
                  {
                    int64_t v126 = (char *)&v139 - (char *)v151;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    long long v34 = v151;
                    long long v33 = (int *)((char *)v151 + v126);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    long long v33 = &v139;
                    long long v34 = v151;
                  }
                }
                uint64_t v35 = &v34[6 * v152];
                long long v36 = *(_OWORD *)v33;
                *((void *)v35 + 2) = *((void *)v33 + 2);
                *(_OWORD *)uint64_t v35 = v36;
                uint64_t v37 = ++v152;
                if (v150[0])
                {
                  int v139 = 3;
                  BOOL v140 = ", ";
                  uint64_t v141 = 2;
                  v38 = &v139;
                  long long v39 = v151;
                  if (v37 >= v153)
                  {
                    unint64_t v105 = v37 + 1;
                    BOOL v106 = &v151[6 * v37] > &v139;
                    if (v151 <= &v139 && v106)
                    {
                      int64_t v127 = (char *)&v139 - (char *)v151;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      long long v39 = v151;
                      v38 = (int *)((char *)v151 + v127);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      v38 = &v139;
                      long long v39 = v151;
                    }
                  }
                  uint64_t v40 = &v39[6 * v152];
                  long long v41 = *(_OWORD *)v38;
                  *((void *)v40 + 2) = *((void *)v38 + 2);
                  *(_OWORD *)uint64_t v40 = v41;
                  uint64_t v42 = ++v152;
                  if (v150[0])
                  {
                    int v139 = 3;
                    BOOL v140 = "tanh";
                    uint64_t v141 = 4;
                    uint64_t v43 = &v139;
                    long long v44 = v151;
                    if (v42 >= v153)
                    {
                      unint64_t v107 = v42 + 1;
                      BOOL v108 = &v151[6 * v42] > &v139;
                      if (v151 <= &v139 && v108)
                      {
                        int64_t v128 = (char *)&v139 - (char *)v151;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        long long v44 = v151;
                        uint64_t v43 = (int *)((char *)v151 + v128);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        uint64_t v43 = &v139;
                        long long v44 = v151;
                      }
                    }
                    v45 = &v44[6 * v152];
                    long long v46 = *(_OWORD *)v43;
                    *((void *)v45 + 2) = *((void *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    uint64_t v47 = ++v152;
                    if (v150[0])
                    {
                      int v139 = 3;
                      BOOL v140 = ", ";
                      uint64_t v141 = 2;
                      v48 = &v139;
                      uint64_t v49 = v151;
                      if (v47 >= v153)
                      {
                        unint64_t v109 = v47 + 1;
                        BOOL v110 = &v151[6 * v47] > &v139;
                        if (v151 <= &v139 && v110)
                        {
                          int64_t v129 = (char *)&v139 - (char *)v151;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          uint64_t v49 = v151;
                          v48 = (int *)((char *)v151 + v129);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          v48 = &v139;
                          uint64_t v49 = v151;
                        }
                      }
                      uint64_t v50 = &v49[6 * v152];
                      long long v51 = *(_OWORD *)v48;
                      *((void *)v50 + 2) = *((void *)v48 + 2);
                      *(_OWORD *)uint64_t v50 = v51;
                      uint64_t v52 = ++v152;
                      if (v150[0])
                      {
                        int v139 = 3;
                        BOOL v140 = "sigmoid";
                        uint64_t v141 = 7;
                        unsigned int v53 = &v139;
                        uint64_t v54 = v151;
                        if (v52 >= v153)
                        {
                          unint64_t v111 = v52 + 1;
                          BOOL v112 = &v151[6 * v52] > &v139;
                          if (v151 <= &v139 && v112)
                          {
                            int64_t v130 = (char *)&v139 - (char *)v151;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            uint64_t v54 = v151;
                            unsigned int v53 = (int *)((char *)v151 + v130);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            unsigned int v53 = &v139;
                            uint64_t v54 = v151;
                          }
                        }
                        unint64_t v55 = &v54[6 * v152];
                        long long v56 = *(_OWORD *)v53;
                        *((void *)v55 + 2) = *((void *)v53 + 2);
                        *(_OWORD *)unint64_t v55 = v56;
                        uint64_t v57 = ++v152;
                        if (v150[0])
                        {
                          int v139 = 3;
                          BOOL v140 = ", ";
                          uint64_t v141 = 2;
                          unint64_t v58 = &v139;
                          BOOL v59 = v151;
                          if (v57 >= v153)
                          {
                            unint64_t v113 = v57 + 1;
                            BOOL v114 = &v151[6 * v57] > &v139;
                            if (v151 <= &v139 && v114)
                            {
                              int64_t v131 = (char *)&v139 - (char *)v151;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              BOOL v59 = v151;
                              unint64_t v58 = (int *)((char *)v151 + v131);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              unint64_t v58 = &v139;
                              BOOL v59 = v151;
                            }
                          }
                          unint64_t v60 = &v59[6 * v152];
                          long long v61 = *(_OWORD *)v58;
                          *((void *)v60 + 2) = *((void *)v58 + 2);
                          *(_OWORD *)unint64_t v60 = v61;
                          uint64_t v62 = ++v152;
                          if (v150[0])
                          {
                            int v139 = 3;
                            BOOL v140 = "hard_sigmoid";
                            uint64_t v141 = 12;
                            BOOL v63 = &v139;
                            unint64_t v64 = v151;
                            if (v62 >= v153)
                            {
                              unint64_t v115 = v62 + 1;
                              BOOL v116 = &v151[6 * v62] > &v139;
                              if (v151 <= &v139 && v116)
                              {
                                int64_t v132 = (char *)&v139 - (char *)v151;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                unint64_t v64 = v151;
                                BOOL v63 = (int *)((char *)v151 + v132);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                BOOL v63 = &v139;
                                unint64_t v64 = v151;
                              }
                            }
                            BOOL v65 = &v64[6 * v152];
                            long long v66 = *(_OWORD *)v63;
                            *((void *)v65 + 2) = *((void *)v63 + 2);
                            *(_OWORD *)BOOL v65 = v66;
                            uint64_t v67 = ++v152;
                            if (v150[0])
                            {
                              int v139 = 3;
                              BOOL v140 = ", ";
                              uint64_t v141 = 2;
                              int64_t v68 = &v139;
                              int64_t v69 = v151;
                              if (v67 >= v153)
                              {
                                unint64_t v117 = v67 + 1;
                                BOOL v118 = &v151[6 * v67] > &v139;
                                if (v151 <= &v139 && v118)
                                {
                                  int64_t v133 = (char *)&v139 - (char *)v151;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  int64_t v69 = v151;
                                  int64_t v68 = (int *)((char *)v151 + v133);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  int64_t v68 = &v139;
                                  int64_t v69 = v151;
                                }
                              }
                              int64_t v70 = &v69[6 * v152];
                              long long v71 = *(_OWORD *)v68;
                              *((void *)v70 + 2) = *((void *)v68 + 2);
                              *(_OWORD *)int64_t v70 = v71;
                              uint64_t v72 = ++v152;
                              if (v150[0])
                              {
                                int v139 = 3;
                                BOOL v140 = "scaled_tanh";
                                uint64_t v141 = 11;
                                uint64_t v73 = &v139;
                                uint64_t v74 = v151;
                                if (v72 >= v153)
                                {
                                  unint64_t v119 = v72 + 1;
                                  BOOL v120 = &v151[6 * v72] > &v139;
                                  if (v151 <= &v139 && v120)
                                  {
                                    int64_t v134 = (char *)&v139 - (char *)v151;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    uint64_t v74 = v151;
                                    uint64_t v73 = (int *)((char *)v151 + v134);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    uint64_t v73 = &v139;
                                    uint64_t v74 = v151;
                                  }
                                }
                                uint64_t v75 = &v74[6 * v152];
                                long long v76 = *(_OWORD *)v73;
                                *((void *)v75 + 2) = *((void *)v73 + 2);
                                *(_OWORD *)uint64_t v75 = v76;
                                ++v152;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v150);
    if (v150[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v150);
    }
    if (v159)
    {
      uint64_t v77 = v157;
      if (v157)
      {
        uint64_t v78 = v158;
        int64_t v79 = v157;
        if (v158 != v157)
        {
          do
            uint64_t v78 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v78 - 1);
          while (v78 != v77);
          int64_t v79 = v157;
        }
        int64_t v158 = v77;
        operator delete(v79);
      }
      int64_t v80 = v155;
      if (v155)
      {
        long long v81 = v156;
        uint64_t v82 = v155;
        if (v156 != v155)
        {
          do
          {
            uint64_t v84 = *--v81;
            uint64_t v83 = v84;
            void *v81 = 0;
            if (v84) {
              MEMORY[0x21667D390](v83, 0x1000C8077774924);
            }
          }
          while (v81 != v80);
          uint64_t v82 = v155;
        }
        int64_t v156 = v80;
        operator delete(v82);
      }
      if (v151 != (int *)v154) {
        free(v151);
      }
    }
    goto LABEL_53;
  }
  unsigned int v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v135[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v150[0] = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
    v150[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v150, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, v135);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::RNNActivationAttr::print(mlir::mps::RNNActivationAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6 > 5)
    {
LABEL_6:
      size_t v9 = 0;
      uint64_t v8 = &byte_211F4AA5D;
      char v7 = 1;
      goto LABEL_11;
    }
  }
  else
  {
    *unsigned int v5 = 60;
    ++*((void *)v4 + 4);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
  }
  char v7 = 0;
  uint64_t v8 = "none";
  size_t v9 = 4;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      char v7 = 0;
      uint64_t v8 = "relu";
      size_t v9 = 4;
      break;
    case 2u:
      char v7 = 0;
      uint64_t v8 = "tanh";
      size_t v9 = 4;
      break;
    case 3u:
      char v7 = 0;
      uint64_t v8 = "sigmoid";
      size_t v9 = 7;
      break;
    case 4u:
      char v7 = 0;
      uint64_t v8 = "hard_sigmoid";
      size_t v9 = 12;
      break;
    case 5u:
      char v7 = 0;
      uint64_t v8 = "scaled_tanh";
      size_t v9 = 11;
      break;
    default:
      goto LABEL_6;
  }
LABEL_11:
  size_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v11 = (void *)*((void *)v10 + 4);
  if (v9 <= *((void *)v10 + 3) - (void)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((void *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    *long long v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::LSTMGateLayoutAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::LSTMGateLayoutAttrStorage,mlir::mps::LSTMGateLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25LSTMGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18LSTMGateLayoutAttrEJNS2_14LSTMGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id, &v5);
}

uint64_t mlir::mps::LSTMGateLayoutAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v123 = *MEMORY[0x263EF8340];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    BOOL v100 = 0;
    uint64_t v101 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v100))
    {
LABEL_48:
      uint64_t v61 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v115) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v105, a1, v61, v113);
      if (v105[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v105);
      }
      if (v112)
      {
        uint64_t v62 = __p;
        if (__p)
        {
          BOOL v63 = v111;
          unint64_t v64 = __p;
          if (v111 != __p)
          {
            do
              BOOL v63 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v63 - 1);
            while (v63 != v62);
            unint64_t v64 = __p;
          }
          unint64_t v111 = v62;
          operator delete(v64);
        }
        BOOL v65 = v108;
        if (v108)
        {
          long long v66 = v109;
          uint64_t v67 = v108;
          if (v109 != v108)
          {
            do
            {
              uint64_t v69 = *--v66;
              uint64_t v68 = v69;
              *long long v66 = 0;
              if (v69) {
                MEMORY[0x21667D390](v68, 0x1000C8077774924);
              }
            }
            while (v66 != v65);
            uint64_t v67 = v108;
          }
          unint64_t v109 = v65;
          operator delete(v67);
        }
        if (v106 != &v107) {
          free(v106);
        }
      }
      return 0;
    }
    if (v101 != 4)
    {
LABEL_8:
      __int16 v99 = 257;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v113, a1, v2, v98);
      if (v113[0])
      {
        int v102 = 3;
        unint64_t v103 = "expected ";
        uint64_t v104 = 9;
        uint64_t v3 = &v102;
        unsigned int v4 = v114;
        if (v115 >= v116)
        {
          unint64_t v73 = v115 + 1;
          if (v114 <= &v102 && &v114[6 * v115] > &v102)
          {
            int64_t v88 = (char *)&v102 - (char *)v114;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v73, 24);
            unsigned int v4 = v114;
            uint64_t v3 = (int *)((char *)v114 + v88);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v73, 24);
            uint64_t v3 = &v102;
            unsigned int v4 = v114;
          }
        }
        unsigned int v5 = &v4[6 * v115];
        long long v6 = *(_OWORD *)v3;
        *((void *)v5 + 2) = *((void *)v3 + 2);
        *(_OWORD *)unsigned int v5 = v6;
        uint64_t v7 = ++v115;
        if (v113[0])
        {
          int v102 = 3;
          unint64_t v103 = "::mlir::mps::LSTMGateLayout";
          uint64_t v104 = 27;
          uint64_t v8 = &v102;
          size_t v9 = v114;
          if (v7 >= v116)
          {
            unint64_t v74 = v7 + 1;
            BOOL v75 = &v114[6 * v7] > &v102;
            if (v114 <= &v102 && v75)
            {
              int64_t v89 = (char *)&v102 - (char *)v114;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v74, 24);
              size_t v9 = v114;
              uint64_t v8 = (int *)((char *)v114 + v89);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v74, 24);
              uint64_t v8 = &v102;
              size_t v9 = v114;
            }
          }
          size_t v10 = &v9[6 * v115];
          long long v11 = *(_OWORD *)v8;
          *((void *)v10 + 2) = *((void *)v8 + 2);
          *(_OWORD *)size_t v10 = v11;
          uint64_t v12 = ++v115;
          if (v113[0])
          {
            int v102 = 3;
            unint64_t v103 = " to be one of: ";
            uint64_t v104 = 15;
            long long v13 = &v102;
            long long v14 = v114;
            if (v12 >= v116)
            {
              unint64_t v76 = v12 + 1;
              BOOL v77 = &v114[6 * v12] > &v102;
              if (v114 <= &v102 && v77)
              {
                int64_t v90 = (char *)&v102 - (char *)v114;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v76, 24);
                long long v14 = v114;
                long long v13 = (int *)((char *)v114 + v90);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v76, 24);
                long long v13 = &v102;
                long long v14 = v114;
              }
            }
            uint64_t v15 = &v14[6 * v115];
            long long v16 = *(_OWORD *)v13;
            *((void *)v15 + 2) = *((void *)v13 + 2);
            *(_OWORD *)uint64_t v15 = v16;
            uint64_t v17 = ++v115;
            if (v113[0])
            {
              int v102 = 3;
              unint64_t v103 = "IFZO";
              uint64_t v104 = 4;
              long long v18 = &v102;
              long long v19 = v114;
              if (v17 >= v116)
              {
                unint64_t v78 = v17 + 1;
                BOOL v79 = &v114[6 * v17] > &v102;
                if (v114 <= &v102 && v79)
                {
                  int64_t v91 = (char *)&v102 - (char *)v114;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v78, 24);
                  long long v19 = v114;
                  long long v18 = (int *)((char *)v114 + v91);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v78, 24);
                  long long v18 = &v102;
                  long long v19 = v114;
                }
              }
              uint64_t v20 = &v19[6 * v115];
              long long v21 = *(_OWORD *)v18;
              *((void *)v20 + 2) = *((void *)v18 + 2);
              *(_OWORD *)uint64_t v20 = v21;
              uint64_t v22 = ++v115;
              if (v113[0])
              {
                int v102 = 3;
                unint64_t v103 = ", ";
                uint64_t v104 = 2;
                long long v23 = &v102;
                long long v24 = v114;
                if (v22 >= v116)
                {
                  unint64_t v80 = v22 + 1;
                  if (v114 <= &v102 && &v114[6 * v22] > &v102)
                  {
                    int64_t v92 = (char *)&v102 - (char *)v114;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v80, 24);
                    long long v24 = v114;
                    long long v23 = (int *)((char *)v114 + v92);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v80, 24);
                    long long v23 = &v102;
                    long long v24 = v114;
                  }
                }
                uint64_t v25 = &v24[6 * v115];
                long long v26 = *(_OWORD *)v23;
                *((void *)v25 + 2) = *((void *)v23 + 2);
                *(_OWORD *)uint64_t v25 = v26;
                uint64_t v27 = ++v115;
                if (v113[0])
                {
                  int v102 = 3;
                  unint64_t v103 = "IZFO";
                  uint64_t v104 = 4;
                  long long v28 = &v102;
                  long long v29 = v114;
                  if (v27 >= v116)
                  {
                    unint64_t v81 = v27 + 1;
                    if (v114 <= &v102 && &v114[6 * v27] > &v102)
                    {
                      int64_t v93 = (char *)&v102 - (char *)v114;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v81, 24);
                      long long v29 = v114;
                      long long v28 = (int *)((char *)v114 + v93);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v81, 24);
                      long long v28 = &v102;
                      long long v29 = v114;
                    }
                  }
                  uint64_t v30 = &v29[6 * v115];
                  long long v31 = *(_OWORD *)v28;
                  *((void *)v30 + 2) = *((void *)v28 + 2);
                  *(_OWORD *)uint64_t v30 = v31;
                  uint64_t v32 = ++v115;
                  if (v113[0])
                  {
                    int v102 = 3;
                    unint64_t v103 = ", ";
                    uint64_t v104 = 2;
                    long long v33 = &v102;
                    long long v34 = v114;
                    if (v32 >= v116)
                    {
                      unint64_t v82 = v32 + 1;
                      if (v114 <= &v102 && &v114[6 * v32] > &v102)
                      {
                        int64_t v94 = (char *)&v102 - (char *)v114;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v82, 24);
                        long long v34 = v114;
                        long long v33 = (int *)((char *)v114 + v94);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v82, 24);
                        long long v33 = &v102;
                        long long v34 = v114;
                      }
                    }
                    uint64_t v35 = &v34[6 * v115];
                    long long v36 = *(_OWORD *)v33;
                    *((void *)v35 + 2) = *((void *)v33 + 2);
                    *(_OWORD *)uint64_t v35 = v36;
                    uint64_t v37 = ++v115;
                    if (v113[0])
                    {
                      int v102 = 3;
                      unint64_t v103 = "IFOZ";
                      uint64_t v104 = 4;
                      v38 = &v102;
                      long long v39 = v114;
                      if (v37 >= v116)
                      {
                        unint64_t v83 = v37 + 1;
                        if (v114 <= &v102 && &v114[6 * v37] > &v102)
                        {
                          int64_t v95 = (char *)&v102 - (char *)v114;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v83, 24);
                          long long v39 = v114;
                          v38 = (int *)((char *)v114 + v95);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v83, 24);
                          v38 = &v102;
                          long long v39 = v114;
                        }
                      }
                      uint64_t v40 = &v39[6 * v115];
                      long long v41 = *(_OWORD *)v38;
                      *((void *)v40 + 2) = *((void *)v38 + 2);
                      *(_OWORD *)uint64_t v40 = v41;
                      uint64_t v42 = ++v115;
                      if (v113[0])
                      {
                        int v102 = 3;
                        unint64_t v103 = ", ";
                        uint64_t v104 = 2;
                        uint64_t v43 = &v102;
                        long long v44 = v114;
                        if (v42 >= v116)
                        {
                          unint64_t v84 = v42 + 1;
                          BOOL v85 = &v114[6 * v42] > &v102;
                          if (v114 <= &v102 && v85)
                          {
                            int64_t v96 = (char *)&v102 - (char *)v114;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v84, 24);
                            long long v44 = v114;
                            uint64_t v43 = (int *)((char *)v114 + v96);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v84, 24);
                            uint64_t v43 = &v102;
                            long long v44 = v114;
                          }
                        }
                        v45 = &v44[6 * v115];
                        long long v46 = *(_OWORD *)v43;
                        *((void *)v45 + 2) = *((void *)v43 + 2);
                        *(_OWORD *)v45 = v46;
                        uint64_t v47 = ++v115;
                        if (v113[0])
                        {
                          int v102 = 3;
                          unint64_t v103 = "IOFZ";
                          uint64_t v104 = 4;
                          v48 = &v102;
                          uint64_t v49 = v114;
                          if (v47 >= v116)
                          {
                            unint64_t v86 = v47 + 1;
                            BOOL v87 = &v114[6 * v47] > &v102;
                            if (v114 <= &v102 && v87)
                            {
                              int64_t v97 = (char *)&v102 - (char *)v114;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v86, 24);
                              uint64_t v49 = v114;
                              v48 = (int *)((char *)v114 + v97);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v86, 24);
                              v48 = &v102;
                              uint64_t v49 = v114;
                            }
                          }
                          uint64_t v50 = &v49[6 * v115];
                          long long v51 = *(_OWORD *)v48;
                          *((void *)v50 + 2) = *((void *)v48 + 2);
                          *(_OWORD *)uint64_t v50 = v51;
                          ++v115;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v113);
      if (v113[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
      }
      if (v122)
      {
        uint64_t v52 = v120;
        if (v120)
        {
          unsigned int v53 = v121;
          uint64_t v54 = v120;
          if (v121 != v120)
          {
            do
              unsigned int v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
            while (v53 != v52);
            uint64_t v54 = v120;
          }
          int64_t v121 = v52;
          operator delete(v54);
        }
        unint64_t v55 = v118;
        if (v118)
        {
          long long v56 = v119;
          uint64_t v57 = v118;
          if (v119 != v118)
          {
            do
            {
              uint64_t v59 = *--v56;
              uint64_t v58 = v59;
              *long long v56 = 0;
              if (v59) {
                MEMORY[0x21667D390](v58, 0x1000C8077774924);
              }
            }
            while (v56 != v55);
            uint64_t v57 = v118;
          }
          unint64_t v119 = v55;
          operator delete(v57);
        }
        if (v114 != (int *)v117) {
          free(v114);
        }
      }
      goto LABEL_48;
    }
    switch(*v100)
    {
      case 0x4F5A4649:
        unsigned int v60 = 0;
        break;
      case 0x4F465A49:
        unsigned int v60 = 1;
        break;
      case 0x5A4F4649:
        unsigned int v60 = 2;
        break;
      case 0x5A464F49:
        unsigned int v60 = 3;
        break;
      default:
        goto LABEL_8;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v98[0] = v60;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v113[0] = &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id;
      v113[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::LSTMGateLayoutAttrStorage,mlir::mps::LSTMGateLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25LSTMGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18LSTMGateLayoutAttrEJNS2_14LSTMGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v113, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id, v98);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::LSTMGateLayoutAttr::print(mlir::mps::LSTMGateLayoutAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6 > 3)
    {
LABEL_6:
      size_t v9 = 0;
      uint64_t v8 = &byte_211F4AA5D;
      char v7 = 1;
      goto LABEL_10;
    }
  }
  else
  {
    *unsigned int v5 = 60;
    ++*((void *)v4 + 4);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
  }
  char v7 = 0;
  uint64_t v8 = "IFZO";
  size_t v9 = 4;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      char v7 = 0;
      uint64_t v8 = "IZFO";
      goto LABEL_9;
    case 2u:
      char v7 = 0;
      uint64_t v8 = "IFOZ";
      goto LABEL_9;
    case 3u:
      char v7 = 0;
      uint64_t v8 = "IOFZ";
LABEL_9:
      size_t v9 = 4;
      break;
    default:
      goto LABEL_6;
  }
LABEL_10:
  size_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v11 = (void *)*((void *)v10 + 4);
  if (v9 <= *((void *)v10 + 3) - (void)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((void *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    *long long v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::GRUGateLayoutAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::GRUGateLayoutAttrStorage,mlir::mps::GRUGateLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24GRUGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17GRUGateLayoutAttrEJNS2_13GRUGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id, &v5);
}

uint64_t mlir::mps::GRUGateLayoutAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v112 = *MEMORY[0x263EF8340];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    uint64_t v89 = 0;
    uint64_t v90 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v89))
    {
LABEL_52:
      uint64_t v54 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v104) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v94, a1, v54, v102);
      if (v94[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v94);
      }
      if (v101)
      {
        unint64_t v55 = __p;
        if (__p)
        {
          long long v56 = v100;
          uint64_t v57 = __p;
          if (v100 != __p)
          {
            do
              long long v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
            while (v56 != v55);
            uint64_t v57 = __p;
          }
          BOOL v100 = v55;
          operator delete(v57);
        }
        uint64_t v58 = v97;
        if (v97)
        {
          uint64_t v59 = v98;
          unsigned int v60 = v97;
          if (v98 != v97)
          {
            do
            {
              uint64_t v62 = *--v59;
              uint64_t v61 = v62;
              *uint64_t v59 = 0;
              if (v62) {
                MEMORY[0x21667D390](v61, 0x1000C8077774924);
              }
            }
            while (v59 != v58);
            unsigned int v60 = v97;
          }
          BOOL v98 = v58;
          operator delete(v60);
        }
        if (v95 != &v96) {
          free(v95);
        }
      }
      return 0;
    }
    if (v90 != 3)
    {
LABEL_16:
      __int16 v88 = 257;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v102, a1, v2, v87);
      if (v102[0])
      {
        int v91 = 3;
        int64_t v92 = "expected ";
        uint64_t v93 = 9;
        unsigned int v6 = &v91;
        char v7 = v103;
        if (v104 >= v105)
        {
          unint64_t v66 = v104 + 1;
          if (v103 <= &v91 && &v103[6 * v104] > &v91)
          {
            int64_t v79 = (char *)&v91 - (char *)v103;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            char v7 = v103;
            unsigned int v6 = (int *)((char *)v103 + v79);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            unsigned int v6 = &v91;
            char v7 = v103;
          }
        }
        uint64_t v8 = &v7[6 * v104];
        long long v9 = *(_OWORD *)v6;
        *((void *)v8 + 2) = *((void *)v6 + 2);
        *(_OWORD *)uint64_t v8 = v9;
        uint64_t v10 = ++v104;
        if (v102[0])
        {
          int v91 = 3;
          int64_t v92 = "::mlir::mps::GRUGateLayout";
          uint64_t v93 = 26;
          long long v11 = &v91;
          uint64_t v12 = v103;
          if (v10 >= v105)
          {
            unint64_t v67 = v10 + 1;
            BOOL v68 = &v103[6 * v10] > &v91;
            if (v103 <= &v91 && v68)
            {
              int64_t v80 = (char *)&v91 - (char *)v103;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              uint64_t v12 = v103;
              long long v11 = (int *)((char *)v103 + v80);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              long long v11 = &v91;
              uint64_t v12 = v103;
            }
          }
          long long v13 = &v12[6 * v104];
          long long v14 = *(_OWORD *)v11;
          *((void *)v13 + 2) = *((void *)v11 + 2);
          *(_OWORD *)long long v13 = v14;
          uint64_t v15 = ++v104;
          if (v102[0])
          {
            int v91 = 3;
            int64_t v92 = " to be one of: ";
            uint64_t v93 = 15;
            long long v16 = &v91;
            uint64_t v17 = v103;
            if (v15 >= v105)
            {
              unint64_t v69 = v15 + 1;
              BOOL v70 = &v103[6 * v15] > &v91;
              if (v103 <= &v91 && v70)
              {
                int64_t v81 = (char *)&v91 - (char *)v103;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                uint64_t v17 = v103;
                long long v16 = (int *)((char *)v103 + v81);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                long long v16 = &v91;
                uint64_t v17 = v103;
              }
            }
            long long v18 = &v17[6 * v104];
            long long v19 = *(_OWORD *)v16;
            *((void *)v18 + 2) = *((void *)v16 + 2);
            *(_OWORD *)long long v18 = v19;
            uint64_t v20 = ++v104;
            if (v102[0])
            {
              int v91 = 3;
              int64_t v92 = "ZRO";
              uint64_t v93 = 3;
              long long v21 = &v91;
              uint64_t v22 = v103;
              if (v20 >= v105)
              {
                unint64_t v71 = v20 + 1;
                BOOL v72 = &v103[6 * v20] > &v91;
                if (v103 <= &v91 && v72)
                {
                  int64_t v82 = (char *)&v91 - (char *)v103;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  uint64_t v22 = v103;
                  long long v21 = (int *)((char *)v103 + v82);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  long long v21 = &v91;
                  uint64_t v22 = v103;
                }
              }
              long long v23 = &v22[6 * v104];
              long long v24 = *(_OWORD *)v21;
              *((void *)v23 + 2) = *((void *)v21 + 2);
              *(_OWORD *)long long v23 = v24;
              uint64_t v25 = ++v104;
              if (v102[0])
              {
                int v91 = 3;
                int64_t v92 = ", ";
                uint64_t v93 = 2;
                long long v26 = &v91;
                uint64_t v27 = v103;
                if (v25 >= v105)
                {
                  unint64_t v73 = v25 + 1;
                  if (v103 <= &v91 && &v103[6 * v25] > &v91)
                  {
                    int64_t v83 = (char *)&v91 - (char *)v103;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    uint64_t v27 = v103;
                    long long v26 = (int *)((char *)v103 + v83);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    long long v26 = &v91;
                    uint64_t v27 = v103;
                  }
                }
                long long v28 = &v27[6 * v104];
                long long v29 = *(_OWORD *)v26;
                *((void *)v28 + 2) = *((void *)v26 + 2);
                *(_OWORD *)long long v28 = v29;
                uint64_t v30 = ++v104;
                if (v102[0])
                {
                  int v91 = 3;
                  int64_t v92 = "RZO";
                  uint64_t v93 = 3;
                  long long v31 = &v91;
                  uint64_t v32 = v103;
                  if (v30 >= v105)
                  {
                    unint64_t v74 = v30 + 1;
                    if (v103 <= &v91 && &v103[6 * v30] > &v91)
                    {
                      int64_t v84 = (char *)&v91 - (char *)v103;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      uint64_t v32 = v103;
                      long long v31 = (int *)((char *)v103 + v84);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      long long v31 = &v91;
                      uint64_t v32 = v103;
                    }
                  }
                  long long v33 = &v32[6 * v104];
                  long long v34 = *(_OWORD *)v31;
                  *((void *)v33 + 2) = *((void *)v31 + 2);
                  *(_OWORD *)long long v33 = v34;
                  uint64_t v35 = ++v104;
                  if (v102[0])
                  {
                    int v91 = 3;
                    int64_t v92 = ", ";
                    uint64_t v93 = 2;
                    long long v36 = &v91;
                    uint64_t v37 = v103;
                    if (v35 >= v105)
                    {
                      unint64_t v75 = v35 + 1;
                      BOOL v76 = &v103[6 * v35] > &v91;
                      if (v103 <= &v91 && v76)
                      {
                        int64_t v85 = (char *)&v91 - (char *)v103;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        uint64_t v37 = v103;
                        long long v36 = (int *)((char *)v103 + v85);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        long long v36 = &v91;
                        uint64_t v37 = v103;
                      }
                    }
                    v38 = &v37[6 * v104];
                    long long v39 = *(_OWORD *)v36;
                    *((void *)v38 + 2) = *((void *)v36 + 2);
                    *(_OWORD *)v38 = v39;
                    uint64_t v40 = ++v104;
                    if (v102[0])
                    {
                      int v91 = 3;
                      int64_t v92 = "ROZ";
                      uint64_t v93 = 3;
                      long long v41 = &v91;
                      uint64_t v42 = v103;
                      if (v40 >= v105)
                      {
                        unint64_t v77 = v40 + 1;
                        BOOL v78 = &v103[6 * v40] > &v91;
                        if (v103 <= &v91 && v78)
                        {
                          int64_t v86 = (char *)&v91 - (char *)v103;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          uint64_t v42 = v103;
                          long long v41 = (int *)((char *)v103 + v86);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          long long v41 = &v91;
                          uint64_t v42 = v103;
                        }
                      }
                      uint64_t v43 = &v42[6 * v104];
                      long long v44 = *(_OWORD *)v41;
                      *((void *)v43 + 2) = *((void *)v41 + 2);
                      *(_OWORD *)uint64_t v43 = v44;
                      ++v104;
                    }
                  }
                }
              }
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v102);
      if (v102[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v102);
      }
      if (v111)
      {
        v45 = v109;
        if (v109)
        {
          long long v46 = v110;
          uint64_t v47 = v109;
          if (v110 != v109)
          {
            do
              long long v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
            while (v46 != v45);
            uint64_t v47 = v109;
          }
          BOOL v110 = v45;
          operator delete(v47);
        }
        v48 = v107;
        if (v107)
        {
          uint64_t v49 = v108;
          uint64_t v50 = v107;
          if (v108 != v107)
          {
            do
            {
              uint64_t v52 = *--v49;
              uint64_t v51 = v52;
              *uint64_t v49 = 0;
              if (v52) {
                MEMORY[0x21667D390](v51, 0x1000C8077774924);
              }
            }
            while (v49 != v48);
            uint64_t v50 = v107;
          }
          BOOL v108 = v48;
          operator delete(v50);
        }
        if (v103 != (int *)v106) {
          free(v103);
        }
      }
      goto LABEL_52;
    }
    if (*(_WORD *)v89 == 21082 && *(unsigned char *)(v89 + 2) == 79)
    {
      unsigned int v53 = 0;
    }
    else if (*(_WORD *)v89 == 23122 && *(unsigned char *)(v89 + 2) == 79)
    {
      unsigned int v53 = 1;
    }
    else
    {
      if (*(_WORD *)v89 != 20306 || *(unsigned char *)(v89 + 2) != 90) {
        goto LABEL_16;
      }
      unsigned int v53 = 2;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v87[0] = v53;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v102[0] = &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id;
      v102[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::GRUGateLayoutAttrStorage,mlir::mps::GRUGateLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24GRUGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17GRUGateLayoutAttrEJNS2_13GRUGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v102, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id, v87);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::GRUGateLayoutAttr::print(mlir::mps::GRUGateLayoutAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) != v5)
  {
    *unsigned int v5 = 60;
    ++*((void *)v4 + 4);
    int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6) {
      goto LABEL_3;
    }
LABEL_11:
    BOOL v7 = 0;
    long long v9 = "ZRO";
LABEL_13:
    size_t v8 = 3;
    goto LABEL_14;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  int v6 = *(_DWORD *)(*(void *)this + 8);
  if (!v6) {
    goto LABEL_11;
  }
LABEL_3:
  if (v6 == 2)
  {
    BOOL v7 = 0;
    long long v9 = "ROZ";
    goto LABEL_13;
  }
  BOOL v7 = v6 != 1;
  if (v6 == 1) {
    size_t v8 = 3;
  }
  else {
    size_t v8 = 0;
  }
  if (v6 == 1) {
    long long v9 = "RZO";
  }
  else {
    long long v9 = &byte_211F4AA5D;
  }
LABEL_14:
  uint64_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v11 = (void *)*((void *)v10 + 4);
  if (v8 <= *((void *)v10 + 3) - (void)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((void *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    *long long v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::StencilPaddingModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::StencilPaddingModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::StencilPaddingModeAttrStorage,mlir::mps::StencilPaddingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail29StencilPaddingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_22StencilPaddingModeAttrEJNS2_18StencilPaddingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::StencilPaddingModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::StencilPaddingModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v176 = *MEMORY[0x263EF8340];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1)) {
    return 0;
  }
  uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  unsigned int v153 = 0;
  uint64_t v154 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v153))
  {
LABEL_57:
    uint64_t v95 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    LOWORD(v168) = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v158, a1, v95, v166);
    if (v158[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v158);
    }
    if (v165)
    {
      uint64_t v96 = __p;
      if (__p)
      {
        int64_t v97 = v164;
        BOOL v98 = __p;
        if (v164 != __p)
        {
          do
            int64_t v97 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v97 - 1);
          while (v97 != v96);
          BOOL v98 = __p;
        }
        int64_t v164 = v96;
        operator delete(v98);
      }
      __int16 v99 = v161;
      if (v161)
      {
        BOOL v100 = v162;
        char v101 = v161;
        if (v162 != v161)
        {
          do
          {
            uint64_t v103 = *--v100;
            uint64_t v102 = v103;
            *BOOL v100 = 0;
            if (v103) {
              MEMORY[0x21667D390](v102, 0x1000C8077774924);
            }
          }
          while (v100 != v99);
          char v101 = v161;
        }
        int64_t v162 = v99;
        operator delete(v101);
      }
      if (v159 != &v160) {
        free(v159);
      }
    }
    return 0;
  }
  uint64_t v3 = mlir::mps::symbolizeStencilPaddingMode(v153, v154);
  if ((v3 & 0xFF00000000) == 0)
  {
    __int16 v152 = 257;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v166, a1, v2, v151);
    if (v166[0])
    {
      int v155 = 3;
      int64_t v156 = "expected ";
      uint64_t v157 = 9;
      size_t v8 = &v155;
      long long v9 = v167;
      if (v168 >= v169)
      {
        unint64_t v104 = v168 + 1;
        if (v167 <= &v155 && &v167[6 * v168] > &v155)
        {
          int64_t v135 = (char *)&v155 - (char *)v167;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v104, 24);
          long long v9 = v167;
          size_t v8 = (int *)((char *)v167 + v135);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v104, 24);
          size_t v8 = &v155;
          long long v9 = v167;
        }
      }
      uint64_t v10 = &v9[6 * v168];
      long long v11 = *(_OWORD *)v8;
      *((void *)v10 + 2) = *((void *)v8 + 2);
      *(_OWORD *)uint64_t v10 = v11;
      uint64_t v12 = ++v168;
      if (v166[0])
      {
        int v155 = 3;
        int64_t v156 = "::mlir::mps::StencilPaddingMode";
        uint64_t v157 = 31;
        long long v13 = &v155;
        long long v14 = v167;
        if (v12 >= v169)
        {
          unint64_t v105 = v12 + 1;
          BOOL v106 = &v167[6 * v12] > &v155;
          if (v167 <= &v155 && v106)
          {
            int64_t v136 = (char *)&v155 - (char *)v167;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v105, 24);
            long long v14 = v167;
            long long v13 = (int *)((char *)v167 + v136);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v105, 24);
            long long v13 = &v155;
            long long v14 = v167;
          }
        }
        uint64_t v15 = &v14[6 * v168];
        long long v16 = *(_OWORD *)v13;
        *((void *)v15 + 2) = *((void *)v13 + 2);
        *(_OWORD *)uint64_t v15 = v16;
        uint64_t v17 = ++v168;
        if (v166[0])
        {
          int v155 = 3;
          int64_t v156 = " to be one of: ";
          uint64_t v157 = 15;
          long long v18 = &v155;
          long long v19 = v167;
          if (v17 >= v169)
          {
            unint64_t v107 = v17 + 1;
            BOOL v108 = &v167[6 * v17] > &v155;
            if (v167 <= &v155 && v108)
            {
              int64_t v137 = (char *)&v155 - (char *)v167;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v107, 24);
              long long v19 = v167;
              long long v18 = (int *)((char *)v167 + v137);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v107, 24);
              long long v18 = &v155;
              long long v19 = v167;
            }
          }
          uint64_t v20 = &v19[6 * v168];
          long long v21 = *(_OWORD *)v18;
          *((void *)v20 + 2) = *((void *)v18 + 2);
          *(_OWORD *)uint64_t v20 = v21;
          uint64_t v22 = ++v168;
          if (v166[0])
          {
            int v155 = 3;
            int64_t v156 = "zero";
            uint64_t v157 = 4;
            long long v23 = &v155;
            long long v24 = v167;
            if (v22 >= v169)
            {
              unint64_t v109 = v22 + 1;
              BOOL v110 = &v167[6 * v22] > &v155;
              if (v167 <= &v155 && v110)
              {
                int64_t v138 = (char *)&v155 - (char *)v167;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v109, 24);
                long long v24 = v167;
                long long v23 = (int *)((char *)v167 + v138);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v109, 24);
                long long v23 = &v155;
                long long v24 = v167;
              }
            }
            uint64_t v25 = &v24[6 * v168];
            long long v26 = *(_OWORD *)v23;
            *((void *)v25 + 2) = *((void *)v23 + 2);
            *(_OWORD *)uint64_t v25 = v26;
            uint64_t v27 = ++v168;
            if (v166[0])
            {
              int v155 = 3;
              int64_t v156 = ", ";
              uint64_t v157 = 2;
              long long v28 = &v155;
              long long v29 = v167;
              if (v27 >= v169)
              {
                unint64_t v111 = v27 + 1;
                BOOL v112 = &v167[6 * v27] > &v155;
                if (v167 <= &v155 && v112)
                {
                  int64_t v139 = (char *)&v155 - (char *)v167;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v111, 24);
                  long long v29 = v167;
                  long long v28 = (int *)((char *)v167 + v139);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v111, 24);
                  long long v28 = &v155;
                  long long v29 = v167;
                }
              }
              uint64_t v30 = &v29[6 * v168];
              long long v31 = *(_OWORD *)v28;
              *((void *)v30 + 2) = *((void *)v28 + 2);
              *(_OWORD *)uint64_t v30 = v31;
              uint64_t v32 = ++v168;
              if (v166[0])
              {
                int v155 = 3;
                int64_t v156 = "constant";
                uint64_t v157 = 8;
                long long v33 = &v155;
                long long v34 = v167;
                if (v32 >= v169)
                {
                  unint64_t v113 = v32 + 1;
                  BOOL v114 = &v167[6 * v32] > &v155;
                  if (v167 <= &v155 && v114)
                  {
                    int64_t v140 = (char *)&v155 - (char *)v167;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v113, 24);
                    long long v34 = v167;
                    long long v33 = (int *)((char *)v167 + v140);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v113, 24);
                    long long v33 = &v155;
                    long long v34 = v167;
                  }
                }
                uint64_t v35 = &v34[6 * v168];
                long long v36 = *(_OWORD *)v33;
                *((void *)v35 + 2) = *((void *)v33 + 2);
                *(_OWORD *)uint64_t v35 = v36;
                uint64_t v37 = ++v168;
                if (v166[0])
                {
                  int v155 = 3;
                  int64_t v156 = ", ";
                  uint64_t v157 = 2;
                  v38 = &v155;
                  long long v39 = v167;
                  if (v37 >= v169)
                  {
                    unint64_t v115 = v37 + 1;
                    BOOL v116 = &v167[6 * v37] > &v155;
                    if (v167 <= &v155 && v116)
                    {
                      int64_t v141 = (char *)&v155 - (char *)v167;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v115, 24);
                      long long v39 = v167;
                      v38 = (int *)((char *)v167 + v141);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v115, 24);
                      v38 = &v155;
                      long long v39 = v167;
                    }
                  }
                  uint64_t v40 = &v39[6 * v168];
                  long long v41 = *(_OWORD *)v38;
                  *((void *)v40 + 2) = *((void *)v38 + 2);
                  *(_OWORD *)uint64_t v40 = v41;
                  uint64_t v42 = ++v168;
                  if (v166[0])
                  {
                    int v155 = 3;
                    int64_t v156 = "clampToEdge";
                    uint64_t v157 = 11;
                    uint64_t v43 = &v155;
                    long long v44 = v167;
                    if (v42 >= v169)
                    {
                      unint64_t v117 = v42 + 1;
                      BOOL v118 = &v167[6 * v42] > &v155;
                      if (v167 <= &v155 && v118)
                      {
                        int64_t v142 = (char *)&v155 - (char *)v167;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v117, 24);
                        long long v44 = v167;
                        uint64_t v43 = (int *)((char *)v167 + v142);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v117, 24);
                        uint64_t v43 = &v155;
                        long long v44 = v167;
                      }
                    }
                    v45 = &v44[6 * v168];
                    long long v46 = *(_OWORD *)v43;
                    *((void *)v45 + 2) = *((void *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    uint64_t v47 = ++v168;
                    if (v166[0])
                    {
                      int v155 = 3;
                      int64_t v156 = ", ";
                      uint64_t v157 = 2;
                      v48 = &v155;
                      uint64_t v49 = v167;
                      if (v47 >= v169)
                      {
                        unint64_t v119 = v47 + 1;
                        BOOL v120 = &v167[6 * v47] > &v155;
                        if (v167 <= &v155 && v120)
                        {
                          int64_t v143 = (char *)&v155 - (char *)v167;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v119, 24);
                          uint64_t v49 = v167;
                          v48 = (int *)((char *)v167 + v143);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v119, 24);
                          v48 = &v155;
                          uint64_t v49 = v167;
                        }
                      }
                      uint64_t v50 = &v49[6 * v168];
                      long long v51 = *(_OWORD *)v48;
                      *((void *)v50 + 2) = *((void *)v48 + 2);
                      *(_OWORD *)uint64_t v50 = v51;
                      uint64_t v52 = ++v168;
                      if (v166[0])
                      {
                        int v155 = 3;
                        int64_t v156 = "mirror";
                        uint64_t v157 = 6;
                        unsigned int v53 = &v155;
                        uint64_t v54 = v167;
                        if (v52 >= v169)
                        {
                          unint64_t v121 = v52 + 1;
                          BOOL v122 = &v167[6 * v52] > &v155;
                          if (v167 <= &v155 && v122)
                          {
                            int64_t v144 = (char *)&v155 - (char *)v167;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v121, 24);
                            uint64_t v54 = v167;
                            unsigned int v53 = (int *)((char *)v167 + v144);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v121, 24);
                            unsigned int v53 = &v155;
                            uint64_t v54 = v167;
                          }
                        }
                        unint64_t v55 = &v54[6 * v168];
                        long long v56 = *(_OWORD *)v53;
                        *((void *)v55 + 2) = *((void *)v53 + 2);
                        *(_OWORD *)unint64_t v55 = v56;
                        uint64_t v57 = ++v168;
                        if (v166[0])
                        {
                          int v155 = 3;
                          int64_t v156 = ", ";
                          uint64_t v157 = 2;
                          uint64_t v58 = &v155;
                          uint64_t v59 = v167;
                          if (v57 >= v169)
                          {
                            unint64_t v123 = v57 + 1;
                            BOOL v124 = &v167[6 * v57] > &v155;
                            if (v167 <= &v155 && v124)
                            {
                              int64_t v145 = (char *)&v155 - (char *)v167;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v123, 24);
                              uint64_t v59 = v167;
                              uint64_t v58 = (int *)((char *)v167 + v145);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v123, 24);
                              uint64_t v58 = &v155;
                              uint64_t v59 = v167;
                            }
                          }
                          unsigned int v60 = &v59[6 * v168];
                          long long v61 = *(_OWORD *)v58;
                          *((void *)v60 + 2) = *((void *)v58 + 2);
                          *(_OWORD *)unsigned int v60 = v61;
                          uint64_t v62 = ++v168;
                          if (v166[0])
                          {
                            int v155 = 3;
                            int64_t v156 = "mirrorWithEdge";
                            uint64_t v157 = 14;
                            BOOL v63 = &v155;
                            unint64_t v64 = v167;
                            if (v62 >= v169)
                            {
                              unint64_t v125 = v62 + 1;
                              BOOL v126 = &v167[6 * v62] > &v155;
                              if (v167 <= &v155 && v126)
                              {
                                int64_t v146 = (char *)&v155 - (char *)v167;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v125, 24);
                                unint64_t v64 = v167;
                                BOOL v63 = (int *)((char *)v167 + v146);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v125, 24);
                                BOOL v63 = &v155;
                                unint64_t v64 = v167;
                              }
                            }
                            BOOL v65 = &v64[6 * v168];
                            long long v66 = *(_OWORD *)v63;
                            *((void *)v65 + 2) = *((void *)v63 + 2);
                            *(_OWORD *)BOOL v65 = v66;
                            uint64_t v67 = ++v168;
                            if (v166[0])
                            {
                              int v155 = 3;
                              int64_t v156 = ", ";
                              uint64_t v157 = 2;
                              BOOL v68 = &v155;
                              unint64_t v69 = v167;
                              if (v67 >= v169)
                              {
                                unint64_t v127 = v67 + 1;
                                BOOL v128 = &v167[6 * v67] > &v155;
                                if (v167 <= &v155 && v128)
                                {
                                  int64_t v147 = (char *)&v155 - (char *)v167;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v127, 24);
                                  unint64_t v69 = v167;
                                  BOOL v68 = (int *)((char *)v167 + v147);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v127, 24);
                                  BOOL v68 = &v155;
                                  unint64_t v69 = v167;
                                }
                              }
                              BOOL v70 = &v69[6 * v168];
                              long long v71 = *(_OWORD *)v68;
                              *((void *)v70 + 2) = *((void *)v68 + 2);
                              *(_OWORD *)BOOL v70 = v71;
                              uint64_t v72 = ++v168;
                              if (v166[0])
                              {
                                int v155 = 3;
                                int64_t v156 = "periodic";
                                uint64_t v157 = 8;
                                unint64_t v73 = &v155;
                                unint64_t v74 = v167;
                                if (v72 >= v169)
                                {
                                  unint64_t v129 = v72 + 1;
                                  BOOL v130 = &v167[6 * v72] > &v155;
                                  if (v167 <= &v155 && v130)
                                  {
                                    int64_t v148 = (char *)&v155 - (char *)v167;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v129, 24);
                                    unint64_t v74 = v167;
                                    unint64_t v73 = (int *)((char *)v167 + v148);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v129, 24);
                                    unint64_t v73 = &v155;
                                    unint64_t v74 = v167;
                                  }
                                }
                                unint64_t v75 = &v74[6 * v168];
                                long long v76 = *(_OWORD *)v73;
                                *((void *)v75 + 2) = *((void *)v73 + 2);
                                *(_OWORD *)unint64_t v75 = v76;
                                uint64_t v77 = ++v168;
                                if (v166[0])
                                {
                                  int v155 = 3;
                                  int64_t v156 = ", ";
                                  uint64_t v157 = 2;
                                  BOOL v78 = &v155;
                                  int64_t v79 = v167;
                                  if (v77 >= v169)
                                  {
                                    unint64_t v131 = v77 + 1;
                                    BOOL v132 = &v167[6 * v77] > &v155;
                                    if (v167 <= &v155 && v132)
                                    {
                                      int64_t v149 = (char *)&v155 - (char *)v167;
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v131, 24);
                                      int64_t v79 = v167;
                                      BOOL v78 = (int *)((char *)v167 + v149);
                                    }
                                    else
                                    {
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v131, 24);
                                      BOOL v78 = &v155;
                                      int64_t v79 = v167;
                                    }
                                  }
                                  int64_t v80 = &v79[6 * v168];
                                  long long v81 = *(_OWORD *)v78;
                                  *((void *)v80 + 2) = *((void *)v78 + 2);
                                  *(_OWORD *)int64_t v80 = v81;
                                  uint64_t v82 = ++v168;
                                  if (v166[0])
                                  {
                                    int v155 = 3;
                                    int64_t v156 = "antiPeriodic";
                                    uint64_t v157 = 12;
                                    int64_t v83 = &v155;
                                    int64_t v84 = v167;
                                    if (v82 >= v169)
                                    {
                                      unint64_t v133 = v82 + 1;
                                      BOOL v134 = &v167[6 * v82] > &v155;
                                      if (v167 <= &v155 && v134)
                                      {
                                        int64_t v150 = (char *)&v155 - (char *)v167;
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v133, 24);
                                        int64_t v84 = v167;
                                        int64_t v83 = (int *)((char *)v167 + v150);
                                      }
                                      else
                                      {
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v133, 24);
                                        int64_t v83 = &v155;
                                        int64_t v84 = v167;
                                      }
                                    }
                                    int64_t v85 = &v84[6 * v168];
                                    long long v86 = *(_OWORD *)v83;
                                    *((void *)v85 + 2) = *((void *)v83 + 2);
                                    *(_OWORD *)int64_t v85 = v86;
                                    ++v168;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v166);
    if (v166[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v166);
    }
    if (v175)
    {
      BOOL v87 = v173;
      if (v173)
      {
        __int16 v88 = v174;
        uint64_t v89 = v173;
        if (v174 != v173)
        {
          do
            __int16 v88 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v88 - 1);
          while (v88 != v87);
          uint64_t v89 = v173;
        }
        unint64_t v174 = v87;
        operator delete(v89);
      }
      uint64_t v90 = v171;
      if (v171)
      {
        int v91 = v172;
        int64_t v92 = v171;
        if (v172 != v171)
        {
          do
          {
            uint64_t v94 = *--v91;
            uint64_t v93 = v94;
            void *v91 = 0;
            if (v94) {
              MEMORY[0x21667D390](v93, 0x1000C8077774924);
            }
          }
          while (v91 != v90);
          int64_t v92 = v171;
        }
        BOOL v172 = v90;
        operator delete(v92);
      }
      if (v167 != (int *)v170) {
        free(v167);
      }
    }
    goto LABEL_57;
  }
  unsigned int v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v151[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v166[0] = &mlir::detail::TypeIDResolver<mlir::mps::StencilPaddingModeAttr,void>::id;
    v166[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::StencilPaddingModeAttrStorage,mlir::mps::StencilPaddingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail29StencilPaddingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_22StencilPaddingModeAttrEJNS2_18StencilPaddingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v166, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::StencilPaddingModeAttr,void>::id, v151);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::StencilPaddingModeAttr::print(mlir::mps::StencilPaddingModeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    size_t v6 = *(unsigned int *)(*(void *)this + 8);
    if (v6 > 6)
    {
LABEL_6:
      size_t v6 = 0;
      size_t v8 = &byte_211F4AA5D;
      char v7 = 1;
      goto LABEL_12;
    }
  }
  else
  {
    *unsigned int v5 = 60;
    ++*((void *)v4 + 4);
    size_t v6 = *(unsigned int *)(*(void *)this + 8);
  }
  char v7 = 0;
  size_t v8 = "zero";
  switch((int)v6)
  {
    case 0:
      char v7 = 0;
      size_t v8 = "constant";
      size_t v6 = 8;
      break;
    case 1:
      char v7 = 0;
      size_t v8 = "mirror";
      size_t v6 = 6;
      break;
    case 2:
      char v7 = 0;
      size_t v8 = "mirrorWithEdge";
      size_t v6 = 14;
      break;
    case 3:
      char v7 = 0;
      size_t v8 = "clampToEdge";
      size_t v6 = 11;
      break;
    case 4:
      break;
    case 5:
      char v7 = 0;
      size_t v8 = "periodic";
      size_t v6 = 8;
      break;
    case 6:
      char v7 = 0;
      size_t v8 = "antiPeriodic";
      size_t v6 = 12;
      break;
    default:
      goto LABEL_6;
  }
LABEL_12:
  long long v9 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v10 = (void *)*((void *)v9 + 4);
  if (v6 <= *((void *)v9 + 3) - (void)v10)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v10, v8, v6);
      *((void *)v9 + 4) += v6;
    }
  }
  else
  {
    llvm::raw_ostream::write(v9, v8, v6);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v12 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v12)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v12 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::CropResizeAlignmentModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::CropResizeAlignmentModeAttrStorage,mlir::mps::CropResizeAlignmentMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail34CropResizeAlignmentModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_27CropResizeAlignmentModeAttrEJNS2_23CropResizeAlignmentModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::CropResizeAlignmentModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v112 = *MEMORY[0x263EF8340];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    uint64_t v89 = 0;
    uint64_t v90 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v89))
    {
LABEL_57:
      uint64_t v54 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v104) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v94, a1, v54, v102);
      if (v94[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v94);
      }
      if (v101)
      {
        unint64_t v55 = __p;
        if (__p)
        {
          long long v56 = v100;
          uint64_t v57 = __p;
          if (v100 != __p)
          {
            do
              long long v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
            while (v56 != v55);
            uint64_t v57 = __p;
          }
          BOOL v100 = v55;
          operator delete(v57);
        }
        uint64_t v58 = v97;
        if (v97)
        {
          uint64_t v59 = v98;
          unsigned int v60 = v97;
          if (v98 != v97)
          {
            do
            {
              uint64_t v62 = *--v59;
              uint64_t v61 = v62;
              *uint64_t v59 = 0;
              if (v62) {
                MEMORY[0x21667D390](v61, 0x1000C8077774924);
              }
            }
            while (v59 != v58);
            unsigned int v60 = v97;
          }
          BOOL v98 = v58;
          operator delete(v60);
        }
        if (v95 != &v96) {
          free(v95);
        }
      }
      return 0;
    }
    if (v90 == 12)
    {
      if (*(void *)v89 != 0x726F436E67696C61 || *(_DWORD *)(v89 + 8) != 1936876910) {
        goto LABEL_22;
      }
      unsigned int v4 = 1;
    }
    else if (v90 == 13)
    {
      if (*(void *)v89 != 0x6F4374657366666FLL || *(void *)(v89 + 5) != 0x7372656E726F4374) {
        goto LABEL_22;
      }
      unsigned int v4 = 2;
    }
    else
    {
      if (v90 != 16
        || (*(void *)v89 == 0x41746C7561666564 ? (BOOL v3 = *(void *)(v89 + 8) == 0x746E656D6E67696CLL) : (BOOL v3 = 0), !v3))
      {
LABEL_22:
        __int16 v88 = 257;
        (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v102, a1, v2, v87);
        if (v102[0])
        {
          int v91 = 3;
          int64_t v92 = "expected ";
          uint64_t v93 = 9;
          char v7 = &v91;
          size_t v8 = v103;
          if (v104 >= v105)
          {
            unint64_t v66 = v104 + 1;
            if (v103 <= &v91 && &v103[6 * v104] > &v91)
            {
              int64_t v79 = (char *)&v91 - (char *)v103;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
              size_t v8 = v103;
              char v7 = (int *)((char *)v103 + v79);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
              char v7 = &v91;
              size_t v8 = v103;
            }
          }
          long long v9 = &v8[6 * v104];
          long long v10 = *(_OWORD *)v7;
          *((void *)v9 + 2) = *((void *)v7 + 2);
          *(_OWORD *)long long v9 = v10;
          uint64_t v11 = ++v104;
          if (v102[0])
          {
            int v91 = 3;
            int64_t v92 = "::mlir::mps::CropResizeAlignmentMode";
            uint64_t v93 = 36;
            uint64_t v12 = &v91;
            long long v13 = v103;
            if (v11 >= v105)
            {
              unint64_t v67 = v11 + 1;
              BOOL v68 = &v103[6 * v11] > &v91;
              if (v103 <= &v91 && v68)
              {
                int64_t v80 = (char *)&v91 - (char *)v103;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
                long long v13 = v103;
                uint64_t v12 = (int *)((char *)v103 + v80);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
                uint64_t v12 = &v91;
                long long v13 = v103;
              }
            }
            long long v14 = &v13[6 * v104];
            long long v15 = *(_OWORD *)v12;
            *((void *)v14 + 2) = *((void *)v12 + 2);
            *(_OWORD *)long long v14 = v15;
            uint64_t v16 = ++v104;
            if (v102[0])
            {
              int v91 = 3;
              int64_t v92 = " to be one of: ";
              uint64_t v93 = 15;
              uint64_t v17 = &v91;
              long long v18 = v103;
              if (v16 >= v105)
              {
                unint64_t v69 = v16 + 1;
                BOOL v70 = &v103[6 * v16] > &v91;
                if (v103 <= &v91 && v70)
                {
                  int64_t v81 = (char *)&v91 - (char *)v103;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                  long long v18 = v103;
                  uint64_t v17 = (int *)((char *)v103 + v81);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                  uint64_t v17 = &v91;
                  long long v18 = v103;
                }
              }
              long long v19 = &v18[6 * v104];
              long long v20 = *(_OWORD *)v17;
              *((void *)v19 + 2) = *((void *)v17 + 2);
              *(_OWORD *)long long v19 = v20;
              uint64_t v21 = ++v104;
              if (v102[0])
              {
                int v91 = 3;
                int64_t v92 = "defaultAlignment";
                uint64_t v93 = 16;
                uint64_t v22 = &v91;
                long long v23 = v103;
                if (v21 >= v105)
                {
                  unint64_t v71 = v21 + 1;
                  BOOL v72 = &v103[6 * v21] > &v91;
                  if (v103 <= &v91 && v72)
                  {
                    int64_t v82 = (char *)&v91 - (char *)v103;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                    long long v23 = v103;
                    uint64_t v22 = (int *)((char *)v103 + v82);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                    uint64_t v22 = &v91;
                    long long v23 = v103;
                  }
                }
                long long v24 = &v23[6 * v104];
                long long v25 = *(_OWORD *)v22;
                *((void *)v24 + 2) = *((void *)v22 + 2);
                *(_OWORD *)long long v24 = v25;
                uint64_t v26 = ++v104;
                if (v102[0])
                {
                  int v91 = 3;
                  int64_t v92 = ", ";
                  uint64_t v93 = 2;
                  uint64_t v27 = &v91;
                  long long v28 = v103;
                  if (v26 >= v105)
                  {
                    unint64_t v73 = v26 + 1;
                    if (v103 <= &v91 && &v103[6 * v26] > &v91)
                    {
                      int64_t v83 = (char *)&v91 - (char *)v103;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                      long long v28 = v103;
                      uint64_t v27 = (int *)((char *)v103 + v83);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                      uint64_t v27 = &v91;
                      long long v28 = v103;
                    }
                  }
                  long long v29 = &v28[6 * v104];
                  long long v30 = *(_OWORD *)v27;
                  *((void *)v29 + 2) = *((void *)v27 + 2);
                  *(_OWORD *)long long v29 = v30;
                  uint64_t v31 = ++v104;
                  if (v102[0])
                  {
                    int v91 = 3;
                    int64_t v92 = "alignCorners";
                    uint64_t v93 = 12;
                    uint64_t v32 = &v91;
                    long long v33 = v103;
                    if (v31 >= v105)
                    {
                      unint64_t v74 = v31 + 1;
                      if (v103 <= &v91 && &v103[6 * v31] > &v91)
                      {
                        int64_t v84 = (char *)&v91 - (char *)v103;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                        long long v33 = v103;
                        uint64_t v32 = (int *)((char *)v103 + v84);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                        uint64_t v32 = &v91;
                        long long v33 = v103;
                      }
                    }
                    long long v34 = &v33[6 * v104];
                    long long v35 = *(_OWORD *)v32;
                    *((void *)v34 + 2) = *((void *)v32 + 2);
                    *(_OWORD *)long long v34 = v35;
                    uint64_t v36 = ++v104;
                    if (v102[0])
                    {
                      int v91 = 3;
                      int64_t v92 = ", ";
                      uint64_t v93 = 2;
                      uint64_t v37 = &v91;
                      v38 = v103;
                      if (v36 >= v105)
                      {
                        unint64_t v75 = v36 + 1;
                        BOOL v76 = &v103[6 * v36] > &v91;
                        if (v103 <= &v91 && v76)
                        {
                          int64_t v85 = (char *)&v91 - (char *)v103;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                          v38 = v103;
                          uint64_t v37 = (int *)((char *)v103 + v85);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                          uint64_t v37 = &v91;
                          v38 = v103;
                        }
                      }
                      long long v39 = &v38[6 * v104];
                      long long v40 = *(_OWORD *)v37;
                      *((void *)v39 + 2) = *((void *)v37 + 2);
                      *(_OWORD *)long long v39 = v40;
                      uint64_t v41 = ++v104;
                      if (v102[0])
                      {
                        int v91 = 3;
                        int64_t v92 = "offsetCorners";
                        uint64_t v93 = 13;
                        uint64_t v42 = &v91;
                        uint64_t v43 = v103;
                        if (v41 >= v105)
                        {
                          unint64_t v77 = v41 + 1;
                          BOOL v78 = &v103[6 * v41] > &v91;
                          if (v103 <= &v91 && v78)
                          {
                            int64_t v86 = (char *)&v91 - (char *)v103;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                            uint64_t v43 = v103;
                            uint64_t v42 = (int *)((char *)v103 + v86);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                            uint64_t v42 = &v91;
                            uint64_t v43 = v103;
                          }
                        }
                        long long v44 = &v43[6 * v104];
                        long long v45 = *(_OWORD *)v42;
                        *((void *)v44 + 2) = *((void *)v42 + 2);
                        *(_OWORD *)long long v44 = v45;
                        ++v104;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v102);
        if (v102[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v102);
        }
        if (v111)
        {
          long long v46 = v109;
          if (v109)
          {
            uint64_t v47 = v110;
            v48 = v109;
            if (v110 != v109)
            {
              do
                uint64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
              while (v47 != v46);
              v48 = v109;
            }
            BOOL v110 = v46;
            operator delete(v48);
          }
          uint64_t v49 = v107;
          if (v107)
          {
            uint64_t v50 = v108;
            long long v51 = v107;
            if (v108 != v107)
            {
              do
              {
                uint64_t v53 = *--v50;
                uint64_t v52 = v53;
                *uint64_t v50 = 0;
                if (v53) {
                  MEMORY[0x21667D390](v52, 0x1000C8077774924);
                }
              }
              while (v50 != v49);
              long long v51 = v107;
            }
            BOOL v108 = v49;
            operator delete(v51);
          }
          if (v103 != (int *)v106) {
            free(v103);
          }
        }
        goto LABEL_57;
      }
      unsigned int v4 = 0;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v87[0] = v4;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v102[0] = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id;
      v102[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::CropResizeAlignmentModeAttrStorage,mlir::mps::CropResizeAlignmentMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail34CropResizeAlignmentModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_27CropResizeAlignmentModeAttrEJNS2_23CropResizeAlignmentModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v102, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id, v87);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::CropResizeAlignmentModeAttr::print(mlir::mps::CropResizeAlignmentModeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) != v5)
  {
    *unsigned int v5 = 60;
    ++*((void *)v4 + 4);
    int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6) {
      goto LABEL_3;
    }
LABEL_11:
    BOOL v7 = 0;
    long long v9 = "defaultAlignment";
    size_t v8 = 16;
    goto LABEL_13;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  int v6 = *(_DWORD *)(*(void *)this + 8);
  if (!v6) {
    goto LABEL_11;
  }
LABEL_3:
  if (v6 == 2)
  {
    BOOL v7 = 0;
    long long v9 = "offsetCorners";
    size_t v8 = 13;
  }
  else
  {
    BOOL v7 = v6 != 1;
    if (v6 == 1) {
      size_t v8 = 12;
    }
    else {
      size_t v8 = 0;
    }
    if (v6 == 1) {
      long long v9 = "alignCorners";
    }
    else {
      long long v9 = &byte_211F4AA5D;
    }
  }
LABEL_13:
  long long v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v11 = (void *)*((void *)v10 + 4);
  if (v8 <= *((void *)v10 + 3) - (void)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((void *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    *long long v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::CropResizeCoordinateModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::CropResizeCoordinateModeAttrStorage,mlir::mps::CropResizeCoordinateMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail35CropResizeCoordinateModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_28CropResizeCoordinateModeAttrEJNS2_24CropResizeCoordinateModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::CropResizeCoordinateModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v131 = *MEMORY[0x263EF8340];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    uint64_t v108 = 0;
    uint64_t v109 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v108))
    {
LABEL_74:
      uint64_t v69 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v123) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v113, a1, v69, v121);
      if (v113[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
      }
      if (v120)
      {
        BOOL v70 = __p;
        if (__p)
        {
          unint64_t v71 = v119;
          BOOL v72 = __p;
          if (v119 != __p)
          {
            do
              unint64_t v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
            while (v71 != v70);
            BOOL v72 = __p;
          }
          unint64_t v119 = v70;
          operator delete(v72);
        }
        unint64_t v73 = v116;
        if (v116)
        {
          unint64_t v74 = v117;
          unint64_t v75 = v116;
          if (v117 != v116)
          {
            do
            {
              uint64_t v77 = *--v74;
              uint64_t v76 = v77;
              *unint64_t v74 = 0;
              if (v77) {
                MEMORY[0x21667D390](v76, 0x1000C8077774924);
              }
            }
            while (v74 != v73);
            unint64_t v75 = v116;
          }
          unint64_t v117 = v73;
          operator delete(v75);
        }
        if (v114 != &v115) {
          free(v114);
        }
      }
      return 0;
    }
    if (v109 == 17)
    {
      if (*(void *)v108 == 0x577372656E726F63
        && *(void *)(v108 + 8) == 0x7372694668746469
        && *(unsigned char *)(v108 + 16) == 116)
      {
        unsigned int v7 = 1;
      }
      else
      {
        if (*(void *)v108 != 0x57737265746E6563
          || *(void *)(v108 + 8) != 0x7372694668746469
          || *(unsigned char *)(v108 + 16) != 116)
        {
          goto LABEL_35;
        }
        unsigned int v7 = 3;
      }
    }
    else
    {
      if (v109 != 18)
      {
LABEL_35:
        __int16 v107 = 257;
        (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v121, a1, v2, v106);
        if (v121[0])
        {
          int v110 = 3;
          char v111 = "expected ";
          uint64_t v112 = 9;
          uint64_t v12 = &v110;
          long long v13 = v122;
          if (v123 >= v124)
          {
            unint64_t v81 = v123 + 1;
            if (v122 <= &v110 && &v122[6 * v123] > &v110)
            {
              int64_t v96 = (char *)&v110 - (char *)v122;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v81, 24);
              long long v13 = v122;
              uint64_t v12 = (int *)((char *)v122 + v96);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v81, 24);
              uint64_t v12 = &v110;
              long long v13 = v122;
            }
          }
          long long v14 = &v13[6 * v123];
          long long v15 = *(_OWORD *)v12;
          *((void *)v14 + 2) = *((void *)v12 + 2);
          *(_OWORD *)long long v14 = v15;
          uint64_t v16 = ++v123;
          if (v121[0])
          {
            int v110 = 3;
            char v111 = "::mlir::mps::CropResizeCoordinateMode";
            uint64_t v112 = 37;
            uint64_t v17 = &v110;
            long long v18 = v122;
            if (v16 >= v124)
            {
              unint64_t v82 = v16 + 1;
              BOOL v83 = &v122[6 * v16] > &v110;
              if (v122 <= &v110 && v83)
              {
                int64_t v97 = (char *)&v110 - (char *)v122;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v82, 24);
                long long v18 = v122;
                uint64_t v17 = (int *)((char *)v122 + v97);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v82, 24);
                uint64_t v17 = &v110;
                long long v18 = v122;
              }
            }
            long long v19 = &v18[6 * v123];
            long long v20 = *(_OWORD *)v17;
            *((void *)v19 + 2) = *((void *)v17 + 2);
            *(_OWORD *)long long v19 = v20;
            uint64_t v21 = ++v123;
            if (v121[0])
            {
              int v110 = 3;
              char v111 = " to be one of: ";
              uint64_t v112 = 15;
              uint64_t v22 = &v110;
              long long v23 = v122;
              if (v21 >= v124)
              {
                unint64_t v84 = v21 + 1;
                BOOL v85 = &v122[6 * v21] > &v110;
                if (v122 <= &v110 && v85)
                {
                  int64_t v98 = (char *)&v110 - (char *)v122;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v84, 24);
                  long long v23 = v122;
                  uint64_t v22 = (int *)((char *)v122 + v98);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v84, 24);
                  uint64_t v22 = &v110;
                  long long v23 = v122;
                }
              }
              long long v24 = &v23[6 * v123];
              long long v25 = *(_OWORD *)v22;
              *((void *)v24 + 2) = *((void *)v22 + 2);
              *(_OWORD *)long long v24 = v25;
              uint64_t v26 = ++v123;
              if (v121[0])
              {
                int v110 = 3;
                char v111 = "cornersHeightFirst";
                uint64_t v112 = 18;
                uint64_t v27 = &v110;
                long long v28 = v122;
                if (v26 >= v124)
                {
                  unint64_t v86 = v26 + 1;
                  BOOL v87 = &v122[6 * v26] > &v110;
                  if (v122 <= &v110 && v87)
                  {
                    int64_t v99 = (char *)&v110 - (char *)v122;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v86, 24);
                    long long v28 = v122;
                    uint64_t v27 = (int *)((char *)v122 + v99);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v86, 24);
                    uint64_t v27 = &v110;
                    long long v28 = v122;
                  }
                }
                long long v29 = &v28[6 * v123];
                long long v30 = *(_OWORD *)v27;
                *((void *)v29 + 2) = *((void *)v27 + 2);
                *(_OWORD *)long long v29 = v30;
                uint64_t v31 = ++v123;
                if (v121[0])
                {
                  int v110 = 3;
                  char v111 = ", ";
                  uint64_t v112 = 2;
                  uint64_t v32 = &v110;
                  long long v33 = v122;
                  if (v31 >= v124)
                  {
                    unint64_t v88 = v31 + 1;
                    if (v122 <= &v110 && &v122[6 * v31] > &v110)
                    {
                      int64_t v100 = (char *)&v110 - (char *)v122;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v88, 24);
                      long long v33 = v122;
                      uint64_t v32 = (int *)((char *)v122 + v100);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v88, 24);
                      uint64_t v32 = &v110;
                      long long v33 = v122;
                    }
                  }
                  long long v34 = &v33[6 * v123];
                  long long v35 = *(_OWORD *)v32;
                  *((void *)v34 + 2) = *((void *)v32 + 2);
                  *(_OWORD *)long long v34 = v35;
                  uint64_t v36 = ++v123;
                  if (v121[0])
                  {
                    int v110 = 3;
                    char v111 = "cornersWidthFirst";
                    uint64_t v112 = 17;
                    uint64_t v37 = &v110;
                    v38 = v122;
                    if (v36 >= v124)
                    {
                      unint64_t v89 = v36 + 1;
                      if (v122 <= &v110 && &v122[6 * v36] > &v110)
                      {
                        int64_t v101 = (char *)&v110 - (char *)v122;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v89, 24);
                        v38 = v122;
                        uint64_t v37 = (int *)((char *)v122 + v101);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v89, 24);
                        uint64_t v37 = &v110;
                        v38 = v122;
                      }
                    }
                    long long v39 = &v38[6 * v123];
                    long long v40 = *(_OWORD *)v37;
                    *((void *)v39 + 2) = *((void *)v37 + 2);
                    *(_OWORD *)long long v39 = v40;
                    uint64_t v41 = ++v123;
                    if (v121[0])
                    {
                      int v110 = 3;
                      char v111 = ", ";
                      uint64_t v112 = 2;
                      uint64_t v42 = &v110;
                      uint64_t v43 = v122;
                      if (v41 >= v124)
                      {
                        unint64_t v90 = v41 + 1;
                        if (v122 <= &v110 && &v122[6 * v41] > &v110)
                        {
                          int64_t v102 = (char *)&v110 - (char *)v122;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v90, 24);
                          uint64_t v43 = v122;
                          uint64_t v42 = (int *)((char *)v122 + v102);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v90, 24);
                          uint64_t v42 = &v110;
                          uint64_t v43 = v122;
                        }
                      }
                      long long v44 = &v43[6 * v123];
                      long long v45 = *(_OWORD *)v42;
                      *((void *)v44 + 2) = *((void *)v42 + 2);
                      *(_OWORD *)long long v44 = v45;
                      uint64_t v46 = ++v123;
                      if (v121[0])
                      {
                        int v110 = 3;
                        char v111 = "centersHeightFirst";
                        uint64_t v112 = 18;
                        uint64_t v47 = &v110;
                        v48 = v122;
                        if (v46 >= v124)
                        {
                          unint64_t v91 = v46 + 1;
                          if (v122 <= &v110 && &v122[6 * v46] > &v110)
                          {
                            int64_t v103 = (char *)&v110 - (char *)v122;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v91, 24);
                            v48 = v122;
                            uint64_t v47 = (int *)((char *)v122 + v103);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v91, 24);
                            uint64_t v47 = &v110;
                            v48 = v122;
                          }
                        }
                        uint64_t v49 = &v48[6 * v123];
                        long long v50 = *(_OWORD *)v47;
                        *((void *)v49 + 2) = *((void *)v47 + 2);
                        *(_OWORD *)uint64_t v49 = v50;
                        uint64_t v51 = ++v123;
                        if (v121[0])
                        {
                          int v110 = 3;
                          char v111 = ", ";
                          uint64_t v112 = 2;
                          uint64_t v52 = &v110;
                          uint64_t v53 = v122;
                          if (v51 >= v124)
                          {
                            unint64_t v92 = v51 + 1;
                            BOOL v93 = &v122[6 * v51] > &v110;
                            if (v122 <= &v110 && v93)
                            {
                              int64_t v104 = (char *)&v110 - (char *)v122;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v92, 24);
                              uint64_t v53 = v122;
                              uint64_t v52 = (int *)((char *)v122 + v104);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v92, 24);
                              uint64_t v52 = &v110;
                              uint64_t v53 = v122;
                            }
                          }
                          uint64_t v54 = &v53[6 * v123];
                          long long v55 = *(_OWORD *)v52;
                          *((void *)v54 + 2) = *((void *)v52 + 2);
                          *(_OWORD *)uint64_t v54 = v55;
                          uint64_t v56 = ++v123;
                          if (v121[0])
                          {
                            int v110 = 3;
                            char v111 = "centersWidthFirst";
                            uint64_t v112 = 17;
                            uint64_t v57 = &v110;
                            uint64_t v58 = v122;
                            if (v56 >= v124)
                            {
                              unint64_t v94 = v56 + 1;
                              BOOL v95 = &v122[6 * v56] > &v110;
                              if (v122 <= &v110 && v95)
                              {
                                int64_t v105 = (char *)&v110 - (char *)v122;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v94, 24);
                                uint64_t v58 = v122;
                                uint64_t v57 = (int *)((char *)v122 + v105);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v94, 24);
                                uint64_t v57 = &v110;
                                uint64_t v58 = v122;
                              }
                            }
                            uint64_t v59 = &v58[6 * v123];
                            long long v60 = *(_OWORD *)v57;
                            *((void *)v59 + 2) = *((void *)v57 + 2);
                            *(_OWORD *)uint64_t v59 = v60;
                            ++v123;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v121);
        if (v121[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v121);
        }
        if (v130)
        {
          uint64_t v61 = v128;
          if (v128)
          {
            uint64_t v62 = v129;
            BOOL v63 = v128;
            if (v129 != v128)
            {
              do
                uint64_t v62 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v62 - 1);
              while (v62 != v61);
              BOOL v63 = v128;
            }
            unint64_t v129 = v61;
            operator delete(v63);
          }
          unint64_t v64 = v126;
          if (v126)
          {
            BOOL v65 = v127;
            unint64_t v66 = v126;
            if (v127 != v126)
            {
              do
              {
                uint64_t v68 = *--v65;
                uint64_t v67 = v68;
                *BOOL v65 = 0;
                if (v68) {
                  MEMORY[0x21667D390](v67, 0x1000C8077774924);
                }
              }
              while (v65 != v64);
              unint64_t v66 = v126;
            }
            unint64_t v127 = v64;
            operator delete(v66);
          }
          if (v122 != (int *)v125) {
            free(v122);
          }
        }
        goto LABEL_74;
      }
      if (*(void *)v108 == 0x487372656E726F63
        && *(void *)(v108 + 8) == 0x7269467468676965
        && *(_WORD *)(v108 + 16) == 29811)
      {
        unsigned int v7 = 0;
      }
      else
      {
        if (*(void *)v108 != 0x48737265746E6563
          || *(void *)(v108 + 8) != 0x7269467468676965
          || *(_WORD *)(v108 + 16) != 29811)
        {
          goto LABEL_35;
        }
        unsigned int v7 = 2;
      }
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v106[0] = v7;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v121[0] = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id;
      v121[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::CropResizeCoordinateModeAttrStorage,mlir::mps::CropResizeCoordinateMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail35CropResizeCoordinateModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_28CropResizeCoordinateModeAttrEJNS2_24CropResizeCoordinateModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v121, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id, v106);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::CropResizeCoordinateModeAttr::print(mlir::mps::CropResizeCoordinateModeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6 > 3)
    {
LABEL_6:
      size_t v9 = 0;
      size_t v8 = &byte_211F4AA5D;
      char v7 = 1;
      goto LABEL_10;
    }
  }
  else
  {
    *unsigned int v5 = 60;
    ++*((void *)v4 + 4);
    unsigned int v6 = *(_DWORD *)(*(void *)this + 8);
  }
  char v7 = 0;
  size_t v8 = "cornersHeightFirst";
  size_t v9 = 18;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      char v7 = 0;
      size_t v8 = "cornersWidthFirst";
      goto LABEL_9;
    case 2u:
      char v7 = 0;
      size_t v8 = "centersHeightFirst";
      size_t v9 = 18;
      break;
    case 3u:
      char v7 = 0;
      size_t v8 = "centersWidthFirst";
LABEL_9:
      size_t v9 = 17;
      break;
    default:
      goto LABEL_6;
  }
LABEL_10:
  long long v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v11 = (void *)*((void *)v10 + 4);
  if (v9 <= *((void *)v10 + 3) - (void)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((void *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    *long long v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::PruningMetricAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::PruningMetricAttrStorage,mlir::mps::PruningMetric>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24PruningMetricAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17PruningMetricAttrEJNS2_13PruningMetricEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id, &v5);
}

uint64_t mlir::mps::PruningMetricAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v80 = *MEMORY[0x263EF8340];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    uint64_t v57 = 0;
    uint64_t v58 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v57))
    {
LABEL_38:
      uint64_t v32 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v72) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v62, a1, v32, v70);
      if (v62[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v62);
      }
      if (v69)
      {
        long long v33 = __p;
        if (__p)
        {
          long long v34 = v68;
          long long v35 = __p;
          if (v68 != __p)
          {
            do
              long long v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
            while (v34 != v33);
            long long v35 = __p;
          }
          uint64_t v68 = v33;
          operator delete(v35);
        }
        uint64_t v36 = v65;
        if (v65)
        {
          uint64_t v37 = v66;
          v38 = v65;
          if (v66 != v65)
          {
            do
            {
              uint64_t v40 = *--v37;
              uint64_t v39 = v40;
              void *v37 = 0;
              if (v40) {
                MEMORY[0x21667D390](v39, 0x1000C8077774924);
              }
            }
            while (v37 != v36);
            v38 = v65;
          }
          unint64_t v66 = v36;
          operator delete(v38);
        }
        if (v63 != &v64) {
          free(v63);
        }
      }
      return 0;
    }
    if (v58 != 17
      || (*(void *)v57 == 0x647574696E67616DLL ? (BOOL v3 = *(void *)(v57 + 8) == 0x6E696E7572705F65) : (BOOL v3 = 0),
          v3 ? (BOOL v4 = *(unsigned char *)(v57 + 16) == 103) : (BOOL v4 = 0),
          !v4))
    {
      __int16 v56 = 257;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v70, a1, v2, v55);
      if (v70[0])
      {
        int v59 = 3;
        long long v60 = "expected ";
        uint64_t v61 = 9;
        unsigned int v5 = &v59;
        unsigned int v6 = v71;
        if (v72 >= v73)
        {
          unint64_t v44 = v72 + 1;
          if (v71 <= &v59 && &v71[6 * v72] > &v59)
          {
            int64_t v51 = (char *)&v59 - (char *)v71;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v44, 24);
            unsigned int v6 = v71;
            unsigned int v5 = (int *)((char *)v71 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v44, 24);
            unsigned int v5 = &v59;
            unsigned int v6 = v71;
          }
        }
        char v7 = &v6[6 * v72];
        long long v8 = *(_OWORD *)v5;
        *((void *)v7 + 2) = *((void *)v5 + 2);
        *(_OWORD *)char v7 = v8;
        uint64_t v9 = ++v72;
        if (v70[0])
        {
          int v59 = 3;
          long long v60 = "::mlir::mps::PruningMetric";
          uint64_t v61 = 26;
          long long v10 = &v59;
          uint64_t v11 = v71;
          if (v9 >= v73)
          {
            unint64_t v45 = v9 + 1;
            BOOL v46 = &v71[6 * v9] > &v59;
            if (v71 <= &v59 && v46)
            {
              int64_t v52 = (char *)&v59 - (char *)v71;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v45, 24);
              uint64_t v11 = v71;
              long long v10 = (int *)((char *)v71 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v45, 24);
              long long v10 = &v59;
              uint64_t v11 = v71;
            }
          }
          uint64_t v12 = &v11[6 * v72];
          long long v13 = *(_OWORD *)v10;
          *((void *)v12 + 2) = *((void *)v10 + 2);
          *(_OWORD *)uint64_t v12 = v13;
          uint64_t v14 = ++v72;
          if (v70[0])
          {
            int v59 = 3;
            long long v60 = " to be one of: ";
            uint64_t v61 = 15;
            long long v15 = &v59;
            uint64_t v16 = v71;
            if (v14 >= v73)
            {
              unint64_t v47 = v14 + 1;
              BOOL v48 = &v71[6 * v14] > &v59;
              if (v71 <= &v59 && v48)
              {
                int64_t v53 = (char *)&v59 - (char *)v71;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v47, 24);
                uint64_t v16 = v71;
                long long v15 = (int *)((char *)v71 + v53);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v47, 24);
                long long v15 = &v59;
                uint64_t v16 = v71;
              }
            }
            uint64_t v17 = &v16[6 * v72];
            long long v18 = *(_OWORD *)v15;
            *((void *)v17 + 2) = *((void *)v15 + 2);
            *(_OWORD *)uint64_t v17 = v18;
            uint64_t v19 = ++v72;
            if (v70[0])
            {
              int v59 = 3;
              long long v60 = "magnitude_pruning";
              uint64_t v61 = 17;
              long long v20 = &v59;
              uint64_t v21 = v71;
              if (v19 >= v73)
              {
                unint64_t v49 = v19 + 1;
                BOOL v50 = &v71[6 * v19] > &v59;
                if (v71 <= &v59 && v50)
                {
                  int64_t v54 = (char *)&v59 - (char *)v71;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v49, 24);
                  uint64_t v21 = v71;
                  long long v20 = (int *)((char *)v71 + v54);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v49, 24);
                  long long v20 = &v59;
                  uint64_t v21 = v71;
                }
              }
              uint64_t v22 = &v21[6 * v72];
              long long v23 = *(_OWORD *)v20;
              *((void *)v22 + 2) = *((void *)v20 + 2);
              *(_OWORD *)uint64_t v22 = v23;
              ++v72;
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v70);
      if (v70[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v70);
      }
      if (v79)
      {
        long long v24 = v77;
        if (v77)
        {
          long long v25 = v78;
          uint64_t v26 = v77;
          if (v78 != v77)
          {
            do
              long long v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
            while (v25 != v24);
            uint64_t v26 = v77;
          }
          BOOL v78 = v24;
          operator delete(v26);
        }
        uint64_t v27 = v75;
        if (v75)
        {
          long long v28 = v76;
          long long v29 = v75;
          if (v76 != v75)
          {
            do
            {
              uint64_t v31 = *--v28;
              uint64_t v30 = v31;
              *long long v28 = 0;
              if (v31) {
                MEMORY[0x21667D390](v30, 0x1000C8077774924);
              }
            }
            while (v28 != v27);
            long long v29 = v75;
          }
          uint64_t v76 = v27;
          operator delete(v29);
        }
        if (v71 != (int *)v74) {
          free(v71);
        }
      }
      goto LABEL_38;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v55[0] = 0;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v70[0] = &mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id;
      v70[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::PruningMetricAttrStorage,mlir::mps::PruningMetric>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24PruningMetricAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17PruningMetricAttrEJNS2_13PruningMetricEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v70, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id, v55);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::PruningMetricAttr::print(mlir::mps::PruningMetricAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  BOOL v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    *unsigned int v5 = 60;
    ++*((void *)v4 + 4);
  }
  int v6 = *(_DWORD *)(*(void *)this + 8);
  if (v6) {
    size_t v7 = 0;
  }
  else {
    size_t v7 = 17;
  }
  long long v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v9 = *((void *)v8 + 4);
  if (v7 <= *((void *)v8 + 3) - v9)
  {
    if (!v6)
    {
      *(unsigned char *)(v9 + 16) = 103;
      *(_OWORD *)uint64_t v9 = *(_OWORD *)"magnitude_pruning";
      *((void *)v8 + 4) += 17;
    }
  }
  else
  {
    if (v6) {
      long long v10 = &byte_211F4AA5D;
    }
    else {
      long long v10 = "magnitude_pruning";
    }
    llvm::raw_ostream::write(v8, v10, v7);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v12 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v12)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v12 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::PruningStructureAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::PruningStructureAttrStorage,mlir::mps::PruningStructure>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27PruningStructureAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20PruningStructureAttrEJNS2_16PruningStructureEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id, &v5);
}

uint64_t mlir::mps::PruningStructureAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v98 = *MEMORY[0x263EF8340];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    uint64_t v75 = 0;
    uint64_t v76 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v75))
    {
LABEL_49:
      uint64_t v44 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v90) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v80, a1, v44, v88);
      if (v80[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v80);
      }
      if (v87)
      {
        unint64_t v45 = __p;
        if (__p)
        {
          BOOL v46 = v86;
          unint64_t v47 = __p;
          if (v86 != __p)
          {
            do
              BOOL v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
            while (v46 != v45);
            unint64_t v47 = __p;
          }
          unint64_t v86 = v45;
          operator delete(v47);
        }
        BOOL v48 = v83;
        if (v83)
        {
          unint64_t v49 = v84;
          BOOL v50 = v83;
          if (v84 != v83)
          {
            do
            {
              uint64_t v52 = *--v49;
              uint64_t v51 = v52;
              *unint64_t v49 = 0;
              if (v52) {
                MEMORY[0x21667D390](v51, 0x1000C8077774924);
              }
            }
            while (v49 != v48);
            BOOL v50 = v83;
          }
          unint64_t v84 = v48;
          operator delete(v50);
        }
        if (v81 != &v82) {
          free(v81);
        }
      }
      return 0;
    }
    if (v76 == 20)
    {
      if (*(void *)v75 != 0x64315F6B636F6C62
        || *(void *)(v75 + 8) != 0x7572705F345F325FLL
        || *(_DWORD *)(v75 + 16) != 1735289198)
      {
        goto LABEL_18;
      }
      unsigned int v4 = 1;
    }
    else
    {
      if (v76 != 14
        || (*(void *)v75 == 0x705F6D6F646E6172 ? (BOOL v3 = *(void *)(v75 + 6) == 0x676E696E7572705FLL) : (BOOL v3 = 0), !v3))
      {
LABEL_18:
        __int16 v74 = 257;
        (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v88, a1, v2, v73);
        if (v88[0])
        {
          int v77 = 3;
          BOOL v78 = "expected ";
          uint64_t v79 = 9;
          size_t v7 = &v77;
          long long v8 = v89;
          if (v90 >= v91)
          {
            unint64_t v56 = v90 + 1;
            if (v89 <= &v77 && &v89[6 * v90] > &v77)
            {
              int64_t v67 = (char *)&v77 - (char *)v89;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v56, 24);
              long long v8 = v89;
              size_t v7 = (int *)((char *)v89 + v67);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v56, 24);
              size_t v7 = &v77;
              long long v8 = v89;
            }
          }
          uint64_t v9 = &v8[6 * v90];
          long long v10 = *(_OWORD *)v7;
          *((void *)v9 + 2) = *((void *)v7 + 2);
          *(_OWORD *)uint64_t v9 = v10;
          uint64_t v11 = ++v90;
          if (v88[0])
          {
            int v77 = 3;
            BOOL v78 = "::mlir::mps::PruningStructure";
            uint64_t v79 = 29;
            uint64_t v12 = &v77;
            long long v13 = v89;
            if (v11 >= v91)
            {
              unint64_t v57 = v11 + 1;
              BOOL v58 = &v89[6 * v11] > &v77;
              if (v89 <= &v77 && v58)
              {
                int64_t v68 = (char *)&v77 - (char *)v89;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v57, 24);
                long long v13 = v89;
                uint64_t v12 = (int *)((char *)v89 + v68);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v57, 24);
                uint64_t v12 = &v77;
                long long v13 = v89;
              }
            }
            uint64_t v14 = &v13[6 * v90];
            long long v15 = *(_OWORD *)v12;
            *((void *)v14 + 2) = *((void *)v12 + 2);
            *(_OWORD *)uint64_t v14 = v15;
            uint64_t v16 = ++v90;
            if (v88[0])
            {
              int v77 = 3;
              BOOL v78 = " to be one of: ";
              uint64_t v79 = 15;
              uint64_t v17 = &v77;
              long long v18 = v89;
              if (v16 >= v91)
              {
                unint64_t v59 = v16 + 1;
                BOOL v60 = &v89[6 * v16] > &v77;
                if (v89 <= &v77 && v60)
                {
                  int64_t v69 = (char *)&v77 - (char *)v89;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v59, 24);
                  long long v18 = v89;
                  uint64_t v17 = (int *)((char *)v89 + v69);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v59, 24);
                  uint64_t v17 = &v77;
                  long long v18 = v89;
                }
              }
              uint64_t v19 = &v18[6 * v90];
              long long v20 = *(_OWORD *)v17;
              *((void *)v19 + 2) = *((void *)v17 + 2);
              *(_OWORD *)uint64_t v19 = v20;
              uint64_t v21 = ++v90;
              if (v88[0])
              {
                int v77 = 3;
                BOOL v78 = "random_pruning";
                uint64_t v79 = 14;
                uint64_t v22 = &v77;
                long long v23 = v89;
                if (v21 >= v91)
                {
                  unint64_t v61 = v21 + 1;
                  BOOL v62 = &v89[6 * v21] > &v77;
                  if (v89 <= &v77 && v62)
                  {
                    int64_t v70 = (char *)&v77 - (char *)v89;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v61, 24);
                    long long v23 = v89;
                    uint64_t v22 = (int *)((char *)v89 + v70);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v61, 24);
                    uint64_t v22 = &v77;
                    long long v23 = v89;
                  }
                }
                long long v24 = &v23[6 * v90];
                long long v25 = *(_OWORD *)v22;
                *((void *)v24 + 2) = *((void *)v22 + 2);
                *(_OWORD *)long long v24 = v25;
                uint64_t v26 = ++v90;
                if (v88[0])
                {
                  int v77 = 3;
                  BOOL v78 = ", ";
                  uint64_t v79 = 2;
                  uint64_t v27 = &v77;
                  long long v28 = v89;
                  if (v26 >= v91)
                  {
                    unint64_t v63 = v26 + 1;
                    BOOL v64 = &v89[6 * v26] > &v77;
                    if (v89 <= &v77 && v64)
                    {
                      int64_t v71 = (char *)&v77 - (char *)v89;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v63, 24);
                      long long v28 = v89;
                      uint64_t v27 = (int *)((char *)v89 + v71);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v63, 24);
                      uint64_t v27 = &v77;
                      long long v28 = v89;
                    }
                  }
                  long long v29 = &v28[6 * v90];
                  long long v30 = *(_OWORD *)v27;
                  *((void *)v29 + 2) = *((void *)v27 + 2);
                  *(_OWORD *)long long v29 = v30;
                  uint64_t v31 = ++v90;
                  if (v88[0])
                  {
                    int v77 = 3;
                    BOOL v78 = "block_1d_2_4_pruning";
                    uint64_t v79 = 20;
                    uint64_t v32 = &v77;
                    long long v33 = v89;
                    if (v31 >= v91)
                    {
                      unint64_t v65 = v31 + 1;
                      BOOL v66 = &v89[6 * v31] > &v77;
                      if (v89 <= &v77 && v66)
                      {
                        int64_t v72 = (char *)&v77 - (char *)v89;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v65, 24);
                        long long v33 = v89;
                        uint64_t v32 = (int *)((char *)v89 + v72);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v65, 24);
                        uint64_t v32 = &v77;
                        long long v33 = v89;
                      }
                    }
                    long long v34 = &v33[6 * v90];
                    long long v35 = *(_OWORD *)v32;
                    *((void *)v34 + 2) = *((void *)v32 + 2);
                    *(_OWORD *)long long v34 = v35;
                    ++v90;
                  }
                }
              }
            }
          }
        }
        mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v88);
        if (v88[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v88);
        }
        if (v97)
        {
          uint64_t v36 = v95;
          if (v95)
          {
            uint64_t v37 = v96;
            v38 = v95;
            if (v96 != v95)
            {
              do
                uint64_t v37 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v37 - 1);
              while (v37 != v36);
              v38 = v95;
            }
            int64_t v96 = v36;
            operator delete(v38);
          }
          uint64_t v39 = v93;
          if (v93)
          {
            uint64_t v40 = v94;
            uint64_t v41 = v93;
            if (v94 != v93)
            {
              do
              {
                uint64_t v43 = *--v40;
                uint64_t v42 = v43;
                *uint64_t v40 = 0;
                if (v43) {
                  MEMORY[0x21667D390](v42, 0x1000C8077774924);
                }
              }
              while (v40 != v39);
              uint64_t v41 = v93;
            }
            unint64_t v94 = v39;
            operator delete(v41);
          }
          if (v89 != (int *)v92) {
            free(v89);
          }
        }
        goto LABEL_49;
      }
      unsigned int v4 = 0;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v73[0] = v4;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v88[0] = &mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id;
      v88[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::PruningStructureAttrStorage,mlir::mps::PruningStructure>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27PruningStructureAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20PruningStructureAttrEJNS2_16PruningStructureEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v88, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id, v73);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::PruningStructureAttr::print(mlir::mps::PruningStructureAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    *unsigned int v5 = 60;
    ++*((void *)v4 + 4);
  }
  int v6 = *(_DWORD *)(*(void *)this + 8);
  size_t v7 = &byte_211F4AA5D;
  uint64_t v8 = 20;
  if (v6 == 1) {
    size_t v7 = "block_1d_2_4_pruning";
  }
  else {
    uint64_t v8 = 0;
  }
  if (v6) {
    BOOL v9 = v6 != 1;
  }
  else {
    BOOL v9 = 0;
  }
  if (v6) {
    size_t v10 = v8;
  }
  else {
    size_t v10 = 14;
  }
  if (v6) {
    uint64_t v11 = v7;
  }
  else {
    uint64_t v11 = "random_pruning";
  }
  uint64_t v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (void *)*((void *)v12 + 4);
  if (v10 <= *((void *)v12 + 3) - (void)v13)
  {
    if (!v9)
    {
      memcpy(v13, v11, v10);
      *((void *)v12 + 4) += v10;
    }
  }
  else
  {
    llvm::raw_ostream::write(v12, v11, v10);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v15 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v15)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v15 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::SimilarityTypeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::SimilarityTypeAttrStorage,mlir::mps::SimilarityType>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25SimilarityTypeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18SimilarityTypeAttrEJNS2_14SimilarityTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id, &v5);
}

uint64_t mlir::mps::SimilarityTypeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v96 = *MEMORY[0x263EF8340];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    unsigned int v73 = 0;
    uint64_t v74 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v73))
    {
LABEL_43:
      uint64_t v42 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v88) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v78, a1, v42, v86);
      if (v78[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v78);
      }
      if (v85)
      {
        uint64_t v43 = __p;
        if (__p)
        {
          uint64_t v44 = v84;
          unint64_t v45 = __p;
          if (v84 != __p)
          {
            do
              uint64_t v44 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v44 - 1);
            while (v44 != v43);
            unint64_t v45 = __p;
          }
          unint64_t v84 = v43;
          operator delete(v45);
        }
        BOOL v46 = v81;
        if (v81)
        {
          unint64_t v47 = v82;
          BOOL v48 = v81;
          if (v82 != v81)
          {
            do
            {
              uint64_t v50 = *--v47;
              uint64_t v49 = v50;
              void *v47 = 0;
              if (v50) {
                MEMORY[0x21667D390](v49, 0x1000C8077774924);
              }
            }
            while (v47 != v46);
            BOOL v48 = v81;
          }
          uint64_t v82 = v46;
          operator delete(v48);
        }
        if (v79 != &v80) {
          free(v79);
        }
      }
      return 0;
    }
    if (v74 == 8)
    {
      if (*v73 != 0x666669645F736261)
      {
LABEL_12:
        __int16 v72 = 257;
        (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v86, a1, v2, v71);
        if (v86[0])
        {
          int v75 = 3;
          uint64_t v76 = "expected ";
          uint64_t v77 = 9;
          unsigned int v5 = &v75;
          int v6 = v87;
          if (v88 >= v89)
          {
            unint64_t v54 = v88 + 1;
            if (v87 <= &v75 && &v87[6 * v88] > &v75)
            {
              int64_t v65 = (char *)&v75 - (char *)v87;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v54, 24);
              int v6 = v87;
              unsigned int v5 = (int *)((char *)v87 + v65);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v54, 24);
              unsigned int v5 = &v75;
              int v6 = v87;
            }
          }
          size_t v7 = &v6[6 * v88];
          long long v8 = *(_OWORD *)v5;
          *((void *)v7 + 2) = *((void *)v5 + 2);
          *(_OWORD *)size_t v7 = v8;
          uint64_t v9 = ++v88;
          if (v86[0])
          {
            int v75 = 3;
            uint64_t v76 = "::mlir::mps::SimilarityType";
            uint64_t v77 = 27;
            size_t v10 = &v75;
            uint64_t v11 = v87;
            if (v9 >= v89)
            {
              unint64_t v55 = v9 + 1;
              BOOL v56 = &v87[6 * v9] > &v75;
              if (v87 <= &v75 && v56)
              {
                int64_t v66 = (char *)&v75 - (char *)v87;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v55, 24);
                uint64_t v11 = v87;
                size_t v10 = (int *)((char *)v87 + v66);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v55, 24);
                size_t v10 = &v75;
                uint64_t v11 = v87;
              }
            }
            uint64_t v12 = &v11[6 * v88];
            long long v13 = *(_OWORD *)v10;
            *((void *)v12 + 2) = *((void *)v10 + 2);
            *(_OWORD *)uint64_t v12 = v13;
            uint64_t v14 = ++v88;
            if (v86[0])
            {
              int v75 = 3;
              uint64_t v76 = " to be one of: ";
              uint64_t v77 = 15;
              long long v15 = &v75;
              uint64_t v16 = v87;
              if (v14 >= v89)
              {
                unint64_t v57 = v14 + 1;
                BOOL v58 = &v87[6 * v14] > &v75;
                if (v87 <= &v75 && v58)
                {
                  int64_t v67 = (char *)&v75 - (char *)v87;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v57, 24);
                  uint64_t v16 = v87;
                  long long v15 = (int *)((char *)v87 + v67);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v57, 24);
                  long long v15 = &v75;
                  uint64_t v16 = v87;
                }
              }
              uint64_t v17 = &v16[6 * v88];
              long long v18 = *(_OWORD *)v15;
              *((void *)v17 + 2) = *((void *)v15 + 2);
              *(_OWORD *)uint64_t v17 = v18;
              uint64_t v19 = ++v88;
              if (v86[0])
              {
                int v75 = 3;
                uint64_t v76 = "dot_product";
                uint64_t v77 = 11;
                long long v20 = &v75;
                uint64_t v21 = v87;
                if (v19 >= v89)
                {
                  unint64_t v59 = v19 + 1;
                  BOOL v60 = &v87[6 * v19] > &v75;
                  if (v87 <= &v75 && v60)
                  {
                    int64_t v68 = (char *)&v75 - (char *)v87;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v59, 24);
                    uint64_t v21 = v87;
                    long long v20 = (int *)((char *)v87 + v68);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v59, 24);
                    long long v20 = &v75;
                    uint64_t v21 = v87;
                  }
                }
                uint64_t v22 = &v21[6 * v88];
                long long v23 = *(_OWORD *)v20;
                *((void *)v22 + 2) = *((void *)v20 + 2);
                *(_OWORD *)uint64_t v22 = v23;
                uint64_t v24 = ++v88;
                if (v86[0])
                {
                  int v75 = 3;
                  uint64_t v76 = ", ";
                  uint64_t v77 = 2;
                  long long v25 = &v75;
                  uint64_t v26 = v87;
                  if (v24 >= v89)
                  {
                    unint64_t v61 = v24 + 1;
                    BOOL v62 = &v87[6 * v24] > &v75;
                    if (v87 <= &v75 && v62)
                    {
                      int64_t v69 = (char *)&v75 - (char *)v87;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v61, 24);
                      uint64_t v26 = v87;
                      long long v25 = (int *)((char *)v87 + v69);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v61, 24);
                      long long v25 = &v75;
                      uint64_t v26 = v87;
                    }
                  }
                  uint64_t v27 = &v26[6 * v88];
                  long long v28 = *(_OWORD *)v25;
                  *((void *)v27 + 2) = *((void *)v25 + 2);
                  *(_OWORD *)uint64_t v27 = v28;
                  uint64_t v29 = ++v88;
                  if (v86[0])
                  {
                    int v75 = 3;
                    uint64_t v76 = "abs_diff";
                    uint64_t v77 = 8;
                    long long v30 = &v75;
                    uint64_t v31 = v87;
                    if (v29 >= v89)
                    {
                      unint64_t v63 = v29 + 1;
                      BOOL v64 = &v87[6 * v29] > &v75;
                      if (v87 <= &v75 && v64)
                      {
                        int64_t v70 = (char *)&v75 - (char *)v87;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v63, 24);
                        uint64_t v31 = v87;
                        long long v30 = (int *)((char *)v87 + v70);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v63, 24);
                        long long v30 = &v75;
                        uint64_t v31 = v87;
                      }
                    }
                    uint64_t v32 = &v31[6 * v88];
                    long long v33 = *(_OWORD *)v30;
                    *((void *)v32 + 2) = *((void *)v30 + 2);
                    *(_OWORD *)uint64_t v32 = v33;
                    ++v88;
                  }
                }
              }
            }
          }
        }
        mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v86);
        if (v86[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v86);
        }
        if (v95)
        {
          long long v34 = v93;
          if (v93)
          {
            long long v35 = v94;
            uint64_t v36 = v93;
            if (v94 != v93)
            {
              do
                long long v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
              while (v35 != v34);
              uint64_t v36 = v93;
            }
            unint64_t v94 = v34;
            operator delete(v36);
          }
          uint64_t v37 = v91;
          if (v91)
          {
            v38 = v92;
            uint64_t v39 = v91;
            if (v92 != v91)
            {
              do
              {
                uint64_t v41 = *--v38;
                uint64_t v40 = v41;
                void *v38 = 0;
                if (v41) {
                  MEMORY[0x21667D390](v40, 0x1000C8077774924);
                }
              }
              while (v38 != v37);
              uint64_t v39 = v91;
            }
            unint64_t v92 = v37;
            operator delete(v39);
          }
          if (v87 != (int *)v90) {
            free(v87);
          }
        }
        goto LABEL_43;
      }
      unsigned int v4 = 1;
    }
    else
    {
      if (v74 != 11) {
        goto LABEL_12;
      }
      if (*v73 != 0x646F72705F746F64 || *(void *)((char *)v73 + 3) != 0x746375646F72705FLL) {
        goto LABEL_12;
      }
      unsigned int v4 = 0;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v71[0] = v4;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v86[0] = &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id;
      v86[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::SimilarityTypeAttrStorage,mlir::mps::SimilarityType>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25SimilarityTypeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18SimilarityTypeAttrEJNS2_14SimilarityTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v86, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id, v71);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::SimilarityTypeAttr::print(mlir::mps::SimilarityTypeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    *unsigned int v5 = 60;
    ++*((void *)v4 + 4);
  }
  int v6 = *(_DWORD *)(*(void *)this + 8);
  size_t v7 = &byte_211F4AA5D;
  uint64_t v8 = 8;
  if (v6 == 1) {
    size_t v7 = "abs_diff";
  }
  else {
    uint64_t v8 = 0;
  }
  if (v6) {
    BOOL v9 = v6 != 1;
  }
  else {
    BOOL v9 = 0;
  }
  if (v6) {
    size_t v10 = v8;
  }
  else {
    size_t v10 = 11;
  }
  if (v6) {
    uint64_t v11 = v7;
  }
  else {
    uint64_t v11 = "dot_product";
  }
  uint64_t v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (void *)*((void *)v12 + 4);
  if (v10 <= *((void *)v12 + 3) - (void)v13)
  {
    if (!v9)
    {
      memcpy(v13, v11, v10);
      *((void *)v12 + 4) += v10;
    }
  }
  else
  {
    llvm::raw_ostream::write(v12, v11, v10);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v15 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v15)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    unsigned char *v15 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::FFTScalingModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::FFTScalingModeAttrStorage,mlir::mps::FFTScalingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25FFTScalingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18FFTScalingModeAttrEJNS2_14FFTScalingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::FFTScalingModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v110 = *MEMORY[0x263EF8340];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1)) {
    return 0;
  }
  uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  char v87 = 0;
  uint64_t v88 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v87))
  {
LABEL_47:
    uint64_t v52 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    LOWORD(v102) = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v92, a1, v52, v100);
    if (v92[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v92);
    }
    if (v99)
    {
      int64_t v53 = __p;
      if (__p)
      {
        unint64_t v54 = v98;
        unint64_t v55 = __p;
        if (v98 != __p)
        {
          do
            unint64_t v54 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v54 - 1);
          while (v54 != v53);
          unint64_t v55 = __p;
        }
        uint64_t v98 = v53;
        operator delete(v55);
      }
      BOOL v56 = v95;
      if (v95)
      {
        unint64_t v57 = v96;
        BOOL v58 = v95;
        if (v96 != v95)
        {
          do
          {
            uint64_t v60 = *--v57;
            uint64_t v59 = v60;
            *unint64_t v57 = 0;
            if (v60) {
              MEMORY[0x21667D390](v59, 0x1000C8077774924);
            }
          }
          while (v57 != v56);
          BOOL v58 = v95;
        }
        uint64_t v96 = v56;
        operator delete(v58);
      }
      if (v93 != &v94) {
        free(v93);
      }
    }
    return 0;
  }
  if (v88 == 7)
  {
    if (*v87 == 1953066613 && *(_DWORD *)((char *)v87 + 3) == 2037539188)
    {
      unsigned int v3 = 2;
      goto LABEL_69;
    }
LABEL_12:
    __int16 v86 = 257;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v100, a1, v2, v85);
    if (v100[0])
    {
      int v89 = 3;
      unsigned int v90 = "expected ";
      uint64_t v91 = 9;
      unsigned int v5 = &v89;
      int v6 = v101;
      if (v102 >= v103)
      {
        unint64_t v64 = v102 + 1;
        if (v101 <= &v89 && &v101[6 * v102] > &v89)
        {
          int64_t v77 = (char *)&v89 - (char *)v101;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v64, 24);
          int v6 = v101;
          unsigned int v5 = (int *)((char *)v101 + v77);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v64, 24);
          unsigned int v5 = &v89;
          int v6 = v101;
        }
      }
      size_t v7 = &v6[6 * v102];
      long long v8 = *(_OWORD *)v5;
      *((void *)v7 + 2) = *((void *)v5 + 2);
      *(_OWORD *)size_t v7 = v8;
      uint64_t v9 = ++v102;
      if (v100[0])
      {
        int v89 = 3;
        unsigned int v90 = "::mlir::mps::FFTScalingMode";
        uint64_t v91 = 27;
        size_t v10 = &v89;
        uint64_t v11 = v101;
        if (v9 >= v103)
        {
          unint64_t v65 = v9 + 1;
          BOOL v66 = &v101[6 * v9] > &v89;
          if (v101 <= &v89 && v66)
          {
            int64_t v78 = (char *)&v89 - (char *)v101;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v65, 24);
            uint64_t v11 = v101;
            size_t v10 = (int *)((char *)v101 + v78);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v65, 24);
            size_t v10 = &v89;
            uint64_t v11 = v101;
          }
        }
        uint64_t v12 = &v11[6 * v102];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = *((void *)v10 + 2);
        *(_OWORD *)uint64_t v12 = v13;
        uint64_t v14 = ++v102;
        if (v100[0])
        {
          int v89 = 3;
          unsigned int v90 = " to be one of: ";
          uint64_t v91 = 15;
          long long v15 = &v89;
          uint64_t v16 = v101;
          if (v14 >= v103)
          {
            unint64_t v67 = v14 + 1;
            BOOL v68 = &v101[6 * v14] > &v89;
            if (v101 <= &v89 && v68)
            {
              int64_t v79 = (char *)&v89 - (char *)v101;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v67, 24);
              uint64_t v16 = v101;
              long long v15 = (int *)((char *)v101 + v79);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v67, 24);
              long long v15 = &v89;
              uint64_t v16 = v101;
            }
          }
          uint64_t v17 = &v16[6 * v102];
          long long v18 = *(_OWORD *)v15;
          *((void *)v17 + 2) = *((void *)v15 + 2);
          *(_OWORD *)uint64_t v17 = v18;
          uint64_t v19 = ++v102;
          if (v100[0])
          {
            int v89 = 3;
            unsigned int v90 = "none";
            uint64_t v91 = 4;
            long long v20 = &v89;
            uint64_t v21 = v101;
            if (v19 >= v103)
            {
              unint64_t v69 = v19 + 1;
              BOOL v70 = &v101[6 * v19] > &v89;
              if (v101 <= &v89 && v70)
              {
                int64_t v80 = (char *)&v89 - (char *)v101;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v69, 24);
                uint64_t v21 = v101;
                long long v20 = (int *)((char *)v101 + v80);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v69, 24);
                long long v20 = &v89;
                uint64_t v21 = v101;
              }
            }
            uint64_t v22 = &v21[6 * v102];
            long long v23 = *(_OWORD *)v20;
            *((void *)v22 + 2) = *((void *)v20 + 2);
            *(_OWORD *)uint64_t v22 = v23;
            uint64_t v24 = ++v102;
            if (v100[0])
            {
              int v89 = 3;
              unsigned int v90 = ", ";
              uint64_t v91 = 2;
              long long v25 = &v89;
              uint64_t v26 = v101;
              if (v24 >= v103)
              {
                unint64_t v71 = v24 + 1;
                if (v101 <= &v89 && &v101[6 * v24] > &v89)
                {
                  int64_t v81 = (char *)&v89 - (char *)v101;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v71, 24);
                  uint64_t v26 = v101;
                  long long v25 = (int *)((char *)v101 + v81);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v71, 24);
                  long long v25 = &v89;
                  uint64_t v26 = v101;
                }
              }
              uint64_t v27 = &v26[6 * v102];
              long long v28 = *(_OWORD *)v25;
              *((void *)v27 + 2) = *((void *)v25 + 2);
              *(_OWORD *)uint64_t v27 = v28;
              uint64_t v29 = ++v102;
              if (v100[0])
              {
                int v89 = 3;
                unsigned int v90 = "size";
                uint64_t v91 = 4;
                long long v30 = &v89;
                uint64_t v31 = v101;
                if (v29 >= v103)
                {
                  unint64_t v72 = v29 + 1;
                  if (v101 <= &v89 && &v101[6 * v29] > &v89)
                  {
                    int64_t v82 = (char *)&v89 - (char *)v101;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v72, 24);
                    uint64_t v31 = v101;
                    long long v30 = (int *)((char *)v101 + v82);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v72, 24);
                    long long v30 = &v89;
                    uint64_t v31 = v101;
                  }
                }
                uint64_t v32 = &v31[6 * v102];
                long long v33 = *(_OWORD *)v30;
                *((void *)v32 + 2) = *((void *)v30 + 2);
                *(_OWORD *)uint64_t v32 = v33;
                uint64_t v34 = ++v102;
                if (v100[0])
                {
                  int v89 = 3;
                  unsigned int v90 = ", ";
                  uint64_t v91 = 2;
                  long long v35 = &v89;
                  uint64_t v36 = v101;
                  if (v34 >= v103)
                  {
                    unint64_t v73 = v34 + 1;
                    BOOL v74 = &v101[6 * v34] > &v89;
                    if (v101 <= &v89 && v74)
                    {
                      int64_t v83 = (char *)&v89 - (char *)v101;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v73, 24);
                      uint64_t v36 = v101;
                      long long v35 = (int *)((char *)v101 + v83);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v73, 24);
                      long long v35 = &v89;
                      uint64_t v36 = v101;
                    }
                  }
                  uint64_t v37 = &v36[6 * v102];
                  long long v38 = *(_OWORD *)v35;
                  *((void *)v37 + 2) = *((void *)v35 + 2);
                  *(_OWORD *)uint64_t v37 = v38;
                  uint64_t v39 = ++v102;
                  if (v100[0])
                  {
                    int v89 = 3;
                    unsigned int v90 = "unitary";
                    uint64_t v91 = 7;
                    uint64_t v40 = &v89;
                    uint64_t v41 = v101;
                    if (v39 >= v103)
                    {
                      unint64_t v75 = v39 + 1;
                      BOOL v76 = &v101[6 * v39] > &v89;
                      if (v101 <= &v89 && v76)
                      {
                        int64_t v84 = (char *)&v89 - (char *)v101;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v75, 24);
                        uint64_t v41 = v101;
                        uint64_t v40 = (int *)((char *)v101 + v84);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v75, 24);
                        uint64_t v40 = &v89;
                        uint64_t v41 = v101;
                      }
                    }
                    uint64_t v42 = &v41[6 * v102];
                    long long v43 = *(_OWORD *)v40;
                    *((void *)v42 + 2) = *((void *)v40 + 2);
                    *(_OWORD *)uint64_t v42 = v43;
                    ++v102;
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v100);
    if (v100[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v100);
    }
    if (v109)
    {
      uint64_t v44 = v107;
      if (v107)
      {
        unint64_t v45 = v108;
        BOOL v46 = v107;
        if (v108 != v107)
        {
          do
            unint64_t v45 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v45 - 1);
          while (v45 != v44);
          BOOL v46 = v107;
        }
        uint64_t v108 = v44;
        operator delete(v46);
      }
      unint64_t v47 = v105;
      if (v105)
      {
        BOOL v48 = v106;
        uint64_t v49 = v105;
        if (v106 != v105)
        {
          do
          {
            uint64_t v51 = *--v48;
            uint64_t v50 = v51;
            void *v48 = 0;
            if (v51) {
              MEMORY[0x21667D390](v50, 0x1000C8077774924);
            }
          }
          while (v48 != v47);
          uint64_t v49 = v105;
        }
        BOOL v106 = v47;
        operator delete(v49);
      }
      if (v101 != (int *)v104) {
        free(v101);
      }
    }
    goto LABEL_47;
  }
  if (v88 != 4) {
    goto LABEL_12;
  }
  if (*v87 != 1701736302)
  {
    if (*v87 == 1702521203)
    {
      unsigned int v3 = 1;
      goto LABEL_69;
    }
    goto LABEL_12;
  }
  unsigned int v3 = 0;
LABEL_69:
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v85[0] = v3;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v100[0] = &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id;
    v100[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::FFTScalingModeAttrStorage,mlir::mps::FFTScalingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25FFTScalingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18FFTScalingModeAttrEJNS2_14FFTScalingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v100, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id, v85);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::FFTScalingModeAttr::print(mlir::mps::FFTScalingModeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) != v5)
  {
    *unsigned int v5 = 60;
    ++*((void *)v4 + 4);
    int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6) {
      goto LABEL_3;
    }
LABEL_11:
    BOOL v7 = 0;
    uint64_t v9 = "none";
    size_t v8 = 4;
    goto LABEL_13;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  int v6 = *(_DWORD *)(*(void *)this + 8);
  if (!v6) {
    goto LABEL_11;
  }
LABEL_3:
  if (v6 == 2)
  {
    BOOL v7 = 0;
    uint64_t v9 = "unitary";
    size_t v8 = 7;
  }
  else
  {
    BOOL v7 = v6 != 1;
    if (v6 == 1) {
      size_t v8 = 4;
    }
    else {
      size_t v8 = 0;
    }
    if (v6 == 1) {
      uint64_t v9 = "size";
    }
    else {
      uint64_t v9 = &byte_211F4AA5D;
    }
  }
LABEL_13:
  size_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v11 = (void *)*((void *)v10 + 4);
  if (v8 <= *((void *)v10 + 3) - (void)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((void *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    *long long v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::MPSBufferTensorAttr::parse(mlir::AsmParser *a1, void *a2)
{
  uint64_t v68 = *MEMORY[0x263EF8340];
  mlir::AsmParser::getContext(a1);
  uint64_t v4 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!a2)
  {
    *(void *)uint64_t v39 = "expected a trailing type";
    __int16 v41 = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned char *))(*(void *)a1 + 24))(v52, a1, v4, v39);
    if (v52[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v52);
    }
    if (!v59) {
      return 0;
    }
    long long v13 = v57;
    if (v57)
    {
      uint64_t v14 = v58;
      long long v15 = v57;
      if (v58 != v57)
      {
        do
          uint64_t v14 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v14 - 1);
        while (v14 != v13);
        long long v15 = v57;
      }
      BOOL v58 = v13;
      operator delete(v15);
    }
    uint64_t v16 = v55;
    if (v55)
    {
      uint64_t v17 = v56;
      long long v18 = v55;
      if (v56 != v55)
      {
        do
        {
          uint64_t v20 = *--v17;
          uint64_t v19 = v20;
          void *v17 = 0;
          if (v20) {
            MEMORY[0x21667D390](v19, 0x1000C8077774924);
          }
        }
        while (v17 != v16);
        long long v18 = v55;
      }
      BOOL v56 = v16;
      operator delete(v18);
    }
    uint64_t v24 = v53;
    if (v53 == &v54) {
      return 0;
    }
    goto LABEL_45;
  }
  if (*(_UNKNOWN **)(*a2 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    *(void *)uint64_t v39 = "invalid kind of type specified";
    __int16 v41 = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned char *))(*(void *)a1 + 24))(v60, a1, v4, v39);
    if (v60[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v60);
    }
    if (!v67) {
      return 0;
    }
    unsigned int v5 = __p;
    if (__p)
    {
      int v6 = v66;
      BOOL v7 = __p;
      if (v66 != __p)
      {
        do
          int v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
        while (v6 != v5);
        BOOL v7 = __p;
      }
      BOOL v66 = v5;
      operator delete(v7);
    }
    size_t v8 = v63;
    if (v63)
    {
      uint64_t v9 = v64;
      size_t v10 = v63;
      if (v64 != v63)
      {
        do
        {
          uint64_t v12 = *--v9;
          uint64_t v11 = v12;
          *uint64_t v9 = 0;
          if (v12) {
            MEMORY[0x21667D390](v11, 0x1000C8077774924);
          }
        }
        while (v9 != v8);
        size_t v10 = v63;
      }
      unint64_t v64 = v8;
      operator delete(v10);
    }
    uint64_t v24 = v61;
    if (v61 == &v62) {
      return 0;
    }
    goto LABEL_45;
  }
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    mlir::AsmParser::parseResourceHandle<mlir::mps::MPSDialectResourceBlobHandle>(a1, (uint64_t)v39);
    char v21 = v39[0];
    *(_OWORD *)uint64_t v51 = *(_OWORD *)&v39[1];
    *(void *)&v51[15] = *(void *)&v39[16];
    uint64_t v22 = *(void *)a1;
    if (v40)
    {
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(v22 + 128))(a1))
      {
        __int16 v41 = 257;
        if (!(*(unsigned __int8 (**)(mlir::AsmParser *, const char *, uint64_t, unsigned char *))(*(void *)a1 + 368))(a1, "handle_offset", 13, v39)|| !(*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 136))(a1))
        {
          return 0;
        }
        *(void *)uint64_t v39 = 0;
        if (!mlir::AsmParser::parseInteger<unsigned long long>((uint64_t)a1, (uint64_t *)v39))
        {
          uint64_t v35 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
          __int16 v41 = 259;
          (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned char *))(*(void *)a1 + 24))(v42, a1, v35, v39);
          mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v42);
          return 0;
        }
        uint64_t v23 = *(void *)v39;
      }
      else
      {
        uint64_t v23 = 0;
      }
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
      {
        uint64_t v37 = a2;
        Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
        v39[0] = v21;
        *(_OWORD *)&v39[1] = *(_OWORD *)v51;
        *(void *)&v39[16] = *(void *)&v51[15];
        uint64_t v36 = v23;
        return mlir::AsmParser::getChecked<mlir::mps::MPSBufferTensorAttr,mlir::MLIRContext *,mlir::RankedTensorType,mlir::mps::MPSDialectResourceBlobHandle,unsigned long long>((uint64_t)a1, v4, &Context, &v37, (uint64_t)v39, &v36);
      }
      return 0;
    }
    uint64_t v26 = (*(uint64_t (**)(mlir::AsmParser *))(v22 + 40))(a1);
    __int16 v41 = 259;
    (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned char *))(*(void *)a1 + 24))(v43, a1, v26, v39);
    if (v43[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v43);
    }
    if (!v50) {
      return 0;
    }
    uint64_t v27 = v48;
    if (v48)
    {
      long long v28 = v49;
      uint64_t v29 = v48;
      if (v49 != v48)
      {
        do
          long long v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v28 - 1);
        while (v28 != v27);
        uint64_t v29 = v48;
      }
      uint64_t v49 = v27;
      operator delete(v29);
    }
    long long v30 = v46;
    if (v46)
    {
      uint64_t v31 = v47;
      uint64_t v32 = v46;
      if (v47 != v46)
      {
        do
        {
          uint64_t v34 = *--v31;
          uint64_t v33 = v34;
          void *v31 = 0;
          if (v34) {
            MEMORY[0x21667D390](v33, 0x1000C8077774924);
          }
        }
        while (v31 != v30);
        uint64_t v32 = v46;
      }
      unint64_t v47 = v30;
      operator delete(v32);
    }
    uint64_t v24 = v44;
    if (v44 == &v45) {
      return 0;
    }
LABEL_45:
    free(v24);
  }
  return 0;
}

void mlir::AsmParser::parseResourceHandle<mlir::mps::MPSDialectResourceBlobHandle>(mlir::AsmParser *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v72 = *MEMORY[0x263EF8340];
  uint64_t v4 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  Context = (char *)mlir::AsmParser::getContext(a1);
  Dialect = mlir::MLIRContext::getOrLoadDialect(Context, (uint64_t)"mps", 3, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MPSDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::mps::MPSDialect * mlir::MLIRContext::getOrLoadDialect<mlir::mps::MPSDialect>(void)::{lambda(void)#1}>, (uint64_t)&Context);
  if (Dialect)
  {
    (*(void (**)(long long *__return_ptr, mlir::AsmParser *, mlir::Dialect *))(*(void *)a1 + 584))(&v50, a1, Dialect);
    if (!v52)
    {
      *(unsigned char *)a2 = 0;
      *(unsigned char *)(a2 + 24) = 0;
      return;
    }
    uint64_t v6 = *((void *)&v50 + 1);
    BOOL v7 = &unk_267775000;
    {
      BOOL v7 = (void *)&unk_267775000;
      if (v39)
      {
        Context = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MPSDialectResourceBlobHandle]";
        unint64_t v62 = 89;
        unint64_t v40 = llvm::StringRef::find((uint64_t *)&Context, "DesiredTypeName = ", 0x12uLL, 0);
        if (v62 >= v40) {
          unint64_t v41 = v40;
        }
        else {
          unint64_t v41 = v62;
        }
        uint64_t v42 = &Context[v41];
        unint64_t v43 = v62 - v41;
        if (v62 - v41 >= 0x12) {
          uint64_t v44 = 18;
        }
        else {
          uint64_t v44 = v62 - v41;
        }
        unint64_t v45 = v43 - v44;
        if (v45 >= v45 - 1) {
          uint64_t v46 = v45 - 1;
        }
        else {
          uint64_t v46 = v45;
        }
        mlir::detail::TypeIDResolver<mlir::mps::MPSDialectResourceBlobHandle,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v42[v44], v46);
        BOOL v7 = (void *)&unk_267775000;
      }
    }
    if (v6 == v7[106])
    {
      *(_OWORD *)a2 = v50;
      *(void *)(a2 + 16) = v51;
      *(unsigned char *)(a2 + 24) = 1;
      return;
    }
    __int16 v57 = 257;
    (*(void (**)(char **__return_ptr, mlir::AsmParser *, uint64_t, void ***))(*(void *)a1 + 24))(&Context, a1, v4, &v54);
    if (Context)
    {
      int v58 = 3;
      char v59 = "provided resource handle differs from the expected resource type";
      uint64_t v60 = 64;
      size_t v8 = &v58;
      uint64_t v9 = (char *)v63;
      if (v64 >= v65)
      {
        unint64_t v37 = v64 + 1;
        if (v63 <= &v58 && (char *)v63 + 24 * v64 > (char *)&v58)
        {
          int64_t v48 = (char *)&v58 - (unsigned char *)v63;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v37, 24);
          uint64_t v9 = (char *)v63;
          size_t v8 = (int *)((char *)v63 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v37, 24);
          size_t v8 = &v58;
          uint64_t v9 = (char *)v63;
        }
      }
      size_t v10 = &v9[24 * v64];
      long long v11 = *(_OWORD *)v8;
      *((void *)v10 + 2) = *((void *)v8 + 2);
      *(_OWORD *)size_t v10 = v11;
      ++v64;
      uint64_t v12 = Context;
      *(unsigned char *)a2 = 0;
      *(unsigned char *)(a2 + 24) = 0;
      if (v12) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Context);
      }
      if (!v71) {
        return;
      }
    }
    else
    {
      *(unsigned char *)a2 = 0;
      *(unsigned char *)(a2 + 24) = 0;
      if (!v71) {
        return;
      }
    }
    long long v30 = __p;
    if (__p)
    {
      uint64_t v31 = v70;
      uint64_t v32 = __p;
      if (v70 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        uint64_t v32 = __p;
      }
      BOOL v70 = v30;
      operator delete(v32);
    }
    long long v25 = v67;
    if (!v67)
    {
LABEL_47:
      if (v63 != v66) {
        free(v63);
      }
      return;
    }
    uint64_t v33 = v68;
    uint64_t v27 = v67;
    if (v68 == v67)
    {
LABEL_46:
      uint64_t v68 = v25;
      operator delete(v27);
      goto LABEL_47;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v25);
LABEL_45:
    uint64_t v27 = v67;
    goto LABEL_46;
  }
  __int16 v53 = 257;
  (*(void (**)(char **__return_ptr, mlir::AsmParser *, uint64_t, long long *))(*(void *)a1 + 24))(&Context, a1, v4, &v50);
  if (!Context) {
    goto LABEL_18;
  }
  LODWORD(v54) = 3;
  unint64_t v55 = "dialect '";
  uint64_t v56 = 9;
  long long v13 = &v54;
  uint64_t v14 = (char *)v63;
  if (v64 >= v65)
  {
    unint64_t v36 = v64 + 1;
    if (v63 <= &v54 && (char *)v63 + 24 * v64 > (char *)&v54)
    {
      int64_t v47 = (char *)&v54 - (unsigned char *)v63;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v36, 24);
      uint64_t v14 = (char *)v63;
      long long v13 = (void ***)((char *)v63 + v47);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v36, 24);
      long long v13 = &v54;
      uint64_t v14 = (char *)v63;
    }
  }
  long long v15 = &v14[24 * v64];
  long long v16 = *(_OWORD *)v13;
  *((void *)v15 + 2) = v13[2];
  *(_OWORD *)long long v15 = v16;
  ++v64;
  if (!Context) {
    goto LABEL_18;
  }
  __int16 v57 = 262;
  uint64_t v54 = (void **)"mps";
  unint64_t v55 = (const char *)3;
  mlir::Diagnostic::operator<<((uint64_t)&v62, &v54);
  if (Context)
  {
    LODWORD(v54) = 3;
    unint64_t v55 = "' is unknown";
    uint64_t v56 = 12;
    uint64_t v17 = &v54;
    long long v18 = (char *)v63;
    if (v64 >= v65)
    {
      unint64_t v38 = v64 + 1;
      if (v63 <= &v54 && (char *)v63 + 24 * v64 > (char *)&v54)
      {
        int64_t v49 = (char *)&v54 - (unsigned char *)v63;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v38, 24);
        long long v18 = (char *)v63;
        uint64_t v17 = (void ***)((char *)v63 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v38, 24);
        uint64_t v17 = &v54;
        long long v18 = (char *)v63;
      }
    }
    uint64_t v19 = &v18[24 * v64];
    long long v20 = *(_OWORD *)v17;
    *((void *)v19 + 2) = v17[2];
    *(_OWORD *)uint64_t v19 = v20;
    ++v64;
    char v21 = Context;
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 24) = 0;
    if (v21) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Context);
    }
  }
  else
  {
LABEL_18:
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 24) = 0;
  }
  if (v71)
  {
    uint64_t v22 = __p;
    if (__p)
    {
      uint64_t v23 = v70;
      uint64_t v24 = __p;
      if (v70 != __p)
      {
        do
          uint64_t v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        uint64_t v24 = __p;
      }
      BOOL v70 = v22;
      operator delete(v24);
    }
    long long v25 = v67;
    if (!v67) {
      goto LABEL_47;
    }
    uint64_t v26 = v68;
    uint64_t v27 = v67;
    if (v68 == v67) {
      goto LABEL_46;
    }
    do
    {
      uint64_t v29 = *--v26;
      uint64_t v28 = v29;
      void *v26 = 0;
      if (v29) {
        MEMORY[0x21667D390](v28, 0x1000C8077774924);
      }
    }
    while (v26 != v25);
    goto LABEL_45;
  }
}

uint64_t mlir::AsmParser::getChecked<mlir::mps::MPSBufferTensorAttr,mlir::MLIRContext *,mlir::RankedTensorType,mlir::mps::MPSDialectResourceBlobHandle,unsigned long long>(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, void **a4, uint64_t a5, uint64_t *a6)
{
  v10[0] = a1;
  v10[1] = &v11;
  uint64_t v11 = a2;
  uint64_t v6 = *a3;
  BOOL v7 = *a4;
  long long v12 = *(_OWORD *)a5;
  uint64_t v13 = *(void *)(a5 + 16);
  uint64_t v14 = *a6;
  long long v15 = v7;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v6);
  v16[0] = &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
  v16[1] = v6;
  return mlir::StorageUniquer::get<mlir::mps::detail::MPSBufferTensorAttrStorage,mlir::RankedTensorType &,mlir::mps::MPSDialectResourceBlobHandle &,unsigned long long &>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail26MPSBufferTensorAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_19MPSBufferTensorAttrEJRNS1_16RankedTensorTypeERNS2_28MPSDialectResourceBlobHandleERyEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESK_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSM_E_EEvlS5_, (uint64_t)v16, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id, (uint64_t *)&v15, &v12, &v14);
}

llvm::raw_ostream *mlir::mps::MPSBufferTensorAttr::print(mlir::mps::MPSBufferTensorAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  uint64_t v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    *unsigned int v5 = 60;
    ++*((void *)v4 + 4);
  }
  long long v6 = *(_OWORD *)(*(void *)this + 16);
  uint64_t v24 = *(void *)(*(void *)this + 32);
  long long v23 = v6;
  (*(void (**)(mlir::AsmPrinter *, long long *))(*(void *)a2 + 80))(a2, &v23);
  if (!*(void *)(*(void *)this + 40)) {
    goto LABEL_25;
  }
  BOOL v7 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  size_t v8 = (unsigned char *)*((void *)v7 + 4);
  if (*((unsigned char **)v7 + 3) == v8)
  {
    llvm::raw_ostream::write(v7, ",", 1uLL);
  }
  else
  {
    *size_t v8 = 44;
    ++*((void *)v7 + 4);
  }
  uint64_t v9 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  size_t v10 = (unsigned char *)*((void *)v9 + 4);
  if ((unint64_t)v10 >= *((void *)v9 + 3))
  {
    llvm::raw_ostream::write(v9, 32);
  }
  else
  {
    *((void *)v9 + 4) = v10 + 1;
    unsigned char *v10 = 32;
  }
  uint64_t v11 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v12 = (void *)*((void *)v11 + 4);
  if (*((void *)v11 + 3) - (void)v12 > 0xCuLL)
  {
    qmemcpy(v12, "handle_offset", 13);
    *((void *)v11 + 4) += 13;
  }
  else
  {
    llvm::raw_ostream::write(v11, "handle_offset", 0xDuLL);
  }
  uint64_t v13 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v14 = (unsigned char *)*((void *)v13 + 4);
  if ((unint64_t)v14 >= *((void *)v13 + 3))
  {
    llvm::raw_ostream::write(v13, 32);
  }
  else
  {
    *((void *)v13 + 4) = v14 + 1;
    *uint64_t v14 = 32;
  }
  long long v15 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v16 = (unsigned char *)*((void *)v15 + 4);
  if (*((unsigned char **)v15 + 3) == v16)
  {
    llvm::raw_ostream::write(v15, "=", 1uLL);
    if (!*(void *)(*(void *)this + 40)) {
      goto LABEL_25;
    }
  }
  else
  {
    unsigned char *v16 = 61;
    ++*((void *)v15 + 4);
    if (!*(void *)(*(void *)this + 40)) {
      goto LABEL_25;
    }
  }
  uint64_t v17 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v18 = (unsigned char *)*((void *)v17 + 4);
  if ((unint64_t)v18 >= *((void *)v17 + 3))
  {
    llvm::raw_ostream::write(v17, 32);
  }
  else
  {
    *((void *)v17 + 4) = v18 + 1;
    *long long v18 = 32;
  }
  unint64_t v19 = *(void *)(*(void *)this + 40);
  long long v20 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  llvm::raw_ostream::operator<<(v20, v19);
LABEL_25:
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v22 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v22) {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  unsigned char *v22 = 62;
  ++*((void *)result + 4);
  return result;
}

uint64_t mlir::mps::CallInlineModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned int v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::CallInlineModeAttrStorage,mlir::mps::CallInlineMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25CallInlineModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18CallInlineModeAttrEJNS2_14CallInlineModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::CallInlineModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v111 = *MEMORY[0x263EF8340];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 152))(a1))
  {
    uint64_t v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
    uint64_t v88 = 0;
    uint64_t v89 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v88))
    {
LABEL_53:
      uint64_t v53 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
      LOWORD(v103) = 259;
      (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, void *))(*(void *)a1 + 24))(v93, a1, v53, v101);
      if (v93[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v93);
      }
      if (v100)
      {
        uint64_t v54 = __p;
        if (__p)
        {
          unint64_t v55 = v99;
          uint64_t v56 = __p;
          if (v99 != __p)
          {
            do
              unint64_t v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
            while (v55 != v54);
            uint64_t v56 = __p;
          }
          char v99 = v54;
          operator delete(v56);
        }
        __int16 v57 = v96;
        if (v96)
        {
          int v58 = v97;
          char v59 = v96;
          if (v97 != v96)
          {
            do
            {
              uint64_t v61 = *--v58;
              uint64_t v60 = v61;
              *int v58 = 0;
              if (v61) {
                MEMORY[0x21667D390](v60, 0x1000C8077774924);
              }
            }
            while (v58 != v57);
            char v59 = v96;
          }
          char v97 = v57;
          operator delete(v59);
        }
        if (v94 != &v95) {
          free(v94);
        }
      }
      return 0;
    }
    switch(v89)
    {
      case 2:
        if (*(_WORD *)v88 != 28271)
        {
LABEL_18:
          __int16 v87 = 257;
          (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(void *)a1 + 24))(v101, a1, v2, v86);
          if (v101[0])
          {
            int v90 = 3;
            uint64_t v91 = "expected ";
            uint64_t v92 = 9;
            long long v6 = &v90;
            BOOL v7 = v102;
            if (v103 >= v104)
            {
              unint64_t v65 = v103 + 1;
              if (v102 <= &v90 && &v102[6 * v103] > &v90)
              {
                int64_t v78 = (char *)&v90 - (char *)v102;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v65, 24);
                BOOL v7 = v102;
                long long v6 = (int *)((char *)v102 + v78);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v65, 24);
                long long v6 = &v90;
                BOOL v7 = v102;
              }
            }
            size_t v8 = &v7[6 * v103];
            long long v9 = *(_OWORD *)v6;
            *((void *)v8 + 2) = *((void *)v6 + 2);
            *(_OWORD *)size_t v8 = v9;
            uint64_t v10 = ++v103;
            if (v101[0])
            {
              int v90 = 3;
              uint64_t v91 = "::mlir::mps::CallInlineMode";
              uint64_t v92 = 27;
              uint64_t v11 = &v90;
              long long v12 = v102;
              if (v10 >= v104)
              {
                unint64_t v66 = v10 + 1;
                BOOL v67 = &v102[6 * v10] > &v90;
                if (v102 <= &v90 && v67)
                {
                  int64_t v79 = (char *)&v90 - (char *)v102;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v66, 24);
                  long long v12 = v102;
                  uint64_t v11 = (int *)((char *)v102 + v79);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v66, 24);
                  uint64_t v11 = &v90;
                  long long v12 = v102;
                }
              }
              uint64_t v13 = &v12[6 * v103];
              long long v14 = *(_OWORD *)v11;
              *((void *)v13 + 2) = *((void *)v11 + 2);
              *(_OWORD *)uint64_t v13 = v14;
              uint64_t v15 = ++v103;
              if (v101[0])
              {
                int v90 = 3;
                uint64_t v91 = " to be one of: ";
                uint64_t v92 = 15;
                long long v16 = &v90;
                uint64_t v17 = v102;
                if (v15 >= v104)
                {
                  unint64_t v68 = v15 + 1;
                  BOOL v69 = &v102[6 * v15] > &v90;
                  if (v102 <= &v90 && v69)
                  {
                    int64_t v80 = (char *)&v90 - (char *)v102;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v68, 24);
                    uint64_t v17 = v102;
                    long long v16 = (int *)((char *)v102 + v80);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v68, 24);
                    long long v16 = &v90;
                    uint64_t v17 = v102;
                  }
                }
                long long v18 = &v17[6 * v103];
                long long v19 = *(_OWORD *)v16;
                *((void *)v18 + 2) = *((void *)v16 + 2);
                *(_OWORD *)long long v18 = v19;
                uint64_t v20 = ++v103;
                if (v101[0])
                {
                  int v90 = 3;
                  uint64_t v91 = "off";
                  uint64_t v92 = 3;
                  char v21 = &v90;
                  uint64_t v22 = v102;
                  if (v20 >= v104)
                  {
                    unint64_t v70 = v20 + 1;
                    BOOL v71 = &v102[6 * v20] > &v90;
                    if (v102 <= &v90 && v71)
                    {
                      int64_t v81 = (char *)&v90 - (char *)v102;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v70, 24);
                      uint64_t v22 = v102;
                      char v21 = (int *)((char *)v102 + v81);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v70, 24);
                      char v21 = &v90;
                      uint64_t v22 = v102;
                    }
                  }
                  long long v23 = &v22[6 * v103];
                  long long v24 = *(_OWORD *)v21;
                  *((void *)v23 + 2) = *((void *)v21 + 2);
                  *(_OWORD *)long long v23 = v24;
                  uint64_t v25 = ++v103;
                  if (v101[0])
                  {
                    int v90 = 3;
                    uint64_t v91 = ", ";
                    uint64_t v92 = 2;
                    uint64_t v26 = &v90;
                    uint64_t v27 = v102;
                    if (v25 >= v104)
                    {
                      unint64_t v72 = v25 + 1;
                      if (v102 <= &v90 && &v102[6 * v25] > &v90)
                      {
                        int64_t v82 = (char *)&v90 - (char *)v102;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v72, 24);
                        uint64_t v27 = v102;
                        uint64_t v26 = (int *)((char *)v102 + v82);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v72, 24);
                        uint64_t v26 = &v90;
                        uint64_t v27 = v102;
                      }
                    }
                    uint64_t v28 = &v27[6 * v103];
                    long long v29 = *(_OWORD *)v26;
                    *((void *)v28 + 2) = *((void *)v26 + 2);
                    *(_OWORD *)uint64_t v28 = v29;
                    uint64_t v30 = ++v103;
                    if (v101[0])
                    {
                      int v90 = 3;
                      uint64_t v91 = "on";
                      uint64_t v92 = 2;
                      uint64_t v31 = &v90;
                      uint64_t v32 = v102;
                      if (v30 >= v104)
                      {
                        unint64_t v73 = v30 + 1;
                        if (v102 <= &v90 && &v102[6 * v30] > &v90)
                        {
                          int64_t v83 = (char *)&v90 - (char *)v102;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v73, 24);
                          uint64_t v32 = v102;
                          uint64_t v31 = (int *)((char *)v102 + v83);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v73, 24);
                          uint64_t v31 = &v90;
                          uint64_t v32 = v102;
                        }
                      }
                      uint64_t v33 = &v32[6 * v103];
                      long long v34 = *(_OWORD *)v31;
                      *((void *)v33 + 2) = *((void *)v31 + 2);
                      *(_OWORD *)uint64_t v33 = v34;
                      uint64_t v35 = ++v103;
                      if (v101[0])
                      {
                        int v90 = 3;
                        uint64_t v91 = ", ";
                        uint64_t v92 = 2;
                        unint64_t v36 = &v90;
                        unint64_t v37 = v102;
                        if (v35 >= v104)
                        {
                          unint64_t v74 = v35 + 1;
                          BOOL v75 = &v102[6 * v35] > &v90;
                          if (v102 <= &v90 && v75)
                          {
                            int64_t v84 = (char *)&v90 - (char *)v102;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v74, 24);
                            unint64_t v37 = v102;
                            unint64_t v36 = (int *)((char *)v102 + v84);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v74, 24);
                            unint64_t v36 = &v90;
                            unint64_t v37 = v102;
                          }
                        }
                        unint64_t v38 = &v37[6 * v103];
                        long long v39 = *(_OWORD *)v36;
                        *((void *)v38 + 2) = *((void *)v36 + 2);
                        *(_OWORD *)unint64_t v38 = v39;
                        uint64_t v40 = ++v103;
                        if (v101[0])
                        {
                          int v90 = 3;
                          uint64_t v91 = "automatic";
                          uint64_t v92 = 9;
                          unint64_t v41 = &v90;
                          uint64_t v42 = v102;
                          if (v40 >= v104)
                          {
                            unint64_t v76 = v40 + 1;
                            BOOL v77 = &v102[6 * v40] > &v90;
                            if (v102 <= &v90 && v77)
                            {
                              int64_t v85 = (char *)&v90 - (char *)v102;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v76, 24);
                              uint64_t v42 = v102;
                              unint64_t v41 = (int *)((char *)v102 + v85);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v76, 24);
                              unint64_t v41 = &v90;
                              uint64_t v42 = v102;
                            }
                          }
                          unint64_t v43 = &v42[6 * v103];
                          long long v44 = *(_OWORD *)v41;
                          *((void *)v43 + 2) = *((void *)v41 + 2);
                          *(_OWORD *)unint64_t v43 = v44;
                          ++v103;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v101);
          if (v101[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v101);
          }
          if (v110)
          {
            unint64_t v45 = v108;
            if (v108)
            {
              uint64_t v46 = v109;
              int64_t v47 = v108;
              if (v109 != v108)
              {
                do
                  uint64_t v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
                while (v46 != v45);
                int64_t v47 = v108;
              }
              char v109 = v45;
              operator delete(v47);
            }
            int64_t v48 = v106;
            if (v106)
            {
              int64_t v49 = v107;
              long long v50 = v106;
              if (v107 != v106)
              {
                do
                {
                  uint64_t v52 = *--v49;
                  uint64_t v51 = v52;
                  *int64_t v49 = 0;
                  if (v52) {
                    MEMORY[0x21667D390](v51, 0x1000C8077774924);
                  }
                }
                while (v49 != v48);
                long long v50 = v106;
              }
              __int16 v107 = v48;
              operator delete(v50);
            }
            if (v102 != (int *)v105) {
              free(v102);
            }
          }
          goto LABEL_53;
        }
        unsigned int v4 = 1;
        break;
      case 9:
        if (*(void *)v88 != 0x6974616D6F747561 || *(unsigned char *)(v88 + 8) != 99) {
          goto LABEL_18;
        }
        unsigned int v4 = 2;
        break;
      case 3:
        if (*(_WORD *)v88 != 26223 || *(unsigned char *)(v88 + 2) != 102) {
          goto LABEL_18;
        }
        unsigned int v4 = 0;
        break;
      default:
        goto LABEL_18;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(void *)a1 + 168))(a1))
    {
      Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v86[0] = v4;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v101[0] = &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id;
      v101[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::CallInlineModeAttrStorage,mlir::mps::CallInlineMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25CallInlineModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18CallInlineModeAttrEJNS2_14CallInlineModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v101, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id, v86);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::CallInlineModeAttr::print(mlir::mps::CallInlineModeAttr *this, mlir::AsmPrinter *a2)
{
  mlir::Attribute::getContext(this);
  unsigned int v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  unsigned int v5 = (unsigned char *)*((void *)v4 + 4);
  if (*((unsigned char **)v4 + 3) != v5)
  {
    *unsigned int v5 = 60;
    ++*((void *)v4 + 4);
    int v6 = *(_DWORD *)(*(void *)this + 8);
    if (v6) {
      goto LABEL_3;
    }
LABEL_11:
    BOOL v7 = 0;
    long long v9 = "off";
    size_t v8 = 3;
    goto LABEL_13;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  int v6 = *(_DWORD *)(*(void *)this + 8);
  if (!v6) {
    goto LABEL_11;
  }
LABEL_3:
  if (v6 == 2)
  {
    BOOL v7 = 0;
    long long v9 = "automatic";
    size_t v8 = 9;
  }
  else
  {
    BOOL v7 = v6 != 1;
    if (v6 == 1) {
      size_t v8 = 2;
    }
    else {
      size_t v8 = 0;
    }
    if (v6 == 1) {
      long long v9 = "on";
    }
    else {
      long long v9 = &byte_211F4AA5D;
    }
  }
LABEL_13:
  uint64_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v11 = (void *)*((void *)v10 + 4);
  if (v8 <= *((void *)v10 + 3) - (void)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((void *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v13 = (unsigned char *)*((void *)result + 4);
  if (*((unsigned char **)result + 3) == v13)
  {
    return llvm::raw_ostream::write(result, ">", 1uLL);
  }
  else
  {
    *uint64_t v13 = 62;
    ++*((void *)result + 4);
  }
  return result;
}

uint64_t mlir::mps::MPSDialect::parseAttribute(uint64_t a1, mlir::AsmParser *a2, void *a3)
{
  uint64_t v97 = *MEMORY[0x263EF8340];
  uint64_t v6 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a2 + 40))(a2);
  int64_t v85 = a2;
  uint64_t v7 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a2 + 40))(a2);
  BYTE2(v89) = 0;
  uint64_t v87 = 0;
  uint64_t v88 = 0;
  uint64_t v86 = v7;
  LOBYTE(v89) = 0;
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *, uint64_t *))(*(void *)a2 + 608))(a2, &v87))
  {
    LOWORD(v89) = 256;
    if (!BYTE2(v89)) {
      BYTE2(v89) = 1;
    }
    goto LABEL_238;
  }
  int64_t v81 = (void **)"tensor_data_layout";
  uint64_t v82 = 18;
  if (BYTE2(v89))
  {
LABEL_238:
    uint64_t v47 = 0;
LABEL_239:
    size_t v8 = 0;
    int64_t v48 = 0;
    goto LABEL_240;
  }
  size_t v8 = v88;
  if (v88)
  {
    if (v88 == (void *)18)
    {
      BOOL v9 = *(void *)v87 == 0x645F726F736E6574 && *(void *)(v87 + 8) == 0x6F79616C5F617461;
      if (v9 && *(_WORD *)(v87 + 16) == 29813)
      {
        uint64_t v72 = mlir::mps::TensorDataLayoutAttr::parse(a2);
        goto LABEL_301;
      }
    }
    int64_t v81 = (void **)"reduction_mode";
    uint64_t v82 = 14;
  }
  else
  {
    (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
    int64_t v81 = (void **)"reduction_mode";
    uint64_t v82 = 14;
    if (BYTE2(v89)) {
      goto LABEL_238;
    }
    size_t v8 = v88;
    if (!v88)
    {
      (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (void **)"device_hint";
      uint64_t v82 = 11;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_19;
      }
LABEL_197:
      (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (void **)"scatter_mode";
      uint64_t v82 = 12;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_25;
      }
LABEL_199:
      (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (void **)"padding_mode";
      uint64_t v82 = 12;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_31;
      }
LABEL_201:
      (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (void **)"sampling_mode";
      uint64_t v82 = 13;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_37;
      }
LABEL_203:
      (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (void **)"nearest_rounding_mode";
      uint64_t v82 = 21;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_43;
      }
LABEL_205:
      (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (void **)"sparse_tensor_storage";
      uint64_t v82 = 21;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_52;
      }
LABEL_207:
      (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (void **)"texture_tensor_pixel_format";
      uint64_t v82 = 27;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_61;
      }
LABEL_209:
      (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (void **)"random_normal_sampling_method";
      uint64_t v82 = 29;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_73;
      }
LABEL_211:
      (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (void **)"padding_style";
      uint64_t v82 = 13;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_85;
      }
LABEL_213:
      (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (void **)"pooling_indices_mode";
      uint64_t v82 = 20;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_91;
      }
LABEL_215:
      (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (void **)"rnn_activation";
      uint64_t v82 = 14;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_100;
      }
LABEL_217:
      (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (void **)"lstm_gate_layout";
      uint64_t v82 = 16;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_106;
      }
LABEL_219:
      (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (void **)"gru_gate_layout";
      uint64_t v82 = 15;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_112;
      }
LABEL_221:
      (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (void **)"stencil_padding_mode";
      uint64_t v82 = 20;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_118;
      }
LABEL_223:
      (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (void **)"crop_resize_alignment_mode";
      uint64_t v82 = 26;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_127;
      }
LABEL_225:
      (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (void **)"crop_resize_coordinate_mode";
      uint64_t v82 = 27;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_139;
      }
LABEL_227:
      (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (void **)"pruning_metric";
      uint64_t v82 = 14;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_151;
      }
      goto LABEL_229;
    }
  }
  if (v8 == (void *)14 && *(void *)v87 == 0x6F69746375646572 && *(void *)(v87 + 6) == 0x65646F6D5F6E6F69)
  {
    uint64_t v72 = mlir::mps::ReductionModeAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (void **)"device_hint";
  uint64_t v82 = 11;
  if (!v8) {
    goto LABEL_197;
  }
LABEL_19:
  if (v8 == (void *)11 && *(void *)v87 == 0x685F656369766564 && *(void *)(v87 + 3) == 0x746E69685F656369)
  {
    uint64_t v72 = mlir::mps::DeviceHintAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (void **)"scatter_mode";
  uint64_t v82 = 12;
  if (!v8) {
    goto LABEL_199;
  }
LABEL_25:
  if (v8 == (void *)12 && *(void *)v87 == 0x5F72657474616373 && *(_DWORD *)(v87 + 8) == 1701080941)
  {
    uint64_t v72 = mlir::mps::ScatterModeAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (void **)"padding_mode";
  uint64_t v82 = 12;
  if (!v8) {
    goto LABEL_201;
  }
LABEL_31:
  if (v8 == (void *)12 && *(void *)v87 == 0x5F676E6964646170 && *(_DWORD *)(v87 + 8) == 1701080941)
  {
    uint64_t v72 = mlir::mps::PaddingModeAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (void **)"sampling_mode";
  uint64_t v82 = 13;
  if (!v8) {
    goto LABEL_203;
  }
LABEL_37:
  if (v8 == (void *)13 && *(void *)v87 == 0x676E696C706D6173 && *(void *)(v87 + 5) == 0x65646F6D5F676E69)
  {
    uint64_t v72 = mlir::mps::SamplingModeAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (void **)"nearest_rounding_mode";
  uint64_t v82 = 21;
  if (!v8) {
    goto LABEL_205;
  }
LABEL_43:
  if (v8 == (void *)21)
  {
    BOOL v16 = *(void *)v87 == 0x5F7473657261656ELL && *(void *)(v87 + 8) == 0x676E69646E756F72;
    if (v16 && *(void *)(v87 + 13) == 0x65646F6D5F676E69)
    {
      uint64_t v72 = mlir::mps::NearestRoundingModeAttr::parse(a2);
      goto LABEL_301;
    }
  }
  int64_t v81 = (void **)"sparse_tensor_storage";
  uint64_t v82 = 21;
  if (!v8) {
    goto LABEL_207;
  }
LABEL_52:
  if (v8 == (void *)21)
  {
    BOOL v18 = *(void *)v87 == 0x745F657372617073 && *(void *)(v87 + 8) == 0x74735F726F736E65;
    if (v18 && *(void *)(v87 + 13) == 0x656761726F74735FLL)
    {
      uint64_t v72 = mlir::mps::SparseTensorStorageAttr::parse(a2);
      goto LABEL_301;
    }
  }
  int64_t v81 = (void **)"texture_tensor_pixel_format";
  uint64_t v82 = 27;
  if (!v8) {
    goto LABEL_209;
  }
LABEL_61:
  if (v8 == (void *)27)
  {
    BOOL v20 = *(void *)v87 == 0x5F65727574786574 && *(void *)(v87 + 8) == 0x705F726F736E6574;
    BOOL v21 = v20 && *(void *)(v87 + 16) == 0x726F665F6C657869;
    if (v21 && *(void *)(v87 + 19) == 0x74616D726F665F6CLL)
    {
      uint64_t v72 = mlir::mps::MetalPixelFormatAttr::parse(a2);
      goto LABEL_301;
    }
  }
  int64_t v81 = (void **)"random_normal_sampling_method";
  uint64_t v82 = 29;
  if (!v8) {
    goto LABEL_211;
  }
LABEL_73:
  if (v8 == (void *)29)
  {
    BOOL v23 = *(void *)v87 == 0x6E5F6D6F646E6172 && *(void *)(v87 + 8) == 0x61735F6C616D726FLL;
    BOOL v24 = v23 && *(void *)(v87 + 16) == 0x6D5F676E696C706DLL;
    if (v24 && *(void *)(v87 + 21) == 0x646F6874656D5F67)
    {
      uint64_t v72 = mlir::mps::NormalSamplingMethodAttr::parse(a2);
      goto LABEL_301;
    }
  }
  int64_t v81 = (void **)"padding_style";
  uint64_t v82 = 13;
  if (!v8) {
    goto LABEL_213;
  }
LABEL_85:
  if (v8 == (void *)13 && *(void *)v87 == 0x5F676E6964646170 && *(void *)(v87 + 5) == 0x656C7974735F676ELL)
  {
    uint64_t v72 = mlir::mps::PaddingStyleAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (void **)"pooling_indices_mode";
  uint64_t v82 = 20;
  if (!v8) {
    goto LABEL_215;
  }
LABEL_91:
  if (v8 == (void *)20)
  {
    BOOL v27 = *(void *)v87 == 0x5F676E696C6F6F70 && *(void *)(v87 + 8) == 0x5F73656369646E69;
    if (v27 && *(_DWORD *)(v87 + 16) == 1701080941)
    {
      uint64_t v72 = mlir::mps::PoolIndicesModeAttr::parse(a2);
      goto LABEL_301;
    }
  }
  int64_t v81 = (void **)"rnn_activation";
  uint64_t v82 = 14;
  if (!v8) {
    goto LABEL_217;
  }
LABEL_100:
  if (v8 == (void *)14 && *(void *)v87 == 0x697463615F6E6E72 && *(void *)(v87 + 6) == 0x6E6F697461766974)
  {
    uint64_t v72 = mlir::mps::RNNActivationAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (void **)"lstm_gate_layout";
  uint64_t v82 = 16;
  if (!v8) {
    goto LABEL_219;
  }
LABEL_106:
  if (v8 == (void *)16 && *(void *)v87 == 0x7461675F6D74736CLL && *(void *)(v87 + 8) == 0x74756F79616C5F65)
  {
    uint64_t v72 = mlir::mps::LSTMGateLayoutAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (void **)"gru_gate_layout";
  uint64_t v82 = 15;
  if (!v8) {
    goto LABEL_221;
  }
LABEL_112:
  if (v8 == (void *)15 && *(void *)v87 == 0x657461675F757267 && *(void *)(v87 + 7) == 0x74756F79616C5F65)
  {
    uint64_t v72 = mlir::mps::GRUGateLayoutAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (void **)"stencil_padding_mode";
  uint64_t v82 = 20;
  if (!v8) {
    goto LABEL_223;
  }
LABEL_118:
  if (v8 == (void *)20)
  {
    BOOL v32 = *(void *)v87 == 0x5F6C69636E657473 && *(void *)(v87 + 8) == 0x5F676E6964646170;
    if (v32 && *(_DWORD *)(v87 + 16) == 1701080941)
    {
      uint64_t v72 = mlir::mps::StencilPaddingModeAttr::parse(a2);
      goto LABEL_301;
    }
  }
  int64_t v81 = (void **)"crop_resize_alignment_mode";
  uint64_t v82 = 26;
  if (!v8) {
    goto LABEL_225;
  }
LABEL_127:
  if (v8 == (void *)26)
  {
    BOOL v34 = *(void *)v87 == 0x7365725F706F7263 && *(void *)(v87 + 8) == 0x67696C615F657A69;
    BOOL v35 = v34 && *(void *)(v87 + 16) == 0x6F6D5F746E656D6ELL;
    if (v35 && *(_WORD *)(v87 + 24) == 25956)
    {
      uint64_t v72 = mlir::mps::CropResizeAlignmentModeAttr::parse(a2);
      goto LABEL_301;
    }
  }
  int64_t v81 = (void **)"crop_resize_coordinate_mode";
  uint64_t v82 = 27;
  if (!v8) {
    goto LABEL_227;
  }
LABEL_139:
  if (v8 == (void *)27)
  {
    BOOL v37 = *(void *)v87 == 0x7365725F706F7263 && *(void *)(v87 + 8) == 0x726F6F635F657A69;
    BOOL v38 = v37 && *(void *)(v87 + 16) == 0x6D5F6574616E6964;
    if (v38 && *(void *)(v87 + 19) == 0x65646F6D5F657461)
    {
      uint64_t v72 = mlir::mps::CropResizeCoordinateModeAttr::parse(a2);
      goto LABEL_301;
    }
  }
  int64_t v81 = (void **)"pruning_metric";
  uint64_t v82 = 14;
  if (v8)
  {
LABEL_151:
    if (v8 == (void *)14 && *(void *)v87 == 0x5F676E696E757270 && *(void *)(v87 + 6) == 0x63697274656D5F67)
    {
      uint64_t v72 = mlir::mps::PruningMetricAttr::parse(a2);
      goto LABEL_301;
    }
    int64_t v81 = (void **)"pruning_structure";
    uint64_t v82 = 17;
    if (v8) {
      goto LABEL_157;
    }
    goto LABEL_231;
  }
LABEL_229:
  (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
  int64_t v81 = (void **)"pruning_structure";
  uint64_t v82 = 17;
  if (BYTE2(v89)) {
    goto LABEL_238;
  }
  size_t v8 = v88;
  if (v88)
  {
LABEL_157:
    if (v8 != (void *)17
      || (*(void *)v87 == 0x5F676E696E757270 ? (BOOL v41 = *(void *)(v87 + 8) == 0x7275746375727473) : (BOOL v41 = 0),
          v41 ? (BOOL v42 = *(unsigned char *)(v87 + 16) == 101) : (BOOL v42 = 0),
          !v42))
    {
      int64_t v81 = (void **)"similarity_type";
      uint64_t v82 = 15;
      if (v8) {
        goto LABEL_166;
      }
LABEL_233:
      (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
      int64_t v81 = (void **)"fft_scaling_mode";
      uint64_t v82 = 16;
      if (BYTE2(v89)) {
        goto LABEL_238;
      }
      size_t v8 = v88;
      if (v88) {
        goto LABEL_172;
      }
      goto LABEL_235;
    }
    uint64_t v72 = mlir::mps::PruningStructureAttr::parse(a2);
LABEL_301:
    uint64_t v47 = v72;
    LOBYTE(v89) = v72 != 0;
    *(_WORD *)((char *)&v89 + 1) = 257;
    goto LABEL_239;
  }
LABEL_231:
  (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
  int64_t v81 = (void **)"similarity_type";
  uint64_t v82 = 15;
  if (BYTE2(v89)) {
    goto LABEL_238;
  }
  size_t v8 = v88;
  if (!v88) {
    goto LABEL_233;
  }
LABEL_166:
  if (v8 == (void *)15 && *(void *)v87 == 0x6972616C696D6973 && *(void *)(v87 + 7) == 0x657079745F797469)
  {
    uint64_t v72 = mlir::mps::SimilarityTypeAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (void **)"fft_scaling_mode";
  uint64_t v82 = 16;
  if (!v8)
  {
LABEL_235:
    (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
    int64_t v81 = (void **)"buffer_tensor";
    uint64_t v82 = 13;
    if (!BYTE2(v89))
    {
      size_t v8 = v88;
      if (v88) {
        goto LABEL_178;
      }
      goto LABEL_237;
    }
    goto LABEL_238;
  }
LABEL_172:
  if (v8 == (void *)16 && *(void *)v87 == 0x6C6163735F746666 && *(void *)(v87 + 8) == 0x65646F6D5F676E69)
  {
    uint64_t v72 = mlir::mps::FFTScalingModeAttr::parse(a2);
    goto LABEL_301;
  }
  int64_t v81 = (void **)"buffer_tensor";
  uint64_t v82 = 13;
  if (!v8)
  {
LABEL_237:
    (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
    int64_t v81 = (void **)"call_inline_mode";
    uint64_t v82 = 16;
    if (!BYTE2(v89))
    {
      size_t v8 = v88;
      if (v88) {
        goto LABEL_184;
      }
      goto LABEL_303;
    }
    goto LABEL_238;
  }
LABEL_178:
  if (v8 == (void *)13 && *(void *)v87 == 0x745F726566667562 && *(void *)(v87 + 5) == 0x726F736E65745F72)
  {
    uint64_t v72 = mlir::mps::MPSBufferTensorAttr::parse(a2, a3);
    goto LABEL_301;
  }
  int64_t v81 = (void **)"call_inline_mode";
  uint64_t v82 = 16;
  if (v8)
  {
LABEL_184:
    if (v8 == (void *)16 && *(void *)v87 == 0x6C6E695F6C6C6163 && *(void *)(v87 + 8) == 0x65646F6D5F656E69)
    {
      uint64_t v47 = mlir::mps::CallInlineModeAttr::parse(a2);
      size_t v8 = 0;
      int64_t v48 = 0;
      LOBYTE(v89) = v47 != 0;
      *(_WORD *)((char *)&v89 + 1) = 257;
      goto LABEL_240;
    }
    goto LABEL_306;
  }
LABEL_303:
  (*(void (**)(mlir::AsmParser *, void ***, uint64_t))(*(void *)v85 + 616))(v85, &v81, 1);
  if (BYTE2(v89))
  {
    size_t v8 = 0;
    int64_t v48 = 0;
    uint64_t v47 = 0;
    goto LABEL_240;
  }
  size_t v8 = v88;
LABEL_306:
  uint64_t v47 = 0;
  int64_t v48 = (void **)v87;
  LOWORD(v89) = 0;
  BYTE2(v89) = 1;
LABEL_240:
  if ((unsigned __int16)mlir::AsmParser::KeywordSwitch<mlir::OptionalParseResult>::operator mlir::OptionalParseResult((uint64_t)&v85) <= 0xFFu)
  {
    __int16 v80 = 257;
    (*(void (**)(mlir::AsmParser **__return_ptr, mlir::AsmParser *, uint64_t, char *))(*(void *)a2 + 24))(&v85, a2, v6, v79);
    if (v85)
    {
      LODWORD(v81) = 3;
      uint64_t v83 = 19;
      int64_t v49 = &v81;
      long long v50 = (char *)v88;
      if (v89 >= v90)
      {
        unint64_t v73 = v89 + 1;
        if (v88 <= &v81 && (char *)v88 + 24 * v89 > (char *)&v81)
        {
          int64_t v76 = (char *)&v81 - (unsigned char *)v88;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v73, 24);
          long long v50 = (char *)v88;
          int64_t v49 = (void ***)((char *)v88 + v76);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v73, 24);
          int64_t v49 = &v81;
          long long v50 = (char *)v88;
        }
      }
      uint64_t v51 = &v50[24 * v89];
      long long v52 = *(_OWORD *)v49;
      *((void *)v51 + 2) = v49[2];
      *(_OWORD *)uint64_t v51 = v52;
      ++v89;
      if (v85)
      {
        __int16 v84 = 261;
        int64_t v81 = v48;
        uint64_t v82 = (uint64_t)v8;
        mlir::Diagnostic::operator<<((uint64_t)&v86, &v81);
        if (v85)
        {
          LODWORD(v81) = 3;
          uint64_t v83 = 14;
          uint64_t v53 = &v81;
          uint64_t v54 = (char *)v88;
          if (v89 >= v90)
          {
            unint64_t v74 = v89 + 1;
            if (v88 <= &v81 && (char *)v88 + 24 * v89 > (char *)&v81)
            {
              int64_t v77 = (char *)&v81 - (unsigned char *)v88;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v74, 24);
              uint64_t v54 = (char *)v88;
              uint64_t v53 = (void ***)((char *)v88 + v77);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v74, 24);
              uint64_t v53 = &v81;
              uint64_t v54 = (char *)v88;
            }
          }
          unint64_t v55 = &v54[24 * v89];
          long long v56 = *(_OWORD *)v53;
          *((void *)v55 + 2) = v53[2];
          *(_OWORD *)unint64_t v55 = v56;
          ++v89;
          if (v85)
          {
            __int16 v57 = *(void ***)(a1 + 8);
            uint64_t v58 = *(void *)(a1 + 16);
            __int16 v84 = 261;
            int64_t v81 = v57;
            uint64_t v82 = v58;
            mlir::Diagnostic::operator<<((uint64_t)&v86, &v81);
            if (v85)
            {
              LODWORD(v81) = 3;
              uint64_t v83 = 1;
              char v59 = &v81;
              uint64_t v60 = (char *)v88;
              if (v89 >= v90)
              {
                unint64_t v75 = v89 + 1;
                if (v88 <= &v81 && (char *)v88 + 24 * v89 > (char *)&v81)
                {
                  int64_t v78 = (char *)&v81 - (unsigned char *)v88;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v75, 24);
                  uint64_t v60 = (char *)v88;
                  char v59 = (void ***)((char *)v88 + v78);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v75, 24);
                  char v59 = &v81;
                  uint64_t v60 = (char *)v88;
                }
              }
              uint64_t v61 = &v60[24 * v89];
              long long v62 = *(_OWORD *)v59;
              *((void *)v61 + 2) = v59[2];
              *(_OWORD *)uint64_t v61 = v62;
              ++v89;
              if (v85) {
                mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v85);
              }
            }
          }
        }
      }
    }
    if (v96)
    {
      unint64_t v63 = __p;
      if (__p)
      {
        unsigned int v64 = v95;
        unint64_t v65 = __p;
        if (v95 != __p)
        {
          do
            unsigned int v64 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v64 - 1);
          while (v64 != v63);
          unint64_t v65 = __p;
        }
        uint64_t v95 = v63;
        operator delete(v65);
      }
      unint64_t v66 = v92;
      if (v92)
      {
        BOOL v67 = v93;
        unint64_t v68 = v92;
        if (v93 != v92)
        {
          do
          {
            uint64_t v70 = *--v67;
            uint64_t v69 = v70;
            *BOOL v67 = 0;
            if (v70) {
              MEMORY[0x21667D390](v69, 0x1000C8077774924);
            }
          }
          while (v67 != v66);
          unint64_t v68 = v92;
        }
        BOOL v93 = v66;
        operator delete(v68);
      }
      if (v88 != v91) {
        free(v88);
      }
    }
    return 0;
  }
  return v47;
}

void mlir::mps::MPSDialect::printAttribute(uint64_t a1, uint64_t a2, mlir::AsmPrinter *a3)
{
  unsigned int v4 = *(void **)(*(void *)a2 + 136);
  if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    uint64_t v53 = a2;
    uint64_t v7 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v8 = *((void *)v7 + 4);
    if ((unint64_t)(*((void *)v7 + 3) - v8) > 0x11)
    {
      *(_WORD *)(v8 + 16) = 29813;
      *(_OWORD *)uint64_t v8 = *(_OWORD *)"tensor_data_layout";
      *((void *)v7 + 4) += 18;
    }
    else
    {
      llvm::raw_ostream::write(v7, "tensor_data_layout", 0x12uLL);
    }
    mlir::mps::TensorDataLayoutAttr::print((mlir::mps::TensorDataLayoutAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::ReductionModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    BOOL v9 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v10 = (void *)*((void *)v9 + 4);
    if (*((void *)v9 + 3) - (void)v10 > 0xDuLL)
    {
      qmemcpy(v10, "reduction_mode", 14);
      *((void *)v9 + 4) += 14;
    }
    else
    {
      llvm::raw_ostream::write(v9, "reduction_mode", 0xEuLL);
    }
    mlir::mps::ReductionModeAttr::print((mlir::mps::ReductionModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::DeviceHintAttr,void>::id)
  {
    uint64_t v53 = a2;
    uint64_t v11 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v12 = *((void *)v11 + 4);
    if ((unint64_t)(*((void *)v11 + 3) - v12) > 0xA)
    {
      *(_DWORD *)(v12 + 7) = 1953393000;
      *(void *)uint64_t v12 = *(void *)"device_hint";
      *((void *)v11 + 4) += 11;
    }
    else
    {
      llvm::raw_ostream::write(v11, "device_hint", 0xBuLL);
    }
    mlir::mps::DeviceHintAttr::print((mlir::mps::DeviceHintAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::ScatterModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    uint64_t v13 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v14 = *((void *)v13 + 4);
    if ((unint64_t)(*((void *)v13 + 3) - v14) > 0xB)
    {
      *(_DWORD *)(v14 + 8) = 1701080941;
      *(void *)uint64_t v14 = *(void *)"scatter_mode";
      *((void *)v13 + 4) += 12;
    }
    else
    {
      llvm::raw_ostream::write(v13, "scatter_mode", 0xCuLL);
    }
    mlir::mps::ScatterModeAttr::print((mlir::mps::ScatterModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    uint64_t v15 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v16 = *((void *)v15 + 4);
    if ((unint64_t)(*((void *)v15 + 3) - v16) > 0xB)
    {
      *(_DWORD *)(v16 + 8) = 1701080941;
      *(void *)uint64_t v16 = *(void *)"padding_mode";
      *((void *)v15 + 4) += 12;
    }
    else
    {
      llvm::raw_ostream::write(v15, "padding_mode", 0xCuLL);
    }
    mlir::mps::PaddingModeAttr::print((mlir::mps::PaddingModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    uint64_t v17 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    BOOL v18 = (void *)*((void *)v17 + 4);
    if (*((void *)v17 + 3) - (void)v18 > 0xCuLL)
    {
      qmemcpy(v18, "sampling_mode", 13);
      *((void *)v17 + 4) += 13;
    }
    else
    {
      llvm::raw_ostream::write(v17, "sampling_mode", 0xDuLL);
    }
    mlir::mps::SamplingModeAttr::print((mlir::mps::SamplingModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::NearestRoundingModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    long long v19 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    BOOL v20 = (void *)*((void *)v19 + 4);
    if (*((void *)v19 + 3) - (void)v20 > 0x14uLL)
    {
      qmemcpy(v20, "nearest_rounding_mode", 21);
      *((void *)v19 + 4) += 21;
    }
    else
    {
      llvm::raw_ostream::write(v19, "nearest_rounding_mode", 0x15uLL);
    }
    mlir::mps::NearestRoundingModeAttr::print((mlir::mps::NearestRoundingModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id)
  {
    uint64_t v53 = a2;
    BOOL v21 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v22 = (void *)*((void *)v21 + 4);
    if (*((void *)v21 + 3) - (void)v22 > 0x14uLL)
    {
      qmemcpy(v22, "sparse_tensor_storage", 21);
      *((void *)v21 + 4) += 21;
    }
    else
    {
      llvm::raw_ostream::write(v21, "sparse_tensor_storage", 0x15uLL);
    }
    mlir::mps::SparseTensorStorageAttr::print((mlir::mps::SparseTensorStorageAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id)
  {
    uint64_t v53 = a2;
    BOOL v23 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    BOOL v24 = (void *)*((void *)v23 + 4);
    if (*((void *)v23 + 3) - (void)v24 > 0x1AuLL)
    {
      qmemcpy(v24, "texture_tensor_pixel_format", 27);
      *((void *)v23 + 4) += 27;
    }
    else
    {
      llvm::raw_ostream::write(v23, "texture_tensor_pixel_format", 0x1BuLL);
    }
    mlir::mps::MetalPixelFormatAttr::print((mlir::mps::MetalPixelFormatAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id)
  {
    uint64_t v53 = a2;
    uint64_t v25 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v26 = (void *)*((void *)v25 + 4);
    if (*((void *)v25 + 3) - (void)v26 > 0x1CuLL)
    {
      qmemcpy(v26, "random_normal_sampling_method", 29);
      *((void *)v25 + 4) += 29;
    }
    else
    {
      llvm::raw_ostream::write(v25, "random_normal_sampling_method", 0x1DuLL);
    }
    mlir::mps::NormalSamplingMethodAttr::print((mlir::mps::NormalSamplingMethodAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
  {
    uint64_t v53 = a2;
    BOOL v27 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v28 = (void *)*((void *)v27 + 4);
    if (*((void *)v27 + 3) - (void)v28 > 0xCuLL)
    {
      qmemcpy(v28, "padding_style", 13);
      *((void *)v27 + 4) += 13;
    }
    else
    {
      llvm::raw_ostream::write(v27, "padding_style", 0xDuLL);
    }
    mlir::mps::PaddingStyleAttr::print((mlir::mps::PaddingStyleAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    long long v29 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v30 = *((void *)v29 + 4);
    if ((unint64_t)(*((void *)v29 + 3) - v30) > 0x13)
    {
      *(_DWORD *)(v30 + 16) = 1701080941;
      *(_OWORD *)uint64_t v30 = *(_OWORD *)"pooling_indices_mode";
      *((void *)v29 + 4) += 20;
    }
    else
    {
      llvm::raw_ostream::write(v29, "pooling_indices_mode", 0x14uLL);
    }
    mlir::mps::PoolIndicesModeAttr::print((mlir::mps::PoolIndicesModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
  {
    uint64_t v53 = a2;
    uint64_t v31 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    BOOL v32 = (void *)*((void *)v31 + 4);
    if (*((void *)v31 + 3) - (void)v32 > 0xDuLL)
    {
      qmemcpy(v32, "rnn_activation", 14);
      *((void *)v31 + 4) += 14;
    }
    else
    {
      llvm::raw_ostream::write(v31, "rnn_activation", 0xEuLL);
    }
    mlir::mps::RNNActivationAttr::print((mlir::mps::RNNActivationAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id)
  {
    uint64_t v53 = a2;
    uint64_t v33 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    BOOL v34 = (_OWORD *)*((void *)v33 + 4);
    if (*((void *)v33 + 3) - (void)v34 > 0xFuLL)
    {
      _OWORD *v34 = *(_OWORD *)"lstm_gate_layout";
      *((void *)v33 + 4) += 16;
    }
    else
    {
      llvm::raw_ostream::write(v33, "lstm_gate_layout", 0x10uLL);
    }
    mlir::mps::LSTMGateLayoutAttr::print((mlir::mps::LSTMGateLayoutAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id)
  {
    uint64_t v53 = a2;
    BOOL v35 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    unint64_t v36 = (void *)*((void *)v35 + 4);
    if (*((void *)v35 + 3) - (void)v36 > 0xEuLL)
    {
      qmemcpy(v36, "gru_gate_layout", 15);
      *((void *)v35 + 4) += 15;
    }
    else
    {
      llvm::raw_ostream::write(v35, "gru_gate_layout", 0xFuLL);
    }
    mlir::mps::GRUGateLayoutAttr::print((mlir::mps::GRUGateLayoutAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::StencilPaddingModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    BOOL v37 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v38 = *((void *)v37 + 4);
    if ((unint64_t)(*((void *)v37 + 3) - v38) > 0x13)
    {
      *(_DWORD *)(v38 + 16) = 1701080941;
      *(_OWORD *)uint64_t v38 = *(_OWORD *)"stencil_padding_mode";
      *((void *)v37 + 4) += 20;
    }
    else
    {
      llvm::raw_ostream::write(v37, "stencil_padding_mode", 0x14uLL);
    }
    mlir::mps::StencilPaddingModeAttr::print((mlir::mps::StencilPaddingModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    long long v39 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v40 = (void *)*((void *)v39 + 4);
    if (*((void *)v39 + 3) - (void)v40 > 0x19uLL)
    {
      qmemcpy(v40, "crop_resize_alignment_mode", 26);
      *((void *)v39 + 4) += 26;
    }
    else
    {
      llvm::raw_ostream::write(v39, "crop_resize_alignment_mode", 0x1AuLL);
    }
    mlir::mps::CropResizeAlignmentModeAttr::print((mlir::mps::CropResizeAlignmentModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    BOOL v41 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    BOOL v42 = (void *)*((void *)v41 + 4);
    if (*((void *)v41 + 3) - (void)v42 > 0x1AuLL)
    {
      qmemcpy(v42, "crop_resize_coordinate_mode", 27);
      *((void *)v41 + 4) += 27;
    }
    else
    {
      llvm::raw_ostream::write(v41, "crop_resize_coordinate_mode", 0x1BuLL);
    }
    mlir::mps::CropResizeCoordinateModeAttr::print((mlir::mps::CropResizeCoordinateModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id)
  {
    uint64_t v53 = a2;
    unint64_t v43 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    long long v44 = (void *)*((void *)v43 + 4);
    if (*((void *)v43 + 3) - (void)v44 > 0xDuLL)
    {
      qmemcpy(v44, "pruning_metric", 14);
      *((void *)v43 + 4) += 14;
    }
    else
    {
      llvm::raw_ostream::write(v43, "pruning_metric", 0xEuLL);
    }
    mlir::mps::PruningMetricAttr::print((mlir::mps::PruningMetricAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id)
  {
    uint64_t v53 = a2;
    unint64_t v45 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v46 = *((void *)v45 + 4);
    if ((unint64_t)(*((void *)v45 + 3) - v46) > 0x10)
    {
      *(unsigned char *)(v46 + 16) = 101;
      *(_OWORD *)uint64_t v46 = *(_OWORD *)"pruning_structure";
      *((void *)v45 + 4) += 17;
    }
    else
    {
      llvm::raw_ostream::write(v45, "pruning_structure", 0x11uLL);
    }
    mlir::mps::PruningStructureAttr::print((mlir::mps::PruningStructureAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id)
  {
    uint64_t v53 = a2;
    uint64_t v47 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    int64_t v48 = (void *)*((void *)v47 + 4);
    if (*((void *)v47 + 3) - (void)v48 > 0xEuLL)
    {
      qmemcpy(v48, "similarity_type", 15);
      *((void *)v47 + 4) += 15;
    }
    else
    {
      llvm::raw_ostream::write(v47, "similarity_type", 0xFuLL);
    }
    mlir::mps::SimilarityTypeAttr::print((mlir::mps::SimilarityTypeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    int64_t v49 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    long long v50 = (_OWORD *)*((void *)v49 + 4);
    if (*((void *)v49 + 3) - (void)v50 > 0xFuLL)
    {
      *long long v50 = *(_OWORD *)"fft_scaling_mode";
      *((void *)v49 + 4) += 16;
    }
    else
    {
      llvm::raw_ostream::write(v49, "fft_scaling_mode", 0x10uLL);
    }
    mlir::mps::FFTScalingModeAttr::print((mlir::mps::FFTScalingModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
  {
    uint64_t v53 = a2;
    uint64_t v51 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    long long v52 = (void *)*((void *)v51 + 4);
    if (*((void *)v51 + 3) - (void)v52 > 0xCuLL)
    {
      qmemcpy(v52, "buffer_tensor", 13);
      *((void *)v51 + 4) += 13;
    }
    else
    {
      llvm::raw_ostream::write(v51, "buffer_tensor", 0xDuLL);
    }
    mlir::mps::MPSBufferTensorAttr::print((mlir::mps::MPSBufferTensorAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id)
  {
    uint64_t v53 = a2;
    unsigned int v5 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v6 = (_OWORD *)*((void *)v5 + 4);
    if (*((void *)v5 + 3) - (void)v6 > 0xFuLL)
    {
      _OWORD *v6 = *(_OWORD *)"call_inline_mode";
      *((void *)v5 + 4) += 16;
    }
    else
    {
      llvm::raw_ostream::write(v5, "call_inline_mode", 0x10uLL);
    }
    mlir::mps::CallInlineModeAttr::print((mlir::mps::CallInlineModeAttr *)&v53, a3);
  }
}

uint64_t mlir::mps::detail::ACosOpGenericAdaptorBase::ACosOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.acos", 8, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(uint64_t a1, void **a2, void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v73 = *MEMORY[0x263EF8340];
  uint64_t v10 = *a2;
  uint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v63[0] = a2;
    v63[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v63);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange)
      || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      return 1;
    }
    uint64_t v10 = *a2;
    uint64_t v11 = (void *)*((void *)*a2 + 17);
  }
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    uint64_t v54 = a2;
    uint64_t v55 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t v14 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v54);
    if (*(_UNKNOWN **)(*(void *)v14 + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      uint64_t v42 = v14;
      uint64_t v59 = v14;
      uint64_t OperandRange = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v59);
      if (mlir::Type::isF16((mlir::Type *)&OperandRange)) {
        return 1;
      }
      uint64_t v57 = v42;
      uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v57);
      if (mlir::Type::isF32((mlir::Type *)&Value)) {
        return 1;
      }
    }
  }
  __int16 v56 = 261;
  uint64_t v54 = a3;
  uint64_t v55 = a4;
  mlir::Operation::emitOpError(a1, &v54, (uint64_t)v63);
  if (v63[0])
  {
    LODWORD(OperandRange) = 3;
    uint64_t v61 = " #";
    uint64_t v62 = 2;
    p_uint64_t OperandRange = &OperandRange;
    uint64_t v16 = (char *)v64;
    if (v65 >= v66)
    {
      unint64_t v44 = v65 + 1;
      if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
      {
        int64_t v50 = (char *)&OperandRange - (unsigned char *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        uint64_t v16 = (char *)v64;
        p_uint64_t OperandRange = (uint64_t *)((char *)v64 + v50);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        p_uint64_t OperandRange = &OperandRange;
        uint64_t v16 = (char *)v64;
      }
    }
    uint64_t v17 = &v16[24 * v65];
    long long v18 = *(_OWORD *)p_OperandRange;
    *((void *)v17 + 2) = p_OperandRange[2];
    *(_OWORD *)uint64_t v17 = v18;
    uint64_t v19 = ++v65;
    if (v63[0])
    {
      LODWORD(OperandRange) = 5;
      uint64_t v61 = (const char *)a5;
      BOOL v20 = &OperandRange;
      BOOL v21 = (char *)v64;
      if (v19 >= v66)
      {
        unint64_t v45 = v19 + 1;
        BOOL v46 = (char *)v64 + 24 * v19 > (char *)&OperandRange;
        if (v64 <= &OperandRange && v46)
        {
          int64_t v51 = (char *)&OperandRange - (unsigned char *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          BOOL v21 = (char *)v64;
          BOOL v20 = (uint64_t *)((char *)v64 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          BOOL v20 = &OperandRange;
          BOOL v21 = (char *)v64;
        }
      }
      uint64_t v22 = &v21[24 * v65];
      long long v23 = *(_OWORD *)v20;
      *((void *)v22 + 2) = v20[2];
      *(_OWORD *)uint64_t v22 = v23;
      uint64_t v24 = ++v65;
      if (v63[0])
      {
        LODWORD(OperandRange) = 3;
        uint64_t v61 = " must be tensor of mps native type values or tensor of complex values, but got ";
        uint64_t v62 = 79;
        uint64_t v25 = &OperandRange;
        uint64_t v26 = (char *)v64;
        if (v24 >= v66)
        {
          unint64_t v47 = v24 + 1;
          BOOL v48 = (char *)v64 + 24 * v24 > (char *)&OperandRange;
          if (v64 <= &OperandRange && v48)
          {
            int64_t v52 = (char *)&OperandRange - (unsigned char *)v64;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            uint64_t v26 = (char *)v64;
            uint64_t v25 = (uint64_t *)((char *)v64 + v52);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            uint64_t v25 = &OperandRange;
            uint64_t v26 = (char *)v64;
          }
        }
        BOOL v27 = &v26[24 * v65];
        long long v28 = *(_OWORD *)v25;
        *((void *)v27 + 2) = v25[2];
        *(_OWORD *)BOOL v27 = v28;
        ++v65;
        if (v63[0])
        {
          long long v29 = &OperandRange;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, (uint64_t)a2);
          uint64_t v30 = (char *)v64;
          if (v65 >= v66)
          {
            unint64_t v49 = v65 + 1;
            if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
            {
              int64_t v53 = (char *)&OperandRange - (unsigned char *)v64;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              uint64_t v30 = (char *)v64;
              long long v29 = (uint64_t *)((char *)v64 + v53);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              long long v29 = &OperandRange;
              uint64_t v30 = (char *)v64;
            }
          }
          uint64_t v31 = &v30[24 * v65];
          long long v32 = *(_OWORD *)v29;
          *((void *)v31 + 2) = v29[2];
          *(_OWORD *)uint64_t v31 = v32;
          ++v65;
        }
      }
    }
  }
  uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v63);
  if (v63[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
  }
  if (v72)
  {
    BOOL v34 = __p;
    if (__p)
    {
      BOOL v35 = v71;
      unint64_t v36 = __p;
      if (v71 != __p)
      {
        do
          BOOL v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        unint64_t v36 = __p;
      }
      BOOL v71 = v34;
      operator delete(v36);
    }
    BOOL v37 = v68;
    if (v68)
    {
      uint64_t v38 = v69;
      long long v39 = v68;
      if (v69 != v68)
      {
        do
        {
          uint64_t v41 = *--v38;
          uint64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            MEMORY[0x21667D390](v40, 0x1000C8077774924);
          }
        }
        while (v38 != v37);
        long long v39 = v68;
      }
      uint64_t v69 = v37;
      operator delete(v39);
    }
    if (v64 != v67) {
      free(v64);
    }
  }
  return v33;
}

void mlir::mps::ACosOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::ACoshOpGenericAdaptorBase::ACoshOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.acosh", 9, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ACoshOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::ASinOpGenericAdaptorBase::ASinOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.asin", 8, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ASinOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::ASinhOpGenericAdaptorBase::ASinhOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.asinh", 9, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ASinhOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::ATan2OpGenericAdaptorBase::ATan2OpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.atan2", 9, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::ATan2Op::verifyInvariantsImpl(mlir::mps::ATan2Op *this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v2 = *(void *)this - 16;
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
}

void mlir::mps::ATan2Op::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::ATanOpGenericAdaptorBase::ATanOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.atan", 8, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ATanOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::ATanhOpGenericAdaptorBase::ATanhOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.atanh", 9, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ATanhOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::AbsoluteOpGenericAdaptorBase::AbsoluteOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.absolute", 12, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::AbsoluteOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::AbsoluteSquareOpGenericAdaptorBase::AbsoluteSquareOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.absolute_square", 19, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::AbsoluteSquareOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::AddOpGenericAdaptorBase::AddOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.add", 7, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::AddOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::AndOpGenericAdaptorBase::AndOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.and", 7, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::AndOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::AssignVariableOpGenericAdaptorBase::AssignVariableOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.assign_variable", 19, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::AssignVariableOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

void mlir::mps::AssignVariableOp::getEffects(uint64_t a1, uint64_t a2)
{
  v26[2] = *MEMORY[0x263EF8340];
  unsigned int v3 = mlir::SideEffects::Effect::Base<mlir::MemoryEffects::Write,mlir::MemoryEffects::Effect>::get();
  {
    uint64_t v22 = v3;
    unsigned int v3 = v22;
    if (v13)
    {
      {
        long long v23 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::SideEffects::DefaultResource]";
        unint64_t v24 = 84;
        unint64_t v15 = llvm::StringRef::find((uint64_t *)&v23, "DesiredTypeName = ", 0x12uLL, 0);
        if (v24 >= v15) {
          unint64_t v16 = v15;
        }
        else {
          unint64_t v16 = v24;
        }
        uint64_t v17 = &v23[v16];
        unint64_t v18 = v24 - v16;
        if (v24 - v16 >= 0x12) {
          uint64_t v19 = 18;
        }
        else {
          uint64_t v19 = v24 - v16;
        }
        unint64_t v20 = v18 - v19;
        if (v20 >= v20 - 1) {
          uint64_t v21 = v20 - 1;
        }
        else {
          uint64_t v21 = v20;
        }
        mlir::detail::TypeIDResolver<mlir::SideEffects::DefaultResource,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v17[v19], v21);
      }
      mlir::SideEffects::Resource::Base<mlir::SideEffects::DefaultResource,mlir::SideEffects::Resource>::get(void)::instance = (uint64_t)&unk_26C35C6D0;
      *(void *)algn_267771CD8 = mlir::detail::TypeIDResolver<mlir::SideEffects::DefaultResource,void>::resolveTypeID(void)::id;
      __cxa_atexit((void (*)(void *))mlir::SideEffects::DefaultResource::~DefaultResource, &mlir::SideEffects::Resource::Base<mlir::SideEffects::DefaultResource,mlir::SideEffects::Resource>::get(void)::instance, &dword_210C72000);
      unsigned int v3 = v22;
    }
  }
  uint64_t v4 = *(unsigned int *)(a2 + 8);
  if (v4 >= *(_DWORD *)(a2 + 12))
  {
    long long v23 = (const char *)v3;
    unint64_t v24 = (unint64_t)&mlir::SideEffects::Resource::Base<mlir::SideEffects::DefaultResource,mlir::SideEffects::Resource>::get(void)::instance;
    unint64_t v6 = v4 + 1;
    uint64_t v25 = 0;
    v26[0] = 0;
    *(void *)((char *)v26 + 5) = 0;
    BOOL v7 = *(void *)a2 + 40 * (unint64_t)v4 > (unint64_t)&v23;
    if (*(void *)a2 <= (unint64_t)&v23 && v7)
    {
      uint64_t v14 = (char *)&v23 - *(void *)a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v6, 40);
      uint64_t v8 = *(void *)a2;
      BOOL v9 = (const char **)&v14[*(void *)a2];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v6, 40);
      uint64_t v8 = *(void *)a2;
      BOOL v9 = &v23;
    }
    uint64_t v10 = v8 + 40 * *(unsigned int *)(a2 + 8);
    long long v11 = *(_OWORD *)v9;
    long long v12 = *((_OWORD *)v9 + 1);
    *(void *)(v10 + 32) = v9[4];
    *(_OWORD *)uint64_t v10 = v11;
    *(_OWORD *)(v10 + 16) = v12;
  }
  else
  {
    unint64_t v5 = (uint64_t **)(*(void *)a2 + 40 * v4);
    *unint64_t v5 = v3;
    v5[1] = &mlir::SideEffects::Resource::Base<mlir::SideEffects::DefaultResource,mlir::SideEffects::Resource>::get(void)::instance;
    v5[2] = 0;
    v5[3] = 0;
    *(uint64_t **)((char *)v5 + 29) = 0;
  }
  ++*(_DWORD *)(a2 + 8);
}

uint64_t mlir::mps::detail::BandPartOpGenericAdaptorBase::BandPartOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.band_part", 13, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::BandPartOp::verifyInvariantsImpl(mlir::mps::BandPartOp *this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 2u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v2 = *(void *)this - 16;
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(uint64_t a1, void **a2, void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v82 = *MEMORY[0x263EF8340];
  uint64_t v10 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    goto LABEL_4;
  }
  v71[0] = a2;
  v71[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  int ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v71);
  uint64_t v10 = *a2;
  if (!ArgOperands) {
    goto LABEL_4;
  }
  uint64_t v61 = a2;
  uint64_t v62 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  mlir::ShapedType::getShape((mlir::ShapedType *)&v61);
  uint64_t v10 = *a2;
  if (!v12)
  {
    uint64_t v47 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
    unint64_t v68 = a2;
    uint64_t v69 = v47;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v68);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
    {
      return 1;
    }
    uint64_t v10 = *a2;
    unint64_t v49 = (void *)*((void *)*a2 + 17);
    if (v49 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v49 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_13;
    }
  }
  else
  {
LABEL_4:
    int v13 = (void *)v10[17];
    if (v13 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v13 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_13;
    }
  }
  uint64_t v15 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  v66[0] = a2;
  v66[1] = v15;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v66);
  if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
  {
    uint64_t v16 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    v65[0] = a2;
    v65[1] = v16;
    Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v65);
    uint64_t v81 = 1;
    if (v18 == 1 && *Shape == v81) {
      return 1;
    }
  }
LABEL_13:
  if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    uint64_t v46 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    v64[0] = a2;
    v64[1] = v46;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v64);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
    {
      return 1;
    }
  }
  __int16 v63 = 261;
  uint64_t v61 = a3;
  uint64_t v62 = a4;
  mlir::Operation::emitOpError(a1, &v61, (uint64_t)v71);
  if (v71[0])
  {
    LODWORD(v68) = 3;
    uint64_t v69 = (uint64_t)" #";
    uint64_t v70 = 2;
    uint64_t v19 = &v68;
    unint64_t v20 = (char *)v72;
    if (v73 >= v74)
    {
      unint64_t v51 = v73 + 1;
      if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
      {
        int64_t v57 = (char *)&v68 - (unsigned char *)v72;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v51, 24);
        unint64_t v20 = (char *)v72;
        uint64_t v19 = (void ***)((char *)v72 + v57);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v51, 24);
        uint64_t v19 = &v68;
        unint64_t v20 = (char *)v72;
      }
    }
    uint64_t v21 = &v20[24 * v73];
    long long v22 = *(_OWORD *)v19;
    *((void *)v21 + 2) = v19[2];
    *(_OWORD *)uint64_t v21 = v22;
    uint64_t v23 = ++v73;
    if (v71[0])
    {
      LODWORD(v68) = 5;
      uint64_t v69 = a5;
      unint64_t v24 = &v68;
      uint64_t v25 = (char *)v72;
      if (v23 >= v74)
      {
        unint64_t v52 = v23 + 1;
        BOOL v53 = (char *)v72 + 24 * v23 > (char *)&v68;
        if (v72 <= &v68 && v53)
        {
          int64_t v58 = (char *)&v68 - (unsigned char *)v72;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v52, 24);
          uint64_t v25 = (char *)v72;
          unint64_t v24 = (void ***)((char *)v72 + v58);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v52, 24);
          unint64_t v24 = &v68;
          uint64_t v25 = (char *)v72;
        }
      }
      uint64_t v26 = &v25[24 * v73];
      long long v27 = *(_OWORD *)v24;
      *((void *)v26 + 2) = v24[2];
      *(_OWORD *)uint64_t v26 = v27;
      uint64_t v28 = ++v73;
      if (v71[0])
      {
        LODWORD(v68) = 3;
        uint64_t v69 = (uint64_t)" must be 0D tensor of mps index type values or static-shape defined tensor with shape equal to [1"
                       "] or unranked tensor of mps index type values, but got ";
        uint64_t v70 = 152;
        long long v29 = &v68;
        uint64_t v30 = (char *)v72;
        if (v28 >= v74)
        {
          unint64_t v54 = v28 + 1;
          BOOL v55 = (char *)v72 + 24 * v28 > (char *)&v68;
          if (v72 <= &v68 && v55)
          {
            int64_t v59 = (char *)&v68 - (unsigned char *)v72;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
            uint64_t v30 = (char *)v72;
            long long v29 = (void ***)((char *)v72 + v59);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
            long long v29 = &v68;
            uint64_t v30 = (char *)v72;
          }
        }
        uint64_t v31 = &v30[24 * v73];
        long long v32 = *(_OWORD *)v29;
        *((void *)v31 + 2) = v29[2];
        *(_OWORD *)uint64_t v31 = v32;
        ++v73;
        if (v71[0])
        {
          uint64_t v33 = &v68;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v68, (uint64_t)a2);
          BOOL v34 = (char *)v72;
          if (v73 >= v74)
          {
            unint64_t v56 = v73 + 1;
            if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
            {
              int64_t v60 = (char *)&v68 - (unsigned char *)v72;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
              BOOL v34 = (char *)v72;
              uint64_t v33 = (void ***)((char *)v72 + v60);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
              uint64_t v33 = &v68;
              BOOL v34 = (char *)v72;
            }
          }
          BOOL v35 = &v34[24 * v73];
          long long v36 = *(_OWORD *)v33;
          *((void *)v35 + 2) = v33[2];
          *(_OWORD *)BOOL v35 = v36;
          ++v73;
        }
      }
    }
  }
  uint64_t v37 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v71);
  if (v71[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v71);
  }
  if (v80)
  {
    uint64_t v38 = __p;
    if (__p)
    {
      long long v39 = v79;
      uint64_t v40 = __p;
      if (v79 != __p)
      {
        do
          long long v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v39 - 1);
        while (v39 != v38);
        uint64_t v40 = __p;
      }
      int64_t v79 = v38;
      operator delete(v40);
    }
    uint64_t v41 = v76;
    if (v76)
    {
      uint64_t v42 = v77;
      unint64_t v43 = v76;
      if (v77 != v76)
      {
        do
        {
          uint64_t v45 = *--v42;
          uint64_t v44 = v45;
          *uint64_t v42 = 0;
          if (v45) {
            MEMORY[0x21667D390](v44, 0x1000C8077774924);
          }
        }
        while (v42 != v41);
        unint64_t v43 = v76;
      }
      int64_t v77 = v41;
      operator delete(v43);
    }
    if (v72 != v75) {
      free(v72);
    }
  }
  return v37;
}

void mlir::mps::BandPartOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::BatchToSpaceOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  unint64_t v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.batch_to_space", 18, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::BatchToSpaceOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      int v44 = 3;
      uint64_t v45 = "expected DictionaryAttr to set properties";
      uint64_t v46 = 41;
      uint64_t v26 = &v44;
      long long v27 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v40 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          long long v27 = (char *)v48;
          uint64_t v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          uint64_t v26 = &v44;
          long long v27 = (char *)v48;
        }
      }
      uint64_t v28 = &v27[24 * v49];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
    if (!v56) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      uint64_t v31 = v55;
      long long v32 = __p;
      if (v55 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        long long v32 = __p;
      }
      BOOL v55 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v52;
    if (!v52) {
      goto LABEL_43;
    }
    uint64_t v33 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "pixel_shuffle", 0xDuLL);
  if (!v8) {
    return 1;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    int v44 = 3;
    uint64_t v46 = 58;
    uint64_t v10 = &v44;
    uint64_t v11 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        int64_t v41 = (char *)&v44 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v11 = (char *)v48;
        uint64_t v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v10 = &v44;
        uint64_t v11 = (char *)v48;
      }
    }
    uint64_t v12 = &v11[24 * v49];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v49;
    if (v47[0])
    {
      uint64_t v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      uint64_t v15 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v42 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v15 = (char *)v48;
          uint64_t v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v14 = &v44;
          uint64_t v15 = (char *)v48;
        }
      }
      uint64_t v16 = &v15[24 * v49];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)uint64_t v16 = v17;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
  }
  if (!v56) {
    return 0;
  }
  uint64_t v18 = __p;
  if (__p)
  {
    uint64_t v19 = v55;
    unint64_t v20 = __p;
    if (v55 != __p)
    {
      do
        uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      unint64_t v20 = __p;
    }
    BOOL v55 = v18;
    operator delete(v20);
  }
  uint64_t v21 = v52;
  if (v52)
  {
    long long v22 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v25 = *--v22;
      uint64_t v24 = v25;
      void *v22 = 0;
      if (v25) {
        MEMORY[0x21667D390](v24, 0x1000C8077774924);
      }
    }
    while (v22 != v21);
LABEL_41:
    uint64_t v23 = v52;
LABEL_42:
    BOOL v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51) {
    free(v48);
  }
  return 0;
}

uint64_t mlir::mps::BatchToSpaceOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x263EF8340];
  uint64_t v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"pixel_shuffle", 13, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  uint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::BatchToSpaceOp::verifyInvariantsImpl(mlir::mps::BatchToSpaceOp *this)
{
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(void *)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  uint64_t v7 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v3, (void **)"pixel_shuffle", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*(void *)this,
                           (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8),
                           (void **)"operand",
                           7,
                           2u)
    || !mlir::mps::__mlir_ods_local_type_constraint_MPSOps4(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 120) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 3u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v4 = *(void *)this - 16;
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(uint64_t a1, void **a2, void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v79 = *MEMORY[0x263EF8340];
  uint64_t v10 = (_UNKNOWN **)*a2;
  if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    goto LABEL_4;
  }
  v69[0] = a2;
  v69[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  int ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v69);
  uint64_t v10 = (_UNKNOWN **)*a2;
  if (!ArgOperands) {
    goto LABEL_4;
  }
  int64_t v58 = a2;
  uint64_t v59 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  mlir::ShapedType::getShape((mlir::ShapedType *)&v58);
  uint64_t v10 = (_UNKNOWN **)*a2;
  if (!v12)
  {
    uint64_t v18 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
    unsigned int v66 = a2;
    uint64_t v67 = v18;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v66);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
    {
      return 1;
    }
    uint64_t v10 = (_UNKNOWN **)*a2;
    if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
      goto LABEL_13;
    }
  }
  else
  {
LABEL_4:
    if (v10[17] != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
      goto LABEL_13;
    }
  }
  uint64_t v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  v64[0] = a2;
  v64[1] = v13;
  int v14 = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v64);
  uint64_t v10 = (_UNKNOWN **)*a2;
  if (v14)
  {
    uint64_t v15 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
    v63[0] = a2;
    v63[1] = v15;
    mlir::ShapedType::getShape((mlir::ShapedType *)v63);
    uint64_t v10 = (_UNKNOWN **)*a2;
    if (v16 == 1)
    {
      uint64_t v17 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
      v62[0] = a2;
      v62[1] = v17;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v62);
      if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
      {
        return 1;
      }
      uint64_t v10 = (_UNKNOWN **)*a2;
    }
  }
LABEL_13:
  if (v10[17] == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    uint64_t v46 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
    v61[0] = a2;
    v61[1] = v46;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
    {
      return 1;
    }
  }
  __int16 v60 = 261;
  int64_t v58 = a3;
  uint64_t v59 = a4;
  mlir::Operation::emitOpError(a1, &v58, (uint64_t)v69);
  if (v69[0])
  {
    LODWORD(v66) = 3;
    uint64_t v67 = (uint64_t)" #";
    uint64_t v68 = 2;
    uint64_t v19 = &v66;
    unint64_t v20 = (char *)v70;
    if (v71 >= v72)
    {
      unint64_t v48 = v71 + 1;
      if (v70 <= &v66 && (char *)v70 + 24 * v71 > (char *)&v66)
      {
        int64_t v54 = (char *)&v66 - (unsigned char *)v70;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v48, 24);
        unint64_t v20 = (char *)v70;
        uint64_t v19 = (void ***)((char *)v70 + v54);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v48, 24);
        uint64_t v19 = &v66;
        unint64_t v20 = (char *)v70;
      }
    }
    uint64_t v21 = &v20[24 * v71];
    long long v22 = *(_OWORD *)v19;
    *((void *)v21 + 2) = v19[2];
    *(_OWORD *)uint64_t v21 = v22;
    uint64_t v23 = ++v71;
    if (v69[0])
    {
      LODWORD(v66) = 5;
      uint64_t v67 = a5;
      uint64_t v24 = &v66;
      uint64_t v25 = (char *)v70;
      if (v23 >= v72)
      {
        unint64_t v49 = v23 + 1;
        BOOL v50 = (char *)v70 + 24 * v23 > (char *)&v66;
        if (v70 <= &v66 && v50)
        {
          int64_t v55 = (char *)&v66 - (unsigned char *)v70;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v49, 24);
          uint64_t v25 = (char *)v70;
          uint64_t v24 = (void ***)((char *)v70 + v55);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v49, 24);
          uint64_t v24 = &v66;
          uint64_t v25 = (char *)v70;
        }
      }
      uint64_t v26 = &v25[24 * v71];
      long long v27 = *(_OWORD *)v24;
      *((void *)v26 + 2) = v24[2];
      *(_OWORD *)uint64_t v26 = v27;
      uint64_t v28 = ++v71;
      if (v69[0])
      {
        LODWORD(v66) = 3;
        uint64_t v67 = (uint64_t)" must be 0D tensor of mps index type values or 1D tensor of mps index type values or unranked ten"
                       "sor of mps index type values, but got ";
        uint64_t v68 = 135;
        long long v29 = &v66;
        uint64_t v30 = (char *)v70;
        if (v28 >= v72)
        {
          unint64_t v51 = v28 + 1;
          BOOL v52 = (char *)v70 + 24 * v28 > (char *)&v66;
          if (v70 <= &v66 && v52)
          {
            int64_t v56 = (char *)&v66 - (unsigned char *)v70;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v51, 24);
            uint64_t v30 = (char *)v70;
            long long v29 = (void ***)((char *)v70 + v56);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v51, 24);
            long long v29 = &v66;
            uint64_t v30 = (char *)v70;
          }
        }
        uint64_t v31 = &v30[24 * v71];
        long long v32 = *(_OWORD *)v29;
        *((void *)v31 + 2) = v29[2];
        *(_OWORD *)uint64_t v31 = v32;
        ++v71;
        if (v69[0])
        {
          uint64_t v33 = &v66;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v66, (uint64_t)a2);
          uint64_t v34 = (char *)v70;
          if (v71 >= v72)
          {
            unint64_t v53 = v71 + 1;
            if (v70 <= &v66 && (char *)v70 + 24 * v71 > (char *)&v66)
            {
              int64_t v57 = (char *)&v66 - (unsigned char *)v70;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v53, 24);
              uint64_t v34 = (char *)v70;
              uint64_t v33 = (void ***)((char *)v70 + v57);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v53, 24);
              uint64_t v33 = &v66;
              uint64_t v34 = (char *)v70;
            }
          }
          uint64_t v35 = &v34[24 * v71];
          long long v36 = *(_OWORD *)v33;
          *((void *)v35 + 2) = v33[2];
          *(_OWORD *)uint64_t v35 = v36;
          ++v71;
        }
      }
    }
  }
  uint64_t v37 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v69);
  if (v69[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v69);
  }
  if (v78)
  {
    unint64_t v38 = __p;
    if (__p)
    {
      unint64_t v39 = v77;
      int64_t v40 = __p;
      if (v77 != __p)
      {
        do
          unint64_t v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v39 - 1);
        while (v39 != v38);
        int64_t v40 = __p;
      }
      int64_t v77 = v38;
      operator delete(v40);
    }
    int64_t v41 = v74;
    if (v74)
    {
      int64_t v42 = v75;
      uint64_t v43 = v74;
      if (v75 != v74)
      {
        do
        {
          uint64_t v45 = *--v42;
          uint64_t v44 = v45;
          *int64_t v42 = 0;
          if (v45) {
            MEMORY[0x21667D390](v44, 0x1000C8077774924);
          }
        }
        while (v42 != v41);
        uint64_t v43 = v74;
      }
      unint64_t v75 = v41;
      operator delete(v43);
    }
    if (v70 != v73) {
      free(v70);
    }
  }
  return v37;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps4(uint64_t a1, void **a2, void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  uint64_t v10 = *a2;
  uint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v61[0] = a2;
    v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    {
      return 1;
    }
    uint64_t v10 = *a2;
    if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_3:
      unint64_t v53 = a2;
      uint64_t v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53)) {
        goto LABEL_24;
      }
      uint64_t v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      int64_t v58 = a2;
      uint64_t v59 = v12;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v58);
      if (v13 != 1) {
        goto LABEL_24;
      }
      uint64_t v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v56[0] = a2;
      v56[1] = v14;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
      if (!mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
        && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
        && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
        && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
        && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
        && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
        && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
        && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
      {
        goto LABEL_24;
      }
      return 1;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    goto LABEL_3;
  }
LABEL_24:
  __int16 v55 = 261;
  unint64_t v53 = a3;
  uint64_t v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    uint64_t v59 = (uint64_t)" #";
    uint64_t v60 = 2;
    uint64_t v16 = &v58;
    uint64_t v17 = (char *)v62;
    if (v63 >= v64)
    {
      unint64_t v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        int64_t v49 = (char *)&v58 - (unsigned char *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        uint64_t v17 = (char *)v62;
        uint64_t v16 = (void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        uint64_t v16 = &v58;
        uint64_t v17 = (char *)v62;
      }
    }
    uint64_t v18 = &v17[24 * v63];
    long long v19 = *(_OWORD *)v16;
    *((void *)v18 + 2) = v16[2];
    *(_OWORD *)uint64_t v18 = v19;
    uint64_t v20 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      uint64_t v59 = a5;
      uint64_t v21 = &v58;
      long long v22 = (char *)v62;
      if (v20 >= v64)
      {
        unint64_t v44 = v20 + 1;
        BOOL v45 = (char *)v62 + 24 * v20 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          int64_t v50 = (char *)&v58 - (unsigned char *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          long long v22 = (char *)v62;
          uint64_t v21 = (void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          uint64_t v21 = &v58;
          long long v22 = (char *)v62;
        }
      }
      uint64_t v23 = &v22[24 * v63];
      long long v24 = *(_OWORD *)v21;
      *((void *)v23 + 2) = v21[2];
      *(_OWORD *)uint64_t v23 = v24;
      uint64_t v25 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        uint64_t v59 = (uint64_t)" must be unranked tensor of int values or 1D tensor of int values, but got ";
        uint64_t v60 = 75;
        uint64_t v26 = &v58;
        long long v27 = (char *)v62;
        if (v25 >= v64)
        {
          unint64_t v46 = v25 + 1;
          BOOL v47 = (char *)v62 + 24 * v25 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            int64_t v51 = (char *)&v58 - (unsigned char *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            long long v27 = (char *)v62;
            uint64_t v26 = (void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            uint64_t v26 = &v58;
            long long v27 = (char *)v62;
          }
        }
        uint64_t v28 = &v27[24 * v63];
        long long v29 = *(_OWORD *)v26;
        *((void *)v28 + 2) = v26[2];
        *(_OWORD *)uint64_t v28 = v29;
        ++v63;
        if (v61[0])
        {
          uint64_t v30 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          uint64_t v31 = (char *)v62;
          if (v63 >= v64)
          {
            unint64_t v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              int64_t v52 = (char *)&v58 - (unsigned char *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              uint64_t v31 = (char *)v62;
              uint64_t v30 = (void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              uint64_t v30 = &v58;
              uint64_t v31 = (char *)v62;
            }
          }
          long long v32 = &v31[24 * v63];
          long long v33 = *(_OWORD *)v30;
          *((void *)v32 + 2) = v30[2];
          *(_OWORD *)long long v32 = v33;
          ++v63;
        }
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  }
  if (v70)
  {
    uint64_t v34 = __p;
    if (__p)
    {
      uint64_t v35 = v69;
      long long v36 = __p;
      if (v69 != __p)
      {
        do
          uint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        long long v36 = __p;
      }
      uint64_t v69 = v34;
      operator delete(v36);
    }
    uint64_t v37 = v66;
    if (v66)
    {
      unint64_t v38 = v67;
      unint64_t v39 = v66;
      if (v67 != v66)
      {
        do
        {
          uint64_t v41 = *--v38;
          uint64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            MEMORY[0x21667D390](v40, 0x1000C8077774924);
          }
        }
        while (v38 != v37);
        unint64_t v39 = v66;
      }
      uint64_t v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65) {
      free(v62);
    }
  }
  return v15;
}

void mlir::mps::BatchToSpaceOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::BiasAddGradOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      int v44 = 3;
      BOOL v45 = "expected DictionaryAttr to set properties";
      uint64_t v46 = 41;
      uint64_t v26 = &v44;
      long long v27 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v40 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          long long v27 = (char *)v48;
          uint64_t v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          uint64_t v26 = &v44;
          long long v27 = (char *)v48;
        }
      }
      uint64_t v28 = &v27[24 * v49];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
    if (!v56) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      uint64_t v31 = v55;
      long long v32 = __p;
      if (v55 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        long long v32 = __p;
      }
      __int16 v55 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v52;
    if (!v52) {
      goto LABEL_43;
    }
    long long v33 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *long long v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "data_format", 0xBuLL);
  if (!v8) {
    return 1;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    int v44 = 3;
    uint64_t v46 = 56;
    uint64_t v10 = &v44;
    uint64_t v11 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        int64_t v41 = (char *)&v44 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v11 = (char *)v48;
        uint64_t v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v10 = &v44;
        uint64_t v11 = (char *)v48;
      }
    }
    uint64_t v12 = &v11[24 * v49];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v49;
    if (v47[0])
    {
      uint64_t v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      uint64_t v15 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v42 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v15 = (char *)v48;
          uint64_t v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v14 = &v44;
          uint64_t v15 = (char *)v48;
        }
      }
      uint64_t v16 = &v15[24 * v49];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)uint64_t v16 = v17;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
  }
  if (!v56) {
    return 0;
  }
  uint64_t v18 = __p;
  if (__p)
  {
    long long v19 = v55;
    uint64_t v20 = __p;
    if (v55 != __p)
    {
      do
        long long v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      uint64_t v20 = __p;
    }
    __int16 v55 = v18;
    operator delete(v20);
  }
  uint64_t v21 = v52;
  if (v52)
  {
    long long v22 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v25 = *--v22;
      uint64_t v24 = v25;
      void *v22 = 0;
      if (v25) {
        MEMORY[0x21667D390](v24, 0x1000C8077774924);
      }
    }
    while (v22 != v21);
LABEL_41:
    uint64_t v23 = v52;
LABEL_42:
    unint64_t v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51) {
    free(v48);
  }
  return 0;
}

uint64_t mlir::mps::BiasAddGradOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x263EF8340];
  uint64_t v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"data_format", 11, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  uint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(_DWORD *a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id
    && a1[2] < 2u)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    BOOL v8 = &v29;
    uint64_t v9 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v9 = (char *)v35;
        BOOL v8 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        BOOL v8 = &v29;
        uint64_t v9 = (char *)v35;
      }
    }
    uint64_t v10 = &v9[24 * v36];
    long long v11 = *(_OWORD *)v8;
    *((void *)v10 + 2) = v8[2];
    *(_OWORD *)uint64_t v10 = v11;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      long long v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid TensorDataLayout is NHWC or NCHW";
        uint64_t v31 = 70;
        uint64_t v12 = &v29;
        long long v13 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            long long v13 = (char *)v35;
            uint64_t v12 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = &v29;
            long long v13 = (char *)v35;
          }
        }
        uint64_t v14 = &v13[24 * v36];
        long long v15 = *(_OWORD *)v12;
        *((void *)v14 + 2) = v12[2];
        *(_OWORD *)uint64_t v14 = v15;
        ++v36;
      }
    }
  }
  uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = __p;
    if (__p)
    {
      long long v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          long long v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      int64_t v42 = v16;
      operator delete(v18);
    }
    long long v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      uint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        uint64_t v21 = v39;
      }
      int64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v7;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::TensorDataLayoutAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  unsigned int v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    uint64_t v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        uint64_t v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    BOOL v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)BOOL v8 = v9;
    ++v47;
  }
  int64_t v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::TensorDataLayoutAttr]";
  unint64_t v41 = 81;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    int64_t v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      uint64_t v14 = &v40;
      long long v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v15 = (char *)v46;
          uint64_t v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v14 = &v40;
          long long v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        long long v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            long long v19 = (char *)v46;
            uint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            long long v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      uint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      unint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      int64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

BOOL mlir::mps::BiasAddGradOp::verifyInvariantsImpl(mlir::mps::BiasAddGradOp *this)
{
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(_DWORD **)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  uint64_t v7 = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(v3, (void **)"data_format", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v4 = *(void *)this - 16;
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(uint64_t a1, uint64_t a2, void **a3, void **a4, unsigned int a5)
{
  uint64_t v66 = *MEMORY[0x263EF8340];
  uint64_t v10 = *(void *)a2;
  unint64_t v11 = *(void **)(*(void *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isF16((mlir::Type *)v51)
      || mlir::Type::isF32((mlir::Type *)v51)
      || mlir::Type::isBF16((mlir::Type *)v51))
    {
      return 1;
    }
  }
  __int16 v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    int v53 = 3;
    char v54 = " #";
    uint64_t v55 = 2;
    uint64_t v14 = &v53;
    long long v15 = (char *)v57;
    if (v58 >= v59)
    {
      unint64_t v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        int64_t v47 = (char *)&v53 - (unsigned char *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        long long v15 = (char *)v57;
        uint64_t v14 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        uint64_t v14 = &v53;
        long long v15 = (char *)v57;
      }
    }
    uint64_t v16 = &v15[24 * v58];
    long long v17 = *(_OWORD *)v14;
    *((void *)v16 + 2) = *((void *)v14 + 2);
    *(_OWORD *)uint64_t v16 = v17;
    uint64_t v18 = ++v58;
    if (v56[0])
    {
      int v53 = 5;
      char v54 = (const char *)a5;
      long long v19 = &v53;
      uint64_t v20 = (char *)v57;
      if (v18 >= v59)
      {
        unint64_t v42 = v18 + 1;
        BOOL v43 = (char *)v57 + 24 * v18 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          int64_t v48 = (char *)&v53 - (unsigned char *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          uint64_t v20 = (char *)v57;
          long long v19 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          long long v19 = &v53;
          uint64_t v20 = (char *)v57;
        }
      }
      long long v21 = &v20[24 * v58];
      long long v22 = *(_OWORD *)v19;
      *((void *)v21 + 2) = *((void *)v19 + 2);
      *(_OWORD *)long long v21 = v22;
      uint64_t v23 = ++v58;
      if (v56[0])
      {
        int v53 = 3;
        char v54 = " must be tensor of floating point values, but got ";
        uint64_t v55 = 50;
        uint64_t v24 = &v53;
        unint64_t v25 = (char *)v57;
        if (v23 >= v59)
        {
          unint64_t v44 = v23 + 1;
          BOOL v45 = (char *)v57 + 24 * v23 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            int64_t v49 = (char *)&v53 - (unsigned char *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            unint64_t v25 = (char *)v57;
            uint64_t v24 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            uint64_t v24 = &v53;
            unint64_t v25 = (char *)v57;
          }
        }
        unint64_t v26 = &v25[24 * v58];
        long long v27 = *(_OWORD *)v24;
        *((void *)v26 + 2) = *((void *)v24 + 2);
        *(_OWORD *)unint64_t v26 = v27;
        ++v58;
        if (v56[0])
        {
          int64_t v28 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          uint64_t v29 = (char *)v57;
          if (v58 >= v59)
          {
            unint64_t v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              int64_t v50 = (char *)&v53 - (unsigned char *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              uint64_t v29 = (char *)v57;
              int64_t v28 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              int64_t v28 = &v53;
              uint64_t v29 = (char *)v57;
            }
          }
          uint64_t v30 = &v29[24 * v58];
          long long v31 = *(_OWORD *)v28;
          *((void *)v30 + 2) = *((void *)v28 + 2);
          *(_OWORD *)uint64_t v30 = v31;
          ++v58;
        }
      }
    }
  }
  uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  }
  if (v65)
  {
    unint64_t v32 = __p;
    if (__p)
    {
      unint64_t v33 = v64;
      unint64_t v34 = __p;
      if (v64 != __p)
      {
        do
          unint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        unint64_t v34 = __p;
      }
      unsigned int v64 = v32;
      operator delete(v34);
    }
    int64_t v35 = v61;
    if (v61)
    {
      int64_t v36 = v62;
      int64_t v37 = v61;
      if (v62 != v61)
      {
        do
        {
          uint64_t v39 = *--v36;
          uint64_t v38 = v39;
          void *v36 = 0;
          if (v39) {
            MEMORY[0x21667D390](v38, 0x1000C8077774924);
          }
        }
        while (v36 != v35);
        int64_t v37 = v61;
      }
      uint64_t v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60) {
      free(v57);
    }
  }
  return v13;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(uint64_t a1, uint64_t a2, void **a3, void **a4, unsigned int a5)
{
  uint64_t v66 = *MEMORY[0x263EF8340];
  uint64_t v10 = *(void *)a2;
  unint64_t v11 = *(void **)(*(void *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isSignlessInteger((mlir::Type *)v51, 1)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 64)
      || mlir::Type::isF16((mlir::Type *)v51)
      || mlir::Type::isF32((mlir::Type *)v51)
      || mlir::Type::isBF16((mlir::Type *)v51)
      || *((_UNKNOWN **)*v51[0] + 17) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      return 1;
    }
  }
  __int16 v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    int v53 = 3;
    char v54 = " #";
    uint64_t v55 = 2;
    uint64_t v13 = &v53;
    uint64_t v14 = (char *)v57;
    if (v58 >= v59)
    {
      unint64_t v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        int64_t v47 = (char *)&v53 - (unsigned char *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        uint64_t v14 = (char *)v57;
        uint64_t v13 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        uint64_t v13 = &v53;
        uint64_t v14 = (char *)v57;
      }
    }
    long long v15 = &v14[24 * v58];
    long long v16 = *(_OWORD *)v13;
    *((void *)v15 + 2) = *((void *)v13 + 2);
    *(_OWORD *)long long v15 = v16;
    uint64_t v17 = ++v58;
    if (v56[0])
    {
      int v53 = 5;
      char v54 = (const char *)a5;
      uint64_t v18 = &v53;
      long long v19 = (char *)v57;
      if (v17 >= v59)
      {
        unint64_t v42 = v17 + 1;
        BOOL v43 = (char *)v57 + 24 * v17 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          int64_t v48 = (char *)&v53 - (unsigned char *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          long long v19 = (char *)v57;
          uint64_t v18 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          uint64_t v18 = &v53;
          long long v19 = (char *)v57;
        }
      }
      uint64_t v20 = &v19[24 * v58];
      long long v21 = *(_OWORD *)v18;
      *((void *)v20 + 2) = *((void *)v18 + 2);
      *(_OWORD *)uint64_t v20 = v21;
      uint64_t v22 = ++v58;
      if (v56[0])
      {
        int v53 = 3;
        char v54 = " must be tensor of mps native type values, but got ";
        uint64_t v55 = 51;
        uint64_t v23 = &v53;
        uint64_t v24 = (char *)v57;
        if (v22 >= v59)
        {
          unint64_t v44 = v22 + 1;
          BOOL v45 = (char *)v57 + 24 * v22 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            int64_t v49 = (char *)&v53 - (unsigned char *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            uint64_t v24 = (char *)v57;
            uint64_t v23 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            uint64_t v23 = &v53;
            uint64_t v24 = (char *)v57;
          }
        }
        unint64_t v25 = &v24[24 * v58];
        long long v26 = *(_OWORD *)v23;
        *((void *)v25 + 2) = *((void *)v23 + 2);
        *(_OWORD *)unint64_t v25 = v26;
        ++v58;
        if (v56[0])
        {
          long long v27 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          int64_t v28 = (char *)v57;
          if (v58 >= v59)
          {
            unint64_t v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              int64_t v50 = (char *)&v53 - (unsigned char *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              int64_t v28 = (char *)v57;
              long long v27 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              long long v27 = &v53;
              int64_t v28 = (char *)v57;
            }
          }
          uint64_t v29 = &v28[24 * v58];
          long long v30 = *(_OWORD *)v27;
          *((void *)v29 + 2) = *((void *)v27 + 2);
          *(_OWORD *)uint64_t v29 = v30;
          ++v58;
        }
      }
    }
  }
  uint64_t v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  }
  if (v65)
  {
    unint64_t v32 = __p;
    if (__p)
    {
      unint64_t v33 = v64;
      unint64_t v34 = __p;
      if (v64 != __p)
      {
        do
          unint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        unint64_t v34 = __p;
      }
      unsigned int v64 = v32;
      operator delete(v34);
    }
    int64_t v35 = v61;
    if (v61)
    {
      int64_t v36 = v62;
      int64_t v37 = v61;
      if (v62 != v61)
      {
        do
        {
          uint64_t v39 = *--v36;
          uint64_t v38 = v39;
          void *v36 = 0;
          if (v39) {
            MEMORY[0x21667D390](v38, 0x1000C8077774924);
          }
        }
        while (v36 != v35);
        int64_t v37 = v61;
      }
      uint64_t v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60) {
      free(v57);
    }
  }
  return v31;
}

void mlir::mps::BiasAddGradOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::BiasAddOpGenericAdaptorBase::BiasAddOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  unsigned int v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.bias_add", 12, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::BiasAddOp::verifyInvariantsImpl(mlir::mps::BiasAddOp *this)
{
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(_DWORD **)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  uint64_t v7 = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(v3, (void **)"data_format", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v4 = *(void *)this - 16;
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
}

void mlir::mps::BiasAddOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::BitwiseAndOpGenericAdaptorBase::BitwiseAndOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_and", 15, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::BitwiseAndOp::verifyInvariantsImpl(mlir::mps::BitwiseAndOp *this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v2 = *(void *)this - 16;
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(uint64_t a1, uint64_t a2, void **a3, void **a4, unsigned int a5)
{
  uint64_t v66 = *MEMORY[0x263EF8340];
  uint64_t v10 = *(void *)a2;
  uint64_t v11 = *(void **)(*(void *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isSignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 64))
    {
      return 1;
    }
  }
  __int16 v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    int v53 = 3;
    char v54 = " #";
    uint64_t v55 = 2;
    uint64_t v14 = &v53;
    long long v15 = (char *)v57;
    if (v58 >= v59)
    {
      unint64_t v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        int64_t v47 = (char *)&v53 - (unsigned char *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        long long v15 = (char *)v57;
        uint64_t v14 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        uint64_t v14 = &v53;
        long long v15 = (char *)v57;
      }
    }
    long long v16 = &v15[24 * v58];
    long long v17 = *(_OWORD *)v14;
    *((void *)v16 + 2) = *((void *)v14 + 2);
    *(_OWORD *)long long v16 = v17;
    uint64_t v18 = ++v58;
    if (v56[0])
    {
      int v53 = 5;
      char v54 = (const char *)a5;
      long long v19 = &v53;
      uint64_t v20 = (char *)v57;
      if (v18 >= v59)
      {
        unint64_t v42 = v18 + 1;
        BOOL v43 = (char *)v57 + 24 * v18 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          int64_t v48 = (char *)&v53 - (unsigned char *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          uint64_t v20 = (char *)v57;
          long long v19 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          long long v19 = &v53;
          uint64_t v20 = (char *)v57;
        }
      }
      long long v21 = &v20[24 * v58];
      long long v22 = *(_OWORD *)v19;
      *((void *)v21 + 2) = *((void *)v19 + 2);
      *(_OWORD *)long long v21 = v22;
      uint64_t v23 = ++v58;
      if (v56[0])
      {
        int v53 = 3;
        char v54 = " must be tensor of int values, but got ";
        uint64_t v55 = 39;
        uint64_t v24 = &v53;
        unint64_t v25 = (char *)v57;
        if (v23 >= v59)
        {
          unint64_t v44 = v23 + 1;
          BOOL v45 = (char *)v57 + 24 * v23 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            int64_t v49 = (char *)&v53 - (unsigned char *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            unint64_t v25 = (char *)v57;
            uint64_t v24 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            uint64_t v24 = &v53;
            unint64_t v25 = (char *)v57;
          }
        }
        long long v26 = &v25[24 * v58];
        long long v27 = *(_OWORD *)v24;
        *((void *)v26 + 2) = *((void *)v24 + 2);
        *(_OWORD *)long long v26 = v27;
        ++v58;
        if (v56[0])
        {
          int64_t v28 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          uint64_t v29 = (char *)v57;
          if (v58 >= v59)
          {
            unint64_t v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              int64_t v50 = (char *)&v53 - (unsigned char *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              uint64_t v29 = (char *)v57;
              int64_t v28 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              int64_t v28 = &v53;
              uint64_t v29 = (char *)v57;
            }
          }
          long long v30 = &v29[24 * v58];
          long long v31 = *(_OWORD *)v28;
          *((void *)v30 + 2) = *((void *)v28 + 2);
          *(_OWORD *)long long v30 = v31;
          ++v58;
        }
      }
    }
  }
  uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  }
  if (v65)
  {
    unint64_t v32 = __p;
    if (__p)
    {
      unint64_t v33 = v64;
      unint64_t v34 = __p;
      if (v64 != __p)
      {
        do
          unint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        unint64_t v34 = __p;
      }
      unsigned int v64 = v32;
      operator delete(v34);
    }
    int64_t v35 = v61;
    if (v61)
    {
      int64_t v36 = v62;
      int64_t v37 = v61;
      if (v62 != v61)
      {
        do
        {
          uint64_t v39 = *--v36;
          uint64_t v38 = v39;
          void *v36 = 0;
          if (v39) {
            MEMORY[0x21667D390](v38, 0x1000C8077774924);
          }
        }
        while (v36 != v35);
        int64_t v37 = v61;
      }
      uint64_t v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60) {
      free(v57);
    }
  }
  return v13;
}

void mlir::mps::BitwiseAndOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::BitwiseLeftShiftOpGenericAdaptorBase::BitwiseLeftShiftOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_left_shift", 22, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::BitwiseLeftShiftOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::BitwiseNotOpGenericAdaptorBase::BitwiseNotOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_not", 15, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::BitwiseNotOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::BitwiseOrOpGenericAdaptorBase::BitwiseOrOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_or", 14, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::BitwiseOrOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::BitwisePopcountOpGenericAdaptorBase::BitwisePopcountOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_popcount", 20, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::BitwisePopcountOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::BitwiseRightShiftOpGenericAdaptorBase::BitwiseRightShiftOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_right_shift", 23, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::BitwiseRightShiftOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::BitwiseXorOpGenericAdaptorBase::BitwiseXorOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_xor", 15, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::BitwiseXorOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::BroadcastGradientArgsOpGenericAdaptorBase::BroadcastGradientArgsOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.broadcast_gradient_args", 27, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::BroadcastGradientArgsOp::verifyInvariantsImpl(mlir::mps::BroadcastGradientArgsOp *this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v2 = *(void *)this - 16;
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
}

void mlir::mps::BroadcastGradientArgsOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::BroadcastToOpGenericAdaptorBase::BroadcastToOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.broadcast_to", 16, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::BroadcastToOp::verifyInvariantsImpl(mlir::mps::BroadcastToOp *this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v2 = *(void *)this - 16;
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
}

void mlir::mps::BroadcastToOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::CallOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v101 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v87 = v6;
  if (!v6)
  {
    a3(v91, a4);
    if (v91[0])
    {
      int v88 = 3;
      unsigned int v89 = "expected DictionaryAttr to set properties";
      uint64_t v90 = 41;
      long long v26 = &v88;
      long long v27 = (char *)v92;
      if (v93 >= v94)
      {
        unint64_t v73 = v93 + 1;
        if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
        {
          int64_t v80 = (char *)&v88 - (unsigned char *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v73, 24);
          long long v27 = (char *)v92;
          long long v26 = (int *)((char *)v92 + v80);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v73, 24);
          long long v26 = &v88;
          long long v27 = (char *)v92;
        }
      }
      int64_t v28 = &v27[24 * v93];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)int64_t v28 = v29;
      ++v93;
      if (v91[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
      }
    }
    if (!v100) {
      return 0;
    }
    long long v30 = __p;
    if (__p)
    {
      long long v31 = v99;
      unint64_t v32 = __p;
      if (v99 != __p)
      {
        do
          long long v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unint64_t v32 = __p;
      }
      char v99 = v30;
      operator delete(v32);
    }
    long long v21 = v96;
    if (!v96) {
      goto LABEL_95;
    }
    unint64_t v33 = v97;
    uint64_t v23 = v96;
    if (v97 == v96) {
      goto LABEL_94;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *unint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_93;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v87, "inlineMode", 0xAuLL);
  if (!v8)
  {
    a3(v91, a4);
    if (v91[0])
    {
      int v88 = 3;
      unsigned int v89 = "expected key entry for inlineMode in DictionaryAttr to set Properties.";
      uint64_t v90 = 70;
      int64_t v36 = &v88;
      int64_t v37 = (char *)v92;
      if (v93 >= v94)
      {
        unint64_t v75 = v93 + 1;
        if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
        {
          int64_t v82 = (char *)&v88 - (unsigned char *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v75, 24);
          int64_t v37 = (char *)v92;
          int64_t v36 = (int *)((char *)v92 + v82);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v75, 24);
          int64_t v36 = &v88;
          int64_t v37 = (char *)v92;
        }
      }
      uint64_t v38 = &v37[24 * v93];
      long long v39 = *(_OWORD *)v36;
      *((void *)v38 + 2) = *((void *)v36 + 2);
      *(_OWORD *)uint64_t v38 = v39;
      ++v93;
      if (v91[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
      }
    }
    if (!v100) {
      return 0;
    }
    int64_t v40 = __p;
    if (__p)
    {
      unint64_t v41 = v99;
      unint64_t v42 = __p;
      if (v99 != __p)
      {
        do
          unint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        unint64_t v42 = __p;
      }
      char v99 = v40;
      operator delete(v42);
    }
    long long v21 = v96;
    if (!v96) {
      goto LABEL_95;
    }
    BOOL v43 = v97;
    uint64_t v23 = v96;
    if (v97 == v96) {
      goto LABEL_94;
    }
    do
    {
      uint64_t v45 = *--v43;
      uint64_t v44 = v45;
      void *v43 = 0;
      if (v45) {
        MEMORY[0x21667D390](v44, 0x1000C8077774924);
      }
    }
    while (v43 != v21);
    goto LABEL_93;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id)
  {
    a3(v91, a4);
    if (v91[0])
    {
      int v88 = 3;
      uint64_t v90 = 55;
      uint64_t v10 = &v88;
      uint64_t v11 = (char *)v92;
      if (v93 >= v94)
      {
        unint64_t v74 = v93 + 1;
        if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
        {
          int64_t v81 = (char *)&v88 - (unsigned char *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v74, 24);
          uint64_t v11 = (char *)v92;
          uint64_t v10 = (int *)((char *)v92 + v81);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v74, 24);
          uint64_t v10 = &v88;
          uint64_t v11 = (char *)v92;
        }
      }
      uint64_t v12 = &v11[24 * v93];
      long long v13 = *(_OWORD *)v10;
      *((void *)v12 + 2) = *((void *)v10 + 2);
      *(_OWORD *)uint64_t v12 = v13;
      ++v93;
      if (v91[0])
      {
        uint64_t v14 = &v88;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v88, v9);
        long long v15 = (char *)v92;
        if (v93 >= v94)
        {
          unint64_t v76 = v93 + 1;
          if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
          {
            int64_t v83 = (char *)&v88 - (unsigned char *)v92;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v76, 24);
            long long v15 = (char *)v92;
            uint64_t v14 = (int *)((char *)v92 + v83);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v76, 24);
            uint64_t v14 = &v88;
            long long v15 = (char *)v92;
          }
        }
        long long v16 = &v15[24 * v93];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = *((void *)v14 + 2);
        *(_OWORD *)long long v16 = v17;
        ++v93;
        if (v91[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
        }
      }
    }
    if (!v100) {
      return 0;
    }
    uint64_t v18 = __p;
    if (__p)
    {
      long long v19 = v99;
      uint64_t v20 = __p;
      if (v99 != __p)
      {
        do
          long long v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        uint64_t v20 = __p;
      }
      char v99 = v18;
      operator delete(v20);
    }
    long long v21 = v96;
    if (!v96) {
      goto LABEL_95;
    }
    long long v22 = v97;
    uint64_t v23 = v96;
    if (v97 == v96) {
      goto LABEL_94;
    }
    do
    {
      uint64_t v25 = *--v22;
      uint64_t v24 = v25;
      void *v22 = 0;
      if (v25) {
        MEMORY[0x21667D390](v24, 0x1000C8077774924);
      }
    }
    while (v22 != v21);
    goto LABEL_93;
  }
  *a1 = v8;
  uint64_t v46 = mlir::DictionaryAttr::get((uint64_t)&v87, "symbolName", 0xAuLL);
  if (!v46)
  {
    a3(v91, a4);
    if (v91[0])
    {
      int v88 = 3;
      unsigned int v89 = "expected key entry for symbolName in DictionaryAttr to set Properties.";
      uint64_t v90 = 70;
      uint64_t v62 = &v88;
      unsigned int v63 = (char *)v92;
      if (v93 >= v94)
      {
        unint64_t v78 = v93 + 1;
        if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
        {
          int64_t v85 = (char *)&v88 - (unsigned char *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v78, 24);
          unsigned int v63 = (char *)v92;
          uint64_t v62 = (int *)((char *)v92 + v85);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v78, 24);
          uint64_t v62 = &v88;
          unsigned int v63 = (char *)v92;
        }
      }
      unsigned int v64 = &v63[24 * v93];
      long long v65 = *(_OWORD *)v62;
      *((void *)v64 + 2) = *((void *)v62 + 2);
      *(_OWORD *)unsigned int v64 = v65;
      ++v93;
      if (v91[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
      }
    }
    if (!v100) {
      return 0;
    }
    uint64_t v66 = __p;
    if (__p)
    {
      uint64_t v67 = v99;
      uint64_t v68 = __p;
      if (v99 != __p)
      {
        do
          uint64_t v67 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v67 - 1);
        while (v67 != v66);
        uint64_t v68 = __p;
      }
      char v99 = v66;
      operator delete(v68);
    }
    long long v21 = v96;
    if (!v96) {
      goto LABEL_95;
    }
    uint64_t v69 = v97;
    uint64_t v23 = v96;
    if (v97 == v96) {
      goto LABEL_94;
    }
    do
    {
      uint64_t v71 = *--v69;
      uint64_t v70 = v71;
      *uint64_t v69 = 0;
      if (v71) {
        MEMORY[0x21667D390](v70, 0x1000C8077774924);
      }
    }
    while (v69 != v21);
    goto LABEL_93;
  }
  uint64_t v47 = v46;
  if (*(_UNKNOWN **)(*(void *)v46 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
  {
    a1[1] = v46;
    return 1;
  }
  a3(v91, a4);
  if (v91[0])
  {
    int v88 = 3;
    uint64_t v90 = 55;
    int64_t v48 = &v88;
    int64_t v49 = (char *)v92;
    if (v93 >= v94)
    {
      unint64_t v77 = v93 + 1;
      if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
      {
        int64_t v84 = (char *)&v88 - (unsigned char *)v92;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v77, 24);
        int64_t v49 = (char *)v92;
        int64_t v48 = (int *)((char *)v92 + v84);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v77, 24);
        int64_t v48 = &v88;
        int64_t v49 = (char *)v92;
      }
    }
    int64_t v50 = &v49[24 * v93];
    long long v51 = *(_OWORD *)v48;
    *((void *)v50 + 2) = *((void *)v48 + 2);
    *(_OWORD *)int64_t v50 = v51;
    ++v93;
    if (v91[0])
    {
      __int16 v52 = &v88;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v88, v47);
      int v53 = (char *)v92;
      if (v93 >= v94)
      {
        unint64_t v79 = v93 + 1;
        if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
        {
          int64_t v86 = (char *)&v88 - (unsigned char *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v79, 24);
          int v53 = (char *)v92;
          __int16 v52 = (int *)((char *)v92 + v86);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v79, 24);
          __int16 v52 = &v88;
          int v53 = (char *)v92;
        }
      }
      char v54 = &v53[24 * v93];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = *((void *)v52 + 2);
      *(_OWORD *)char v54 = v55;
      ++v93;
      if (v91[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
      }
    }
  }
  if (v100)
  {
    char v56 = __p;
    if (__p)
    {
      uint64_t v57 = v99;
      unsigned int v58 = __p;
      if (v99 != __p)
      {
        do
          uint64_t v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        unsigned int v58 = __p;
      }
      char v99 = v56;
      operator delete(v58);
    }
    long long v21 = v96;
    if (!v96) {
      goto LABEL_95;
    }
    unsigned int v59 = v97;
    uint64_t v23 = v96;
    if (v97 == v96)
    {
LABEL_94:
      uint64_t v97 = v21;
      operator delete(v23);
LABEL_95:
      if (v92 != v95) {
        free(v92);
      }
      return 0;
    }
    do
    {
      uint64_t v61 = *--v59;
      uint64_t v60 = v61;
      *unsigned int v59 = 0;
      if (v61) {
        MEMORY[0x21667D390](v60, 0x1000C8077774924);
      }
    }
    while (v59 != v21);
LABEL_93:
    uint64_t v23 = v96;
    goto LABEL_94;
  }
  return 0;
}

uint64_t mlir::mps::CallOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v21[6] = *MEMORY[0x263EF8340];
  uint64_t v18 = a1;
  long long v19 = v21;
  uint64_t v20 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"inlineMode", 10, *a2);
    uint64_t v5 = v4;
    unsigned int v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      unsigned int v6 = v20;
    }
    uint64_t v7 = (uint64_t *)((char *)v19 + 16 * v6);
    uint64_t *v7 = NamedAttr;
    v7[1] = v5;
    unsigned int v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    uint64_t v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      uint64_t v10 = (uint64_t *)v19;
      if (v8) {
        goto LABEL_6;
      }
LABEL_13:
      uint64_t DictionaryAttr = 0;
      if (v10 == v21) {
        return DictionaryAttr;
      }
      goto LABEL_7;
    }
  }
  else
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_5;
    }
  }
  uint64_t v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"symbolName", 10, v9);
  uint64_t v15 = v14;
  unsigned int v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    unsigned int v16 = v20;
  }
  long long v17 = (uint64_t *)((char *)v19 + 16 * v16);
  uint64_t *v17 = v13;
  v17[1] = v15;
  unsigned int v8 = v20 + 1;
  LODWORD(v20) = v8;
  uint64_t v10 = (uint64_t *)v19;
  if (!v8) {
    goto LABEL_13;
  }
LABEL_6:
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  uint64_t v10 = (uint64_t *)v19;
  if (v19 != v21) {
LABEL_7:
  }
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps3(uint64_t a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    long long v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    unsigned int v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        unsigned int v8 = (char *)v35;
        uint64_t v7 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        unsigned int v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      long long v29 = a2;
      long long v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        long long v30 = "' failed to satisfy constraint: valid CallInlineMode";
        uint64_t v31 = 52;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    unsigned int v16 = __p;
    if (__p)
    {
      long long v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          long long v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      unint64_t v42 = v16;
      operator delete(v18);
    }
    long long v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      long long v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        long long v21 = v39;
      }
      int64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CallOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::CallInlineModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  uint64_t v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unsigned int v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        unsigned int v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unsigned int v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    unsigned int v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)unsigned int v8 = v9;
    ++v47;
  }
  int64_t v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::CallInlineModeAttr]";
  unint64_t v41 = 79;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    int64_t v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      long long v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          long long v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      unsigned int v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)unsigned int v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        long long v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            long long v19 = (char *)v46;
            uint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            long long v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      uint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      int v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      long long v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

uint64_t mlir::mps::CallOp::verifyInvariantsImpl(mlir::mps::CallOp *this)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  if (!*v3)
  {
    v31[0] = (void **)"requires attribute 'inlineMode'";
    __int16 v32 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v31, (uint64_t)v33);
    uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v33);
    if (v33[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v33);
    }
    if (!v40) {
      return v15;
    }
    unsigned int v16 = __p;
    if (__p)
    {
      long long v17 = v39;
      uint64_t v18 = __p;
      if (v39 != __p)
      {
        do
          long long v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      uint64_t v39 = v16;
      operator delete(v18);
    }
    long long v19 = v36;
    if (v36)
    {
      uint64_t v20 = v37;
      long long v21 = v36;
      if (v37 == v36) {
        goto LABEL_52;
      }
      do
      {
        uint64_t v23 = *--v20;
        uint64_t v22 = v23;
        void *v20 = 0;
        if (v23) {
          MEMORY[0x21667D390](v22, 0x1000C8077774924);
        }
      }
      while (v20 != v19);
LABEL_51:
      long long v21 = v36;
LABEL_52:
      int64_t v37 = v19;
      operator delete(v21);
    }
LABEL_53:
    if (v34 != &v35) {
      free(v34);
    }
    return v15;
  }
  uint64_t v5 = v3[1];
  if (!v5)
  {
    v31[0] = (void **)"requires attribute 'symbolName'";
    __int16 v32 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v31, (uint64_t)v33);
    uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v33);
    if (v33[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v33);
    }
    if (!v40) {
      return v15;
    }
    uint64_t v24 = __p;
    if (__p)
    {
      unint64_t v25 = v39;
      unint64_t v26 = __p;
      if (v39 != __p)
      {
        do
          unint64_t v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        unint64_t v26 = __p;
      }
      uint64_t v39 = v24;
      operator delete(v26);
    }
    long long v19 = v36;
    if (v36)
    {
      int64_t v27 = v37;
      long long v21 = v36;
      if (v37 == v36) {
        goto LABEL_52;
      }
      do
      {
        uint64_t v29 = *--v27;
        uint64_t v28 = v29;
        void *v27 = 0;
        if (v29) {
          MEMORY[0x21667D390](v28, 0x1000C8077774924);
        }
      }
      while (v27 != v19);
      goto LABEL_51;
    }
    goto LABEL_53;
  }
  v33[0] = v2;
  if (!mlir::func::__mlir_ods_local_attr_constraint_FuncOps1(v5, (void **)"symbolName", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v33))return 0; {
  v33[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps3(v4, (void **)"inlineMode", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps3(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v33))return 0; {
  uint64_t v6 = *(void *)this;
  }
  if ((*(unsigned char *)(*(void *)this + 46) & 0x80) != 0)
  {
    uint64_t v7 = *(unsigned int *)(v6 + 68);
    if (v7)
    {
      uint64_t v8 = 0;
      uint64_t v9 = *(void *)(v6 + 72) + 24;
      while (mlir::mps::__mlir_ods_local_type_constraint_MPSOps8(*(void *)this, *(void *)(*(void *)v9 + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, v8))
      {
        ++v8;
        v9 += 32;
        if (v7 == v8)
        {
          uint64_t v6 = *(void *)this;
          goto LABEL_14;
        }
      }
      return 0;
    }
  }
LABEL_14:
  uint64_t v10 = *(unsigned int *)(v6 + 36);
  uint64_t v11 = v6 - 16;
  if (v10) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  if (v10)
  {
    uint64_t v13 = 0;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v12, v13);
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps8(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, v13))break; {
      if (v10 == ++v13)
      }
        return 1;
    }
    return 0;
  }
  return 1;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps8(uint64_t a1, uint64_t a2, void **a3, void **a4, unsigned int a5)
{
  uint64_t v66 = *MEMORY[0x263EF8340];
  uint64_t v10 = *(void *)a2;
  uint64_t v11 = *(void **)(*(void *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isSignlessInteger((mlir::Type *)v51, 1)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 64)
      || mlir::Type::isF16((mlir::Type *)v51)
      || mlir::Type::isF32((mlir::Type *)v51)
      || mlir::Type::isBF16((mlir::Type *)v51)
      || *((_UNKNOWN **)*v51[0] + 17) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      return 1;
    }
  }
  __int16 v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    int v53 = 3;
    char v54 = " #";
    uint64_t v55 = 2;
    uint64_t v13 = &v53;
    long long v14 = (char *)v57;
    if (v58 >= v59)
    {
      unint64_t v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        int64_t v47 = (char *)&v53 - (unsigned char *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        long long v14 = (char *)v57;
        uint64_t v13 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        uint64_t v13 = &v53;
        long long v14 = (char *)v57;
      }
    }
    uint64_t v15 = &v14[24 * v58];
    long long v16 = *(_OWORD *)v13;
    *((void *)v15 + 2) = *((void *)v13 + 2);
    *(_OWORD *)uint64_t v15 = v16;
    uint64_t v17 = ++v58;
    if (v56[0])
    {
      int v53 = 5;
      char v54 = (const char *)a5;
      uint64_t v18 = &v53;
      long long v19 = (char *)v57;
      if (v17 >= v59)
      {
        unint64_t v42 = v17 + 1;
        BOOL v43 = (char *)v57 + 24 * v17 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          int64_t v48 = (char *)&v53 - (unsigned char *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          long long v19 = (char *)v57;
          uint64_t v18 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          uint64_t v18 = &v53;
          long long v19 = (char *)v57;
        }
      }
      uint64_t v20 = &v19[24 * v58];
      long long v21 = *(_OWORD *)v18;
      *((void *)v20 + 2) = *((void *)v18 + 2);
      *(_OWORD *)uint64_t v20 = v21;
      uint64_t v22 = ++v58;
      if (v56[0])
      {
        int v53 = 3;
        char v54 = " must be variadic of tensor of mps native type values, but got ";
        uint64_t v55 = 63;
        uint64_t v23 = &v53;
        uint64_t v24 = (char *)v57;
        if (v22 >= v59)
        {
          unint64_t v44 = v22 + 1;
          BOOL v45 = (char *)v57 + 24 * v22 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            int64_t v49 = (char *)&v53 - (unsigned char *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            uint64_t v24 = (char *)v57;
            uint64_t v23 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            uint64_t v23 = &v53;
            uint64_t v24 = (char *)v57;
          }
        }
        unint64_t v25 = &v24[24 * v58];
        long long v26 = *(_OWORD *)v23;
        *((void *)v25 + 2) = *((void *)v23 + 2);
        *(_OWORD *)unint64_t v25 = v26;
        ++v58;
        if (v56[0])
        {
          int64_t v27 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          uint64_t v28 = (char *)v57;
          if (v58 >= v59)
          {
            unint64_t v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              int64_t v50 = (char *)&v53 - (unsigned char *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              uint64_t v28 = (char *)v57;
              int64_t v27 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              int64_t v27 = &v53;
              uint64_t v28 = (char *)v57;
            }
          }
          uint64_t v29 = &v28[24 * v58];
          long long v30 = *(_OWORD *)v27;
          *((void *)v29 + 2) = *((void *)v27 + 2);
          *(_OWORD *)uint64_t v29 = v30;
          ++v58;
        }
      }
    }
  }
  uint64_t v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  }
  if (v65)
  {
    __int16 v32 = __p;
    if (__p)
    {
      unint64_t v33 = v64;
      unint64_t v34 = __p;
      if (v64 != __p)
      {
        do
          unint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        unint64_t v34 = __p;
      }
      unsigned int v64 = v32;
      operator delete(v34);
    }
    uint64_t v35 = v61;
    if (v61)
    {
      int64_t v36 = v62;
      int64_t v37 = v61;
      if (v62 != v61)
      {
        do
        {
          uint64_t v39 = *--v36;
          uint64_t v38 = v39;
          void *v36 = 0;
          if (v39) {
            MEMORY[0x21667D390](v38, 0x1000C8077774924);
          }
        }
        while (v36 != v35);
        int64_t v37 = v61;
      }
      uint64_t v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60) {
      free(v57);
    }
  }
  return v31;
}

void mlir::mps::CallOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::CastOpGenericAdaptorBase::CastOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  uint64_t v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.cast", 8, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::CastOpGenericAdaptorBase::getODSOperandIndexAndLength(mlir::mps::detail::CastOpGenericAdaptorBase *this, unsigned int a2)
{
  return a2 | 0x100000000;
}

uint64_t mlir::mps::CastOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v55 = v6;
  if (!v6)
  {
    a3(v59, a4);
    if (v59[0])
    {
      int v56 = 3;
      uint64_t v57 = "expected DictionaryAttr to set properties";
      uint64_t v58 = 41;
      long long v26 = &v56;
      int64_t v27 = (char *)v60;
      if (v61 >= v62)
      {
        unint64_t v47 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          int64_t v51 = (char *)&v56 - (unsigned char *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          int64_t v27 = (char *)v60;
          long long v26 = (int *)((char *)v60 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          long long v26 = &v56;
          int64_t v27 = (char *)v60;
        }
      }
      uint64_t v28 = &v27[24 * v61];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v61;
      if (v59[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
      }
    }
    if (!v68) {
      return 0;
    }
    long long v30 = __p;
    if (__p)
    {
      uint64_t v31 = v67;
      __int16 v32 = __p;
      if (v67 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        __int16 v32 = __p;
      }
      uint64_t v67 = v30;
      operator delete(v32);
    }
    long long v21 = v64;
    if (!v64) {
      goto LABEL_59;
    }
    unint64_t v33 = v65;
    uint64_t v23 = v64;
    if (v65 == v64) {
      goto LABEL_58;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *unint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_57;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v55, "resultElementType", 0x11uLL);
  if (!v8)
  {
    a3(v59, a4);
    if (v59[0])
    {
      int v56 = 3;
      uint64_t v57 = "expected key entry for resultElementType in DictionaryAttr to set Properties.";
      uint64_t v58 = 77;
      int64_t v36 = &v56;
      int64_t v37 = (char *)v60;
      if (v61 >= v62)
      {
        unint64_t v49 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          int64_t v53 = (char *)&v56 - (unsigned char *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          int64_t v37 = (char *)v60;
          int64_t v36 = (int *)((char *)v60 + v53);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          int64_t v36 = &v56;
          int64_t v37 = (char *)v60;
        }
      }
      uint64_t v38 = &v37[24 * v61];
      long long v39 = *(_OWORD *)v36;
      *((void *)v38 + 2) = *((void *)v36 + 2);
      *(_OWORD *)uint64_t v38 = v39;
      ++v61;
      if (v59[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
      }
    }
    if (!v68) {
      return 0;
    }
    char v40 = __p;
    if (__p)
    {
      unint64_t v41 = v67;
      unint64_t v42 = __p;
      if (v67 != __p)
      {
        do
          unint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        unint64_t v42 = __p;
      }
      uint64_t v67 = v40;
      operator delete(v42);
    }
    long long v21 = v64;
    if (!v64) {
      goto LABEL_59;
    }
    BOOL v43 = v65;
    uint64_t v23 = v64;
    if (v65 == v64) {
      goto LABEL_58;
    }
    do
    {
      uint64_t v45 = *--v43;
      uint64_t v44 = v45;
      void *v43 = 0;
      if (v45) {
        MEMORY[0x21667D390](v44, 0x1000C8077774924);
      }
    }
    while (v43 != v21);
    goto LABEL_57;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v59, a4);
  if (v59[0])
  {
    int v56 = 3;
    uint64_t v58 = 62;
    uint64_t v10 = &v56;
    uint64_t v11 = (char *)v60;
    if (v61 >= v62)
    {
      unint64_t v48 = v61 + 1;
      if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
      {
        int64_t v52 = (char *)&v56 - (unsigned char *)v60;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        uint64_t v11 = (char *)v60;
        uint64_t v10 = (int *)((char *)v60 + v52);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        uint64_t v10 = &v56;
        uint64_t v11 = (char *)v60;
      }
    }
    uint64_t v12 = &v11[24 * v61];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v61;
    if (v59[0])
    {
      long long v14 = &v56;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v56, v9);
      uint64_t v15 = (char *)v60;
      if (v61 >= v62)
      {
        unint64_t v50 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          int64_t v54 = (char *)&v56 - (unsigned char *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          uint64_t v15 = (char *)v60;
          long long v14 = (int *)((char *)v60 + v54);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          long long v14 = &v56;
          uint64_t v15 = (char *)v60;
        }
      }
      long long v16 = &v15[24 * v61];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)long long v16 = v17;
      ++v61;
      if (v59[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
      }
    }
  }
  if (v68)
  {
    uint64_t v18 = __p;
    if (__p)
    {
      long long v19 = v67;
      uint64_t v20 = __p;
      if (v67 != __p)
      {
        do
          long long v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        uint64_t v20 = __p;
      }
      uint64_t v67 = v18;
      operator delete(v20);
    }
    long long v21 = v64;
    if (!v64) {
      goto LABEL_59;
    }
    uint64_t v22 = v65;
    uint64_t v23 = v64;
    if (v65 == v64)
    {
LABEL_58:
      char v65 = v21;
      operator delete(v23);
LABEL_59:
      if (v60 != v63) {
        free(v60);
      }
      return 0;
    }
    do
    {
      uint64_t v25 = *--v22;
      uint64_t v24 = v25;
      void *v22 = 0;
      if (v25) {
        MEMORY[0x21667D390](v24, 0x1000C8077774924);
      }
    }
    while (v22 != v21);
LABEL_57:
    uint64_t v23 = v64;
    goto LABEL_58;
  }
  return 0;
}

uint64_t mlir::mps::CastOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x263EF8340];
  uint64_t v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"resultElementType", 17, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  uint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CastOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

void mlir::mps::CastOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v24[2] = *MEMORY[0x263EF8340];
  uint64_t v19 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  uint64_t v7 = mlir::TypeAttr::get(a4);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CastOpGenericAdaptorBase::Properties>(a2) = v7;
  __src = v24;
  uint64_t v23 = 0x200000000;
  BOOL v8 = *a1;
  mlir::ValueRange::ValueRange(v21, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v11 = *(uint64_t **)(a2 + 256);
  mlir::ValueRange::ValueRange(v20, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::CastOp::inferReturnTypes(v8, v12, v13, v21[0], v21[1], Dictionary, v11, v14, v20[0], v20[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v15 = __src;
  }
  uint64_t v16 = v23;
  uint64_t v17 = *(unsigned int *)(a2 + 72);
  unint64_t v18 = v17 + v23;
  if (v18 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v18, 8);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  if (v16)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v17), v15, 8 * v16);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v17 + v16;
  if (__src != v24) {
    free(__src);
  }
}

BOOL mlir::mps::CastOp::verifyInvariantsImpl(mlir::mps::CastOp *this)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(void *)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  if (v3)
  {
    v18[0] = v2;
    if (mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v3, (void **)"resultElementType", (const char *)0x11, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps4(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v18)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0))
    {
      if (*(_DWORD *)(*(void *)this + 36)) {
        uint64_t v4 = *(void *)this - 16;
      }
      else {
        uint64_t v4 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v16 = (void **)"requires attribute 'resultElementType'";
    __int16 v17 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, &v16, (uint64_t)v18);
    uint64_t v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v18);
    if (v18[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
    }
    if (v25)
    {
      uint64_t v7 = __p;
      if (__p)
      {
        BOOL v8 = v24;
        uint64_t v9 = __p;
        if (v24 != __p)
        {
          do
            BOOL v8 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v8 - 1);
          while (v8 != v7);
          uint64_t v9 = __p;
        }
        uint64_t v24 = v7;
        operator delete(v9);
      }
      uint64_t v10 = v21;
      if (v21)
      {
        uint64_t v11 = v22;
        uint64_t v12 = v21;
        if (v22 != v21)
        {
          do
          {
            uint64_t v14 = *--v11;
            uint64_t v13 = v14;
            void *v11 = 0;
            if (v14) {
              MEMORY[0x21667D390](v13, 0x1000C8077774924);
            }
          }
          while (v11 != v10);
          uint64_t v12 = v21;
        }
        uint64_t v22 = v10;
        operator delete(v12);
      }
      if (v19 != &v20) {
        free(v19);
      }
    }
  }
  return v6;
}

void mlir::mps::CastOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::CeilOpGenericAdaptorBase::CeilOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.ceil", 8, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::CeilOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::ClampOpGenericAdaptorBase::ClampOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.clamp", 9, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::ClampOp::verifyInvariantsImpl(mlir::mps::ClampOp *this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 2u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v2 = *(void *)this - 16;
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
}

void mlir::mps::ClampOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::ColToImOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v122 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v108 = v6;
  if (!v6)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      char v110 = "expected DictionaryAttr to set properties";
      uint64_t v111 = 41;
      uint64_t v26 = &v109;
      int64_t v27 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v91 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v99 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v91, 24);
          int64_t v27 = (char *)v113;
          uint64_t v26 = (uint64_t *)((char *)v113 + v99);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v91, 24);
          uint64_t v26 = &v109;
          int64_t v27 = (char *)v113;
        }
      }
      uint64_t v28 = &v27[24 * v114];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)uint64_t v28 = v29;
      ++v114;
      if (v112[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121) {
      return 0;
    }
    long long v30 = __p;
    if (__p)
    {
      uint64_t v31 = v120;
      __int16 v32 = __p;
      if (v120 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        __int16 v32 = __p;
      }
      char v120 = v30;
      operator delete(v32);
    }
    long long v21 = v117;
    if (!v117) {
      goto LABEL_118;
    }
    unint64_t v33 = v118;
    uint64_t v23 = v117;
    if (v118 == v117)
    {
LABEL_117:
      BOOL v118 = v21;
      operator delete(v23);
LABEL_118:
      if (v113 != v116) {
        free(v113);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *unint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
LABEL_116:
    uint64_t v23 = v117;
    goto LABEL_117;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v108, "data_layout", 0xBuLL);
  if (!v8)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      char v110 = "expected key entry for data_layout in DictionaryAttr to set Properties.";
      uint64_t v111 = 71;
      int64_t v36 = &v109;
      int64_t v37 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v93 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v101 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v93, 24);
          int64_t v37 = (char *)v113;
          int64_t v36 = (uint64_t *)((char *)v113 + v101);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v93, 24);
          int64_t v36 = &v109;
          int64_t v37 = (char *)v113;
        }
      }
      uint64_t v38 = &v37[24 * v114];
      long long v39 = *(_OWORD *)v36;
      *((void *)v38 + 2) = v36[2];
      *(_OWORD *)uint64_t v38 = v39;
      ++v114;
      if (v112[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121) {
      return 0;
    }
    char v40 = __p;
    if (__p)
    {
      unint64_t v41 = v120;
      unint64_t v42 = __p;
      if (v120 != __p)
      {
        do
          unint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        unint64_t v42 = __p;
      }
      char v120 = v40;
      operator delete(v42);
    }
    long long v21 = v117;
    if (!v117) {
      goto LABEL_118;
    }
    BOOL v43 = v118;
    uint64_t v23 = v117;
    if (v118 == v117) {
      goto LABEL_117;
    }
    do
    {
      uint64_t v45 = *--v43;
      uint64_t v44 = v45;
      void *v43 = 0;
      if (v45) {
        MEMORY[0x21667D390](v44, 0x1000C8077774924);
      }
    }
    while (v43 != v21);
    goto LABEL_116;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      uint64_t v111 = 56;
      uint64_t v10 = &v109;
      uint64_t v11 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v92 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v100 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v92, 24);
          uint64_t v11 = (char *)v113;
          uint64_t v10 = (uint64_t *)((char *)v113 + v100);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v92, 24);
          uint64_t v10 = &v109;
          uint64_t v11 = (char *)v113;
        }
      }
      uint64_t v12 = &v11[24 * v114];
      long long v13 = *(_OWORD *)v10;
      *((void *)v12 + 2) = v10[2];
      *(_OWORD *)uint64_t v12 = v13;
      ++v114;
      if (v112[0])
      {
        uint64_t v14 = &v109;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v109, v9);
        uint64_t v15 = (char *)v113;
        if (v114 >= v115)
        {
          unint64_t v94 = v114 + 1;
          if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
          {
            int64_t v102 = (char *)&v109 - (unsigned char *)v113;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v94, 24);
            uint64_t v15 = (char *)v113;
            uint64_t v14 = (uint64_t *)((char *)v113 + v102);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v94, 24);
            uint64_t v14 = &v109;
            uint64_t v15 = (char *)v113;
          }
        }
        uint64_t v16 = &v15[24 * v114];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = v14[2];
        *(_OWORD *)uint64_t v16 = v17;
        ++v114;
        if (v112[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
        }
      }
    }
    if (!v121) {
      return 0;
    }
    unint64_t v18 = __p;
    if (__p)
    {
      uint64_t v19 = v120;
      uint64_t v20 = __p;
      if (v120 != __p)
      {
        do
          uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        uint64_t v20 = __p;
      }
      char v120 = v18;
      operator delete(v20);
    }
    long long v21 = v117;
    if (!v117) {
      goto LABEL_118;
    }
    uint64_t v22 = v118;
    uint64_t v23 = v117;
    if (v118 == v117) {
      goto LABEL_117;
    }
    do
    {
      uint64_t v25 = *--v22;
      uint64_t v24 = v25;
      void *v22 = 0;
      if (v25) {
        MEMORY[0x21667D390](v24, 0x1000C8077774924);
      }
    }
    while (v22 != v21);
    goto LABEL_116;
  }
  *a1 = v8;
  uint64_t v46 = mlir::DictionaryAttr::get((uint64_t)&v108, "dilation_rates", 0xEuLL);
  if (!v46)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      char v110 = "expected key entry for dilation_rates in DictionaryAttr to set Properties.";
      uint64_t v111 = 74;
      uint64_t v55 = &v109;
      int v56 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v95 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v103 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v95, 24);
          int v56 = (char *)v113;
          uint64_t v55 = (uint64_t *)((char *)v113 + v103);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v95, 24);
          uint64_t v55 = &v109;
          int v56 = (char *)v113;
        }
      }
      uint64_t v57 = &v56[24 * v114];
      long long v58 = *(_OWORD *)v55;
      *((void *)v57 + 2) = v55[2];
      *(_OWORD *)uint64_t v57 = v58;
      ++v114;
      if (v112[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121) {
      return 0;
    }
    unsigned int v59 = __p;
    if (__p)
    {
      uint64_t v60 = v120;
      unsigned int v61 = __p;
      if (v120 != __p)
      {
        do
          uint64_t v60 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v60 - 1);
        while (v60 != v59);
        unsigned int v61 = __p;
      }
      char v120 = v59;
      operator delete(v61);
    }
    long long v21 = v117;
    if (!v117) {
      goto LABEL_118;
    }
    unsigned int v62 = v118;
    uint64_t v23 = v117;
    if (v118 == v117) {
      goto LABEL_117;
    }
    do
    {
      uint64_t v64 = *--v62;
      uint64_t v63 = v64;
      *unsigned int v62 = 0;
      if (v64) {
        MEMORY[0x21667D390](v63, 0x1000C8077774924);
      }
    }
    while (v62 != v21);
    goto LABEL_116;
  }
  uint64_t v47 = v46;
  if ((mlir::DenseIntElementsAttr::classof(v46) & 1) == 0)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      uint64_t v111 = 59;
      char v65 = &v109;
      uint64_t v66 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v96 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v104 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v96, 24);
          uint64_t v66 = (char *)v113;
          char v65 = (uint64_t *)((char *)v113 + v104);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v96, 24);
          char v65 = &v109;
          uint64_t v66 = (char *)v113;
        }
      }
      uint64_t v67 = &v66[24 * v114];
      long long v68 = *(_OWORD *)v65;
      *((void *)v67 + 2) = v65[2];
      *(_OWORD *)uint64_t v67 = v68;
      ++v114;
      if (v112[0])
      {
        uint64_t v69 = &v109;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v109, v47);
        uint64_t v70 = (char *)v113;
        if (v114 >= v115)
        {
          unint64_t v97 = v114 + 1;
          if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
          {
            int64_t v105 = (char *)&v109 - (unsigned char *)v113;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v97, 24);
            uint64_t v70 = (char *)v113;
            uint64_t v69 = (uint64_t *)((char *)v113 + v105);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v97, 24);
            uint64_t v69 = &v109;
            uint64_t v70 = (char *)v113;
          }
        }
        uint64_t v71 = &v70[24 * v114];
        long long v72 = *(_OWORD *)v69;
        *((void *)v71 + 2) = v69[2];
        *(_OWORD *)uint64_t v71 = v72;
        ++v114;
        if (v112[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
        }
      }
    }
    if (!v121) {
      return 0;
    }
    unint64_t v73 = __p;
    if (__p)
    {
      unint64_t v74 = v120;
      unint64_t v75 = __p;
      if (v120 != __p)
      {
        do
          unint64_t v74 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v74 - 1);
        while (v74 != v73);
        unint64_t v75 = __p;
      }
      char v120 = v73;
      operator delete(v75);
    }
    long long v21 = v117;
    if (!v117) {
      goto LABEL_118;
    }
    unint64_t v76 = v118;
    uint64_t v23 = v117;
    if (v118 == v117) {
      goto LABEL_117;
    }
    do
    {
      uint64_t v78 = *--v76;
      uint64_t v77 = v78;
      void *v76 = 0;
      if (v78) {
        MEMORY[0x21667D390](v77, 0x1000C8077774924);
      }
    }
    while (v76 != v21);
    goto LABEL_116;
  }
  a1[1] = v47;
  uint64_t v48 = mlir::DictionaryAttr::get((uint64_t)&v108, "explicit_padding", 0x10uLL);
  uint64_t v107 = v48;
  if (!v48)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      char v110 = "expected key entry for explicit_padding in DictionaryAttr to set Properties.";
      uint64_t v111 = 76;
      unint64_t v79 = &v109;
      int64_t v80 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v98 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v106 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v98, 24);
          int64_t v80 = (char *)v113;
          unint64_t v79 = (uint64_t *)((char *)v113 + v106);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v98, 24);
          unint64_t v79 = &v109;
          int64_t v80 = (char *)v113;
        }
      }
      int64_t v81 = &v80[24 * v114];
      long long v82 = *(_OWORD *)v79;
      *((void *)v81 + 2) = v79[2];
      *(_OWORD *)int64_t v81 = v82;
      ++v114;
      if (v112[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121) {
      return 0;
    }
    int64_t v83 = __p;
    if (__p)
    {
      int64_t v84 = v120;
      int64_t v85 = __p;
      if (v120 != __p)
      {
        do
          int64_t v84 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v84 - 1);
        while (v84 != v83);
        int64_t v85 = __p;
      }
      char v120 = v83;
      operator delete(v85);
    }
    long long v21 = v117;
    if (!v117) {
      goto LABEL_118;
    }
    int64_t v86 = v118;
    uint64_t v23 = v117;
    if (v118 == v117) {
      goto LABEL_117;
    }
    do
    {
      uint64_t v88 = *--v86;
      uint64_t v87 = v88;
      void *v86 = 0;
      if (v88) {
        MEMORY[0x21667D390](v87, 0x1000C8077774924);
      }
    }
    while (v86 != v21);
    goto LABEL_116;
  }
  uint64_t v49 = v48;
  if (mlir::DenseIntElementsAttr::classof(v48))
  {
    a1[2] = v49;
    uint64_t v50 = mlir::DictionaryAttr::get((uint64_t)&v108, "kernel_sizes", 0xCuLL);
    uint64_t v109 = v50;
    if (v50)
    {
      uint64_t v51 = v50;
      if ((mlir::DenseIntElementsAttr::classof(v50) & 1) == 0)
      {
        a3(v112, a4);
LABEL_127:
        mlir::InFlightDiagnostic::append<mlir::Attribute>(v90, &v109);
        goto LABEL_128;
      }
      a1[3] = v51;
      uint64_t v52 = mlir::DictionaryAttr::get((uint64_t)&v108, "strides", 7uLL);
      uint64_t v109 = v52;
      if (v52)
      {
        uint64_t v53 = v52;
        if (mlir::DenseIntElementsAttr::classof(v52))
        {
          a1[4] = v53;
          return 1;
        }
        a3(v112, a4);
        goto LABEL_127;
      }
      a3(v112, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v112, "expected key entry for strides in DictionaryAttr to set Properties.");
    }
    else
    {
      a3(v112, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v112, "expected key entry for kernel_sizes in DictionaryAttr to set Properties.");
    }
LABEL_128:
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v112);
    return 0;
  }
  a3(v112, a4);
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v89, &v107);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v112);
  return 0;
}

uint64_t mlir::mps::ColToImOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v39[6] = *MEMORY[0x263EF8340];
  int64_t v36 = a1;
  int64_t v37 = v39;
  uint64_t v38 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v36, (uint64_t)"data_layout", 11, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v38;
  if (v38 >= HIDWORD(v38))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
    unsigned int v6 = v38;
  }
  uint64_t v7 = (uint64_t *)((char *)v37 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v38 + 1;
  LODWORD(v38) = v38 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"dilation_rates", 14, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      unsigned int v13 = v38;
    }
    uint64_t v14 = (uint64_t *)((char *)v37 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"explicit_padding", 16, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      unsigned int v19 = v38;
    }
    uint64_t v20 = (uint64_t *)((char *)v37 + 16 * v19);
    uint64_t *v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"kernel_sizes", 12, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      unsigned int v25 = v38;
    }
    uint64_t v26 = (uint64_t *)((char *)v37 + 16 * v25);
    uint64_t *v26 = v22;
    v26[1] = v24;
    unsigned int v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"strides", 7, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      unsigned int v31 = v38;
    }
    __int16 v32 = (uint64_t *)((char *)v37 + 16 * v31);
    uint64_t *v32 = v28;
    v32[1] = v30;
    unsigned int v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  unint64_t v33 = v37;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v37 == v39) {
      return DictionaryAttr;
    }
    goto LABEL_24;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v36, (uint64_t *)v37, v8);
  unint64_t v33 = v37;
  if (v37 != v39) {
LABEL_24:
  }
    free(v33);
  return DictionaryAttr;
}

uint64_t mlir::mps::ColToImOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xDuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xCuLL:
      if (memcmp(__s1, "kernel_sizes", __n)) {
        return 0;
      }
      return a2[3];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n)) {
        return 0;
      }
      return a2[1];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::ColToImOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, uint64_t a4)
{
  uint64_t v5 = (void *)result;
  switch(a3)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v5[4] = v11;
        }
        else
        {
          v5[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v7 = a4;
          }
          else {
            uint64_t v7 = 0;
          }
          *(void *)uint64_t result = v7;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xCuLL:
      uint64_t result = memcmp(__s1, "kernel_sizes", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v5[3] = v8;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          v5[1] = v9;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          v5[2] = v10;
        }
        else
        {
          v5[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::ColToImOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"data_layout", 11, *a2);
  }
  uint64_t v5 = a2[1];
  if (v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"dilation_rates", 14, v5);
  }
  uint64_t v6 = a2[2];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"explicit_padding", 16, v6);
  }
  uint64_t v7 = a2[3];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"kernel_sizes", 12, v7);
  }
  uint64_t v8 = a2[4];
  if (v8)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"strides", 7, v8);
  }
}

BOOL mlir::mps::ColToImOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(void ***__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = (_DWORD *)mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(v8, (void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))a3, a4))
  {
    uint64_t v9 = (void *)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v9, (void **)"dilation_rates", (const char *)0xE, a3, a4))
    {
      uint64_t v10 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v10, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))a3, a4))
      {
        uint64_t v11 = (void *)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v11, (void **)"kernel_sizes", (const char *)0xC, a3, a4))
        {
          uint64_t v12 = (void *)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v12, (void **)"strides", (const char *)7, a3, a4))
          {
            return 1;
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(_DWORD *a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id
    && a1[2] < 2u)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v8 = &v29;
    uint64_t v9 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v9 = (char *)v35;
        uint64_t v8 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = &v29;
        uint64_t v9 = (char *)v35;
      }
    }
    uint64_t v10 = &v9[24 * v36];
    long long v11 = *(_OWORD *)v8;
    *((void *)v10 + 2) = v8[2];
    *(_OWORD *)uint64_t v10 = v11;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      uint64_t v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid TensorDataLayout is one of NCHW or NHWC";
        uint64_t v31 = 77;
        uint64_t v12 = &v29;
        unsigned int v13 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            unsigned int v13 = (char *)v35;
            uint64_t v12 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = &v29;
            unsigned int v13 = (char *)v35;
          }
        }
        uint64_t v14 = &v13[24 * v36];
        long long v15 = *(_OWORD *)v12;
        *((void *)v14 + 2) = v12[2];
        *(_OWORD *)uint64_t v14 = v15;
        ++v36;
      }
    }
  }
  uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = __p;
    if (__p)
    {
      uint64_t v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          uint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      unint64_t v42 = v16;
      operator delete(v18);
    }
    unsigned int v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      uint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        uint64_t v21 = v39;
      }
      char v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v7;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(void *a1, void **a2, const char *a3, void (*a4)(void ***__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v66 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1)) {
    goto LABEL_7;
  }
  uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*a1 + 8);
  v45[0] = a1;
  v45[1] = v10;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v45);
  uint64_t v12 = Type;
  if (Type) {
    Type = (void *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  }
  v46[0] = v12;
  v46[1] = Type;
  Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v46);
  uint64_t v65 = 2;
  if (v14 != 1 || *Shape != v65) {
    goto LABEL_7;
  }
  uint64_t v44 = a1;
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v53, (uint64_t)a1, 0);
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v44);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v49, (uint64_t)a1, NumElements);
  while (1)
  {
    BOOL v34 = v53 == v49 && v54[0] == v50;
    if (v34 && v55 == v51) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*(&v53, (llvm::APInt *)&v47);
    if (v48 > 0x40)
    {
      uint64_t v33 = *v47;
      MEMORY[0x21667D390]();
      if (!v33) {
        goto LABEL_7;
      }
    }
    else if (!v47)
    {
      goto LABEL_7;
    }
    ++v55;
  }
  unint64_t v41 = a1;
  v42[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v41);
  v42[1] = v35;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v42);
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
    return 1;
  }
LABEL_7:
  a4(&v53, a5);
  if (v53)
  {
    LODWORD(v49) = 3;
    uint64_t v50 = "attribute '";
    uint64_t v51 = 11;
    long long v15 = &v49;
    uint64_t v16 = (char *)v56;
    if (v57 >= v58)
    {
      unint64_t v37 = v57 + 1;
      if (v56 <= &v49 && (char *)v56 + 24 * v57 > (char *)&v49)
      {
        int64_t v39 = (char *)&v49 - (unsigned char *)v56;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v37, 24);
        uint64_t v16 = (char *)v56;
        long long v15 = (void ***)((char *)v56 + v39);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v37, 24);
        long long v15 = &v49;
        uint64_t v16 = (char *)v56;
      }
    }
    uint64_t v17 = &v16[24 * v57];
    long long v18 = *(_OWORD *)v15;
    *((void *)v17 + 2) = v15[2];
    *(_OWORD *)uint64_t v17 = v18;
    ++v57;
    if (v53)
    {
      __int16 v52 = 261;
      uint64_t v49 = a2;
      uint64_t v50 = a3;
      mlir::Diagnostic::operator<<((uint64_t)v54, &v49);
      if (v53)
      {
        LODWORD(v49) = 3;
        uint64_t v50 = "' failed to satisfy constraint: positive ui64 elements attribute of shape {2}";
        uint64_t v51 = 77;
        unsigned int v19 = &v49;
        uint64_t v20 = (char *)v56;
        if (v57 >= v58)
        {
          unint64_t v38 = v57 + 1;
          if (v56 <= &v49 && (char *)v56 + 24 * v57 > (char *)&v49)
          {
            int64_t v40 = (char *)&v49 - (unsigned char *)v56;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v38, 24);
            uint64_t v20 = (char *)v56;
            unsigned int v19 = (void ***)((char *)v56 + v40);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v38, 24);
            unsigned int v19 = &v49;
            uint64_t v20 = (char *)v56;
          }
        }
        uint64_t v21 = &v20[24 * v57];
        long long v22 = *(_OWORD *)v19;
        *((void *)v21 + 2) = v19[2];
        *(_OWORD *)uint64_t v21 = v22;
        ++v57;
      }
    }
  }
  uint64_t v23 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v53);
  if (v53) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v53);
  }
  if (v64)
  {
    uint64_t v24 = __p;
    if (__p)
    {
      unint64_t v25 = v63;
      unint64_t v26 = __p;
      if (v63 != __p)
      {
        do
          unint64_t v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        unint64_t v26 = __p;
      }
      uint64_t v63 = v24;
      operator delete(v26);
    }
    int64_t v27 = v60;
    if (v60)
    {
      int64_t v28 = v61;
      uint64_t v29 = v60;
      if (v61 != v60)
      {
        do
        {
          uint64_t v31 = *--v28;
          uint64_t v30 = v31;
          *int64_t v28 = 0;
          if (v31) {
            MEMORY[0x21667D390](v30, 0x1000C8077774924);
          }
        }
        while (v28 != v27);
        uint64_t v29 = v60;
      }
      unsigned int v61 = v27;
      operator delete(v29);
    }
    if (v56 != v59) {
      free(v56);
    }
  }
  return v23;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(void **a1, void **a2, const char *a3, void (*a4)(void **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1)) {
    goto LABEL_13;
  }
  uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  unint64_t v42 = a1;
  char v43 = (const char *)v10;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v42);
  uint64_t v12 = Type;
  if (Type) {
    Type = (void *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  }
  uint64_t v46 = v12;
  uint64_t v47 = Type;
  Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v46);
  long long v57 = xmmword_211ED27F0;
  if (v14 == 2 && *Shape == (void)v57 && Shape[1] == *((void *)&v57 + 1))
  {
    int64_t v39 = a1;
    v40[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39);
    v40[1] = v16;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v40);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
  }
LABEL_13:
  a4(&v46, a5);
  if (v46)
  {
    LODWORD(v42) = 3;
    char v43 = "attribute '";
    uint64_t v44 = 11;
    long long v18 = &v42;
    unsigned int v19 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v35 = v49 + 1;
      if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
      {
        int64_t v37 = (char *)&v42 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
        unsigned int v19 = (char *)v48;
        long long v18 = (void ***)((char *)v48 + v37);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
        long long v18 = &v42;
        unsigned int v19 = (char *)v48;
      }
    }
    uint64_t v20 = &v19[24 * v49];
    long long v21 = *(_OWORD *)v18;
    *((void *)v20 + 2) = v18[2];
    *(_OWORD *)uint64_t v20 = v21;
    ++v49;
    if (v46)
    {
      __int16 v45 = 261;
      unint64_t v42 = a2;
      char v43 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v47, &v42);
      if (v46)
      {
        LODWORD(v42) = 3;
        char v43 = "' failed to satisfy constraint: ui64 elements attribute of shape {4, 2}";
        uint64_t v44 = 71;
        long long v22 = &v42;
        uint64_t v23 = (char *)v48;
        if (v49 >= v50)
        {
          unint64_t v36 = v49 + 1;
          if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
          {
            int64_t v38 = (char *)&v42 - (unsigned char *)v48;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            uint64_t v23 = (char *)v48;
            long long v22 = (void ***)((char *)v48 + v38);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            long long v22 = &v42;
            uint64_t v23 = (char *)v48;
          }
        }
        uint64_t v24 = &v23[24 * v49];
        long long v25 = *(_OWORD *)v22;
        *((void *)v24 + 2) = v22[2];
        *(_OWORD *)uint64_t v24 = v25;
        ++v49;
      }
    }
  }
  uint64_t v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v46);
  if (v46) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v46);
  }
  if (v56)
  {
    unint64_t v26 = __p;
    if (__p)
    {
      int64_t v27 = v55;
      int64_t v28 = __p;
      if (v55 != __p)
      {
        do
          int64_t v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
        while (v27 != v26);
        int64_t v28 = __p;
      }
      uint64_t v55 = v26;
      operator delete(v28);
    }
    uint64_t v29 = v52;
    if (v52)
    {
      uint64_t v30 = v53;
      uint64_t v31 = v52;
      if (v53 != v52)
      {
        do
        {
          uint64_t v33 = *--v30;
          uint64_t v32 = v33;
          void *v30 = 0;
          if (v33) {
            MEMORY[0x21667D390](v32, 0x1000C8077774924);
          }
        }
        while (v30 != v29);
        uint64_t v31 = v52;
      }
      uint64_t v53 = v29;
      operator delete(v31);
    }
    if (v48 != v51) {
      free(v48);
    }
  }
  return v17;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  uint64_t v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    uint64_t v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        uint64_t v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  int64_t v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::TensorDataLayoutAttr]";
  unint64_t v41 = 81;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    int64_t v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      uint64_t v14 = &v40;
      long long v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v15 = (char *)v46;
          uint64_t v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v14 = &v40;
          long long v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        long long v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unsigned int v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unsigned int v19 = (char *)v46;
            long long v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            long long v18 = &v40;
            unsigned int v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      uint64_t v24 = v53;
      long long v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        long long v25 = __p;
      }
      uint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      uint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

BOOL mlir::mps::ColToImOp::verifyInvariantsImpl(mlir::mps::ColToImOp *this)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v3 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = *(_DWORD **)v3;
  if (*(void *)v3)
  {
    uint64_t v5 = *(void **)(v3 + 8);
    if (v5)
    {
      uint64_t v6 = *(void ***)(v3 + 16);
      if (v6)
      {
        uint64_t v7 = *(void **)(v3 + 24);
        if (v7)
        {
          uint64_t v8 = *(void **)(v3 + 32);
          if (v8)
          {
            v47[0] = v2;
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v7, (void **)"kernel_sizes", (const char *)0xC, (void (*)(void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0; {
            v47[0] = *(void *)this;
            }
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v8, (void **)"strides", (const char *)7, (void (*)(void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0; {
            v47[0] = *(void *)this;
            }
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v5, (void **)"dilation_rates", (const char *)0xE, (void (*)(void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0; {
            v47[0] = *(void *)this;
            }
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0; {
            v47[0] = *(void *)this;
            }
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(v4, (void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps9(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 1u))
            {
              return 0;
            }
            if (*(_DWORD *)(*(void *)this + 36)) {
              uint64_t v9 = *(void *)this - 16;
            }
            else {
              uint64_t v9 = 0;
            }
            uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v9, 0);
            return mlir::mps::__mlir_ods_local_type_constraint_MPSOps10(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
          }
          v45[0] = (void **)"requires attribute 'strides'";
          __int16 v46 = 259;
          mlir::OpState::emitOpError((uint64_t *)this, v45, (uint64_t)v47);
          uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
          if (v47[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
          }
          if (v54)
          {
            int64_t v38 = __p;
            if (__p)
            {
              uint64_t v39 = v53;
              int64_t v40 = __p;
              if (v53 != __p)
              {
                do
                  uint64_t v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v39 - 1);
                while (v39 != v38);
                int64_t v40 = __p;
              }
              uint64_t v53 = v38;
              operator delete(v40);
            }
            long long v15 = v50;
            if (!v50) {
              goto LABEL_93;
            }
            unint64_t v41 = v51;
            long long v17 = v50;
            if (v51 == v50)
            {
LABEL_92:
              uint64_t v51 = v15;
              operator delete(v17);
LABEL_93:
              if (v48 != &v49) {
                free(v48);
              }
              return v11;
            }
            do
            {
              uint64_t v43 = *--v41;
              uint64_t v42 = v43;
              *unint64_t v41 = 0;
              if (v43) {
                MEMORY[0x21667D390](v42, 0x1000C8077774924);
              }
            }
            while (v41 != v15);
LABEL_91:
            long long v17 = v50;
            goto LABEL_92;
          }
        }
        else
        {
          v45[0] = (void **)"requires attribute 'kernel_sizes'";
          __int16 v46 = 259;
          mlir::OpState::emitOpError((uint64_t *)this, v45, (uint64_t)v47);
          uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
          if (v47[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
          }
          if (v54)
          {
            unint64_t v32 = __p;
            if (__p)
            {
              unint64_t v33 = v53;
              unint64_t v34 = __p;
              if (v53 != __p)
              {
                do
                  unint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
                while (v33 != v32);
                unint64_t v34 = __p;
              }
              uint64_t v53 = v32;
              operator delete(v34);
            }
            long long v15 = v50;
            if (!v50) {
              goto LABEL_93;
            }
            int64_t v35 = v51;
            long long v17 = v50;
            if (v51 == v50) {
              goto LABEL_92;
            }
            do
            {
              uint64_t v37 = *--v35;
              uint64_t v36 = v37;
              void *v35 = 0;
              if (v37) {
                MEMORY[0x21667D390](v36, 0x1000C8077774924);
              }
            }
            while (v35 != v15);
            goto LABEL_91;
          }
        }
      }
      else
      {
        v45[0] = (void **)"requires attribute 'explicit_padding'";
        __int16 v46 = 259;
        mlir::OpState::emitOpError((uint64_t *)this, v45, (uint64_t)v47);
        uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
        if (v47[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
        }
        if (v54)
        {
          unint64_t v26 = __p;
          if (__p)
          {
            int64_t v27 = v53;
            int64_t v28 = __p;
            if (v53 != __p)
            {
              do
                int64_t v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
              while (v27 != v26);
              int64_t v28 = __p;
            }
            uint64_t v53 = v26;
            operator delete(v28);
          }
          long long v15 = v50;
          if (!v50) {
            goto LABEL_93;
          }
          uint64_t v29 = v51;
          long long v17 = v50;
          if (v51 == v50) {
            goto LABEL_92;
          }
          do
          {
            uint64_t v31 = *--v29;
            uint64_t v30 = v31;
            *uint64_t v29 = 0;
            if (v31) {
              MEMORY[0x21667D390](v30, 0x1000C8077774924);
            }
          }
          while (v29 != v15);
          goto LABEL_91;
        }
      }
    }
    else
    {
      v45[0] = (void **)"requires attribute 'dilation_rates'";
      __int16 v46 = 259;
      mlir::OpState::emitOpError((uint64_t *)this, v45, (uint64_t)v47);
      uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
      if (v54)
      {
        uint64_t v20 = __p;
        if (__p)
        {
          long long v21 = v53;
          uint64_t v22 = __p;
          if (v53 != __p)
          {
            do
              long long v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
            while (v21 != v20);
            uint64_t v22 = __p;
          }
          uint64_t v53 = v20;
          operator delete(v22);
        }
        long long v15 = v50;
        if (!v50) {
          goto LABEL_93;
        }
        uint64_t v23 = v51;
        long long v17 = v50;
        if (v51 == v50) {
          goto LABEL_92;
        }
        do
        {
          uint64_t v25 = *--v23;
          uint64_t v24 = v25;
          *uint64_t v23 = 0;
          if (v25) {
            MEMORY[0x21667D390](v24, 0x1000C8077774924);
          }
        }
        while (v23 != v15);
        goto LABEL_91;
      }
    }
  }
  else
  {
    v45[0] = (void **)"requires attribute 'data_layout'";
    __int16 v46 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v45, (uint64_t)v47);
    uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
    if (v47[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
    if (v54)
    {
      uint64_t v12 = __p;
      if (__p)
      {
        unint64_t v13 = v53;
        uint64_t v14 = __p;
        if (v53 != __p)
        {
          do
            unint64_t v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          uint64_t v14 = __p;
        }
        uint64_t v53 = v12;
        operator delete(v14);
      }
      long long v15 = v50;
      if (!v50) {
        goto LABEL_93;
      }
      uint64_t v16 = v51;
      long long v17 = v50;
      if (v51 == v50) {
        goto LABEL_92;
      }
      do
      {
        uint64_t v19 = *--v16;
        uint64_t v18 = v19;
        void *v16 = 0;
        if (v19) {
          MEMORY[0x21667D390](v18, 0x1000C8077774924);
        }
      }
      while (v16 != v15);
      goto LABEL_91;
    }
  }
  return v11;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps9(uint64_t a1, void **a2, void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  unint64_t v10 = *a2;
  uint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v61[0] = a2;
    v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isF32((mlir::Type *)&OperandRange)) {
      return 1;
    }
    unint64_t v10 = *a2;
    if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_3:
      uint64_t v53 = a2;
      uint64_t v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53)) {
        goto LABEL_10;
      }
      uint64_t v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      uint64_t v58 = a2;
      uint64_t v59 = v12;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v58);
      if (v13 != 3) {
        goto LABEL_10;
      }
      uint64_t v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v56[0] = a2;
      v56[1] = v14;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
      if (!mlir::Type::isF32((mlir::Type *)&OperandRange)) {
        goto LABEL_10;
      }
      return 1;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    goto LABEL_3;
  }
LABEL_10:
  __int16 v55 = 261;
  uint64_t v53 = a3;
  uint64_t v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    uint64_t v59 = (uint64_t)" #";
    uint64_t v60 = 2;
    uint64_t v16 = &v58;
    long long v17 = (char *)v62;
    if (v63 >= v64)
    {
      unint64_t v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        int64_t v49 = (char *)&v58 - (unsigned char *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        long long v17 = (char *)v62;
        uint64_t v16 = (void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        uint64_t v16 = &v58;
        long long v17 = (char *)v62;
      }
    }
    uint64_t v18 = &v17[24 * v63];
    long long v19 = *(_OWORD *)v16;
    *((void *)v18 + 2) = v16[2];
    *(_OWORD *)uint64_t v18 = v19;
    uint64_t v20 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      uint64_t v59 = a5;
      long long v21 = &v58;
      uint64_t v22 = (char *)v62;
      if (v20 >= v64)
      {
        unint64_t v44 = v20 + 1;
        BOOL v45 = (char *)v62 + 24 * v20 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          int64_t v50 = (char *)&v58 - (unsigned char *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          uint64_t v22 = (char *)v62;
          long long v21 = (void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          long long v21 = &v58;
          uint64_t v22 = (char *)v62;
        }
      }
      uint64_t v23 = &v22[24 * v63];
      long long v24 = *(_OWORD *)v21;
      *((void *)v23 + 2) = v21[2];
      *(_OWORD *)uint64_t v23 = v24;
      uint64_t v25 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        uint64_t v59 = (uint64_t)" must be unranked tensor of 32-bit float values or 3D tensor of 32-bit float values, but got ";
        uint64_t v60 = 93;
        unint64_t v26 = &v58;
        int64_t v27 = (char *)v62;
        if (v25 >= v64)
        {
          unint64_t v46 = v25 + 1;
          BOOL v47 = (char *)v62 + 24 * v25 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            int64_t v51 = (char *)&v58 - (unsigned char *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            int64_t v27 = (char *)v62;
            unint64_t v26 = (void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            unint64_t v26 = &v58;
            int64_t v27 = (char *)v62;
          }
        }
        int64_t v28 = &v27[24 * v63];
        long long v29 = *(_OWORD *)v26;
        *((void *)v28 + 2) = v26[2];
        *(_OWORD *)int64_t v28 = v29;
        ++v63;
        if (v61[0])
        {
          uint64_t v30 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          uint64_t v31 = (char *)v62;
          if (v63 >= v64)
          {
            unint64_t v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              int64_t v52 = (char *)&v58 - (unsigned char *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              uint64_t v31 = (char *)v62;
              uint64_t v30 = (void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              uint64_t v30 = &v58;
              uint64_t v31 = (char *)v62;
            }
          }
          unint64_t v32 = &v31[24 * v63];
          long long v33 = *(_OWORD *)v30;
          *((void *)v32 + 2) = v30[2];
          *(_OWORD *)unint64_t v32 = v33;
          ++v63;
        }
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  }
  if (v70)
  {
    unint64_t v34 = __p;
    if (__p)
    {
      int64_t v35 = v69;
      uint64_t v36 = __p;
      if (v69 != __p)
      {
        do
          int64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        uint64_t v36 = __p;
      }
      uint64_t v69 = v34;
      operator delete(v36);
    }
    uint64_t v37 = v66;
    if (v66)
    {
      int64_t v38 = v67;
      uint64_t v39 = v66;
      if (v67 != v66)
      {
        do
        {
          uint64_t v41 = *--v38;
          uint64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            MEMORY[0x21667D390](v40, 0x1000C8077774924);
          }
        }
        while (v38 != v37);
        uint64_t v39 = v66;
      }
      uint64_t v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65) {
      free(v62);
    }
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps10(uint64_t a1, void **a2, void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  unint64_t v10 = *a2;
  uint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v61[0] = a2;
    v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isF32((mlir::Type *)&OperandRange)) {
      return 1;
    }
    unint64_t v10 = *a2;
    if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_3:
      uint64_t v53 = a2;
      uint64_t v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53)) {
        goto LABEL_10;
      }
      uint64_t v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      uint64_t v58 = a2;
      uint64_t v59 = v12;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v58);
      if (v13 != 4) {
        goto LABEL_10;
      }
      uint64_t v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v56[0] = a2;
      v56[1] = v14;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
      if (!mlir::Type::isF32((mlir::Type *)&OperandRange)) {
        goto LABEL_10;
      }
      return 1;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    goto LABEL_3;
  }
LABEL_10:
  __int16 v55 = 261;
  uint64_t v53 = a3;
  uint64_t v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    uint64_t v59 = (uint64_t)" #";
    uint64_t v60 = 2;
    uint64_t v16 = &v58;
    long long v17 = (char *)v62;
    if (v63 >= v64)
    {
      unint64_t v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        int64_t v49 = (char *)&v58 - (unsigned char *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        long long v17 = (char *)v62;
        uint64_t v16 = (void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        uint64_t v16 = &v58;
        long long v17 = (char *)v62;
      }
    }
    uint64_t v18 = &v17[24 * v63];
    long long v19 = *(_OWORD *)v16;
    *((void *)v18 + 2) = v16[2];
    *(_OWORD *)uint64_t v18 = v19;
    uint64_t v20 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      uint64_t v59 = a5;
      long long v21 = &v58;
      uint64_t v22 = (char *)v62;
      if (v20 >= v64)
      {
        unint64_t v44 = v20 + 1;
        BOOL v45 = (char *)v62 + 24 * v20 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          int64_t v50 = (char *)&v58 - (unsigned char *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          uint64_t v22 = (char *)v62;
          long long v21 = (void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          long long v21 = &v58;
          uint64_t v22 = (char *)v62;
        }
      }
      uint64_t v23 = &v22[24 * v63];
      long long v24 = *(_OWORD *)v21;
      *((void *)v23 + 2) = v21[2];
      *(_OWORD *)uint64_t v23 = v24;
      uint64_t v25 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        uint64_t v59 = (uint64_t)" must be unranked tensor of 32-bit float values or 4D tensor of 32-bit float values, but got ";
        uint64_t v60 = 93;
        unint64_t v26 = &v58;
        int64_t v27 = (char *)v62;
        if (v25 >= v64)
        {
          unint64_t v46 = v25 + 1;
          BOOL v47 = (char *)v62 + 24 * v25 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            int64_t v51 = (char *)&v58 - (unsigned char *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            int64_t v27 = (char *)v62;
            unint64_t v26 = (void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            unint64_t v26 = &v58;
            int64_t v27 = (char *)v62;
          }
        }
        int64_t v28 = &v27[24 * v63];
        long long v29 = *(_OWORD *)v26;
        *((void *)v28 + 2) = v26[2];
        *(_OWORD *)int64_t v28 = v29;
        ++v63;
        if (v61[0])
        {
          uint64_t v30 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          uint64_t v31 = (char *)v62;
          if (v63 >= v64)
          {
            unint64_t v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              int64_t v52 = (char *)&v58 - (unsigned char *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              uint64_t v31 = (char *)v62;
              uint64_t v30 = (void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              uint64_t v30 = &v58;
              uint64_t v31 = (char *)v62;
            }
          }
          unint64_t v32 = &v31[24 * v63];
          long long v33 = *(_OWORD *)v30;
          *((void *)v32 + 2) = v30[2];
          *(_OWORD *)unint64_t v32 = v33;
          ++v63;
        }
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  }
  if (v70)
  {
    unint64_t v34 = __p;
    if (__p)
    {
      int64_t v35 = v69;
      uint64_t v36 = __p;
      if (v69 != __p)
      {
        do
          int64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        uint64_t v36 = __p;
      }
      uint64_t v69 = v34;
      operator delete(v36);
    }
    uint64_t v37 = v66;
    if (v66)
    {
      int64_t v38 = v67;
      uint64_t v39 = v66;
      if (v67 != v66)
      {
        do
        {
          uint64_t v41 = *--v38;
          uint64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            MEMORY[0x21667D390](v40, 0x1000C8077774924);
          }
        }
        while (v38 != v37);
        uint64_t v39 = v66;
      }
      uint64_t v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65) {
      free(v62);
    }
  }
  return v15;
}

void mlir::mps::ColToImOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::ConcatOpGenericAdaptorBase::ConcatOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  uint64_t v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.concat", 10, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::ConcatOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      int v44 = 3;
      BOOL v45 = "expected DictionaryAttr to set properties";
      uint64_t v46 = 41;
      unint64_t v26 = &v44;
      int64_t v27 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v40 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          int64_t v27 = (char *)v48;
          unint64_t v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          unint64_t v26 = &v44;
          int64_t v27 = (char *)v48;
        }
      }
      int64_t v28 = &v27[24 * v49];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)int64_t v28 = v29;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
    if (!v56) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      uint64_t v31 = v55;
      unint64_t v32 = __p;
      if (v55 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unint64_t v32 = __p;
      }
      __int16 v55 = v30;
      operator delete(v32);
    }
    long long v21 = v52;
    if (!v52) {
      goto LABEL_43;
    }
    long long v33 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *long long v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "interleave", 0xAuLL);
  if (!v8) {
    return 1;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    int v44 = 3;
    uint64_t v46 = 55;
    unint64_t v10 = &v44;
    uint64_t v11 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        int64_t v41 = (char *)&v44 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v11 = (char *)v48;
        unint64_t v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        unint64_t v10 = &v44;
        uint64_t v11 = (char *)v48;
      }
    }
    uint64_t v12 = &v11[24 * v49];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v49;
    if (v47[0])
    {
      uint64_t v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      uint64_t v15 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v42 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v15 = (char *)v48;
          uint64_t v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v14 = &v44;
          uint64_t v15 = (char *)v48;
        }
      }
      uint64_t v16 = &v15[24 * v49];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)uint64_t v16 = v17;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
  }
  if (!v56) {
    return 0;
  }
  uint64_t v18 = __p;
  if (__p)
  {
    long long v19 = v55;
    uint64_t v20 = __p;
    if (v55 != __p)
    {
      do
        long long v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      uint64_t v20 = __p;
    }
    __int16 v55 = v18;
    operator delete(v20);
  }
  long long v21 = v52;
  if (v52)
  {
    uint64_t v22 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v25 = *--v22;
      uint64_t v24 = v25;
      void *v22 = 0;
      if (v25) {
        MEMORY[0x21667D390](v24, 0x1000C8077774924);
      }
    }
    while (v22 != v21);
LABEL_41:
    uint64_t v23 = v52;
LABEL_42:
    uint64_t v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51) {
    free(v48);
  }
  return 0;
}

uint64_t mlir::mps::ConcatOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x263EF8340];
  uint64_t v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"interleave", 10, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  uint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::ConcatOp::verifyInvariantsImpl(mlir::mps::ConcatOp *this)
{
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(void *)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  uint64_t v19 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v3, (void **)"interleave", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v19))return 0; {
  uint64_t v4 = *(void *)this;
  }
  if ((*(unsigned char *)(*(void *)this + 46) & 0x80) == 0)
  {
    uint64_t v7 = 0;
    uint64_t v6 = 0xFFFFFFFFLL;
LABEL_5:
    uint64_t v8 = 0;
    uint64_t v9 = v7 + 24;
    while (mlir::mps::__mlir_ods_local_type_constraint_MPSOps11(*(void *)this, (void **)(*(void *)(*(void *)v9 + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, v8))
    {
      ++v8;
      v9 += 32;
      if (v6 == v8)
      {
        uint64_t v4 = *(void *)this;
        if ((*(unsigned char *)(*(void *)this + 46) & 0x80) != 0) {
          goto LABEL_11;
        }
        uint64_t v10 = 0;
        int v11 = -2;
        goto LABEL_12;
      }
    }
    return 0;
  }
  int v5 = *(_DWORD *)(v4 + 68);
  uint64_t v6 = (v5 - 1);
  if (v5 != 1)
  {
    uint64_t v7 = *(void *)(v4 + 72);
    goto LABEL_5;
  }
  LODWORD(v8) = 0;
LABEL_11:
  int v12 = *(_DWORD *)(v4 + 68);
  uint64_t v10 = *(void *)(v4 + 72);
  int v11 = v12 - 2;
LABEL_12:
  uint64_t v13 = (v11 + 1);
  uint64_t v14 = (v11 + 2) - v13;
  for (uint64_t i = v10 + 32 * v13 + 24;
        mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*(void *)this, (void **)(*(void *)(*(void *)i + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, v8);
        i += 32)
  {
    LODWORD(v8) = v8 + 1;
    if (!--v14)
    {
      if (*(_DWORD *)(*(void *)this + 36)) {
        uint64_t v16 = *(void *)this - 16;
      }
      else {
        uint64_t v16 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v16, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
    }
  }
  return 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps11(uint64_t a1, void **a2, void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v73 = *MEMORY[0x263EF8340];
  uint64_t v10 = *a2;
  int v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v63[0] = a2;
    v63[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v63);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange)
      || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      return 1;
    }
    uint64_t v10 = *a2;
    int v11 = (void *)*((void *)*a2 + 17);
  }
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    uint64_t v54 = a2;
    uint64_t v55 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t v14 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v54);
    if (*(_UNKNOWN **)(*(void *)v14 + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      uint64_t v42 = v14;
      uint64_t v59 = v14;
      uint64_t OperandRange = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v59);
      if (mlir::Type::isF16((mlir::Type *)&OperandRange)) {
        return 1;
      }
      uint64_t v57 = v42;
      uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v57);
      if (mlir::Type::isF32((mlir::Type *)&Value)) {
        return 1;
      }
    }
  }
  __int16 v56 = 261;
  uint64_t v54 = a3;
  uint64_t v55 = a4;
  mlir::Operation::emitOpError(a1, &v54, (uint64_t)v63);
  if (v63[0])
  {
    LODWORD(OperandRange) = 3;
    unsigned int v61 = " #";
    uint64_t v62 = 2;
    p_uint64_t OperandRange = &OperandRange;
    uint64_t v16 = (char *)v64;
    if (v65 >= v66)
    {
      unint64_t v44 = v65 + 1;
      if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
      {
        int64_t v50 = (char *)&OperandRange - (unsigned char *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        uint64_t v16 = (char *)v64;
        p_uint64_t OperandRange = (uint64_t *)((char *)v64 + v50);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        p_uint64_t OperandRange = &OperandRange;
        uint64_t v16 = (char *)v64;
      }
    }
    long long v17 = &v16[24 * v65];
    long long v18 = *(_OWORD *)p_OperandRange;
    *((void *)v17 + 2) = p_OperandRange[2];
    *(_OWORD *)long long v17 = v18;
    uint64_t v19 = ++v65;
    if (v63[0])
    {
      LODWORD(OperandRange) = 5;
      unsigned int v61 = (const char *)a5;
      uint64_t v20 = &OperandRange;
      long long v21 = (char *)v64;
      if (v19 >= v66)
      {
        unint64_t v45 = v19 + 1;
        BOOL v46 = (char *)v64 + 24 * v19 > (char *)&OperandRange;
        if (v64 <= &OperandRange && v46)
        {
          int64_t v51 = (char *)&OperandRange - (unsigned char *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          long long v21 = (char *)v64;
          uint64_t v20 = (uint64_t *)((char *)v64 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          uint64_t v20 = &OperandRange;
          long long v21 = (char *)v64;
        }
      }
      uint64_t v22 = &v21[24 * v65];
      long long v23 = *(_OWORD *)v20;
      *((void *)v22 + 2) = v20[2];
      *(_OWORD *)uint64_t v22 = v23;
      uint64_t v24 = ++v65;
      if (v63[0])
      {
        LODWORD(OperandRange) = 3;
        unsigned int v61 = " must be variadic of tensor of mps native type values or tensor of complex values, but got ";
        uint64_t v62 = 91;
        uint64_t v25 = &OperandRange;
        unint64_t v26 = (char *)v64;
        if (v24 >= v66)
        {
          unint64_t v47 = v24 + 1;
          BOOL v48 = (char *)v64 + 24 * v24 > (char *)&OperandRange;
          if (v64 <= &OperandRange && v48)
          {
            int64_t v52 = (char *)&OperandRange - (unsigned char *)v64;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            unint64_t v26 = (char *)v64;
            uint64_t v25 = (uint64_t *)((char *)v64 + v52);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            uint64_t v25 = &OperandRange;
            unint64_t v26 = (char *)v64;
          }
        }
        int64_t v27 = &v26[24 * v65];
        long long v28 = *(_OWORD *)v25;
        *((void *)v27 + 2) = v25[2];
        *(_OWORD *)int64_t v27 = v28;
        ++v65;
        if (v63[0])
        {
          long long v29 = &OperandRange;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, (uint64_t)a2);
          uint64_t v30 = (char *)v64;
          if (v65 >= v66)
          {
            unint64_t v49 = v65 + 1;
            if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
            {
              int64_t v53 = (char *)&OperandRange - (unsigned char *)v64;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              uint64_t v30 = (char *)v64;
              long long v29 = (uint64_t *)((char *)v64 + v53);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              long long v29 = &OperandRange;
              uint64_t v30 = (char *)v64;
            }
          }
          uint64_t v31 = &v30[24 * v65];
          long long v32 = *(_OWORD *)v29;
          *((void *)v31 + 2) = v29[2];
          *(_OWORD *)uint64_t v31 = v32;
          ++v65;
        }
      }
    }
  }
  uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v63);
  if (v63[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
  }
  if (v72)
  {
    uint64_t v34 = __p;
    if (__p)
    {
      uint64_t v35 = v71;
      uint64_t v36 = __p;
      if (v71 != __p)
      {
        do
          uint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        uint64_t v36 = __p;
      }
      uint64_t v71 = v34;
      operator delete(v36);
    }
    unint64_t v37 = v68;
    if (v68)
    {
      unint64_t v38 = v69;
      unint64_t v39 = v68;
      if (v69 != v68)
      {
        do
        {
          uint64_t v41 = *--v38;
          uint64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            MEMORY[0x21667D390](v40, 0x1000C8077774924);
          }
        }
        while (v38 != v37);
        unint64_t v39 = v68;
      }
      uint64_t v69 = v37;
      operator delete(v39);
    }
    if (v64 != v67) {
      free(v64);
    }
  }
  return v33;
}

void mlir::mps::ConcatOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::ConjugateOpGenericAdaptorBase::ConjugateOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.conjugate", 13, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ConjugateOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

mlir::Attribute *mlir::mps::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase(mlir::Attribute *this, uint64_t a2, void **a3, uint64_t a4, uint64_t a5)
{
  *(void *)this = a2;
  *((unsigned char *)this + 8) = 0;
  uint64_t v8 = (char *)this + 8;
  *((unsigned char *)this + 16) = 0;
  uint64_t v9 = *a3;
  *((void *)this + 3) = *a3;
  if (v9
    && ((uint64_t v10 = *(void **)(*v9 + 136),
         BOOL v11 = v10 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id,
         v10 != &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
      ? (int v12 = 0)
      : (int v12 = v9),
        uint64_t v20 = v12,
        v11))
  {
    uint64_t v15 = v9[2];
    uint64_t Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
    long long v18 = (pthread_rwlock_t **)(mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v17) + 48);
    llvm::sys::RWMutexImpl::lock(v18);
    ++*(void *)(v15 + 88);
    llvm::sys::RWMutexImpl::unlock_shared(v18);
    uint64_t v19 = *(void *)this;
    *((void *)this + 4) = a4;
    *((void *)this + 5) = a5;
    if (!v19) {
      return this;
    }
  }
  else
  {
    *((void *)this + 4) = a4;
    *((void *)this + 5) = a5;
    if (!a2) {
      return this;
    }
  }
  uint64_t v13 = mlir::Attribute::getContext(this);
  if (*((unsigned char *)this + 16)) {
    *((unsigned char *)this + 16) = 0;
  }
  mlir::OperationName::OperationName(v8, "mps.constant", 12, v13);
  *((unsigned char *)this + 16) = 1;
  return this;
}

mlir::Attribute *mlir::mps::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase(mlir::Attribute *a1, uint64_t a2)
{
  void v10[2] = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  uint64_t v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  if (BYTE3(v4)) {
    uint64_t v8 = (void **)v5;
  }
  else {
    uint64_t v8 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  mlir::mps::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase(a1, v3, v8, v10[0], v10[1]);
  return a1;
}

uint64_t mlir::mps::ConstantOp::setPropertiesFromAttr(void *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v44 = v6;
  if (!v6)
  {
    a3(v48, a4);
    if (v48[0])
    {
      int v45 = 3;
      BOOL v46 = "expected DictionaryAttr to set properties";
      uint64_t v47 = 41;
      long long v18 = &v45;
      uint64_t v19 = (char *)v49;
      if (v50 >= v51)
      {
        unint64_t v40 = v50 + 1;
        if (v49 <= &v45 && (char *)v49 + 24 * v50 > (char *)&v45)
        {
          int64_t v42 = (char *)&v45 - (unsigned char *)v49;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v40, 24);
          uint64_t v19 = (char *)v49;
          long long v18 = (int *)((char *)v49 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v40, 24);
          long long v18 = &v45;
          uint64_t v19 = (char *)v49;
        }
      }
      uint64_t v20 = &v19[24 * v50];
      long long v21 = *(_OWORD *)v18;
      *((void *)v20 + 2) = *((void *)v18 + 2);
      *(_OWORD *)uint64_t v20 = v21;
      ++v50;
      if (v48[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
      }
    }
    if (!v57) {
      return 0;
    }
    uint64_t v22 = __p;
    if (__p)
    {
      long long v23 = v56;
      uint64_t v24 = __p;
      if (v56 != __p)
      {
        do
          long long v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        uint64_t v24 = __p;
      }
      __int16 v56 = v22;
      operator delete(v24);
    }
    uint64_t v25 = v53;
    if (!v53) {
      goto LABEL_47;
    }
    unint64_t v26 = v54;
    int64_t v27 = v53;
    if (v54 == v53) {
      goto LABEL_46;
    }
    do
    {
      uint64_t v29 = *--v26;
      uint64_t v28 = v29;
      void *v26 = 0;
      if (v29) {
        MEMORY[0x21667D390](v28, 0x1000C8077774924);
      }
    }
    while (v26 != v25);
    goto LABEL_45;
  }
  uint64_t v8 = (void *)mlir::DictionaryAttr::get((uint64_t)&v44, "value", 5uLL);
  if (!v8)
  {
    a3(v48, a4);
    if (v48[0])
    {
      int v45 = 3;
      BOOL v46 = "expected key entry for value in DictionaryAttr to set Properties.";
      uint64_t v47 = 65;
      uint64_t v30 = &v45;
      uint64_t v31 = (char *)v49;
      if (v50 >= v51)
      {
        unint64_t v41 = v50 + 1;
        if (v49 <= &v45 && (char *)v49 + 24 * v50 > (char *)&v45)
        {
          int64_t v43 = (char *)&v45 - (unsigned char *)v49;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v41, 24);
          uint64_t v31 = (char *)v49;
          uint64_t v30 = (int *)((char *)v49 + v43);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v41, 24);
          uint64_t v30 = &v45;
          uint64_t v31 = (char *)v49;
        }
      }
      long long v32 = &v31[24 * v50];
      long long v33 = *(_OWORD *)v30;
      *((void *)v32 + 2) = *((void *)v30 + 2);
      *(_OWORD *)long long v32 = v33;
      ++v50;
      if (v48[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
      }
    }
    if (!v57) {
      return 0;
    }
    uint64_t v34 = __p;
    if (__p)
    {
      uint64_t v35 = v56;
      uint64_t v36 = __p;
      if (v56 != __p)
      {
        do
          uint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        uint64_t v36 = __p;
      }
      __int16 v56 = v34;
      operator delete(v36);
    }
    uint64_t v25 = v53;
    if (!v53)
    {
LABEL_47:
      if (v49 != v52) {
        free(v49);
      }
      return 0;
    }
    unint64_t v37 = v54;
    int64_t v27 = v53;
    if (v54 == v53)
    {
LABEL_46:
      uint64_t v54 = v25;
      operator delete(v27);
      goto LABEL_47;
    }
    do
    {
      uint64_t v39 = *--v37;
      uint64_t v38 = v39;
      void *v37 = 0;
      if (v39) {
        MEMORY[0x21667D390](v38, 0x1000C8077774924);
      }
    }
    while (v37 != v25);
LABEL_45:
    int64_t v27 = v53;
    goto LABEL_46;
  }
  uint64_t v9 = v8;
  uint64_t v10 = *(void **)(*v8 + 136);
  BOOL v11 = v10 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
  if (v10 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id) {
    int v12 = v8;
  }
  else {
    int v12 = 0;
  }
  v48[0] = v12;
  if (v11)
  {
    uint64_t v13 = v8[2];
    uint64_t Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)v48);
    uint64_t v16 = (pthread_rwlock_t **)(mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v15) + 48);
    llvm::sys::RWMutexImpl::lock(v16);
    ++*(void *)(v13 + 88);
    llvm::sys::RWMutexImpl::unlock_shared(v16);
  }
  *a1 = v9;
  return 1;
}

uint64_t mlir::mps::ConstantOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, mlir::MLIRContext *a2)
{
  v16[6] = *MEMORY[0x263EF8340];
  uint64_t v13 = a1;
  uint64_t v14 = v16;
  uint64_t v15 = 0x300000000;
  uint64_t v2 = *(void *)a2;
  if (!*(void *)a2) {
    uint64_t v2 = mlir::UnitAttr::get(a1, a2);
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v13, (uint64_t)"value", 5, v2);
  uint64_t v5 = v4;
  unsigned int v6 = v15;
  if (v15 >= HIDWORD(v15))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v14, v16, v15 + 1, 16);
    unsigned int v6 = v15;
  }
  uint64_t v7 = (uint64_t *)((char *)v14 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  BOOL v8 = __CFADD__(v15, 1);
  uint64_t v9 = (v15 + 1);
  LODWORD(v15) = v15 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    BOOL v11 = v14;
    if (v14 == v16) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v13, (uint64_t *)v14, v9);
  BOOL v11 = v14;
  if (v14 != v16) {
LABEL_10:
  }
    free(v11);
  return DictionaryAttr;
}

unint64_t mlir::mps::ConstantOp::computePropertiesHash(unint64_t *a1)
{
  unint64_t v1 = *a1;
  if (*(_UNKNOWN **)(*(void *)*a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
  {
    unint64_t v24 = llvm::hash_value(**(void ***)(v1 + 16), *(void *)(*(void *)(v1 + 16) + 8));
    unint64_t v5 = *(void *)(v1 + 40);
    {
      unint64_t v21 = v5;
      unint64_t v5 = v21;
      if (v18)
      {
        unint64_t v19 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v19 = 0xFF51AFD7ED558CCDLL;
        }
        llvm::hashing::detail::get_execution_seed(void)::seed = v19;
        unint64_t v5 = v21;
      }
    }
    unint64_t v6 = HIDWORD(v5);
    unint64_t v7 = 0x9DDFEA08EB382D69
       * ((llvm::hashing::detail::get_execution_seed(void)::seed + 8 * v5) ^ HIDWORD(v5));
    unint64_t v23 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
    unint64_t v8 = *(void *)(v1 + 8);
    {
      unint64_t v20 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v20 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v20;
    }
    unint64_t v9 = 0x9DDFEA08EB382D69
       * ((llvm::hashing::detail::get_execution_seed(void)::seed + 8 * v8) ^ HIDWORD(v8));
    unint64_t v10 = 0x9DDFEA08EB382D69 * (HIDWORD(v8) ^ (v9 >> 47) ^ v9);
    unint64_t v22 = 0x9DDFEA08EB382D69 * (v10 ^ (v10 >> 47));
    unint64_t v4 = llvm::hash_combine<llvm::hash_code,llvm::hash_code,llvm::hash_code>(&v24, (uint64_t *)&v23, (uint64_t *)&v22);
  }
  else
  {
    {
      unint64_t v17 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v17 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v17;
    }
    unint64_t v2 = 0x9DDFEA08EB382D69
       * ((llvm::hashing::detail::get_execution_seed(void)::seed + 8 * v1) ^ HIDWORD(v1));
    unint64_t v3 = 0x9DDFEA08EB382D69 * (HIDWORD(v1) ^ (v2 >> 47) ^ v2);
    unint64_t v4 = 0x9DDFEA08EB382D69 * (v3 ^ (v3 >> 47));
    {
LABEL_9:
      unint64_t v14 = v4;
      unint64_t v4 = v14;
      if (v15)
      {
        unint64_t v16 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v16 = 0xFF51AFD7ED558CCDLL;
        }
        llvm::hashing::detail::get_execution_seed(void)::seed = v16;
        unint64_t v4 = v14;
      }
    }
  }
  uint64_t v11 = llvm::hashing::detail::get_execution_seed(void)::seed ^ HIDWORD(v4);
  unint64_t v12 = 0x9DDFEA08EB382D69 * (v11 ^ (8 * v4 + 8));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v11 ^ (v12 >> 47) ^ v12)) ^ ((0x9DDFEA08EB382D69 * (v11 ^ (v12 >> 47) ^ v12)) >> 47));
}

uint64_t mlir::mps::ConstantOp::readProperties(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties>(a2);
  uint64_t v13 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, void **))(*(void *)a1 + 48))(a1, &v13)) {
    return 0;
  }
  unint64_t v4 = v13;
  if (v13)
  {
    unint64_t v5 = *(void **)(*v13 + 136);
    BOOL v6 = v5 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
    if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id) {
      unint64_t v7 = v13;
    }
    else {
      unint64_t v7 = 0;
    }
    unint64_t v14 = v7;
    if (v6)
    {
      uint64_t v8 = v13[2];
      uint64_t Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
      uint64_t v11 = (pthread_rwlock_t **)(mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v10) + 48);
      llvm::sys::RWMutexImpl::lock(v11);
      ++*(void *)(v8 + 88);
      llvm::sys::RWMutexImpl::unlock_shared(v11);
    }
  }
  *unint64_t v3 = v4;
  return 1;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

void mlir::mps::ConstantOp::build(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  v16[0] = a3;
  v16[1] = a4;
  if (a3)
  {
    BOOL v6 = *(void **)(*a3 + 136);
    BOOL v7 = v6 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
    uint64_t v8 = v6 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id ? a3 : 0;
    unint64_t v17 = v8;
    if (v7)
    {
      uint64_t v9 = a3[2];
      uint64_t Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v17);
      unint64_t v12 = (pthread_rwlock_t **)(mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v11) + 48);
      llvm::sys::RWMutexImpl::lock(v12);
      ++*(void *)(v9 + 88);
      llvm::sys::RWMutexImpl::unlock_shared(v12);
    }
  }
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>(a2) = a3;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v16);
  unint64_t v14 = Type;
  if (Type) {
    mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  }
  uint64_t v15 = *(unsigned int *)(a2 + 72);
  if (v15 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v15 + 1, 8);
    LODWORD(v15) = *(_DWORD *)(a2 + 72);
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v15) = v14;
  ++*(_DWORD *)(a2 + 72);
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

void mlir::mps::ConstantOp::build(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a4)
  {
    BOOL v7 = *(void **)(*a4 + 136);
    BOOL v8 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
    uint64_t v9 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id ? a4 : 0;
    uint64_t v15 = v9;
    if (v8)
    {
      uint64_t v11 = a4[2];
      uint64_t Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v15);
      unint64_t v14 = (pthread_rwlock_t **)(mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v13) + 48);
      llvm::sys::RWMutexImpl::lock(v14);
      ++*(void *)(v11 + 88);
      llvm::sys::RWMutexImpl::unlock_shared(v14);
      *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>(a2) = a4;
      uint64_t v10 = *(unsigned int *)(a2 + 72);
      if (v10 < *(_DWORD *)(a2 + 76)) {
        goto LABEL_8;
      }
      goto LABEL_7;
    }
  }
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>(a2) = a4;
  uint64_t v10 = *(unsigned int *)(a2 + 72);
  if (v10 >= *(_DWORD *)(a2 + 76))
  {
LABEL_7:
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v10 + 1, 8);
    LODWORD(v10) = *(_DWORD *)(a2 + 72);
  }
LABEL_8:
  *(void *)(*(void *)(a2 + 64) + 8 * v10) = a3;
  ++*(_DWORD *)(a2 + 72);
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps12(uint64_t a1, void **a2, void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v73 = *MEMORY[0x263EF8340];
  uint64_t v10 = *a2;
  uint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v63[0] = a2;
    v63[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v63);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)) {
      return 1;
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)) {
      return 1;
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)) {
      return 1;
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)) {
      return 1;
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)) {
      return 1;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)) {
      return 1;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)) {
      return 1;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
    if (mlir::Type::isF16((mlir::Type *)&OperandRange)) {
      return 1;
    }
    if (mlir::Type::isF32((mlir::Type *)&OperandRange)) {
      return 1;
    }
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange)) {
      return 1;
    }
    uint64_t v13 = *(void **)(*(void *)OperandRange + 136);
    if (v13 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id) {
      return 1;
    }
    if (v13 == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      uint64_t v58 = OperandRange;
      uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v58);
      if (mlir::Type::isF16((mlir::Type *)&Value)) {
        return 1;
      }
      uint64_t v56 = OperandRange;
      uint64_t v57 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v56);
      if (mlir::Type::isF32((mlir::Type *)&v57)) {
        return 1;
      }
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 2)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 4)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 1)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 2)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 4)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::mps::NF4Type,void>::id)
    {
      return 1;
    }
    uint64_t v10 = *a2;
    uint64_t v11 = (void *)*((void *)*a2 + 17);
  }
  if (v11 == &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
  {
    int64_t v53 = a2;
    uint64_t v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v53);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)) {
      return 1;
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)) {
      return 1;
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)) {
      return 1;
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)) {
      return 1;
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)) {
      return 1;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)) {
      return 1;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)) {
      return 1;
    }
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
    if (mlir::Type::isF16((mlir::Type *)&OperandRange)) {
      return 1;
    }
    if (mlir::Type::isF32((mlir::Type *)&OperandRange)) {
      return 1;
    }
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange)) {
      return 1;
    }
    unint64_t v41 = *(void **)(*(void *)OperandRange + 136);
    if (v41 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id) {
      return 1;
    }
    if (v41 == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      uint64_t v58 = OperandRange;
      uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v58);
      if (mlir::Type::isF16((mlir::Type *)&Value)) {
        return 1;
      }
      uint64_t v56 = OperandRange;
      uint64_t v57 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v56);
      if (mlir::Type::isF32((mlir::Type *)&v57)) {
        return 1;
      }
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 2)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 4)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 1)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 2)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 4)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::mps::NF4Type,void>::id)
    {
      return 1;
    }
  }
  __int16 v55 = 261;
  int64_t v53 = a3;
  uint64_t v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v63);
  if (v63[0])
  {
    LODWORD(OperandRange) = 3;
    unsigned int v61 = " #";
    uint64_t v62 = 2;
    p_uint64_t OperandRange = &OperandRange;
    uint64_t v15 = (char *)v64;
    if (v65 >= v66)
    {
      unint64_t v42 = v65 + 1;
      if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
      {
        int64_t v49 = (char *)&OperandRange - (unsigned char *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v42, 24);
        uint64_t v15 = (char *)v64;
        p_uint64_t OperandRange = (uint64_t *)((char *)v64 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v42, 24);
        p_uint64_t OperandRange = &OperandRange;
        uint64_t v15 = (char *)v64;
      }
    }
    unint64_t v16 = &v15[24 * v65];
    long long v17 = *(_OWORD *)p_OperandRange;
    *((void *)v16 + 2) = p_OperandRange[2];
    *(_OWORD *)unint64_t v16 = v17;
    uint64_t v18 = ++v65;
    if (v63[0])
    {
      LODWORD(OperandRange) = 5;
      unsigned int v61 = (const char *)a5;
      unint64_t v19 = &OperandRange;
      unint64_t v20 = (char *)v64;
      if (v18 >= v66)
      {
        unint64_t v43 = v18 + 1;
        BOOL v44 = (char *)v64 + 24 * v18 > (char *)&OperandRange;
        if (v64 <= &OperandRange && v44)
        {
          int64_t v50 = (char *)&OperandRange - (unsigned char *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v43, 24);
          unint64_t v20 = (char *)v64;
          unint64_t v19 = (uint64_t *)((char *)v64 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v43, 24);
          unint64_t v19 = &OperandRange;
          unint64_t v20 = (char *)v64;
        }
      }
      unint64_t v21 = &v20[24 * v65];
      long long v22 = *(_OWORD *)v19;
      *((void *)v21 + 2) = v19[2];
      *(_OWORD *)unint64_t v21 = v22;
      uint64_t v23 = ++v65;
      if (v63[0])
      {
        LODWORD(OperandRange) = 3;
        unsigned int v61 = " must be tensor of mps native type or complex or quantized values or memref of mps native type or complex "
              "or quantized values, but got ";
        uint64_t v62 = 135;
        unint64_t v24 = &OperandRange;
        uint64_t v25 = (char *)v64;
        if (v23 >= v66)
        {
          unint64_t v45 = v23 + 1;
          BOOL v46 = (char *)v64 + 24 * v23 > (char *)&OperandRange;
          if (v64 <= &OperandRange && v46)
          {
            int64_t v51 = (char *)&OperandRange - (unsigned char *)v64;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
            uint64_t v25 = (char *)v64;
            unint64_t v24 = (uint64_t *)((char *)v64 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
            unint64_t v24 = &OperandRange;
            uint64_t v25 = (char *)v64;
          }
        }
        unint64_t v26 = &v25[24 * v65];
        long long v27 = *(_OWORD *)v24;
        *((void *)v26 + 2) = v24[2];
        *(_OWORD *)unint64_t v26 = v27;
        ++v65;
        if (v63[0])
        {
          uint64_t v28 = &OperandRange;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, (uint64_t)a2);
          uint64_t v29 = (char *)v64;
          if (v65 >= v66)
          {
            unint64_t v47 = v65 + 1;
            if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
            {
              int64_t v52 = (char *)&OperandRange - (unsigned char *)v64;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
              uint64_t v29 = (char *)v64;
              uint64_t v28 = (uint64_t *)((char *)v64 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
              uint64_t v28 = &OperandRange;
              uint64_t v29 = (char *)v64;
            }
          }
          uint64_t v30 = &v29[24 * v65];
          long long v31 = *(_OWORD *)v28;
          *((void *)v30 + 2) = v28[2];
          *(_OWORD *)uint64_t v30 = v31;
          ++v65;
        }
      }
    }
  }
  uint64_t v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v63);
  if (v63[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
  }
  if (v72)
  {
    long long v33 = __p;
    if (__p)
    {
      uint64_t v34 = v71;
      uint64_t v35 = __p;
      if (v71 != __p)
      {
        do
          uint64_t v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
        while (v34 != v33);
        uint64_t v35 = __p;
      }
      uint64_t v71 = v33;
      operator delete(v35);
    }
    uint64_t v36 = v68;
    if (v68)
    {
      unint64_t v37 = v69;
      uint64_t v38 = v68;
      if (v69 != v68)
      {
        do
        {
          uint64_t v40 = *--v37;
          uint64_t v39 = v40;
          void *v37 = 0;
          if (v40) {
            MEMORY[0x21667D390](v39, 0x1000C8077774924);
          }
        }
        while (v37 != v36);
        uint64_t v38 = v68;
      }
      uint64_t v69 = v36;
      operator delete(v38);
    }
    if (v64 != v67) {
      free(v64);
    }
  }
  return v32;
}

void mlir::mps::ConstantOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Conv2DDataGradientOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v5;
  long long v9 = *(_OWORD *)(v5 + 16);
  long long v10 = *(_OWORD *)(v5 + 32);
  *(void *)(a1 + 72) = *(void *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.conv_2d_data_gradient", 25, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::Conv2DDataGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v123 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v109 = v6;
  if (!v6)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      uint64_t v111 = "expected DictionaryAttr to set properties";
      uint64_t v112 = 41;
      unint64_t v26 = &v110;
      long long v27 = (char *)v114;
      if (v115 >= v116)
      {
        unint64_t v92 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          int64_t v100 = (char *)&v110 - (unsigned char *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v92, 24);
          long long v27 = (char *)v114;
          unint64_t v26 = (uint64_t *)((char *)v114 + v100);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v92, 24);
          unint64_t v26 = &v110;
          long long v27 = (char *)v114;
        }
      }
      uint64_t v28 = &v27[24 * v115];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)uint64_t v28 = v29;
      ++v115;
      if (v113[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
      }
    }
    if (!v122) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      long long v31 = v121;
      uint64_t v32 = __p;
      if (v121 != __p)
      {
        do
          long long v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        uint64_t v32 = __p;
      }
      char v121 = v30;
      operator delete(v32);
    }
    unint64_t v21 = v118;
    if (!v118) {
      goto LABEL_117;
    }
    long long v33 = v119;
    uint64_t v23 = v118;
    if (v119 == v118)
    {
LABEL_116:
      unint64_t v119 = v21;
      operator delete(v23);
LABEL_117:
      if (v114 != v117) {
        free(v114);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *long long v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
LABEL_115:
    uint64_t v23 = v118;
    goto LABEL_116;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v109, "data_layout", 0xBuLL);
  if (!v8)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      uint64_t v111 = "expected key entry for data_layout in DictionaryAttr to set Properties.";
      uint64_t v112 = 71;
      uint64_t v36 = &v110;
      unint64_t v37 = (char *)v114;
      if (v115 >= v116)
      {
        unint64_t v94 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          int64_t v102 = (char *)&v110 - (unsigned char *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v94, 24);
          unint64_t v37 = (char *)v114;
          uint64_t v36 = (uint64_t *)((char *)v114 + v102);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v94, 24);
          uint64_t v36 = &v110;
          unint64_t v37 = (char *)v114;
        }
      }
      uint64_t v38 = &v37[24 * v115];
      long long v39 = *(_OWORD *)v36;
      *((void *)v38 + 2) = v36[2];
      *(_OWORD *)uint64_t v38 = v39;
      ++v115;
      if (v113[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
      }
    }
    if (!v122) {
      return 0;
    }
    uint64_t v40 = __p;
    if (__p)
    {
      unint64_t v41 = v121;
      unint64_t v42 = __p;
      if (v121 != __p)
      {
        do
          unint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        unint64_t v42 = __p;
      }
      char v121 = v40;
      operator delete(v42);
    }
    unint64_t v21 = v118;
    if (!v118) {
      goto LABEL_117;
    }
    unint64_t v43 = v119;
    uint64_t v23 = v118;
    if (v119 == v118) {
      goto LABEL_116;
    }
    do
    {
      uint64_t v45 = *--v43;
      uint64_t v44 = v45;
      void *v43 = 0;
      if (v45) {
        MEMORY[0x21667D390](v44, 0x1000C8077774924);
      }
    }
    while (v43 != v21);
    goto LABEL_115;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      uint64_t v112 = 56;
      long long v10 = &v110;
      uint64_t v11 = (char *)v114;
      if (v115 >= v116)
      {
        unint64_t v93 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          int64_t v101 = (char *)&v110 - (unsigned char *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v93, 24);
          uint64_t v11 = (char *)v114;
          long long v10 = (uint64_t *)((char *)v114 + v101);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v93, 24);
          long long v10 = &v110;
          uint64_t v11 = (char *)v114;
        }
      }
      unint64_t v12 = &v11[24 * v115];
      long long v13 = *(_OWORD *)v10;
      *((void *)v12 + 2) = v10[2];
      *(_OWORD *)unint64_t v12 = v13;
      ++v115;
      if (v113[0])
      {
        uint64_t v14 = &v110;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v110, v9);
        uint64_t v15 = (char *)v114;
        if (v115 >= v116)
        {
          unint64_t v95 = v115 + 1;
          if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
          {
            int64_t v103 = (char *)&v110 - (unsigned char *)v114;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v95, 24);
            uint64_t v15 = (char *)v114;
            uint64_t v14 = (uint64_t *)((char *)v114 + v103);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v95, 24);
            uint64_t v14 = &v110;
            uint64_t v15 = (char *)v114;
          }
        }
        unint64_t v16 = &v15[24 * v115];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = v14[2];
        *(_OWORD *)unint64_t v16 = v17;
        ++v115;
        if (v113[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
        }
      }
    }
    if (!v122) {
      return 0;
    }
    uint64_t v18 = __p;
    if (__p)
    {
      unint64_t v19 = v121;
      unint64_t v20 = __p;
      if (v121 != __p)
      {
        do
          unint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        unint64_t v20 = __p;
      }
      char v121 = v18;
      operator delete(v20);
    }
    unint64_t v21 = v118;
    if (!v118) {
      goto LABEL_117;
    }
    long long v22 = v119;
    uint64_t v23 = v118;
    if (v119 == v118) {
      goto LABEL_116;
    }
    do
    {
      uint64_t v25 = *--v22;
      uint64_t v24 = v25;
      void *v22 = 0;
      if (v25) {
        MEMORY[0x21667D390](v24, 0x1000C8077774924);
      }
    }
    while (v22 != v21);
    goto LABEL_115;
  }
  *a1 = v8;
  uint64_t v46 = mlir::DictionaryAttr::get((uint64_t)&v109, "dilation_rates", 0xEuLL);
  if (!v46)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      uint64_t v111 = "expected key entry for dilation_rates in DictionaryAttr to set Properties.";
      uint64_t v112 = 74;
      int64_t v52 = &v110;
      int64_t v53 = (char *)v114;
      if (v115 >= v116)
      {
        unint64_t v96 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          int64_t v104 = (char *)&v110 - (unsigned char *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v96, 24);
          int64_t v53 = (char *)v114;
          int64_t v52 = (uint64_t *)((char *)v114 + v104);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v96, 24);
          int64_t v52 = &v110;
          int64_t v53 = (char *)v114;
        }
      }
      uint64_t v54 = &v53[24 * v115];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = v52[2];
      *(_OWORD *)uint64_t v54 = v55;
      ++v115;
      if (v113[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
      }
    }
    if (!v122) {
      return 0;
    }
    uint64_t v56 = __p;
    if (__p)
    {
      uint64_t v57 = v121;
      uint64_t v58 = __p;
      if (v121 != __p)
      {
        do
          uint64_t v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        uint64_t v58 = __p;
      }
      char v121 = v56;
      operator delete(v58);
    }
    unint64_t v21 = v118;
    if (!v118) {
      goto LABEL_117;
    }
    uint64_t v59 = v119;
    uint64_t v23 = v118;
    if (v119 == v118) {
      goto LABEL_116;
    }
    do
    {
      uint64_t v61 = *--v59;
      uint64_t v60 = v61;
      *uint64_t v59 = 0;
      if (v61) {
        MEMORY[0x21667D390](v60, 0x1000C8077774924);
      }
    }
    while (v59 != v21);
    goto LABEL_115;
  }
  uint64_t v47 = v46;
  if ((mlir::DenseIntElementsAttr::classof(v46) & 1) == 0)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      uint64_t v112 = 59;
      uint64_t v62 = &v110;
      unsigned int v63 = (char *)v114;
      if (v115 >= v116)
      {
        unint64_t v97 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          int64_t v105 = (char *)&v110 - (unsigned char *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v97, 24);
          unsigned int v63 = (char *)v114;
          uint64_t v62 = (uint64_t *)((char *)v114 + v105);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v97, 24);
          uint64_t v62 = &v110;
          unsigned int v63 = (char *)v114;
        }
      }
      unsigned int v64 = &v63[24 * v115];
      long long v65 = *(_OWORD *)v62;
      *((void *)v64 + 2) = v62[2];
      *(_OWORD *)unsigned int v64 = v65;
      ++v115;
      if (v113[0])
      {
        unsigned int v66 = &v110;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v110, v47);
        uint64_t v67 = (char *)v114;
        if (v115 >= v116)
        {
          unint64_t v98 = v115 + 1;
          if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
          {
            int64_t v106 = (char *)&v110 - (unsigned char *)v114;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v98, 24);
            uint64_t v67 = (char *)v114;
            unsigned int v66 = (uint64_t *)((char *)v114 + v106);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v98, 24);
            unsigned int v66 = &v110;
            uint64_t v67 = (char *)v114;
          }
        }
        long long v68 = &v67[24 * v115];
        long long v69 = *(_OWORD *)v66;
        *((void *)v68 + 2) = v66[2];
        *(_OWORD *)long long v68 = v69;
        ++v115;
        if (v113[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
        }
      }
    }
    if (!v122) {
      return 0;
    }
    char v70 = __p;
    if (__p)
    {
      uint64_t v71 = v121;
      char v72 = __p;
      if (v121 != __p)
      {
        do
          uint64_t v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
        while (v71 != v70);
        char v72 = __p;
      }
      char v121 = v70;
      operator delete(v72);
    }
    unint64_t v21 = v118;
    if (!v118) {
      goto LABEL_117;
    }
    uint64_t v73 = v119;
    uint64_t v23 = v118;
    if (v119 == v118) {
      goto LABEL_116;
    }
    do
    {
      uint64_t v75 = *--v73;
      uint64_t v74 = v75;
      *uint64_t v73 = 0;
      if (v75) {
        MEMORY[0x21667D390](v74, 0x1000C8077774924);
      }
    }
    while (v73 != v21);
    goto LABEL_115;
  }
  a1[1] = v47;
  uint64_t v48 = mlir::DictionaryAttr::get((uint64_t)&v109, "explicit_padding", 0x10uLL);
  uint64_t v108 = v48;
  if (!v48)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      uint64_t v111 = "expected key entry for explicit_padding in DictionaryAttr to set Properties.";
      uint64_t v112 = 76;
      unint64_t v76 = &v110;
      uint64_t v77 = (char *)v114;
      if (v115 >= v116)
      {
        unint64_t v99 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          int64_t v107 = (char *)&v110 - (unsigned char *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v99, 24);
          uint64_t v77 = (char *)v114;
          unint64_t v76 = (uint64_t *)((char *)v114 + v107);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v99, 24);
          unint64_t v76 = &v110;
          uint64_t v77 = (char *)v114;
        }
      }
      uint64_t v78 = &v77[24 * v115];
      long long v79 = *(_OWORD *)v76;
      *((void *)v78 + 2) = v76[2];
      *(_OWORD *)uint64_t v78 = v79;
      ++v115;
      if (v113[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
      }
    }
    if (!v122) {
      return 0;
    }
    int64_t v80 = __p;
    if (__p)
    {
      int64_t v81 = v121;
      long long v82 = __p;
      if (v121 != __p)
      {
        do
          int64_t v81 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v81 - 1);
        while (v81 != v80);
        long long v82 = __p;
      }
      char v121 = v80;
      operator delete(v82);
    }
    unint64_t v21 = v118;
    if (!v118) {
      goto LABEL_117;
    }
    int64_t v83 = v119;
    uint64_t v23 = v118;
    if (v119 == v118) {
      goto LABEL_116;
    }
    do
    {
      uint64_t v85 = *--v83;
      uint64_t v84 = v85;
      *int64_t v83 = 0;
      if (v85) {
        MEMORY[0x21667D390](v84, 0x1000C8077774924);
      }
    }
    while (v83 != v21);
    goto LABEL_115;
  }
  uint64_t v49 = v48;
  if (mlir::DenseIntElementsAttr::classof(v48))
  {
    a1[2] = v49;
    uint64_t v50 = mlir::DictionaryAttr::get((uint64_t)&v109, "groups", 6uLL);
    uint64_t v110 = v50;
    if (v50)
    {
      if (*(_UNKNOWN **)(*(void *)v50 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        a1[3] = v50;
        uint64_t v88 = mlir::DictionaryAttr::get((uint64_t)&v109, "padding_style", 0xDuLL);
        uint64_t v110 = v88;
        if (!v88)
        {
          a3(v113, a4);
          mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v113, "expected key entry for padding_style in DictionaryAttr to set Properties.");
          goto LABEL_123;
        }
        if (*(_UNKNOWN **)(*(void *)v88 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
        {
          a1[4] = v88;
          uint64_t v89 = mlir::DictionaryAttr::get((uint64_t)&v109, "strides", 7uLL);
          uint64_t v110 = v89;
          if (!v89)
          {
            a3(v113, a4);
            mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v113, "expected key entry for strides in DictionaryAttr to set Properties.");
            goto LABEL_123;
          }
          uint64_t v90 = v89;
          if (mlir::DenseIntElementsAttr::classof(v89))
          {
            a1[5] = v90;
            uint64_t v91 = mlir::DictionaryAttr::get((uint64_t)&v109, "weights_layout", 0xEuLL);
            uint64_t v110 = v91;
            if (!v91)
            {
              a3(v113, a4);
              mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v113, "expected key entry for weights_layout in DictionaryAttr to set Properties.");
              goto LABEL_123;
            }
            if (*(_UNKNOWN **)(*(void *)v91 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            {
              a1[6] = v91;
              return 1;
            }
            a3(v113, a4);
          }
          else
          {
            a3(v113, a4);
          }
        }
        else
        {
          a3(v113, a4);
        }
      }
      else
      {
        a3(v113, a4);
      }
      mlir::InFlightDiagnostic::append<mlir::Attribute>(v51, &v110);
    }
    else
    {
      a3(v113, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v113, "expected key entry for groups in DictionaryAttr to set Properties.");
    }
LABEL_123:
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v113);
    return 0;
  }
  a3(v113, a4);
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v87, &v108);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v113);
  return 0;
}

uint64_t mlir::mps::Conv2DDataGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v51[6] = *MEMORY[0x263EF8340];
  uint64_t v48 = a1;
  uint64_t v49 = v51;
  uint64_t v50 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v48, (uint64_t)"data_layout", 11, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v50;
  if (v50 >= HIDWORD(v50))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
    unsigned int v6 = v50;
  }
  uint64_t v7 = (uint64_t *)((char *)v49 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v50 + 1;
  LODWORD(v50) = v50 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"dilation_rates", 14, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v13 = v50;
    }
    uint64_t v14 = (uint64_t *)((char *)v49 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"explicit_padding", 16, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v19 = v50;
    }
    unint64_t v20 = (uint64_t *)((char *)v49 + 16 * v19);
    uint64_t *v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"groups", 6, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v25 = v50;
    }
    unint64_t v26 = (uint64_t *)((char *)v49 + 16 * v25);
    uint64_t *v26 = v22;
    v26[1] = v24;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"padding_style", 13, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v31 = v50;
    }
    uint64_t v32 = (uint64_t *)((char *)v49 + 16 * v31);
    uint64_t *v32 = v28;
    v32[1] = v30;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v33 = a2[5];
  if (v33)
  {
    uint64_t v34 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"strides", 7, v33);
    uint64_t v36 = v35;
    unsigned int v37 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v37 = v50;
    }
    uint64_t v38 = (uint64_t *)((char *)v49 + 16 * v37);
    uint64_t *v38 = v34;
    v38[1] = v36;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v39 = a2[6];
  if (v39)
  {
    uint64_t v40 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"weights_layout", 14, v39);
    uint64_t v42 = v41;
    unsigned int v43 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v43 = v50;
    }
    uint64_t v44 = (uint64_t *)((char *)v49 + 16 * v43);
    uint64_t *v44 = v40;
    v44[1] = v42;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v45 = v49;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v49 == v51) {
      return DictionaryAttr;
    }
    goto LABEL_32;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v48, (uint64_t *)v49, v8);
  uint64_t v45 = v49;
  if (v49 != v51) {
LABEL_32:
  }
    free(v45);
  return DictionaryAttr;
}

unint64_t mlir::mps::Conv2DDataGradientOp::computePropertiesHash(unint64_t *a1)
{
  uint64_t v84 = *MEMORY[0x263EF8340];
  unint64_t v1 = *a1;
  unint64_t v2 = &unk_267770000;
  {
    int64_t v52 = a1;
    unint64_t v66 = v1;
    unint64_t v1 = v66;
    unint64_t v2 = &unk_267770000;
    int v26 = v25;
    a1 = v52;
    if (v26)
    {
      unint64_t v27 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v27 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v27;
      unint64_t v1 = v66;
      unint64_t v2 = (void *)&unk_267770000;
      a1 = v52;
    }
  }
  uint64_t v3 = v2[385];
  unint64_t v4 = a1[1];
  {
    int64_t v53 = a1;
    uint64_t v59 = v3;
    unint64_t v67 = v1;
    unint64_t v47 = v4;
    uint64_t v3 = v59;
    unint64_t v1 = v67;
    unint64_t v2 = &unk_267770000;
    int v29 = v28;
    unint64_t v4 = v47;
    a1 = v53;
    if (v29)
    {
      unint64_t v30 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v30 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v30;
      unint64_t v4 = v47;
      a1 = v53;
      uint64_t v3 = v59;
      unint64_t v1 = v67;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v5 = HIDWORD(v4);
  unint64_t v6 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v4) ^ HIDWORD(v4));
  unint64_t v79 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) ^ ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) >> 47));
  unint64_t v7 = a1[2];
  {
    uint64_t v54 = a1;
    uint64_t v60 = v3;
    unint64_t v68 = v1;
    unint64_t v48 = v7;
    uint64_t v3 = v60;
    unint64_t v1 = v68;
    unint64_t v2 = &unk_267770000;
    int v32 = v31;
    unint64_t v7 = v48;
    a1 = v54;
    if (v32)
    {
      unint64_t v33 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v33 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v33;
      unint64_t v7 = v48;
      a1 = v54;
      uint64_t v3 = v60;
      unint64_t v1 = v68;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v8 = HIDWORD(v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v7) ^ HIDWORD(v7));
  unint64_t v78 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
  unint64_t v10 = a1[3];
  {
    long long v55 = a1;
    uint64_t v61 = v3;
    unint64_t v69 = v1;
    unint64_t v49 = v10;
    uint64_t v3 = v61;
    unint64_t v1 = v69;
    unint64_t v2 = &unk_267770000;
    int v35 = v34;
    unint64_t v10 = v49;
    a1 = v55;
    if (v35)
    {
      unint64_t v36 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v36 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v36;
      unint64_t v10 = v49;
      a1 = v55;
      uint64_t v3 = v61;
      unint64_t v1 = v69;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v11 = HIDWORD(v10);
  unint64_t v12 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v10) ^ HIDWORD(v10));
  unint64_t v77 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v11 ^ (v12 >> 47) ^ v12)) ^ ((0x9DDFEA08EB382D69 * (v11 ^ (v12 >> 47) ^ v12)) >> 47));
  unint64_t v13 = a1[4];
  {
    uint64_t v56 = a1;
    uint64_t v62 = v3;
    unint64_t v70 = v1;
    unint64_t v50 = v13;
    uint64_t v3 = v62;
    unint64_t v1 = v70;
    unint64_t v2 = &unk_267770000;
    int v38 = v37;
    unint64_t v13 = v50;
    a1 = v56;
    if (v38)
    {
      unint64_t v39 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v39 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v39;
      unint64_t v13 = v50;
      a1 = v56;
      uint64_t v3 = v62;
      unint64_t v1 = v70;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v14 = HIDWORD(v13);
  unint64_t v15 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v13) ^ HIDWORD(v13));
  unint64_t v76 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v14 ^ (v15 >> 47) ^ v15)) ^ ((0x9DDFEA08EB382D69 * (v14 ^ (v15 >> 47) ^ v15)) >> 47));
  unint64_t v16 = a1[5];
  {
    uint64_t v57 = a1;
    uint64_t v63 = v3;
    unint64_t v71 = v1;
    unint64_t v51 = v16;
    uint64_t v3 = v63;
    unint64_t v1 = v71;
    unint64_t v2 = &unk_267770000;
    int v41 = v40;
    unint64_t v16 = v51;
    a1 = v57;
    if (v41)
    {
      unint64_t v42 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v42 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v42;
      unint64_t v16 = v51;
      a1 = v57;
      uint64_t v3 = v63;
      unint64_t v1 = v71;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v17 = HIDWORD(v16);
  unint64_t v18 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v16) ^ HIDWORD(v16));
  unint64_t v75 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v17 ^ (v18 >> 47) ^ v18)) ^ ((0x9DDFEA08EB382D69 * (v17 ^ (v18 >> 47) ^ v18)) >> 47));
  unint64_t v19 = a1[6];
  {
    uint64_t v64 = v3;
    unint64_t v72 = v1;
    unint64_t v58 = v19;
    unint64_t v19 = v58;
    uint64_t v3 = v64;
    unint64_t v1 = v72;
    unint64_t v2 = &unk_267770000;
    if (v43)
    {
      unint64_t v44 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v44 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v44;
      unint64_t v19 = v58;
      uint64_t v3 = v64;
      unint64_t v1 = v72;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v20 = HIDWORD(v19);
  unint64_t v21 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v19) ^ HIDWORD(v19));
  unint64_t v74 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v20 ^ (v21 >> 47) ^ v21)) ^ ((0x9DDFEA08EB382D69 * (v20 ^ (v21 >> 47) ^ v21)) >> 47));
  uint64_t v82 = 0;
  memset(v81, 0, sizeof(v81));
  memset(v80, 0, sizeof(v80));
  {
    uint64_t v65 = v3;
    unint64_t v73 = v1;
    uint64_t v3 = v65;
    unint64_t v1 = v73;
    unint64_t v2 = &unk_267770000;
    if (v45)
    {
      unint64_t v46 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v46 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v46;
      uint64_t v3 = v65;
      unint64_t v1 = v73;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v22 = HIDWORD(v1);
  unint64_t v23 = 0x9DDFEA08EB382D69 * ((v3 + 8 * v1) ^ HIDWORD(v1));
  uint64_t v83 = v2[385];
  *(void *)&v80[0] = 0x9DDFEA08EB382D69
                     * ((0x9DDFEA08EB382D69 * (v22 ^ (v23 >> 47) ^ v23)) ^ ((0x9DDFEA08EB382D69
                                                                             * (v22 ^ (v23 >> 47) ^ v23)) >> 47));
  return llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>((llvm::hashing::detail::hash_combine_recursive_helper *)v80, 0, (void *)v80 + 1, (char *)v81, (uint64_t *)&v79, (uint64_t *)&v78, (uint64_t *)&v77, (uint64_t *)&v76, (uint64_t *)&v75, (uint64_t *)&v74);
}

uint64_t mlir::mps::Conv2DDataGradientOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n)) {
        return 0;
      }
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n)) {
        return a2[1];
      }
      if (memcmp(__s1, "weights_layout", __n)) {
        return 0;
      }
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv2DDataGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  unint64_t v7 = (void *)result;
  switch(__n)
  {
    case 6uLL:
      uint64_t result = memcmp(__s1, "groups", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v14 = a4;
          }
          else {
            uint64_t v14 = 0;
          }
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          *(void *)uint64_t result = v10;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "weights_layout", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
              uint64_t v12 = a4;
            }
            else {
              uint64_t v12 = 0;
            }
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v15 = a4;
        }
        else {
          uint64_t v15 = 0;
        }
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v13 = a4;
          }
          else {
            uint64_t v13 = 0;
          }
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::Conv2DDataGradientOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"data_layout", 11, *a2);
  }
  uint64_t v5 = a2[1];
  if (v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"dilation_rates", 14, v5);
  }
  uint64_t v6 = a2[2];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"explicit_padding", 16, v6);
  }
  uint64_t v7 = a2[3];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"groups", 6, v7);
  }
  uint64_t v8 = a2[4];
  if (v8) {
    mlir::NamedAttrList::append(a3, (uint64_t)"padding_style", 13, v8);
  }
  uint64_t v9 = a2[5];
  if (v9) {
    mlir::NamedAttrList::append(a3, (uint64_t)"strides", 7, v9);
  }
  uint64_t v10 = a2[6];
  if (v10)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"weights_layout", 14, v10);
  }
}

BOOL mlir::mps::Conv2DDataGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v8, (void **)"data_layout", (const char *)0xB, a3, a4))
  {
    uint64_t v9 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))a3, a4))
    {
      uint64_t v10 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v10, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))a3, a4))
      {
        uint64_t v11 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v11, (void **)"groups", (const char *)6, a3, a4))
        {
          uint64_t v12 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v12, (void **)"padding_style", (const char *)0xD, a3, a4))
          {
            uint64_t v13 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v13, (void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))a3, a4))
            {
              uint64_t v14 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v14, (void **)"weights_layout", (const char *)0xE, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(uint64_t a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    unint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      int v29 = a2;
      unint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        unint64_t v30 = "' failed to satisfy constraint: valid TensorDataLayout";
        uint64_t v31 = 54;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    unint64_t v16 = __p;
    if (__p)
    {
      unint64_t v17 = v42;
      unint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          unint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        unint64_t v18 = __p;
      }
      unint64_t v42 = v16;
      operator delete(v18);
    }
    unint64_t v19 = v39;
    if (v39)
    {
      unint64_t v20 = v40;
      unint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        unint64_t v21 = v39;
      }
      int v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(void **a1, void **a2, const char *a3, void (*a4)(void **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1)) {
    goto LABEL_9;
  }
  uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  int v41 = a1;
  unint64_t v42 = (const char *)v10;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v41);
  uint64_t v12 = Type;
  if (Type) {
    Type = (void *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  }
  int v45 = v12;
  unint64_t v46 = Type;
  Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v45);
  uint64_t v56 = 4;
  if (v14 == 1 && *Shape == v56)
  {
    int v38 = a1;
    v39[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v38);
    v39[1] = v15;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v39);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
  }
LABEL_9:
  a4(&v45, a5);
  if (v45)
  {
    LODWORD(v41) = 3;
    unint64_t v42 = "attribute '";
    uint64_t v43 = 11;
    unint64_t v17 = &v41;
    unint64_t v18 = (char *)v47;
    if (v48 >= v49)
    {
      unint64_t v34 = v48 + 1;
      if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
      {
        int64_t v36 = (char *)&v41 - (unsigned char *)v47;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        unint64_t v18 = (char *)v47;
        unint64_t v17 = (void ***)((char *)v47 + v36);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        unint64_t v17 = &v41;
        unint64_t v18 = (char *)v47;
      }
    }
    unint64_t v19 = &v18[24 * v48];
    long long v20 = *(_OWORD *)v17;
    *((void *)v19 + 2) = v17[2];
    *(_OWORD *)unint64_t v19 = v20;
    ++v48;
    if (v45)
    {
      __int16 v44 = 261;
      int v41 = a2;
      unint64_t v42 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
      if (v45)
      {
        LODWORD(v41) = 3;
        unint64_t v42 = "' failed to satisfy constraint: ui64 elements attribute of shape {4}";
        uint64_t v43 = 68;
        unint64_t v21 = &v41;
        uint64_t v22 = (char *)v47;
        if (v48 >= v49)
        {
          unint64_t v35 = v48 + 1;
          if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
          {
            int64_t v37 = (char *)&v41 - (unsigned char *)v47;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            uint64_t v22 = (char *)v47;
            unint64_t v21 = (void ***)((char *)v47 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            unint64_t v21 = &v41;
            uint64_t v22 = (char *)v47;
          }
        }
        uint64_t v23 = &v22[24 * v48];
        long long v24 = *(_OWORD *)v21;
        *((void *)v23 + 2) = v21[2];
        *(_OWORD *)uint64_t v23 = v24;
        ++v48;
      }
    }
  }
  uint64_t v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v45);
  if (v45) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v45);
  }
  if (v55)
  {
    unint64_t v25 = __p;
    if (__p)
    {
      unint64_t v26 = v54;
      int64_t v27 = __p;
      if (v54 != __p)
      {
        do
          unint64_t v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        int64_t v27 = __p;
      }
      uint64_t v54 = v25;
      operator delete(v27);
    }
    int64_t v28 = v51;
    if (v51)
    {
      int v29 = v52;
      unint64_t v30 = v51;
      if (v52 != v51)
      {
        do
        {
          uint64_t v32 = *--v29;
          uint64_t v31 = v32;
          *int v29 = 0;
          if (v32) {
            MEMORY[0x21667D390](v31, 0x1000C8077774924);
          }
        }
        while (v29 != v28);
        unint64_t v30 = v51;
      }
      int64_t v52 = v28;
      operator delete(v30);
    }
    if (v47 != v50) {
      free(v47);
    }
  }
  return v16;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(void **a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  if (*((_UNKNOWN **)*a1 + 17) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    uint64_t v31 = a1;
    uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v31);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 64)) {
      return 1;
    }
  }
  a4(&Value, a5);
  if (Value)
  {
    LODWORD(v31) = 3;
    uint64_t v32 = "attribute '";
    uint64_t v33 = 11;
    uint64_t v10 = &v31;
    uint64_t v11 = (char *)v37;
    if (v38 >= v39)
    {
      unint64_t v27 = v38 + 1;
      if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
      {
        int64_t v29 = (char *)&v31 - (unsigned char *)v37;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        uint64_t v11 = (char *)v37;
        uint64_t v10 = (void ***)((char *)v37 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        uint64_t v10 = &v31;
        uint64_t v11 = (char *)v37;
      }
    }
    uint64_t v12 = &v11[24 * v38];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = v10[2];
    *(_OWORD *)uint64_t v12 = v13;
    ++v38;
    if (Value)
    {
      __int16 v34 = 261;
      uint64_t v31 = a2;
      uint64_t v32 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v36, &v31);
      if (Value)
      {
        LODWORD(v31) = 3;
        uint64_t v32 = "' failed to satisfy constraint: 64-bit unsigned integer attribute";
        uint64_t v33 = 65;
        uint64_t v14 = &v31;
        uint64_t v15 = (char *)v37;
        if (v38 >= v39)
        {
          unint64_t v28 = v38 + 1;
          if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
          {
            int64_t v30 = (char *)&v31 - (unsigned char *)v37;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            uint64_t v15 = (char *)v37;
            uint64_t v14 = (void ***)((char *)v37 + v30);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            uint64_t v14 = &v31;
            uint64_t v15 = (char *)v37;
          }
        }
        uint64_t v16 = &v15[24 * v38];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = v14[2];
        *(_OWORD *)uint64_t v16 = v17;
        ++v38;
      }
    }
  }
  uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  if (v45)
  {
    unint64_t v18 = __p;
    if (__p)
    {
      unint64_t v19 = v44;
      long long v20 = __p;
      if (v44 != __p)
      {
        do
          unint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        long long v20 = __p;
      }
      __int16 v44 = v18;
      operator delete(v20);
    }
    unint64_t v21 = v41;
    if (v41)
    {
      uint64_t v22 = v42;
      uint64_t v23 = v41;
      if (v42 != v41)
      {
        do
        {
          uint64_t v25 = *--v22;
          uint64_t v24 = v25;
          void *v22 = 0;
          if (v25) {
            MEMORY[0x21667D390](v24, 0x1000C8077774924);
          }
        }
        while (v22 != v21);
        uint64_t v23 = v41;
      }
      unint64_t v42 = v21;
      operator delete(v23);
    }
    if (v37 != v40) {
      free(v37);
    }
  }
  return v9;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(uint64_t a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    int64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      int64_t v29 = a2;
      int64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        int64_t v30 = "' failed to satisfy constraint: valid padding_style";
        uint64_t v31 = 51;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        long long v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)long long v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = __p;
    if (__p)
    {
      long long v17 = v42;
      unint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          long long v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        unint64_t v18 = __p;
      }
      unint64_t v42 = v16;
      operator delete(v18);
    }
    unint64_t v19 = v39;
    if (v39)
    {
      long long v20 = v40;
      unint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        unint64_t v21 = v39;
      }
      int v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

BOOL mlir::mps::Conv2DDataGradientOp::readProperties(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  uint64_t v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    uint64_t v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        uint64_t v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  int v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::PaddingStyleAttr]";
  unint64_t v41 = 77;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    int v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      long long v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          long long v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        unint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unint64_t v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unint64_t v19 = (char *)v46;
            unint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unint64_t v18 = &v40;
            unint64_t v19 = (char *)v46;
          }
        }
        long long v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)long long v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      uint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      int64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      unint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

uint64_t *mlir::mps::Conv2DDataGradientOp::getGroups(mlir::mps::Conv2DDataGradientOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  uint64_t v6 = *(void *)(v1 + 24);
  mlir::IntegerAttr::getValue((uint64_t)&v6, (llvm::APInt *)&v4);
  if (v5 <= 0x40) {
    return v4;
  }
  uint64_t v3 = *v4;
  MEMORY[0x21667D390]();
  return (uint64_t *)v3;
}

BOOL mlir::mps::Conv2DDataGradientOp::verifyInvariantsImpl(mlir::mps::Conv2DDataGradientOp *this)
{
  uint64_t v76 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  if (!*v3)
  {
    v66[0] = (void **)"requires attribute 'data_layout'";
    __int16 v67 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v66, (uint64_t)v68);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    }
    if (!v75) {
      return v27;
    }
    int64_t v28 = __p;
    if (__p)
    {
      uint64_t v29 = v74;
      uint64_t v30 = __p;
      if (v74 != __p)
      {
        do
          uint64_t v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
        while (v29 != v28);
        uint64_t v30 = __p;
      }
      unint64_t v74 = v28;
      operator delete(v30);
    }
    uint64_t v31 = v71;
    if (v71)
    {
      unint64_t v32 = v72;
      unint64_t v33 = v71;
      if (v72 == v71) {
        goto LABEL_97;
      }
      do
      {
        uint64_t v35 = *--v32;
        uint64_t v34 = v35;
        void *v32 = 0;
        if (v35) {
          MEMORY[0x21667D390](v34, 0x1000C8077774924);
        }
      }
      while (v32 != v31);
LABEL_96:
      unint64_t v33 = v71;
LABEL_97:
      unint64_t v72 = v31;
      operator delete(v33);
    }
LABEL_98:
    if (v69 != &v70) {
      free(v69);
    }
    return v27;
  }
  unsigned int v5 = (void **)v3[1];
  if (!v5)
  {
    v66[0] = (void **)"requires attribute 'dilation_rates'";
    __int16 v67 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v66, (uint64_t)v68);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    }
    if (!v75) {
      return v27;
    }
    int64_t v36 = __p;
    if (__p)
    {
      int64_t v37 = v74;
      unsigned int v38 = __p;
      if (v74 != __p)
      {
        do
          int64_t v37 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v37 - 1);
        while (v37 != v36);
        unsigned int v38 = __p;
      }
      unint64_t v74 = v36;
      operator delete(v38);
    }
    uint64_t v31 = v71;
    if (v71)
    {
      uint64_t v39 = v72;
      unint64_t v33 = v71;
      if (v72 == v71) {
        goto LABEL_97;
      }
      do
      {
        uint64_t v41 = *--v39;
        uint64_t v40 = v41;
        void *v39 = 0;
        if (v41) {
          MEMORY[0x21667D390](v40, 0x1000C8077774924);
        }
      }
      while (v39 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  uint64_t v6 = (void **)v3[2];
  if (!v6)
  {
    v66[0] = (void **)"requires attribute 'explicit_padding'";
    __int16 v67 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v66, (uint64_t)v68);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    }
    if (!v75) {
      return v27;
    }
    uint64_t v42 = __p;
    if (__p)
    {
      __int16 v43 = v74;
      uint64_t v44 = __p;
      if (v74 != __p)
      {
        do
          __int16 v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
        while (v43 != v42);
        uint64_t v44 = __p;
      }
      unint64_t v74 = v42;
      operator delete(v44);
    }
    uint64_t v31 = v71;
    if (v71)
    {
      uint64_t v45 = v72;
      unint64_t v33 = v71;
      if (v72 == v71) {
        goto LABEL_97;
      }
      do
      {
        uint64_t v47 = *--v45;
        uint64_t v46 = v47;
        void *v45 = 0;
        if (v47) {
          MEMORY[0x21667D390](v46, 0x1000C8077774924);
        }
      }
      while (v45 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  uint64_t v7 = (void **)v3[3];
  if (!v7)
  {
    v66[0] = (void **)"requires attribute 'groups'";
    __int16 v67 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v66, (uint64_t)v68);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    }
    if (!v75) {
      return v27;
    }
    unsigned int v48 = __p;
    if (__p)
    {
      unsigned int v49 = v74;
      unint64_t v50 = __p;
      if (v74 != __p)
      {
        do
          unsigned int v49 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v49 - 1);
        while (v49 != v48);
        unint64_t v50 = __p;
      }
      unint64_t v74 = v48;
      operator delete(v50);
    }
    uint64_t v31 = v71;
    if (v71)
    {
      unint64_t v51 = v72;
      unint64_t v33 = v71;
      if (v72 == v71) {
        goto LABEL_97;
      }
      do
      {
        uint64_t v53 = *--v51;
        uint64_t v52 = v53;
        *unint64_t v51 = 0;
        if (v53) {
          MEMORY[0x21667D390](v52, 0x1000C8077774924);
        }
      }
      while (v51 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  uint64_t v8 = v3[4];
  if (!v8)
  {
    v66[0] = (void **)"requires attribute 'padding_style'";
    __int16 v67 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v66, (uint64_t)v68);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    }
    if (!v75) {
      return v27;
    }
    char v54 = __p;
    if (__p)
    {
      uint64_t v55 = v74;
      uint64_t v56 = __p;
      if (v74 != __p)
      {
        do
          uint64_t v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
        while (v55 != v54);
        uint64_t v56 = __p;
      }
      unint64_t v74 = v54;
      operator delete(v56);
    }
    uint64_t v31 = v71;
    if (v71)
    {
      uint64_t v57 = v72;
      unint64_t v33 = v71;
      if (v72 == v71) {
        goto LABEL_97;
      }
      do
      {
        uint64_t v59 = *--v57;
        uint64_t v58 = v59;
        *uint64_t v57 = 0;
        if (v59) {
          MEMORY[0x21667D390](v58, 0x1000C8077774924);
        }
      }
      while (v57 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  long long v9 = (void **)v3[5];
  if (!v9)
  {
    uint64_t v61 = "requires attribute 'strides'";
LABEL_103:
    v66[0] = (void **)v61;
    __int16 v67 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v66, (uint64_t)v68);
    unint64_t v26 = v68;
    goto LABEL_104;
  }
  uint64_t v10 = v3[6];
  if (!v10)
  {
    uint64_t v61 = "requires attribute 'weights_layout'";
    goto LABEL_103;
  }
  v68[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v5, (void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v4, (void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v10, (void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  uint64_t v11 = *(void *)this;
  }
  unint64_t v12 = *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  unsigned int v65 = 1;
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v11, v12, (void **)"operand", (void **)7, 0))return 0; {
  unsigned int v13 = 1;
  }
  uint64_t ODSOperands = mlir::tensor::UnPackOp::getODSOperands(this, 1u);
  if (v15)
  {
    uint64_t v16 = v15;
    uint64_t v17 = 0;
    uint64_t v18 = ODSOperands + 24;
    while (1)
    {
      uint64_t v19 = *(void *)this;
      unint64_t v20 = *(void *)(*(void *)v18 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v65 = v17 + 2;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v19, v20, (void **)"operand", (void **)7, (int)v17 + 1))return 0; {
      ++v17;
      }
      v18 += 32;
      if (v16 == v17)
      {
        unsigned int v13 = v17 + 1;
        break;
      }
    }
  }
  uint64_t v21 = mlir::tensor::UnPackOp::getODSOperands(this, 2u);
  uint64_t v23 = v22;
  if (v22 >= 2)
  {
    v66[0] = (void **)"operand group starting at #";
    __int16 v67 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v66, (uint64_t)v68);
    uint64_t v24 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v68, &v65);
    uint64_t v25 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v24, " requires 0 or 1 element, but found ");
    uint64_t v64 = v23;
    unint64_t v26 = (void *)mlir::InFlightDiagnostic::operator<<<unsigned long &>(v25, &v64);
LABEL_104:
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v26);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v68);
    return v27;
  }
  if (v22
    && !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(v21 + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, v13))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v62 = *(void *)this - 16;
  }
  else {
    uint64_t v62 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v62, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
}

void mlir::mps::Conv2DDataGradientOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::Conv2DOpGenericAdaptorBase::Conv2DOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v5;
  long long v9 = *(_OWORD *)(v5 + 16);
  long long v10 = *(_OWORD *)(v5 + 32);
  *(void *)(a1 + 72) = *(void *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.conv_2d", 11, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::Conv2DOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n)) {
        return 0;
      }
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n)) {
        return a2[1];
      }
      if (memcmp(__s1, "weights_layout", __n)) {
        return 0;
      }
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv2DOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  uint64_t v7 = (void *)result;
  switch(__n)
  {
    case 6uLL:
      uint64_t result = memcmp(__s1, "groups", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v14 = a4;
          }
          else {
            uint64_t v14 = 0;
          }
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          *(void *)uint64_t result = v10;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "weights_layout", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
              uint64_t v12 = a4;
            }
            else {
              uint64_t v12 = 0;
            }
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v15 = a4;
        }
        else {
          uint64_t v15 = 0;
        }
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v13 = a4;
          }
          else {
            uint64_t v13 = 0;
          }
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::Conv2DOp::readProperties(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::Conv2DOp::verifyInvariantsImpl(mlir::mps::Conv2DOp *this)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  if (*v3)
  {
    uint64_t v5 = (void **)v3[1];
    if (v5)
    {
      unint64_t v6 = (void **)v3[2];
      if (v6)
      {
        uint64_t v7 = (void **)v3[3];
        if (v7)
        {
          uint64_t v8 = v3[4];
          if (v8)
          {
            long long v9 = (void **)v3[5];
            if (v9)
            {
              uint64_t v10 = v3[6];
              if (v10)
              {
                v50[0] = v2;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v5, (void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v4, (void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v10, (void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u))
                {
                  return 0;
                }
                if (*(_DWORD *)(*(void *)this + 36)) {
                  uint64_t v11 = *(void *)this - 16;
                }
                else {
                  uint64_t v11 = 0;
                }
                uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
              }
              uint64_t v47 = "requires attribute 'weights_layout'";
            }
            else
            {
              uint64_t v47 = "requires attribute 'strides'";
            }
            v48[0] = (void **)v47;
            __int16 v49 = 259;
            mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
            uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v50);
            return v13;
          }
          v48[0] = (void **)"requires attribute 'padding_style'";
          __int16 v49 = 259;
          mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
          uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          }
          if (v57)
          {
            uint64_t v40 = __p;
            if (__p)
            {
              uint64_t v41 = v56;
              uint64_t v42 = __p;
              if (v56 != __p)
              {
                do
                  uint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
                while (v41 != v40);
                uint64_t v42 = __p;
              }
              uint64_t v56 = v40;
              operator delete(v42);
            }
            uint64_t v17 = v53;
            if (!v53) {
              goto LABEL_96;
            }
            __int16 v43 = v54;
            uint64_t v19 = v53;
            if (v54 == v53)
            {
LABEL_95:
              char v54 = v17;
              operator delete(v19);
LABEL_96:
              if (v51 != &v52) {
                free(v51);
              }
              return v13;
            }
            do
            {
              uint64_t v45 = *--v43;
              uint64_t v44 = v45;
              void *v43 = 0;
              if (v45) {
                MEMORY[0x21667D390](v44, 0x1000C8077774924);
              }
            }
            while (v43 != v17);
LABEL_94:
            uint64_t v19 = v53;
            goto LABEL_95;
          }
        }
        else
        {
          v48[0] = (void **)"requires attribute 'groups'";
          __int16 v49 = 259;
          mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
          uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          }
          if (v57)
          {
            uint64_t v34 = __p;
            if (__p)
            {
              uint64_t v35 = v56;
              int64_t v36 = __p;
              if (v56 != __p)
              {
                do
                  uint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
                while (v35 != v34);
                int64_t v36 = __p;
              }
              uint64_t v56 = v34;
              operator delete(v36);
            }
            uint64_t v17 = v53;
            if (!v53) {
              goto LABEL_96;
            }
            int64_t v37 = v54;
            uint64_t v19 = v53;
            if (v54 == v53) {
              goto LABEL_95;
            }
            do
            {
              uint64_t v39 = *--v37;
              uint64_t v38 = v39;
              void *v37 = 0;
              if (v39) {
                MEMORY[0x21667D390](v38, 0x1000C8077774924);
              }
            }
            while (v37 != v17);
            goto LABEL_94;
          }
        }
      }
      else
      {
        v48[0] = (void **)"requires attribute 'explicit_padding'";
        __int16 v49 = 259;
        mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
        uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
        if (v50[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
        }
        if (v57)
        {
          int64_t v28 = __p;
          if (__p)
          {
            uint64_t v29 = v56;
            uint64_t v30 = __p;
            if (v56 != __p)
            {
              do
                uint64_t v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
              while (v29 != v28);
              uint64_t v30 = __p;
            }
            uint64_t v56 = v28;
            operator delete(v30);
          }
          uint64_t v17 = v53;
          if (!v53) {
            goto LABEL_96;
          }
          uint64_t v31 = v54;
          uint64_t v19 = v53;
          if (v54 == v53) {
            goto LABEL_95;
          }
          do
          {
            uint64_t v33 = *--v31;
            uint64_t v32 = v33;
            void *v31 = 0;
            if (v33) {
              MEMORY[0x21667D390](v32, 0x1000C8077774924);
            }
          }
          while (v31 != v17);
          goto LABEL_94;
        }
      }
    }
    else
    {
      v48[0] = (void **)"requires attribute 'dilation_rates'";
      __int16 v49 = 259;
      mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
      uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
      if (v50[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
      }
      if (v57)
      {
        unint64_t v22 = __p;
        if (__p)
        {
          uint64_t v23 = v56;
          uint64_t v24 = __p;
          if (v56 != __p)
          {
            do
              uint64_t v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
            while (v23 != v22);
            uint64_t v24 = __p;
          }
          uint64_t v56 = v22;
          operator delete(v24);
        }
        uint64_t v17 = v53;
        if (!v53) {
          goto LABEL_96;
        }
        uint64_t v25 = v54;
        uint64_t v19 = v53;
        if (v54 == v53) {
          goto LABEL_95;
        }
        do
        {
          uint64_t v27 = *--v25;
          uint64_t v26 = v27;
          void *v25 = 0;
          if (v27) {
            MEMORY[0x21667D390](v26, 0x1000C8077774924);
          }
        }
        while (v25 != v17);
        goto LABEL_94;
      }
    }
  }
  else
  {
    v48[0] = (void **)"requires attribute 'data_layout'";
    __int16 v49 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
    uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
    if (v50[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
    }
    if (v57)
    {
      uint64_t v14 = __p;
      if (__p)
      {
        uint64_t v15 = v56;
        uint64_t v16 = __p;
        if (v56 != __p)
        {
          do
            uint64_t v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
          while (v15 != v14);
          uint64_t v16 = __p;
        }
        uint64_t v56 = v14;
        operator delete(v16);
      }
      uint64_t v17 = v53;
      if (!v53) {
        goto LABEL_96;
      }
      uint64_t v18 = v54;
      uint64_t v19 = v53;
      if (v54 == v53) {
        goto LABEL_95;
      }
      do
      {
        uint64_t v21 = *--v18;
        uint64_t v20 = v21;
        *uint64_t v18 = 0;
        if (v21) {
          MEMORY[0x21667D390](v20, 0x1000C8077774924);
        }
      }
      while (v18 != v17);
      goto LABEL_94;
    }
  }
  return v13;
}

void mlir::mps::Conv2DOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::Conv2DWeightsGradientOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n)) {
        return 0;
      }
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n)) {
        return a2[1];
      }
      if (memcmp(__s1, "weights_layout", __n)) {
        return 0;
      }
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv2DWeightsGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  uint64_t v7 = (void *)result;
  switch(__n)
  {
    case 6uLL:
      uint64_t result = memcmp(__s1, "groups", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v14 = a4;
          }
          else {
            uint64_t v14 = 0;
          }
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          *(void *)uint64_t result = v10;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "weights_layout", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
              uint64_t v12 = a4;
            }
            else {
              uint64_t v12 = 0;
            }
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v15 = a4;
        }
        else {
          uint64_t v15 = 0;
        }
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v13 = a4;
          }
          else {
            uint64_t v13 = 0;
          }
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::Conv2DWeightsGradientOp::readProperties(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::Conv2DWeightsGradientOp::verifyInvariantsImpl(mlir::mps::Conv2DWeightsGradientOp *this)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  if (*v3)
  {
    uint64_t v5 = (void **)v3[1];
    if (v5)
    {
      unint64_t v6 = (void **)v3[2];
      if (v6)
      {
        uint64_t v7 = (void **)v3[3];
        if (v7)
        {
          uint64_t v8 = v3[4];
          if (v8)
          {
            long long v9 = (void **)v3[5];
            if (v9)
            {
              uint64_t v10 = v3[6];
              if (v10)
              {
                v50[0] = v2;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v5, (void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v4, (void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v10, (void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this,
                                         *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8,
                                         (void **)"operand",
                                         (void **)7,
                                         2u))
                {
                  return 0;
                }
                if (*(_DWORD *)(*(void *)this + 36)) {
                  uint64_t v11 = *(void *)this - 16;
                }
                else {
                  uint64_t v11 = 0;
                }
                uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
              }
              uint64_t v47 = "requires attribute 'weights_layout'";
            }
            else
            {
              uint64_t v47 = "requires attribute 'strides'";
            }
            v48[0] = (void **)v47;
            __int16 v49 = 259;
            mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
            uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v50);
            return v13;
          }
          v48[0] = (void **)"requires attribute 'padding_style'";
          __int16 v49 = 259;
          mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
          uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          }
          if (v57)
          {
            uint64_t v40 = __p;
            if (__p)
            {
              uint64_t v41 = v56;
              uint64_t v42 = __p;
              if (v56 != __p)
              {
                do
                  uint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
                while (v41 != v40);
                uint64_t v42 = __p;
              }
              uint64_t v56 = v40;
              operator delete(v42);
            }
            uint64_t v17 = v53;
            if (!v53) {
              goto LABEL_97;
            }
            __int16 v43 = v54;
            uint64_t v19 = v53;
            if (v54 == v53)
            {
LABEL_96:
              char v54 = v17;
              operator delete(v19);
LABEL_97:
              if (v51 != &v52) {
                free(v51);
              }
              return v13;
            }
            do
            {
              uint64_t v45 = *--v43;
              uint64_t v44 = v45;
              void *v43 = 0;
              if (v45) {
                MEMORY[0x21667D390](v44, 0x1000C8077774924);
              }
            }
            while (v43 != v17);
LABEL_95:
            uint64_t v19 = v53;
            goto LABEL_96;
          }
        }
        else
        {
          v48[0] = (void **)"requires attribute 'groups'";
          __int16 v49 = 259;
          mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
          uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          }
          if (v57)
          {
            uint64_t v34 = __p;
            if (__p)
            {
              uint64_t v35 = v56;
              int64_t v36 = __p;
              if (v56 != __p)
              {
                do
                  uint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
                while (v35 != v34);
                int64_t v36 = __p;
              }
              uint64_t v56 = v34;
              operator delete(v36);
            }
            uint64_t v17 = v53;
            if (!v53) {
              goto LABEL_97;
            }
            int64_t v37 = v54;
            uint64_t v19 = v53;
            if (v54 == v53) {
              goto LABEL_96;
            }
            do
            {
              uint64_t v39 = *--v37;
              uint64_t v38 = v39;
              void *v37 = 0;
              if (v39) {
                MEMORY[0x21667D390](v38, 0x1000C8077774924);
              }
            }
            while (v37 != v17);
            goto LABEL_95;
          }
        }
      }
      else
      {
        v48[0] = (void **)"requires attribute 'explicit_padding'";
        __int16 v49 = 259;
        mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
        uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
        if (v50[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
        }
        if (v57)
        {
          int64_t v28 = __p;
          if (__p)
          {
            uint64_t v29 = v56;
            uint64_t v30 = __p;
            if (v56 != __p)
            {
              do
                uint64_t v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
              while (v29 != v28);
              uint64_t v30 = __p;
            }
            uint64_t v56 = v28;
            operator delete(v30);
          }
          uint64_t v17 = v53;
          if (!v53) {
            goto LABEL_97;
          }
          uint64_t v31 = v54;
          uint64_t v19 = v53;
          if (v54 == v53) {
            goto LABEL_96;
          }
          do
          {
            uint64_t v33 = *--v31;
            uint64_t v32 = v33;
            void *v31 = 0;
            if (v33) {
              MEMORY[0x21667D390](v32, 0x1000C8077774924);
            }
          }
          while (v31 != v17);
          goto LABEL_95;
        }
      }
    }
    else
    {
      v48[0] = (void **)"requires attribute 'dilation_rates'";
      __int16 v49 = 259;
      mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
      uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
      if (v50[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
      }
      if (v57)
      {
        unint64_t v22 = __p;
        if (__p)
        {
          uint64_t v23 = v56;
          uint64_t v24 = __p;
          if (v56 != __p)
          {
            do
              uint64_t v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
            while (v23 != v22);
            uint64_t v24 = __p;
          }
          uint64_t v56 = v22;
          operator delete(v24);
        }
        uint64_t v17 = v53;
        if (!v53) {
          goto LABEL_97;
        }
        uint64_t v25 = v54;
        uint64_t v19 = v53;
        if (v54 == v53) {
          goto LABEL_96;
        }
        do
        {
          uint64_t v27 = *--v25;
          uint64_t v26 = v27;
          void *v25 = 0;
          if (v27) {
            MEMORY[0x21667D390](v26, 0x1000C8077774924);
          }
        }
        while (v25 != v17);
        goto LABEL_95;
      }
    }
  }
  else
  {
    v48[0] = (void **)"requires attribute 'data_layout'";
    __int16 v49 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
    uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
    if (v50[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
    }
    if (v57)
    {
      uint64_t v14 = __p;
      if (__p)
      {
        uint64_t v15 = v56;
        uint64_t v16 = __p;
        if (v56 != __p)
        {
          do
            uint64_t v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
          while (v15 != v14);
          uint64_t v16 = __p;
        }
        uint64_t v56 = v14;
        operator delete(v16);
      }
      uint64_t v17 = v53;
      if (!v53) {
        goto LABEL_97;
      }
      uint64_t v18 = v54;
      uint64_t v19 = v53;
      if (v54 == v53) {
        goto LABEL_96;
      }
      do
      {
        uint64_t v21 = *--v18;
        uint64_t v20 = v21;
        *uint64_t v18 = 0;
        if (v21) {
          MEMORY[0x21667D390](v20, 0x1000C8077774924);
        }
      }
      while (v18 != v17);
      goto LABEL_95;
    }
  }
  return v13;
}

void mlir::mps::Conv2DWeightsGradientOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Conv3DDataGradientOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v5;
  long long v9 = *(_OWORD *)(v5 + 16);
  long long v10 = *(_OWORD *)(v5 + 32);
  *(void *)(a1 + 72) = *(void *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.conv_3d_data_gradient", 25, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t llvm::all_of<mlir::DenseIntElementsAttr,mlir::mps::Conv3DDataGradientOpAdaptor::verify(mlir::Location)::$_0>(uint64_t *a1)
{
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v10, *a1, 0);
  uint64_t v2 = *a1;
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)a1);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v7, v2, NumElements);
  while (1)
  {
    BOOL v4 = v10 == v7 && v11 == v8;
    if (v4 && v12 == v9) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*(&v10, (llvm::APInt *)&v13);
    if (v14 <= 0x40)
    {
      if (!v13) {
        return 0;
      }
    }
    else
    {
      uint64_t v5 = *v13;
      MEMORY[0x21667D390]();
      if (!v5) {
        return 0;
      }
    }
    ++v12;
  }
  return 1;
}

uint64_t mlir::mps::Conv3DDataGradientOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n)) {
        return 0;
      }
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n)) {
        return a2[1];
      }
      if (memcmp(__s1, "weights_layout", __n)) {
        return 0;
      }
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv3DDataGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  uint64_t v7 = (void *)result;
  switch(__n)
  {
    case 6uLL:
      uint64_t result = memcmp(__s1, "groups", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v14 = a4;
          }
          else {
            uint64_t v14 = 0;
          }
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          *(void *)uint64_t result = v10;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "weights_layout", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
              uint64_t v12 = a4;
            }
            else {
              uint64_t v12 = 0;
            }
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v15 = a4;
        }
        else {
          uint64_t v15 = 0;
        }
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v13 = a4;
          }
          else {
            uint64_t v13 = 0;
          }
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::Conv3DDataGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = (_DWORD *)mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(v8, (void **)"data_layout", (const char *)0xB, a3, a4))
  {
    uint64_t v9 = (void *)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v9, (void **)"dilation_rates", (const char *)0xE, (void (*)(void ***__return_ptr, uint64_t))a3, a4))
    {
      uint64_t v10 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(v10, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))a3, a4))
      {
        uint64_t v11 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v11, (void **)"groups", (const char *)6, a3, a4))
        {
          uint64_t v12 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v12, (void **)"padding_style", (const char *)0xD, a3, a4))
          {
            uint64_t v13 = (void *)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v13, (void **)"strides", (const char *)7, (void (*)(void ***__return_ptr, uint64_t))a3, a4))
            {
              uint64_t v14 = (_DWORD *)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(v14, (void **)"weights_layout", (const char *)0xE, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(_DWORD *a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id
    && (a1[2] - 7) < 2)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v8 = &v29;
    uint64_t v9 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v9 = (char *)v35;
        uint64_t v8 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = &v29;
        uint64_t v9 = (char *)v35;
      }
    }
    uint64_t v10 = &v9[24 * v36];
    long long v11 = *(_OWORD *)v8;
    *((void *)v10 + 2) = v8[2];
    *(_OWORD *)uint64_t v10 = v11;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      uint64_t v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid TensorDataLayout is one of NDHWC or NCDHW";
        uint64_t v31 = 79;
        uint64_t v12 = &v29;
        uint64_t v13 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v13 = (char *)v35;
            uint64_t v12 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = &v29;
            uint64_t v13 = (char *)v35;
          }
        }
        uint64_t v14 = &v13[24 * v36];
        long long v15 = *(_OWORD *)v12;
        *((void *)v14 + 2) = v12[2];
        *(_OWORD *)uint64_t v14 = v15;
        ++v36;
      }
    }
  }
  uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = __p;
    if (__p)
    {
      uint64_t v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          uint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      uint64_t v42 = v16;
      operator delete(v18);
    }
    uint64_t v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      uint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        uint64_t v21 = v39;
      }
      uint64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v7;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(void *a1, void **a2, const char *a3, void (*a4)(void ***__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v66 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1)) {
    goto LABEL_7;
  }
  uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*a1 + 8);
  v45[0] = a1;
  v45[1] = v10;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v45);
  uint64_t v12 = Type;
  if (Type) {
    Type = (void *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  }
  v46[0] = v12;
  v46[1] = Type;
  Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v46);
  uint64_t v65 = 5;
  if (v14 != 1 || *Shape != v65) {
    goto LABEL_7;
  }
  uint64_t v44 = a1;
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v53, (uint64_t)a1, 0);
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v44);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v49, (uint64_t)a1, NumElements);
  while (1)
  {
    BOOL v34 = v53 == v49 && v54[0] == v50;
    if (v34 && v55 == v51) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*(&v53, (llvm::APInt *)&v47);
    if (v48 > 0x40)
    {
      uint64_t v33 = *v47;
      MEMORY[0x21667D390]();
      if (!v33) {
        goto LABEL_7;
      }
    }
    else if (!v47)
    {
      goto LABEL_7;
    }
    ++v55;
  }
  uint64_t v41 = a1;
  v42[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v41);
  v42[1] = v35;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v42);
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
    return 1;
  }
LABEL_7:
  a4(&v53, a5);
  if (v53)
  {
    LODWORD(v49) = 3;
    unint64_t v50 = "attribute '";
    uint64_t v51 = 11;
    long long v15 = &v49;
    uint64_t v16 = (char *)v56;
    if (v57 >= v58)
    {
      unint64_t v37 = v57 + 1;
      if (v56 <= &v49 && (char *)v56 + 24 * v57 > (char *)&v49)
      {
        int64_t v39 = (char *)&v49 - (unsigned char *)v56;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v37, 24);
        uint64_t v16 = (char *)v56;
        long long v15 = (void ***)((char *)v56 + v39);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v37, 24);
        long long v15 = &v49;
        uint64_t v16 = (char *)v56;
      }
    }
    uint64_t v17 = &v16[24 * v57];
    long long v18 = *(_OWORD *)v15;
    *((void *)v17 + 2) = v15[2];
    *(_OWORD *)uint64_t v17 = v18;
    ++v57;
    if (v53)
    {
      __int16 v52 = 261;
      __int16 v49 = a2;
      unint64_t v50 = a3;
      mlir::Diagnostic::operator<<((uint64_t)v54, &v49);
      if (v53)
      {
        LODWORD(v49) = 3;
        unint64_t v50 = "' failed to satisfy constraint: positive ui64 elements attribute of shape {5}";
        uint64_t v51 = 77;
        uint64_t v19 = &v49;
        uint64_t v20 = (char *)v56;
        if (v57 >= v58)
        {
          unint64_t v38 = v57 + 1;
          if (v56 <= &v49 && (char *)v56 + 24 * v57 > (char *)&v49)
          {
            int64_t v40 = (char *)&v49 - (unsigned char *)v56;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v38, 24);
            uint64_t v20 = (char *)v56;
            uint64_t v19 = (void ***)((char *)v56 + v40);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v38, 24);
            uint64_t v19 = &v49;
            uint64_t v20 = (char *)v56;
          }
        }
        uint64_t v21 = &v20[24 * v57];
        long long v22 = *(_OWORD *)v19;
        *((void *)v21 + 2) = v19[2];
        *(_OWORD *)uint64_t v21 = v22;
        ++v57;
      }
    }
  }
  uint64_t v23 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v53);
  if (v53) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v53);
  }
  if (v64)
  {
    uint64_t v24 = __p;
    if (__p)
    {
      unint64_t v25 = v63;
      unint64_t v26 = __p;
      if (v63 != __p)
      {
        do
          unint64_t v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        unint64_t v26 = __p;
      }
      uint64_t v63 = v24;
      operator delete(v26);
    }
    int64_t v27 = v60;
    if (v60)
    {
      int64_t v28 = v61;
      uint64_t v29 = v60;
      if (v61 != v60)
      {
        do
        {
          uint64_t v31 = *--v28;
          uint64_t v30 = v31;
          *int64_t v28 = 0;
          if (v31) {
            MEMORY[0x21667D390](v30, 0x1000C8077774924);
          }
        }
        while (v28 != v27);
        uint64_t v29 = v60;
      }
      uint64_t v61 = v27;
      operator delete(v29);
    }
    if (v56 != v59) {
      free(v56);
    }
  }
  return v23;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(void **a1, void **a2, const char *a3, void (*a4)(void **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1)) {
    goto LABEL_13;
  }
  uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  uint64_t v42 = a1;
  char v43 = (const char *)v10;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v42);
  uint64_t v12 = Type;
  if (Type) {
    Type = (void *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  }
  uint64_t v46 = v12;
  uint64_t v47 = Type;
  Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v46);
  long long v57 = xmmword_211F09570;
  if (v14 == 2 && *Shape == (void)v57 && Shape[1] == *((void *)&v57 + 1))
  {
    int64_t v39 = a1;
    v40[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39);
    v40[1] = v16;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v40);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
  }
LABEL_13:
  a4(&v46, a5);
  if (v46)
  {
    LODWORD(v42) = 3;
    char v43 = "attribute '";
    uint64_t v44 = 11;
    long long v18 = &v42;
    uint64_t v19 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v35 = v49 + 1;
      if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
      {
        int64_t v37 = (char *)&v42 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
        uint64_t v19 = (char *)v48;
        long long v18 = (void ***)((char *)v48 + v37);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
        long long v18 = &v42;
        uint64_t v19 = (char *)v48;
      }
    }
    uint64_t v20 = &v19[24 * v49];
    long long v21 = *(_OWORD *)v18;
    *((void *)v20 + 2) = v18[2];
    *(_OWORD *)uint64_t v20 = v21;
    ++v49;
    if (v46)
    {
      __int16 v45 = 261;
      uint64_t v42 = a2;
      char v43 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v47, &v42);
      if (v46)
      {
        LODWORD(v42) = 3;
        char v43 = "' failed to satisfy constraint: ui64 elements attribute of shape {5, 2}";
        uint64_t v44 = 71;
        long long v22 = &v42;
        uint64_t v23 = (char *)v48;
        if (v49 >= v50)
        {
          unint64_t v36 = v49 + 1;
          if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
          {
            int64_t v38 = (char *)&v42 - (unsigned char *)v48;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            uint64_t v23 = (char *)v48;
            long long v22 = (void ***)((char *)v48 + v38);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            long long v22 = &v42;
            uint64_t v23 = (char *)v48;
          }
        }
        uint64_t v24 = &v23[24 * v49];
        long long v25 = *(_OWORD *)v22;
        *((void *)v24 + 2) = v22[2];
        *(_OWORD *)uint64_t v24 = v25;
        ++v49;
      }
    }
  }
  uint64_t v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v46);
  if (v46) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v46);
  }
  if (v56)
  {
    unint64_t v26 = __p;
    if (__p)
    {
      int64_t v27 = v55;
      int64_t v28 = __p;
      if (v55 != __p)
      {
        do
          int64_t v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
        while (v27 != v26);
        int64_t v28 = __p;
      }
      uint64_t v55 = v26;
      operator delete(v28);
    }
    uint64_t v29 = v52;
    if (v52)
    {
      uint64_t v30 = v53;
      uint64_t v31 = v52;
      if (v53 != v52)
      {
        do
        {
          uint64_t v33 = *--v30;
          uint64_t v32 = v33;
          void *v30 = 0;
          if (v33) {
            MEMORY[0x21667D390](v32, 0x1000C8077774924);
          }
        }
        while (v30 != v29);
        uint64_t v31 = v52;
      }
      uint64_t v53 = v29;
      operator delete(v31);
    }
    if (v48 != v51) {
      free(v48);
    }
  }
  return v17;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(_DWORD *a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id
    && (a1[2] - 9) < 2)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v8 = &v29;
    uint64_t v9 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v9 = (char *)v35;
        uint64_t v8 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = &v29;
        uint64_t v9 = (char *)v35;
      }
    }
    uint64_t v10 = &v9[24 * v36];
    long long v11 = *(_OWORD *)v8;
    *((void *)v10 + 2) = v8[2];
    *(_OWORD *)uint64_t v10 = v11;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      uint64_t v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid TensorDataLayout is one of DHWIO or OIDHW";
        uint64_t v31 = 79;
        uint64_t v12 = &v29;
        uint64_t v13 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v13 = (char *)v35;
            uint64_t v12 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = &v29;
            uint64_t v13 = (char *)v35;
          }
        }
        uint64_t v14 = &v13[24 * v36];
        long long v15 = *(_OWORD *)v12;
        *((void *)v14 + 2) = v12[2];
        *(_OWORD *)uint64_t v14 = v15;
        ++v36;
      }
    }
  }
  uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = __p;
    if (__p)
    {
      uint64_t v17 = v42;
      long long v18 = __p;
      if (v42 != __p)
      {
        do
          uint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        long long v18 = __p;
      }
      uint64_t v42 = v16;
      operator delete(v18);
    }
    uint64_t v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      long long v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        long long v21 = v39;
      }
      int64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v7;
}

BOOL mlir::mps::Conv3DDataGradientOp::readProperties(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::Conv3DDataGradientOp::verifyInvariantsImpl(mlir::mps::Conv3DDataGradientOp *this)
{
  uint64_t v76 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v3 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v3 = 0;
  }
  BOOL v4 = *(_DWORD **)v3;
  if (!*(void *)v3)
  {
    v66[0] = (void **)"requires attribute 'data_layout'";
    __int16 v67 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v66, (uint64_t)v68);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    }
    if (!v75) {
      return v27;
    }
    int64_t v28 = __p;
    if (__p)
    {
      uint64_t v29 = v74;
      uint64_t v30 = __p;
      if (v74 != __p)
      {
        do
          uint64_t v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
        while (v29 != v28);
        uint64_t v30 = __p;
      }
      unint64_t v74 = v28;
      operator delete(v30);
    }
    uint64_t v31 = v71;
    if (v71)
    {
      __int16 v32 = v72;
      uint64_t v33 = v71;
      if (v72 == v71) {
        goto LABEL_97;
      }
      do
      {
        uint64_t v35 = *--v32;
        uint64_t v34 = v35;
        void *v32 = 0;
        if (v35) {
          MEMORY[0x21667D390](v34, 0x1000C8077774924);
        }
      }
      while (v32 != v31);
LABEL_96:
      uint64_t v33 = v71;
LABEL_97:
      unint64_t v72 = v31;
      operator delete(v33);
    }
LABEL_98:
    if (v69 != &v70) {
      free(v69);
    }
    return v27;
  }
  uint64_t v5 = *(void **)(v3 + 8);
  if (!v5)
  {
    v66[0] = (void **)"requires attribute 'dilation_rates'";
    __int16 v67 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v66, (uint64_t)v68);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    }
    if (!v75) {
      return v27;
    }
    unsigned int v36 = __p;
    if (__p)
    {
      unsigned int v37 = v74;
      int64_t v38 = __p;
      if (v74 != __p)
      {
        do
          unsigned int v37 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v37 - 1);
        while (v37 != v36);
        int64_t v38 = __p;
      }
      unint64_t v74 = v36;
      operator delete(v38);
    }
    uint64_t v31 = v71;
    if (v71)
    {
      int64_t v39 = v72;
      uint64_t v33 = v71;
      if (v72 == v71) {
        goto LABEL_97;
      }
      do
      {
        uint64_t v41 = *--v39;
        uint64_t v40 = v41;
        void *v39 = 0;
        if (v41) {
          MEMORY[0x21667D390](v40, 0x1000C8077774924);
        }
      }
      while (v39 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  unint64_t v6 = *(void ***)(v3 + 16);
  if (!v6)
  {
    v66[0] = (void **)"requires attribute 'explicit_padding'";
    __int16 v67 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v66, (uint64_t)v68);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    }
    if (!v75) {
      return v27;
    }
    uint64_t v42 = __p;
    if (__p)
    {
      char v43 = v74;
      uint64_t v44 = __p;
      if (v74 != __p)
      {
        do
          char v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
        while (v43 != v42);
        uint64_t v44 = __p;
      }
      unint64_t v74 = v42;
      operator delete(v44);
    }
    uint64_t v31 = v71;
    if (v71)
    {
      __int16 v45 = v72;
      uint64_t v33 = v71;
      if (v72 == v71) {
        goto LABEL_97;
      }
      do
      {
        uint64_t v47 = *--v45;
        uint64_t v46 = v47;
        void *v45 = 0;
        if (v47) {
          MEMORY[0x21667D390](v46, 0x1000C8077774924);
        }
      }
      while (v45 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  uint64_t v7 = *(void ***)(v3 + 24);
  if (!v7)
  {
    v66[0] = (void **)"requires attribute 'groups'";
    __int16 v67 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v66, (uint64_t)v68);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    }
    if (!v75) {
      return v27;
    }
    unsigned int v48 = __p;
    if (__p)
    {
      unsigned int v49 = v74;
      unsigned int v50 = __p;
      if (v74 != __p)
      {
        do
          unsigned int v49 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v49 - 1);
        while (v49 != v48);
        unsigned int v50 = __p;
      }
      unint64_t v74 = v48;
      operator delete(v50);
    }
    uint64_t v31 = v71;
    if (v71)
    {
      uint64_t v51 = v72;
      uint64_t v33 = v71;
      if (v72 == v71) {
        goto LABEL_97;
      }
      do
      {
        uint64_t v53 = *--v51;
        uint64_t v52 = v53;
        *uint64_t v51 = 0;
        if (v53) {
          MEMORY[0x21667D390](v52, 0x1000C8077774924);
        }
      }
      while (v51 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  uint64_t v8 = *(void *)(v3 + 32);
  if (!v8)
  {
    v66[0] = (void **)"requires attribute 'padding_style'";
    __int16 v67 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v66, (uint64_t)v68);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    }
    if (!v75) {
      return v27;
    }
    char v54 = __p;
    if (__p)
    {
      uint64_t v55 = v74;
      char v56 = __p;
      if (v74 != __p)
      {
        do
          uint64_t v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
        while (v55 != v54);
        char v56 = __p;
      }
      unint64_t v74 = v54;
      operator delete(v56);
    }
    uint64_t v31 = v71;
    if (v71)
    {
      long long v57 = v72;
      uint64_t v33 = v71;
      if (v72 == v71) {
        goto LABEL_97;
      }
      do
      {
        uint64_t v59 = *--v57;
        uint64_t v58 = v59;
        *long long v57 = 0;
        if (v59) {
          MEMORY[0x21667D390](v58, 0x1000C8077774924);
        }
      }
      while (v57 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  uint64_t v9 = *(void **)(v3 + 40);
  if (!v9)
  {
    uint64_t v61 = "requires attribute 'strides'";
LABEL_103:
    v66[0] = (void **)v61;
    __int16 v67 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v66, (uint64_t)v68);
    unint64_t v26 = v68;
    goto LABEL_104;
  }
  uint64_t v10 = *(_DWORD **)(v3 + 48);
  if (!v10)
  {
    uint64_t v61 = "requires attribute 'weights_layout'";
    goto LABEL_103;
  }
  v68[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v9, (void **)"strides", (const char *)7, (void (*)(void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v5, (void **)"dilation_rates", (const char *)0xE, (void (*)(void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(v6, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(v4, (void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  v68[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(v10, (void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0; {
  uint64_t v11 = *(void *)this;
  }
  uint64_t v12 = (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  unsigned int v65 = 1;
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(v11, v12, (void **)"operand", 7, 0)) {
    return 0;
  }
  unsigned int v13 = 1;
  uint64_t ODSOperands = mlir::tensor::UnPackOp::getODSOperands(this, 1u);
  if (v15)
  {
    uint64_t v16 = v15;
    uint64_t v17 = 0;
    uint64_t v18 = ODSOperands + 24;
    while (1)
    {
      uint64_t v19 = *(void *)this;
      uint64_t v20 = (void **)(*(void *)(*(void *)v18 + 8) & 0xFFFFFFFFFFFFFFF8);
      unsigned int v65 = v17 + 2;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps14(v19, v20, (void **)"operand", 7, (int)v17 + 1))return 0; {
      ++v17;
      }
      v18 += 32;
      if (v16 == v17)
      {
        unsigned int v13 = v17 + 1;
        break;
      }
    }
  }
  uint64_t v21 = mlir::tensor::UnPackOp::getODSOperands(this, 2u);
  uint64_t v23 = v22;
  if (v22 >= 2)
  {
    v66[0] = (void **)"operand group starting at #";
    __int16 v67 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v66, (uint64_t)v68);
    uint64_t v24 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v68, &v65);
    uint64_t v25 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v24, " requires 0 or 1 element, but found ");
    uint64_t v64 = v23;
    unint64_t v26 = (void *)mlir::InFlightDiagnostic::operator<<<unsigned long &>(v25, &v64);
LABEL_104:
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v26);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v68);
    return v27;
  }
  if (v22
    && !mlir::mps::__mlir_ods_local_type_constraint_MPSOps15(*(void *)this, (void **)(*(void *)(*(void *)(v21 + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, v13))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v62 = *(void *)this - 16;
  }
  else {
    uint64_t v62 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v62, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(uint64_t a1, void **a2, void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v72 = *MEMORY[0x263EF8340];
  uint64_t v10 = *a2;
  uint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v62[0] = a2;
    v62[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v62);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange)
      || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      return 1;
    }
    uint64_t v10 = *a2;
    uint64_t v42 = (void *)*((void *)*a2 + 17);
    if (v42 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v42 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_21;
    }
  }
  else if (v11 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id {
         && v11 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  }
  {
    goto LABEL_21;
  }
  uint64_t v55 = a2;
  uint64_t v56 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v55);
  if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
    || mlir::Type::isF16((mlir::Type *)&OperandRange)
    || mlir::Type::isF32((mlir::Type *)&OperandRange)
    || mlir::Type::isBF16((mlir::Type *)&OperandRange)
    || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
  {
    uint64_t v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    uint64_t v59 = a2;
    uint64_t v60 = v13;
    mlir::ShapedType::getShape((mlir::ShapedType *)&v59);
    if (v14 >= 5) {
      return 1;
    }
  }
LABEL_21:
  __int16 v57 = 261;
  uint64_t v55 = a3;
  uint64_t v56 = a4;
  mlir::Operation::emitOpError(a1, &v55, (uint64_t)v62);
  if (v62[0])
  {
    LODWORD(v59) = 3;
    uint64_t v60 = (uint64_t)" #";
    uint64_t v61 = 2;
    uint64_t v15 = &v59;
    uint64_t v16 = (char *)v63;
    if (v64 >= v65)
    {
      unint64_t v45 = v64 + 1;
      if (v63 <= &v59 && (char *)v63 + 24 * v64 > (char *)&v59)
      {
        int64_t v51 = (char *)&v59 - (unsigned char *)v63;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v45, 24);
        uint64_t v16 = (char *)v63;
        uint64_t v15 = (void ***)((char *)v63 + v51);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v45, 24);
        uint64_t v15 = &v59;
        uint64_t v16 = (char *)v63;
      }
    }
    uint64_t v17 = &v16[24 * v64];
    long long v18 = *(_OWORD *)v15;
    *((void *)v17 + 2) = v15[2];
    *(_OWORD *)uint64_t v17 = v18;
    uint64_t v19 = ++v64;
    if (v62[0])
    {
      LODWORD(v59) = 5;
      uint64_t v60 = a5;
      uint64_t v20 = &v59;
      uint64_t v21 = (char *)v63;
      if (v19 >= v65)
      {
        unint64_t v46 = v19 + 1;
        BOOL v47 = (char *)v63 + 24 * v19 > (char *)&v59;
        if (v63 <= &v59 && v47)
        {
          int64_t v52 = (char *)&v59 - (unsigned char *)v63;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v46, 24);
          uint64_t v21 = (char *)v63;
          uint64_t v20 = (void ***)((char *)v63 + v52);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v46, 24);
          uint64_t v20 = &v59;
          uint64_t v21 = (char *)v63;
        }
      }
      unint64_t v22 = &v21[24 * v64];
      long long v23 = *(_OWORD *)v20;
      *((void *)v22 + 2) = v20[2];
      *(_OWORD *)unint64_t v22 = v23;
      uint64_t v24 = ++v64;
      if (v62[0])
      {
        LODWORD(v59) = 3;
        uint64_t v60 = (uint64_t)" must be unranked tensor of mps native type values or ranked tensor type with rank equal to or gr"
                       "eater than 5, but got ";
        uint64_t v61 = 119;
        uint64_t v25 = &v59;
        unint64_t v26 = (char *)v63;
        if (v24 >= v65)
        {
          unint64_t v48 = v24 + 1;
          BOOL v49 = (char *)v63 + 24 * v24 > (char *)&v59;
          if (v63 <= &v59 && v49)
          {
            int64_t v53 = (char *)&v59 - (unsigned char *)v63;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v48, 24);
            unint64_t v26 = (char *)v63;
            uint64_t v25 = (void ***)((char *)v63 + v53);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v48, 24);
            uint64_t v25 = &v59;
            unint64_t v26 = (char *)v63;
          }
        }
        uint64_t v27 = &v26[24 * v64];
        long long v28 = *(_OWORD *)v25;
        *((void *)v27 + 2) = v25[2];
        *(_OWORD *)uint64_t v27 = v28;
        ++v64;
        if (v62[0])
        {
          uint64_t v29 = &v59;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v59, (uint64_t)a2);
          uint64_t v30 = (char *)v63;
          if (v64 >= v65)
          {
            unint64_t v50 = v64 + 1;
            if (v63 <= &v59 && (char *)v63 + 24 * v64 > (char *)&v59)
            {
              int64_t v54 = (char *)&v59 - (unsigned char *)v63;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v50, 24);
              uint64_t v30 = (char *)v63;
              uint64_t v29 = (void ***)((char *)v63 + v54);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v50, 24);
              uint64_t v29 = &v59;
              uint64_t v30 = (char *)v63;
            }
          }
          uint64_t v31 = &v30[24 * v64];
          long long v32 = *(_OWORD *)v29;
          *((void *)v31 + 2) = v29[2];
          *(_OWORD *)uint64_t v31 = v32;
          ++v64;
        }
      }
    }
  }
  uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v62);
  if (v62[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v62);
  }
  if (v71)
  {
    uint64_t v34 = __p;
    if (__p)
    {
      uint64_t v35 = v70;
      unsigned int v36 = __p;
      if (v70 != __p)
      {
        do
          uint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        unsigned int v36 = __p;
      }
      uint64_t v70 = v34;
      operator delete(v36);
    }
    unsigned int v37 = v67;
    if (v67)
    {
      int64_t v38 = v68;
      int64_t v39 = v67;
      if (v68 != v67)
      {
        do
        {
          uint64_t v41 = *--v38;
          uint64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            MEMORY[0x21667D390](v40, 0x1000C8077774924);
          }
        }
        while (v38 != v37);
        int64_t v39 = v67;
      }
      unint64_t v68 = v37;
      operator delete(v39);
    }
    if (v63 != v66) {
      free(v63);
    }
  }
  return v33;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps14(uint64_t a1, void **a2, void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  uint64_t v10 = *a2;
  uint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    if (v11 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
      goto LABEL_33;
    }
    goto LABEL_3;
  }
  v61[0] = a2;
  v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
  if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
    || mlir::Type::isF16((mlir::Type *)&OperandRange)
    || mlir::Type::isF32((mlir::Type *)&OperandRange)
    || mlir::Type::isBF16((mlir::Type *)&OperandRange)
    || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
  {
    return 1;
  }
  uint64_t v10 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
LABEL_3:
    int64_t v53 = a2;
    uint64_t v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53))
    {
      uint64_t v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      uint64_t v58 = a2;
      uint64_t v59 = v12;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v58);
      if (v13 == 5)
      {
        uint64_t v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
        v56[0] = a2;
        v56[1] = v14;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
        if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isF16((mlir::Type *)&OperandRange)
          || mlir::Type::isF32((mlir::Type *)&OperandRange)
          || mlir::Type::isBF16((mlir::Type *)&OperandRange)
          || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
        {
          return 1;
        }
      }
    }
  }
LABEL_33:
  __int16 v55 = 261;
  int64_t v53 = a3;
  uint64_t v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    uint64_t v59 = (uint64_t)" #";
    uint64_t v60 = 2;
    uint64_t v15 = &v58;
    uint64_t v16 = (char *)v62;
    if (v63 >= v64)
    {
      unint64_t v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        int64_t v49 = (char *)&v58 - (unsigned char *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        uint64_t v16 = (char *)v62;
        uint64_t v15 = (void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        uint64_t v15 = &v58;
        uint64_t v16 = (char *)v62;
      }
    }
    uint64_t v17 = &v16[24 * v63];
    long long v18 = *(_OWORD *)v15;
    *((void *)v17 + 2) = v15[2];
    *(_OWORD *)uint64_t v17 = v18;
    uint64_t v19 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      uint64_t v59 = a5;
      uint64_t v20 = &v58;
      uint64_t v21 = (char *)v62;
      if (v19 >= v64)
      {
        unint64_t v44 = v19 + 1;
        BOOL v45 = (char *)v62 + 24 * v19 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          int64_t v50 = (char *)&v58 - (unsigned char *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          uint64_t v21 = (char *)v62;
          uint64_t v20 = (void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          uint64_t v20 = &v58;
          uint64_t v21 = (char *)v62;
        }
      }
      unint64_t v22 = &v21[24 * v63];
      long long v23 = *(_OWORD *)v20;
      *((void *)v22 + 2) = v20[2];
      *(_OWORD *)unint64_t v22 = v23;
      uint64_t v24 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        uint64_t v59 = (uint64_t)" must be unranked tensor of mps native type values or 5D tensor of mps native type values, but got ";
        uint64_t v60 = 99;
        uint64_t v25 = &v58;
        unint64_t v26 = (char *)v62;
        if (v24 >= v64)
        {
          unint64_t v46 = v24 + 1;
          BOOL v47 = (char *)v62 + 24 * v24 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            int64_t v51 = (char *)&v58 - (unsigned char *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            unint64_t v26 = (char *)v62;
            uint64_t v25 = (void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            uint64_t v25 = &v58;
            unint64_t v26 = (char *)v62;
          }
        }
        uint64_t v27 = &v26[24 * v63];
        long long v28 = *(_OWORD *)v25;
        *((void *)v27 + 2) = v25[2];
        *(_OWORD *)uint64_t v27 = v28;
        ++v63;
        if (v61[0])
        {
          uint64_t v29 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          uint64_t v30 = (char *)v62;
          if (v63 >= v64)
          {
            unint64_t v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              int64_t v52 = (char *)&v58 - (unsigned char *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              uint64_t v30 = (char *)v62;
              uint64_t v29 = (void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              uint64_t v29 = &v58;
              uint64_t v30 = (char *)v62;
            }
          }
          uint64_t v31 = &v30[24 * v63];
          long long v32 = *(_OWORD *)v29;
          *((void *)v31 + 2) = v29[2];
          *(_OWORD *)uint64_t v31 = v32;
          ++v63;
        }
      }
    }
  }
  uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  }
  if (v70)
  {
    uint64_t v34 = __p;
    if (__p)
    {
      uint64_t v35 = v69;
      unsigned int v36 = __p;
      if (v69 != __p)
      {
        do
          uint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        unsigned int v36 = __p;
      }
      unint64_t v69 = v34;
      operator delete(v36);
    }
    unsigned int v37 = v66;
    if (v66)
    {
      int64_t v38 = v67;
      int64_t v39 = v66;
      if (v67 != v66)
      {
        do
        {
          uint64_t v41 = *--v38;
          uint64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            MEMORY[0x21667D390](v40, 0x1000C8077774924);
          }
        }
        while (v38 != v37);
        int64_t v39 = v66;
      }
      __int16 v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65) {
      free(v62);
    }
  }
  return v33;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps15(uint64_t a1, void **a2, void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  uint64_t v10 = *a2;
  uint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v61[0] = a2;
    v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)) {
      return 1;
    }
    uint64_t v10 = *a2;
    if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_3:
      int64_t v53 = a2;
      uint64_t v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53)) {
        goto LABEL_10;
      }
      uint64_t v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      uint64_t v58 = a2;
      uint64_t v59 = v12;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v58);
      if (v13 != 1) {
        goto LABEL_10;
      }
      uint64_t v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v56[0] = a2;
      v56[1] = v14;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
      if (!mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)) {
        goto LABEL_10;
      }
      return 1;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    goto LABEL_3;
  }
LABEL_10:
  __int16 v55 = 261;
  int64_t v53 = a3;
  uint64_t v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    uint64_t v59 = (uint64_t)" #";
    uint64_t v60 = 2;
    uint64_t v16 = &v58;
    uint64_t v17 = (char *)v62;
    if (v63 >= v64)
    {
      unint64_t v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        int64_t v49 = (char *)&v58 - (unsigned char *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        uint64_t v17 = (char *)v62;
        uint64_t v16 = (void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        uint64_t v16 = &v58;
        uint64_t v17 = (char *)v62;
      }
    }
    long long v18 = &v17[24 * v63];
    long long v19 = *(_OWORD *)v16;
    *((void *)v18 + 2) = v16[2];
    *(_OWORD *)long long v18 = v19;
    uint64_t v20 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      uint64_t v59 = a5;
      uint64_t v21 = &v58;
      unint64_t v22 = (char *)v62;
      if (v20 >= v64)
      {
        unint64_t v44 = v20 + 1;
        BOOL v45 = (char *)v62 + 24 * v20 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          int64_t v50 = (char *)&v58 - (unsigned char *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          unint64_t v22 = (char *)v62;
          uint64_t v21 = (void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          uint64_t v21 = &v58;
          unint64_t v22 = (char *)v62;
        }
      }
      long long v23 = &v22[24 * v63];
      long long v24 = *(_OWORD *)v21;
      *((void *)v23 + 2) = v21[2];
      *(_OWORD *)long long v23 = v24;
      uint64_t v25 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        uint64_t v59 = (uint64_t)" must be unranked tensor of 32-bit signed integer values or 1D tensor of 32-bit signed integer values, but got ";
        uint64_t v60 = 111;
        unint64_t v26 = &v58;
        uint64_t v27 = (char *)v62;
        if (v25 >= v64)
        {
          unint64_t v46 = v25 + 1;
          BOOL v47 = (char *)v62 + 24 * v25 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            int64_t v51 = (char *)&v58 - (unsigned char *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            uint64_t v27 = (char *)v62;
            unint64_t v26 = (void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            unint64_t v26 = &v58;
            uint64_t v27 = (char *)v62;
          }
        }
        long long v28 = &v27[24 * v63];
        long long v29 = *(_OWORD *)v26;
        *((void *)v28 + 2) = v26[2];
        *(_OWORD *)long long v28 = v29;
        ++v63;
        if (v61[0])
        {
          uint64_t v30 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          uint64_t v31 = (char *)v62;
          if (v63 >= v64)
          {
            unint64_t v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              int64_t v52 = (char *)&v58 - (unsigned char *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              uint64_t v31 = (char *)v62;
              uint64_t v30 = (void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              uint64_t v30 = &v58;
              uint64_t v31 = (char *)v62;
            }
          }
          long long v32 = &v31[24 * v63];
          long long v33 = *(_OWORD *)v30;
          *((void *)v32 + 2) = v30[2];
          *(_OWORD *)long long v32 = v33;
          ++v63;
        }
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  }
  if (v70)
  {
    uint64_t v34 = __p;
    if (__p)
    {
      uint64_t v35 = v69;
      unsigned int v36 = __p;
      if (v69 != __p)
      {
        do
          uint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        unsigned int v36 = __p;
      }
      unint64_t v69 = v34;
      operator delete(v36);
    }
    unsigned int v37 = v66;
    if (v66)
    {
      int64_t v38 = v67;
      int64_t v39 = v66;
      if (v67 != v66)
      {
        do
        {
          uint64_t v41 = *--v38;
          uint64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            MEMORY[0x21667D390](v40, 0x1000C8077774924);
          }
        }
        while (v38 != v37);
        int64_t v39 = v66;
      }
      __int16 v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65) {
      free(v62);
    }
  }
  return v15;
}

void mlir::mps::Conv3DDataGradientOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::Conv3DOpGenericAdaptorBase::Conv3DOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v5;
  long long v9 = *(_OWORD *)(v5 + 16);
  long long v10 = *(_OWORD *)(v5 + 32);
  *(void *)(a1 + 72) = *(void *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.conv_3d", 11, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::Conv3DOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n)) {
        return 0;
      }
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n)) {
        return a2[1];
      }
      if (memcmp(__s1, "weights_layout", __n)) {
        return 0;
      }
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv3DOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  uint64_t v7 = (void *)result;
  switch(__n)
  {
    case 6uLL:
      uint64_t result = memcmp(__s1, "groups", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v14 = a4;
          }
          else {
            uint64_t v14 = 0;
          }
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          *(void *)uint64_t result = v10;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "weights_layout", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
              uint64_t v12 = a4;
            }
            else {
              uint64_t v12 = 0;
            }
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v15 = a4;
        }
        else {
          uint64_t v15 = 0;
        }
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v13 = a4;
          }
          else {
            uint64_t v13 = 0;
          }
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::Conv3DOp::readProperties(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::Conv3DOp::verifyInvariantsImpl(mlir::mps::Conv3DOp *this)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v3 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v3 = 0;
  }
  unint64_t v4 = *(_DWORD **)v3;
  if (*(void *)v3)
  {
    uint64_t v5 = *(void **)(v3 + 8);
    if (v5)
    {
      unint64_t v6 = *(void ***)(v3 + 16);
      if (v6)
      {
        uint64_t v7 = *(void ***)(v3 + 24);
        if (v7)
        {
          uint64_t v8 = *(void *)(v3 + 32);
          if (v8)
          {
            long long v9 = *(void **)(v3 + 40);
            if (v9)
            {
              uint64_t v10 = *(_DWORD **)(v3 + 48);
              if (v10)
              {
                v50[0] = v2;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v9, (void **)"strides", (const char *)7, (void (*)(void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v5, (void **)"dilation_rates", (const char *)0xE, (void (*)(void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(v6, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(v4, (void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(v10, (void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24)+ 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps14(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56)+ 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 1u))
                {
                  return 0;
                }
                if (*(_DWORD *)(*(void *)this + 36)) {
                  uint64_t v11 = *(void *)this - 16;
                }
                else {
                  uint64_t v11 = 0;
                }
                uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
              }
              BOOL v47 = "requires attribute 'weights_layout'";
            }
            else
            {
              BOOL v47 = "requires attribute 'strides'";
            }
            v48[0] = (void **)v47;
            __int16 v49 = 259;
            mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
            uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v50);
            return v13;
          }
          v48[0] = (void **)"requires attribute 'padding_style'";
          __int16 v49 = 259;
          mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
          uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          }
          if (v57)
          {
            uint64_t v40 = __p;
            if (__p)
            {
              uint64_t v41 = v56;
              uint64_t v42 = __p;
              if (v56 != __p)
              {
                do
                  uint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
                while (v41 != v40);
                uint64_t v42 = __p;
              }
              uint64_t v56 = v40;
              operator delete(v42);
            }
            uint64_t v17 = v53;
            if (!v53) {
              goto LABEL_96;
            }
            unint64_t v43 = v54;
            long long v19 = v53;
            if (v54 == v53)
            {
LABEL_95:
              uint64_t v54 = v17;
              operator delete(v19);
LABEL_96:
              if (v51 != &v52) {
                free(v51);
              }
              return v13;
            }
            do
            {
              uint64_t v45 = *--v43;
              uint64_t v44 = v45;
              void *v43 = 0;
              if (v45) {
                MEMORY[0x21667D390](v44, 0x1000C8077774924);
              }
            }
            while (v43 != v17);
LABEL_94:
            long long v19 = v53;
            goto LABEL_95;
          }
        }
        else
        {
          v48[0] = (void **)"requires attribute 'groups'";
          __int16 v49 = 259;
          mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
          uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          }
          if (v57)
          {
            uint64_t v34 = __p;
            if (__p)
            {
              uint64_t v35 = v56;
              unsigned int v36 = __p;
              if (v56 != __p)
              {
                do
                  uint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
                while (v35 != v34);
                unsigned int v36 = __p;
              }
              uint64_t v56 = v34;
              operator delete(v36);
            }
            uint64_t v17 = v53;
            if (!v53) {
              goto LABEL_96;
            }
            unsigned int v37 = v54;
            long long v19 = v53;
            if (v54 == v53) {
              goto LABEL_95;
            }
            do
            {
              uint64_t v39 = *--v37;
              uint64_t v38 = v39;
              void *v37 = 0;
              if (v39) {
                MEMORY[0x21667D390](v38, 0x1000C8077774924);
              }
            }
            while (v37 != v17);
            goto LABEL_94;
          }
        }
      }
      else
      {
        v48[0] = (void **)"requires attribute 'explicit_padding'";
        __int16 v49 = 259;
        mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
        uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
        if (v50[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
        }
        if (v57)
        {
          long long v28 = __p;
          if (__p)
          {
            long long v29 = v56;
            uint64_t v30 = __p;
            if (v56 != __p)
            {
              do
                long long v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
              while (v29 != v28);
              uint64_t v30 = __p;
            }
            uint64_t v56 = v28;
            operator delete(v30);
          }
          uint64_t v17 = v53;
          if (!v53) {
            goto LABEL_96;
          }
          uint64_t v31 = v54;
          long long v19 = v53;
          if (v54 == v53) {
            goto LABEL_95;
          }
          do
          {
            uint64_t v33 = *--v31;
            uint64_t v32 = v33;
            void *v31 = 0;
            if (v33) {
              MEMORY[0x21667D390](v32, 0x1000C8077774924);
            }
          }
          while (v31 != v17);
          goto LABEL_94;
        }
      }
    }
    else
    {
      v48[0] = (void **)"requires attribute 'dilation_rates'";
      __int16 v49 = 259;
      mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
      uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
      if (v50[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
      }
      if (v57)
      {
        unint64_t v22 = __p;
        if (__p)
        {
          long long v23 = v56;
          long long v24 = __p;
          if (v56 != __p)
          {
            do
              long long v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
            while (v23 != v22);
            long long v24 = __p;
          }
          uint64_t v56 = v22;
          operator delete(v24);
        }
        uint64_t v17 = v53;
        if (!v53) {
          goto LABEL_96;
        }
        uint64_t v25 = v54;
        long long v19 = v53;
        if (v54 == v53) {
          goto LABEL_95;
        }
        do
        {
          uint64_t v27 = *--v25;
          uint64_t v26 = v27;
          void *v25 = 0;
          if (v27) {
            MEMORY[0x21667D390](v26, 0x1000C8077774924);
          }
        }
        while (v25 != v17);
        goto LABEL_94;
      }
    }
  }
  else
  {
    v48[0] = (void **)"requires attribute 'data_layout'";
    __int16 v49 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
    uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
    if (v50[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
    }
    if (v57)
    {
      uint64_t v14 = __p;
      if (__p)
      {
        uint64_t v15 = v56;
        uint64_t v16 = __p;
        if (v56 != __p)
        {
          do
            uint64_t v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
          while (v15 != v14);
          uint64_t v16 = __p;
        }
        uint64_t v56 = v14;
        operator delete(v16);
      }
      uint64_t v17 = v53;
      if (!v53) {
        goto LABEL_96;
      }
      long long v18 = v54;
      long long v19 = v53;
      if (v54 == v53) {
        goto LABEL_95;
      }
      do
      {
        uint64_t v21 = *--v18;
        uint64_t v20 = v21;
        *long long v18 = 0;
        if (v21) {
          MEMORY[0x21667D390](v20, 0x1000C8077774924);
        }
      }
      while (v18 != v17);
      goto LABEL_94;
    }
  }
  return v13;
}

void mlir::mps::Conv3DOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::Conv3DWeightsGradientOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n)) {
        return 0;
      }
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n)) {
        return a2[1];
      }
      if (memcmp(__s1, "weights_layout", __n)) {
        return 0;
      }
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv3DWeightsGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  uint64_t v7 = (void *)result;
  switch(__n)
  {
    case 6uLL:
      uint64_t result = memcmp(__s1, "groups", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v14 = a4;
          }
          else {
            uint64_t v14 = 0;
          }
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          *(void *)uint64_t result = v10;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "weights_layout", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
              uint64_t v12 = a4;
            }
            else {
              uint64_t v12 = 0;
            }
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v15 = a4;
        }
        else {
          uint64_t v15 = 0;
        }
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v13 = a4;
          }
          else {
            uint64_t v13 = 0;
          }
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::Conv3DWeightsGradientOp::readProperties(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::Conv3DWeightsGradientOp::verifyInvariantsImpl(mlir::mps::Conv3DWeightsGradientOp *this)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v3 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v3 = 0;
  }
  unint64_t v4 = *(_DWORD **)v3;
  if (*(void *)v3)
  {
    uint64_t v5 = *(void **)(v3 + 8);
    if (v5)
    {
      unint64_t v6 = *(void ***)(v3 + 16);
      if (v6)
      {
        uint64_t v7 = *(void ***)(v3 + 24);
        if (v7)
        {
          uint64_t v8 = *(void *)(v3 + 32);
          if (v8)
          {
            long long v9 = *(void **)(v3 + 40);
            if (v9)
            {
              uint64_t v10 = *(_DWORD **)(v3 + 48);
              if (v10)
              {
                v50[0] = v2;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v9, (void **)"strides", (const char *)7, (void (*)(void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v5, (void **)"dilation_rates", (const char *)0xE, (void (*)(void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(v6, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(v4, (void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0; {
                v50[0] = *(void *)this;
                }
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(v10, (void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24)+ 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56)+ 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 1u)
                  || !mlir::mps::__mlir_ods_local_type_constraint_MPSOps16(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88)+ 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 2u))
                {
                  return 0;
                }
                if (*(_DWORD *)(*(void *)this + 36)) {
                  uint64_t v11 = *(void *)this - 16;
                }
                else {
                  uint64_t v11 = 0;
                }
                uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps14(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
              }
              BOOL v47 = "requires attribute 'weights_layout'";
            }
            else
            {
              BOOL v47 = "requires attribute 'strides'";
            }
            v48[0] = (void **)v47;
            __int16 v49 = 259;
            mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
            uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v50);
            return v13;
          }
          v48[0] = (void **)"requires attribute 'padding_style'";
          __int16 v49 = 259;
          mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
          uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          }
          if (v57)
          {
            uint64_t v40 = __p;
            if (__p)
            {
              uint64_t v41 = v56;
              uint64_t v42 = __p;
              if (v56 != __p)
              {
                do
                  uint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
                while (v41 != v40);
                uint64_t v42 = __p;
              }
              uint64_t v56 = v40;
              operator delete(v42);
            }
            uint64_t v17 = v53;
            if (!v53) {
              goto LABEL_97;
            }
            unint64_t v43 = v54;
            long long v19 = v53;
            if (v54 == v53)
            {
LABEL_96:
              uint64_t v54 = v17;
              operator delete(v19);
LABEL_97:
              if (v51 != &v52) {
                free(v51);
              }
              return v13;
            }
            do
            {
              uint64_t v45 = *--v43;
              uint64_t v44 = v45;
              void *v43 = 0;
              if (v45) {
                MEMORY[0x21667D390](v44, 0x1000C8077774924);
              }
            }
            while (v43 != v17);
LABEL_95:
            long long v19 = v53;
            goto LABEL_96;
          }
        }
        else
        {
          v48[0] = (void **)"requires attribute 'groups'";
          __int16 v49 = 259;
          mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
          uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          }
          if (v57)
          {
            uint64_t v34 = __p;
            if (__p)
            {
              uint64_t v35 = v56;
              unsigned int v36 = __p;
              if (v56 != __p)
              {
                do
                  uint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
                while (v35 != v34);
                unsigned int v36 = __p;
              }
              uint64_t v56 = v34;
              operator delete(v36);
            }
            uint64_t v17 = v53;
            if (!v53) {
              goto LABEL_97;
            }
            unsigned int v37 = v54;
            long long v19 = v53;
            if (v54 == v53) {
              goto LABEL_96;
            }
            do
            {
              uint64_t v39 = *--v37;
              uint64_t v38 = v39;
              void *v37 = 0;
              if (v39) {
                MEMORY[0x21667D390](v38, 0x1000C8077774924);
              }
            }
            while (v37 != v17);
            goto LABEL_95;
          }
        }
      }
      else
      {
        v48[0] = (void **)"requires attribute 'explicit_padding'";
        __int16 v49 = 259;
        mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
        uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
        if (v50[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
        }
        if (v57)
        {
          long long v28 = __p;
          if (__p)
          {
            long long v29 = v56;
            uint64_t v30 = __p;
            if (v56 != __p)
            {
              do
                long long v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
              while (v29 != v28);
              uint64_t v30 = __p;
            }
            uint64_t v56 = v28;
            operator delete(v30);
          }
          uint64_t v17 = v53;
          if (!v53) {
            goto LABEL_97;
          }
          uint64_t v31 = v54;
          long long v19 = v53;
          if (v54 == v53) {
            goto LABEL_96;
          }
          do
          {
            uint64_t v33 = *--v31;
            uint64_t v32 = v33;
            void *v31 = 0;
            if (v33) {
              MEMORY[0x21667D390](v32, 0x1000C8077774924);
            }
          }
          while (v31 != v17);
          goto LABEL_95;
        }
      }
    }
    else
    {
      v48[0] = (void **)"requires attribute 'dilation_rates'";
      __int16 v49 = 259;
      mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
      uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
      if (v50[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
      }
      if (v57)
      {
        unint64_t v22 = __p;
        if (__p)
        {
          long long v23 = v56;
          long long v24 = __p;
          if (v56 != __p)
          {
            do
              long long v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
            while (v23 != v22);
            long long v24 = __p;
          }
          uint64_t v56 = v22;
          operator delete(v24);
        }
        uint64_t v17 = v53;
        if (!v53) {
          goto LABEL_97;
        }
        uint64_t v25 = v54;
        long long v19 = v53;
        if (v54 == v53) {
          goto LABEL_96;
        }
        do
        {
          uint64_t v27 = *--v25;
          uint64_t v26 = v27;
          void *v25 = 0;
          if (v27) {
            MEMORY[0x21667D390](v26, 0x1000C8077774924);
          }
        }
        while (v25 != v17);
        goto LABEL_95;
      }
    }
  }
  else
  {
    v48[0] = (void **)"requires attribute 'data_layout'";
    __int16 v49 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v48, (uint64_t)v50);
    uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
    if (v50[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
    }
    if (v57)
    {
      uint64_t v14 = __p;
      if (__p)
      {
        uint64_t v15 = v56;
        uint64_t v16 = __p;
        if (v56 != __p)
        {
          do
            uint64_t v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
          while (v15 != v14);
          uint64_t v16 = __p;
        }
        uint64_t v56 = v14;
        operator delete(v16);
      }
      uint64_t v17 = v53;
      if (!v53) {
        goto LABEL_97;
      }
      long long v18 = v54;
      long long v19 = v53;
      if (v54 == v53) {
        goto LABEL_96;
      }
      do
      {
        uint64_t v21 = *--v18;
        uint64_t v20 = v21;
        *long long v18 = 0;
        if (v21) {
          MEMORY[0x21667D390](v20, 0x1000C8077774924);
        }
      }
      while (v18 != v17);
      goto LABEL_95;
    }
  }
  return v13;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps16(uint64_t a1, void **a2, void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v74 = *MEMORY[0x263EF8340];
  uint64_t v10 = *a2;
  uint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v63[0] = a2;
    v63[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v63);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)) {
      return 1;
    }
    uint64_t v10 = *a2;
    uint64_t v17 = (void *)*((void *)*a2 + 17);
    if (v17 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v17 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_17;
    }
  }
  else if (v11 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id {
         && v11 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  }
  {
    goto LABEL_17;
  }
  uint64_t v56 = a2;
  uint64_t v57 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v56);
  if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32))
  {
    uint64_t v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    uint64_t v60 = a2;
    uint64_t v61 = v13;
    Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v60);
    uint64_t v73 = 5;
    if (v15 == 1 && *Shape == v73) {
      return 1;
    }
  }
LABEL_17:
  __int16 v58 = 261;
  uint64_t v56 = a3;
  uint64_t v57 = a4;
  mlir::Operation::emitOpError(a1, &v56, (uint64_t)v63);
  if (v63[0])
  {
    LODWORD(v60) = 3;
    uint64_t v61 = (uint64_t)" #";
    uint64_t v62 = 2;
    long long v19 = &v60;
    uint64_t v20 = (char *)v64;
    if (v65 >= v66)
    {
      unint64_t v46 = v65 + 1;
      if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
      {
        int64_t v52 = (char *)&v60 - (unsigned char *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v46, 24);
        uint64_t v20 = (char *)v64;
        long long v19 = (void ***)((char *)v64 + v52);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v46, 24);
        long long v19 = &v60;
        uint64_t v20 = (char *)v64;
      }
    }
    uint64_t v21 = &v20[24 * v65];
    long long v22 = *(_OWORD *)v19;
    *((void *)v21 + 2) = v19[2];
    *(_OWORD *)uint64_t v21 = v22;
    uint64_t v23 = ++v65;
    if (v63[0])
    {
      LODWORD(v60) = 5;
      uint64_t v61 = a5;
      long long v24 = &v60;
      uint64_t v25 = (char *)v64;
      if (v23 >= v66)
      {
        unint64_t v47 = v23 + 1;
        BOOL v48 = (char *)v64 + 24 * v23 > (char *)&v60;
        if (v64 <= &v60 && v48)
        {
          int64_t v53 = (char *)&v60 - (unsigned char *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
          uint64_t v25 = (char *)v64;
          long long v24 = (void ***)((char *)v64 + v53);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
          long long v24 = &v60;
          uint64_t v25 = (char *)v64;
        }
      }
      uint64_t v26 = &v25[24 * v65];
      long long v27 = *(_OWORD *)v24;
      *((void *)v26 + 2) = v24[2];
      *(_OWORD *)uint64_t v26 = v27;
      uint64_t v28 = ++v65;
      if (v63[0])
      {
        LODWORD(v60) = 3;
        uint64_t v61 = (uint64_t)" must be unranked tensor of 32-bit signed integer values or static-shape defined tensor with shap"
                       "e equal to [5], but got ";
        uint64_t v62 = 121;
        long long v29 = &v60;
        uint64_t v30 = (char *)v64;
        if (v28 >= v66)
        {
          unint64_t v49 = v28 + 1;
          BOOL v50 = (char *)v64 + 24 * v28 > (char *)&v60;
          if (v64 <= &v60 && v50)
          {
            int64_t v54 = (char *)&v60 - (unsigned char *)v64;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
            uint64_t v30 = (char *)v64;
            long long v29 = (void ***)((char *)v64 + v54);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
            long long v29 = &v60;
            uint64_t v30 = (char *)v64;
          }
        }
        uint64_t v31 = &v30[24 * v65];
        long long v32 = *(_OWORD *)v29;
        *((void *)v31 + 2) = v29[2];
        *(_OWORD *)uint64_t v31 = v32;
        ++v65;
        if (v63[0])
        {
          uint64_t v33 = &v60;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v60, (uint64_t)a2);
          uint64_t v34 = (char *)v64;
          if (v65 >= v66)
          {
            unint64_t v51 = v65 + 1;
            if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
            {
              int64_t v55 = (char *)&v60 - (unsigned char *)v64;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v51, 24);
              uint64_t v34 = (char *)v64;
              uint64_t v33 = (void ***)((char *)v64 + v55);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v51, 24);
              uint64_t v33 = &v60;
              uint64_t v34 = (char *)v64;
            }
          }
          uint64_t v35 = &v34[24 * v65];
          long long v36 = *(_OWORD *)v33;
          *((void *)v35 + 2) = v33[2];
          *(_OWORD *)uint64_t v35 = v36;
          ++v65;
        }
      }
    }
  }
  uint64_t v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v63);
  if (v63[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
  }
  if (v72)
  {
    unsigned int v37 = __p;
    if (__p)
    {
      uint64_t v38 = v71;
      uint64_t v39 = __p;
      if (v71 != __p)
      {
        do
          uint64_t v38 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v38 - 1);
        while (v38 != v37);
        uint64_t v39 = __p;
      }
      uint64_t v71 = v37;
      operator delete(v39);
    }
    uint64_t v40 = v68;
    if (v68)
    {
      uint64_t v41 = v69;
      uint64_t v42 = v68;
      if (v69 != v68)
      {
        do
        {
          uint64_t v44 = *--v41;
          uint64_t v43 = v44;
          *uint64_t v41 = 0;
          if (v44) {
            MEMORY[0x21667D390](v43, 0x1000C8077774924);
          }
        }
        while (v41 != v40);
        uint64_t v42 = v68;
      }
      unint64_t v69 = v40;
      operator delete(v42);
    }
    if (v64 != v67) {
      free(v64);
    }
  }
  return v16;
}

void mlir::mps::Conv3DWeightsGradientOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::CosOpGenericAdaptorBase::CosOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.cos", 7, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::CosOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::CoshOpGenericAdaptorBase::CoshOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.cosh", 8, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::CoshOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::CostVolumeOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v83 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v69 = v6;
  if (!v6)
  {
    a3(v73, a4);
    if (v73[0])
    {
      LODWORD(v70) = 3;
      uint64_t v71 = "expected DictionaryAttr to set properties";
      uint64_t v72 = 41;
      uint64_t v28 = &v70;
      long long v29 = (char *)v74;
      if (v75 >= v76)
      {
        unint64_t v59 = v75 + 1;
        if (v74 <= &v70 && (char *)v74 + 24 * v75 > (char *)&v70)
        {
          int64_t v64 = (char *)&v70 - (unsigned char *)v74;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v59, 24);
          long long v29 = (char *)v74;
          uint64_t v28 = (uint64_t *)((char *)v74 + v64);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v59, 24);
          uint64_t v28 = &v70;
          long long v29 = (char *)v74;
        }
      }
      uint64_t v30 = &v29[24 * v75];
      long long v31 = *(_OWORD *)v28;
      *((void *)v30 + 2) = v28[2];
      *(_OWORD *)uint64_t v30 = v31;
      ++v75;
      if (v73[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v73);
      }
    }
    if (!v82) {
      return 0;
    }
    long long v32 = __p;
    if (__p)
    {
      uint64_t v33 = v81;
      uint64_t v34 = __p;
      if (v81 != __p)
      {
        do
          uint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        uint64_t v34 = __p;
      }
      int64_t v81 = v32;
      operator delete(v34);
    }
    uint64_t v23 = v78;
    if (!v78) {
      goto LABEL_64;
    }
    uint64_t v35 = v79;
    uint64_t v25 = v78;
    if (v79 == v78)
    {
LABEL_63:
      unint64_t v79 = v23;
      operator delete(v25);
LABEL_64:
      if (v74 != v77) {
        free(v74);
      }
      return 0;
    }
    do
    {
      uint64_t v37 = *--v35;
      uint64_t v36 = v37;
      void *v35 = 0;
      if (v37) {
        MEMORY[0x21667D390](v36, 0x1000C8077774924);
      }
    }
    while (v35 != v23);
LABEL_62:
    uint64_t v25 = v78;
    goto LABEL_63;
  }
  uint64_t v8 = (void *)mlir::DictionaryAttr::get((uint64_t)&v69, "coord_is_x_only", 0xFuLL);
  if (!v8) {
    goto LABEL_8;
  }
  uint64_t v9 = (uint64_t)v8;
  if (!mlir::BoolAttr::classof(v8))
  {
    a3(v73, a4);
    if (v73[0])
    {
      LODWORD(v70) = 3;
      uint64_t v72 = 60;
      uint64_t v38 = &v70;
      uint64_t v39 = (char *)v74;
      if (v75 >= v76)
      {
        unint64_t v60 = v75 + 1;
        if (v74 <= &v70 && (char *)v74 + 24 * v75 > (char *)&v70)
        {
          int64_t v65 = (char *)&v70 - (unsigned char *)v74;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v60, 24);
          uint64_t v39 = (char *)v74;
          uint64_t v38 = (uint64_t *)((char *)v74 + v65);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v60, 24);
          uint64_t v38 = &v70;
          uint64_t v39 = (char *)v74;
        }
      }
      uint64_t v40 = &v39[24 * v75];
      long long v41 = *(_OWORD *)v38;
      *((void *)v40 + 2) = v38[2];
      *(_OWORD *)uint64_t v40 = v41;
      ++v75;
      if (v73[0])
      {
        uint64_t v42 = &v70;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v70, v9);
        uint64_t v43 = (char *)v74;
        if (v75 >= v76)
        {
          unint64_t v62 = v75 + 1;
          if (v74 <= &v70 && (char *)v74 + 24 * v75 > (char *)&v70)
          {
            int64_t v67 = (char *)&v70 - (unsigned char *)v74;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v62, 24);
            uint64_t v43 = (char *)v74;
            uint64_t v42 = (uint64_t *)((char *)v74 + v67);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v62, 24);
            uint64_t v42 = &v70;
            uint64_t v43 = (char *)v74;
          }
        }
        uint64_t v44 = &v43[24 * v75];
        long long v45 = *(_OWORD *)v42;
        *((void *)v44 + 2) = v42[2];
        *(_OWORD *)uint64_t v44 = v45;
        ++v75;
        if (v73[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v73);
        }
      }
    }
    if (!v82) {
      return 0;
    }
    unint64_t v46 = __p;
    if (__p)
    {
      unint64_t v47 = v81;
      BOOL v48 = __p;
      if (v81 != __p)
      {
        do
          unint64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        BOOL v48 = __p;
      }
      int64_t v81 = v46;
      operator delete(v48);
    }
    uint64_t v23 = v78;
    if (!v78) {
      goto LABEL_64;
    }
    unint64_t v49 = v79;
    uint64_t v25 = v78;
    if (v79 == v78) {
      goto LABEL_63;
    }
    do
    {
      uint64_t v51 = *--v49;
      uint64_t v50 = v51;
      *unint64_t v49 = 0;
      if (v51) {
        MEMORY[0x21667D390](v50, 0x1000C8077774924);
      }
    }
    while (v49 != v23);
    goto LABEL_62;
  }
  *a1 = v9;
LABEL_8:
  uint64_t v10 = mlir::DictionaryAttr::get((uint64_t)&v69, "data_layout", 0xBuLL);
  if (v10)
  {
    uint64_t v11 = v10;
    if (*(_UNKNOWN **)(*(void *)v10 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
    {
      a3(v73, a4);
      if (v73[0])
      {
        LODWORD(v70) = 3;
        uint64_t v72 = 56;
        uint64_t v12 = &v70;
        uint64_t v13 = (char *)v74;
        if (v75 >= v76)
        {
          unint64_t v61 = v75 + 1;
          if (v74 <= &v70 && (char *)v74 + 24 * v75 > (char *)&v70)
          {
            int64_t v66 = (char *)&v70 - (unsigned char *)v74;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v61, 24);
            uint64_t v13 = (char *)v74;
            uint64_t v12 = (uint64_t *)((char *)v74 + v66);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v61, 24);
            uint64_t v12 = &v70;
            uint64_t v13 = (char *)v74;
          }
        }
        uint64_t v14 = &v13[24 * v75];
        long long v15 = *(_OWORD *)v12;
        *((void *)v14 + 2) = v12[2];
        *(_OWORD *)uint64_t v14 = v15;
        ++v75;
        if (v73[0])
        {
          uint64_t v16 = &v70;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v70, v11);
          uint64_t v17 = (char *)v74;
          if (v75 >= v76)
          {
            unint64_t v63 = v75 + 1;
            if (v74 <= &v70 && (char *)v74 + 24 * v75 > (char *)&v70)
            {
              int64_t v68 = (char *)&v70 - (unsigned char *)v74;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v63, 24);
              uint64_t v17 = (char *)v74;
              uint64_t v16 = (uint64_t *)((char *)v74 + v68);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v63, 24);
              uint64_t v16 = &v70;
              uint64_t v17 = (char *)v74;
            }
          }
          long long v18 = &v17[24 * v75];
          long long v19 = *(_OWORD *)v16;
          *((void *)v18 + 2) = v16[2];
          *(_OWORD *)long long v18 = v19;
          ++v75;
          if (v73[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v73);
          }
        }
      }
      if (!v82) {
        return 0;
      }
      uint64_t v20 = __p;
      if (__p)
      {
        uint64_t v21 = v81;
        long long v22 = __p;
        if (v81 != __p)
        {
          do
            uint64_t v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
          while (v21 != v20);
          long long v22 = __p;
        }
        int64_t v81 = v20;
        operator delete(v22);
      }
      uint64_t v23 = v78;
      if (!v78) {
        goto LABEL_64;
      }
      long long v24 = v79;
      uint64_t v25 = v78;
      if (v79 == v78) {
        goto LABEL_63;
      }
      do
      {
        uint64_t v27 = *--v24;
        uint64_t v26 = v27;
        *long long v24 = 0;
        if (v27) {
          MEMORY[0x21667D390](v26, 0x1000C8077774924);
        }
      }
      while (v24 != v23);
      goto LABEL_62;
    }
    a1[1] = v10;
  }
  uint64_t v52 = mlir::DictionaryAttr::get((uint64_t)&v69, "normalize_coordinates", 0x15uLL);
  uint64_t v70 = v52;
  if (!v52)
  {
LABEL_71:
    uint64_t v54 = mlir::DictionaryAttr::get((uint64_t)&v69, "relative_coordinates", 0x14uLL);
    uint64_t v70 = v54;
    if (v54)
    {
      if (*(_UNKNOWN **)(*(void *)v54 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
      {
        a3(v73, a4);
        goto LABEL_86;
      }
      a1[3] = v54;
    }
    uint64_t v55 = mlir::DictionaryAttr::get((uint64_t)&v69, "similarity_type", 0xFuLL);
    uint64_t v70 = v55;
    if (v55)
    {
      if (*(_UNKNOWN **)(*(void *)v55 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id)
      {
        a3(v73, a4);
        goto LABEL_86;
      }
      a1[4] = v55;
    }
    uint64_t v56 = mlir::DictionaryAttr::get((uint64_t)&v69, "window_height", 0xDuLL);
    uint64_t v70 = v56;
    if (v56)
    {
      if (*(_UNKNOWN **)(*(void *)v56 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        a3(v73, a4);
        goto LABEL_86;
      }
      a1[5] = v56;
    }
    uint64_t v57 = mlir::DictionaryAttr::get((uint64_t)&v69, "window_width", 0xCuLL);
    uint64_t v70 = v57;
    if (v57)
    {
      if (*(_UNKNOWN **)(*(void *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        a3(v73, a4);
        goto LABEL_86;
      }
      a1[6] = v57;
    }
    return 1;
  }
  if (*(_UNKNOWN **)(*(void *)v52 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    a1[2] = v52;
    goto LABEL_71;
  }
  a3(v73, a4);
LABEL_86:
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v53, &v70);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v73);
  return 0;
}

uint64_t mlir::mps::CostVolumeOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v51[6] = *MEMORY[0x263EF8340];
  BOOL v48 = a1;
  unint64_t v49 = v51;
  uint64_t v50 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v48, (uint64_t)"coord_is_x_only", 15, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v50;
  if (v50 >= HIDWORD(v50))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
    unsigned int v6 = v50;
  }
  uint64_t v7 = (uint64_t *)((char *)v49 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v50 + 1;
  LODWORD(v50) = v50 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"data_layout", 11, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v13 = v50;
    }
    uint64_t v14 = (uint64_t *)((char *)v49 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"normalize_coordinates", 21, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v19 = v50;
    }
    uint64_t v20 = (uint64_t *)((char *)v49 + 16 * v19);
    uint64_t *v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"relative_coordinates", 20, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v25 = v50;
    }
    uint64_t v26 = (uint64_t *)((char *)v49 + 16 * v25);
    uint64_t *v26 = v22;
    v26[1] = v24;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"similarity_type", 15, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v31 = v50;
    }
    long long v32 = (uint64_t *)((char *)v49 + 16 * v31);
    uint64_t *v32 = v28;
    v32[1] = v30;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v33 = a2[5];
  if (v33)
  {
    uint64_t v34 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"window_height", 13, v33);
    uint64_t v36 = v35;
    unsigned int v37 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v37 = v50;
    }
    uint64_t v38 = (uint64_t *)((char *)v49 + 16 * v37);
    uint64_t *v38 = v34;
    v38[1] = v36;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v39 = a2[6];
  if (v39)
  {
    uint64_t v40 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"window_width", 12, v39);
    uint64_t v42 = v41;
    unsigned int v43 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v43 = v50;
    }
    uint64_t v44 = (uint64_t *)((char *)v49 + 16 * v43);
    uint64_t *v44 = v40;
    v44[1] = v42;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  long long v45 = v49;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v49 == v51) {
      return DictionaryAttr;
    }
    goto LABEL_32;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v48, (uint64_t *)v49, v8);
  long long v45 = v49;
  if (v49 != v51) {
LABEL_32:
  }
    free(v45);
  return DictionaryAttr;
}

uint64_t mlir::mps::CostVolumeOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 0xBuLL:
      if (memcmp(__s1, "data_layout", __n)) {
        return 0;
      }
      return a2[1];
    case 0xCuLL:
      if (memcmp(__s1, "window_width", __n)) {
        return 0;
      }
      return a2[6];
    case 0xDuLL:
      if (memcmp(__s1, "window_height", __n)) {
        return 0;
      }
      return a2[5];
    case 0xEuLL:
    case 0x10uLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x13uLL:
      return 0;
    case 0xFuLL:
      if (*(void *)__s1 == 0x73695F64726F6F63 && *(void *)(__s1 + 7) == 0x796C6E6F5F785F73) {
        return *a2;
      }
      if (memcmp(__s1, "similarity_type", __n)) {
        return 0;
      }
      return a2[4];
    case 0x14uLL:
      if (memcmp(__s1, "relative_coordinates", __n)) {
        return 0;
      }
      return a2[3];
    case 0x15uLL:
      if (memcmp(__s1, "normalize_coordinates", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::CostVolumeOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, void *a4)
{
  uint64_t v5 = (void *)result;
  switch(a3)
  {
    case 0xBuLL:
      uint64_t result = memcmp(__s1, "data_layout", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v12 = a4;
          }
          else {
            uint64_t v12 = 0;
          }
          v5[1] = v12;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0xCuLL:
      uint64_t result = memcmp(__s1, "window_width", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            unsigned int v6 = a4;
          }
          else {
            unsigned int v6 = 0;
          }
          v5[6] = v6;
        }
        else
        {
          v5[6] = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "window_height", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v7 = a4;
          }
          else {
            uint64_t v7 = 0;
          }
          v5[5] = v7;
        }
        else
        {
          v5[5] = 0;
        }
      }
      break;
    case 0xFuLL:
      if (*(void *)__s1 == 0x73695F64726F6F63 && *(void *)(__s1 + 7) == 0x796C6E6F5F785F73)
      {
        if (a4)
        {
          uint64_t result = mlir::BoolAttr::classof(a4);
          if (result) {
            unsigned int v13 = a4;
          }
          else {
            unsigned int v13 = 0;
          }
          *uint64_t v5 = v13;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      else
      {
        uint64_t result = memcmp(__s1, "similarity_type", a3);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id) {
              uint64_t v9 = a4;
            }
            else {
              uint64_t v9 = 0;
            }
            v5[4] = v9;
          }
          else
          {
            v5[4] = 0;
          }
        }
      }
      break;
    case 0x14uLL:
      uint64_t result = memcmp(__s1, "relative_coordinates", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          v5[3] = v10;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0x15uLL:
      uint64_t result = memcmp(__s1, "normalize_coordinates", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v5[2] = v11;
        }
        else
        {
          v5[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::CostVolumeOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"coord_is_x_only", 15, *a2);
  }
  uint64_t v5 = a2[1];
  if (v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"data_layout", 11, v5);
  }
  uint64_t v6 = a2[2];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"normalize_coordinates", 21, v6);
  }
  uint64_t v7 = a2[3];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"relative_coordinates", 20, v7);
  }
  uint64_t v8 = a2[4];
  if (v8) {
    mlir::NamedAttrList::append(a3, (uint64_t)"similarity_type", 15, v8);
  }
  uint64_t v9 = a2[5];
  if (v9) {
    mlir::NamedAttrList::append(a3, (uint64_t)"window_height", 13, v9);
  }
  uint64_t v10 = a2[6];
  if (v10)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"window_width", 12, v10);
  }
}

BOOL mlir::mps::CostVolumeOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = (void *)mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps2(v8, (void **)"coord_is_x_only", (const char *)0xF, a3, a4))
  {
    uint64_t v9 = (_DWORD *)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(v9, (void **)"data_layout", (const char *)0xB, a3, a4))
    {
      uint64_t v10 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v10, (void **)"normalize_coordinates", (const char *)0x15, a3, a4))
      {
        uint64_t v11 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v11, (void **)"relative_coordinates", (const char *)0x14, a3, a4))
        {
          uint64_t v12 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps16(v12, (void **)"similarity_type", (const char *)0xF, a3, a4))
          {
            unsigned int v13 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v13, (void **)"window_height", (const char *)0xD, a3, a4))
            {
              uint64_t v14 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v14, (void **)"window_width", (const char *)0xC, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps16(uint64_t a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      uint64_t v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid SimilarityType";
        uint64_t v31 = 52;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        unsigned int v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)unsigned int v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = __p;
    if (__p)
    {
      uint64_t v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          uint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      uint64_t v42 = v16;
      operator delete(v18);
    }
    unsigned int v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      uint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        uint64_t v21 = v39;
      }
      uint64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

BOOL mlir::mps::CostVolumeOp::readProperties(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::BoolAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 1)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 2)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 3)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::SimilarityTypeAttr>(a1, v3 + 4)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3 + 5)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::SimilarityTypeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  uint64_t v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    uint64_t v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        uint64_t v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  uint64_t v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::SimilarityTypeAttr]";
  unint64_t v41 = 79;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    uint64_t v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      long long v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          long long v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unsigned int v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unsigned int v19 = (char *)v46;
            uint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unsigned int v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      uint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      uint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      uint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

mlir::MLIRContext *mlir::mps::CostVolumeOp::populateDefaultProperties(uint64_t a1, void *a2)
{
  uint64_t v12 = *(void **)(a1 + 8);
  uint64_t result = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  unint64_t v10 = result;
  if (a2[5])
  {
    if (a2[6]) {
      goto LABEL_3;
    }
  }
  else
  {
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)&v10, 0x40u, 0);
    uint64_t result = (mlir::MLIRContext *)mlir::Builder::getIntegerAttr((uint64_t)&v10, IntegerType, 1uLL);
    a2[5] = result;
    if (a2[6])
    {
LABEL_3:
      if (a2[4]) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  uint64_t v5 = mlir::Builder::getIntegerType((mlir::Builder *)&v10, 0x40u, 0);
  uint64_t result = (mlir::MLIRContext *)mlir::Builder::getIntegerAttr((uint64_t)&v10, v5, 1uLL);
  a2[6] = result;
  if (a2[4])
  {
LABEL_4:
    if (a2[1]) {
      return result;
    }
LABEL_9:
    uint64_t v8 = v10;
    unsigned int v11 = 0;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v10);
    uint64_t v12 = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
    unint64_t v13 = v8;
    uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v11);
    a2[1] = result;
    return result;
  }
LABEL_8:
  uint64_t v6 = v10;
  unsigned int v11 = 0;
  uint64_t v7 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v10);
  uint64_t v12 = &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id;
  unint64_t v13 = v6;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::SimilarityTypeAttrStorage,mlir::mps::SimilarityType>(v7, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25SimilarityTypeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18SimilarityTypeAttrEJNS2_14SimilarityTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id, &v11);
  a2[4] = result;
  if (!a2[1]) {
    goto LABEL_9;
  }
  return result;
}

BOOL mlir::mps::CostVolumeOp::verifyInvariantsImpl(mlir::mps::CostVolumeOp *this)
{
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v3 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = *(void **)v3;
  uint64_t v5 = *(_DWORD **)(v3 + 8);
  uint64_t v6 = *(void *)(v3 + 16);
  uint64_t v7 = *(void *)(v3 + 24);
  uint64_t v8 = *(void *)(v3 + 32);
  long long v9 = *(void ***)(v3 + 40);
  unint64_t v10 = *(void ***)(v3 + 48);
  uint64_t v14 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v6, (void **)"normalize_coordinates", (const char *)0x15, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  uint64_t v14 = *(void *)this;
  }
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (void **)"relative_coordinates", (const char *)0x14, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  uint64_t v14 = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v9, (void **)"window_height", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  uint64_t v14 = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v10, (void **)"window_width", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  uint64_t v14 = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps16(v8, (void **)"similarity_type", (const char *)0xF, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps16(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  uint64_t v14 = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(v5, (void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  uint64_t v14 = *(void *)this;
  }
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps2(v4, (void **)"coord_is_x_only", (const char *)0xF, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps17(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps17(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps17(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps17(*(void *)this,
                           (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8),
                           (void **)"operand",
                           7,
                           2u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v11 = *(void *)this - 16;
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps17(uint64_t a1, void **a2, void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  unint64_t v10 = *a2;
  uint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v61[0] = a2;
    v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
      return 1;
    }
    unint64_t v10 = *a2;
    if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_3:
      uint64_t v53 = a2;
      uint64_t v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53)) {
        goto LABEL_14;
      }
      uint64_t v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      __int16 v58 = a2;
      uint64_t v59 = v12;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v58);
      if (v13 != 4) {
        goto LABEL_14;
      }
      uint64_t v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v56[0] = a2;
      v56[1] = v14;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
      if (!mlir::Type::isF16((mlir::Type *)&OperandRange)
        && !mlir::Type::isF32((mlir::Type *)&OperandRange)
        && !mlir::Type::isBF16((mlir::Type *)&OperandRange))
      {
        goto LABEL_14;
      }
      return 1;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    goto LABEL_3;
  }
LABEL_14:
  __int16 v55 = 261;
  uint64_t v53 = a3;
  uint64_t v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    uint64_t v59 = (uint64_t)" #";
    uint64_t v60 = 2;
    uint64_t v16 = &v58;
    long long v17 = (char *)v62;
    if (v63 >= v64)
    {
      unint64_t v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        int64_t v49 = (char *)&v58 - (unsigned char *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        long long v17 = (char *)v62;
        uint64_t v16 = (void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        uint64_t v16 = &v58;
        long long v17 = (char *)v62;
      }
    }
    uint64_t v18 = &v17[24 * v63];
    long long v19 = *(_OWORD *)v16;
    *((void *)v18 + 2) = v16[2];
    *(_OWORD *)uint64_t v18 = v19;
    uint64_t v20 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      uint64_t v59 = a5;
      long long v21 = &v58;
      uint64_t v22 = (char *)v62;
      if (v20 >= v64)
      {
        unint64_t v44 = v20 + 1;
        BOOL v45 = (char *)v62 + 24 * v20 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          int64_t v50 = (char *)&v58 - (unsigned char *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          uint64_t v22 = (char *)v62;
          long long v21 = (void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          long long v21 = &v58;
          uint64_t v22 = (char *)v62;
        }
      }
      uint64_t v23 = &v22[24 * v63];
      long long v24 = *(_OWORD *)v21;
      *((void *)v23 + 2) = v21[2];
      *(_OWORD *)uint64_t v23 = v24;
      uint64_t v25 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        uint64_t v59 = (uint64_t)" must be unranked tensor of floating point values or 4D tensor of floating point values, but got ";
        uint64_t v60 = 97;
        unint64_t v26 = &v58;
        int64_t v27 = (char *)v62;
        if (v25 >= v64)
        {
          unint64_t v46 = v25 + 1;
          BOOL v47 = (char *)v62 + 24 * v25 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            int64_t v51 = (char *)&v58 - (unsigned char *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            int64_t v27 = (char *)v62;
            unint64_t v26 = (void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            unint64_t v26 = &v58;
            int64_t v27 = (char *)v62;
          }
        }
        int64_t v28 = &v27[24 * v63];
        long long v29 = *(_OWORD *)v26;
        *((void *)v28 + 2) = v26[2];
        *(_OWORD *)int64_t v28 = v29;
        ++v63;
        if (v61[0])
        {
          uint64_t v30 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          uint64_t v31 = (char *)v62;
          if (v63 >= v64)
          {
            unint64_t v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              int64_t v52 = (char *)&v58 - (unsigned char *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              uint64_t v31 = (char *)v62;
              uint64_t v30 = (void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              uint64_t v30 = &v58;
              uint64_t v31 = (char *)v62;
            }
          }
          unint64_t v32 = &v31[24 * v63];
          long long v33 = *(_OWORD *)v30;
          *((void *)v32 + 2) = v30[2];
          *(_OWORD *)unint64_t v32 = v33;
          ++v63;
        }
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  }
  if (v70)
  {
    unint64_t v34 = __p;
    if (__p)
    {
      int64_t v35 = v69;
      int64_t v36 = __p;
      if (v69 != __p)
      {
        do
          int64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        int64_t v36 = __p;
      }
      uint64_t v69 = v34;
      operator delete(v36);
    }
    int64_t v37 = v66;
    if (v66)
    {
      uint64_t v38 = v67;
      uint64_t v39 = v66;
      if (v67 != v66)
      {
        do
        {
          uint64_t v41 = *--v38;
          uint64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            MEMORY[0x21667D390](v40, 0x1000C8077774924);
          }
        }
        while (v38 != v37);
        uint64_t v39 = v66;
      }
      int64_t v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65) {
      free(v62);
    }
  }
  return v15;
}

void mlir::mps::CostVolumeOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::CreateComplexOpGenericAdaptorBase::CreateComplexOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.create_complex", 18, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::CreateComplexOp::verifyInvariantsImpl(mlir::mps::CreateComplexOp *this)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps18(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps18(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u))
  {
    return 0;
  }
  uint64_t v2 = *(_DWORD *)(*(void *)this + 36) ? *(void *)this - 16 : 0;
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps19(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0))return 0; {
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(void *)(*(void *)(*(void *)this + 72) + 24));
  }
  if (ElementTypeOrSelf == mlir::getElementTypeOrSelf(*(void *)(*(void *)(*(void *)this + 72) + 56)))
  {
    uint64_t v5 = mlir::getElementTypeOrSelf(*(void *)(*(void *)(*(void *)this + 72) + 56));
    if (v5 == mlir::getElementTypeOrSelf(*(void *)(*(void *)(*(void *)this + 72) + 24))) {
      return 1;
    }
  }
  uint64_t v16 = (void **)"failed to verify that all of {real, imag} have same element type";
  __int16 v17 = 259;
  mlir::OpState::emitOpError((uint64_t *)this, &v16, (uint64_t)v18);
  uint64_t v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v18);
  if (v18[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
  }
  if (v25)
  {
    uint64_t v7 = __p;
    if (__p)
    {
      uint64_t v8 = v24;
      long long v9 = __p;
      if (v24 != __p)
      {
        do
          uint64_t v8 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v8 - 1);
        while (v8 != v7);
        long long v9 = __p;
      }
      long long v24 = v7;
      operator delete(v9);
    }
    unint64_t v10 = v21;
    if (v21)
    {
      uint64_t v11 = v22;
      uint64_t v12 = v21;
      if (v22 != v21)
      {
        do
        {
          uint64_t v14 = *--v11;
          uint64_t v13 = v14;
          void *v11 = 0;
          if (v14) {
            MEMORY[0x21667D390](v13, 0x1000C8077774924);
          }
        }
        while (v11 != v10);
        uint64_t v12 = v21;
      }
      uint64_t v22 = v10;
      operator delete(v12);
    }
    if (v19 != &v20) {
      free(v19);
    }
  }
  return v6;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps18(uint64_t a1, uint64_t a2, void **a3, void **a4, unsigned int a5)
{
  uint64_t v66 = *MEMORY[0x263EF8340];
  uint64_t v10 = *(void *)a2;
  uint64_t v11 = *(void **)(*(void *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isF16((mlir::Type *)v51) || mlir::Type::isF32((mlir::Type *)v51)) {
      return 1;
    }
  }
  __int16 v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    int v53 = 3;
    uint64_t v54 = " #";
    uint64_t v55 = 2;
    uint64_t v14 = &v53;
    uint64_t v15 = (char *)v57;
    if (v58 >= v59)
    {
      unint64_t v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        int64_t v47 = (char *)&v53 - (unsigned char *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        uint64_t v15 = (char *)v57;
        uint64_t v14 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        uint64_t v14 = &v53;
        uint64_t v15 = (char *)v57;
      }
    }
    uint64_t v16 = &v15[24 * v58];
    long long v17 = *(_OWORD *)v14;
    *((void *)v16 + 2) = *((void *)v14 + 2);
    *(_OWORD *)uint64_t v16 = v17;
    uint64_t v18 = ++v58;
    if (v56[0])
    {
      int v53 = 5;
      uint64_t v54 = (const char *)a5;
      long long v19 = &v53;
      uint64_t v20 = (char *)v57;
      if (v18 >= v59)
      {
        unint64_t v42 = v18 + 1;
        BOOL v43 = (char *)v57 + 24 * v18 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          int64_t v48 = (char *)&v53 - (unsigned char *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          uint64_t v20 = (char *)v57;
          long long v19 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          long long v19 = &v53;
          uint64_t v20 = (char *)v57;
        }
      }
      long long v21 = &v20[24 * v58];
      long long v22 = *(_OWORD *)v19;
      *((void *)v21 + 2) = *((void *)v19 + 2);
      *(_OWORD *)long long v21 = v22;
      uint64_t v23 = ++v58;
      if (v56[0])
      {
        int v53 = 3;
        uint64_t v54 = " must be tensor of 16-bit float or 32-bit float values, but got ";
        uint64_t v55 = 64;
        long long v24 = &v53;
        char v25 = (char *)v57;
        if (v23 >= v59)
        {
          unint64_t v44 = v23 + 1;
          BOOL v45 = (char *)v57 + 24 * v23 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            int64_t v49 = (char *)&v53 - (unsigned char *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            char v25 = (char *)v57;
            long long v24 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            long long v24 = &v53;
            char v25 = (char *)v57;
          }
        }
        uint64_t v26 = &v25[24 * v58];
        long long v27 = *(_OWORD *)v24;
        *((void *)v26 + 2) = *((void *)v24 + 2);
        *(_OWORD *)uint64_t v26 = v27;
        ++v58;
        if (v56[0])
        {
          int64_t v28 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          long long v29 = (char *)v57;
          if (v58 >= v59)
          {
            unint64_t v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              int64_t v50 = (char *)&v53 - (unsigned char *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              long long v29 = (char *)v57;
              int64_t v28 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              int64_t v28 = &v53;
              long long v29 = (char *)v57;
            }
          }
          uint64_t v30 = &v29[24 * v58];
          long long v31 = *(_OWORD *)v28;
          *((void *)v30 + 2) = *((void *)v28 + 2);
          *(_OWORD *)uint64_t v30 = v31;
          ++v58;
        }
      }
    }
  }
  uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  }
  if (v65)
  {
    unint64_t v32 = __p;
    if (__p)
    {
      long long v33 = v64;
      unint64_t v34 = __p;
      if (v64 != __p)
      {
        do
          long long v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        unint64_t v34 = __p;
      }
      unsigned int v64 = v32;
      operator delete(v34);
    }
    int64_t v35 = v61;
    if (v61)
    {
      int64_t v36 = v62;
      int64_t v37 = v61;
      if (v62 != v61)
      {
        do
        {
          uint64_t v39 = *--v36;
          uint64_t v38 = v39;
          void *v36 = 0;
          if (v39) {
            MEMORY[0x21667D390](v38, 0x1000C8077774924);
          }
        }
        while (v36 != v35);
        int64_t v37 = v61;
      }
      unint64_t v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60) {
      free(v57);
    }
  }
  return v13;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps19(uint64_t a1, uint64_t a2, void **a3, void **a4, unsigned int a5)
{
  uint64_t v70 = *MEMORY[0x263EF8340];
  uint64_t v10 = *(void *)a2;
  uint64_t v11 = *(void **)(*(void *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v60[0] = a2;
    v60[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v60);
    if (*(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      uint64_t v41 = OperandRange;
      uint64_t v57 = OperandRange;
      v53[0] = (void **)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v57);
      if (mlir::Type::isF16((mlir::Type *)v53)) {
        return 1;
      }
      uint64_t v55 = v41;
      uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v55);
      if (mlir::Type::isF32((mlir::Type *)&Value)) {
        return 1;
      }
    }
  }
  __int16 v54 = 261;
  v53[0] = a3;
  v53[1] = a4;
  mlir::Operation::emitOpError(a1, v53, (uint64_t)v60);
  if (v60[0])
  {
    LODWORD(v57) = 3;
    unsigned int v58 = " #";
    uint64_t v59 = 2;
    uint64_t v14 = &v57;
    uint64_t v15 = (char *)v61;
    if (v62 >= v63)
    {
      unint64_t v43 = v62 + 1;
      if (v61 <= &v57 && (char *)v61 + 24 * v62 > (char *)&v57)
      {
        int64_t v49 = (char *)&v57 - (unsigned char *)v61;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v43, 24);
        uint64_t v15 = (char *)v61;
        uint64_t v14 = (uint64_t *)((char *)v61 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v43, 24);
        uint64_t v14 = &v57;
        uint64_t v15 = (char *)v61;
      }
    }
    uint64_t v16 = &v15[24 * v62];
    long long v17 = *(_OWORD *)v14;
    *((void *)v16 + 2) = v14[2];
    *(_OWORD *)uint64_t v16 = v17;
    uint64_t v18 = ++v62;
    if (v60[0])
    {
      LODWORD(v57) = 5;
      unsigned int v58 = (const char *)a5;
      long long v19 = &v57;
      uint64_t v20 = (char *)v61;
      if (v18 >= v63)
      {
        unint64_t v44 = v18 + 1;
        BOOL v45 = (char *)v61 + 24 * v18 > (char *)&v57;
        if (v61 <= &v57 && v45)
        {
          int64_t v50 = (char *)&v57 - (unsigned char *)v61;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v44, 24);
          uint64_t v20 = (char *)v61;
          long long v19 = (uint64_t *)((char *)v61 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v44, 24);
          long long v19 = &v57;
          uint64_t v20 = (char *)v61;
        }
      }
      long long v21 = &v20[24 * v62];
      long long v22 = *(_OWORD *)v19;
      *((void *)v21 + 2) = v19[2];
      *(_OWORD *)long long v21 = v22;
      uint64_t v23 = ++v62;
      if (v60[0])
      {
        LODWORD(v57) = 3;
        unsigned int v58 = " must be tensor of complex values, but got ";
        uint64_t v59 = 43;
        long long v24 = &v57;
        char v25 = (char *)v61;
        if (v23 >= v63)
        {
          unint64_t v46 = v23 + 1;
          BOOL v47 = (char *)v61 + 24 * v23 > (char *)&v57;
          if (v61 <= &v57 && v47)
          {
            int64_t v51 = (char *)&v57 - (unsigned char *)v61;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v46, 24);
            char v25 = (char *)v61;
            long long v24 = (uint64_t *)((char *)v61 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v46, 24);
            long long v24 = &v57;
            char v25 = (char *)v61;
          }
        }
        uint64_t v26 = &v25[24 * v62];
        long long v27 = *(_OWORD *)v24;
        *((void *)v26 + 2) = v24[2];
        *(_OWORD *)uint64_t v26 = v27;
        ++v62;
        if (v60[0])
        {
          int64_t v28 = &v57;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v57, a2);
          long long v29 = (char *)v61;
          if (v62 >= v63)
          {
            unint64_t v48 = v62 + 1;
            if (v61 <= &v57 && (char *)v61 + 24 * v62 > (char *)&v57)
            {
              int64_t v52 = (char *)&v57 - (unsigned char *)v61;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v48, 24);
              long long v29 = (char *)v61;
              int64_t v28 = (uint64_t *)((char *)v61 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v48, 24);
              int64_t v28 = &v57;
              long long v29 = (char *)v61;
            }
          }
          uint64_t v30 = &v29[24 * v62];
          long long v31 = *(_OWORD *)v28;
          *((void *)v30 + 2) = v28[2];
          *(_OWORD *)uint64_t v30 = v31;
          ++v62;
        }
      }
    }
  }
  uint64_t v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v60);
  if (v60[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v60);
  }
  if (v69)
  {
    long long v33 = __p;
    if (__p)
    {
      unint64_t v34 = v68;
      int64_t v35 = __p;
      if (v68 != __p)
      {
        do
          unint64_t v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
        while (v34 != v33);
        int64_t v35 = __p;
      }
      int64_t v68 = v33;
      operator delete(v35);
    }
    int64_t v36 = v65;
    if (v65)
    {
      int64_t v37 = v66;
      uint64_t v38 = v65;
      if (v66 != v65)
      {
        do
        {
          uint64_t v40 = *--v37;
          uint64_t v39 = v40;
          void *v37 = 0;
          if (v40) {
            MEMORY[0x21667D390](v39, 0x1000C8077774924);
          }
        }
        while (v37 != v36);
        uint64_t v38 = v65;
      }
      uint64_t v66 = v36;
      operator delete(v38);
    }
    if (v61 != v64) {
      free(v61);
    }
  }
  return v32;
}

void mlir::mps::CreateComplexOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::CreateTextureTensorOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v89 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v75 = v6;
  if (!v6)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      unint64_t v77 = "expected DictionaryAttr to set properties";
      uint64_t v78 = 41;
      uint64_t v26 = &v76;
      long long v27 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v63 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v69 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          long long v27 = (char *)v80;
          uint64_t v26 = (int *)((char *)v80 + v69);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          uint64_t v26 = &v76;
          long long v27 = (char *)v80;
        }
      }
      int64_t v28 = &v27[24 * v81];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)int64_t v28 = v29;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      long long v31 = v87;
      uint64_t v32 = __p;
      if (v87 != __p)
      {
        do
          long long v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        uint64_t v32 = __p;
      }
      uint64_t v87 = v30;
      operator delete(v32);
    }
    long long v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    long long v33 = v85;
    uint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_79;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *long long v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_78;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v75, "compressed", 0xAuLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v79, a4);
      if (v79[0])
      {
        int v76 = 3;
        uint64_t v78 = 55;
        uint64_t v10 = &v76;
        uint64_t v11 = (char *)v80;
        if (v81 >= v82)
        {
          unint64_t v64 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            int64_t v70 = (char *)&v76 - (unsigned char *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            uint64_t v11 = (char *)v80;
            uint64_t v10 = (int *)((char *)v80 + v70);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            uint64_t v10 = &v76;
            uint64_t v11 = (char *)v80;
          }
        }
        uint64_t v12 = &v11[24 * v81];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = *((void *)v10 + 2);
        *(_OWORD *)uint64_t v12 = v13;
        ++v81;
        if (v79[0])
        {
          uint64_t v14 = &v76;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v9);
          uint64_t v15 = (char *)v80;
          if (v81 >= v82)
          {
            unint64_t v65 = v81 + 1;
            if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
            {
              int64_t v71 = (char *)&v76 - (unsigned char *)v80;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              uint64_t v15 = (char *)v80;
              uint64_t v14 = (int *)((char *)v80 + v71);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              uint64_t v14 = &v76;
              uint64_t v15 = (char *)v80;
            }
          }
          uint64_t v16 = &v15[24 * v81];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = *((void *)v14 + 2);
          *(_OWORD *)uint64_t v16 = v17;
          ++v81;
          if (v79[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
          }
        }
      }
      if (!v88) {
        return 0;
      }
      uint64_t v18 = __p;
      if (__p)
      {
        long long v19 = v87;
        uint64_t v20 = __p;
        if (v87 != __p)
        {
          do
            long long v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          uint64_t v20 = __p;
        }
        uint64_t v87 = v18;
        operator delete(v20);
      }
      long long v21 = v84;
      if (!v84) {
        goto LABEL_80;
      }
      long long v22 = v85;
      uint64_t v23 = v84;
      if (v85 == v84) {
        goto LABEL_79;
      }
      do
      {
        uint64_t v25 = *--v22;
        uint64_t v24 = v25;
        void *v22 = 0;
        if (v25) {
          MEMORY[0x21667D390](v24, 0x1000C8077774924);
        }
      }
      while (v22 != v21);
      goto LABEL_78;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v75, "pixel_format", 0xCuLL);
  if (!v36)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      unint64_t v77 = "expected key entry for pixel_format in DictionaryAttr to set Properties.";
      uint64_t v78 = 72;
      int64_t v52 = &v76;
      int v53 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v67 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v73 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          int v53 = (char *)v80;
          int64_t v52 = (int *)((char *)v80 + v73);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          int64_t v52 = &v76;
          int v53 = (char *)v80;
        }
      }
      __int16 v54 = &v53[24 * v81];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = *((void *)v52 + 2);
      *(_OWORD *)__int16 v54 = v55;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    uint64_t v56 = __p;
    if (__p)
    {
      uint64_t v57 = v87;
      unsigned int v58 = __p;
      if (v87 != __p)
      {
        do
          uint64_t v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        unsigned int v58 = __p;
      }
      uint64_t v87 = v56;
      operator delete(v58);
    }
    long long v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    uint64_t v59 = v85;
    uint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_79;
    }
    do
    {
      uint64_t v61 = *--v59;
      uint64_t v60 = v61;
      *uint64_t v59 = 0;
      if (v61) {
        MEMORY[0x21667D390](v60, 0x1000C8077774924);
      }
    }
    while (v59 != v21);
    goto LABEL_78;
  }
  uint64_t v37 = v36;
  if (*(_UNKNOWN **)(*(void *)v36 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id)
  {
    a1[1] = v36;
    return 1;
  }
  a3(v79, a4);
  if (v79[0])
  {
    int v76 = 3;
    uint64_t v78 = 57;
    uint64_t v38 = &v76;
    uint64_t v39 = (char *)v80;
    if (v81 >= v82)
    {
      unint64_t v66 = v81 + 1;
      if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
      {
        int64_t v72 = (char *)&v76 - (unsigned char *)v80;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        uint64_t v39 = (char *)v80;
        uint64_t v38 = (int *)((char *)v80 + v72);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        uint64_t v38 = &v76;
        uint64_t v39 = (char *)v80;
      }
    }
    uint64_t v40 = &v39[24 * v81];
    long long v41 = *(_OWORD *)v38;
    *((void *)v40 + 2) = *((void *)v38 + 2);
    *(_OWORD *)uint64_t v40 = v41;
    ++v81;
    if (v79[0])
    {
      unint64_t v42 = &v76;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v37);
      unint64_t v43 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v68 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v74 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          unint64_t v43 = (char *)v80;
          unint64_t v42 = (int *)((char *)v80 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          unint64_t v42 = &v76;
          unint64_t v43 = (char *)v80;
        }
      }
      unint64_t v44 = &v43[24 * v81];
      long long v45 = *(_OWORD *)v42;
      *((void *)v44 + 2) = *((void *)v42 + 2);
      *(_OWORD *)unint64_t v44 = v45;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
  }
  if (v88)
  {
    unint64_t v46 = __p;
    if (__p)
    {
      BOOL v47 = v87;
      unint64_t v48 = __p;
      if (v87 != __p)
      {
        do
          BOOL v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        unint64_t v48 = __p;
      }
      uint64_t v87 = v46;
      operator delete(v48);
    }
    long long v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    int64_t v49 = v85;
    uint64_t v23 = v84;
    if (v85 == v84)
    {
LABEL_79:
      uint64_t v85 = v21;
      operator delete(v23);
LABEL_80:
      if (v80 != v83) {
        free(v80);
      }
      return 0;
    }
    do
    {
      uint64_t v51 = *--v49;
      uint64_t v50 = v51;
      *int64_t v49 = 0;
      if (v51) {
        MEMORY[0x21667D390](v50, 0x1000C8077774924);
      }
    }
    while (v49 != v21);
LABEL_78:
    uint64_t v23 = v84;
    goto LABEL_79;
  }
  return 0;
}

uint64_t mlir::mps::CreateTextureTensorOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v21[6] = *MEMORY[0x263EF8340];
  uint64_t v18 = a1;
  long long v19 = v21;
  uint64_t v20 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"compressed", 10, *a2);
    uint64_t v5 = v4;
    unsigned int v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      unsigned int v6 = v20;
    }
    uint64_t v7 = (uint64_t *)((char *)v19 + 16 * v6);
    uint64_t *v7 = NamedAttr;
    v7[1] = v5;
    unsigned int v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    uint64_t v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      uint64_t v10 = (uint64_t *)v19;
      if (v8) {
        goto LABEL_6;
      }
LABEL_13:
      uint64_t DictionaryAttr = 0;
      if (v10 == v21) {
        return DictionaryAttr;
      }
      goto LABEL_7;
    }
  }
  else
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_5;
    }
  }
  uint64_t v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"pixel_format", 12, v9);
  uint64_t v15 = v14;
  unsigned int v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    unsigned int v16 = v20;
  }
  long long v17 = (uint64_t *)((char *)v19 + 16 * v16);
  uint64_t *v17 = v13;
  v17[1] = v15;
  unsigned int v8 = v20 + 1;
  LODWORD(v20) = v8;
  uint64_t v10 = (uint64_t *)v19;
  if (!v8) {
    goto LABEL_13;
  }
LABEL_6:
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  uint64_t v10 = (uint64_t *)v19;
  if (v19 != v21) {
LABEL_7:
  }
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps18(uint64_t a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    unsigned int v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        unsigned int v8 = (char *)v35;
        uint64_t v7 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        unsigned int v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      long long v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid MetalPixelFormat";
        uint64_t v31 = 54;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    unsigned int v16 = __p;
    if (__p)
    {
      long long v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          long long v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      unint64_t v42 = v16;
      operator delete(v18);
    }
    long long v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      long long v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        long long v21 = v39;
      }
      uint64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::MetalPixelFormatAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  uint64_t v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unsigned int v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        unsigned int v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unsigned int v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    unsigned int v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)unsigned int v8 = v9;
    ++v47;
  }
  uint64_t v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MetalPixelFormatAttr]";
  unint64_t v41 = 81;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    uint64_t v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      long long v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          long long v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      unsigned int v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)unsigned int v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        long long v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            long long v19 = (char *)v46;
            uint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            long long v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      uint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      int v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      uint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

BOOL mlir::mps::CreateTextureTensorOp::verifyInvariantsImpl(mlir::mps::CreateTextureTensorOp *this)
{
  uint64_t v81 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = v3[1];
  if (v4)
  {
    uint64_t v5 = *v3;
    v71[0] = v2;
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps18(v4, (void **)"pixel_format", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps18(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v71))return 0; {
    v71[0] = *(void *)this;
    }
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (void **)"compressed", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v71))return 0; {
    uint64_t v6 = *(void *)this;
    }
    uint64_t v7 = (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
    unsigned int v8 = *v7;
    long long v9 = (void *)*((void *)*v7 + 17);
    if (v9 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      uint64_t v22 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v8 + 8);
      v71[0] = v7;
      v71[1] = v22;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v71);
      if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
        || mlir::Type::isF16((mlir::Type *)&OperandRange)
        || mlir::Type::isF32((mlir::Type *)&OperandRange)
        || mlir::Type::isBF16((mlir::Type *)&OperandRange)
        || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
      {
LABEL_85:
        if (*(_DWORD *)(*(void *)this + 36)) {
          uint64_t v50 = *(void *)this - 16;
        }
        else {
          uint64_t v50 = 0;
        }
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v50, 0);
        return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
      }
      unsigned int v8 = *v7;
      if (*((_UNKNOWN **)*v7 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
        goto LABEL_53;
      }
    }
    else if (v9 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_53:
      __int16 v65 = 261;
      unint64_t v63 = (void **)"operand";
      uint64_t v64 = 7;
      mlir::Operation::emitOpError(v6, &v63, (uint64_t)v71);
      if (v71[0])
      {
        LODWORD(v68) = 3;
        int64_t v69 = " #";
        uint64_t v70 = 2;
        uint64_t v23 = &v68;
        uint64_t v24 = (char *)v72;
        if (v73 >= v74)
        {
          unint64_t v53 = v73 + 1;
          if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
          {
            int64_t v59 = (char *)&v68 - (unsigned char *)v72;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v53, 24);
            uint64_t v24 = (char *)v72;
            uint64_t v23 = (void ***)((char *)v72 + v59);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v53, 24);
            uint64_t v23 = &v68;
            uint64_t v24 = (char *)v72;
          }
        }
        unint64_t v25 = &v24[24 * v73];
        long long v26 = *(_OWORD *)v23;
        *((void *)v25 + 2) = v23[2];
        *(_OWORD *)unint64_t v25 = v26;
        uint64_t v27 = ++v73;
        if (v71[0])
        {
          LODWORD(v68) = 5;
          int64_t v69 = 0;
          int64_t v28 = &v68;
          uint64_t v29 = (char *)v72;
          if (v27 >= v74)
          {
            unint64_t v54 = v27 + 1;
            BOOL v55 = (char *)v72 + 24 * v27 > (char *)&v68;
            if (v72 <= &v68 && v55)
            {
              int64_t v60 = (char *)&v68 - (unsigned char *)v72;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
              uint64_t v29 = (char *)v72;
              int64_t v28 = (void ***)((char *)v72 + v60);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
              int64_t v28 = &v68;
              uint64_t v29 = (char *)v72;
            }
          }
          uint64_t v30 = &v29[24 * v73];
          long long v31 = *(_OWORD *)v28;
          *((void *)v30 + 2) = v28[2];
          *(_OWORD *)uint64_t v30 = v31;
          uint64_t v32 = ++v73;
          if (v71[0])
          {
            LODWORD(v68) = 3;
            int64_t v69 = " must be unranked tensor of mps native type values or 4D tensor of mps native type values, but got ";
            uint64_t v70 = 99;
            unint64_t v33 = &v68;
            unint64_t v34 = (char *)v72;
            if (v32 >= v74)
            {
              unint64_t v56 = v32 + 1;
              BOOL v57 = (char *)v72 + 24 * v32 > (char *)&v68;
              if (v72 <= &v68 && v57)
              {
                int64_t v61 = (char *)&v68 - (unsigned char *)v72;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
                unint64_t v34 = (char *)v72;
                unint64_t v33 = (void ***)((char *)v72 + v61);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
                unint64_t v33 = &v68;
                unint64_t v34 = (char *)v72;
              }
            }
            int64_t v35 = &v34[24 * v73];
            long long v36 = *(_OWORD *)v33;
            *((void *)v35 + 2) = v33[2];
            *(_OWORD *)int64_t v35 = v36;
            ++v73;
            if (v71[0])
            {
              int64_t v37 = &v68;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v68, (uint64_t)v7);
              uint64_t v38 = (char *)v72;
              if (v73 >= v74)
              {
                unint64_t v58 = v73 + 1;
                if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
                {
                  int64_t v62 = (char *)&v68 - (unsigned char *)v72;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v58, 24);
                  uint64_t v38 = (char *)v72;
                  int64_t v37 = (void ***)((char *)v72 + v62);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v58, 24);
                  int64_t v37 = &v68;
                  uint64_t v38 = (char *)v72;
                }
              }
              uint64_t v39 = &v38[24 * v73];
              long long v40 = *(_OWORD *)v37;
              *((void *)v39 + 2) = v37[2];
              *(_OWORD *)uint64_t v39 = v40;
              ++v73;
            }
          }
        }
      }
      char v41 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v71);
      if (v71[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v71);
      }
      if (v80)
      {
        uint64_t v42 = __p;
        if (__p)
        {
          __int16 v43 = v79;
          uint64_t v44 = __p;
          if (v79 != __p)
          {
            do
              __int16 v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
            while (v43 != v42);
            uint64_t v44 = __p;
          }
          unint64_t v79 = v42;
          operator delete(v44);
        }
        uint64_t v45 = v76;
        if (v76)
        {
          unint64_t v46 = v77;
          unsigned int v47 = v76;
          if (v77 != v76)
          {
            do
            {
              uint64_t v49 = *--v46;
              uint64_t v48 = v49;
              void *v46 = 0;
              if (v49) {
                MEMORY[0x21667D390](v48, 0x1000C8077774924);
              }
            }
            while (v46 != v45);
            unsigned int v47 = v76;
          }
          unint64_t v77 = v45;
          operator delete(v47);
        }
        if (v72 != v75) {
          free(v72);
        }
      }
      if (v41) {
        goto LABEL_85;
      }
      return 0;
    }
    unint64_t v63 = v7;
    uint64_t v64 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v8 + 8);
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v63))
    {
      uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v7 + 8);
      unint64_t v68 = v7;
      int64_t v69 = (const char *)v10;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v68);
      if (v11 == 4)
      {
        uint64_t v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v7 + 8);
        v66[0] = v7;
        v66[1] = v12;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v66);
        if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isF16((mlir::Type *)&OperandRange)
          || mlir::Type::isF32((mlir::Type *)&OperandRange)
          || mlir::Type::isBF16((mlir::Type *)&OperandRange)
          || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
        {
          goto LABEL_85;
        }
      }
    }
    goto LABEL_53;
  }
  unint64_t v63 = (void **)"requires attribute 'pixel_format'";
  __int16 v65 = 259;
  mlir::OpState::emitOpError((uint64_t *)this, &v63, (uint64_t)v71);
  uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v71);
  if (v71[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v71);
  }
  if (v80)
  {
    long long v14 = __p;
    if (__p)
    {
      uint64_t v15 = v79;
      unsigned int v16 = __p;
      if (v79 != __p)
      {
        do
          uint64_t v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
        while (v15 != v14);
        unsigned int v16 = __p;
      }
      unint64_t v79 = v14;
      operator delete(v16);
    }
    long long v17 = v76;
    if (v76)
    {
      uint64_t v18 = v77;
      long long v19 = v76;
      if (v77 != v76)
      {
        do
        {
          uint64_t v21 = *--v18;
          uint64_t v20 = v21;
          *uint64_t v18 = 0;
          if (v21) {
            MEMORY[0x21667D390](v20, 0x1000C8077774924);
          }
        }
        while (v18 != v17);
        long long v19 = v76;
      }
      unint64_t v77 = v17;
      operator delete(v19);
    }
    if (v72 != v75) {
      free(v72);
    }
  }
  return v13;
}

void mlir::mps::CreateTextureTensorOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::CropOpGenericAdaptorBase::CropOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  unint64_t v5 = a2[11];
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.crop", 8, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::CropOp::verifyInvariantsImpl(mlir::mps::CropOp *this)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 2u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*(void *)this,
                           (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 120) + 8) & 0xFFFFFFFFFFFFFFF8),
                           (void **)"operand",
                           7,
                           3u))
  {
    return 0;
  }
  uint64_t v2 = *(_DWORD *)(*(void *)this + 36) ? *(void *)this - 16 : 0;
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0))return 0; {
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(void *)(*(void *)(*(void *)this + 72) + 24));
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v5 = *(void *)this - 16;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  if (ElementTypeOrSelf == mlir::getElementTypeOrSelf(v6))
  {
    uint64_t v7 = *(_DWORD *)(*(void *)this + 36) ? *(void *)this - 16 : 0;
    uint64_t v8 = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0);
    uint64_t v9 = mlir::getElementTypeOrSelf(v8);
    if (v9 == mlir::getElementTypeOrSelf(*(void *)(*(void *)(*(void *)this + 72) + 24))) {
      return 1;
    }
  }
  uint64_t v20 = (void **)"failed to verify that all of {input, result} have same element type";
  __int16 v21 = 259;
  mlir::OpState::emitOpError((uint64_t *)this, &v20, (uint64_t)v22);
  uint64_t v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v22);
  if (v22[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v22);
  }
  if (v29)
  {
    uint64_t v11 = __p;
    if (__p)
    {
      uint64_t v12 = v28;
      uint64_t v13 = __p;
      if (v28 != __p)
      {
        do
          uint64_t v12 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v12 - 1);
        while (v12 != v11);
        uint64_t v13 = __p;
      }
      int64_t v28 = v11;
      operator delete(v13);
    }
    long long v14 = v25;
    if (v25)
    {
      uint64_t v15 = v26;
      unsigned int v16 = v25;
      if (v26 != v25)
      {
        do
        {
          uint64_t v19 = *--v15;
          uint64_t v18 = v19;
          void *v15 = 0;
          if (v19) {
            MEMORY[0x21667D390](v18, 0x1000C8077774924);
          }
        }
        while (v15 != v14);
        unsigned int v16 = v25;
      }
      long long v26 = v14;
      operator delete(v16);
    }
    if (v23 != &v24) {
      free(v23);
    }
  }
  return v10;
}

void mlir::mps::CropOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::CropResizeOpGenericAdaptorBase::CropResizeOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v5;
  long long v9 = *(_OWORD *)(v5 + 16);
  long long v10 = *(_OWORD *)(v5 + 32);
  *(void *)(a1 + 72) = *(void *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.crop_resize", 15, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::CropResizeOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v84 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v70 = v6;
  if (!v6)
  {
    a3(v74, a4);
    if (v74[0])
    {
      LODWORD(v71) = 3;
      int64_t v72 = "expected DictionaryAttr to set properties";
      uint64_t v73 = 41;
      long long v26 = &v71;
      uint64_t v27 = (char *)v75;
      if (v76 >= v77)
      {
        unint64_t v60 = v76 + 1;
        if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
        {
          int64_t v65 = (char *)&v71 - (unsigned char *)v75;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v60, 24);
          uint64_t v27 = (char *)v75;
          long long v26 = (uint64_t *)((char *)v75 + v65);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v60, 24);
          long long v26 = &v71;
          uint64_t v27 = (char *)v75;
        }
      }
      int64_t v28 = &v27[24 * v76];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)int64_t v28 = v29;
      ++v76;
      if (v74[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
      }
    }
    if (!v83) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      long long v31 = v82;
      uint64_t v32 = __p;
      if (v82 != __p)
      {
        do
          long long v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        uint64_t v32 = __p;
      }
      unsigned int v82 = v30;
      operator delete(v32);
    }
    __int16 v21 = v79;
    if (!v79) {
      goto LABEL_64;
    }
    unint64_t v33 = v80;
    uint64_t v23 = v79;
    if (v80 == v79)
    {
LABEL_63:
      char v80 = v21;
      operator delete(v23);
LABEL_64:
      if (v75 != v78) {
        free(v75);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *unint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
LABEL_62:
    uint64_t v23 = v79;
    goto LABEL_63;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v70, "alignment_mode", 0xEuLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id)
    {
      a3(v74, a4);
      if (v74[0])
      {
        LODWORD(v71) = 3;
        uint64_t v73 = 59;
        long long v10 = &v71;
        uint64_t v11 = (char *)v75;
        if (v76 >= v77)
        {
          unint64_t v61 = v76 + 1;
          if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
          {
            int64_t v66 = (char *)&v71 - (unsigned char *)v75;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v61, 24);
            uint64_t v11 = (char *)v75;
            long long v10 = (uint64_t *)((char *)v75 + v66);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v61, 24);
            long long v10 = &v71;
            uint64_t v11 = (char *)v75;
          }
        }
        uint64_t v12 = &v11[24 * v76];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = v10[2];
        *(_OWORD *)uint64_t v12 = v13;
        ++v76;
        if (v74[0])
        {
          uint64_t v14 = &v71;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v71, v9);
          uint64_t v15 = (char *)v75;
          if (v76 >= v77)
          {
            unint64_t v62 = v76 + 1;
            if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
            {
              int64_t v67 = (char *)&v71 - (unsigned char *)v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v62, 24);
              uint64_t v15 = (char *)v75;
              uint64_t v14 = (uint64_t *)((char *)v75 + v67);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v62, 24);
              uint64_t v14 = &v71;
              uint64_t v15 = (char *)v75;
            }
          }
          unsigned int v16 = &v15[24 * v76];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = v14[2];
          *(_OWORD *)unsigned int v16 = v17;
          ++v76;
          if (v74[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
          }
        }
      }
      if (!v83) {
        return 0;
      }
      uint64_t v18 = __p;
      if (__p)
      {
        uint64_t v19 = v82;
        uint64_t v20 = __p;
        if (v82 != __p)
        {
          do
            uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          uint64_t v20 = __p;
        }
        unsigned int v82 = v18;
        operator delete(v20);
      }
      __int16 v21 = v79;
      if (!v79) {
        goto LABEL_64;
      }
      uint64_t v22 = v80;
      uint64_t v23 = v79;
      if (v80 == v79) {
        goto LABEL_63;
      }
      do
      {
        uint64_t v25 = *--v22;
        uint64_t v24 = v25;
        void *v22 = 0;
        if (v25) {
          MEMORY[0x21667D390](v24, 0x1000C8077774924);
        }
      }
      while (v22 != v21);
      goto LABEL_62;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v70, "coordinate_mode", 0xFuLL);
  if (v36)
  {
    uint64_t v37 = v36;
    if (*(_UNKNOWN **)(*(void *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id)
    {
      a3(v74, a4);
      if (v74[0])
      {
        LODWORD(v71) = 3;
        uint64_t v73 = 60;
        uint64_t v38 = &v71;
        uint64_t v39 = (char *)v75;
        if (v76 >= v77)
        {
          unint64_t v63 = v76 + 1;
          if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
          {
            int64_t v68 = (char *)&v71 - (unsigned char *)v75;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v63, 24);
            uint64_t v39 = (char *)v75;
            uint64_t v38 = (uint64_t *)((char *)v75 + v68);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v63, 24);
            uint64_t v38 = &v71;
            uint64_t v39 = (char *)v75;
          }
        }
        long long v40 = &v39[24 * v76];
        long long v41 = *(_OWORD *)v38;
        *((void *)v40 + 2) = v38[2];
        *(_OWORD *)long long v40 = v41;
        ++v76;
        if (v74[0])
        {
          uint64_t v42 = &v71;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v71, v37);
          __int16 v43 = (char *)v75;
          if (v76 >= v77)
          {
            unint64_t v64 = v76 + 1;
            if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
            {
              int64_t v69 = (char *)&v71 - (unsigned char *)v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v64, 24);
              __int16 v43 = (char *)v75;
              uint64_t v42 = (uint64_t *)((char *)v75 + v69);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v64, 24);
              uint64_t v42 = &v71;
              __int16 v43 = (char *)v75;
            }
          }
          uint64_t v44 = &v43[24 * v76];
          long long v45 = *(_OWORD *)v42;
          *((void *)v44 + 2) = v42[2];
          *(_OWORD *)uint64_t v44 = v45;
          ++v76;
          if (v74[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
          }
        }
      }
      if (!v83) {
        return 0;
      }
      unint64_t v46 = __p;
      if (__p)
      {
        unsigned int v47 = v82;
        uint64_t v48 = __p;
        if (v82 != __p)
        {
          do
            unsigned int v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          uint64_t v48 = __p;
        }
        unsigned int v82 = v46;
        operator delete(v48);
      }
      __int16 v21 = v79;
      if (!v79) {
        goto LABEL_64;
      }
      uint64_t v49 = v80;
      uint64_t v23 = v79;
      if (v80 == v79) {
        goto LABEL_63;
      }
      do
      {
        uint64_t v51 = *--v49;
        uint64_t v50 = v51;
        *uint64_t v49 = 0;
        if (v51) {
          MEMORY[0x21667D390](v50, 0x1000C8077774924);
        }
      }
      while (v49 != v21);
      goto LABEL_62;
    }
    a1[1] = v36;
  }
  uint64_t v52 = mlir::DictionaryAttr::get((uint64_t)&v70, "interpolation_mode", 0x12uLL);
  uint64_t v71 = v52;
  if (!v52)
  {
LABEL_71:
    uint64_t v54 = mlir::DictionaryAttr::get((uint64_t)&v70, "normalize_coordinates", 0x15uLL);
    uint64_t v71 = v54;
    if (v54)
    {
      if (*(_UNKNOWN **)(*(void *)v54 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
      {
        a3(v74, a4);
        goto LABEL_87;
      }
      a1[3] = v54;
    }
    uint64_t v55 = mlir::DictionaryAttr::get((uint64_t)&v70, "resize_height", 0xDuLL);
    uint64_t v71 = v55;
    if (v55)
    {
      if (*(_UNKNOWN **)(*(void *)v55 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        a3(v74, a4);
LABEL_86:
        uint64_t v53 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v74, v56);
        goto LABEL_87;
      }
      a1[4] = v55;
    }
    uint64_t v57 = mlir::DictionaryAttr::get((uint64_t)&v70, "resize_width", 0xCuLL);
    uint64_t v71 = v57;
    if (v57)
    {
      if (*(_UNKNOWN **)(*(void *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        a3(v74, a4);
        goto LABEL_87;
      }
      a1[5] = v57;
    }
    uint64_t v58 = mlir::DictionaryAttr::get((uint64_t)&v70, "spatial_scale", 0xDuLL);
    uint64_t v71 = v58;
    if (v58)
    {
      if (*(_UNKNOWN **)(*(void *)v58 + 136) != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
      {
        a3(v74, a4);
        goto LABEL_86;
      }
      a1[6] = v58;
    }
    return 1;
  }
  if (*(_UNKNOWN **)(*(void *)v52 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id)
  {
    a1[2] = v52;
    goto LABEL_71;
  }
  a3(v74, a4);
LABEL_87:
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v53, &v71);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v74);
  return 0;
}

uint64_t mlir::mps::CropResizeOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v51[6] = *MEMORY[0x263EF8340];
  uint64_t v48 = a1;
  uint64_t v49 = v51;
  uint64_t v50 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v48, (uint64_t)"alignment_mode", 14, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v50;
  if (v50 >= HIDWORD(v50))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
    unsigned int v6 = v50;
  }
  uint64_t v7 = (uint64_t *)((char *)v49 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v50 + 1;
  LODWORD(v50) = v50 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"coordinate_mode", 15, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v13 = v50;
    }
    uint64_t v14 = (uint64_t *)((char *)v49 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"interpolation_mode", 18, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v19 = v50;
    }
    uint64_t v20 = (uint64_t *)((char *)v49 + 16 * v19);
    uint64_t *v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"normalize_coordinates", 21, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v25 = v50;
    }
    long long v26 = (uint64_t *)((char *)v49 + 16 * v25);
    uint64_t *v26 = v22;
    v26[1] = v24;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"resize_height", 13, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v31 = v50;
    }
    uint64_t v32 = (uint64_t *)((char *)v49 + 16 * v31);
    uint64_t *v32 = v28;
    v32[1] = v30;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v33 = a2[5];
  if (v33)
  {
    uint64_t v34 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"resize_width", 12, v33);
    uint64_t v36 = v35;
    unsigned int v37 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v37 = v50;
    }
    uint64_t v38 = (uint64_t *)((char *)v49 + 16 * v37);
    uint64_t *v38 = v34;
    v38[1] = v36;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v39 = a2[6];
  if (v39)
  {
    uint64_t v40 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"spatial_scale", 13, v39);
    uint64_t v42 = v41;
    unsigned int v43 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v43 = v50;
    }
    uint64_t v44 = (uint64_t *)((char *)v49 + 16 * v43);
    uint64_t *v44 = v40;
    v44[1] = v42;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  long long v45 = v49;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v49 == v51) {
      return DictionaryAttr;
    }
    goto LABEL_32;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v48, (uint64_t *)v49, v8);
  long long v45 = v49;
  if (v49 != v51) {
LABEL_32:
  }
    free(v45);
  return DictionaryAttr;
}

uint64_t mlir::mps::CropResizeOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 0xCuLL:
      if (memcmp(__s1, "resize_width", __n)) {
        return 0;
      }
      return a2[5];
    case 0xDuLL:
      if (!memcmp(__s1, "resize_height", __n)) {
        return a2[4];
      }
      if (memcmp(__s1, "spatial_scale", __n)) {
        return 0;
      }
      return a2[6];
    case 0xEuLL:
      if (*(void *)__s1 != 0x6E656D6E67696C61 || *(void *)(__s1 + 6) != 0x65646F6D5F746E65) {
        return 0;
      }
      return *a2;
    case 0xFuLL:
      if (memcmp(__s1, "coordinate_mode", __n)) {
        return 0;
      }
      return a2[1];
    case 0x10uLL:
    case 0x11uLL:
    case 0x13uLL:
    case 0x14uLL:
      return 0;
    case 0x12uLL:
      if (memcmp(__s1, "interpolation_mode", __n)) {
        return 0;
      }
      return a2[2];
    case 0x15uLL:
      if (memcmp(__s1, "normalize_coordinates", __n)) {
        return 0;
      }
      return a2[3];
    default:
      return 0;
  }
}

uint64_t mlir::mps::CropResizeOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  uint64_t v7 = (void *)result;
  switch(__n)
  {
    case 0xCuLL:
      uint64_t result = memcmp(__s1, "resize_width", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v14 = a4;
          }
          else {
            uint64_t v14 = 0;
          }
          v7[5] = v14;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "resize_height", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "spatial_scale", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id) {
              uint64_t v8 = a4;
            }
            else {
              uint64_t v8 = 0;
            }
            v7[6] = v8;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
          uint64_t v15 = a4;
        }
        else {
          uint64_t v15 = 0;
        }
        v7[4] = v15;
      }
      else
      {
        v7[4] = 0;
      }
      break;
    case 0xEuLL:
      if (*(void *)__s1 == 0x6E656D6E67696C61 && *(void *)(__s1 + 6) == 0x65646F6D5F746E65)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          *(void *)uint64_t result = v10;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xFuLL:
      uint64_t result = memcmp(__s1, "coordinate_mode", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v7[1] = v11;
        }
        else
        {
          v7[1] = 0;
        }
      }
      break;
    case 0x12uLL:
      uint64_t result = memcmp(__s1, "interpolation_mode", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id) {
            uint64_t v12 = a4;
          }
          else {
            uint64_t v12 = 0;
          }
          v7[2] = v12;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    case 0x15uLL:
      uint64_t result = memcmp(__s1, "normalize_coordinates", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
            uint64_t v13 = a4;
          }
          else {
            uint64_t v13 = 0;
          }
          v7[3] = v13;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::CropResizeOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"alignment_mode", 14, *a2);
  }
  uint64_t v5 = a2[1];
  if (v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"coordinate_mode", 15, v5);
  }
  uint64_t v6 = a2[2];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"interpolation_mode", 18, v6);
  }
  uint64_t v7 = a2[3];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"normalize_coordinates", 21, v7);
  }
  uint64_t v8 = a2[4];
  if (v8) {
    mlir::NamedAttrList::append(a3, (uint64_t)"resize_height", 13, v8);
  }
  uint64_t v9 = a2[5];
  if (v9) {
    mlir::NamedAttrList::append(a3, (uint64_t)"resize_width", 12, v9);
  }
  uint64_t v10 = a2[6];
  if (v10)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"spatial_scale", 13, v10);
  }
}

BOOL mlir::mps::CropResizeOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps22(v8, (void **)"alignment_mode", (const char *)0xE, a3, a4))
  {
    uint64_t v9 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps23(v9, (void **)"coordinate_mode", (const char *)0xF, a3, a4))
    {
      uint64_t v10 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps21(v10, (void **)"interpolation_mode", (const char *)0x12, a3, a4))
      {
        uint64_t v11 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v11, (void **)"normalize_coordinates", (const char *)0x15, a3, a4))
        {
          uint64_t v12 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v12, (void **)"resize_height", (const char *)0xD, a3, a4))
          {
            uint64_t v13 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v13, (void **)"resize_width", (const char *)0xC, a3, a4))
            {
              uint64_t v14 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(v14, (void **)"spatial_scale", (const char *)0xD, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps22(uint64_t a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      uint64_t v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid CropResizeAlignmentMode";
        uint64_t v31 = 61;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = __p;
    if (__p)
    {
      uint64_t v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          uint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      uint64_t v42 = v16;
      operator delete(v18);
    }
    unsigned int v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      uint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        uint64_t v21 = v39;
      }
      uint64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps23(uint64_t a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      uint64_t v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid CropResizeCoordinateMode";
        uint64_t v31 = 62;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = __p;
    if (__p)
    {
      uint64_t v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          uint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      uint64_t v42 = v16;
      operator delete(v18);
    }
    unsigned int v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      uint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        uint64_t v21 = v39;
      }
      uint64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps21(uint64_t a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      uint64_t v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid sampling modes";
        uint64_t v31 = 52;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = __p;
    if (__p)
    {
      uint64_t v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          uint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      uint64_t v42 = v16;
      operator delete(v18);
    }
    unsigned int v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      uint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        uint64_t v21 = v39;
      }
      uint64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(void **a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  if (*((_UNKNOWN **)*a1 + 17) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    uint64_t v31 = a1;
    uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v31);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 32)) {
      return 1;
    }
  }
  a4(&Value, a5);
  if (Value)
  {
    LODWORD(v31) = 3;
    __int16 v32 = "attribute '";
    uint64_t v33 = 11;
    long long v10 = &v31;
    uint64_t v11 = (char *)v37;
    if (v38 >= v39)
    {
      unint64_t v27 = v38 + 1;
      if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
      {
        int64_t v29 = (char *)&v31 - (unsigned char *)v37;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        uint64_t v11 = (char *)v37;
        long long v10 = (void ***)((char *)v37 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        long long v10 = &v31;
        uint64_t v11 = (char *)v37;
      }
    }
    uint64_t v12 = &v11[24 * v38];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = v10[2];
    *(_OWORD *)uint64_t v12 = v13;
    ++v38;
    if (Value)
    {
      __int16 v34 = 261;
      uint64_t v31 = a2;
      __int16 v32 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v36, &v31);
      if (Value)
      {
        LODWORD(v31) = 3;
        __int16 v32 = "' failed to satisfy constraint: 32-bit unsigned integer attribute";
        uint64_t v33 = 65;
        long long v14 = &v31;
        uint64_t v15 = (char *)v37;
        if (v38 >= v39)
        {
          unint64_t v28 = v38 + 1;
          if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
          {
            int64_t v30 = (char *)&v31 - (unsigned char *)v37;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            uint64_t v15 = (char *)v37;
            long long v14 = (void ***)((char *)v37 + v30);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            long long v14 = &v31;
            uint64_t v15 = (char *)v37;
          }
        }
        uint64_t v16 = &v15[24 * v38];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = v14[2];
        *(_OWORD *)uint64_t v16 = v17;
        ++v38;
      }
    }
  }
  uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  if (v45)
  {
    uint64_t v18 = __p;
    if (__p)
    {
      unsigned int v19 = v44;
      uint64_t v20 = __p;
      if (v44 != __p)
      {
        do
          unsigned int v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        uint64_t v20 = __p;
      }
      uint64_t v44 = v18;
      operator delete(v20);
    }
    uint64_t v21 = v41;
    if (v41)
    {
      uint64_t v22 = v42;
      uint64_t v23 = v41;
      if (v42 != v41)
      {
        do
        {
          uint64_t v25 = *--v22;
          uint64_t v24 = v25;
          void *v22 = 0;
          if (v25) {
            MEMORY[0x21667D390](v24, 0x1000C8077774924);
          }
        }
        while (v22 != v21);
        uint64_t v23 = v41;
      }
      uint64_t v42 = v21;
      operator delete(v23);
    }
    if (v37 != v40) {
      free(v37);
    }
  }
  return v9;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(void **a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  if (*((_UNKNOWN **)*a1 + 17) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    uint64_t v31 = a1;
    uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v31);
    if (mlir::Type::isF32((mlir::Type *)&Value)) {
      return 1;
    }
  }
  a4(&Value, a5);
  if (Value)
  {
    LODWORD(v31) = 3;
    __int16 v32 = "attribute '";
    uint64_t v33 = 11;
    long long v10 = &v31;
    uint64_t v11 = (char *)v37;
    if (v38 >= v39)
    {
      unint64_t v27 = v38 + 1;
      if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
      {
        int64_t v29 = (char *)&v31 - (unsigned char *)v37;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        uint64_t v11 = (char *)v37;
        long long v10 = (void ***)((char *)v37 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        long long v10 = &v31;
        uint64_t v11 = (char *)v37;
      }
    }
    uint64_t v12 = &v11[24 * v38];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = v10[2];
    *(_OWORD *)uint64_t v12 = v13;
    ++v38;
    if (Value)
    {
      __int16 v34 = 261;
      uint64_t v31 = a2;
      __int16 v32 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v36, &v31);
      if (Value)
      {
        LODWORD(v31) = 3;
        __int16 v32 = "' failed to satisfy constraint: 32-bit float attribute";
        uint64_t v33 = 54;
        long long v14 = &v31;
        uint64_t v15 = (char *)v37;
        if (v38 >= v39)
        {
          unint64_t v28 = v38 + 1;
          if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
          {
            int64_t v30 = (char *)&v31 - (unsigned char *)v37;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            uint64_t v15 = (char *)v37;
            long long v14 = (void ***)((char *)v37 + v30);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            long long v14 = &v31;
            uint64_t v15 = (char *)v37;
          }
        }
        uint64_t v16 = &v15[24 * v38];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = v14[2];
        *(_OWORD *)uint64_t v16 = v17;
        ++v38;
      }
    }
  }
  uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  if (v45)
  {
    uint64_t v18 = __p;
    if (__p)
    {
      unsigned int v19 = v44;
      uint64_t v20 = __p;
      if (v44 != __p)
      {
        do
          unsigned int v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        uint64_t v20 = __p;
      }
      uint64_t v44 = v18;
      operator delete(v20);
    }
    uint64_t v21 = v41;
    if (v41)
    {
      uint64_t v22 = v42;
      uint64_t v23 = v41;
      if (v42 != v41)
      {
        do
        {
          uint64_t v25 = *--v22;
          uint64_t v24 = v25;
          void *v22 = 0;
          if (v25) {
            MEMORY[0x21667D390](v24, 0x1000C8077774924);
          }
        }
        while (v22 != v21);
        uint64_t v23 = v41;
      }
      uint64_t v42 = v21;
      operator delete(v23);
    }
    if (v37 != v40) {
      free(v37);
    }
  }
  return v9;
}

BOOL mlir::mps::CropResizeOp::readProperties(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::CropResizeAlignmentModeAttr>(a1, v3)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::CropResizeCoordinateModeAttr>(a1, v3 + 1)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::SamplingModeAttr>(a1, v3 + 2)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 3)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3 + 4)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3 + 5)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::FloatAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::CropResizeAlignmentModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  uint64_t v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    uint64_t v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        uint64_t v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  uint64_t v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::CropResizeAlignmentModeAttr]";
  unint64_t v41 = 88;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    uint64_t v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      long long v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          long long v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unsigned int v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unsigned int v19 = (char *)v46;
            uint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unsigned int v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      uint64_t v24 = v53;
      uint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        uint64_t v25 = __p;
      }
      uint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      unint64_t v27 = v51;
      unint64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        unint64_t v28 = v50;
      }
      uint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::CropResizeCoordinateModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  uint64_t v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    uint64_t v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        uint64_t v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  uint64_t v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::CropResizeCoordinateModeAttr]";
  unint64_t v41 = 89;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    uint64_t v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      long long v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          long long v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unsigned int v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unsigned int v19 = (char *)v46;
            uint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unsigned int v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      uint64_t v24 = v53;
      uint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        uint64_t v25 = __p;
      }
      uint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      unint64_t v27 = v51;
      unint64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        unint64_t v28 = v50;
      }
      uint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::SamplingModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  uint64_t v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    uint64_t v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        uint64_t v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  uint64_t v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::SamplingModeAttr]";
  unint64_t v41 = 77;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    uint64_t v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      long long v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          long long v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unsigned int v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unsigned int v19 = (char *)v46;
            uint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unsigned int v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      uint64_t v24 = v53;
      uint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        uint64_t v25 = __p;
      }
      uint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      unint64_t v27 = v51;
      unint64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        unint64_t v28 = v50;
      }
      uint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::FloatAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  uint64_t v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    uint64_t v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        uint64_t v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  uint64_t v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::FloatAttr]";
  unint64_t v41 = 65;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    uint64_t v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      long long v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          long long v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unsigned int v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unsigned int v19 = (char *)v46;
            uint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unsigned int v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      uint64_t v24 = v53;
      uint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        uint64_t v25 = __p;
      }
      uint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      unint64_t v27 = v51;
      unint64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        unint64_t v28 = v50;
      }
      uint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

uint64_t *mlir::mps::CropResizeOp::getResizeHeight(mlir::mps::CropResizeOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  uint64_t v6 = *(void *)(v1 + 32);
  mlir::IntegerAttr::getValue((uint64_t)&v6, (llvm::APInt *)&v4);
  if (v5 <= 0x40) {
    return v4;
  }
  uint64_t v3 = *v4;
  MEMORY[0x21667D390]();
  return (uint64_t *)v3;
}

uint64_t *mlir::mps::CropResizeOp::getResizeWidth(mlir::mps::CropResizeOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  uint64_t v6 = *(void *)(v1 + 40);
  mlir::IntegerAttr::getValue((uint64_t)&v6, (llvm::APInt *)&v4);
  if (v5 <= 0x40) {
    return v4;
  }
  uint64_t v3 = *v4;
  MEMORY[0x21667D390]();
  return (uint64_t *)v3;
}

BOOL mlir::mps::CropResizeOp::getNormalizeCoordinates(mlir::mps::CropResizeOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  return *(void *)(v1 + 24) != 0;
}

void *mlir::mps::CropResizeOp::getSpatialScale@<X0>(mlir::mps::CropResizeOp *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v2 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v2 = 0;
  }
  uint64_t v4 = *(void *)(v2 + 48);
  return mlir::FloatAttr::getValue((mlir::FloatAttr *)&v4, a2);
}

uint64_t mlir::mps::CropResizeOp::getInterpolationMode(mlir::mps::CropResizeOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  return *(unsigned int *)(*(void *)(v1 + 16) + 8);
}

uint64_t mlir::mps::CropResizeOp::getCoordinateMode(mlir::mps::CropResizeOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  return *(unsigned int *)(*(void *)(v1 + 8) + 8);
}

mlir::MLIRContext *mlir::mps::CropResizeOp::populateDefaultProperties(uint64_t a1, mlir::MLIRContext **a2)
{
  uint64_t v16 = *(void **)(a1 + 8);
  uint64_t result = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  long long v14 = result;
  if (a2[4])
  {
    if (a2[5]) {
      goto LABEL_3;
    }
  }
  else
  {
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)&v14, 0x20u, 0);
    uint64_t result = (mlir::MLIRContext *)mlir::Builder::getIntegerAttr((uint64_t)&v14, IntegerType, 1uLL);
    a2[4] = result;
    if (a2[5])
    {
LABEL_3:
      if (a2[6]) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }
  uint64_t v6 = mlir::Builder::getIntegerType((mlir::Builder *)&v14, 0x20u, 0);
  uint64_t result = (mlir::MLIRContext *)mlir::Builder::getIntegerAttr((uint64_t)&v14, v6, 1uLL);
  a2[5] = result;
  if (a2[6])
  {
LABEL_4:
    if (a2[2]) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }
LABEL_10:
  uint64_t F32Type = mlir::Builder::getF32Type(&v14, v4);
  uint64_t result = mlir::Builder::getFloatAttr(1.0, (uint64_t)&v14, F32Type);
  a2[6] = result;
  if (a2[2])
  {
LABEL_5:
    if (*a2) {
      goto LABEL_6;
    }
    goto LABEL_12;
  }
LABEL_11:
  uint64_t v8 = v14;
  unsigned int v15 = 1;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v14);
  uint64_t v16 = &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id;
  long long v17 = v8;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::SamplingModeAttrStorage,mlir::mps::SamplingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23SamplingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16SamplingModeAttrEJNS2_12SamplingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v16, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id, &v15);
  a2[2] = result;
  if (*a2)
  {
LABEL_6:
    if (a2[1]) {
      return result;
    }
LABEL_13:
    uint64_t v12 = v14;
    unsigned int v15 = 0;
    unint64_t v13 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v14);
    uint64_t v16 = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id;
    long long v17 = v12;
    uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::CropResizeCoordinateModeAttrStorage,mlir::mps::CropResizeCoordinateMode>(v13, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail35CropResizeCoordinateModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_28CropResizeCoordinateModeAttrEJNS2_24CropResizeCoordinateModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v16, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id, &v15);
    a2[1] = result;
    return result;
  }
LABEL_12:
  unint64_t v10 = v14;
  unsigned int v15 = 0;
  unint64_t v11 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v14);
  uint64_t v16 = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id;
  long long v17 = v10;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::CropResizeAlignmentModeAttrStorage,mlir::mps::CropResizeAlignmentMode>(v11, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail34CropResizeAlignmentModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_27CropResizeAlignmentModeAttrEJNS2_23CropResizeAlignmentModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v16, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id, &v15);
  *a2 = result;
  if (!a2[1]) {
    goto LABEL_13;
  }
  return result;
}

BOOL mlir::mps::CropResizeOp::verifyInvariantsImpl(mlir::mps::CropResizeOp *this)
{
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    uint64_t v3 = 0;
  }
  uint64_t v5 = *v3;
  uint64_t v4 = v3[1];
  uint64_t v6 = v3[2];
  uint64_t v7 = v3[3];
  uint64_t v8 = (void **)v3[4];
  long long v9 = (void **)v3[5];
  unint64_t v10 = (void **)v3[6];
  uint64_t v14 = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v8, (void **)"resize_height", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  uint64_t v14 = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v9, (void **)"resize_width", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  uint64_t v14 = *(void *)this;
  }
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (void **)"normalize_coordinates", (const char *)0x15, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  uint64_t v14 = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(v10, (void **)"spatial_scale", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  uint64_t v14 = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps21(v6, (void **)"interpolation_mode", (const char *)0x12, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps21(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  uint64_t v14 = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps22(v5, (void **)"alignment_mode", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps22(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0; {
  uint64_t v14 = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps23(v4, (void **)"coordinate_mode", (const char *)0xF, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps23(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v11 = *(void *)this - 16;
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
}

void mlir::mps::CropResizeOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::CumulativeMaximumOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v77 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v63 = v6;
  if (!v6)
  {
    a3(v67, a4);
    if (v67[0])
    {
      int v64 = 3;
      int64_t v65 = "expected DictionaryAttr to set properties";
      uint64_t v66 = 41;
      unint64_t v26 = &v64;
      unint64_t v27 = (char *)v68;
      if (v69 >= v70)
      {
        unint64_t v53 = v69 + 1;
        if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
        {
          int64_t v58 = (char *)&v64 - (unsigned char *)v68;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v53, 24);
          unint64_t v27 = (char *)v68;
          unint64_t v26 = (int *)((char *)v68 + v58);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v53, 24);
          unint64_t v26 = &v64;
          unint64_t v27 = (char *)v68;
        }
      }
      unint64_t v28 = &v27[24 * v69];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)unint64_t v28 = v29;
      ++v69;
      if (v67[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
      }
    }
    if (!v76) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      uint64_t v31 = v75;
      unint64_t v32 = __p;
      if (v75 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unint64_t v32 = __p;
      }
      uint64_t v75 = v30;
      operator delete(v32);
    }
    long long v21 = v72;
    if (!v72) {
      goto LABEL_64;
    }
    unint64_t v33 = v73;
    uint64_t v23 = v72;
    if (v73 == v72) {
      goto LABEL_63;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *unint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_62;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v63, "exclusive", 9uLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v67, a4);
      if (v67[0])
      {
        int v64 = 3;
        uint64_t v66 = 54;
        unint64_t v10 = &v64;
        uint64_t v11 = (char *)v68;
        if (v69 >= v70)
        {
          unint64_t v54 = v69 + 1;
          if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
          {
            int64_t v59 = (char *)&v64 - (unsigned char *)v68;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v54, 24);
            uint64_t v11 = (char *)v68;
            unint64_t v10 = (int *)((char *)v68 + v59);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v54, 24);
            unint64_t v10 = &v64;
            uint64_t v11 = (char *)v68;
          }
        }
        uint64_t v12 = &v11[24 * v69];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = *((void *)v10 + 2);
        *(_OWORD *)uint64_t v12 = v13;
        ++v69;
        if (v67[0])
        {
          uint64_t v14 = &v64;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v64, v9);
          unsigned int v15 = (char *)v68;
          if (v69 >= v70)
          {
            unint64_t v55 = v69 + 1;
            if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
            {
              int64_t v60 = (char *)&v64 - (unsigned char *)v68;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v55, 24);
              unsigned int v15 = (char *)v68;
              uint64_t v14 = (int *)((char *)v68 + v60);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v55, 24);
              uint64_t v14 = &v64;
              unsigned int v15 = (char *)v68;
            }
          }
          uint64_t v16 = &v15[24 * v69];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = *((void *)v14 + 2);
          *(_OWORD *)uint64_t v16 = v17;
          ++v69;
          if (v67[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
          }
        }
      }
      if (!v76) {
        return 0;
      }
      uint64_t v18 = __p;
      if (__p)
      {
        unsigned int v19 = v75;
        uint64_t v20 = __p;
        if (v75 != __p)
        {
          do
            unsigned int v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          uint64_t v20 = __p;
        }
        uint64_t v75 = v18;
        operator delete(v20);
      }
      long long v21 = v72;
      if (!v72) {
        goto LABEL_64;
      }
      uint64_t v22 = v73;
      uint64_t v23 = v72;
      if (v73 == v72) {
        goto LABEL_63;
      }
      do
      {
        uint64_t v25 = *--v22;
        uint64_t v24 = v25;
        void *v22 = 0;
        if (v25) {
          MEMORY[0x21667D390](v24, 0x1000C8077774924);
        }
      }
      while (v22 != v21);
      goto LABEL_62;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v63, "reverse", 7uLL);
  if (!v36) {
    return 1;
  }
  uint64_t v37 = v36;
  if (*(_UNKNOWN **)(*(void *)v36 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    a1[1] = v36;
    return 1;
  }
  a3(v67, a4);
  if (v67[0])
  {
    int v64 = 3;
    uint64_t v66 = 52;
    unsigned int v38 = &v64;
    uint64_t v39 = (char *)v68;
    if (v69 >= v70)
    {
      unint64_t v56 = v69 + 1;
      if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
      {
        int64_t v61 = (char *)&v64 - (unsigned char *)v68;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v56, 24);
        uint64_t v39 = (char *)v68;
        unsigned int v38 = (int *)((char *)v68 + v61);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v56, 24);
        unsigned int v38 = &v64;
        uint64_t v39 = (char *)v68;
      }
    }
    uint64_t v40 = &v39[24 * v69];
    long long v41 = *(_OWORD *)v38;
    *((void *)v40 + 2) = *((void *)v38 + 2);
    *(_OWORD *)uint64_t v40 = v41;
    ++v69;
    if (v67[0])
    {
      uint64_t v42 = &v64;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v64, v37);
      __int16 v43 = (char *)v68;
      if (v69 >= v70)
      {
        unint64_t v57 = v69 + 1;
        if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
        {
          int64_t v62 = (char *)&v64 - (unsigned char *)v68;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v57, 24);
          __int16 v43 = (char *)v68;
          uint64_t v42 = (int *)((char *)v68 + v62);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v57, 24);
          uint64_t v42 = &v64;
          __int16 v43 = (char *)v68;
        }
      }
      uint64_t v44 = &v43[24 * v69];
      long long v45 = *(_OWORD *)v42;
      *((void *)v44 + 2) = *((void *)v42 + 2);
      *(_OWORD *)uint64_t v44 = v45;
      ++v69;
      if (v67[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
      }
    }
  }
  if (v76)
  {
    uint64_t v46 = __p;
    if (__p)
    {
      unsigned int v47 = v75;
      unsigned int v48 = __p;
      if (v75 != __p)
      {
        do
          unsigned int v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        unsigned int v48 = __p;
      }
      uint64_t v75 = v46;
      operator delete(v48);
    }
    long long v21 = v72;
    if (!v72) {
      goto LABEL_64;
    }
    uint64_t v49 = v73;
    uint64_t v23 = v72;
    if (v73 == v72)
    {
LABEL_63:
      uint64_t v73 = v21;
      operator delete(v23);
LABEL_64:
      if (v68 != v71) {
        free(v68);
      }
      return 0;
    }
    do
    {
      uint64_t v51 = *--v49;
      uint64_t v50 = v51;
      *uint64_t v49 = 0;
      if (v51) {
        MEMORY[0x21667D390](v50, 0x1000C8077774924);
      }
    }
    while (v49 != v21);
LABEL_62:
    uint64_t v23 = v72;
    goto LABEL_63;
  }
  return 0;
}

uint64_t mlir::mps::CumulativeMaximumOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v21[6] = *MEMORY[0x263EF8340];
  uint64_t v18 = a1;
  unsigned int v19 = v21;
  uint64_t v20 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"exclusive", 9, *a2);
    uint64_t v5 = v4;
    unsigned int v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      unsigned int v6 = v20;
    }
    uint64_t v7 = (uint64_t *)((char *)v19 + 16 * v6);
    uint64_t *v7 = NamedAttr;
    v7[1] = v5;
    unsigned int v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    uint64_t v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      unint64_t v10 = (uint64_t *)v19;
      if (v8) {
        goto LABEL_6;
      }
LABEL_13:
      uint64_t DictionaryAttr = 0;
      if (v10 == v21) {
        return DictionaryAttr;
      }
      goto LABEL_7;
    }
  }
  else
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_5;
    }
  }
  uint64_t v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"reverse", 7, v9);
  uint64_t v15 = v14;
  unsigned int v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    unsigned int v16 = v20;
  }
  long long v17 = (uint64_t *)((char *)v19 + 16 * v16);
  uint64_t *v17 = v13;
  v17[1] = v15;
  unsigned int v8 = v20 + 1;
  LODWORD(v20) = v8;
  unint64_t v10 = (uint64_t *)v19;
  if (!v8) {
    goto LABEL_13;
  }
LABEL_6:
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  unint64_t v10 = (uint64_t *)v19;
  if (v19 != v21) {
LABEL_7:
  }
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::CumulativeMaximumOp::verifyInvariantsImpl(mlir::mps::CumulativeMaximumOp *this)
{
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  uint64_t v9 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v4, (void **)"exclusive", (const char *)9, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v9))return 0; {
  uint64_t v9 = *(void *)this;
  }
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (void **)"reverse", (const char *)7, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v9)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v6 = *(void *)this - 16;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
}

void mlir::mps::CumulativeMaximumOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

void mlir::mps::CumulativeMinimumOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

void mlir::mps::CumulativeProductOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

void mlir::mps::CumulativeSumOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::DegammaOpGenericAdaptorBase::DegammaOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.degamma", 11, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::DegammaOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::DepthToSpace2DOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v5 = (_OWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  }
  else {
    unint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v11, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v11;
  *(_OWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 40) = v8;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.depth_to_space_2d", 21, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::DepthToSpace2DOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v89 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v75 = v6;
  if (!v6)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      uint64_t v77 = "expected DictionaryAttr to set properties";
      uint64_t v78 = 41;
      unint64_t v26 = &v76;
      unint64_t v27 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v63 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v69 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          unint64_t v27 = (char *)v80;
          unint64_t v26 = (int *)((char *)v80 + v69);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          unint64_t v26 = &v76;
          unint64_t v27 = (char *)v80;
        }
      }
      unint64_t v28 = &v27[24 * v81];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)unint64_t v28 = v29;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      uint64_t v31 = v87;
      unint64_t v32 = __p;
      if (v87 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unint64_t v32 = __p;
      }
      uint64_t v87 = v30;
      operator delete(v32);
    }
    long long v21 = v84;
    if (!v84) {
      goto LABEL_79;
    }
    unint64_t v33 = v85;
    uint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_78;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *unint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_77;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v75, "block_size", 0xAuLL);
  if (!v8)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      uint64_t v77 = "expected key entry for block_size in DictionaryAttr to set Properties.";
      uint64_t v78 = 70;
      uint64_t v36 = &v76;
      uint64_t v37 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v65 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v71 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
          uint64_t v37 = (char *)v80;
          uint64_t v36 = (int *)((char *)v80 + v71);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
          uint64_t v36 = &v76;
          uint64_t v37 = (char *)v80;
        }
      }
      unsigned int v38 = &v37[24 * v81];
      long long v39 = *(_OWORD *)v36;
      *((void *)v38 + 2) = *((void *)v36 + 2);
      *(_OWORD *)unsigned int v38 = v39;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    uint64_t v40 = __p;
    if (__p)
    {
      long long v41 = v87;
      uint64_t v42 = __p;
      if (v87 != __p)
      {
        do
          long long v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        uint64_t v42 = __p;
      }
      uint64_t v87 = v40;
      operator delete(v42);
    }
    long long v21 = v84;
    if (!v84) {
      goto LABEL_79;
    }
    __int16 v43 = v85;
    uint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_78;
    }
    do
    {
      uint64_t v45 = *--v43;
      uint64_t v44 = v45;
      void *v43 = 0;
      if (v45) {
        MEMORY[0x21667D390](v44, 0x1000C8077774924);
      }
    }
    while (v43 != v21);
    goto LABEL_77;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      uint64_t v78 = 55;
      unint64_t v10 = &v76;
      uint64_t v11 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v64 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v70 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
          uint64_t v11 = (char *)v80;
          unint64_t v10 = (int *)((char *)v80 + v70);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
          unint64_t v10 = &v76;
          uint64_t v11 = (char *)v80;
        }
      }
      uint64_t v12 = &v11[24 * v81];
      long long v13 = *(_OWORD *)v10;
      *((void *)v12 + 2) = *((void *)v10 + 2);
      *(_OWORD *)uint64_t v12 = v13;
      ++v81;
      if (v79[0])
      {
        uint64_t v14 = &v76;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v9);
        uint64_t v15 = (char *)v80;
        if (v81 >= v82)
        {
          unint64_t v66 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            int64_t v72 = (char *)&v76 - (unsigned char *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
            uint64_t v15 = (char *)v80;
            uint64_t v14 = (int *)((char *)v80 + v72);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
            uint64_t v14 = &v76;
            uint64_t v15 = (char *)v80;
          }
        }
        unsigned int v16 = &v15[24 * v81];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = *((void *)v14 + 2);
        *(_OWORD *)unsigned int v16 = v17;
        ++v81;
        if (v79[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
        }
      }
    }
    if (!v88) {
      return 0;
    }
    uint64_t v18 = __p;
    if (__p)
    {
      unsigned int v19 = v87;
      uint64_t v20 = __p;
      if (v87 != __p)
      {
        do
          unsigned int v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        uint64_t v20 = __p;
      }
      uint64_t v87 = v18;
      operator delete(v20);
    }
    long long v21 = v84;
    if (!v84) {
      goto LABEL_79;
    }
    uint64_t v22 = v85;
    uint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_78;
    }
    do
    {
      uint64_t v25 = *--v22;
      uint64_t v24 = v25;
      void *v22 = 0;
      if (v25) {
        MEMORY[0x21667D390](v24, 0x1000C8077774924);
      }
    }
    while (v22 != v21);
    goto LABEL_77;
  }
  *a1 = v8;
  uint64_t v46 = mlir::DictionaryAttr::get((uint64_t)&v75, "pixel_shuffle", 0xDuLL);
  if (!v46) {
    return 1;
  }
  uint64_t v47 = v46;
  if (*(_UNKNOWN **)(*(void *)v46 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    a1[1] = v46;
    return 1;
  }
  a3(v79, a4);
  if (v79[0])
  {
    int v76 = 3;
    uint64_t v78 = 58;
    unsigned int v48 = &v76;
    uint64_t v49 = (char *)v80;
    if (v81 >= v82)
    {
      unint64_t v67 = v81 + 1;
      if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
      {
        int64_t v73 = (char *)&v76 - (unsigned char *)v80;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
        uint64_t v49 = (char *)v80;
        unsigned int v48 = (int *)((char *)v80 + v73);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
        unsigned int v48 = &v76;
        uint64_t v49 = (char *)v80;
      }
    }
    uint64_t v50 = &v49[24 * v81];
    long long v51 = *(_OWORD *)v48;
    *((void *)v50 + 2) = *((void *)v48 + 2);
    *(_OWORD *)uint64_t v50 = v51;
    ++v81;
    if (v79[0])
    {
      uint64_t v52 = &v76;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v47);
      unint64_t v53 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v68 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v74 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          unint64_t v53 = (char *)v80;
          uint64_t v52 = (int *)((char *)v80 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          uint64_t v52 = &v76;
          unint64_t v53 = (char *)v80;
        }
      }
      unint64_t v54 = &v53[24 * v81];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = *((void *)v52 + 2);
      *(_OWORD *)unint64_t v54 = v55;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
  }
  if (v88)
  {
    unint64_t v56 = __p;
    if (__p)
    {
      unint64_t v57 = v87;
      int64_t v58 = __p;
      if (v87 != __p)
      {
        do
          unint64_t v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        int64_t v58 = __p;
      }
      uint64_t v87 = v56;
      operator delete(v58);
    }
    long long v21 = v84;
    if (!v84) {
      goto LABEL_79;
    }
    int64_t v59 = v85;
    uint64_t v23 = v84;
    if (v85 == v84)
    {
LABEL_78:
      uint64_t v85 = v21;
      operator delete(v23);
LABEL_79:
      if (v80 != v83) {
        free(v80);
      }
      return 0;
    }
    do
    {
      uint64_t v61 = *--v59;
      uint64_t v60 = v61;
      *int64_t v59 = 0;
      if (v61) {
        MEMORY[0x21667D390](v60, 0x1000C8077774924);
      }
    }
    while (v59 != v21);
LABEL_77:
    uint64_t v23 = v84;
    goto LABEL_78;
  }
  return 0;
}

uint64_t mlir::mps::DepthToSpace2DOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v21[6] = *MEMORY[0x263EF8340];
  uint64_t v18 = a1;
  unsigned int v19 = v21;
  uint64_t v20 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"block_size", 10, *a2);
    uint64_t v5 = v4;
    unsigned int v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      unsigned int v6 = v20;
    }
    uint64_t v7 = (uint64_t *)((char *)v19 + 16 * v6);
    uint64_t *v7 = NamedAttr;
    v7[1] = v5;
    unsigned int v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    uint64_t v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      unint64_t v10 = (uint64_t *)v19;
      if (v8) {
        goto LABEL_6;
      }
LABEL_13:
      uint64_t DictionaryAttr = 0;
      if (v10 == v21) {
        return DictionaryAttr;
      }
      goto LABEL_7;
    }
  }
  else
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_5;
    }
  }
  uint64_t v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"pixel_shuffle", 13, v9);
  uint64_t v15 = v14;
  unsigned int v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    unsigned int v16 = v20;
  }
  long long v17 = (uint64_t *)((char *)v19 + 16 * v16);
  uint64_t *v17 = v13;
  v17[1] = v15;
  unsigned int v8 = v20 + 1;
  LODWORD(v20) = v8;
  unint64_t v10 = (uint64_t *)v19;
  if (!v8) {
    goto LABEL_13;
  }
LABEL_6:
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  unint64_t v10 = (uint64_t *)v19;
  if (v19 != v21) {
LABEL_7:
  }
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::DepthToSpace2DOp::verifyInvariantsImpl(mlir::mps::DepthToSpace2DOp *this)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v3 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = *(void ***)v3;
  if (*(void *)v3)
  {
    uint64_t v5 = *(void *)(v3 + 8);
    v20[0] = v2;
    if (mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v4, (void **)"block_size", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20)&& (v20[0] = *(void *)this, mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (void **)"pixel_shuffle", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20))&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(
                            *(void *)this,
                            (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8),
                            (void **)"operand",
                            7,
                            1u)
      && mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 2u)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 120) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 3u))
    {
      if (*(_DWORD *)(*(void *)this + 36)) {
        uint64_t v6 = *(void *)this - 16;
      }
      else {
        uint64_t v6 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v18 = (void **)"requires attribute 'block_size'";
    __int16 v19 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, &v18, (uint64_t)v20);
    uint64_t v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v20);
    if (v20[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v20);
    }
    if (v27)
    {
      unint64_t v10 = __p;
      if (__p)
      {
        uint64_t v11 = v26;
        uint64_t v12 = __p;
        if (v26 != __p)
        {
          do
            uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
          while (v11 != v10);
          uint64_t v12 = __p;
        }
        unint64_t v26 = v10;
        operator delete(v12);
      }
      uint64_t v13 = v23;
      if (v23)
      {
        uint64_t v14 = v24;
        uint64_t v15 = v23;
        if (v24 != v23)
        {
          do
          {
            uint64_t v17 = *--v14;
            uint64_t v16 = v17;
            *uint64_t v14 = 0;
            if (v17) {
              MEMORY[0x21667D390](v16, 0x1000C8077774924);
            }
          }
          while (v14 != v13);
          uint64_t v15 = v23;
        }
        uint64_t v24 = v13;
        operator delete(v15);
      }
      if (v21 != &v22) {
        free(v21);
      }
    }
  }
  return v8;
}

void mlir::mps::DepthToSpace2DOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::DepthwiseConv2DDataGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v122 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v108 = v6;
  if (!v6)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      uint64_t v110 = "expected DictionaryAttr to set properties";
      uint64_t v111 = 41;
      unint64_t v26 = &v109;
      char v27 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v91 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v99 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v91, 24);
          char v27 = (char *)v113;
          unint64_t v26 = (uint64_t *)((char *)v113 + v99);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v91, 24);
          unint64_t v26 = &v109;
          char v27 = (char *)v113;
        }
      }
      uint64_t v28 = &v27[24 * v114];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)uint64_t v28 = v29;
      ++v114;
      if (v112[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      uint64_t v31 = v120;
      unint64_t v32 = __p;
      if (v120 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unint64_t v32 = __p;
      }
      char v120 = v30;
      operator delete(v32);
    }
    long long v21 = v117;
    if (!v117) {
      goto LABEL_117;
    }
    unint64_t v33 = v118;
    uint64_t v23 = v117;
    if (v118 == v117)
    {
LABEL_116:
      BOOL v118 = v21;
      operator delete(v23);
LABEL_117:
      if (v113 != v116) {
        free(v113);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *unint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
LABEL_115:
    uint64_t v23 = v117;
    goto LABEL_116;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v108, "data_layout", 0xBuLL);
  if (!v8)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      uint64_t v110 = "expected key entry for data_layout in DictionaryAttr to set Properties.";
      uint64_t v111 = 71;
      uint64_t v36 = &v109;
      uint64_t v37 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v93 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v101 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v93, 24);
          uint64_t v37 = (char *)v113;
          uint64_t v36 = (uint64_t *)((char *)v113 + v101);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v93, 24);
          uint64_t v36 = &v109;
          uint64_t v37 = (char *)v113;
        }
      }
      unsigned int v38 = &v37[24 * v114];
      long long v39 = *(_OWORD *)v36;
      *((void *)v38 + 2) = v36[2];
      *(_OWORD *)unsigned int v38 = v39;
      ++v114;
      if (v112[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121) {
      return 0;
    }
    uint64_t v40 = __p;
    if (__p)
    {
      long long v41 = v120;
      uint64_t v42 = __p;
      if (v120 != __p)
      {
        do
          long long v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        uint64_t v42 = __p;
      }
      char v120 = v40;
      operator delete(v42);
    }
    long long v21 = v117;
    if (!v117) {
      goto LABEL_117;
    }
    __int16 v43 = v118;
    uint64_t v23 = v117;
    if (v118 == v117) {
      goto LABEL_116;
    }
    do
    {
      uint64_t v45 = *--v43;
      uint64_t v44 = v45;
      void *v43 = 0;
      if (v45) {
        MEMORY[0x21667D390](v44, 0x1000C8077774924);
      }
    }
    while (v43 != v21);
    goto LABEL_115;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      uint64_t v111 = 56;
      unint64_t v10 = &v109;
      uint64_t v11 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v92 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v100 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v92, 24);
          uint64_t v11 = (char *)v113;
          unint64_t v10 = (uint64_t *)((char *)v113 + v100);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v92, 24);
          unint64_t v10 = &v109;
          uint64_t v11 = (char *)v113;
        }
      }
      uint64_t v12 = &v11[24 * v114];
      long long v13 = *(_OWORD *)v10;
      *((void *)v12 + 2) = v10[2];
      *(_OWORD *)uint64_t v12 = v13;
      ++v114;
      if (v112[0])
      {
        uint64_t v14 = &v109;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v109, v9);
        uint64_t v15 = (char *)v113;
        if (v114 >= v115)
        {
          unint64_t v94 = v114 + 1;
          if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
          {
            int64_t v102 = (char *)&v109 - (unsigned char *)v113;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v94, 24);
            uint64_t v15 = (char *)v113;
            uint64_t v14 = (uint64_t *)((char *)v113 + v102);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v94, 24);
            uint64_t v14 = &v109;
            uint64_t v15 = (char *)v113;
          }
        }
        uint64_t v16 = &v15[24 * v114];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = v14[2];
        *(_OWORD *)uint64_t v16 = v17;
        ++v114;
        if (v112[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
        }
      }
    }
    if (!v121) {
      return 0;
    }
    uint64_t v18 = __p;
    if (__p)
    {
      __int16 v19 = v120;
      uint64_t v20 = __p;
      if (v120 != __p)
      {
        do
          __int16 v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        uint64_t v20 = __p;
      }
      char v120 = v18;
      operator delete(v20);
    }
    long long v21 = v117;
    if (!v117) {
      goto LABEL_117;
    }
    uint64_t v22 = v118;
    uint64_t v23 = v117;
    if (v118 == v117) {
      goto LABEL_116;
    }
    do
    {
      uint64_t v25 = *--v22;
      uint64_t v24 = v25;
      void *v22 = 0;
      if (v25) {
        MEMORY[0x21667D390](v24, 0x1000C8077774924);
      }
    }
    while (v22 != v21);
    goto LABEL_115;
  }
  *a1 = v8;
  uint64_t v46 = mlir::DictionaryAttr::get((uint64_t)&v108, "dilation_rates", 0xEuLL);
  if (!v46)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      uint64_t v110 = "expected key entry for dilation_rates in DictionaryAttr to set Properties.";
      uint64_t v111 = 74;
      uint64_t v52 = &v109;
      unint64_t v53 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v95 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v103 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v95, 24);
          unint64_t v53 = (char *)v113;
          uint64_t v52 = (uint64_t *)((char *)v113 + v103);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v95, 24);
          uint64_t v52 = &v109;
          unint64_t v53 = (char *)v113;
        }
      }
      unint64_t v54 = &v53[24 * v114];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = v52[2];
      *(_OWORD *)unint64_t v54 = v55;
      ++v114;
      if (v112[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121) {
      return 0;
    }
    unint64_t v56 = __p;
    if (__p)
    {
      unint64_t v57 = v120;
      int64_t v58 = __p;
      if (v120 != __p)
      {
        do
          unint64_t v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        int64_t v58 = __p;
      }
      char v120 = v56;
      operator delete(v58);
    }
    long long v21 = v117;
    if (!v117) {
      goto LABEL_117;
    }
    int64_t v59 = v118;
    uint64_t v23 = v117;
    if (v118 == v117) {
      goto LABEL_116;
    }
    do
    {
      uint64_t v61 = *--v59;
      uint64_t v60 = v61;
      *int64_t v59 = 0;
      if (v61) {
        MEMORY[0x21667D390](v60, 0x1000C8077774924);
      }
    }
    while (v59 != v21);
    goto LABEL_115;
  }
  uint64_t v47 = v46;
  if ((mlir::DenseIntElementsAttr::classof(v46) & 1) == 0)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      uint64_t v111 = 59;
      int64_t v62 = &v109;
      unint64_t v63 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v96 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v104 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v96, 24);
          unint64_t v63 = (char *)v113;
          int64_t v62 = (uint64_t *)((char *)v113 + v104);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v96, 24);
          int64_t v62 = &v109;
          unint64_t v63 = (char *)v113;
        }
      }
      unint64_t v64 = &v63[24 * v114];
      long long v65 = *(_OWORD *)v62;
      *((void *)v64 + 2) = v62[2];
      *(_OWORD *)unint64_t v64 = v65;
      ++v114;
      if (v112[0])
      {
        unint64_t v66 = &v109;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v109, v47);
        unint64_t v67 = (char *)v113;
        if (v114 >= v115)
        {
          unint64_t v97 = v114 + 1;
          if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
          {
            int64_t v105 = (char *)&v109 - (unsigned char *)v113;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v97, 24);
            unint64_t v67 = (char *)v113;
            unint64_t v66 = (uint64_t *)((char *)v113 + v105);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v97, 24);
            unint64_t v66 = &v109;
            unint64_t v67 = (char *)v113;
          }
        }
        unint64_t v68 = &v67[24 * v114];
        long long v69 = *(_OWORD *)v66;
        *((void *)v68 + 2) = v66[2];
        *(_OWORD *)unint64_t v68 = v69;
        ++v114;
        if (v112[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
        }
      }
    }
    if (!v121) {
      return 0;
    }
    int64_t v70 = __p;
    if (__p)
    {
      int64_t v71 = v120;
      int64_t v72 = __p;
      if (v120 != __p)
      {
        do
          int64_t v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
        while (v71 != v70);
        int64_t v72 = __p;
      }
      char v120 = v70;
      operator delete(v72);
    }
    long long v21 = v117;
    if (!v117) {
      goto LABEL_117;
    }
    int64_t v73 = v118;
    uint64_t v23 = v117;
    if (v118 == v117) {
      goto LABEL_116;
    }
    do
    {
      uint64_t v75 = *--v73;
      uint64_t v74 = v75;
      *int64_t v73 = 0;
      if (v75) {
        MEMORY[0x21667D390](v74, 0x1000C8077774924);
      }
    }
    while (v73 != v21);
    goto LABEL_115;
  }
  a1[1] = v47;
  uint64_t v48 = mlir::DictionaryAttr::get((uint64_t)&v108, "explicit_padding", 0x10uLL);
  uint64_t v107 = v48;
  if (!v48)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      uint64_t v110 = "expected key entry for explicit_padding in DictionaryAttr to set Properties.";
      uint64_t v111 = 76;
      int v76 = &v109;
      uint64_t v77 = (char *)v113;
      if (v114 >= v115)
      {
        unint64_t v98 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          int64_t v106 = (char *)&v109 - (unsigned char *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v98, 24);
          uint64_t v77 = (char *)v113;
          int v76 = (uint64_t *)((char *)v113 + v106);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v98, 24);
          int v76 = &v109;
          uint64_t v77 = (char *)v113;
        }
      }
      uint64_t v78 = &v77[24 * v114];
      long long v79 = *(_OWORD *)v76;
      *((void *)v78 + 2) = v76[2];
      *(_OWORD *)uint64_t v78 = v79;
      ++v114;
      if (v112[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121) {
      return 0;
    }
    char v80 = __p;
    if (__p)
    {
      unsigned int v81 = v120;
      unsigned int v82 = __p;
      if (v120 != __p)
      {
        do
          unsigned int v81 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v81 - 1);
        while (v81 != v80);
        unsigned int v82 = __p;
      }
      char v120 = v80;
      operator delete(v82);
    }
    long long v21 = v117;
    if (!v117) {
      goto LABEL_117;
    }
    char v83 = v118;
    uint64_t v23 = v117;
    if (v118 == v117) {
      goto LABEL_116;
    }
    do
    {
      uint64_t v85 = *--v83;
      uint64_t v84 = v85;
      *char v83 = 0;
      if (v85) {
        MEMORY[0x21667D390](v84, 0x1000C8077774924);
      }
    }
    while (v83 != v21);
    goto LABEL_115;
  }
  uint64_t v49 = v48;
  if (mlir::DenseIntElementsAttr::classof(v48))
  {
    a1[2] = v49;
    uint64_t v50 = mlir::DictionaryAttr::get((uint64_t)&v108, "padding_style", 0xDuLL);
    uint64_t v109 = v50;
    if (v50)
    {
      if (*(_UNKNOWN **)(*(void *)v50 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
      {
        a1[3] = v50;
        uint64_t v88 = mlir::DictionaryAttr::get((uint64_t)&v108, "strides", 7uLL);
        uint64_t v109 = v88;
        if (!v88)
        {
          a3(v112, a4);
          mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v112, "expected key entry for strides in DictionaryAttr to set Properties.");
          goto LABEL_123;
        }
        uint64_t v89 = v88;
        if (mlir::DenseIntElementsAttr::classof(v88))
        {
          a1[4] = v89;
          uint64_t v90 = mlir::DictionaryAttr::get((uint64_t)&v108, "weights_layout", 0xEuLL);
          uint64_t v109 = v90;
          if (!v90)
          {
            a3(v112, a4);
            mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v112, "expected key entry for weights_layout in DictionaryAttr to set Properties.");
            goto LABEL_123;
          }
          if (*(_UNKNOWN **)(*(void *)v90 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
          {
            a1[5] = v90;
            return 1;
          }
          a3(v112, a4);
        }
        else
        {
          a3(v112, a4);
        }
      }
      else
      {
        a3(v112, a4);
      }
      mlir::InFlightDiagnostic::append<mlir::Attribute>(v51, &v109);
    }
    else
    {
      a3(v112, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v112, "expected key entry for padding_style in DictionaryAttr to set Properties.");
    }
LABEL_123:
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v112);
    return 0;
  }
  a3(v112, a4);
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v87, &v107);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v112);
  return 0;
}

uint64_t mlir::mps::DepthwiseConv2DDataGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v45[6] = *MEMORY[0x263EF8340];
  uint64_t v42 = a1;
  __int16 v43 = v45;
  uint64_t v44 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v42, (uint64_t)"data_layout", 11, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v44;
  if (v44 >= HIDWORD(v44))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v44 + 1, 16);
    unsigned int v6 = v44;
  }
  uint64_t v7 = (uint64_t *)((char *)v43 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v44 + 1;
  LODWORD(v44) = v44 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v42, (uint64_t)"dilation_rates", 14, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v44;
    if (v44 >= HIDWORD(v44))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v44 + 1, 16);
      unsigned int v13 = v44;
    }
    uint64_t v14 = (uint64_t *)((char *)v43 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v44 + 1;
    LODWORD(v44) = v44 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v42, (uint64_t)"explicit_padding", 16, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v44;
    if (v44 >= HIDWORD(v44))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v44 + 1, 16);
      unsigned int v19 = v44;
    }
    uint64_t v20 = (uint64_t *)((char *)v43 + 16 * v19);
    uint64_t *v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v44 + 1;
    LODWORD(v44) = v44 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v42, (uint64_t)"padding_style", 13, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v44;
    if (v44 >= HIDWORD(v44))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v44 + 1, 16);
      unsigned int v25 = v44;
    }
    unint64_t v26 = (uint64_t *)((char *)v43 + 16 * v25);
    uint64_t *v26 = v22;
    v26[1] = v24;
    unsigned int v8 = v44 + 1;
    LODWORD(v44) = v44 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v42, (uint64_t)"strides", 7, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v44;
    if (v44 >= HIDWORD(v44))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v44 + 1, 16);
      unsigned int v31 = v44;
    }
    unint64_t v32 = (uint64_t *)((char *)v43 + 16 * v31);
    uint64_t *v32 = v28;
    v32[1] = v30;
    unsigned int v8 = v44 + 1;
    LODWORD(v44) = v44 + 1;
  }
  uint64_t v33 = a2[5];
  if (v33)
  {
    uint64_t v34 = mlir::Builder::getNamedAttr(&v42, (uint64_t)"weights_layout", 14, v33);
    uint64_t v36 = v35;
    unsigned int v37 = v44;
    if (v44 >= HIDWORD(v44))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v44 + 1, 16);
      unsigned int v37 = v44;
    }
    unsigned int v38 = (uint64_t *)((char *)v43 + 16 * v37);
    uint64_t *v38 = v34;
    v38[1] = v36;
    unsigned int v8 = v44 + 1;
    LODWORD(v44) = v44 + 1;
  }
  long long v39 = v43;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v43 == v45) {
      return DictionaryAttr;
    }
    goto LABEL_28;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v42, (uint64_t *)v43, v8);
  long long v39 = v43;
  if (v43 != v45) {
LABEL_28:
  }
    free(v39);
  return DictionaryAttr;
}

uint64_t mlir::mps::DepthwiseConv2DDataGradientOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[3];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n)) {
        return a2[1];
      }
      if (memcmp(__s1, "weights_layout", __n)) {
        return 0;
      }
      return a2[5];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::DepthwiseConv2DDataGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  uint64_t v7 = (void *)result;
  switch(__n)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v13 = a4;
          }
          else {
            uint64_t v13 = 0;
          }
          v7[4] = v13;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          *(void *)uint64_t result = v9;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          v7[3] = v10;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "weights_layout", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
              uint64_t v11 = a4;
            }
            else {
              uint64_t v11 = 0;
            }
            v7[5] = v11;
          }
          else
          {
            v7[5] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v14 = a4;
        }
        else {
          uint64_t v14 = 0;
        }
        v7[1] = v14;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v12 = a4;
          }
          else {
            uint64_t v12 = 0;
          }
          v7[2] = v12;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::DepthwiseConv2DDataGradientOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"data_layout", 11, *a2);
  }
  uint64_t v5 = a2[1];
  if (v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"dilation_rates", 14, v5);
  }
  uint64_t v6 = a2[2];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"explicit_padding", 16, v6);
  }
  uint64_t v7 = a2[3];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"padding_style", 13, v7);
  }
  uint64_t v8 = a2[4];
  if (v8) {
    mlir::NamedAttrList::append(a3, (uint64_t)"strides", 7, v8);
  }
  uint64_t v9 = a2[5];
  if (v9)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"weights_layout", 14, v9);
  }
}

BOOL mlir::mps::DepthwiseConv2DDataGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v8, (void **)"data_layout", (const char *)0xB, a3, a4))
  {
    uint64_t v9 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))a3, a4))
    {
      uint64_t v10 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v10, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))a3, a4))
      {
        uint64_t v11 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v11, (void **)"padding_style", (const char *)0xD, a3, a4))
        {
          uint64_t v12 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v12, (void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))a3, a4))
          {
            uint64_t v13 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v13, (void **)"weights_layout", (const char *)0xE, a3, a4))
            {
              return 1;
            }
          }
        }
      }
    }
  }
  return result;
}

BOOL mlir::mps::DepthwiseConv2DDataGradientOp::readProperties(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 5) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::DepthwiseConv2DDataGradientOp::verifyInvariantsImpl(mlir::mps::DepthwiseConv2DDataGradientOp *this)
{
  uint64_t v56 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  if (*v3)
  {
    uint64_t v5 = (void **)v3[1];
    if (v5)
    {
      uint64_t v6 = (void **)v3[2];
      if (v6)
      {
        uint64_t v7 = v3[3];
        if (v7)
        {
          uint64_t v8 = (void **)v3[4];
          if (v8)
          {
            uint64_t v9 = v3[5];
            if (v9)
            {
              v48[0] = v2;
              if (mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v8, (void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48)&& (v48[0] = *(void *)this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v5, (void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))&& (v48[0] = *(void *)this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))
                && (v48[0] = *(void *)this,
                    mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v7, (void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))&& (v48[0] = *(void *)this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v4, (void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))&& (v48[0] = *(void *)this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v9, (void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))
                && mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 2u))
              {
                if (*(_DWORD *)(*(void *)this + 36)) {
                  uint64_t v10 = *(void *)this - 16;
                }
                else {
                  uint64_t v10 = 0;
                }
                uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
              }
              else
              {
                return 0;
              }
            }
            else
            {
              v46[0] = (void **)"requires attribute 'weights_layout'";
              __int16 v47 = 259;
              mlir::OpState::emitOpError((uint64_t *)this, v46, (uint64_t)v48);
              uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
              mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v48);
            }
            return v12;
          }
          v46[0] = (void **)"requires attribute 'strides'";
          __int16 v47 = 259;
          mlir::OpState::emitOpError((uint64_t *)this, v46, (uint64_t)v48);
          uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
          if (v48[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
          }
          if (v55)
          {
            long long v39 = __p;
            if (__p)
            {
              uint64_t v40 = v54;
              long long v41 = __p;
              if (v54 != __p)
              {
                do
                  uint64_t v40 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v40 - 1);
                while (v40 != v39);
                long long v41 = __p;
              }
              unint64_t v54 = v39;
              operator delete(v41);
            }
            uint64_t v16 = v51;
            if (!v51) {
              goto LABEL_96;
            }
            uint64_t v42 = v52;
            uint64_t v18 = v51;
            if (v52 == v51)
            {
LABEL_95:
              uint64_t v52 = v16;
              operator delete(v18);
LABEL_96:
              if (v49 != &v50) {
                free(v49);
              }
              return v12;
            }
            do
            {
              uint64_t v44 = *--v42;
              uint64_t v43 = v44;
              *uint64_t v42 = 0;
              if (v44) {
                MEMORY[0x21667D390](v43, 0x1000C8077774924);
              }
            }
            while (v42 != v16);
LABEL_94:
            uint64_t v18 = v51;
            goto LABEL_95;
          }
        }
        else
        {
          v46[0] = (void **)"requires attribute 'padding_style'";
          __int16 v47 = 259;
          mlir::OpState::emitOpError((uint64_t *)this, v46, (uint64_t)v48);
          uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
          if (v48[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
          }
          if (v55)
          {
            uint64_t v33 = __p;
            if (__p)
            {
              uint64_t v34 = v54;
              uint64_t v35 = __p;
              if (v54 != __p)
              {
                do
                  uint64_t v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
                while (v34 != v33);
                uint64_t v35 = __p;
              }
              unint64_t v54 = v33;
              operator delete(v35);
            }
            uint64_t v16 = v51;
            if (!v51) {
              goto LABEL_96;
            }
            uint64_t v36 = v52;
            uint64_t v18 = v51;
            if (v52 == v51) {
              goto LABEL_95;
            }
            do
            {
              uint64_t v38 = *--v36;
              uint64_t v37 = v38;
              void *v36 = 0;
              if (v38) {
                MEMORY[0x21667D390](v37, 0x1000C8077774924);
              }
            }
            while (v36 != v16);
            goto LABEL_94;
          }
        }
      }
      else
      {
        v46[0] = (void **)"requires attribute 'explicit_padding'";
        __int16 v47 = 259;
        mlir::OpState::emitOpError((uint64_t *)this, v46, (uint64_t)v48);
        uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
        if (v48[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
        }
        if (v55)
        {
          uint64_t v27 = __p;
          if (__p)
          {
            uint64_t v28 = v54;
            uint64_t v29 = __p;
            if (v54 != __p)
            {
              do
                uint64_t v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v28 - 1);
              while (v28 != v27);
              uint64_t v29 = __p;
            }
            unint64_t v54 = v27;
            operator delete(v29);
          }
          uint64_t v16 = v51;
          if (!v51) {
            goto LABEL_96;
          }
          uint64_t v30 = v52;
          uint64_t v18 = v51;
          if (v52 == v51) {
            goto LABEL_95;
          }
          do
          {
            uint64_t v32 = *--v30;
            uint64_t v31 = v32;
            void *v30 = 0;
            if (v32) {
              MEMORY[0x21667D390](v31, 0x1000C8077774924);
            }
          }
          while (v30 != v16);
          goto LABEL_94;
        }
      }
    }
    else
    {
      v46[0] = (void **)"requires attribute 'dilation_rates'";
      __int16 v47 = 259;
      mlir::OpState::emitOpError((uint64_t *)this, v46, (uint64_t)v48);
      uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
      if (v48[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
      }
      if (v55)
      {
        uint64_t v21 = __p;
        if (__p)
        {
          uint64_t v22 = v54;
          uint64_t v23 = __p;
          if (v54 != __p)
          {
            do
              uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
            while (v22 != v21);
            uint64_t v23 = __p;
          }
          unint64_t v54 = v21;
          operator delete(v23);
        }
        uint64_t v16 = v51;
        if (!v51) {
          goto LABEL_96;
        }
        uint64_t v24 = v52;
        uint64_t v18 = v51;
        if (v52 == v51) {
          goto LABEL_95;
        }
        do
        {
          uint64_t v26 = *--v24;
          uint64_t v25 = v26;
          *uint64_t v24 = 0;
          if (v26) {
            MEMORY[0x21667D390](v25, 0x1000C8077774924);
          }
        }
        while (v24 != v16);
        goto LABEL_94;
      }
    }
  }
  else
  {
    v46[0] = (void **)"requires attribute 'data_layout'";
    __int16 v47 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v46, (uint64_t)v48);
    uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
    if (v48[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
    }
    if (v55)
    {
      uint64_t v13 = __p;
      if (__p)
      {
        uint64_t v14 = v54;
        uint64_t v15 = __p;
        if (v54 != __p)
        {
          do
            uint64_t v14 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v14 - 1);
          while (v14 != v13);
          uint64_t v15 = __p;
        }
        unint64_t v54 = v13;
        operator delete(v15);
      }
      uint64_t v16 = v51;
      if (!v51) {
        goto LABEL_96;
      }
      uint64_t v17 = v52;
      uint64_t v18 = v51;
      if (v52 == v51) {
        goto LABEL_95;
      }
      do
      {
        uint64_t v20 = *--v17;
        uint64_t v19 = v20;
        void *v17 = 0;
        if (v20) {
          MEMORY[0x21667D390](v19, 0x1000C8077774924);
        }
      }
      while (v17 != v16);
      goto LABEL_94;
    }
  }
  return v12;
}

void mlir::mps::DepthwiseConv2DDataGradientOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::DepthwiseConv2DOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (long long *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v12, v7, v6);
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *v5;
  long long v9 = v5[1];
  *(_OWORD *)(a1 + 56) = v5[2];
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)v12;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.depthwise_conv_2d", 21, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::DepthwiseConv2DOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[3];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n)) {
        return a2[1];
      }
      if (memcmp(__s1, "weights_layout", __n)) {
        return 0;
      }
      return a2[5];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::DepthwiseConv2DOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  uint64_t v7 = (void *)result;
  switch(__n)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v13 = a4;
          }
          else {
            uint64_t v13 = 0;
          }
          v7[4] = v13;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          *(void *)uint64_t result = v9;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          v7[3] = v10;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "weights_layout", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
              uint64_t v11 = a4;
            }
            else {
              uint64_t v11 = 0;
            }
            v7[5] = v11;
          }
          else
          {
            v7[5] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v14 = a4;
        }
        else {
          uint64_t v14 = 0;
        }
        v7[1] = v14;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v12 = a4;
          }
          else {
            uint64_t v12 = 0;
          }
          v7[2] = v12;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::DepthwiseConv2DOp::readProperties(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 5) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::mps::DepthwiseConv2DOp::getStrides(mlir::mps::DepthwiseConv2DOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  return *(void *)(v1 + 32);
}

uint64_t mlir::mps::DepthwiseConv2DOp::getPaddingStyle(mlir::mps::DepthwiseConv2DOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  return *(unsigned int *)(*(void *)(v1 + 24) + 8);
}

BOOL mlir::mps::DepthwiseConv2DOp::verifyInvariantsImpl(mlir::mps::DepthwiseConv2DOp *this)
{
  uint64_t v56 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  if (*v3)
  {
    uint64_t v5 = (void **)v3[1];
    if (v5)
    {
      unint64_t v6 = (void **)v3[2];
      if (v6)
      {
        uint64_t v7 = v3[3];
        if (v7)
        {
          long long v8 = (void **)v3[4];
          if (v8)
          {
            uint64_t v9 = v3[5];
            if (v9)
            {
              v48[0] = v2;
              if (mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v8, (void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48)&& (v48[0] = *(void *)this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v5, (void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))&& (v48[0] = *(void *)this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))
                && (v48[0] = *(void *)this,
                    mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v7, (void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))&& (v48[0] = *(void *)this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v4, (void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))&& (v48[0] = *(void *)this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v9, (void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))
                && mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u))
              {
                if (*(_DWORD *)(*(void *)this + 36)) {
                  uint64_t v10 = *(void *)this - 16;
                }
                else {
                  uint64_t v10 = 0;
                }
                uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
              }
              else
              {
                return 0;
              }
            }
            else
            {
              v46[0] = (void **)"requires attribute 'weights_layout'";
              __int16 v47 = 259;
              mlir::OpState::emitOpError((uint64_t *)this, v46, (uint64_t)v48);
              uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
              mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v48);
            }
            return v12;
          }
          v46[0] = (void **)"requires attribute 'strides'";
          __int16 v47 = 259;
          mlir::OpState::emitOpError((uint64_t *)this, v46, (uint64_t)v48);
          uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
          if (v48[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
          }
          if (v55)
          {
            long long v39 = __p;
            if (__p)
            {
              uint64_t v40 = v54;
              long long v41 = __p;
              if (v54 != __p)
              {
                do
                  uint64_t v40 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v40 - 1);
                while (v40 != v39);
                long long v41 = __p;
              }
              unint64_t v54 = v39;
              operator delete(v41);
            }
            uint64_t v16 = v51;
            if (!v51) {
              goto LABEL_95;
            }
            uint64_t v42 = v52;
            uint64_t v18 = v51;
            if (v52 == v51)
            {
LABEL_94:
              uint64_t v52 = v16;
              operator delete(v18);
LABEL_95:
              if (v49 != &v50) {
                free(v49);
              }
              return v12;
            }
            do
            {
              uint64_t v44 = *--v42;
              uint64_t v43 = v44;
              *uint64_t v42 = 0;
              if (v44) {
                MEMORY[0x21667D390](v43, 0x1000C8077774924);
              }
            }
            while (v42 != v16);
LABEL_93:
            uint64_t v18 = v51;
            goto LABEL_94;
          }
        }
        else
        {
          v46[0] = (void **)"requires attribute 'padding_style'";
          __int16 v47 = 259;
          mlir::OpState::emitOpError((uint64_t *)this, v46, (uint64_t)v48);
          uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
          if (v48[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
          }
          if (v55)
          {
            uint64_t v33 = __p;
            if (__p)
            {
              uint64_t v34 = v54;
              uint64_t v35 = __p;
              if (v54 != __p)
              {
                do
                  uint64_t v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
                while (v34 != v33);
                uint64_t v35 = __p;
              }
              unint64_t v54 = v33;
              operator delete(v35);
            }
            uint64_t v16 = v51;
            if (!v51) {
              goto LABEL_95;
            }
            uint64_t v36 = v52;
            uint64_t v18 = v51;
            if (v52 == v51) {
              goto LABEL_94;
            }
            do
            {
              uint64_t v38 = *--v36;
              uint64_t v37 = v38;
              void *v36 = 0;
              if (v38) {
                MEMORY[0x21667D390](v37, 0x1000C8077774924);
              }
            }
            while (v36 != v16);
            goto LABEL_93;
          }
        }
      }
      else
      {
        v46[0] = (void **)"requires attribute 'explicit_padding'";
        __int16 v47 = 259;
        mlir::OpState::emitOpError((uint64_t *)this, v46, (uint64_t)v48);
        uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
        if (v48[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
        }
        if (v55)
        {
          uint64_t v27 = __p;
          if (__p)
          {
            uint64_t v28 = v54;
            uint64_t v29 = __p;
            if (v54 != __p)
            {
              do
                uint64_t v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v28 - 1);
              while (v28 != v27);
              uint64_t v29 = __p;
            }
            unint64_t v54 = v27;
            operator delete(v29);
          }
          uint64_t v16 = v51;
          if (!v51) {
            goto LABEL_95;
          }
          uint64_t v30 = v52;
          uint64_t v18 = v51;
          if (v52 == v51) {
            goto LABEL_94;
          }
          do
          {
            uint64_t v32 = *--v30;
            uint64_t v31 = v32;
            void *v30 = 0;
            if (v32) {
              MEMORY[0x21667D390](v31, 0x1000C8077774924);
            }
          }
          while (v30 != v16);
          goto LABEL_93;
        }
      }
    }
    else
    {
      v46[0] = (void **)"requires attribute 'dilation_rates'";
      __int16 v47 = 259;
      mlir::OpState::emitOpError((uint64_t *)this, v46, (uint64_t)v48);
      uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
      if (v48[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
      }
      if (v55)
      {
        uint64_t v21 = __p;
        if (__p)
        {
          uint64_t v22 = v54;
          uint64_t v23 = __p;
          if (v54 != __p)
          {
            do
              uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
            while (v22 != v21);
            uint64_t v23 = __p;
          }
          unint64_t v54 = v21;
          operator delete(v23);
        }
        uint64_t v16 = v51;
        if (!v51) {
          goto LABEL_95;
        }
        uint64_t v24 = v52;
        uint64_t v18 = v51;
        if (v52 == v51) {
          goto LABEL_94;
        }
        do
        {
          uint64_t v26 = *--v24;
          uint64_t v25 = v26;
          *uint64_t v24 = 0;
          if (v26) {
            MEMORY[0x21667D390](v25, 0x1000C8077774924);
          }
        }
        while (v24 != v16);
        goto LABEL_93;
      }
    }
  }
  else
  {
    v46[0] = (void **)"requires attribute 'data_layout'";
    __int16 v47 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v46, (uint64_t)v48);
    uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
    if (v48[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
    }
    if (v55)
    {
      uint64_t v13 = __p;
      if (__p)
      {
        uint64_t v14 = v54;
        uint64_t v15 = __p;
        if (v54 != __p)
        {
          do
            uint64_t v14 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v14 - 1);
          while (v14 != v13);
          uint64_t v15 = __p;
        }
        unint64_t v54 = v13;
        operator delete(v15);
      }
      uint64_t v16 = v51;
      if (!v51) {
        goto LABEL_95;
      }
      uint64_t v17 = v52;
      uint64_t v18 = v51;
      if (v52 == v51) {
        goto LABEL_94;
      }
      do
      {
        uint64_t v20 = *--v17;
        uint64_t v19 = v20;
        void *v17 = 0;
        if (v20) {
          MEMORY[0x21667D390](v19, 0x1000C8077774924);
        }
      }
      while (v17 != v16);
      goto LABEL_93;
    }
  }
  return v12;
}

void mlir::mps::DepthwiseConv2DOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::DepthwiseConv2DWeightsGradientOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[3];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n)) {
        return a2[1];
      }
      if (memcmp(__s1, "weights_layout", __n)) {
        return 0;
      }
      return a2[5];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::DepthwiseConv2DWeightsGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  uint64_t v7 = (void *)result;
  switch(__n)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v13 = a4;
          }
          else {
            uint64_t v13 = 0;
          }
          v7[4] = v13;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          *(void *)uint64_t result = v9;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          v7[3] = v10;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "weights_layout", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
              uint64_t v11 = a4;
            }
            else {
              uint64_t v11 = 0;
            }
            v7[5] = v11;
          }
          else
          {
            v7[5] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v14 = a4;
        }
        else {
          uint64_t v14 = 0;
        }
        v7[1] = v14;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v12 = a4;
          }
          else {
            uint64_t v12 = 0;
          }
          v7[2] = v12;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::DepthwiseConv2DWeightsGradientOp::readProperties(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 5) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

void mlir::mps::DepthwiseConv2DWeightsGradientOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::DepthwiseConv3DDataGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v125 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v111 = v6;
  if (!v6)
  {
    a3(v115, a4);
    if (v115[0])
    {
      LODWORD(v112) = 3;
      unint64_t v113 = "expected DictionaryAttr to set properties";
      uint64_t v114 = 41;
      uint64_t v26 = &v112;
      uint64_t v27 = (char *)v116;
      if (v117 >= v118)
      {
        unint64_t v93 = v117 + 1;
        if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
        {
          int64_t v102 = (char *)&v112 - (unsigned char *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v93, 24);
          uint64_t v27 = (char *)v116;
          uint64_t v26 = (uint64_t *)((char *)v116 + v102);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v93, 24);
          uint64_t v26 = &v112;
          uint64_t v27 = (char *)v116;
        }
      }
      uint64_t v28 = &v27[24 * v117];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)uint64_t v28 = v29;
      ++v117;
      if (v115[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
      }
    }
    if (!v124) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      uint64_t v31 = v123;
      uint64_t v32 = __p;
      if (v123 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        uint64_t v32 = __p;
      }
      uint64_t v123 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v120;
    if (!v120) {
      goto LABEL_120;
    }
    uint64_t v33 = v121;
    uint64_t v23 = v120;
    if (v121 == v120)
    {
LABEL_119:
      char v121 = v21;
      operator delete(v23);
LABEL_120:
      if (v116 != v119) {
        free(v116);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
LABEL_118:
    uint64_t v23 = v120;
    goto LABEL_119;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v111, "channelAxis", 0xBuLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      a3(v115, a4);
      if (v115[0])
      {
        LODWORD(v112) = 3;
        uint64_t v114 = 56;
        uint64_t v10 = &v112;
        uint64_t v11 = (char *)v116;
        if (v117 >= v118)
        {
          unint64_t v94 = v117 + 1;
          if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
          {
            int64_t v103 = (char *)&v112 - (unsigned char *)v116;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v94, 24);
            uint64_t v11 = (char *)v116;
            uint64_t v10 = (uint64_t *)((char *)v116 + v103);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v94, 24);
            uint64_t v10 = &v112;
            uint64_t v11 = (char *)v116;
          }
        }
        uint64_t v12 = &v11[24 * v117];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = v10[2];
        *(_OWORD *)uint64_t v12 = v13;
        ++v117;
        if (v115[0])
        {
          uint64_t v14 = &v112;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v112, v9);
          uint64_t v15 = (char *)v116;
          if (v117 >= v118)
          {
            unint64_t v95 = v117 + 1;
            if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
            {
              int64_t v104 = (char *)&v112 - (unsigned char *)v116;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v95, 24);
              uint64_t v15 = (char *)v116;
              uint64_t v14 = (uint64_t *)((char *)v116 + v104);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v95, 24);
              uint64_t v14 = &v112;
              uint64_t v15 = (char *)v116;
            }
          }
          uint64_t v16 = &v15[24 * v117];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = v14[2];
          *(_OWORD *)uint64_t v16 = v17;
          ++v117;
          if (v115[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
          }
        }
      }
      if (!v124) {
        return 0;
      }
      uint64_t v18 = __p;
      if (__p)
      {
        uint64_t v19 = v123;
        uint64_t v20 = __p;
        if (v123 != __p)
        {
          do
            uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          uint64_t v20 = __p;
        }
        uint64_t v123 = v18;
        operator delete(v20);
      }
      uint64_t v21 = v120;
      if (!v120) {
        goto LABEL_120;
      }
      uint64_t v22 = v121;
      uint64_t v23 = v120;
      if (v121 == v120) {
        goto LABEL_119;
      }
      do
      {
        uint64_t v25 = *--v22;
        uint64_t v24 = v25;
        void *v22 = 0;
        if (v25) {
          MEMORY[0x21667D390](v24, 0x1000C8077774924);
        }
      }
      while (v22 != v21);
      goto LABEL_118;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v111, "dilation_rates", 0xEuLL);
  if (!v36)
  {
    a3(v115, a4);
    if (v115[0])
    {
      LODWORD(v112) = 3;
      unint64_t v113 = "expected key entry for dilation_rates in DictionaryAttr to set Properties.";
      uint64_t v114 = 74;
      uint64_t v42 = &v112;
      uint64_t v43 = (char *)v116;
      if (v117 >= v118)
      {
        unint64_t v96 = v117 + 1;
        if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
        {
          int64_t v105 = (char *)&v112 - (unsigned char *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v96, 24);
          uint64_t v43 = (char *)v116;
          uint64_t v42 = (uint64_t *)((char *)v116 + v105);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v96, 24);
          uint64_t v42 = &v112;
          uint64_t v43 = (char *)v116;
        }
      }
      uint64_t v44 = &v43[24 * v117];
      long long v45 = *(_OWORD *)v42;
      *((void *)v44 + 2) = v42[2];
      *(_OWORD *)uint64_t v44 = v45;
      ++v117;
      if (v115[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
      }
    }
    if (!v124) {
      return 0;
    }
    uint64_t v46 = __p;
    if (__p)
    {
      __int16 v47 = v123;
      uint64_t v48 = __p;
      if (v123 != __p)
      {
        do
          __int16 v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        uint64_t v48 = __p;
      }
      uint64_t v123 = v46;
      operator delete(v48);
    }
    uint64_t v21 = v120;
    if (!v120) {
      goto LABEL_120;
    }
    uint64_t v49 = v121;
    uint64_t v23 = v120;
    if (v121 == v120) {
      goto LABEL_119;
    }
    do
    {
      uint64_t v51 = *--v49;
      uint64_t v50 = v51;
      *uint64_t v49 = 0;
      if (v51) {
        MEMORY[0x21667D390](v50, 0x1000C8077774924);
      }
    }
    while (v49 != v21);
    goto LABEL_118;
  }
  uint64_t v37 = v36;
  if ((mlir::DenseIntElementsAttr::classof(v36) & 1) == 0)
  {
    a3(v115, a4);
    if (v115[0])
    {
      LODWORD(v112) = 3;
      uint64_t v114 = 59;
      uint64_t v52 = &v112;
      unint64_t v53 = (char *)v116;
      if (v117 >= v118)
      {
        unint64_t v97 = v117 + 1;
        if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
        {
          int64_t v106 = (char *)&v112 - (unsigned char *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v97, 24);
          unint64_t v53 = (char *)v116;
          uint64_t v52 = (uint64_t *)((char *)v116 + v106);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v97, 24);
          uint64_t v52 = &v112;
          unint64_t v53 = (char *)v116;
        }
      }
      unint64_t v54 = &v53[24 * v117];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = v52[2];
      *(_OWORD *)unint64_t v54 = v55;
      ++v117;
      if (v115[0])
      {
        uint64_t v56 = &v112;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v112, v37);
        unint64_t v57 = (char *)v116;
        if (v117 >= v118)
        {
          unint64_t v98 = v117 + 1;
          if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
          {
            int64_t v107 = (char *)&v112 - (unsigned char *)v116;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v98, 24);
            unint64_t v57 = (char *)v116;
            uint64_t v56 = (uint64_t *)((char *)v116 + v107);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v98, 24);
            uint64_t v56 = &v112;
            unint64_t v57 = (char *)v116;
          }
        }
        int64_t v58 = &v57[24 * v117];
        long long v59 = *(_OWORD *)v56;
        *((void *)v58 + 2) = v56[2];
        *(_OWORD *)int64_t v58 = v59;
        ++v117;
        if (v115[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
        }
      }
    }
    if (!v124) {
      return 0;
    }
    uint64_t v60 = __p;
    if (__p)
    {
      uint64_t v61 = v123;
      int64_t v62 = __p;
      if (v123 != __p)
      {
        do
          uint64_t v61 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v61 - 1);
        while (v61 != v60);
        int64_t v62 = __p;
      }
      uint64_t v123 = v60;
      operator delete(v62);
    }
    uint64_t v21 = v120;
    if (!v120) {
      goto LABEL_120;
    }
    unint64_t v63 = v121;
    uint64_t v23 = v120;
    if (v121 == v120) {
      goto LABEL_119;
    }
    do
    {
      uint64_t v65 = *--v63;
      uint64_t v64 = v65;
      *unint64_t v63 = 0;
      if (v65) {
        MEMORY[0x21667D390](v64, 0x1000C8077774924);
      }
    }
    while (v63 != v21);
    goto LABEL_118;
  }
  a1[1] = v37;
  uint64_t v38 = mlir::DictionaryAttr::get((uint64_t)&v111, "explicit_padding", 0x10uLL);
  if (!v38)
  {
    a3(v115, a4);
    if (v115[0])
    {
      LODWORD(v112) = 3;
      unint64_t v113 = "expected key entry for explicit_padding in DictionaryAttr to set Properties.";
      uint64_t v114 = 76;
      unint64_t v66 = &v112;
      unint64_t v67 = (char *)v116;
      if (v117 >= v118)
      {
        unint64_t v99 = v117 + 1;
        if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
        {
          int64_t v108 = (char *)&v112 - (unsigned char *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v99, 24);
          unint64_t v67 = (char *)v116;
          unint64_t v66 = (uint64_t *)((char *)v116 + v108);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v99, 24);
          unint64_t v66 = &v112;
          unint64_t v67 = (char *)v116;
        }
      }
      unint64_t v68 = &v67[24 * v117];
      long long v69 = *(_OWORD *)v66;
      *((void *)v68 + 2) = v66[2];
      *(_OWORD *)unint64_t v68 = v69;
      ++v117;
      if (v115[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
      }
    }
    if (!v124) {
      return 0;
    }
    int64_t v70 = __p;
    if (__p)
    {
      int64_t v71 = v123;
      int64_t v72 = __p;
      if (v123 != __p)
      {
        do
          int64_t v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
        while (v71 != v70);
        int64_t v72 = __p;
      }
      uint64_t v123 = v70;
      operator delete(v72);
    }
    uint64_t v21 = v120;
    if (!v120) {
      goto LABEL_120;
    }
    int64_t v73 = v121;
    uint64_t v23 = v120;
    if (v121 == v120) {
      goto LABEL_119;
    }
    do
    {
      uint64_t v75 = *--v73;
      uint64_t v74 = v75;
      *int64_t v73 = 0;
      if (v75) {
        MEMORY[0x21667D390](v74, 0x1000C8077774924);
      }
    }
    while (v73 != v21);
    goto LABEL_118;
  }
  uint64_t v39 = v38;
  if ((mlir::DenseIntElementsAttr::classof(v38) & 1) == 0)
  {
    a3(v115, a4);
    if (v115[0])
    {
      LODWORD(v112) = 3;
      uint64_t v114 = 61;
      int v76 = &v112;
      uint64_t v77 = (char *)v116;
      if (v117 >= v118)
      {
        unint64_t v100 = v117 + 1;
        if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
        {
          int64_t v109 = (char *)&v112 - (unsigned char *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v100, 24);
          uint64_t v77 = (char *)v116;
          int v76 = (uint64_t *)((char *)v116 + v109);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v100, 24);
          int v76 = &v112;
          uint64_t v77 = (char *)v116;
        }
      }
      uint64_t v78 = &v77[24 * v117];
      long long v79 = *(_OWORD *)v76;
      *((void *)v78 + 2) = v76[2];
      *(_OWORD *)uint64_t v78 = v79;
      ++v117;
      if (v115[0])
      {
        char v80 = &v112;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v112, v39);
        unsigned int v81 = (char *)v116;
        if (v117 >= v118)
        {
          unint64_t v101 = v117 + 1;
          if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
          {
            int64_t v110 = (char *)&v112 - (unsigned char *)v116;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v101, 24);
            unsigned int v81 = (char *)v116;
            char v80 = (uint64_t *)((char *)v116 + v110);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v101, 24);
            char v80 = &v112;
            unsigned int v81 = (char *)v116;
          }
        }
        unsigned int v82 = &v81[24 * v117];
        long long v83 = *(_OWORD *)v80;
        *((void *)v82 + 2) = v80[2];
        *(_OWORD *)unsigned int v82 = v83;
        ++v117;
        if (v115[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
        }
      }
    }
    if (!v124) {
      return 0;
    }
    uint64_t v84 = __p;
    if (__p)
    {
      uint64_t v85 = v123;
      int64_t v86 = __p;
      if (v123 != __p)
      {
        do
          uint64_t v85 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v85 - 1);
        while (v85 != v84);
        int64_t v86 = __p;
      }
      uint64_t v123 = v84;
      operator delete(v86);
    }
    uint64_t v21 = v120;
    if (!v120) {
      goto LABEL_120;
    }
    uint64_t v87 = v121;
    uint64_t v23 = v120;
    if (v121 == v120) {
      goto LABEL_119;
    }
    do
    {
      uint64_t v89 = *--v87;
      uint64_t v88 = v89;
      void *v87 = 0;
      if (v89) {
        MEMORY[0x21667D390](v88, 0x1000C8077774924);
      }
    }
    while (v87 != v21);
    goto LABEL_118;
  }
  a1[2] = v39;
  uint64_t v40 = mlir::DictionaryAttr::get((uint64_t)&v111, "padding_style", 0xDuLL);
  uint64_t v112 = v40;
  if (v40)
  {
    if (*(_UNKNOWN **)(*(void *)v40 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
    {
      a1[3] = v40;
      uint64_t v91 = mlir::DictionaryAttr::get((uint64_t)&v111, "strides", 7uLL);
      uint64_t v112 = v91;
      if (!v91)
      {
        a3(v115, a4);
        mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v115, "expected key entry for strides in DictionaryAttr to set Properties.");
        goto LABEL_125;
      }
      uint64_t v92 = v91;
      if (mlir::DenseIntElementsAttr::classof(v91))
      {
        a1[4] = v92;
        return 1;
      }
      a3(v115, a4);
    }
    else
    {
      a3(v115, a4);
    }
    mlir::InFlightDiagnostic::append<mlir::Attribute>(v41, &v112);
  }
  else
  {
    a3(v115, a4);
    mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v115, "expected key entry for padding_style in DictionaryAttr to set Properties.");
  }
LABEL_125:
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v115);
  return 0;
}

uint64_t mlir::mps::DepthwiseConv3DDataGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v39[6] = *MEMORY[0x263EF8340];
  uint64_t v36 = a1;
  uint64_t v37 = v39;
  uint64_t v38 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v36, (uint64_t)"channelAxis", 11, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v38;
  if (v38 >= HIDWORD(v38))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
    unsigned int v6 = v38;
  }
  uint64_t v7 = (uint64_t *)((char *)v37 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v38 + 1;
  LODWORD(v38) = v38 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"dilation_rates", 14, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      unsigned int v13 = v38;
    }
    uint64_t v14 = (uint64_t *)((char *)v37 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"explicit_padding", 16, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      unsigned int v19 = v38;
    }
    uint64_t v20 = (uint64_t *)((char *)v37 + 16 * v19);
    uint64_t *v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"padding_style", 13, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      unsigned int v25 = v38;
    }
    uint64_t v26 = (uint64_t *)((char *)v37 + 16 * v25);
    uint64_t *v26 = v22;
    v26[1] = v24;
    unsigned int v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"strides", 7, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      unsigned int v31 = v38;
    }
    uint64_t v32 = (uint64_t *)((char *)v37 + 16 * v31);
    uint64_t *v32 = v28;
    v32[1] = v30;
    unsigned int v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  uint64_t v33 = v37;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v37 == v39) {
      return DictionaryAttr;
    }
    goto LABEL_24;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v36, (uint64_t *)v37, v8);
  uint64_t v33 = v37;
  if (v37 != v39) {
LABEL_24:
  }
    free(v33);
  return DictionaryAttr;
}

uint64_t mlir::mps::DepthwiseConv3DDataGradientOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x416C656E6E616863 || *(void *)(__s1 + 3) != 0x736978416C656E6ELL) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[3];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n)) {
        return 0;
      }
      return a2[1];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::DepthwiseConv3DDataGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, uint64_t a4)
{
  uint64_t v5 = (void *)result;
  switch(a3)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v5[4] = v11;
        }
        else
        {
          v5[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x416C656E6E616863 && *(void *)(__s1 + 3) == 0x736978416C656E6ELL)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v7 = a4;
          }
          else {
            uint64_t v7 = 0;
          }
          *(void *)uint64_t result = v7;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v5[3] = v8;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          v5[1] = v9;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          v5[2] = v10;
        }
        else
        {
          v5[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::DepthwiseConv3DDataGradientOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"channelAxis", 11, *a2);
  }
  uint64_t v5 = a2[1];
  if (v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"dilation_rates", 14, v5);
  }
  uint64_t v6 = a2[2];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"explicit_padding", 16, v6);
  }
  uint64_t v7 = a2[3];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"padding_style", 13, v7);
  }
  uint64_t v8 = a2[4];
  if (v8)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"strides", 7, v8);
  }
}

BOOL mlir::mps::DepthwiseConv3DDataGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = (void **)mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v8, (void **)"channelAxis", (const char *)0xB, a3, a4))
  {
    uint64_t v9 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v9, (void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))a3, a4))
    {
      uint64_t v10 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(v10, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))a3, a4))
      {
        uint64_t v11 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v11, (void **)"padding_style", (const char *)0xD, a3, a4))
        {
          uint64_t v12 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v12, (void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))a3, a4))
          {
            return 1;
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(void **a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  if (*((_UNKNOWN **)*a1 + 17) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    unsigned int v31 = a1;
    uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v31);
    if (mlir::Type::isSignedInteger((mlir::Type *)&Value, 32)) {
      return 1;
    }
  }
  a4(&Value, a5);
  if (Value)
  {
    LODWORD(v31) = 3;
    uint64_t v32 = "attribute '";
    uint64_t v33 = 11;
    uint64_t v10 = &v31;
    uint64_t v11 = (char *)v37;
    if (v38 >= v39)
    {
      unint64_t v27 = v38 + 1;
      if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
      {
        int64_t v29 = (char *)&v31 - (unsigned char *)v37;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        uint64_t v11 = (char *)v37;
        uint64_t v10 = (void ***)((char *)v37 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        uint64_t v10 = &v31;
        uint64_t v11 = (char *)v37;
      }
    }
    uint64_t v12 = &v11[24 * v38];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = v10[2];
    *(_OWORD *)uint64_t v12 = v13;
    ++v38;
    if (Value)
    {
      __int16 v34 = 261;
      unsigned int v31 = a2;
      uint64_t v32 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v36, &v31);
      if (Value)
      {
        LODWORD(v31) = 3;
        uint64_t v32 = "' failed to satisfy constraint: 32-bit signed integer attribute";
        uint64_t v33 = 63;
        uint64_t v14 = &v31;
        uint64_t v15 = (char *)v37;
        if (v38 >= v39)
        {
          unint64_t v28 = v38 + 1;
          if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
          {
            int64_t v30 = (char *)&v31 - (unsigned char *)v37;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            uint64_t v15 = (char *)v37;
            uint64_t v14 = (void ***)((char *)v37 + v30);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            uint64_t v14 = &v31;
            uint64_t v15 = (char *)v37;
          }
        }
        uint64_t v16 = &v15[24 * v38];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = v14[2];
        *(_OWORD *)uint64_t v16 = v17;
        ++v38;
      }
    }
  }
  uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  if (v45)
  {
    uint64_t v18 = __p;
    if (__p)
    {
      unsigned int v19 = v44;
      uint64_t v20 = __p;
      if (v44 != __p)
      {
        do
          unsigned int v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        uint64_t v20 = __p;
      }
      uint64_t v44 = v18;
      operator delete(v20);
    }
    uint64_t v21 = v41;
    if (v41)
    {
      uint64_t v22 = v42;
      uint64_t v23 = v41;
      if (v42 != v41)
      {
        do
        {
          uint64_t v25 = *--v22;
          uint64_t v24 = v25;
          void *v22 = 0;
          if (v25) {
            MEMORY[0x21667D390](v24, 0x1000C8077774924);
          }
        }
        while (v22 != v21);
        uint64_t v23 = v41;
      }
      uint64_t v42 = v21;
      operator delete(v23);
    }
    if (v37 != v40) {
      free(v37);
    }
  }
  return v9;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(void **a1, void **a2, const char *a3, void (*a4)(void **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1)) {
    goto LABEL_9;
  }
  uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  uint64_t v41 = a1;
  uint64_t v42 = (const char *)v10;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v41);
  uint64_t v12 = Type;
  if (Type) {
    Type = (void *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  }
  char v45 = v12;
  uint64_t v46 = Type;
  Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v45);
  uint64_t v56 = 3;
  if (v14 == 1 && *Shape == v56)
  {
    unsigned int v38 = a1;
    v39[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v38);
    v39[1] = v15;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v39);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
  }
LABEL_9:
  a4(&v45, a5);
  if (v45)
  {
    LODWORD(v41) = 3;
    uint64_t v42 = "attribute '";
    uint64_t v43 = 11;
    long long v17 = &v41;
    uint64_t v18 = (char *)v47;
    if (v48 >= v49)
    {
      unint64_t v34 = v48 + 1;
      if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
      {
        int64_t v36 = (char *)&v41 - (unsigned char *)v47;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        uint64_t v18 = (char *)v47;
        long long v17 = (void ***)((char *)v47 + v36);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        long long v17 = &v41;
        uint64_t v18 = (char *)v47;
      }
    }
    unsigned int v19 = &v18[24 * v48];
    long long v20 = *(_OWORD *)v17;
    *((void *)v19 + 2) = v17[2];
    *(_OWORD *)unsigned int v19 = v20;
    ++v48;
    if (v45)
    {
      __int16 v44 = 261;
      uint64_t v41 = a2;
      uint64_t v42 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
      if (v45)
      {
        LODWORD(v41) = 3;
        uint64_t v42 = "' failed to satisfy constraint: ui64 elements attribute of shape {3}";
        uint64_t v43 = 68;
        uint64_t v21 = &v41;
        uint64_t v22 = (char *)v47;
        if (v48 >= v49)
        {
          unint64_t v35 = v48 + 1;
          if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
          {
            int64_t v37 = (char *)&v41 - (unsigned char *)v47;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            uint64_t v22 = (char *)v47;
            uint64_t v21 = (void ***)((char *)v47 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            uint64_t v21 = &v41;
            uint64_t v22 = (char *)v47;
          }
        }
        uint64_t v23 = &v22[24 * v48];
        long long v24 = *(_OWORD *)v21;
        *((void *)v23 + 2) = v21[2];
        *(_OWORD *)uint64_t v23 = v24;
        ++v48;
      }
    }
  }
  uint64_t v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v45);
  if (v45) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v45);
  }
  if (v55)
  {
    uint64_t v25 = __p;
    if (__p)
    {
      uint64_t v26 = v54;
      unint64_t v27 = __p;
      if (v54 != __p)
      {
        do
          uint64_t v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        unint64_t v27 = __p;
      }
      unint64_t v54 = v25;
      operator delete(v27);
    }
    unint64_t v28 = v51;
    if (v51)
    {
      int64_t v29 = v52;
      int64_t v30 = v51;
      if (v52 != v51)
      {
        do
        {
          uint64_t v32 = *--v29;
          uint64_t v31 = v32;
          *int64_t v29 = 0;
          if (v32) {
            MEMORY[0x21667D390](v31, 0x1000C8077774924);
          }
        }
        while (v29 != v28);
        int64_t v30 = v51;
      }
      uint64_t v52 = v28;
      operator delete(v30);
    }
    if (v47 != v50) {
      free(v47);
    }
  }
  return v16;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(void **a1, void **a2, const char *a3, void (*a4)(void **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1)) {
    goto LABEL_9;
  }
  uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  uint64_t v41 = a1;
  uint64_t v42 = (const char *)v10;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v41);
  uint64_t v12 = Type;
  if (Type) {
    Type = (void *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  }
  char v45 = v12;
  uint64_t v46 = Type;
  Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v45);
  uint64_t v56 = 6;
  if (v14 == 1 && *Shape == v56)
  {
    unsigned int v38 = a1;
    v39[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v38);
    v39[1] = v15;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v39);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
  }
LABEL_9:
  a4(&v45, a5);
  if (v45)
  {
    LODWORD(v41) = 3;
    uint64_t v42 = "attribute '";
    uint64_t v43 = 11;
    long long v17 = &v41;
    uint64_t v18 = (char *)v47;
    if (v48 >= v49)
    {
      unint64_t v34 = v48 + 1;
      if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
      {
        int64_t v36 = (char *)&v41 - (unsigned char *)v47;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        uint64_t v18 = (char *)v47;
        long long v17 = (void ***)((char *)v47 + v36);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        long long v17 = &v41;
        uint64_t v18 = (char *)v47;
      }
    }
    unsigned int v19 = &v18[24 * v48];
    long long v20 = *(_OWORD *)v17;
    *((void *)v19 + 2) = v17[2];
    *(_OWORD *)unsigned int v19 = v20;
    ++v48;
    if (v45)
    {
      __int16 v44 = 261;
      uint64_t v41 = a2;
      uint64_t v42 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
      if (v45)
      {
        LODWORD(v41) = 3;
        uint64_t v42 = "' failed to satisfy constraint: ui64 elements attribute of shape {6}";
        uint64_t v43 = 68;
        uint64_t v21 = &v41;
        uint64_t v22 = (char *)v47;
        if (v48 >= v49)
        {
          unint64_t v35 = v48 + 1;
          if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
          {
            int64_t v37 = (char *)&v41 - (unsigned char *)v47;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            uint64_t v22 = (char *)v47;
            uint64_t v21 = (void ***)((char *)v47 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            uint64_t v21 = &v41;
            uint64_t v22 = (char *)v47;
          }
        }
        uint64_t v23 = &v22[24 * v48];
        long long v24 = *(_OWORD *)v21;
        *((void *)v23 + 2) = v21[2];
        *(_OWORD *)uint64_t v23 = v24;
        ++v48;
      }
    }
  }
  uint64_t v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v45);
  if (v45) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v45);
  }
  if (v55)
  {
    uint64_t v25 = __p;
    if (__p)
    {
      uint64_t v26 = v54;
      unint64_t v27 = __p;
      if (v54 != __p)
      {
        do
          uint64_t v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        unint64_t v27 = __p;
      }
      unint64_t v54 = v25;
      operator delete(v27);
    }
    unint64_t v28 = v51;
    if (v51)
    {
      int64_t v29 = v52;
      int64_t v30 = v51;
      if (v52 != v51)
      {
        do
        {
          uint64_t v32 = *--v29;
          uint64_t v31 = v32;
          *int64_t v29 = 0;
          if (v32) {
            MEMORY[0x21667D390](v31, 0x1000C8077774924);
          }
        }
        while (v29 != v28);
        int64_t v30 = v51;
      }
      uint64_t v52 = v28;
      operator delete(v30);
    }
    if (v47 != v50) {
      free(v47);
    }
  }
  return v16;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::DepthwiseConv3DDataGradientOp::verifyInvariantsImpl(mlir::mps::DepthwiseConv3DDataGradientOp *this)
{
  uint64_t v67 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v3 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = *(void ***)(v3 + 8);
  if (!v4)
  {
    v57[0] = (void **)"requires attribute 'dilation_rates'";
    __int16 v58 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v57, (uint64_t)v59);
    uint64_t v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v59);
    if (v59[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (!v66) {
      return v25;
    }
    uint64_t v26 = __p;
    if (__p)
    {
      unint64_t v27 = v65;
      unint64_t v28 = __p;
      if (v65 != __p)
      {
        do
          unint64_t v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
        while (v27 != v26);
        unint64_t v28 = __p;
      }
      uint64_t v65 = v26;
      operator delete(v28);
    }
    int64_t v29 = v62;
    if (v62)
    {
      int64_t v30 = v63;
      uint64_t v31 = v62;
      if (v63 == v62) {
        goto LABEL_78;
      }
      do
      {
        uint64_t v33 = *--v30;
        uint64_t v32 = v33;
        void *v30 = 0;
        if (v33) {
          MEMORY[0x21667D390](v32, 0x1000C8077774924);
        }
      }
      while (v30 != v29);
LABEL_77:
      uint64_t v31 = v62;
LABEL_78:
      unint64_t v63 = v29;
      operator delete(v31);
    }
LABEL_79:
    if (v60 != &v61) {
      free(v60);
    }
    return v25;
  }
  uint64_t v5 = *(void ***)(v3 + 16);
  if (!v5)
  {
    v57[0] = (void **)"requires attribute 'explicit_padding'";
    __int16 v58 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v57, (uint64_t)v59);
    uint64_t v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v59);
    if (v59[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (!v66) {
      return v25;
    }
    unint64_t v34 = __p;
    if (__p)
    {
      unint64_t v35 = v65;
      int64_t v36 = __p;
      if (v65 != __p)
      {
        do
          unint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        int64_t v36 = __p;
      }
      uint64_t v65 = v34;
      operator delete(v36);
    }
    int64_t v29 = v62;
    if (v62)
    {
      int64_t v37 = v63;
      uint64_t v31 = v62;
      if (v63 == v62) {
        goto LABEL_78;
      }
      do
      {
        uint64_t v39 = *--v37;
        uint64_t v38 = v39;
        void *v37 = 0;
        if (v39) {
          MEMORY[0x21667D390](v38, 0x1000C8077774924);
        }
      }
      while (v37 != v29);
      goto LABEL_77;
    }
    goto LABEL_79;
  }
  uint64_t v6 = *(void *)(v3 + 24);
  if (!v6)
  {
    v57[0] = (void **)"requires attribute 'padding_style'";
    __int16 v58 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v57, (uint64_t)v59);
    uint64_t v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v59);
    if (v59[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (!v66) {
      return v25;
    }
    uint64_t v40 = __p;
    if (__p)
    {
      uint64_t v41 = v65;
      uint64_t v42 = __p;
      if (v65 != __p)
      {
        do
          uint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        uint64_t v42 = __p;
      }
      uint64_t v65 = v40;
      operator delete(v42);
    }
    int64_t v29 = v62;
    if (v62)
    {
      uint64_t v43 = v63;
      uint64_t v31 = v62;
      if (v63 == v62) {
        goto LABEL_78;
      }
      do
      {
        uint64_t v45 = *--v43;
        uint64_t v44 = v45;
        void *v43 = 0;
        if (v45) {
          MEMORY[0x21667D390](v44, 0x1000C8077774924);
        }
      }
      while (v43 != v29);
      goto LABEL_77;
    }
    goto LABEL_79;
  }
  uint64_t v7 = *(void ***)(v3 + 32);
  if (!v7)
  {
    v57[0] = (void **)"requires attribute 'strides'";
    __int16 v58 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v57, (uint64_t)v59);
    uint64_t v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v59);
    if (v59[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (!v66) {
      return v25;
    }
    uint64_t v46 = __p;
    if (__p)
    {
      __int16 v47 = v65;
      unsigned int v48 = __p;
      if (v65 != __p)
      {
        do
          __int16 v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        unsigned int v48 = __p;
      }
      uint64_t v65 = v46;
      operator delete(v48);
    }
    int64_t v29 = v62;
    if (v62)
    {
      unsigned int v49 = v63;
      uint64_t v31 = v62;
      if (v63 == v62) {
        goto LABEL_78;
      }
      do
      {
        uint64_t v51 = *--v49;
        uint64_t v50 = v51;
        *unsigned int v49 = 0;
        if (v51) {
          MEMORY[0x21667D390](v50, 0x1000C8077774924);
        }
      }
      while (v49 != v29);
      goto LABEL_77;
    }
    goto LABEL_79;
  }
  uint64_t v8 = *(void ***)v3;
  v59[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v7, (void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0; {
  v59[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v4, (void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0; {
  v59[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(v5, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0; {
  v59[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v6, (void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0; {
  v59[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v8, (void **)"channelAxis", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0; {
  uint64_t v9 = *(void *)this;
  }
  unint64_t v10 = *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  unsigned int v56 = 1;
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v9, v10, (void **)"operand", (void **)7, 0)) {
    return 0;
  }
  unsigned int v11 = 1;
  uint64_t ODSOperands = mlir::tensor::UnPackOp::getODSOperands(this, 1u);
  if (v13)
  {
    uint64_t v14 = v13;
    uint64_t v15 = 0;
    uint64_t v16 = ODSOperands + 24;
    while (1)
    {
      uint64_t v17 = *(void *)this;
      unint64_t v18 = *(void *)(*(void *)v16 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v56 = v15 + 2;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v17, v18, (void **)"operand", (void **)7, (int)v15 + 1))return 0; {
      ++v15;
      }
      v16 += 32;
      if (v14 == v15)
      {
        unsigned int v11 = v15 + 1;
        break;
      }
    }
  }
  uint64_t v19 = mlir::tensor::UnPackOp::getODSOperands(this, 2u);
  uint64_t v21 = v20;
  if (v20 >= 2)
  {
    v57[0] = (void **)"operand group starting at #";
    __int16 v58 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v57, (uint64_t)v59);
    uint64_t v22 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v59, &v56);
    uint64_t v23 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v22, " requires 0 or 1 element, but found ");
    uint64_t v55 = v21;
    uint64_t v24 = mlir::InFlightDiagnostic::operator<<<unsigned long &>(v23, &v55);
    uint64_t v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v24);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v59);
    return v25;
  }
  if (v20
    && !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(v19 + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, v11))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v52 = *(void *)this - 16;
  }
  else {
    uint64_t v52 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v52, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
}

void mlir::mps::DepthwiseConv3DDataGradientOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::DepthwiseConv3DOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v12, v7, v6);
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v5;
  long long v9 = *(_OWORD *)(v5 + 16);
  *(void *)(a1 + 56) = *(void *)(v5 + 32);
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)v12;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.depthwise_conv_3d", 21, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::DepthwiseConv3DOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x416C656E6E616863 || *(void *)(__s1 + 3) != 0x736978416C656E6ELL) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[3];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n)) {
        return 0;
      }
      return a2[1];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::DepthwiseConv3DOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, uint64_t a4)
{
  uint64_t v5 = (void *)result;
  switch(a3)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v5[4] = v11;
        }
        else
        {
          v5[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x416C656E6E616863 && *(void *)(__s1 + 3) == 0x736978416C656E6ELL)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v7 = a4;
          }
          else {
            uint64_t v7 = 0;
          }
          *(void *)uint64_t result = v7;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v5[3] = v8;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          v5[1] = v9;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          v5[2] = v10;
        }
        else
        {
          v5[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::mps::DepthwiseConv3DOp::getChannelAxis(mlir::mps::DepthwiseConv3DOp *this)
{
  uint64_t v5 = *(void *)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  mlir::IntegerAttr::getValue((uint64_t)&v5, (llvm::APInt *)&v3);
  if (v4 <= 0x40) {
    return (uint64_t)((void)v3 << -(uint64_t)v4) >> -(uint64_t)v4;
  }
  uint64_t v2 = *v3;
  MEMORY[0x21667D390]();
  return v2;
}

BOOL mlir::mps::DepthwiseConv3DOp::verifyInvariantsImpl(mlir::mps::DepthwiseConv3DOp *this)
{
  uint64_t v49 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v3 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v3 = 0;
  }
  unsigned int v4 = *(void ***)(v3 + 8);
  if (v4)
  {
    uint64_t v5 = *(void ***)(v3 + 16);
    if (v5)
    {
      uint64_t v6 = *(void *)(v3 + 24);
      if (v6)
      {
        uint64_t v7 = *(void ***)(v3 + 32);
        if (v7)
        {
          uint64_t v8 = *(void ***)v3;
          v41[0] = v2;
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v7, (void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0; {
          v41[0] = *(void *)this;
          }
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v4, (void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0; {
          v41[0] = *(void *)this;
          }
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(v5, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0; {
          v41[0] = *(void *)this;
          }
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v6, (void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0; {
          v41[0] = *(void *)this;
          }
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v8, (void **)"channelAxis", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u))
          {
            return 0;
          }
          if (*(_DWORD *)(*(void *)this + 36)) {
            uint64_t v9 = *(void *)this - 16;
          }
          else {
            uint64_t v9 = 0;
          }
          uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v9, 0);
          return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
        }
        v39[0] = (void **)"requires attribute 'strides'";
        __int16 v40 = 259;
        mlir::OpState::emitOpError((uint64_t *)this, v39, (uint64_t)v41);
        uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
        if (v41[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
        }
        if (v48)
        {
          uint64_t v32 = __p;
          if (__p)
          {
            uint64_t v33 = v47;
            unint64_t v34 = __p;
            if (v47 != __p)
            {
              do
                uint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
              while (v33 != v32);
              unint64_t v34 = __p;
            }
            __int16 v47 = v32;
            operator delete(v34);
          }
          uint64_t v15 = v44;
          if (!v44) {
            goto LABEL_78;
          }
          unint64_t v35 = v45;
          uint64_t v17 = v44;
          if (v45 == v44)
          {
LABEL_77:
            uint64_t v45 = v15;
            operator delete(v17);
LABEL_78:
            if (v42 != &v43) {
              free(v42);
            }
            return v11;
          }
          do
          {
            uint64_t v37 = *--v35;
            uint64_t v36 = v37;
            void *v35 = 0;
            if (v37) {
              MEMORY[0x21667D390](v36, 0x1000C8077774924);
            }
          }
          while (v35 != v15);
LABEL_76:
          uint64_t v17 = v44;
          goto LABEL_77;
        }
      }
      else
      {
        v39[0] = (void **)"requires attribute 'padding_style'";
        __int16 v40 = 259;
        mlir::OpState::emitOpError((uint64_t *)this, v39, (uint64_t)v41);
        uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
        if (v41[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
        }
        if (v48)
        {
          uint64_t v26 = __p;
          if (__p)
          {
            unint64_t v27 = v47;
            unint64_t v28 = __p;
            if (v47 != __p)
            {
              do
                unint64_t v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
              while (v27 != v26);
              unint64_t v28 = __p;
            }
            __int16 v47 = v26;
            operator delete(v28);
          }
          uint64_t v15 = v44;
          if (!v44) {
            goto LABEL_78;
          }
          int64_t v29 = v45;
          uint64_t v17 = v44;
          if (v45 == v44) {
            goto LABEL_77;
          }
          do
          {
            uint64_t v31 = *--v29;
            uint64_t v30 = v31;
            *int64_t v29 = 0;
            if (v31) {
              MEMORY[0x21667D390](v30, 0x1000C8077774924);
            }
          }
          while (v29 != v15);
          goto LABEL_76;
        }
      }
    }
    else
    {
      v39[0] = (void **)"requires attribute 'explicit_padding'";
      __int16 v40 = 259;
      mlir::OpState::emitOpError((uint64_t *)this, v39, (uint64_t)v41);
      uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
      if (v41[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
      }
      if (v48)
      {
        unint64_t v20 = __p;
        if (__p)
        {
          uint64_t v21 = v47;
          uint64_t v22 = __p;
          if (v47 != __p)
          {
            do
              uint64_t v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
            while (v21 != v20);
            uint64_t v22 = __p;
          }
          __int16 v47 = v20;
          operator delete(v22);
        }
        uint64_t v15 = v44;
        if (!v44) {
          goto LABEL_78;
        }
        uint64_t v23 = v45;
        uint64_t v17 = v44;
        if (v45 == v44) {
          goto LABEL_77;
        }
        do
        {
          uint64_t v25 = *--v23;
          uint64_t v24 = v25;
          *uint64_t v23 = 0;
          if (v25) {
            MEMORY[0x21667D390](v24, 0x1000C8077774924);
          }
        }
        while (v23 != v15);
        goto LABEL_76;
      }
    }
  }
  else
  {
    v39[0] = (void **)"requires attribute 'dilation_rates'";
    __int16 v40 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v39, (uint64_t)v41);
    uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
    if (v41[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
    }
    if (v48)
    {
      uint64_t v12 = __p;
      if (__p)
      {
        uint64_t v13 = v47;
        uint64_t v14 = __p;
        if (v47 != __p)
        {
          do
            uint64_t v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          uint64_t v14 = __p;
        }
        __int16 v47 = v12;
        operator delete(v14);
      }
      uint64_t v15 = v44;
      if (!v44) {
        goto LABEL_78;
      }
      uint64_t v16 = v45;
      uint64_t v17 = v44;
      if (v45 == v44) {
        goto LABEL_77;
      }
      do
      {
        uint64_t v19 = *--v16;
        uint64_t v18 = v19;
        void *v16 = 0;
        if (v19) {
          MEMORY[0x21667D390](v18, 0x1000C8077774924);
        }
      }
      while (v16 != v15);
      goto LABEL_76;
    }
  }
  return v11;
}

void mlir::mps::DepthwiseConv3DOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::DepthwiseConv3DWeightsGradientOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x416C656E6E616863 || *(void *)(__s1 + 3) != 0x736978416C656E6ELL) {
        return 0;
      }
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[3];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n)) {
        return 0;
      }
      return a2[1];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::DepthwiseConv3DWeightsGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, uint64_t a4)
{
  uint64_t v5 = (void *)result;
  switch(a3)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v5[4] = v11;
        }
        else
        {
          v5[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x416C656E6E616863 && *(void *)(__s1 + 3) == 0x736978416C656E6ELL)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
            uint64_t v7 = a4;
          }
          else {
            uint64_t v7 = 0;
          }
          *(void *)uint64_t result = v7;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v5[3] = v8;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          v5[1] = v9;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          v5[2] = v10;
        }
        else
        {
          v5[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::DepthwiseConv3DWeightsGradientOp::verifyInvariantsImpl(mlir::mps::DepthwiseConv3DWeightsGradientOp *this)
{
  uint64_t v49 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v3 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v3 = 0;
  }
  unsigned int v4 = *(void ***)(v3 + 8);
  if (v4)
  {
    uint64_t v5 = *(void ***)(v3 + 16);
    if (v5)
    {
      uint64_t v6 = *(void *)(v3 + 24);
      if (v6)
      {
        uint64_t v7 = *(void ***)(v3 + 32);
        if (v7)
        {
          uint64_t v8 = *(void ***)v3;
          v41[0] = v2;
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v7, (void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0; {
          v41[0] = *(void *)this;
          }
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v4, (void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0; {
          v41[0] = *(void *)this;
          }
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(v5, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0; {
          v41[0] = *(void *)this;
          }
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v6, (void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0; {
          v41[0] = *(void *)this;
          }
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v8, (void **)"channelAxis", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this,
                                   *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8,
                                   (void **)"operand",
                                   (void **)7,
                                   2u))
          {
            return 0;
          }
          if (*(_DWORD *)(*(void *)this + 36)) {
            uint64_t v9 = *(void *)this - 16;
          }
          else {
            uint64_t v9 = 0;
          }
          uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v9, 0);
          return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
        }
        v39[0] = (void **)"requires attribute 'strides'";
        __int16 v40 = 259;
        mlir::OpState::emitOpError((uint64_t *)this, v39, (uint64_t)v41);
        uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
        if (v41[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
        }
        if (v48)
        {
          uint64_t v32 = __p;
          if (__p)
          {
            uint64_t v33 = v47;
            unint64_t v34 = __p;
            if (v47 != __p)
            {
              do
                uint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
              while (v33 != v32);
              unint64_t v34 = __p;
            }
            __int16 v47 = v32;
            operator delete(v34);
          }
          uint64_t v15 = v44;
          if (!v44) {
            goto LABEL_79;
          }
          unint64_t v35 = v45;
          uint64_t v17 = v44;
          if (v45 == v44)
          {
LABEL_78:
            uint64_t v45 = v15;
            operator delete(v17);
LABEL_79:
            if (v42 != &v43) {
              free(v42);
            }
            return v11;
          }
          do
          {
            uint64_t v37 = *--v35;
            uint64_t v36 = v37;
            void *v35 = 0;
            if (v37) {
              MEMORY[0x21667D390](v36, 0x1000C8077774924);
            }
          }
          while (v35 != v15);
LABEL_77:
          uint64_t v17 = v44;
          goto LABEL_78;
        }
      }
      else
      {
        v39[0] = (void **)"requires attribute 'padding_style'";
        __int16 v40 = 259;
        mlir::OpState::emitOpError((uint64_t *)this, v39, (uint64_t)v41);
        uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
        if (v41[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
        }
        if (v48)
        {
          uint64_t v26 = __p;
          if (__p)
          {
            unint64_t v27 = v47;
            unint64_t v28 = __p;
            if (v47 != __p)
            {
              do
                unint64_t v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
              while (v27 != v26);
              unint64_t v28 = __p;
            }
            __int16 v47 = v26;
            operator delete(v28);
          }
          uint64_t v15 = v44;
          if (!v44) {
            goto LABEL_79;
          }
          int64_t v29 = v45;
          uint64_t v17 = v44;
          if (v45 == v44) {
            goto LABEL_78;
          }
          do
          {
            uint64_t v31 = *--v29;
            uint64_t v30 = v31;
            *int64_t v29 = 0;
            if (v31) {
              MEMORY[0x21667D390](v30, 0x1000C8077774924);
            }
          }
          while (v29 != v15);
          goto LABEL_77;
        }
      }
    }
    else
    {
      v39[0] = (void **)"requires attribute 'explicit_padding'";
      __int16 v40 = 259;
      mlir::OpState::emitOpError((uint64_t *)this, v39, (uint64_t)v41);
      uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
      if (v41[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
      }
      if (v48)
      {
        unint64_t v20 = __p;
        if (__p)
        {
          uint64_t v21 = v47;
          uint64_t v22 = __p;
          if (v47 != __p)
          {
            do
              uint64_t v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
            while (v21 != v20);
            uint64_t v22 = __p;
          }
          __int16 v47 = v20;
          operator delete(v22);
        }
        uint64_t v15 = v44;
        if (!v44) {
          goto LABEL_79;
        }
        uint64_t v23 = v45;
        uint64_t v17 = v44;
        if (v45 == v44) {
          goto LABEL_78;
        }
        do
        {
          uint64_t v25 = *--v23;
          uint64_t v24 = v25;
          *uint64_t v23 = 0;
          if (v25) {
            MEMORY[0x21667D390](v24, 0x1000C8077774924);
          }
        }
        while (v23 != v15);
        goto LABEL_77;
      }
    }
  }
  else
  {
    v39[0] = (void **)"requires attribute 'dilation_rates'";
    __int16 v40 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v39, (uint64_t)v41);
    uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
    if (v41[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
    }
    if (v48)
    {
      uint64_t v12 = __p;
      if (__p)
      {
        uint64_t v13 = v47;
        uint64_t v14 = __p;
        if (v47 != __p)
        {
          do
            uint64_t v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          uint64_t v14 = __p;
        }
        __int16 v47 = v12;
        operator delete(v14);
      }
      uint64_t v15 = v44;
      if (!v44) {
        goto LABEL_79;
      }
      uint64_t v16 = v45;
      uint64_t v17 = v44;
      if (v45 == v44) {
        goto LABEL_78;
      }
      do
      {
        uint64_t v19 = *--v16;
        uint64_t v18 = v19;
        void *v16 = 0;
        if (v19) {
          MEMORY[0x21667D390](v18, 0x1000C8077774924);
        }
      }
      while (v16 != v15);
      goto LABEL_77;
    }
  }
  return v11;
}

void mlir::mps::DepthwiseConv3DWeightsGradientOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::DequantizeLUTOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      int v44 = 3;
      uint64_t v45 = "expected DictionaryAttr to set properties";
      uint64_t v46 = 41;
      uint64_t v26 = &v44;
      unint64_t v27 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v40 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          unint64_t v27 = (char *)v48;
          uint64_t v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          uint64_t v26 = &v44;
          unint64_t v27 = (char *)v48;
        }
      }
      unint64_t v28 = &v27[24 * v49];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)unint64_t v28 = v29;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
    if (!v56) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      uint64_t v31 = v55;
      uint64_t v32 = __p;
      if (v55 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        uint64_t v32 = __p;
      }
      uint64_t v55 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v52;
    if (!v52) {
      goto LABEL_43;
    }
    uint64_t v33 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "axis", 4uLL);
  if (!v8) {
    return 1;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    int v44 = 3;
    uint64_t v46 = 49;
    uint64_t v10 = &v44;
    uint64_t v11 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        int64_t v41 = (char *)&v44 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v11 = (char *)v48;
        uint64_t v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v10 = &v44;
        uint64_t v11 = (char *)v48;
      }
    }
    uint64_t v12 = &v11[24 * v49];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v49;
    if (v47[0])
    {
      uint64_t v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      uint64_t v15 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v42 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v15 = (char *)v48;
          uint64_t v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v14 = &v44;
          uint64_t v15 = (char *)v48;
        }
      }
      uint64_t v16 = &v15[24 * v49];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)uint64_t v16 = v17;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
  }
  if (!v56) {
    return 0;
  }
  uint64_t v18 = __p;
  if (__p)
  {
    uint64_t v19 = v55;
    unint64_t v20 = __p;
    if (v55 != __p)
    {
      do
        uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      unint64_t v20 = __p;
    }
    uint64_t v55 = v18;
    operator delete(v20);
  }
  uint64_t v21 = v52;
  if (v52)
  {
    uint64_t v22 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v25 = *--v22;
      uint64_t v24 = v25;
      void *v22 = 0;
      if (v25) {
        MEMORY[0x21667D390](v24, 0x1000C8077774924);
      }
    }
    while (v22 != v21);
LABEL_41:
    uint64_t v23 = v52;
LABEL_42:
    unint64_t v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51) {
    free(v48);
  }
  return 0;
}

uint64_t mlir::mps::DequantizeLUTOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x263EF8340];
  uint64_t v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"axis", 4, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  uint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::DequantizeLUTOp::verifyInvariantsImpl(mlir::mps::DequantizeLUTOp *this)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(void ***)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  v54[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v3, (void **)"axis", (const char *)4, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v54))return 0; {
  uint64_t v4 = *(void *)this;
  }
  unint64_t v5 = *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  uint64_t v6 = *(void **)(*(void *)v5 + 136);
  BOOL v7 = v6 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v6 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
  if (!v7
    || (uint64_t v8 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(void *)v5 + 8),
        v54[0] = v5,
        v54[1] = v8,
        v49[0] = (void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v54),
        !mlir::Type::isUnsignedInteger((mlir::Type *)v49, 2))
    && !mlir::Type::isUnsignedInteger((mlir::Type *)v49, 4)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)v49, 8))
  {
    __int16 v50 = 261;
    v49[0] = (void **)"operand";
    v49[1] = (void **)7;
    mlir::Operation::emitOpError(v4, v49, (uint64_t)v54);
    if (v54[0])
    {
      int v51 = 3;
      uint64_t v52 = " #";
      uint64_t v53 = 2;
      uint64_t v9 = &v51;
      uint64_t v10 = (char *)v55;
      if (v56 >= v57)
      {
        unint64_t v39 = v56 + 1;
        if (v55 <= &v51 && (char *)v55 + 24 * v56 > (char *)&v51)
        {
          int64_t v45 = (char *)&v51 - (unsigned char *)v55;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v39, 24);
          uint64_t v10 = (char *)v55;
          uint64_t v9 = (int *)((char *)v55 + v45);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v39, 24);
          uint64_t v9 = &v51;
          uint64_t v10 = (char *)v55;
        }
      }
      uint64_t v11 = &v10[24 * v56];
      long long v12 = *(_OWORD *)v9;
      *((void *)v11 + 2) = *((void *)v9 + 2);
      *(_OWORD *)uint64_t v11 = v12;
      uint64_t v13 = ++v56;
      if (v54[0])
      {
        int v51 = 5;
        uint64_t v52 = 0;
        uint64_t v14 = &v51;
        uint64_t v15 = (char *)v55;
        if (v13 >= v57)
        {
          unint64_t v40 = v13 + 1;
          BOOL v41 = (char *)v55 + 24 * v13 > (char *)&v51;
          if (v55 <= &v51 && v41)
          {
            int64_t v46 = (char *)&v51 - (unsigned char *)v55;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v40, 24);
            uint64_t v15 = (char *)v55;
            uint64_t v14 = (int *)((char *)v55 + v46);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v40, 24);
            uint64_t v14 = &v51;
            uint64_t v15 = (char *)v55;
          }
        }
        uint64_t v16 = &v15[24 * v56];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = *((void *)v14 + 2);
        *(_OWORD *)uint64_t v16 = v17;
        uint64_t v18 = ++v56;
        if (v54[0])
        {
          int v51 = 3;
          uint64_t v52 = " must be tensor of palette LUT index values, but got ";
          uint64_t v53 = 53;
          uint64_t v19 = &v51;
          unint64_t v20 = (char *)v55;
          if (v18 >= v57)
          {
            unint64_t v42 = v18 + 1;
            BOOL v43 = (char *)v55 + 24 * v18 > (char *)&v51;
            if (v55 <= &v51 && v43)
            {
              int64_t v47 = (char *)&v51 - (unsigned char *)v55;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v42, 24);
              unint64_t v20 = (char *)v55;
              uint64_t v19 = (int *)((char *)v55 + v47);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v42, 24);
              uint64_t v19 = &v51;
              unint64_t v20 = (char *)v55;
            }
          }
          uint64_t v21 = &v20[24 * v56];
          long long v22 = *(_OWORD *)v19;
          *((void *)v21 + 2) = *((void *)v19 + 2);
          *(_OWORD *)uint64_t v21 = v22;
          ++v56;
          if (v54[0])
          {
            uint64_t v23 = &v51;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v51, v5);
            uint64_t v24 = (char *)v55;
            if (v56 >= v57)
            {
              unint64_t v44 = v56 + 1;
              if (v55 <= &v51 && (char *)v55 + 24 * v56 > (char *)&v51)
              {
                int64_t v48 = (char *)&v51 - (unsigned char *)v55;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v44, 24);
                uint64_t v24 = (char *)v55;
                uint64_t v23 = (int *)((char *)v55 + v48);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v44, 24);
                uint64_t v23 = &v51;
                uint64_t v24 = (char *)v55;
              }
            }
            uint64_t v25 = &v24[24 * v56];
            long long v26 = *(_OWORD *)v23;
            *((void *)v25 + 2) = *((void *)v23 + 2);
            *(_OWORD *)uint64_t v25 = v26;
            ++v56;
          }
        }
      }
    }
    char v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v54);
    if (v54[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v54);
    }
    if (v63)
    {
      unint64_t v28 = __p;
      if (__p)
      {
        long long v29 = v62;
        uint64_t v30 = __p;
        if (v62 != __p)
        {
          do
            long long v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
          while (v29 != v28);
          uint64_t v30 = __p;
        }
        int64_t v62 = v28;
        operator delete(v30);
      }
      uint64_t v31 = v59;
      if (v59)
      {
        uint64_t v32 = v60;
        uint64_t v33 = v59;
        if (v60 != v59)
        {
          do
          {
            uint64_t v35 = *--v32;
            uint64_t v34 = v35;
            void *v32 = 0;
            if (v35) {
              MEMORY[0x21667D390](v34, 0x1000C8077774924);
            }
          }
          while (v32 != v31);
          uint64_t v33 = v59;
        }
        uint64_t v60 = v31;
        operator delete(v33);
      }
      if (v55 != v58) {
        free(v55);
      }
    }
    if (!v27) {
      return 0;
    }
  }
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u))return 0; {
  if (*(_DWORD *)(*(void *)this + 36))
  }
    uint64_t v36 = *(void *)this - 16;
  else {
    uint64_t v36 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v36, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
}

void mlir::mps::DequantizeLUTOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::DequantizeOpGenericAdaptorBase::DequantizeOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v5 = (_OWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  }
  else {
    unint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v11, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v11;
  *(_OWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 40) = v8;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.dequantize", 14, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::DequantizeOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v89 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v75 = v6;
  if (!v6)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      uint64_t v77 = "expected DictionaryAttr to set properties";
      uint64_t v78 = 41;
      long long v26 = &v76;
      char v27 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v63 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v69 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          char v27 = (char *)v80;
          long long v26 = (int *)((char *)v80 + v69);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          long long v26 = &v76;
          char v27 = (char *)v80;
        }
      }
      unint64_t v28 = &v27[24 * v81];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)unint64_t v28 = v29;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      uint64_t v31 = v87;
      uint64_t v32 = __p;
      if (v87 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        uint64_t v32 = __p;
      }
      uint64_t v87 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    uint64_t v33 = v85;
    uint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_79;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_78;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v75, "axis", 4uLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      a3(v79, a4);
      if (v79[0])
      {
        int v76 = 3;
        uint64_t v78 = 49;
        uint64_t v10 = &v76;
        uint64_t v11 = (char *)v80;
        if (v81 >= v82)
        {
          unint64_t v64 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            int64_t v70 = (char *)&v76 - (unsigned char *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            uint64_t v11 = (char *)v80;
            uint64_t v10 = (int *)((char *)v80 + v70);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            uint64_t v10 = &v76;
            uint64_t v11 = (char *)v80;
          }
        }
        uint64_t v12 = &v11[24 * v81];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = *((void *)v10 + 2);
        *(_OWORD *)uint64_t v12 = v13;
        ++v81;
        if (v79[0])
        {
          uint64_t v14 = &v76;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v9);
          uint64_t v15 = (char *)v80;
          if (v81 >= v82)
          {
            unint64_t v65 = v81 + 1;
            if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
            {
              int64_t v71 = (char *)&v76 - (unsigned char *)v80;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              uint64_t v15 = (char *)v80;
              uint64_t v14 = (int *)((char *)v80 + v71);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              uint64_t v14 = &v76;
              uint64_t v15 = (char *)v80;
            }
          }
          uint64_t v16 = &v15[24 * v81];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = *((void *)v14 + 2);
          *(_OWORD *)uint64_t v16 = v17;
          ++v81;
          if (v79[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
          }
        }
      }
      if (!v88) {
        return 0;
      }
      uint64_t v18 = __p;
      if (__p)
      {
        uint64_t v19 = v87;
        unint64_t v20 = __p;
        if (v87 != __p)
        {
          do
            uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          unint64_t v20 = __p;
        }
        uint64_t v87 = v18;
        operator delete(v20);
      }
      uint64_t v21 = v84;
      if (!v84) {
        goto LABEL_80;
      }
      long long v22 = v85;
      uint64_t v23 = v84;
      if (v85 == v84) {
        goto LABEL_79;
      }
      do
      {
        uint64_t v25 = *--v22;
        uint64_t v24 = v25;
        void *v22 = 0;
        if (v25) {
          MEMORY[0x21667D390](v24, 0x1000C8077774924);
        }
      }
      while (v22 != v21);
      goto LABEL_78;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v75, "dtype", 5uLL);
  if (!v36)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      uint64_t v77 = "expected key entry for dtype in DictionaryAttr to set Properties.";
      uint64_t v78 = 65;
      uint64_t v52 = &v76;
      uint64_t v53 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v67 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v73 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          uint64_t v53 = (char *)v80;
          uint64_t v52 = (int *)((char *)v80 + v73);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          uint64_t v52 = &v76;
          uint64_t v53 = (char *)v80;
        }
      }
      unint64_t v54 = &v53[24 * v81];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = *((void *)v52 + 2);
      *(_OWORD *)unint64_t v54 = v55;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    unsigned int v56 = __p;
    if (__p)
    {
      unsigned int v57 = v87;
      __int16 v58 = __p;
      if (v87 != __p)
      {
        do
          unsigned int v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        __int16 v58 = __p;
      }
      uint64_t v87 = v56;
      operator delete(v58);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    long long v59 = v85;
    uint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_79;
    }
    do
    {
      uint64_t v61 = *--v59;
      uint64_t v60 = v61;
      *long long v59 = 0;
      if (v61) {
        MEMORY[0x21667D390](v60, 0x1000C8077774924);
      }
    }
    while (v59 != v21);
    goto LABEL_78;
  }
  uint64_t v37 = v36;
  if (*(_UNKNOWN **)(*(void *)v36 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
  {
    a1[1] = v36;
    return 1;
  }
  a3(v79, a4);
  if (v79[0])
  {
    int v76 = 3;
    uint64_t v78 = 50;
    unint64_t v38 = &v76;
    unint64_t v39 = (char *)v80;
    if (v81 >= v82)
    {
      unint64_t v66 = v81 + 1;
      if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
      {
        int64_t v72 = (char *)&v76 - (unsigned char *)v80;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        unint64_t v39 = (char *)v80;
        unint64_t v38 = (int *)((char *)v80 + v72);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        unint64_t v38 = &v76;
        unint64_t v39 = (char *)v80;
      }
    }
    unint64_t v40 = &v39[24 * v81];
    long long v41 = *(_OWORD *)v38;
    *((void *)v40 + 2) = *((void *)v38 + 2);
    *(_OWORD *)unint64_t v40 = v41;
    ++v81;
    if (v79[0])
    {
      unint64_t v42 = &v76;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v37);
      BOOL v43 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v68 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v74 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          BOOL v43 = (char *)v80;
          unint64_t v42 = (int *)((char *)v80 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          unint64_t v42 = &v76;
          BOOL v43 = (char *)v80;
        }
      }
      unint64_t v44 = &v43[24 * v81];
      long long v45 = *(_OWORD *)v42;
      *((void *)v44 + 2) = *((void *)v42 + 2);
      *(_OWORD *)unint64_t v44 = v45;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
  }
  if (v88)
  {
    int64_t v46 = __p;
    if (__p)
    {
      int64_t v47 = v87;
      int64_t v48 = __p;
      if (v87 != __p)
      {
        do
          int64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        int64_t v48 = __p;
      }
      uint64_t v87 = v46;
      operator delete(v48);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    unsigned int v49 = v85;
    uint64_t v23 = v84;
    if (v85 == v84)
    {
LABEL_79:
      uint64_t v85 = v21;
      operator delete(v23);
LABEL_80:
      if (v80 != v83) {
        free(v80);
      }
      return 0;
    }
    do
    {
      uint64_t v51 = *--v49;
      uint64_t v50 = v51;
      *unsigned int v49 = 0;
      if (v51) {
        MEMORY[0x21667D390](v50, 0x1000C8077774924);
      }
    }
    while (v49 != v21);
LABEL_78:
    uint64_t v23 = v84;
    goto LABEL_79;
  }
  return 0;
}

uint64_t mlir::mps::DequantizeOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v21[6] = *MEMORY[0x263EF8340];
  uint64_t v18 = a1;
  uint64_t v19 = v21;
  uint64_t v20 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"axis", 4, *a2);
    uint64_t v5 = v4;
    unsigned int v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      unsigned int v6 = v20;
    }
    uint64_t v7 = (uint64_t *)((char *)v19 + 16 * v6);
    uint64_t *v7 = NamedAttr;
    v7[1] = v5;
    unsigned int v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    uint64_t v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      uint64_t v10 = (uint64_t *)v19;
      if (v8) {
        goto LABEL_6;
      }
LABEL_13:
      uint64_t DictionaryAttr = 0;
      if (v10 == v21) {
        return DictionaryAttr;
      }
      goto LABEL_7;
    }
  }
  else
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_5;
    }
  }
  uint64_t v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"dtype", 5, v9);
  uint64_t v15 = v14;
  unsigned int v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    unsigned int v16 = v20;
  }
  long long v17 = (uint64_t *)((char *)v19 + 16 * v16);
  uint64_t *v17 = v13;
  v17[1] = v15;
  unsigned int v8 = v20 + 1;
  LODWORD(v20) = v8;
  uint64_t v10 = (uint64_t *)v19;
  if (!v8) {
    goto LABEL_13;
  }
LABEL_6:
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  uint64_t v10 = (uint64_t *)v19;
  if (v19 != v21) {
LABEL_7:
  }
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::mps::DequantizeOp::getAxis(mlir::mps::DequantizeOp *this)
{
  uint64_t v5 = *(void *)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  if (!v5) {
    return 0;
  }
  mlir::IntegerAttr::getValue((uint64_t)&v5, (llvm::APInt *)&v3);
  if (v4 <= 0x40) {
    return ((uint64_t)((void)v3 << -(uint64_t)v4) >> -(uint64_t)v4) | 0x100000000;
  }
  unsigned int v2 = *v3;
  MEMORY[0x21667D390]();
  return v2 | 0x100000000;
}

void mlir::mps::DequantizeOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v31[2] = *MEMORY[0x263EF8340];
  uint64_t v25 = a4;
  uint64_t v26 = a3;
  uint64_t v23 = a6;
  uint64_t v24 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v26, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v25, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v24, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v23, 1);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties>(a2)
            + 8) = a7;
  if (a8) {
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties>(a2) = a8;
  }
  __src = v31;
  uint64_t v30 = 0x200000000;
  uint64_t v12 = *a1;
  mlir::ValueRange::ValueRange(v28, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v15 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v27, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DequantizeOp::inferReturnTypes(v12, v16, v17, v28[0], v28[1], Dictionary, v15, v18, v27[0], v27[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v19 = __src;
  }
  uint64_t v20 = v30;
  uint64_t v21 = *(unsigned int *)(a2 + 72);
  unint64_t v22 = v21 + v30;
  if (v22 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v22, 8);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  if (v20)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v21), v19, 8 * v20);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v21 + v20;
  if (__src != v31) {
    free(__src);
  }
}

BOOL mlir::mps::DequantizeOp::verifyInvariantsImpl(mlir::mps::DequantizeOp *this)
{
  uint64_t v121 = *MEMORY[0x263EF8340];
  unint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v3 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = *(void *)(v3 + 8);
  if (v4)
  {
    uint64_t v5 = *(void ***)v3;
    unint64_t v110 = v2;
    if (!mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v4, (void **)"dtype", (const char *)5, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps4(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v110))return 0; {
    unint64_t v110 = *(void *)this;
    }
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v5, (void **)"axis", (const char *)4, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v110))return 0; {
    uint64_t v6 = *(void *)this;
    }
    uint64_t v7 = (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
    unsigned int v8 = *v7;
    uint64_t v9 = (void *)*((void *)*v7 + 17);
    if (v9 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      || v9 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      uint64_t v11 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v8 + 8);
      unint64_t v110 = (unint64_t)v7;
      uint64_t v111 = v11;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v110);
      if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
        || mlir::Type::isF16((mlir::Type *)&OperandRange)
        || mlir::Type::isF32((mlir::Type *)&OperandRange)
        || mlir::Type::isBF16((mlir::Type *)&OperandRange)
        || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
      {
LABEL_89:
        if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u))
        {
          uint64_t v49 = *(void *)this;
          unint64_t v50 = *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8;
          uint64_t v51 = *(void **)(*(void *)v50 + 136);
          if (v51 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
            || v51 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
          {
            uint64_t v53 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(void *)v50 + 8);
            unint64_t v110 = v50;
            uint64_t v111 = v53;
            int64_t v104 = (void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v110);
            if (mlir::Type::isSignedInteger((mlir::Type *)&v104, 2)
              || mlir::Type::isSignedInteger((mlir::Type *)&v104, 4)
              || mlir::Type::isSignedInteger((mlir::Type *)&v104, 8)
              || mlir::Type::isSignedInteger((mlir::Type *)&v104, 16)
              || mlir::Type::isSignedInteger((mlir::Type *)&v104, 32)
              || mlir::Type::isUnsignedInteger((mlir::Type *)&v104, 1)
              || mlir::Type::isUnsignedInteger((mlir::Type *)&v104, 2)
              || mlir::Type::isUnsignedInteger((mlir::Type *)&v104, 4)
              || mlir::Type::isUnsignedInteger((mlir::Type *)&v104, 8)
              || mlir::Type::isUnsignedInteger((mlir::Type *)&v104, 16)
              || mlir::Type::isUnsignedInteger((mlir::Type *)&v104, 32)
              || *((_UNKNOWN **)*v104 + 17) == &mlir::detail::TypeIDResolver<mlir::mps::NF4Type,void>::id)
            {
              goto LABEL_176;
            }
          }
          __int16 v106 = 261;
          int64_t v104 = (void **)"operand";
          uint64_t v105 = 7;
          mlir::Operation::emitOpError(v49, &v104, (uint64_t)&v110);
          if (v110)
          {
            LODWORD(OperandRange) = 3;
            int64_t v108 = " #";
            uint64_t v109 = 2;
            p_uint64_t OperandRange = &OperandRange;
            long long v55 = (char *)v112;
            if (v113 >= v114)
            {
              unint64_t v84 = v113 + 1;
              if (v112 <= &OperandRange && (char *)v112 + 24 * v113 > (char *)&OperandRange)
              {
                int64_t v96 = (char *)&OperandRange - (unsigned char *)v112;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v84, 24);
                long long v55 = (char *)v112;
                p_uint64_t OperandRange = (uint64_t *)((char *)v112 + v96);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v84, 24);
                p_uint64_t OperandRange = &OperandRange;
                long long v55 = (char *)v112;
              }
            }
            unsigned int v56 = &v55[24 * v113];
            long long v57 = *(_OWORD *)p_OperandRange;
            *((void *)v56 + 2) = p_OperandRange[2];
            *(_OWORD *)unsigned int v56 = v57;
            uint64_t v58 = ++v113;
            if (v110)
            {
              LODWORD(OperandRange) = 5;
              int64_t v108 = (const char *)2;
              long long v59 = &OperandRange;
              uint64_t v60 = (char *)v112;
              if (v58 >= v114)
              {
                unint64_t v86 = v58 + 1;
                BOOL v87 = (char *)v112 + 24 * v58 > (char *)&OperandRange;
                if (v112 <= &OperandRange && v87)
                {
                  int64_t v98 = (char *)&OperandRange - (unsigned char *)v112;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v86, 24);
                  uint64_t v60 = (char *)v112;
                  long long v59 = (uint64_t *)((char *)v112 + v98);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v86, 24);
                  long long v59 = &OperandRange;
                  uint64_t v60 = (char *)v112;
                }
              }
              uint64_t v61 = &v60[24 * v113];
              long long v62 = *(_OWORD *)v59;
              *((void *)v61 + 2) = v59[2];
              *(_OWORD *)uint64_t v61 = v62;
              uint64_t v63 = ++v113;
              if (v110)
              {
                LODWORD(OperandRange) = 3;
                int64_t v108 = " must be tensor of quantized values, but got ";
                uint64_t v109 = 45;
                unint64_t v64 = &OperandRange;
                unint64_t v65 = (char *)v112;
                if (v63 >= v114)
                {
                  unint64_t v90 = v63 + 1;
                  BOOL v91 = (char *)v112 + 24 * v63 > (char *)&OperandRange;
                  if (v112 <= &OperandRange && v91)
                  {
                    int64_t v100 = (char *)&OperandRange - (unsigned char *)v112;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v90, 24);
                    unint64_t v65 = (char *)v112;
                    unint64_t v64 = (uint64_t *)((char *)v112 + v100);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v90, 24);
                    unint64_t v64 = &OperandRange;
                    unint64_t v65 = (char *)v112;
                  }
                }
                unint64_t v66 = &v65[24 * v113];
                long long v67 = *(_OWORD *)v64;
                *((void *)v66 + 2) = v64[2];
                *(_OWORD *)unint64_t v66 = v67;
                ++v113;
                if (v110)
                {
                  unint64_t v68 = &OperandRange;
                  mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, v50);
                  int64_t v69 = (char *)v112;
                  if (v113 >= v114)
                  {
                    unint64_t v94 = v113 + 1;
                    if (v112 <= &OperandRange && (char *)v112 + 24 * v113 > (char *)&OperandRange)
                    {
                      int64_t v102 = (char *)&OperandRange - (unsigned char *)v112;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v94, 24);
                      int64_t v69 = (char *)v112;
                      unint64_t v68 = (uint64_t *)((char *)v112 + v102);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v94, 24);
                      unint64_t v68 = &OperandRange;
                      int64_t v69 = (char *)v112;
                    }
                  }
                  int64_t v70 = &v69[24 * v113];
                  long long v71 = *(_OWORD *)v68;
                  *((void *)v70 + 2) = v68[2];
                  *(_OWORD *)int64_t v70 = v71;
                  ++v113;
                }
              }
            }
          }
          char v72 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v110);
          if (v110) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v110);
          }
          if (v120)
          {
            int64_t v73 = __p;
            if (__p)
            {
              int64_t v74 = v119;
              uint64_t v75 = __p;
              if (v119 != __p)
              {
                do
                  int64_t v74 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v74 - 1);
                while (v74 != v73);
                uint64_t v75 = __p;
              }
              unint64_t v119 = v73;
              operator delete(v75);
            }
            int v76 = v116;
            if (v116)
            {
              uint64_t v77 = v117;
              uint64_t v78 = v116;
              if (v117 != v116)
              {
                do
                {
                  uint64_t v80 = *--v77;
                  uint64_t v79 = v80;
                  *uint64_t v77 = 0;
                  if (v80) {
                    MEMORY[0x21667D390](v79, 0x1000C8077774924);
                  }
                }
                while (v77 != v76);
                uint64_t v78 = v116;
              }
              unsigned int v117 = v76;
              operator delete(v78);
            }
            if (v112 != v115) {
              free(v112);
            }
          }
          if (v72)
          {
LABEL_176:
            if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 120) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 3u))
            {
              if (*(_DWORD *)(*(void *)this + 36)) {
                uint64_t v81 = *(void *)this - 16;
              }
              else {
                uint64_t v81 = 0;
              }
              uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v81, 0);
              return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
            }
          }
        }
        return 0;
      }
      unsigned int v8 = *v7;
      uint64_t v9 = (void *)*((void *)*v7 + 17);
    }
    BOOL v12 = v9 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
       || v9 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
    if (!v12
      || (int64_t v104 = v7,
          uint64_t v105 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v8 + 8),
          uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v104),
          !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 2))
      && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 4)
      && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 1)
      && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 2)
      && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 4)
      && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      && *(_UNKNOWN **)(*(void *)OperandRange + 136) != &mlir::detail::TypeIDResolver<mlir::mps::NF4Type,void>::id)
    {
      __int16 v106 = 261;
      int64_t v104 = (void **)"operand";
      uint64_t v105 = 7;
      mlir::Operation::emitOpError(v6, &v104, (uint64_t)&v110);
      if (v110)
      {
        LODWORD(OperandRange) = 3;
        int64_t v108 = " #";
        uint64_t v109 = 2;
        uint64_t v13 = &OperandRange;
        uint64_t v14 = (char *)v112;
        if (v113 >= v114)
        {
          unint64_t v85 = v113 + 1;
          if (v112 <= &OperandRange && (char *)v112 + 24 * v113 > (char *)&OperandRange)
          {
            int64_t v97 = (char *)&OperandRange - (unsigned char *)v112;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v85, 24);
            uint64_t v14 = (char *)v112;
            uint64_t v13 = (uint64_t *)((char *)v112 + v97);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v85, 24);
            uint64_t v13 = &OperandRange;
            uint64_t v14 = (char *)v112;
          }
        }
        uint64_t v15 = &v14[24 * v113];
        long long v16 = *(_OWORD *)v13;
        *((void *)v15 + 2) = v13[2];
        *(_OWORD *)uint64_t v15 = v16;
        uint64_t v17 = ++v113;
        if (v110)
        {
          LODWORD(OperandRange) = 5;
          int64_t v108 = 0;
          int v18 = &OperandRange;
          uint64_t v19 = (char *)v112;
          if (v17 >= v114)
          {
            unint64_t v88 = v17 + 1;
            BOOL v89 = (char *)v112 + 24 * v17 > (char *)&OperandRange;
            if (v112 <= &OperandRange && v89)
            {
              int64_t v99 = (char *)&OperandRange - (unsigned char *)v112;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v88, 24);
              uint64_t v19 = (char *)v112;
              int v18 = (uint64_t *)((char *)v112 + v99);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v88, 24);
              int v18 = &OperandRange;
              uint64_t v19 = (char *)v112;
            }
          }
          uint64_t v20 = &v19[24 * v113];
          long long v21 = *(_OWORD *)v18;
          *((void *)v20 + 2) = v18[2];
          *(_OWORD *)uint64_t v20 = v21;
          uint64_t v22 = ++v113;
          if (v110)
          {
            LODWORD(OperandRange) = 3;
            int64_t v108 = " must be tensor of mps native type values or tensor of quantized values, but got ";
            uint64_t v109 = 81;
            uint64_t v23 = &OperandRange;
            uint64_t v24 = (char *)v112;
            if (v22 >= v114)
            {
              unint64_t v92 = v22 + 1;
              BOOL v93 = (char *)v112 + 24 * v22 > (char *)&OperandRange;
              if (v112 <= &OperandRange && v93)
              {
                int64_t v101 = (char *)&OperandRange - (unsigned char *)v112;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v92, 24);
                uint64_t v24 = (char *)v112;
                uint64_t v23 = (uint64_t *)((char *)v112 + v101);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v92, 24);
                uint64_t v23 = &OperandRange;
                uint64_t v24 = (char *)v112;
              }
            }
            uint64_t v25 = &v24[24 * v113];
            long long v26 = *(_OWORD *)v23;
            *((void *)v25 + 2) = v23[2];
            *(_OWORD *)uint64_t v25 = v26;
            ++v113;
            if (v110)
            {
              char v27 = &OperandRange;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, (uint64_t)v7);
              unint64_t v28 = (char *)v112;
              if (v113 >= v114)
              {
                unint64_t v95 = v113 + 1;
                if (v112 <= &OperandRange && (char *)v112 + 24 * v113 > (char *)&OperandRange)
                {
                  int64_t v103 = (char *)&OperandRange - (unsigned char *)v112;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v95, 24);
                  unint64_t v28 = (char *)v112;
                  char v27 = (uint64_t *)((char *)v112 + v103);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v95, 24);
                  char v27 = &OperandRange;
                  unint64_t v28 = (char *)v112;
                }
              }
              long long v29 = &v28[24 * v113];
              long long v30 = *(_OWORD *)v27;
              *((void *)v29 + 2) = v27[2];
              *(_OWORD *)long long v29 = v30;
              ++v113;
            }
          }
        }
      }
      char v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v110);
      if (v110) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v110);
      }
      if (v120)
      {
        uint64_t v32 = __p;
        if (__p)
        {
          uint64_t v33 = v119;
          uint64_t v34 = __p;
          if (v119 != __p)
          {
            do
              uint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
            while (v33 != v32);
            uint64_t v34 = __p;
          }
          unint64_t v119 = v32;
          operator delete(v34);
        }
        uint64_t v35 = v116;
        if (v116)
        {
          uint64_t v36 = v117;
          uint64_t v37 = v116;
          if (v117 != v116)
          {
            do
            {
              uint64_t v39 = *--v36;
              uint64_t v38 = v39;
              void *v36 = 0;
              if (v39) {
                MEMORY[0x21667D390](v38, 0x1000C8077774924);
              }
            }
            while (v36 != v35);
            uint64_t v37 = v116;
          }
          unsigned int v117 = v35;
          operator delete(v37);
        }
        if (v112 != v115) {
          free(v112);
        }
      }
      if (!v31) {
        return 0;
      }
    }
    goto LABEL_89;
  }
  int64_t v104 = (void **)"requires attribute 'dtype'";
  __int16 v106 = 259;
  mlir::OpState::emitOpError((uint64_t *)this, &v104, (uint64_t)&v110);
  uint64_t v40 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v110);
  if (v110) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v110);
  }
  if (v120)
  {
    long long v41 = __p;
    if (__p)
    {
      unint64_t v42 = v119;
      BOOL v43 = __p;
      if (v119 != __p)
      {
        do
          unint64_t v42 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v42 - 1);
        while (v42 != v41);
        BOOL v43 = __p;
      }
      unint64_t v119 = v41;
      operator delete(v43);
    }
    unint64_t v44 = v116;
    if (v116)
    {
      long long v45 = v117;
      int64_t v46 = v116;
      if (v117 != v116)
      {
        do
        {
          uint64_t v48 = *--v45;
          uint64_t v47 = v48;
          void *v45 = 0;
          if (v48) {
            MEMORY[0x21667D390](v47, 0x1000C8077774924);
          }
        }
        while (v45 != v44);
        int64_t v46 = v116;
      }
      unsigned int v117 = v44;
      operator delete(v46);
    }
    if (v112 != v115) {
      free(v112);
    }
  }
  return v40;
}

void mlir::mps::DequantizeOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::DimensionSizeOpGenericAdaptorBase::DimensionSizeOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.dimension_size", 18, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::DimensionSizeOp::verifyInvariantsImpl(mlir::mps::DimensionSizeOp *this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps24(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v2 = *(void *)this - 16;
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps24(uint64_t a1, uint64_t a2, void **a3, void **a4, unsigned int a5)
{
  uint64_t v66 = *MEMORY[0x263EF8340];
  uint64_t v10 = *(void *)a2;
  uint64_t v11 = *(void **)(*(void *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isSignedInteger((mlir::Type *)v51, 32) || mlir::Type::isSignedInteger((mlir::Type *)v51, 64)) {
      return 1;
    }
  }
  __int16 v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    int v53 = 3;
    unint64_t v54 = " #";
    uint64_t v55 = 2;
    uint64_t v14 = &v53;
    uint64_t v15 = (char *)v57;
    if (v58 >= v59)
    {
      unint64_t v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        int64_t v47 = (char *)&v53 - (unsigned char *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        uint64_t v15 = (char *)v57;
        uint64_t v14 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        uint64_t v14 = &v53;
        uint64_t v15 = (char *)v57;
      }
    }
    long long v16 = &v15[24 * v58];
    long long v17 = *(_OWORD *)v14;
    *((void *)v16 + 2) = *((void *)v14 + 2);
    *(_OWORD *)long long v16 = v17;
    uint64_t v18 = ++v58;
    if (v56[0])
    {
      int v53 = 5;
      unint64_t v54 = (const char *)a5;
      uint64_t v19 = &v53;
      uint64_t v20 = (char *)v57;
      if (v18 >= v59)
      {
        unint64_t v42 = v18 + 1;
        BOOL v43 = (char *)v57 + 24 * v18 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          int64_t v48 = (char *)&v53 - (unsigned char *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          uint64_t v20 = (char *)v57;
          uint64_t v19 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          uint64_t v19 = &v53;
          uint64_t v20 = (char *)v57;
        }
      }
      long long v21 = &v20[24 * v58];
      long long v22 = *(_OWORD *)v19;
      *((void *)v21 + 2) = *((void *)v19 + 2);
      *(_OWORD *)long long v21 = v22;
      uint64_t v23 = ++v58;
      if (v56[0])
      {
        int v53 = 3;
        unint64_t v54 = " must be tensor of mps index type values, but got ";
        uint64_t v55 = 50;
        uint64_t v24 = &v53;
        uint64_t v25 = (char *)v57;
        if (v23 >= v59)
        {
          unint64_t v44 = v23 + 1;
          BOOL v45 = (char *)v57 + 24 * v23 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            int64_t v49 = (char *)&v53 - (unsigned char *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            uint64_t v25 = (char *)v57;
            uint64_t v24 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            uint64_t v24 = &v53;
            uint64_t v25 = (char *)v57;
          }
        }
        long long v26 = &v25[24 * v58];
        long long v27 = *(_OWORD *)v24;
        *((void *)v26 + 2) = *((void *)v24 + 2);
        *(_OWORD *)long long v26 = v27;
        ++v58;
        if (v56[0])
        {
          unint64_t v28 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          long long v29 = (char *)v57;
          if (v58 >= v59)
          {
            unint64_t v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              int64_t v50 = (char *)&v53 - (unsigned char *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              long long v29 = (char *)v57;
              unint64_t v28 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              unint64_t v28 = &v53;
              long long v29 = (char *)v57;
            }
          }
          long long v30 = &v29[24 * v58];
          long long v31 = *(_OWORD *)v28;
          *((void *)v30 + 2) = *((void *)v28 + 2);
          *(_OWORD *)long long v30 = v31;
          ++v58;
        }
      }
    }
  }
  uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  }
  if (v65)
  {
    uint64_t v32 = __p;
    if (__p)
    {
      uint64_t v33 = v64;
      uint64_t v34 = __p;
      if (v64 != __p)
      {
        do
          uint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        uint64_t v34 = __p;
      }
      unint64_t v64 = v32;
      operator delete(v34);
    }
    uint64_t v35 = v61;
    if (v61)
    {
      uint64_t v36 = v62;
      uint64_t v37 = v61;
      if (v62 != v61)
      {
        do
        {
          uint64_t v39 = *--v36;
          uint64_t v38 = v39;
          void *v36 = 0;
          if (v39) {
            MEMORY[0x21667D390](v38, 0x1000C8077774924);
          }
        }
        while (v36 != v35);
        uint64_t v37 = v61;
      }
      long long v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60) {
      free(v57);
    }
  }
  return v13;
}

void mlir::mps::DimensionSizeOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::DiracOpGenericAdaptorBase::DiracOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.dirac", 9, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::DiracOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::DivideOpGenericAdaptorBase::DivideOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.divide", 10, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::DivideOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::DynamicShapeCastOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      int v44 = 3;
      BOOL v45 = "expected DictionaryAttr to set properties";
      uint64_t v46 = 41;
      long long v26 = &v44;
      long long v27 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v40 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          long long v27 = (char *)v48;
          long long v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          long long v26 = &v44;
          long long v27 = (char *)v48;
        }
      }
      unint64_t v28 = &v27[24 * v49];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)unint64_t v28 = v29;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
    if (!v56) {
      return 0;
    }
    long long v30 = __p;
    if (__p)
    {
      long long v31 = v55;
      uint64_t v32 = __p;
      if (v55 != __p)
      {
        do
          long long v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        uint64_t v32 = __p;
      }
      uint64_t v55 = v30;
      operator delete(v32);
    }
    long long v21 = v52;
    if (!v52) {
      goto LABEL_43;
    }
    uint64_t v33 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "unranked", 8uLL);
  if (!v8) {
    return 1;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    int v44 = 3;
    uint64_t v46 = 53;
    uint64_t v10 = &v44;
    uint64_t v11 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        int64_t v41 = (char *)&v44 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v11 = (char *)v48;
        uint64_t v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v10 = &v44;
        uint64_t v11 = (char *)v48;
      }
    }
    BOOL v12 = &v11[24 * v49];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)BOOL v12 = v13;
    ++v49;
    if (v47[0])
    {
      uint64_t v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      uint64_t v15 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v42 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v15 = (char *)v48;
          uint64_t v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v14 = &v44;
          uint64_t v15 = (char *)v48;
        }
      }
      long long v16 = &v15[24 * v49];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)long long v16 = v17;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
  }
  if (!v56) {
    return 0;
  }
  uint64_t v18 = __p;
  if (__p)
  {
    uint64_t v19 = v55;
    uint64_t v20 = __p;
    if (v55 != __p)
    {
      do
        uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      uint64_t v20 = __p;
    }
    uint64_t v55 = v18;
    operator delete(v20);
  }
  long long v21 = v52;
  if (v52)
  {
    long long v22 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v25 = *--v22;
      uint64_t v24 = v25;
      void *v22 = 0;
      if (v25) {
        MEMORY[0x21667D390](v24, 0x1000C8077774924);
      }
    }
    while (v22 != v21);
LABEL_41:
    uint64_t v23 = v52;
LABEL_42:
    int v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51) {
    free(v48);
  }
  return 0;
}

uint64_t mlir::mps::DynamicShapeCastOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x263EF8340];
  BOOL v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"unranked", 8, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  uint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DynamicShapeCastOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::DynamicShapeCastOp::verifyInvariantsImpl(mlir::mps::DynamicShapeCastOp *this)
{
  uint64_t v60 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(void *)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  v50[0] = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v3, (void **)"unranked", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0))
  {
    return 0;
  }
  uint64_t v4 = *(void *)this;
  if ((*(unsigned char *)(*(void *)this + 46) & 0x80) == 0)
  {
    uint64_t v6 = -1;
    goto LABEL_5;
  }
  uint64_t v5 = *(unsigned int *)(v4 + 68);
  uint64_t v6 = v5 - 1;
  if ((unint64_t)(v5 - 1) <= 1)
  {
    if (v5 == 1)
    {
LABEL_31:
      int v32 = *(_DWORD *)(v4 + 36);
      uint64_t v33 = v4 - 16;
      if (v32) {
        uint64_t v34 = v33;
      }
      else {
        uint64_t v34 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v34, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
    }
    uint64_t v30 = *(void *)(v4 + 72) + 56;
    uint64_t v31 = 1;
    while (mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*(void *)this, (void **)(*(void *)(*(void *)v30 + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, v31))
    {
      ++v31;
      v30 += 32;
      if (v5 == v31)
      {
        uint64_t v4 = *(void *)this;
        goto LABEL_31;
      }
    }
    return 0;
  }
LABEL_5:
  BOOL v45 = (void **)"operand group starting at #";
  __int16 v46 = 259;
  mlir::OpState::emitOpError((uint64_t *)this, &v45, (uint64_t)v50);
  if (v50[0])
  {
    int v47 = 5;
    uint64_t v48 = 1;
    uint64_t v7 = &v47;
    BOOL v8 = (char *)v51;
    if (v52 >= v53)
    {
      unint64_t v37 = v52 + 1;
      if (v51 <= &v47 && (char *)v51 + 24 * v52 > (char *)&v47)
      {
        int64_t v42 = (char *)&v47 - (unsigned char *)v51;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v54, v37, 24);
        BOOL v8 = (char *)v51;
        uint64_t v7 = (int *)((char *)v51 + v42);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v54, v37, 24);
        uint64_t v7 = &v47;
        BOOL v8 = (char *)v51;
      }
    }
    uint64_t v9 = &v8[24 * v52];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = *((void *)v7 + 2);
    *(_OWORD *)uint64_t v9 = v10;
    uint64_t v11 = ++v52;
    if (v50[0])
    {
      int v47 = 3;
      uint64_t v48 = (uint64_t)" requires 0 or 1 element, but found ";
      uint64_t v49 = 36;
      BOOL v12 = &v47;
      long long v13 = (char *)v51;
      if (v11 >= v53)
      {
        unint64_t v38 = v11 + 1;
        BOOL v39 = (char *)v51 + 24 * v11 > (char *)&v47;
        if (v51 <= &v47 && v39)
        {
          int64_t v43 = (char *)&v47 - (unsigned char *)v51;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v54, v38, 24);
          long long v13 = (char *)v51;
          BOOL v12 = (int *)((char *)v51 + v43);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v54, v38, 24);
          BOOL v12 = &v47;
          long long v13 = (char *)v51;
        }
      }
      uint64_t v14 = &v13[24 * v52];
      long long v15 = *(_OWORD *)v12;
      *((void *)v14 + 2) = *((void *)v12 + 2);
      *(_OWORD *)uint64_t v14 = v15;
      uint64_t v16 = ++v52;
      if (v50[0])
      {
        int v47 = 5;
        uint64_t v48 = v6;
        long long v17 = &v47;
        uint64_t v18 = (char *)v51;
        if (v16 >= v53)
        {
          unint64_t v40 = v16 + 1;
          BOOL v41 = (char *)v51 + 24 * v16 > (char *)&v47;
          if (v51 <= &v47 && v41)
          {
            int64_t v44 = (char *)&v47 - (unsigned char *)v51;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v54, v40, 24);
            uint64_t v18 = (char *)v51;
            long long v17 = (int *)((char *)v51 + v44);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v54, v40, 24);
            long long v17 = &v47;
            uint64_t v18 = (char *)v51;
          }
        }
        uint64_t v19 = &v18[24 * v52];
        long long v20 = *(_OWORD *)v17;
        *((void *)v19 + 2) = *((void *)v17 + 2);
        *(_OWORD *)uint64_t v19 = v20;
        ++v52;
      }
    }
  }
  uint64_t v21 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
  if (v50[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
  }
  if (v59)
  {
    long long v22 = __p;
    if (__p)
    {
      uint64_t v23 = v58;
      uint64_t v24 = __p;
      if (v58 != __p)
      {
        do
          uint64_t v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        uint64_t v24 = __p;
      }
      unsigned int v58 = v22;
      operator delete(v24);
    }
    uint64_t v25 = v55;
    if (v55)
    {
      long long v26 = v56;
      long long v27 = v55;
      if (v56 != v55)
      {
        do
        {
          uint64_t v29 = *--v26;
          uint64_t v28 = v29;
          void *v26 = 0;
          if (v29) {
            MEMORY[0x21667D390](v28, 0x1000C8077774924);
          }
        }
        while (v26 != v25);
        long long v27 = v55;
      }
      char v56 = v25;
      operator delete(v27);
    }
    if (v51 != v54) {
      free(v51);
    }
  }
  return v21;
}

void mlir::mps::DynamicShapeCastOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::EluOpGenericAdaptorBase::EluOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.elu", 7, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::EluOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::EqualToOpGenericAdaptorBase::EqualToOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.equal", 9, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::EqualToOp::verifyInvariantsImpl(mlir::mps::EqualToOp *this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v2 = *(void *)this - 16;
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps25(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps25(uint64_t a1, uint64_t a2, void **a3, void **a4, unsigned int a5)
{
  uint64_t v66 = *MEMORY[0x263EF8340];
  uint64_t v10 = *(void *)a2;
  uint64_t v11 = *(void **)(*(void *)a2 + 136);
  BOOL v12 = v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
     || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
  if (!v12
    || (v56[0] = a2,
        v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8),
        v51[0] = (void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56),
        uint64_t v13 = 1,
        !mlir::Type::isSignlessInteger((mlir::Type *)v51, 1)))
  {
    __int16 v52 = 261;
    v51[0] = a3;
    v51[1] = a4;
    mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
    if (v56[0])
    {
      int v53 = 3;
      unint64_t v54 = " #";
      uint64_t v55 = 2;
      uint64_t v14 = &v53;
      long long v15 = (char *)v57;
      if (v58 >= v59)
      {
        unint64_t v41 = v58 + 1;
        if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
        {
          int64_t v47 = (char *)&v53 - (unsigned char *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
          long long v15 = (char *)v57;
          uint64_t v14 = (int *)((char *)v57 + v47);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
          uint64_t v14 = &v53;
          long long v15 = (char *)v57;
        }
      }
      uint64_t v16 = &v15[24 * v58];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)uint64_t v16 = v17;
      uint64_t v18 = ++v58;
      if (v56[0])
      {
        int v53 = 5;
        unint64_t v54 = (const char *)a5;
        uint64_t v19 = &v53;
        long long v20 = (char *)v57;
        if (v18 >= v59)
        {
          unint64_t v42 = v18 + 1;
          BOOL v43 = (char *)v57 + 24 * v18 > (char *)&v53;
          if (v57 <= &v53 && v43)
          {
            int64_t v48 = (char *)&v53 - (unsigned char *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
            long long v20 = (char *)v57;
            uint64_t v19 = (int *)((char *)v57 + v48);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
            uint64_t v19 = &v53;
            long long v20 = (char *)v57;
          }
        }
        uint64_t v21 = &v20[24 * v58];
        long long v22 = *(_OWORD *)v19;
        *((void *)v21 + 2) = *((void *)v19 + 2);
        *(_OWORD *)uint64_t v21 = v22;
        uint64_t v23 = ++v58;
        if (v56[0])
        {
          int v53 = 3;
          unint64_t v54 = " must be tensor of 1-bit signless integer values, but got ";
          uint64_t v55 = 58;
          uint64_t v24 = &v53;
          uint64_t v25 = (char *)v57;
          if (v23 >= v59)
          {
            unint64_t v44 = v23 + 1;
            BOOL v45 = (char *)v57 + 24 * v23 > (char *)&v53;
            if (v57 <= &v53 && v45)
            {
              int64_t v49 = (char *)&v53 - (unsigned char *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
              uint64_t v25 = (char *)v57;
              uint64_t v24 = (int *)((char *)v57 + v49);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
              uint64_t v24 = &v53;
              uint64_t v25 = (char *)v57;
            }
          }
          long long v26 = &v25[24 * v58];
          long long v27 = *(_OWORD *)v24;
          *((void *)v26 + 2) = *((void *)v24 + 2);
          *(_OWORD *)long long v26 = v27;
          ++v58;
          if (v56[0])
          {
            uint64_t v28 = &v53;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
            uint64_t v29 = (char *)v57;
            if (v58 >= v59)
            {
              unint64_t v46 = v58 + 1;
              if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
              {
                int64_t v50 = (char *)&v53 - (unsigned char *)v57;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
                uint64_t v29 = (char *)v57;
                uint64_t v28 = (int *)((char *)v57 + v50);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
                uint64_t v28 = &v53;
                uint64_t v29 = (char *)v57;
              }
            }
            uint64_t v30 = &v29[24 * v58];
            long long v31 = *(_OWORD *)v28;
            *((void *)v30 + 2) = *((void *)v28 + 2);
            *(_OWORD *)uint64_t v30 = v31;
            ++v58;
          }
        }
      }
    }
    uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
    if (v56[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
    }
    if (v65)
    {
      int v32 = __p;
      if (__p)
      {
        uint64_t v33 = v64;
        uint64_t v34 = __p;
        if (v64 != __p)
        {
          do
            uint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
          while (v33 != v32);
          uint64_t v34 = __p;
        }
        unint64_t v64 = v32;
        operator delete(v34);
      }
      uint64_t v35 = v61;
      if (v61)
      {
        uint64_t v36 = v62;
        unint64_t v37 = v61;
        if (v62 != v61)
        {
          do
          {
            uint64_t v39 = *--v36;
            uint64_t v38 = v39;
            void *v36 = 0;
            if (v39) {
              MEMORY[0x21667D390](v38, 0x1000C8077774924);
            }
          }
          while (v36 != v35);
          unint64_t v37 = v61;
        }
        long long v62 = v35;
        operator delete(v37);
      }
      if (v57 != v60) {
        free(v57);
      }
    }
  }
  return v13;
}

void mlir::mps::EqualToOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::ErfOpGenericAdaptorBase::ErfOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.erf", 7, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ErfOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::ExpandDimsOpGenericAdaptorBase::ExpandDimsOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  unint64_t v5 = a2[11];
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.expand_dims", 15, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ExpandDimsOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::ExponentBase10OpGenericAdaptorBase::ExponentBase10OpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.exponent_base_10", 20, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ExponentBase10Op::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::ExponentBase2OpGenericAdaptorBase::ExponentBase2OpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.exponent_base_2", 19, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ExponentBase2Op::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::ExponentOpGenericAdaptorBase::ExponentOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.exponent", 12, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ExponentOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::FastFourierTransformOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v89 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v75 = v6;
  if (!v6)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      uint64_t v77 = "expected DictionaryAttr to set properties";
      uint64_t v78 = 41;
      long long v26 = &v76;
      long long v27 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v63 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v69 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          long long v27 = (char *)v80;
          long long v26 = (int *)((char *)v80 + v69);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          long long v26 = &v76;
          long long v27 = (char *)v80;
        }
      }
      uint64_t v28 = &v27[24 * v81];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      long long v31 = v87;
      int v32 = __p;
      if (v87 != __p)
      {
        do
          long long v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        int v32 = __p;
      }
      BOOL v87 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    uint64_t v33 = v85;
    uint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_79;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_78;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v75, "inverse", 7uLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v79, a4);
      if (v79[0])
      {
        int v76 = 3;
        uint64_t v78 = 52;
        uint64_t v10 = &v76;
        uint64_t v11 = (char *)v80;
        if (v81 >= v82)
        {
          unint64_t v64 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            int64_t v70 = (char *)&v76 - (unsigned char *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            uint64_t v11 = (char *)v80;
            uint64_t v10 = (int *)((char *)v80 + v70);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            uint64_t v10 = &v76;
            uint64_t v11 = (char *)v80;
          }
        }
        BOOL v12 = &v11[24 * v81];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = *((void *)v10 + 2);
        *(_OWORD *)BOOL v12 = v13;
        ++v81;
        if (v79[0])
        {
          uint64_t v14 = &v76;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v9);
          long long v15 = (char *)v80;
          if (v81 >= v82)
          {
            unint64_t v65 = v81 + 1;
            if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
            {
              int64_t v71 = (char *)&v76 - (unsigned char *)v80;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              long long v15 = (char *)v80;
              uint64_t v14 = (int *)((char *)v80 + v71);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              uint64_t v14 = &v76;
              long long v15 = (char *)v80;
            }
          }
          uint64_t v16 = &v15[24 * v81];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = *((void *)v14 + 2);
          *(_OWORD *)uint64_t v16 = v17;
          ++v81;
          if (v79[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
          }
        }
      }
      if (!v88) {
        return 0;
      }
      uint64_t v18 = __p;
      if (__p)
      {
        uint64_t v19 = v87;
        long long v20 = __p;
        if (v87 != __p)
        {
          do
            uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          long long v20 = __p;
        }
        BOOL v87 = v18;
        operator delete(v20);
      }
      uint64_t v21 = v84;
      if (!v84) {
        goto LABEL_80;
      }
      long long v22 = v85;
      uint64_t v23 = v84;
      if (v85 == v84) {
        goto LABEL_79;
      }
      do
      {
        uint64_t v25 = *--v22;
        uint64_t v24 = v25;
        void *v22 = 0;
        if (v25) {
          MEMORY[0x21667D390](v24, 0x1000C8077774924);
        }
      }
      while (v22 != v21);
      goto LABEL_78;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v75, "scaling_mode", 0xCuLL);
  if (!v36)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      uint64_t v77 = "expected key entry for scaling_mode in DictionaryAttr to set Properties.";
      uint64_t v78 = 72;
      __int16 v52 = &v76;
      int v53 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v67 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v73 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          int v53 = (char *)v80;
          __int16 v52 = (int *)((char *)v80 + v73);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          __int16 v52 = &v76;
          int v53 = (char *)v80;
        }
      }
      unint64_t v54 = &v53[24 * v81];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = *((void *)v52 + 2);
      *(_OWORD *)unint64_t v54 = v55;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    char v56 = __p;
    if (__p)
    {
      uint64_t v57 = v87;
      unsigned int v58 = __p;
      if (v87 != __p)
      {
        do
          uint64_t v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        unsigned int v58 = __p;
      }
      BOOL v87 = v56;
      operator delete(v58);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    unsigned int v59 = v85;
    uint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_79;
    }
    do
    {
      uint64_t v61 = *--v59;
      uint64_t v60 = v61;
      *unsigned int v59 = 0;
      if (v61) {
        MEMORY[0x21667D390](v60, 0x1000C8077774924);
      }
    }
    while (v59 != v21);
    goto LABEL_78;
  }
  uint64_t v37 = v36;
  if (*(_UNKNOWN **)(*(void *)v36 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id)
  {
    a1[1] = v36;
    return 1;
  }
  a3(v79, a4);
  if (v79[0])
  {
    int v76 = 3;
    uint64_t v78 = 57;
    uint64_t v38 = &v76;
    uint64_t v39 = (char *)v80;
    if (v81 >= v82)
    {
      unint64_t v66 = v81 + 1;
      if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
      {
        int64_t v72 = (char *)&v76 - (unsigned char *)v80;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        uint64_t v39 = (char *)v80;
        uint64_t v38 = (int *)((char *)v80 + v72);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        uint64_t v38 = &v76;
        uint64_t v39 = (char *)v80;
      }
    }
    unint64_t v40 = &v39[24 * v81];
    long long v41 = *(_OWORD *)v38;
    *((void *)v40 + 2) = *((void *)v38 + 2);
    *(_OWORD *)unint64_t v40 = v41;
    ++v81;
    if (v79[0])
    {
      unint64_t v42 = &v76;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v37);
      BOOL v43 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v68 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v74 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          BOOL v43 = (char *)v80;
          unint64_t v42 = (int *)((char *)v80 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          unint64_t v42 = &v76;
          BOOL v43 = (char *)v80;
        }
      }
      unint64_t v44 = &v43[24 * v81];
      long long v45 = *(_OWORD *)v42;
      *((void *)v44 + 2) = *((void *)v42 + 2);
      *(_OWORD *)unint64_t v44 = v45;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
  }
  if (v88)
  {
    unint64_t v46 = __p;
    if (__p)
    {
      int64_t v47 = v87;
      int64_t v48 = __p;
      if (v87 != __p)
      {
        do
          int64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        int64_t v48 = __p;
      }
      BOOL v87 = v46;
      operator delete(v48);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    int64_t v49 = v85;
    uint64_t v23 = v84;
    if (v85 == v84)
    {
LABEL_79:
      unint64_t v85 = v21;
      operator delete(v23);
LABEL_80:
      if (v80 != v83) {
        free(v80);
      }
      return 0;
    }
    do
    {
      uint64_t v51 = *--v49;
      uint64_t v50 = v51;
      *int64_t v49 = 0;
      if (v51) {
        MEMORY[0x21667D390](v50, 0x1000C8077774924);
      }
    }
    while (v49 != v21);
LABEL_78:
    uint64_t v23 = v84;
    goto LABEL_79;
  }
  return 0;
}

uint64_t mlir::mps::FastFourierTransformOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v21[6] = *MEMORY[0x263EF8340];
  uint64_t v18 = a1;
  uint64_t v19 = v21;
  uint64_t v20 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"inverse", 7, *a2);
    uint64_t v5 = v4;
    unsigned int v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      unsigned int v6 = v20;
    }
    uint64_t v7 = (uint64_t *)((char *)v19 + 16 * v6);
    uint64_t *v7 = NamedAttr;
    v7[1] = v5;
    unsigned int v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    uint64_t v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      uint64_t v10 = (uint64_t *)v19;
      if (v8) {
        goto LABEL_6;
      }
LABEL_13:
      uint64_t DictionaryAttr = 0;
      if (v10 == v21) {
        return DictionaryAttr;
      }
      goto LABEL_7;
    }
  }
  else
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_5;
    }
  }
  uint64_t v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"scaling_mode", 12, v9);
  uint64_t v15 = v14;
  unsigned int v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    unsigned int v16 = v20;
  }
  long long v17 = (uint64_t *)((char *)v19 + 16 * v16);
  uint64_t *v17 = v13;
  v17[1] = v15;
  unsigned int v8 = v20 + 1;
  LODWORD(v20) = v8;
  uint64_t v10 = (uint64_t *)v19;
  if (!v8) {
    goto LABEL_13;
  }
LABEL_6:
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  uint64_t v10 = (uint64_t *)v19;
  if (v19 != v21) {
LABEL_7:
  }
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps27(uint64_t a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    unsigned int v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        unsigned int v8 = (char *)v35;
        uint64_t v7 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        unsigned int v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      long long v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid FFT scaling mode";
        uint64_t v31 = 54;
        uint64_t v11 = &v29;
        BOOL v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            BOOL v12 = (char *)v35;
            uint64_t v11 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            BOOL v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    unsigned int v16 = __p;
    if (__p)
    {
      long long v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          long long v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      unint64_t v42 = v16;
      operator delete(v18);
    }
    uint64_t v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      uint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        uint64_t v21 = v39;
      }
      unint64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::FFTScalingModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  uint64_t v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unsigned int v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        unsigned int v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unsigned int v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    unsigned int v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)unsigned int v8 = v9;
    ++v47;
  }
  unint64_t v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::FFTScalingModeAttr]";
  unint64_t v41 = 79;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    unint64_t v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      long long v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          long long v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      unsigned int v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)unsigned int v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        uint64_t v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v19 = (char *)v46;
            uint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            uint64_t v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      uint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      int v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      uint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

BOOL mlir::mps::FastFourierTransformOp::verifyInvariantsImpl(mlir::mps::FastFourierTransformOp *this)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = v3[1];
  if (v4)
  {
    uint64_t v5 = *v3;
    v20[0] = v2;
    if (mlir::mps::__mlir_ods_local_attr_constraint_MPSOps27(v4, (void **)"scaling_mode", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps27(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20)&& (v20[0] = *(void *)this, mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (void **)"inverse", (const char *)7, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20))&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps26(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(
                            *(void *)this,
                            (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8),
                            (void **)"operand",
                            7,
                            1u))
    {
      if (*(_DWORD *)(*(void *)this + 36)) {
        uint64_t v6 = *(void *)this - 16;
      }
      else {
        uint64_t v6 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps19(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v18 = (void **)"requires attribute 'scaling_mode'";
    __int16 v19 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, &v18, (uint64_t)v20);
    uint64_t v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v20);
    if (v20[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v20);
    }
    if (v27)
    {
      long long v9 = __p;
      if (__p)
      {
        unint64_t v10 = v26;
        unint64_t v11 = __p;
        if (v26 != __p)
        {
          do
            unint64_t v10 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v10 - 1);
          while (v10 != v9);
          unint64_t v11 = __p;
        }
        unint64_t v26 = v9;
        operator delete(v11);
      }
      uint64_t v12 = v23;
      if (v23)
      {
        unint64_t v13 = v24;
        long long v14 = v23;
        if (v24 != v23)
        {
          do
          {
            uint64_t v16 = *--v13;
            uint64_t v15 = v16;
            *unint64_t v13 = 0;
            if (v16) {
              MEMORY[0x21667D390](v15, 0x1000C8077774924);
            }
          }
          while (v13 != v12);
          long long v14 = v23;
        }
        uint64_t v24 = v12;
        operator delete(v14);
      }
      if (v21 != &v22) {
        free(v21);
      }
    }
  }
  return v8;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps26(uint64_t a1, void **a2, void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v73 = *MEMORY[0x263EF8340];
  unint64_t v10 = *a2;
  unint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v63[0] = a2;
    v63[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v63);
    if (mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
      return 1;
    }
    unint64_t v10 = *a2;
    unint64_t v11 = (void *)*((void *)*a2 + 17);
  }
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    char v54 = a2;
    uint64_t v55 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t v14 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v54);
    if (*(_UNKNOWN **)(*(void *)v14 + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      uint64_t v42 = v14;
      uint64_t v59 = v14;
      uint64_t OperandRange = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v59);
      if (mlir::Type::isF16((mlir::Type *)&OperandRange)) {
        return 1;
      }
      uint64_t v57 = v42;
      uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v57);
      if (mlir::Type::isF32((mlir::Type *)&Value)) {
        return 1;
      }
    }
  }
  __int16 v56 = 261;
  char v54 = a3;
  uint64_t v55 = a4;
  mlir::Operation::emitOpError(a1, &v54, (uint64_t)v63);
  if (v63[0])
  {
    LODWORD(OperandRange) = 3;
    uint64_t v61 = " #";
    uint64_t v62 = 2;
    p_uint64_t OperandRange = &OperandRange;
    uint64_t v16 = (char *)v64;
    if (v65 >= v66)
    {
      unint64_t v44 = v65 + 1;
      if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
      {
        int64_t v50 = (char *)&OperandRange - (unsigned char *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        uint64_t v16 = (char *)v64;
        p_uint64_t OperandRange = (uint64_t *)((char *)v64 + v50);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        p_uint64_t OperandRange = &OperandRange;
        uint64_t v16 = (char *)v64;
      }
    }
    long long v17 = &v16[24 * v65];
    long long v18 = *(_OWORD *)p_OperandRange;
    *((void *)v17 + 2) = p_OperandRange[2];
    *(_OWORD *)long long v17 = v18;
    uint64_t v19 = ++v65;
    if (v63[0])
    {
      LODWORD(OperandRange) = 5;
      uint64_t v61 = (const char *)a5;
      uint64_t v20 = &OperandRange;
      long long v21 = (char *)v64;
      if (v19 >= v66)
      {
        unint64_t v45 = v19 + 1;
        BOOL v46 = (char *)v64 + 24 * v19 > (char *)&OperandRange;
        if (v64 <= &OperandRange && v46)
        {
          int64_t v51 = (char *)&OperandRange - (unsigned char *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          long long v21 = (char *)v64;
          uint64_t v20 = (uint64_t *)((char *)v64 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          uint64_t v20 = &OperandRange;
          long long v21 = (char *)v64;
        }
      }
      uint64_t v22 = &v21[24 * v65];
      long long v23 = *(_OWORD *)v20;
      *((void *)v22 + 2) = v20[2];
      *(_OWORD *)uint64_t v22 = v23;
      uint64_t v24 = ++v65;
      if (v63[0])
      {
        LODWORD(OperandRange) = 3;
        uint64_t v61 = " must be tensor of floating point values or tensor of complex values, but got ";
        uint64_t v62 = 78;
        unint64_t v25 = &OperandRange;
        unint64_t v26 = (char *)v64;
        if (v24 >= v66)
        {
          unint64_t v47 = v24 + 1;
          BOOL v48 = (char *)v64 + 24 * v24 > (char *)&OperandRange;
          if (v64 <= &OperandRange && v48)
          {
            int64_t v52 = (char *)&OperandRange - (unsigned char *)v64;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            unint64_t v26 = (char *)v64;
            unint64_t v25 = (uint64_t *)((char *)v64 + v52);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            unint64_t v25 = &OperandRange;
            unint64_t v26 = (char *)v64;
          }
        }
        char v27 = &v26[24 * v65];
        long long v28 = *(_OWORD *)v25;
        *((void *)v27 + 2) = v25[2];
        *(_OWORD *)char v27 = v28;
        ++v65;
        if (v63[0])
        {
          uint64_t v29 = &OperandRange;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, (uint64_t)a2);
          uint64_t v30 = (char *)v64;
          if (v65 >= v66)
          {
            unint64_t v49 = v65 + 1;
            if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
            {
              int64_t v53 = (char *)&OperandRange - (unsigned char *)v64;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              uint64_t v30 = (char *)v64;
              uint64_t v29 = (uint64_t *)((char *)v64 + v53);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              uint64_t v29 = &OperandRange;
              uint64_t v30 = (char *)v64;
            }
          }
          uint64_t v31 = &v30[24 * v65];
          long long v32 = *(_OWORD *)v29;
          *((void *)v31 + 2) = v29[2];
          *(_OWORD *)uint64_t v31 = v32;
          ++v65;
        }
      }
    }
  }
  uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v63);
  if (v63[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
  }
  if (v72)
  {
    unint64_t v34 = __p;
    if (__p)
    {
      int64_t v35 = v71;
      int64_t v36 = __p;
      if (v71 != __p)
      {
        do
          int64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        int64_t v36 = __p;
      }
      int64_t v71 = v34;
      operator delete(v36);
    }
    int64_t v37 = v68;
    if (v68)
    {
      uint64_t v38 = v69;
      uint64_t v39 = v68;
      if (v69 != v68)
      {
        do
        {
          uint64_t v41 = *--v38;
          uint64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            MEMORY[0x21667D390](v40, 0x1000C8077774924);
          }
        }
        while (v38 != v37);
        uint64_t v39 = v68;
      }
      int64_t v69 = v37;
      operator delete(v39);
    }
    if (v64 != v67) {
      free(v64);
    }
  }
  return v33;
}

void mlir::mps::FastFourierTransformOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::Flatten2DOpGenericAdaptorBase::Flatten2DOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.flatten_2d", 14, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::Flatten2DOp::verifyInvariantsImpl(mlir::mps::Flatten2DOp *this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v2 = *(void *)this - 16;
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
}

void mlir::mps::Flatten2DOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::FloorDivideOpGenericAdaptorBase::FloorDivideOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.floor_divide", 16, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::FloorDivideOp::verifyInvariantsImpl(mlir::mps::FloorDivideOp *this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v2 = *(void *)this - 16;
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
}

void mlir::mps::FloorDivideOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::FloorOpGenericAdaptorBase::FloorOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.floor", 9, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::FloorOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::GRUGradientOp::getAsmResultNames(uint64_t *a1, void (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  if (*(_DWORD *)(*a1 + 36)) {
    uint64_t v5 = *a1 - 16;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  a2(a3, NextResultAtOffset, "gradient_output_sequence", 24);
  if (*(_DWORD *)(*a1 + 36)) {
    uint64_t v7 = *a1 - 16;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 1);
  uint64_t v9 = mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0);
  a2(a3, v9, "gradient_recurrent_weight", 25);
  if (*(_DWORD *)(*a1 + 36)) {
    uint64_t v10 = *a1 - 16;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 2);
  uint64_t v12 = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
  a2(a3, v12, "gradient_input_state", 20);
  uint64_t v13 = *a1;
  int v14 = *(_DWORD *)(*a1 + 36);
  uint64_t v15 = v13 - 16;
  if (v14) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t result = mlir::detail::OpResultImpl::getNextResultAtOffset(v16, 3);
  if (v14 != 3)
  {
    uint64_t v18 = mlir::detail::OpResultImpl::getNextResultAtOffset(result, 0);
    return ((uint64_t (*)(uint64_t, uint64_t, const char *, uint64_t))a2)(a3, v18, "gradient_bias", 13);
  }
  return result;
}

uint64_t mlir::mps::GRUGradientOp::getODSResults(mlir::mps::GRUGradientOp *this, unsigned int a2)
{
  if (a2)
  {
    if (a2 >= 8)
    {
      int32x4_t v4 = (int32x4_t)xmmword_211EE3A90;
      unsigned int v3 = a2 & 0xFFFFFFF8;
      int32x4_t v5 = 0uLL;
      v6.i64[0] = 0x300000003;
      v6.i64[1] = 0x300000003;
      v7.i64[0] = -1;
      v7.i64[1] = -1;
      v8.i64[0] = 0x800000008;
      v8.i64[1] = 0x800000008;
      unsigned int v9 = a2 & 0xFFFFFFF8;
      int32x4_t v10 = 0uLL;
      do
      {
        int32x4_t v5 = vsubq_s32(v5, vceqq_s32(v4, v6));
        int32x4_t v10 = vsubq_s32(v10, vceqq_s32(v4, v7));
        int32x4_t v4 = vaddq_s32(v4, v8);
        v9 -= 8;
      }
      while (v9);
      int v2 = vaddvq_s32(vaddq_s32(v10, v5));
      if (v3 == a2) {
        goto LABEL_11;
      }
    }
    else
    {
      int v2 = 0;
      unsigned int v3 = 0;
    }
    do
    {
      if (v3 == 3) {
        ++v2;
      }
      ++v3;
    }
    while (a2 != v3);
  }
  else
  {
    int v2 = 0;
  }
LABEL_11:
  int v11 = *(_DWORD *)(*(void *)this + 36);
  if (v11) {
    uint64_t result = *(void *)this - 16;
  }
  else {
    uint64_t result = 0;
  }
  if (a2 + (v11 - 4) * v2) {
    return mlir::detail::OpResultImpl::getNextResultAtOffset(result, a2 + (v11 - 4) * v2);
  }
  return result;
}

uint64_t mlir::mps::GRUGradientOp::getODSOperands(mlir::mps::GRUGradientOp *this, unsigned int a2)
{
  unint64_t v2 = *(unsigned int *)(*(void *)this + 44);
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = *(void *)this + 16 * ((v2 >> 23) & 1) + 64;
  }
  else {
    uint64_t v3 = 0;
  }
  if (!a2)
  {
    uint64_t v6 = 0;
    goto LABEL_14;
  }
  if (a2 >= 8)
  {
    uint64_t v4 = a2 & 0xFFFFFFF8;
    int32x4_t v7 = (int32x4_t *)(v3 + 64);
    int32x4_t v8 = 0uLL;
    uint64_t v9 = v4;
    int32x4_t v10 = 0uLL;
    do
    {
      int32x4_t v8 = vaddq_s32(v7[-1], v8);
      int32x4_t v10 = vaddq_s32(*v7, v10);
      v7 += 2;
      v9 -= 8;
    }
    while (v9);
    unsigned int v5 = vaddvq_s32(vaddq_s32(v10, v8));
    if (v4 == a2) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v4 = 0;
    unsigned int v5 = 0;
  }
  uint64_t v11 = a2 - v4;
  uint64_t v12 = (int *)(v3 + 4 * v4 + 48);
  do
  {
    int v13 = *v12++;
    v5 += v13;
    --v11;
  }
  while (v11);
LABEL_13:
  uint64_t v6 = v5;
LABEL_14:
  if ((v2 & 0x800000) != 0) {
    return *(void *)(*(void *)this + 72) + 32 * v6;
  }
  else {
    return 32 * v6;
  }
}

BOOL mlir::mps::GRUGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v84 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v70 = v6;
  if (!v6)
  {
    a3(v74, a4);
    if (v74[0])
    {
      LODWORD(v71) = 3;
      char v72 = "expected DictionaryAttr to set properties";
      uint64_t v73 = 41;
      unint64_t v26 = &v71;
      char v27 = (char *)v75;
      if (v76 >= v77)
      {
        unint64_t v60 = v76 + 1;
        if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
        {
          int64_t v65 = (char *)&v71 - (unsigned char *)v75;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v60, 24);
          char v27 = (char *)v75;
          unint64_t v26 = (uint64_t *)((char *)v75 + v65);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v60, 24);
          unint64_t v26 = &v71;
          char v27 = (char *)v75;
        }
      }
      long long v28 = &v27[24 * v76];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)long long v28 = v29;
      ++v76;
      if (v74[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
      }
    }
    if (!v83) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      uint64_t v31 = v82;
      long long v32 = __p;
      if (v82 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        long long v32 = __p;
      }
      unsigned int v82 = v30;
      operator delete(v32);
    }
    long long v21 = v79;
    if (!v79) {
      goto LABEL_64;
    }
    uint64_t v33 = v80;
    long long v23 = v79;
    if (v80 == v79)
    {
LABEL_63:
      uint64_t v80 = v21;
      operator delete(v23);
LABEL_64:
      if (v75 != v78) {
        free(v75);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
LABEL_62:
    long long v23 = v79;
    goto LABEL_63;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v70, "flip_z", 6uLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v74, a4);
      if (v74[0])
      {
        LODWORD(v71) = 3;
        uint64_t v73 = 51;
        int32x4_t v10 = &v71;
        uint64_t v11 = (char *)v75;
        if (v76 >= v77)
        {
          unint64_t v61 = v76 + 1;
          if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
          {
            int64_t v66 = (char *)&v71 - (unsigned char *)v75;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v61, 24);
            uint64_t v11 = (char *)v75;
            int32x4_t v10 = (uint64_t *)((char *)v75 + v66);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v61, 24);
            int32x4_t v10 = &v71;
            uint64_t v11 = (char *)v75;
          }
        }
        uint64_t v12 = &v11[24 * v76];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = v10[2];
        *(_OWORD *)uint64_t v12 = v13;
        ++v76;
        if (v74[0])
        {
          int v14 = &v71;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v71, v9);
          uint64_t v15 = (char *)v75;
          if (v76 >= v77)
          {
            unint64_t v62 = v76 + 1;
            if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
            {
              int64_t v67 = (char *)&v71 - (unsigned char *)v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v62, 24);
              uint64_t v15 = (char *)v75;
              int v14 = (uint64_t *)((char *)v75 + v67);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v62, 24);
              int v14 = &v71;
              uint64_t v15 = (char *)v75;
            }
          }
          uint64_t v16 = &v15[24 * v76];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = v14[2];
          *(_OWORD *)uint64_t v16 = v17;
          ++v76;
          if (v74[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
          }
        }
      }
      if (!v83) {
        return 0;
      }
      uint64_t v18 = __p;
      if (__p)
      {
        uint64_t v19 = v82;
        uint64_t v20 = __p;
        if (v82 != __p)
        {
          do
            uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          uint64_t v20 = __p;
        }
        unsigned int v82 = v18;
        operator delete(v20);
      }
      long long v21 = v79;
      if (!v79) {
        goto LABEL_64;
      }
      uint64_t v22 = v80;
      long long v23 = v79;
      if (v80 == v79) {
        goto LABEL_63;
      }
      do
      {
        uint64_t v25 = *--v22;
        uint64_t v24 = v25;
        void *v22 = 0;
        if (v25) {
          MEMORY[0x21667D390](v24, 0x1000C8077774924);
        }
      }
      while (v22 != v21);
      goto LABEL_62;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v70, "gate_layout", 0xBuLL);
  if (v36)
  {
    uint64_t v37 = v36;
    if (*(_UNKNOWN **)(*(void *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id)
    {
      a3(v74, a4);
      if (v74[0])
      {
        LODWORD(v71) = 3;
        uint64_t v73 = 56;
        uint64_t v38 = &v71;
        uint64_t v39 = (char *)v75;
        if (v76 >= v77)
        {
          unint64_t v63 = v76 + 1;
          if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
          {
            int64_t v68 = (char *)&v71 - (unsigned char *)v75;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v63, 24);
            uint64_t v39 = (char *)v75;
            uint64_t v38 = (uint64_t *)((char *)v75 + v68);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v63, 24);
            uint64_t v38 = &v71;
            uint64_t v39 = (char *)v75;
          }
        }
        uint64_t v40 = &v39[24 * v76];
        long long v41 = *(_OWORD *)v38;
        *((void *)v40 + 2) = v38[2];
        *(_OWORD *)uint64_t v40 = v41;
        ++v76;
        if (v74[0])
        {
          uint64_t v42 = &v71;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v71, v37);
          __int16 v43 = (char *)v75;
          if (v76 >= v77)
          {
            unint64_t v64 = v76 + 1;
            if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
            {
              int64_t v69 = (char *)&v71 - (unsigned char *)v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v64, 24);
              __int16 v43 = (char *)v75;
              uint64_t v42 = (uint64_t *)((char *)v75 + v69);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v64, 24);
              uint64_t v42 = &v71;
              __int16 v43 = (char *)v75;
            }
          }
          unint64_t v44 = &v43[24 * v76];
          long long v45 = *(_OWORD *)v42;
          *((void *)v44 + 2) = v42[2];
          *(_OWORD *)unint64_t v44 = v45;
          ++v76;
          if (v74[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
          }
        }
      }
      if (!v83) {
        return 0;
      }
      BOOL v46 = __p;
      if (__p)
      {
        unint64_t v47 = v82;
        BOOL v48 = __p;
        if (v82 != __p)
        {
          do
            unint64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          BOOL v48 = __p;
        }
        unsigned int v82 = v46;
        operator delete(v48);
      }
      long long v21 = v79;
      if (!v79) {
        goto LABEL_64;
      }
      unint64_t v49 = v80;
      long long v23 = v79;
      if (v80 == v79) {
        goto LABEL_63;
      }
      do
      {
        uint64_t v51 = *--v49;
        uint64_t v50 = v51;
        *unint64_t v49 = 0;
        if (v51) {
          MEMORY[0x21667D390](v50, 0x1000C8077774924);
        }
      }
      while (v49 != v21);
      goto LABEL_62;
    }
    a1[1] = v36;
  }
  uint64_t v52 = mlir::DictionaryAttr::get((uint64_t)&v70, "ogate_activation", 0x10uLL);
  uint64_t v71 = v52;
  if (v52)
  {
    if (*(_UNKNOWN **)(*(void *)v52 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
LABEL_82:
      uint64_t v55 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v74, v53);
      goto LABEL_83;
    }
    a1[2] = v52;
  }
  uint64_t v54 = mlir::DictionaryAttr::get((uint64_t)&v70, "reset_after", 0xBuLL);
  uint64_t v71 = v54;
  if (v54)
  {
    if (*(_UNKNOWN **)(*(void *)v54 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v74, a4);
LABEL_83:
      mlir::InFlightDiagnostic::append<mlir::Attribute>(v55, &v71);
LABEL_84:
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v74);
      return 0;
    }
    a1[3] = v54;
  }
  uint64_t v56 = mlir::DictionaryAttr::get((uint64_t)&v70, "rgate_activation", 0x10uLL);
  uint64_t v71 = v56;
  if (v56)
  {
    if (*(_UNKNOWN **)(*(void *)v56 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
      goto LABEL_82;
    }
    a1[4] = v56;
  }
  uint64_t v57 = mlir::DictionaryAttr::get((uint64_t)&v70, "zgate_activation", 0x10uLL);
  uint64_t v71 = v57;
  if (v57)
  {
    if (*(_UNKNOWN **)(*(void *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
      goto LABEL_82;
    }
    a1[5] = v57;
  }
  uint64_t v59 = (void *)mlir::DictionaryAttr::get((uint64_t)&v70, "operandSegmentSizes", 0x13uLL);
  if (!v59)
  {
    uint64_t v59 = (void *)mlir::DictionaryAttr::get((uint64_t)&v70, "operand_segment_sizes", 0x15uLL);
    if (!v59)
    {
      a3(v74, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v74, "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.");
      goto LABEL_84;
    }
  }
  return mlir::convertFromAttribute(a1 + 6, (const char *)7, v59, a3, a4) != 0;
}

uint64_t mlir::mps::GRUGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v53[6] = *MEMORY[0x263EF8340];
  uint64_t v50 = a1;
  uint64_t v51 = v53;
  uint64_t v52 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v50, (uint64_t)"flip_z", 6, *a2);
    uint64_t v6 = v5;
    unsigned int v7 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v7 = v52;
    }
    uint64_t v8 = (uint64_t *)((char *)v51 + 16 * v7);
    *uint64_t v8 = NamedAttr;
    v8[1] = v6;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v9 = a2[1];
  if (v9)
  {
    uint64_t v10 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"gate_layout", 11, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v13 = v52;
    }
    int v14 = (uint64_t *)((char *)v51 + 16 * v13);
    *int v14 = v10;
    v14[1] = v12;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"ogate_activation", 16, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v19 = v52;
    }
    uint64_t v20 = (uint64_t *)((char *)v51 + 16 * v19);
    uint64_t *v20 = v16;
    v20[1] = v18;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"reset_after", 11, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v25 = v52;
    }
    unint64_t v26 = (uint64_t *)((char *)v51 + 16 * v25);
    uint64_t *v26 = v22;
    v26[1] = v24;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"rgate_activation", 16, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v31 = v52;
    }
    long long v32 = (uint64_t *)((char *)v51 + 16 * v31);
    uint64_t *v32 = v28;
    v32[1] = v30;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v33 = a2[5];
  if (v33)
  {
    uint64_t v34 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"zgate_activation", 16, v33);
    uint64_t v36 = v35;
    unsigned int v37 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v37 = v52;
    }
    uint64_t v38 = (uint64_t *)((char *)v51 + 16 * v37);
    uint64_t *v38 = v34;
    v38[1] = v36;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v39 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 7);
  uint64_t v40 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"operandSegmentSizes", 19, v39);
  uint64_t v42 = v41;
  unsigned int v43 = v52;
  if (v52 >= HIDWORD(v52))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
    unsigned int v43 = v52;
  }
  unint64_t v44 = (uint64_t *)((char *)v51 + 16 * v43);
  uint64_t *v44 = v40;
  v44[1] = v42;
  BOOL v45 = __CFADD__(v52, 1);
  uint64_t v46 = (v52 + 1);
  LODWORD(v52) = v52 + 1;
  if (v45)
  {
    uint64_t DictionaryAttr = 0;
    BOOL v48 = v51;
    if (v51 == v53) {
      return DictionaryAttr;
    }
    goto LABEL_32;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v50, (uint64_t *)v51, v46);
  BOOL v48 = v51;
  if (v51 != v53) {
LABEL_32:
  }
    free(v48);
  return DictionaryAttr;
}

unint64_t mlir::mps::GRUGradientOp::computePropertiesHash(unint64_t *a1)
{
  uint64_t v87 = *MEMORY[0x263EF8340];
  unint64_t v1 = *a1;
  unint64_t v2 = &unk_267770000;
  {
    unint64_t v62 = a1;
    unint64_t v69 = v1;
    unint64_t v2 = &unk_267770000;
    int v28 = v27;
    a1 = v62;
    unint64_t v1 = v69;
    if (v28)
    {
      unint64_t v29 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v29 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v29;
      a1 = v62;
      unint64_t v1 = v69;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  uint64_t v3 = v2[385];
  unint64_t v4 = a1[1];
  {
    unint64_t v63 = a1;
    unint64_t v70 = v1;
    unint64_t v50 = v4;
    uint64_t v55 = v3;
    unint64_t v4 = v50;
    uint64_t v3 = v55;
    unint64_t v2 = &unk_267770000;
    int v31 = v30;
    a1 = v63;
    unint64_t v1 = v70;
    if (v31)
    {
      unint64_t v32 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v32 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v32;
      unint64_t v4 = v50;
      uint64_t v3 = v55;
      a1 = v63;
      unint64_t v1 = v70;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v5 = HIDWORD(v4);
  unint64_t v6 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v4) ^ HIDWORD(v4));
  unint64_t v82 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) ^ ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) >> 47));
  unint64_t v7 = a1[2];
  {
    unint64_t v64 = a1;
    unint64_t v71 = v1;
    unint64_t v51 = v7;
    uint64_t v56 = v3;
    unint64_t v7 = v51;
    uint64_t v3 = v56;
    unint64_t v2 = &unk_267770000;
    int v34 = v33;
    a1 = v64;
    unint64_t v1 = v71;
    if (v34)
    {
      unint64_t v35 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v35 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v35;
      unint64_t v7 = v51;
      uint64_t v3 = v56;
      a1 = v64;
      unint64_t v1 = v71;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v8 = HIDWORD(v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v7) ^ HIDWORD(v7));
  unint64_t v81 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
  unint64_t v10 = a1[3];
  {
    int64_t v65 = a1;
    unint64_t v72 = v1;
    unint64_t v52 = v10;
    uint64_t v57 = v3;
    unint64_t v10 = v52;
    uint64_t v3 = v57;
    unint64_t v2 = &unk_267770000;
    int v37 = v36;
    a1 = v65;
    unint64_t v1 = v72;
    if (v37)
    {
      unint64_t v38 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v38 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v38;
      unint64_t v10 = v52;
      uint64_t v3 = v57;
      a1 = v65;
      unint64_t v1 = v72;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v11 = HIDWORD(v10);
  unint64_t v12 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v10) ^ HIDWORD(v10));
  unint64_t v80 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v11 ^ (v12 >> 47) ^ v12)) ^ ((0x9DDFEA08EB382D69 * (v11 ^ (v12 >> 47) ^ v12)) >> 47));
  unint64_t v13 = a1[4];
  {
    int64_t v66 = a1;
    unint64_t v73 = v1;
    unint64_t v53 = v13;
    uint64_t v58 = v3;
    unint64_t v13 = v53;
    uint64_t v3 = v58;
    unint64_t v2 = &unk_267770000;
    int v40 = v39;
    a1 = v66;
    unint64_t v1 = v73;
    if (v40)
    {
      unint64_t v41 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v41 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v41;
      unint64_t v13 = v53;
      uint64_t v3 = v58;
      a1 = v66;
      unint64_t v1 = v73;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v14 = HIDWORD(v13);
  unint64_t v15 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v13) ^ HIDWORD(v13));
  unint64_t v79 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v14 ^ (v15 >> 47) ^ v15)) ^ ((0x9DDFEA08EB382D69 * (v14 ^ (v15 >> 47) ^ v15)) >> 47));
  unint64_t v16 = a1[5];
  {
    int64_t v67 = a1;
    unint64_t v74 = v1;
    unint64_t v54 = v16;
    uint64_t v59 = v3;
    unint64_t v16 = v54;
    uint64_t v3 = v59;
    unint64_t v2 = &unk_267770000;
    int v43 = v42;
    a1 = v67;
    unint64_t v1 = v74;
    if (v43)
    {
      unint64_t v44 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v44 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v44;
      unint64_t v16 = v54;
      uint64_t v3 = v59;
      a1 = v67;
      unint64_t v1 = v74;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v17 = HIDWORD(v16);
  unint64_t v18 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v16) ^ HIDWORD(v16));
  unint64_t v78 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v17 ^ (v18 >> 47) ^ v18)) ^ ((0x9DDFEA08EB382D69 * (v17 ^ (v18 >> 47) ^ v18)) >> 47));
  {
    int64_t v68 = a1;
    unint64_t v75 = v1;
    uint64_t v60 = v3;
    unint64_t v1 = v75;
    unint64_t v2 = &unk_267770000;
    int v46 = v45;
    uint64_t v3 = v60;
    a1 = v68;
    if (v46)
    {
      unint64_t v47 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v47 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v47;
      uint64_t v3 = v60;
      a1 = v68;
      unint64_t v1 = v75;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  uint64_t v19 = v2[385];
  unint64_t v20 = a1[7];
  unint64_t v21 = 0x9AE16A3B2F90404FLL * *(unint64_t *)((char *)a1 + 68);
  uint64_t v22 = __ROR8__(0xB492B66FBE98F273 * a1[6] - v20, 43)
      - 0x3C5A37A36834CED9 * *(unint64_t *)((char *)a1 + 60)
      + __ROR8__(v21 ^ v19, 30);
  uint64_t v23 = v19 + __ROR8__(v20 ^ 0xC949D7C7509E6557, 20) - 0x4B6D499041670D8DLL * a1[6] - v21 + 28;
  unint64_t v77 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v23 ^ ((0x9DDFEA08EB382D69 * (v22 ^ v23)) >> 47) ^ (0x9DDFEA08EB382D69 * (v22 ^ v23)))) ^ ((0x9DDFEA08EB382D69 * (v23 ^ ((0x9DDFEA08EB382D69 * (v22 ^ v23)) >> 47) ^ (0x9DDFEA08EB382D69 * (v22 ^ v23)))) >> 47));
  uint64_t v85 = 0;
  memset(v84, 0, sizeof(v84));
  memset(v83, 0, sizeof(v83));
  {
    unint64_t v76 = v1;
    uint64_t v61 = v3;
    uint64_t v3 = v61;
    unint64_t v1 = v76;
    unint64_t v2 = &unk_267770000;
    if (v48)
    {
      unint64_t v49 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v49 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v49;
      uint64_t v3 = v61;
      unint64_t v1 = v76;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v24 = HIDWORD(v1);
  unint64_t v25 = 0x9DDFEA08EB382D69 * ((v3 + 8 * v1) ^ HIDWORD(v1));
  uint64_t v86 = v2[385];
  *(void *)&v83[0] = 0x9DDFEA08EB382D69
                     * ((0x9DDFEA08EB382D69 * (v24 ^ (v25 >> 47) ^ v25)) ^ ((0x9DDFEA08EB382D69
                                                                             * (v24 ^ (v25 >> 47) ^ v25)) >> 47));
  return llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>((llvm::hashing::detail::hash_combine_recursive_helper *)v83, 0, (void *)v83 + 1, (char *)v84, (uint64_t *)&v82, (uint64_t *)&v81, (uint64_t *)&v80, (uint64_t *)&v79, (uint64_t *)&v78, (uint64_t *)&v77);
}

uint64_t mlir::mps::GRUGradientOp::getInherentAttr(mlir::MLIRContext *a1, void *a2, _WORD *__s1, size_t __n)
{
  uint64_t result = 0;
  switch(__n)
  {
    case 6uLL:
      if (*(_DWORD *)__s1 != 1885957222 || __s1[2] != 31327) {
        goto LABEL_20;
      }
      return *a2;
    case 7uLL:
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0xFuLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x14uLL:
      goto LABEL_20;
    case 0xBuLL:
      if (!memcmp(__s1, "gate_layout", __n))
      {
        uint64_t result = a2[1];
      }
      else
      {
        if (memcmp(__s1, "reset_after", __n)) {
          goto LABEL_20;
        }
        uint64_t result = a2[3];
      }
      break;
    case 0x10uLL:
      if (!memcmp(__s1, "ogate_activation", __n))
      {
        uint64_t result = a2[2];
      }
      else if (!memcmp(__s1, "rgate_activation", __n))
      {
        uint64_t result = a2[4];
      }
      else if (*(void *)__s1 == 0x63615F657461677ALL && *((void *)__s1 + 1) == 0x6E6F697461766974)
      {
        uint64_t result = a2[5];
      }
      else
      {
LABEL_20:
        uint64_t result = 0;
      }
      break;
    case 0x13uLL:
      if (memcmp(__s1, "operandSegmentSizes", __n)) {
        goto LABEL_20;
      }
      return mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 7);
    case 0x15uLL:
      if (memcmp(__s1, "operand_segment_sizes", __n)) {
        goto LABEL_20;
      }
      return mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 7);
    default:
      return result;
  }
  return result;
}

uint64_t mlir::mps::GRUGradientOp::setInherentAttr(uint64_t result, _WORD *__s1, size_t __n, void *a4)
{
  unint64_t v7 = (void *)result;
  switch(__n)
  {
    case 6uLL:
      if (*(_DWORD *)__s1 == 1885957222 && __s1[2] == 31327)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
            unint64_t v14 = a4;
          }
          else {
            unint64_t v14 = 0;
          }
          *(void *)uint64_t result = v14;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xBuLL:
      uint64_t result = memcmp(__s1, "gate_layout", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "reset_after", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
              unint64_t v9 = a4;
            }
            else {
              unint64_t v9 = 0;
            }
            v7[3] = v9;
          }
          else
          {
            v7[3] = 0;
          }
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id) {
          unint64_t v15 = a4;
        }
        else {
          unint64_t v15 = 0;
        }
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "ogate_activation", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "rgate_activation", __n);
        if (result)
        {
          if (*(void *)__s1 == 0x63615F657461677ALL && *((void *)__s1 + 1) == 0x6E6F697461766974)
          {
            if (a4)
            {
              if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
                unint64_t v11 = a4;
              }
              else {
                unint64_t v11 = 0;
              }
              v7[5] = v11;
            }
            else
            {
              v7[5] = 0;
            }
          }
        }
        else if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
            unint64_t v17 = a4;
          }
          else {
            unint64_t v17 = 0;
          }
          v7[4] = v17;
        }
        else
        {
          v7[4] = 0;
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
          unint64_t v16 = a4;
        }
        else {
          unint64_t v16 = 0;
        }
        v7[2] = v16;
      }
      else
      {
        v7[2] = 0;
      }
      break;
    case 0x13uLL:
      uint64_t result = memcmp(__s1, "operandSegmentSizes", __n);
      if (!result) {
        goto LABEL_29;
      }
      break;
    case 0x15uLL:
      uint64_t result = memcmp(__s1, "operand_segment_sizes", __n);
      if (!result)
      {
LABEL_29:
        if (a4)
        {
          uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
          unint64_t v12 = result ? a4 : 0;
          unint64_t v18 = v12;
          if (result)
          {
            uint64_t result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v18);
            if (result == 7)
            {
              uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v18);
              if (v13) {
                uint64_t result = (uint64_t)memmove(v7 + 6, (const void *)result, 4 * v13);
              }
            }
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::GRUGradientOp::populateInherentAttrs(mlir::MLIRContext *a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"flip_z", 6, *a2);
  }
  uint64_t v6 = a2[1];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"gate_layout", 11, v6);
  }
  uint64_t v7 = a2[2];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"ogate_activation", 16, v7);
  }
  uint64_t v8 = a2[3];
  if (v8) {
    mlir::NamedAttrList::append(a3, (uint64_t)"reset_after", 11, v8);
  }
  uint64_t v9 = a2[4];
  if (v9) {
    mlir::NamedAttrList::append(a3, (uint64_t)"rgate_activation", 16, v9);
  }
  uint64_t v10 = a2[5];
  if (v10) {
    mlir::NamedAttrList::append(a3, (uint64_t)"zgate_activation", 16, v10);
  }
  uint64_t v11 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 7);

  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v11);
}

BOOL mlir::mps::GRUGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v8, (void **)"flip_z", (const char *)6, a3, a4))
  {
    uint64_t v9 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(v9, (void **)"gate_layout", (const char *)0xB, a3, a4))
    {
      uint64_t v10 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v10, (void **)"ogate_activation", (const char *)0x10, a3, a4))
      {
        uint64_t v11 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v11, (void **)"reset_after", (const char *)0xB, a3, a4))
        {
          uint64_t v12 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v12, (void **)"rgate_activation", (const char *)0x10, a3, a4))
          {
            uint64_t v13 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v13, (void **)"zgate_activation", (const char *)0x10, a3, a4))
            {
              return 1;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(uint64_t a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    int v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      unint64_t v29 = a2;
      int v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        int v30 = "' failed to satisfy constraint: valid GRU gate layout";
        uint64_t v31 = 53;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    unint64_t v16 = __p;
    if (__p)
    {
      unint64_t v17 = v42;
      unint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          unint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        unint64_t v18 = __p;
      }
      int v42 = v16;
      operator delete(v18);
    }
    uint64_t v19 = v39;
    if (v39)
    {
      unint64_t v20 = v40;
      unint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        unint64_t v21 = v39;
      }
      int v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(uint64_t a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    int v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      unint64_t v29 = a2;
      int v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        int v30 = "' failed to satisfy constraint: valid RNN activation";
        uint64_t v31 = 52;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    unint64_t v16 = __p;
    if (__p)
    {
      unint64_t v17 = v42;
      unint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          unint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        unint64_t v18 = __p;
      }
      int v42 = v16;
      operator delete(v18);
    }
    uint64_t v19 = v39;
    if (v39)
    {
      unint64_t v20 = v40;
      unint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        unint64_t v21 = v39;
      }
      int v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

BOOL mlir::mps::GRUGradientOp::readProperties(uint64_t a1, uint64_t a2)
{
  v10[24] = *MEMORY[0x263EF8340];
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>(a2);
  if (!mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::GRUGateLayoutAttr>(a1, v3 + 1)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 2))
  {
    return 0;
  }
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) <= 5)
  {
    uint64_t v9 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v9)) {
      return 0;
    }
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v9) >= 8)
    {
      v7[0] = (uint64_t)"size mismatch for operand/result_segment_size";
      __int16 v8 = 259;
      (*(void (**)(void *__return_ptr, uint64_t, uint64_t *))(*(void *)a1 + 16))(v10, a1, v7);
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v10);
      return 0;
    }
    unint64_t v4 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v9);
    if (v5) {
      memmove(v3 + 6, v4, 4 * v5);
    }
  }
  if (mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 3)
    && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 4)
    && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 5))
  {
    v7[0] = a1;
    v7[1] = (uint64_t)(v3 + 6);
    return mlir::mps::GRUGradientOp::readProperties(mlir::DialectBytecodeReader &,mlir::OperationState &)::$_0::operator()(v7) != 0;
  }
  return 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::GRUGateLayoutAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  uint64_t v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    uint64_t v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        uint64_t v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    __int16 v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)__int16 v8 = v9;
    ++v47;
  }
  int v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::GRUGateLayoutAttr]";
  unint64_t v41 = 78;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    int v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      long long v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          long long v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      unint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)unint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        unint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        uint64_t v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v19 = (char *)v46;
            unint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unint64_t v18 = &v40;
            uint64_t v19 = (char *)v46;
          }
        }
        unint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)unint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      unint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          unint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      unint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      unint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  uint64_t v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    uint64_t v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        uint64_t v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    __int16 v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)__int16 v8 = v9;
    ++v47;
  }
  int v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::RNNActivationAttr]";
  unint64_t v41 = 78;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    int v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      long long v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          long long v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      unint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)unint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        unint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        uint64_t v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v19 = (char *)v46;
            unint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unint64_t v18 = &v40;
            uint64_t v19 = (char *)v46;
          }
        }
        unint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)unint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      unint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          unint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      unint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      unint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

uint64_t mlir::mps::GRUGradientOp::readProperties(mlir::DialectBytecodeReader &,mlir::OperationState &)::$_0::operator()(uint64_t *a1)
{
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)*a1 + 40))(*a1) < 6) {
    return 1;
  }
  uint64_t v2 = *a1;
  uint64_t v3 = (_DWORD *)a1[1];

  return mlir::DialectBytecodeReader::readSparseArray<int>(v2, v3, (const char *)7);
}

uint64_t mlir::mps::GRUGradientOp::writeProperties(uint64_t a1, uint64_t a2)
{
  if (HIBYTE(*(_DWORD *)(*(void *)a1 + 44))) {
    unint64_t v4 = *(void *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(void *)a1 + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)v4);
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 8));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 16));
  if ((*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2) <= 5)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(void *)a1 + 24));
    uint64_t v6 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v4 + 48, 7);
    (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, v6);
  }
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 24));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 32));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 40));
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2);
  if (result >= 6)
  {
    return mlir::DialectBytecodeWriter::writeSparseArray<int>(a2, (int *)(v4 + 48), 7);
  }
  return result;
}

mlir::MLIRContext *mlir::mps::GRUGradientOp::populateDefaultProperties(uint64_t a1, void *a2)
{
  unint64_t v10 = *(void **)(a1 + 8);
  uint64_t result = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v10);
  unint64_t v4 = result;
  if (a2[5])
  {
    if (a2[4]) {
      goto LABEL_3;
    }
  }
  else
  {
    unsigned int v9 = 3;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(result);
    unint64_t v10 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
    unint64_t v11 = v4;
    uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v9);
    a2[5] = result;
    if (a2[4])
    {
LABEL_3:
      if (a2[2]) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  unsigned int v9 = 3;
  uint64_t v6 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  unint64_t v10 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  unint64_t v11 = v4;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v6, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v9);
  a2[4] = result;
  if (a2[2])
  {
LABEL_4:
    if (a2[1]) {
      return result;
    }
LABEL_9:
    unsigned int v9 = 0;
    __int16 v8 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
    unint64_t v10 = &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id;
    unint64_t v11 = v4;
    uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::GRUGateLayoutAttrStorage,mlir::mps::GRUGateLayout>(v8, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24GRUGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17GRUGateLayoutAttrEJNS2_13GRUGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id, &v9);
    a2[1] = result;
    return result;
  }
LABEL_8:
  unsigned int v9 = 2;
  uint64_t v7 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  unint64_t v10 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  unint64_t v11 = v4;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v7, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v9);
  a2[2] = result;
  if (!a2[1]) {
    goto LABEL_9;
  }
  return result;
}

uint64_t mlir::mps::GRUGradientOp::verifyInvariantsImpl(mlir::mps::GRUGradientOp *this)
{
  v96[24] = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  uint64_t v7 = v3[2];
  uint64_t v6 = v3[3];
  uint64_t v9 = v3[4];
  uint64_t v8 = v3[5];
  v96[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v8, (void **)"zgate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v96))return 0; {
  v96[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v9, (void **)"rgate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v96))return 0; {
  v96[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v7, (void **)"ogate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v96))return 0; {
  v96[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(v5, (void **)"gate_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v96))return 0; {
  v96[0] = *(void *)this;
  }
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v6, (void **)"reset_after", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v96))return 0; {
  v96[0] = *(void *)this;
  }
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v4, (void **)"flip_z", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v96))return 0; {
  unsigned int v95 = 0;
  }
  unint64_t v10 = *(unsigned int *)(*(void *)this + 44);
  uint64_t v11 = *(void *)this + 16 * ((v10 >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v11 = 0;
  }
  uint64_t v12 = *(unsigned int *)(v11 + 48);
  if ((v10 & 0x800000) != 0)
  {
    uint64_t v13 = *(void *)(*(void *)this + 72);
    if (v12) {
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v13 = 0;
    if (v12)
    {
LABEL_14:
      uint64_t v14 = v13 + 24;
      do
      {
        uint64_t v15 = *(void *)this;
        unint64_t v16 = *(void *)(*(void *)v14 + 8) & 0xFFFFFFFFFFFFFFF8;
        unsigned int v17 = v95++;
        if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v15, v16, (void **)"operand", (void **)7, v17))return 0; {
        v14 += 32;
        }
      }
      while (--v12);
    }
  }
  uint64_t ODSOperands = mlir::mps::GRUGradientOp::getODSOperands(this, 1u);
  if (v19)
  {
    uint64_t v20 = v19;
    uint64_t v21 = ODSOperands + 24;
    do
    {
      uint64_t v22 = *(void *)this;
      unint64_t v23 = *(void *)(*(void *)v21 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v24 = v95++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v22, v23, (void **)"operand", (void **)7, v24))return 0; {
      v21 += 32;
      }
    }
    while (--v20);
  }
  uint64_t v25 = mlir::mps::GRUGradientOp::getODSOperands(this, 2u);
  if (v26)
  {
    uint64_t v27 = v26;
    uint64_t v28 = v25 + 24;
    do
    {
      uint64_t v29 = *(void *)this;
      unint64_t v30 = *(void *)(*(void *)v28 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v31 = v95++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v29, v30, (void **)"operand", (void **)7, v31))return 0; {
      v28 += 32;
      }
    }
    while (--v27);
  }
  uint64_t v32 = mlir::mps::GRUGradientOp::getODSOperands(this, 3u);
  if (v33)
  {
    uint64_t v34 = v33;
    uint64_t v35 = v32 + 24;
    do
    {
      uint64_t v36 = *(void *)this;
      unint64_t v37 = *(void *)(*(void *)v35 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v38 = v95++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v36, v37, (void **)"operand", (void **)7, v38))return 0; {
      v35 += 32;
      }
    }
    while (--v34);
  }
  uint64_t v39 = mlir::mps::GRUGradientOp::getODSOperands(this, 4u);
  uint64_t v41 = v40;
  if (v40 >= 2) {
    goto LABEL_36;
  }
  if (v40)
  {
    uint64_t v42 = *(void *)(v39 + 24);
    uint64_t v43 = *(void *)this;
    unint64_t v44 = *(void *)(v42 + 8) & 0xFFFFFFFFFFFFFFF8;
    unsigned int v45 = v95++;
    if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v43, v44, (void **)"operand", (void **)7, v45))return 0; {
  }
    }
  uint64_t v46 = mlir::mps::GRUGradientOp::getODSOperands(this, 5u);
  uint64_t v41 = v47;
  if (v47 < 2)
  {
    if (!v47
      || (uint64_t v48 = *(void *)(v46 + 24),
          uint64_t v49 = *(void *)this,
          unint64_t v50 = *(void *)(v48 + 8) & 0xFFFFFFFFFFFFFFF8,
          unsigned int v51 = v95,
          ++v95,
          mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v49, v50, (void **)"operand", (void **)7, v51)))
    {
      uint64_t v52 = mlir::mps::GRUGradientOp::getODSOperands(this, 6u);
      uint64_t v41 = v53;
      if (v53 >= 2) {
        goto LABEL_36;
      }
      if (!v53
        || (uint64_t v58 = *(void *)(v52 + 24),
            uint64_t v59 = *(void *)this,
            unint64_t v60 = *(void *)(v58 + 8) & 0xFFFFFFFFFFFFFFF8,
            unsigned int v61 = v95,
            ++v95,
            mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v59, v60, (void **)"operand", (void **)7, v61)))
      {
        unsigned int v95 = 0;
        uint64_t ODSResults = mlir::mps::GRUGradientOp::getODSResults(this, 0);
        if (v63)
        {
          uint64_t v64 = ODSResults;
          uint64_t v65 = v63;
          uint64_t v66 = 0;
          while (1)
          {
            uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v64, v66);
            uint64_t v68 = *(void *)this;
            unint64_t v69 = *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8;
            unsigned int v95 = v66 + 1;
            if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v68, v69, (void **)"result", (void **)6, v66))break; {
            if (v65 == ++v66)
            }
              goto LABEL_46;
          }
        }
        else
        {
          LODWORD(v66) = 0;
LABEL_46:
          uint64_t v70 = mlir::mps::GRUGradientOp::getODSResults(this, 1u);
          if (v71)
          {
            uint64_t v72 = v70;
            uint64_t v73 = v71;
            uint64_t v74 = 0;
            while (1)
            {
              uint64_t v75 = mlir::detail::OpResultImpl::getNextResultAtOffset(v72, v74);
              uint64_t v76 = *(void *)this;
              unint64_t v77 = *(void *)(v75 + 8) & 0xFFFFFFFFFFFFFFF8;
              unsigned int v95 = v66 + v74 + 1;
              if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v76, v77, (void **)"result", (void **)6, (int)v66 + (int)v74))break; {
              if (v73 == ++v74)
              }
              {
                LODWORD(v66) = v66 + v74;
                goto LABEL_51;
              }
            }
          }
          else
          {
LABEL_51:
            uint64_t v78 = mlir::mps::GRUGradientOp::getODSResults(this, 2u);
            if (v79)
            {
              uint64_t v80 = v78;
              uint64_t v81 = v79;
              uint64_t v82 = 0;
              while (1)
              {
                uint64_t v83 = mlir::detail::OpResultImpl::getNextResultAtOffset(v80, v82);
                uint64_t v84 = *(void *)this;
                unint64_t v85 = *(void *)(v83 + 8) & 0xFFFFFFFFFFFFFFF8;
                unsigned int v95 = v66 + v82 + 1;
                if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v84, v85, (void **)"result", (void **)6, (int)v66 + (int)v82))break; {
                if (v81 == ++v82)
                }
                {
                  LODWORD(v66) = v66 + v82;
                  goto LABEL_56;
                }
              }
            }
            else
            {
LABEL_56:
              uint64_t v86 = mlir::mps::GRUGradientOp::getODSResults(this, 3u);
              uint64_t v88 = v87;
              if (v87 >= 2)
              {
                v93[0] = (void **)"result group starting at #";
                __int16 v94 = 259;
                mlir::OpState::emitOpError((uint64_t *)this, v93, (uint64_t)v96);
                uint64_t v89 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v96, &v95);
                uint64_t v55 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v89, " requires 0 or 1 element, but found ");
                uint64_t v92 = v88;
                goto LABEL_37;
              }
              if (!v87) {
                return 1;
              }
              uint64_t v90 = mlir::detail::OpResultImpl::getNextResultAtOffset(v86, 0);
              if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(v90 + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, v66))return 1; {
            }
              }
          }
        }
      }
    }
    return 0;
  }
LABEL_36:
  v93[0] = (void **)"operand group starting at #";
  __int16 v94 = 259;
  mlir::OpState::emitOpError((uint64_t *)this, v93, (uint64_t)v96);
  uint64_t v54 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v96, &v95);
  uint64_t v55 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v54, " requires 0 or 1 element, but found ");
  uint64_t v92 = v41;
LABEL_37:
  uint64_t v56 = mlir::InFlightDiagnostic::operator<<<unsigned long &>(v55, &v92);
  uint64_t v57 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v56);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v96);
  return v57;
}

void mlir::mps::GRUGradientOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::GRUOp::getODSResults(mlir::mps::GRUOp *this, unsigned int a2)
{
  if (a2)
  {
    if (a2 >= 8)
    {
      int32x4_t v4 = (int32x4_t)xmmword_211EE3A90;
      unsigned int v3 = a2 & 0xFFFFFFF8;
      int32x4_t v5 = 0uLL;
      v6.i64[0] = 0x300000003;
      v6.i64[1] = 0x300000003;
      v7.i64[0] = 0x800000008;
      v7.i64[1] = 0x800000008;
      unsigned int v8 = a2 & 0xFFFFFFF8;
      int32x4_t v9 = 0uLL;
      do
      {
        int32x4_t v5 = vsubq_s32(v5, vtstq_s32(v4, v4));
        int32x4_t v9 = vsubq_s32(v9, (int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(v4, v6)));
        int32x4_t v4 = vaddq_s32(v4, v7);
        v8 -= 8;
      }
      while (v8);
      int v2 = vaddvq_s32(vaddq_s32(v9, v5));
      if (v3 == a2) {
        goto LABEL_11;
      }
    }
    else
    {
      int v2 = 0;
      unsigned int v3 = 0;
    }
    do
    {
      if (v3) {
        ++v2;
      }
      ++v3;
    }
    while (a2 != v3);
  }
  else
  {
    int v2 = 0;
  }
LABEL_11:
  int v10 = *(_DWORD *)(*(void *)this + 36);
  if (v10) {
    uint64_t result = *(void *)this - 16;
  }
  else {
    uint64_t result = 0;
  }
  if (a2 + (v10 - 2) * v2) {
    return mlir::detail::OpResultImpl::getNextResultAtOffset(result, a2 + (v10 - 2) * v2);
  }
  return result;
}

uint64_t mlir::mps::GRUOp::getODSOperands(mlir::mps::GRUOp *this, unsigned int a2)
{
  unint64_t v2 = *(unsigned int *)(*(void *)this + 44);
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = *(void *)this + 16 * ((v2 >> 23) & 1) + 64;
  }
  else {
    uint64_t v3 = 0;
  }
  if (!a2)
  {
    uint64_t v6 = 0;
    goto LABEL_14;
  }
  if (a2 >= 8)
  {
    uint64_t v4 = a2 & 0xFFFFFFF8;
    int32x4_t v7 = (int32x4_t *)(v3 + 72);
    int32x4_t v8 = 0uLL;
    uint64_t v9 = v4;
    int32x4_t v10 = 0uLL;
    do
    {
      int32x4_t v8 = vaddq_s32(v7[-1], v8);
      int32x4_t v10 = vaddq_s32(*v7, v10);
      v7 += 2;
      v9 -= 8;
    }
    while (v9);
    unsigned int v5 = vaddvq_s32(vaddq_s32(v10, v8));
    if (v4 == a2) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v4 = 0;
    unsigned int v5 = 0;
  }
  uint64_t v11 = a2 - v4;
  uint64_t v12 = (int *)(v3 + 4 * v4 + 56);
  do
  {
    int v13 = *v12++;
    v5 += v13;
    --v11;
  }
  while (v11);
LABEL_13:
  uint64_t v6 = v5;
LABEL_14:
  if ((v2 & 0x800000) != 0) {
    return *(void *)(*(void *)this + 72) + 32 * v6;
  }
  else {
    return 32 * v6;
  }
}

BOOL mlir::mps::GRUOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v85 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v71 = v6;
  if (!v6)
  {
    a3(v75, a4);
    if (v75[0])
    {
      LODWORD(v72) = 3;
      uint64_t v73 = "expected DictionaryAttr to set properties";
      uint64_t v74 = 41;
      uint64_t v26 = &v72;
      uint64_t v27 = (char *)v76;
      if (v77 >= v78)
      {
        unint64_t v61 = v77 + 1;
        if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
        {
          int64_t v66 = (char *)&v72 - (unsigned char *)v76;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v61, 24);
          uint64_t v27 = (char *)v76;
          uint64_t v26 = (uint64_t *)((char *)v76 + v66);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v61, 24);
          uint64_t v26 = &v72;
          uint64_t v27 = (char *)v76;
        }
      }
      uint64_t v28 = &v27[24 * v77];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)uint64_t v28 = v29;
      ++v77;
      if (v75[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v75);
      }
    }
    if (!v84) {
      return 0;
    }
    unint64_t v30 = __p;
    if (__p)
    {
      unsigned int v31 = v83;
      uint64_t v32 = __p;
      if (v83 != __p)
      {
        do
          unsigned int v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        uint64_t v32 = __p;
      }
      uint64_t v83 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v80;
    if (!v80) {
      goto LABEL_64;
    }
    uint64_t v33 = v81;
    unint64_t v23 = v80;
    if (v81 == v80)
    {
LABEL_63:
      uint64_t v81 = v21;
      operator delete(v23);
LABEL_64:
      if (v76 != v79) {
        free(v76);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
LABEL_62:
    unint64_t v23 = v80;
    goto LABEL_63;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v71, "flip_z", 6uLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v75, a4);
      if (v75[0])
      {
        LODWORD(v72) = 3;
        uint64_t v74 = 51;
        int32x4_t v10 = &v72;
        uint64_t v11 = (char *)v76;
        if (v77 >= v78)
        {
          unint64_t v62 = v77 + 1;
          if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
          {
            int64_t v67 = (char *)&v72 - (unsigned char *)v76;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v62, 24);
            uint64_t v11 = (char *)v76;
            int32x4_t v10 = (uint64_t *)((char *)v76 + v67);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v62, 24);
            int32x4_t v10 = &v72;
            uint64_t v11 = (char *)v76;
          }
        }
        uint64_t v12 = &v11[24 * v77];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = v10[2];
        *(_OWORD *)uint64_t v12 = v13;
        ++v77;
        if (v75[0])
        {
          uint64_t v14 = &v72;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v72, v9);
          uint64_t v15 = (char *)v76;
          if (v77 >= v78)
          {
            unint64_t v63 = v77 + 1;
            if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
            {
              int64_t v68 = (char *)&v72 - (unsigned char *)v76;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v63, 24);
              uint64_t v15 = (char *)v76;
              uint64_t v14 = (uint64_t *)((char *)v76 + v68);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v63, 24);
              uint64_t v14 = &v72;
              uint64_t v15 = (char *)v76;
            }
          }
          unint64_t v16 = &v15[24 * v77];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = v14[2];
          *(_OWORD *)unint64_t v16 = v17;
          ++v77;
          if (v75[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v75);
          }
        }
      }
      if (!v84) {
        return 0;
      }
      unint64_t v18 = __p;
      if (__p)
      {
        uint64_t v19 = v83;
        uint64_t v20 = __p;
        if (v83 != __p)
        {
          do
            uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          uint64_t v20 = __p;
        }
        uint64_t v83 = v18;
        operator delete(v20);
      }
      uint64_t v21 = v80;
      if (!v80) {
        goto LABEL_64;
      }
      uint64_t v22 = v81;
      unint64_t v23 = v80;
      if (v81 == v80) {
        goto LABEL_63;
      }
      do
      {
        uint64_t v25 = *--v22;
        uint64_t v24 = v25;
        void *v22 = 0;
        if (v25) {
          MEMORY[0x21667D390](v24, 0x1000C8077774924);
        }
      }
      while (v22 != v21);
      goto LABEL_62;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v71, "gate_layout", 0xBuLL);
  if (v36)
  {
    uint64_t v37 = v36;
    if (*(_UNKNOWN **)(*(void *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id)
    {
      a3(v75, a4);
      if (v75[0])
      {
        LODWORD(v72) = 3;
        uint64_t v74 = 56;
        unsigned int v38 = &v72;
        uint64_t v39 = (char *)v76;
        if (v77 >= v78)
        {
          unint64_t v64 = v77 + 1;
          if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
          {
            int64_t v69 = (char *)&v72 - (unsigned char *)v76;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v64, 24);
            uint64_t v39 = (char *)v76;
            unsigned int v38 = (uint64_t *)((char *)v76 + v69);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v64, 24);
            unsigned int v38 = &v72;
            uint64_t v39 = (char *)v76;
          }
        }
        unint64_t v40 = &v39[24 * v77];
        long long v41 = *(_OWORD *)v38;
        *((void *)v40 + 2) = v38[2];
        *(_OWORD *)unint64_t v40 = v41;
        ++v77;
        if (v75[0])
        {
          uint64_t v42 = &v72;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v72, v37);
          uint64_t v43 = (char *)v76;
          if (v77 >= v78)
          {
            unint64_t v65 = v77 + 1;
            if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
            {
              int64_t v70 = (char *)&v72 - (unsigned char *)v76;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v65, 24);
              uint64_t v43 = (char *)v76;
              uint64_t v42 = (uint64_t *)((char *)v76 + v70);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v65, 24);
              uint64_t v42 = &v72;
              uint64_t v43 = (char *)v76;
            }
          }
          unint64_t v44 = &v43[24 * v77];
          long long v45 = *(_OWORD *)v42;
          *((void *)v44 + 2) = v42[2];
          *(_OWORD *)unint64_t v44 = v45;
          ++v77;
          if (v75[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v75);
          }
        }
      }
      if (!v84) {
        return 0;
      }
      uint64_t v46 = __p;
      if (__p)
      {
        unint64_t v47 = v83;
        uint64_t v48 = __p;
        if (v83 != __p)
        {
          do
            unint64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          uint64_t v48 = __p;
        }
        uint64_t v83 = v46;
        operator delete(v48);
      }
      uint64_t v21 = v80;
      if (!v80) {
        goto LABEL_64;
      }
      uint64_t v49 = v81;
      unint64_t v23 = v80;
      if (v81 == v80) {
        goto LABEL_63;
      }
      do
      {
        uint64_t v51 = *--v49;
        uint64_t v50 = v51;
        *uint64_t v49 = 0;
        if (v51) {
          MEMORY[0x21667D390](v50, 0x1000C8077774924);
        }
      }
      while (v49 != v21);
      goto LABEL_62;
    }
    a1[1] = v36;
  }
  uint64_t v52 = mlir::DictionaryAttr::get((uint64_t)&v71, "ogate_activation", 0x10uLL);
  uint64_t v72 = v52;
  if (v52)
  {
    if (*(_UNKNOWN **)(*(void *)v52 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v75, a4);
LABEL_86:
      uint64_t v55 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v75, v53);
      goto LABEL_87;
    }
    a1[2] = v52;
  }
  uint64_t v54 = mlir::DictionaryAttr::get((uint64_t)&v71, "reset_after", 0xBuLL);
  uint64_t v72 = v54;
  if (v54)
  {
    if (*(_UNKNOWN **)(*(void *)v54 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v75, a4);
LABEL_87:
      mlir::InFlightDiagnostic::append<mlir::Attribute>(v55, &v72);
LABEL_88:
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v75);
      return 0;
    }
    a1[3] = v54;
  }
  uint64_t v56 = mlir::DictionaryAttr::get((uint64_t)&v71, "rgate_activation", 0x10uLL);
  uint64_t v72 = v56;
  if (v56)
  {
    if (*(_UNKNOWN **)(*(void *)v56 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v75, a4);
      goto LABEL_86;
    }
    a1[4] = v56;
  }
  uint64_t v57 = mlir::DictionaryAttr::get((uint64_t)&v71, "training", 8uLL);
  uint64_t v72 = v57;
  if (v57)
  {
    if (*(_UNKNOWN **)(*(void *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v75, a4);
      goto LABEL_87;
    }
    a1[5] = v57;
  }
  uint64_t v58 = mlir::DictionaryAttr::get((uint64_t)&v71, "zgate_activation", 0x10uLL);
  uint64_t v72 = v58;
  if (v58)
  {
    if (*(_UNKNOWN **)(*(void *)v58 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v75, a4);
      goto LABEL_86;
    }
    a1[6] = v58;
  }
  unint64_t v60 = (void *)mlir::DictionaryAttr::get((uint64_t)&v71, "operandSegmentSizes", 0x13uLL);
  if (!v60)
  {
    unint64_t v60 = (void *)mlir::DictionaryAttr::get((uint64_t)&v71, "operand_segment_sizes", 0x15uLL);
    if (!v60)
    {
      a3(v75, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v75, "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.");
      goto LABEL_88;
    }
  }
  return mlir::convertFromAttribute(a1 + 7, (const char *)5, v60, a3, a4) != 0;
}

uint64_t mlir::mps::GRUOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v59[6] = *MEMORY[0x263EF8340];
  uint64_t v56 = a1;
  uint64_t v57 = v59;
  uint64_t v58 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v56, (uint64_t)"flip_z", 6, *a2);
    uint64_t v6 = v5;
    unsigned int v7 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v7 = v58;
    }
    uint64_t v8 = (uint64_t *)((char *)v57 + 16 * v7);
    *uint64_t v8 = NamedAttr;
    v8[1] = v6;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v9 = a2[1];
  if (v9)
  {
    uint64_t v10 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"gate_layout", 11, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v13 = v58;
    }
    uint64_t v14 = (uint64_t *)((char *)v57 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"ogate_activation", 16, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v19 = v58;
    }
    uint64_t v20 = (uint64_t *)((char *)v57 + 16 * v19);
    uint64_t *v20 = v16;
    v20[1] = v18;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"reset_after", 11, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v25 = v58;
    }
    uint64_t v26 = (uint64_t *)((char *)v57 + 16 * v25);
    uint64_t *v26 = v22;
    v26[1] = v24;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"rgate_activation", 16, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v31 = v58;
    }
    uint64_t v32 = (uint64_t *)((char *)v57 + 16 * v31);
    uint64_t *v32 = v28;
    v32[1] = v30;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v33 = a2[5];
  if (v33)
  {
    uint64_t v34 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"training", 8, v33);
    uint64_t v36 = v35;
    unsigned int v37 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v37 = v58;
    }
    unsigned int v38 = (uint64_t *)((char *)v57 + 16 * v37);
    uint64_t *v38 = v34;
    v38[1] = v36;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v39 = a2[6];
  if (v39)
  {
    uint64_t v40 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"zgate_activation", 16, v39);
    uint64_t v42 = v41;
    unsigned int v43 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v43 = v58;
    }
    unint64_t v44 = (uint64_t *)((char *)v57 + 16 * v43);
    uint64_t *v44 = v40;
    v44[1] = v42;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v45 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 7), 5);
  uint64_t v46 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"operandSegmentSizes", 19, v45);
  uint64_t v48 = v47;
  unsigned int v49 = v58;
  if (v58 >= HIDWORD(v58))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
    unsigned int v49 = v58;
  }
  uint64_t v50 = (uint64_t *)((char *)v57 + 16 * v49);
  *uint64_t v50 = v46;
  v50[1] = v48;
  BOOL v51 = __CFADD__(v58, 1);
  uint64_t v52 = (v58 + 1);
  LODWORD(v58) = v58 + 1;
  if (v51)
  {
    uint64_t DictionaryAttr = 0;
    uint64_t v54 = v57;
    if (v57 == v59) {
      return DictionaryAttr;
    }
    goto LABEL_36;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v56, (uint64_t *)v57, v52);
  uint64_t v54 = v57;
  if (v57 != v59) {
LABEL_36:
  }
    free(v54);
  return DictionaryAttr;
}

unint64_t mlir::mps::GRUOp::computePropertiesHash(unint64_t *a1)
{
  uint64_t v114 = *MEMORY[0x263EF8340];
  unint64_t v1 = *a1;
  unint64_t v2 = &unk_267770000;
  {
    uint64_t v86 = a1;
    unint64_t v94 = v1;
    unint64_t v2 = &unk_267770000;
    int v33 = v32;
    a1 = v86;
    unint64_t v1 = v94;
    if (v33)
    {
      unint64_t v34 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v34 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v34;
      a1 = v86;
      unint64_t v1 = v94;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  uint64_t v3 = v2[385];
  unint64_t v4 = a1[1];
  {
    unint64_t v87 = a1;
    unint64_t v95 = v1;
    uint64_t v70 = v3;
    unint64_t v78 = v4;
    uint64_t v3 = v70;
    unint64_t v4 = v78;
    unint64_t v2 = &unk_267770000;
    int v36 = v35;
    a1 = v87;
    unint64_t v1 = v95;
    if (v36)
    {
      unint64_t v37 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v37 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v37;
      uint64_t v3 = v70;
      unint64_t v4 = v78;
      a1 = v87;
      unint64_t v1 = v95;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  uint64_t v5 = v2[385];
  unint64_t v6 = a1[2];
  {
    uint64_t v88 = a1;
    unint64_t v96 = v1;
    uint64_t v71 = v3;
    unint64_t v79 = v4;
    unint64_t v58 = v6;
    uint64_t v63 = v5;
    unint64_t v6 = v58;
    uint64_t v5 = v63;
    uint64_t v3 = v71;
    unint64_t v4 = v79;
    unint64_t v2 = &unk_267770000;
    int v39 = v38;
    a1 = v88;
    unint64_t v1 = v96;
    if (v39)
    {
      unint64_t v40 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v40 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v40;
      unint64_t v6 = v58;
      uint64_t v5 = v63;
      uint64_t v3 = v71;
      unint64_t v4 = v79;
      a1 = v88;
      unint64_t v1 = v96;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v7 = HIDWORD(v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v6) ^ HIDWORD(v6));
  unint64_t v108 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) ^ ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) >> 47));
  unint64_t v9 = a1[3];
  {
    uint64_t v89 = a1;
    unint64_t v97 = v1;
    uint64_t v72 = v3;
    unint64_t v80 = v4;
    unint64_t v59 = v9;
    uint64_t v64 = v5;
    unint64_t v9 = v59;
    uint64_t v5 = v64;
    uint64_t v3 = v72;
    unint64_t v4 = v80;
    unint64_t v2 = &unk_267770000;
    int v42 = v41;
    a1 = v89;
    unint64_t v1 = v97;
    if (v42)
    {
      unint64_t v43 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v43 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v43;
      unint64_t v9 = v59;
      uint64_t v5 = v64;
      uint64_t v3 = v72;
      unint64_t v4 = v80;
      a1 = v89;
      unint64_t v1 = v97;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v10 = HIDWORD(v9);
  unint64_t v11 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v9) ^ HIDWORD(v9));
  unint64_t v107 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) ^ ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) >> 47));
  unint64_t v12 = a1[4];
  {
    uint64_t v90 = a1;
    unint64_t v98 = v1;
    uint64_t v73 = v3;
    unint64_t v81 = v4;
    unint64_t v60 = v12;
    uint64_t v65 = v5;
    unint64_t v12 = v60;
    uint64_t v5 = v65;
    uint64_t v3 = v73;
    unint64_t v4 = v81;
    unint64_t v2 = &unk_267770000;
    int v45 = v44;
    a1 = v90;
    unint64_t v1 = v98;
    if (v45)
    {
      unint64_t v46 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v46 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v46;
      unint64_t v12 = v60;
      uint64_t v5 = v65;
      uint64_t v3 = v73;
      unint64_t v4 = v81;
      a1 = v90;
      unint64_t v1 = v98;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v13 = HIDWORD(v12);
  unint64_t v14 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v12) ^ HIDWORD(v12));
  unint64_t v106 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) ^ ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) >> 47));
  unint64_t v15 = a1[5];
  {
    BOOL v91 = a1;
    unint64_t v99 = v1;
    uint64_t v74 = v3;
    unint64_t v82 = v4;
    unint64_t v61 = v15;
    uint64_t v66 = v5;
    unint64_t v15 = v61;
    uint64_t v5 = v66;
    uint64_t v3 = v74;
    unint64_t v4 = v82;
    unint64_t v2 = &unk_267770000;
    int v48 = v47;
    a1 = v91;
    unint64_t v1 = v99;
    if (v48)
    {
      unint64_t v49 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v49 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v49;
      unint64_t v15 = v61;
      uint64_t v5 = v66;
      uint64_t v3 = v74;
      unint64_t v4 = v82;
      a1 = v91;
      unint64_t v1 = v99;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v16 = HIDWORD(v15);
  unint64_t v17 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v15) ^ HIDWORD(v15));
  unint64_t v105 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) ^ ((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) >> 47));
  unint64_t v18 = a1[6];
  {
    uint64_t v92 = a1;
    unint64_t v100 = v1;
    uint64_t v75 = v3;
    unint64_t v83 = v4;
    unint64_t v62 = v18;
    uint64_t v67 = v5;
    unint64_t v18 = v62;
    uint64_t v5 = v67;
    uint64_t v3 = v75;
    unint64_t v4 = v83;
    unint64_t v2 = &unk_267770000;
    int v51 = v50;
    a1 = v92;
    unint64_t v1 = v100;
    if (v51)
    {
      unint64_t v52 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v52 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v52;
      unint64_t v18 = v62;
      uint64_t v5 = v67;
      uint64_t v3 = v75;
      unint64_t v4 = v83;
      a1 = v92;
      unint64_t v1 = v100;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v19 = HIDWORD(v18);
  unint64_t v20 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v18) ^ HIDWORD(v18));
  unint64_t v104 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v19 ^ (v20 >> 47) ^ v20)) ^ ((0x9DDFEA08EB382D69 * (v19 ^ (v20 >> 47) ^ v20)) >> 47));
  {
    BOOL v93 = a1;
    unint64_t v101 = v1;
    uint64_t v76 = v3;
    unint64_t v84 = v4;
    uint64_t v68 = v5;
    uint64_t v5 = v68;
    uint64_t v3 = v76;
    unint64_t v1 = v101;
    unint64_t v2 = &unk_267770000;
    int v54 = v53;
    unint64_t v4 = v84;
    a1 = v93;
    if (v54)
    {
      unint64_t v55 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v55 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v55;
      uint64_t v5 = v68;
      uint64_t v3 = v76;
      unint64_t v4 = v84;
      a1 = v93;
      unint64_t v1 = v101;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  uint64_t v21 = v2[385];
  unint64_t v22 = 0xB492B66FBE98F273 * a1[7];
  unint64_t v23 = a1[8];
  unint64_t v24 = 0x9AE16A3B2F90404FLL * *(unint64_t *)((char *)a1 + 68);
  uint64_t v25 = __ROR8__(v22 - v23, 43)
      - 0x3C5A37A36834CED9 * *(unint64_t *)((char *)a1 + 60)
      + __ROR8__(v24 ^ v21, 30);
  uint64_t v26 = v21 + __ROR8__(v23 ^ 0xC949D7C7509E6557, 20) + v22 - v24 + 20;
  unint64_t v103 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69
         * (v26 ^ ((0x9DDFEA08EB382D69 * (v25 ^ v26)) >> 47) ^ (0x9DDFEA08EB382D69 * (v25 ^ v26)))) ^ ((0x9DDFEA08EB382D69 * (v26 ^ ((0x9DDFEA08EB382D69 * (v25 ^ v26)) >> 47) ^ (0x9DDFEA08EB382D69 * (v25 ^ v26)))) >> 47));
  uint64_t v112 = 0;
  memset(v111, 0, sizeof(v111));
  memset(v110, 0, sizeof(v110));
  long long v109 = 0u;
  {
    unint64_t v102 = v1;
    uint64_t v77 = v3;
    unint64_t v85 = v4;
    uint64_t v69 = v5;
    uint64_t v5 = v69;
    uint64_t v3 = v77;
    unint64_t v4 = v85;
    unint64_t v1 = v102;
    unint64_t v2 = &unk_267770000;
    if (v56)
    {
      unint64_t v57 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v57 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v57;
      uint64_t v5 = v69;
      uint64_t v3 = v77;
      unint64_t v4 = v85;
      unint64_t v1 = v102;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v27 = 0x9DDFEA08EB382D69 * ((v5 + 8 * v4) ^ HIDWORD(v4));
  unint64_t v28 = 0x9DDFEA08EB382D69 * (HIDWORD(v4) ^ (v27 >> 47) ^ v27);
  unint64_t v29 = HIDWORD(v1);
  unint64_t v30 = 0x9DDFEA08EB382D69 * ((v3 + 8 * v1) ^ HIDWORD(v1));
  uint64_t v113 = v2[385];
  *(void *)&long long v109 = 0x9DDFEA08EB382D69
                   * ((0x9DDFEA08EB382D69 * (v29 ^ (v30 >> 47) ^ v30)) ^ ((0x9DDFEA08EB382D69
                                                                           * (v29 ^ (v30 >> 47) ^ v30)) >> 47));
  *((void *)&v109 + 1) = 0x9DDFEA08EB382D69 * (v28 ^ (v28 >> 47));
  return llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>((llvm::hashing::detail::hash_combine_recursive_helper *)&v109, 0, v110, (char *)v111, (uint64_t *)&v108, (uint64_t *)&v107, (uint64_t *)&v106, (uint64_t *)&v105, (uint64_t *)&v104, (uint64_t *)&v103);
}

uint64_t mlir::mps::GRUOp::getInherentAttr(mlir::MLIRContext *a1, void *a2, _WORD *__s1, size_t __n)
{
  uint64_t result = 0;
  switch(__n)
  {
    case 6uLL:
      if (*(_DWORD *)__s1 != 1885957222 || __s1[2] != 31327) {
        goto LABEL_18;
      }
      return *a2;
    case 7uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0xFuLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x14uLL:
      goto LABEL_18;
    case 8uLL:
      if (memcmp(__s1, "training", __n)) {
        goto LABEL_18;
      }
      return a2[5];
    case 0xBuLL:
      if (!memcmp(__s1, "gate_layout", __n))
      {
        uint64_t result = a2[1];
      }
      else
      {
        if (memcmp(__s1, "reset_after", __n)) {
          goto LABEL_18;
        }
        uint64_t result = a2[3];
      }
      break;
    case 0x10uLL:
      if (!memcmp(__s1, "ogate_activation", __n))
      {
        uint64_t result = a2[2];
      }
      else if (!memcmp(__s1, "rgate_activation", __n))
      {
        uint64_t result = a2[4];
      }
      else if (!memcmp(__s1, "zgate_activation", __n))
      {
        uint64_t result = a2[6];
      }
      else
      {
LABEL_18:
        uint64_t result = 0;
      }
      break;
    case 0x13uLL:
      if (memcmp(__s1, "operandSegmentSizes", __n)) {
        goto LABEL_18;
      }
      return mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 7), 5);
    case 0x15uLL:
      if (memcmp(__s1, "operand_segment_sizes", __n)) {
        goto LABEL_18;
      }
      return mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 7), 5);
    default:
      return result;
  }
  return result;
}

uint64_t mlir::mps::GRUOp::setInherentAttr(uint64_t result, _WORD *__s1, size_t __n, void *a4)
{
  unint64_t v7 = (void *)result;
  switch(__n)
  {
    case 6uLL:
      if (*(_DWORD *)__s1 == 1885957222 && __s1[2] == 31327)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
            unint64_t v14 = a4;
          }
          else {
            unint64_t v14 = 0;
          }
          *(void *)uint64_t result = v14;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 8uLL:
      uint64_t result = memcmp(__s1, "training", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
            unint64_t v9 = a4;
          }
          else {
            unint64_t v9 = 0;
          }
          v7[5] = v9;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      uint64_t result = memcmp(__s1, "gate_layout", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "reset_after", __n);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
              unint64_t v10 = a4;
            }
            else {
              unint64_t v10 = 0;
            }
            v7[3] = v10;
          }
          else
          {
            v7[3] = 0;
          }
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id) {
          unint64_t v15 = a4;
        }
        else {
          unint64_t v15 = 0;
        }
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "ogate_activation", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "rgate_activation", __n);
        if (result)
        {
          uint64_t result = memcmp(__s1, "zgate_activation", __n);
          if (!result)
          {
            if (a4)
            {
              if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
                unint64_t v11 = a4;
              }
              else {
                unint64_t v11 = 0;
              }
              v7[6] = v11;
            }
            else
            {
              v7[6] = 0;
            }
          }
        }
        else if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
            unint64_t v17 = a4;
          }
          else {
            unint64_t v17 = 0;
          }
          uint64_t v7[4] = v17;
        }
        else
        {
          uint64_t v7[4] = 0;
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
          unint64_t v16 = a4;
        }
        else {
          unint64_t v16 = 0;
        }
        v7[2] = v16;
      }
      else
      {
        v7[2] = 0;
      }
      break;
    case 0x13uLL:
      uint64_t result = memcmp(__s1, "operandSegmentSizes", __n);
      if (!result) {
        goto LABEL_31;
      }
      break;
    case 0x15uLL:
      uint64_t result = memcmp(__s1, "operand_segment_sizes", __n);
      if (!result)
      {
LABEL_31:
        if (a4)
        {
          uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
          unint64_t v12 = result ? a4 : 0;
          unint64_t v18 = v12;
          if (result)
          {
            uint64_t result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v18);
            if (result == 5)
            {
              uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v18);
              if (v13) {
                uint64_t result = (uint64_t)memmove(v7 + 7, (const void *)result, 4 * v13);
              }
            }
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::GRUOp::populateInherentAttrs(mlir::MLIRContext *a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"flip_z", 6, *a2);
  }
  uint64_t v6 = a2[1];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"gate_layout", 11, v6);
  }
  uint64_t v7 = a2[2];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"ogate_activation", 16, v7);
  }
  uint64_t v8 = a2[3];
  if (v8) {
    mlir::NamedAttrList::append(a3, (uint64_t)"reset_after", 11, v8);
  }
  uint64_t v9 = a2[4];
  if (v9) {
    mlir::NamedAttrList::append(a3, (uint64_t)"rgate_activation", 16, v9);
  }
  uint64_t v10 = a2[5];
  if (v10) {
    mlir::NamedAttrList::append(a3, (uint64_t)"training", 8, v10);
  }
  uint64_t v11 = a2[6];
  if (v11) {
    mlir::NamedAttrList::append(a3, (uint64_t)"zgate_activation", 16, v11);
  }
  uint64_t v12 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 7), 5);

  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v12);
}

BOOL mlir::mps::GRUOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v8, (void **)"flip_z", (const char *)6, a3, a4))
  {
    uint64_t v9 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(v9, (void **)"gate_layout", (const char *)0xB, a3, a4))
    {
      uint64_t v10 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v10, (void **)"ogate_activation", (const char *)0x10, a3, a4))
      {
        uint64_t v11 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v11, (void **)"reset_after", (const char *)0xB, a3, a4))
        {
          uint64_t v12 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v12, (void **)"rgate_activation", (const char *)0x10, a3, a4))
          {
            uint64_t v13 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 40));
            if (!v13
              || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v13, (void **)"training", (const char *)8, a3, a4))
            {
              uint64_t v14 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v14, (void **)"zgate_activation", (const char *)0x10, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

BOOL mlir::mps::GRUOp::readProperties(uint64_t a1, uint64_t a2)
{
  v10[24] = *MEMORY[0x263EF8340];
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>(a2);
  if (!mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::GRUGateLayoutAttr>(a1, v3 + 1)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 2))
  {
    return 0;
  }
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) <= 5)
  {
    uint64_t v9 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v9)) {
      return 0;
    }
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v9) >= 6)
    {
      v7[0] = (uint64_t)"size mismatch for operand/result_segment_size";
      __int16 v8 = 259;
      (*(void (**)(void *__return_ptr, uint64_t, uint64_t *))(*(void *)a1 + 16))(v10, a1, v7);
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v10);
      return 0;
    }
    unint64_t v4 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v9);
    if (v5) {
      memmove(v3 + 7, v4, 4 * v5);
    }
  }
  if (mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 3)
    && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 4)
    && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 5)
    && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 6))
  {
    v7[0] = a1;
    v7[1] = (uint64_t)(v3 + 7);
    return mlir::mps::GRUOp::readProperties(mlir::DialectBytecodeReader &,mlir::OperationState &)::$_0::operator()(v7) != 0;
  }
  return 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::mps::GRUOp::readProperties(mlir::DialectBytecodeReader &,mlir::OperationState &)::$_0::operator()(uint64_t *a1)
{
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)*a1 + 40))(*a1) < 6) {
    return 1;
  }
  uint64_t v2 = *a1;
  uint64_t v3 = (_DWORD *)a1[1];

  return mlir::DialectBytecodeReader::readSparseArray<int>(v2, v3, (const char *)5);
}

uint64_t mlir::mps::GRUOp::writeProperties(uint64_t a1, uint64_t a2)
{
  if (HIBYTE(*(_DWORD *)(*(void *)a1 + 44))) {
    unint64_t v4 = *(void *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(void *)a1 + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)v4);
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 8));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 16));
  if ((*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2) <= 5)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(void *)a1 + 24));
    uint64_t v6 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v4 + 56, 5);
    (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, v6);
  }
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 24));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 32));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 40));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 48));
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2);
  if (result >= 6)
  {
    return mlir::DialectBytecodeWriter::writeSparseArray<int>(a2, (int *)(v4 + 56), 5);
  }
  return result;
}

mlir::MLIRContext *mlir::mps::GRUOp::populateDefaultProperties(uint64_t a1, void *a2)
{
  uint64_t v10 = *(void **)(a1 + 8);
  uint64_t result = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v10);
  unint64_t v4 = result;
  if (a2[6])
  {
    if (a2[4]) {
      goto LABEL_3;
    }
  }
  else
  {
    unsigned int v9 = 3;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(result);
    uint64_t v10 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
    uint64_t v11 = v4;
    uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v9);
    a2[6] = result;
    if (a2[4])
    {
LABEL_3:
      if (a2[2]) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  unsigned int v9 = 3;
  uint64_t v6 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  uint64_t v10 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  uint64_t v11 = v4;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v6, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v9);
  a2[4] = result;
  if (a2[2])
  {
LABEL_4:
    if (a2[1]) {
      return result;
    }
LABEL_9:
    unsigned int v9 = 0;
    __int16 v8 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
    uint64_t v10 = &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id;
    uint64_t v11 = v4;
    uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::GRUGateLayoutAttrStorage,mlir::mps::GRUGateLayout>(v8, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24GRUGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17GRUGateLayoutAttrEJNS2_13GRUGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id, &v9);
    a2[1] = result;
    return result;
  }
LABEL_8:
  unsigned int v9 = 2;
  uint64_t v7 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  uint64_t v10 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  uint64_t v11 = v4;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v7, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v9);
  a2[2] = result;
  if (!a2[1]) {
    goto LABEL_9;
  }
  return result;
}

uint64_t mlir::mps::GRUOp::verifyInvariantsImpl(mlir::mps::GRUOp *this)
{
  v67[24] = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  uint64_t v7 = v3[2];
  uint64_t v6 = v3[3];
  uint64_t v9 = v3[4];
  uint64_t v8 = v3[5];
  uint64_t v10 = v3[6];
  v67[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v10, (void **)"zgate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0; {
  v67[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v9, (void **)"rgate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0; {
  v67[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v7, (void **)"ogate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0; {
  v67[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(v5, (void **)"gate_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0; {
  v67[0] = *(void *)this;
  }
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v8, (void **)"training", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0; {
  v67[0] = *(void *)this;
  }
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v6, (void **)"reset_after", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0; {
  v67[0] = *(void *)this;
  }
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v4, (void **)"flip_z", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0; {
  unsigned int v66 = 0;
  }
  unint64_t v11 = *(unsigned int *)(*(void *)this + 44);
  uint64_t v12 = *(void *)this + 16 * ((v11 >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v12 = 0;
  }
  uint64_t v13 = *(unsigned int *)(v12 + 56);
  if ((v11 & 0x800000) != 0)
  {
    uint64_t v14 = *(void *)(*(void *)this + 72);
    if (v13) {
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v14 = 0;
    if (v13)
    {
LABEL_15:
      uint64_t v15 = v14 + 24;
      do
      {
        uint64_t v16 = *(void *)this;
        unint64_t v17 = *(void *)(*(void *)v15 + 8) & 0xFFFFFFFFFFFFFFF8;
        unsigned int v18 = v66++;
        if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v16, v17, (void **)"operand", (void **)7, v18))return 0; {
        v15 += 32;
        }
      }
      while (--v13);
    }
  }
  uint64_t ODSOperands = mlir::mps::GRUOp::getODSOperands(this, 1u);
  if (v20)
  {
    uint64_t v21 = v20;
    uint64_t v22 = ODSOperands + 24;
    do
    {
      uint64_t v23 = *(void *)this;
      unint64_t v24 = *(void *)(*(void *)v22 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v25 = v66++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v23, v24, (void **)"operand", (void **)7, v25))return 0; {
      v22 += 32;
      }
    }
    while (--v21);
  }
  uint64_t v26 = mlir::mps::GRUOp::getODSOperands(this, 2u);
  uint64_t v28 = v27;
  if (v27 >= 2) {
    goto LABEL_29;
  }
  if (v27)
  {
    uint64_t v29 = *(void *)(v26 + 24);
    uint64_t v30 = *(void *)this;
    unint64_t v31 = *(void *)(v29 + 8) & 0xFFFFFFFFFFFFFFF8;
    unsigned int v32 = v66++;
    if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v30, v31, (void **)"operand", (void **)7, v32))return 0; {
  }
    }
  uint64_t v33 = mlir::mps::GRUOp::getODSOperands(this, 3u);
  uint64_t v28 = v34;
  if (v34 < 2)
  {
    if (!v34
      || (uint64_t v35 = *(void *)(v33 + 24),
          uint64_t v36 = *(void *)this,
          unint64_t v37 = *(void *)(v35 + 8) & 0xFFFFFFFFFFFFFFF8,
          unsigned int v38 = v66,
          ++v66,
          mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v36, v37, (void **)"operand", (void **)7, v38)))
    {
      uint64_t v39 = mlir::mps::GRUOp::getODSOperands(this, 4u);
      uint64_t v28 = v40;
      if (v40 >= 2) {
        goto LABEL_29;
      }
      if (!v40
        || (uint64_t v45 = *(void *)(v39 + 24),
            uint64_t v46 = *(void *)this,
            unint64_t v47 = *(void *)(v45 + 8) & 0xFFFFFFFFFFFFFFF8,
            unsigned int v48 = v66,
            ++v66,
            mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v46, v47, (void **)"operand", (void **)7, v48)))
      {
        unsigned int v66 = 0;
        uint64_t ODSResults = mlir::mps::GRUOp::getODSResults(this, 0);
        if (v50)
        {
          uint64_t v51 = ODSResults;
          uint64_t v52 = v50;
          uint64_t v53 = 0;
          while (1)
          {
            uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v51, v53);
            uint64_t v55 = *(void *)this;
            unint64_t v56 = *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8;
            unsigned int v66 = v53 + 1;
            if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v55, v56, (void **)"result", (void **)6, v53))break; {
            if (v52 == ++v53)
            }
              goto LABEL_39;
          }
        }
        else
        {
          LODWORD(v53) = 0;
LABEL_39:
          uint64_t v57 = mlir::mps::GRUOp::getODSResults(this, 1u);
          uint64_t v59 = v58;
          if (v58 >= 2)
          {
            v64[0] = (void **)"result group starting at #";
            __int16 v65 = 259;
            mlir::OpState::emitOpError((uint64_t *)this, v64, (uint64_t)v67);
            uint64_t v60 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v67, &v66);
            uint64_t v42 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v60, " requires 0 or 1 element, but found ");
            uint64_t v63 = v59;
            goto LABEL_30;
          }
          if (!v58) {
            return 1;
          }
          uint64_t v61 = mlir::detail::OpResultImpl::getNextResultAtOffset(v57, 0);
          if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(v61 + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, v53))return 1; {
        }
          }
      }
    }
    return 0;
  }
LABEL_29:
  v64[0] = (void **)"operand group starting at #";
  __int16 v65 = 259;
  mlir::OpState::emitOpError((uint64_t *)this, v64, (uint64_t)v67);
  uint64_t v41 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v67, &v66);
  uint64_t v42 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v41, " requires 0 or 1 element, but found ");
  uint64_t v63 = v28;
LABEL_30:
  uint64_t v43 = mlir::InFlightDiagnostic::operator<<<unsigned long &>(v42, &v63);
  uint64_t v44 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v43);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v67);
  return v44;
}

void mlir::mps::GRUOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::GatherAlongAxisOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      int v44 = 3;
      uint64_t v45 = "expected DictionaryAttr to set properties";
      uint64_t v46 = 41;
      uint64_t v26 = &v44;
      unint64_t v27 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v40 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          unint64_t v27 = (char *)v48;
          uint64_t v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          uint64_t v26 = &v44;
          unint64_t v27 = (char *)v48;
        }
      }
      uint64_t v28 = &v27[24 * v49];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
    if (!v56) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      unint64_t v31 = v55;
      unsigned int v32 = __p;
      if (v55 != __p)
      {
        do
          unint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unsigned int v32 = __p;
      }
      uint64_t v55 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v52;
    if (!v52) {
      goto LABEL_43;
    }
    uint64_t v33 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "allow_negative_indices", 0x16uLL);
  if (!v8) {
    return 1;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    int v44 = 3;
    uint64_t v46 = 67;
    uint64_t v10 = &v44;
    unint64_t v11 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        int64_t v41 = (char *)&v44 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        unint64_t v11 = (char *)v48;
        uint64_t v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v10 = &v44;
        unint64_t v11 = (char *)v48;
      }
    }
    uint64_t v12 = &v11[24 * v49];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v49;
    if (v47[0])
    {
      uint64_t v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      uint64_t v15 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v42 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v15 = (char *)v48;
          uint64_t v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v14 = &v44;
          uint64_t v15 = (char *)v48;
        }
      }
      uint64_t v16 = &v15[24 * v49];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)uint64_t v16 = v17;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
  }
  if (!v56) {
    return 0;
  }
  unsigned int v18 = __p;
  if (__p)
  {
    unint64_t v19 = v55;
    uint64_t v20 = __p;
    if (v55 != __p)
    {
      do
        unint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      uint64_t v20 = __p;
    }
    uint64_t v55 = v18;
    operator delete(v20);
  }
  uint64_t v21 = v52;
  if (v52)
  {
    uint64_t v22 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v25 = *--v22;
      uint64_t v24 = v25;
      void *v22 = 0;
      if (v25) {
        MEMORY[0x21667D390](v24, 0x1000C8077774924);
      }
    }
    while (v22 != v21);
LABEL_41:
    uint64_t v23 = v52;
LABEL_42:
    uint64_t v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51) {
    free(v48);
  }
  return 0;
}

uint64_t mlir::mps::GatherAlongAxisOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x263EF8340];
  uint64_t v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"allow_negative_indices", 22, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  uint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::GatherAlongAxisOp::verifyInvariantsImpl(mlir::mps::GatherAlongAxisOp *this)
{
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(void *)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  uint64_t v7 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v3, (void **)"allow_negative_indices", (const char *)0x16, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*(void *)this,
                           (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8),
                           (void **)"operand",
                           7,
                           2u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v4 = *(void *)this - 16;
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
}

void mlir::mps::GatherAlongAxisOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::GatherNDOpGenericAdaptorBase::GatherNDOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unsigned int v5 = (_OWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  }
  else {
    unsigned int v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v11, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v11;
  *(_OWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 40) = v8;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.gather_nd", 13, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::GatherNDOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v89 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v75 = v6;
  if (!v6)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      uint64_t v77 = "expected DictionaryAttr to set properties";
      uint64_t v78 = 41;
      uint64_t v26 = &v76;
      unint64_t v27 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v63 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v69 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          unint64_t v27 = (char *)v80;
          uint64_t v26 = (int *)((char *)v80 + v69);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          uint64_t v26 = &v76;
          unint64_t v27 = (char *)v80;
        }
      }
      uint64_t v28 = &v27[24 * v81];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      unint64_t v31 = v87;
      unsigned int v32 = __p;
      if (v87 != __p)
      {
        do
          unint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unsigned int v32 = __p;
      }
      unint64_t v87 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    uint64_t v33 = v85;
    uint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_79;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_78;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v75, "allow_negative_indices", 0x16uLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v79, a4);
      if (v79[0])
      {
        int v76 = 3;
        uint64_t v78 = 67;
        uint64_t v10 = &v76;
        unint64_t v11 = (char *)v80;
        if (v81 >= v82)
        {
          unint64_t v64 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            int64_t v70 = (char *)&v76 - (unsigned char *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            unint64_t v11 = (char *)v80;
            uint64_t v10 = (int *)((char *)v80 + v70);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            uint64_t v10 = &v76;
            unint64_t v11 = (char *)v80;
          }
        }
        uint64_t v12 = &v11[24 * v81];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = *((void *)v10 + 2);
        *(_OWORD *)uint64_t v12 = v13;
        ++v81;
        if (v79[0])
        {
          uint64_t v14 = &v76;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v9);
          uint64_t v15 = (char *)v80;
          if (v81 >= v82)
          {
            unint64_t v65 = v81 + 1;
            if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
            {
              int64_t v71 = (char *)&v76 - (unsigned char *)v80;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              uint64_t v15 = (char *)v80;
              uint64_t v14 = (int *)((char *)v80 + v71);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              uint64_t v14 = &v76;
              uint64_t v15 = (char *)v80;
            }
          }
          uint64_t v16 = &v15[24 * v81];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = *((void *)v14 + 2);
          *(_OWORD *)uint64_t v16 = v17;
          ++v81;
          if (v79[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
          }
        }
      }
      if (!v88) {
        return 0;
      }
      unsigned int v18 = __p;
      if (__p)
      {
        unint64_t v19 = v87;
        uint64_t v20 = __p;
        if (v87 != __p)
        {
          do
            unint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          uint64_t v20 = __p;
        }
        unint64_t v87 = v18;
        operator delete(v20);
      }
      uint64_t v21 = v84;
      if (!v84) {
        goto LABEL_80;
      }
      uint64_t v22 = v85;
      uint64_t v23 = v84;
      if (v85 == v84) {
        goto LABEL_79;
      }
      do
      {
        uint64_t v25 = *--v22;
        uint64_t v24 = v25;
        void *v22 = 0;
        if (v25) {
          MEMORY[0x21667D390](v24, 0x1000C8077774924);
        }
      }
      while (v22 != v21);
      goto LABEL_78;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v75, "batch_dims", 0xAuLL);
  if (!v36)
  {
    a3(v79, a4);
    if (v79[0])
    {
      int v76 = 3;
      uint64_t v77 = "expected key entry for batch_dims in DictionaryAttr to set Properties.";
      uint64_t v78 = 70;
      uint64_t v52 = &v76;
      uint64_t v53 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v67 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v73 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          uint64_t v53 = (char *)v80;
          uint64_t v52 = (int *)((char *)v80 + v73);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          uint64_t v52 = &v76;
          uint64_t v53 = (char *)v80;
        }
      }
      int v54 = &v53[24 * v81];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = *((void *)v52 + 2);
      *(_OWORD *)int v54 = v55;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    char v56 = __p;
    if (__p)
    {
      uint64_t v57 = v87;
      unint64_t v58 = __p;
      if (v87 != __p)
      {
        do
          uint64_t v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        unint64_t v58 = __p;
      }
      unint64_t v87 = v56;
      operator delete(v58);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    uint64_t v59 = v85;
    uint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_79;
    }
    do
    {
      uint64_t v61 = *--v59;
      uint64_t v60 = v61;
      *uint64_t v59 = 0;
      if (v61) {
        MEMORY[0x21667D390](v60, 0x1000C8077774924);
      }
    }
    while (v59 != v21);
    goto LABEL_78;
  }
  uint64_t v37 = v36;
  if (*(_UNKNOWN **)(*(void *)v36 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    a1[1] = v36;
    return 1;
  }
  a3(v79, a4);
  if (v79[0])
  {
    int v76 = 3;
    uint64_t v78 = 55;
    unint64_t v38 = &v76;
    unint64_t v39 = (char *)v80;
    if (v81 >= v82)
    {
      unint64_t v66 = v81 + 1;
      if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
      {
        int64_t v72 = (char *)&v76 - (unsigned char *)v80;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        unint64_t v39 = (char *)v80;
        unint64_t v38 = (int *)((char *)v80 + v72);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        unint64_t v38 = &v76;
        unint64_t v39 = (char *)v80;
      }
    }
    int64_t v40 = &v39[24 * v81];
    long long v41 = *(_OWORD *)v38;
    *((void *)v40 + 2) = *((void *)v38 + 2);
    *(_OWORD *)int64_t v40 = v41;
    ++v81;
    if (v79[0])
    {
      int64_t v42 = &v76;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v37);
      uint64_t v43 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v68 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v74 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          uint64_t v43 = (char *)v80;
          int64_t v42 = (int *)((char *)v80 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          int64_t v42 = &v76;
          uint64_t v43 = (char *)v80;
        }
      }
      int v44 = &v43[24 * v81];
      long long v45 = *(_OWORD *)v42;
      *((void *)v44 + 2) = *((void *)v42 + 2);
      *(_OWORD *)int v44 = v45;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
  }
  if (v88)
  {
    uint64_t v46 = __p;
    if (__p)
    {
      unint64_t v47 = v87;
      unsigned int v48 = __p;
      if (v87 != __p)
      {
        do
          unint64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        unsigned int v48 = __p;
      }
      unint64_t v87 = v46;
      operator delete(v48);
    }
    uint64_t v21 = v84;
    if (!v84) {
      goto LABEL_80;
    }
    unsigned int v49 = v85;
    uint64_t v23 = v84;
    if (v85 == v84)
    {
LABEL_79:
      unint64_t v85 = v21;
      operator delete(v23);
LABEL_80:
      if (v80 != v83) {
        free(v80);
      }
      return 0;
    }
    do
    {
      uint64_t v51 = *--v49;
      uint64_t v50 = v51;
      *unsigned int v49 = 0;
      if (v51) {
        MEMORY[0x21667D390](v50, 0x1000C8077774924);
      }
    }
    while (v49 != v21);
LABEL_78:
    uint64_t v23 = v84;
    goto LABEL_79;
  }
  return 0;
}

uint64_t mlir::mps::GatherNDOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v21[6] = *MEMORY[0x263EF8340];
  unsigned int v18 = a1;
  unint64_t v19 = v21;
  uint64_t v20 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"allow_negative_indices", 22, *a2);
    uint64_t v5 = v4;
    unsigned int v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      unsigned int v6 = v20;
    }
    uint64_t v7 = (uint64_t *)((char *)v19 + 16 * v6);
    uint64_t *v7 = NamedAttr;
    v7[1] = v5;
    unsigned int v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    uint64_t v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      uint64_t v10 = (uint64_t *)v19;
      if (v8) {
        goto LABEL_6;
      }
LABEL_13:
      uint64_t DictionaryAttr = 0;
      if (v10 == v21) {
        return DictionaryAttr;
      }
      goto LABEL_7;
    }
  }
  else
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_5;
    }
  }
  uint64_t v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"batch_dims", 10, v9);
  uint64_t v15 = v14;
  unsigned int v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    unsigned int v16 = v20;
  }
  long long v17 = (uint64_t *)((char *)v19 + 16 * v16);
  uint64_t *v17 = v13;
  v17[1] = v15;
  unsigned int v8 = v20 + 1;
  LODWORD(v20) = v8;
  uint64_t v10 = (uint64_t *)v19;
  if (!v8) {
    goto LABEL_13;
  }
LABEL_6:
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  uint64_t v10 = (uint64_t *)v19;
  if (v19 != v21) {
LABEL_7:
  }
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::GatherNDOp::verifyInvariantsImpl(mlir::mps::GatherNDOp *this)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = (void **)v3[1];
  if (v4)
  {
    uint64_t v5 = *v3;
    v20[0] = v2;
    if (mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v4, (void **)"batch_dims", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20)&& (v20[0] = *(void *)this, mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (void **)"allow_negative_indices", (const char *)0x16, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20))&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(
                            *(void *)this,
                            *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8,
                            (void **)"operand",
                            (void **)7,
                            1u))
    {
      if (*(_DWORD *)(*(void *)this + 36)) {
        uint64_t v6 = *(void *)this - 16;
      }
      else {
        uint64_t v6 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    unsigned int v18 = (void **)"requires attribute 'batch_dims'";
    __int16 v19 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, &v18, (uint64_t)v20);
    uint64_t v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v20);
    if (v20[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v20);
    }
    if (v27)
    {
      uint64_t v9 = __p;
      if (__p)
      {
        uint64_t v10 = v26;
        unint64_t v11 = __p;
        if (v26 != __p)
        {
          do
            uint64_t v10 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v10 - 1);
          while (v10 != v9);
          unint64_t v11 = __p;
        }
        uint64_t v26 = v9;
        operator delete(v11);
      }
      uint64_t v12 = v23;
      if (v23)
      {
        uint64_t v13 = v24;
        uint64_t v14 = v23;
        if (v24 != v23)
        {
          do
          {
            uint64_t v16 = *--v13;
            uint64_t v15 = v16;
            *uint64_t v13 = 0;
            if (v16) {
              MEMORY[0x21667D390](v15, 0x1000C8077774924);
            }
          }
          while (v13 != v12);
          uint64_t v14 = v23;
        }
        uint64_t v24 = v12;
        operator delete(v14);
      }
      if (v21 != &v22) {
        free(v21);
      }
    }
  }
  return v8;
}

void mlir::mps::GatherNDOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::GatherOpGenericAdaptorBase::GatherOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (_OWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v11, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v11;
  *(_OWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 40) = v8;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.gather", 10, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::GatherOp::verifyInvariantsImpl(mlir::mps::GatherOp *this)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    uint64_t v3 = 0;
  }
  unint64_t v4 = (void **)v3[1];
  if (v4)
  {
    uint64_t v5 = *v3;
    v20[0] = v2;
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v4, (void **)"batch_dims", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20))return 0; {
    v20[0] = *(void *)this;
    }
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (void **)"allow_negative_indices", (const char *)0x16, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0))
    {
      return 0;
    }
    if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u))return 0; {
    if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 2u))
    }
    {
      if (*(_DWORD *)(*(void *)this + 36)) {
        uint64_t v6 = *(void *)this - 16;
      }
      else {
        uint64_t v6 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    unsigned int v18 = (void **)"requires attribute 'batch_dims'";
    __int16 v19 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, &v18, (uint64_t)v20);
    uint64_t v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v20);
    if (v20[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v20);
    }
    if (v27)
    {
      uint64_t v9 = __p;
      if (__p)
      {
        uint64_t v10 = v26;
        unint64_t v11 = __p;
        if (v26 != __p)
        {
          do
            uint64_t v10 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v10 - 1);
          while (v10 != v9);
          unint64_t v11 = __p;
        }
        uint64_t v26 = v9;
        operator delete(v11);
      }
      uint64_t v12 = v23;
      if (v23)
      {
        uint64_t v13 = v24;
        uint64_t v14 = v23;
        if (v24 != v23)
        {
          do
          {
            uint64_t v16 = *--v13;
            uint64_t v15 = v16;
            *uint64_t v13 = 0;
            if (v16) {
              MEMORY[0x21667D390](v15, 0x1000C8077774924);
            }
          }
          while (v13 != v12);
          uint64_t v14 = v23;
        }
        uint64_t v24 = v12;
        operator delete(v14);
      }
      if (v21 != &v22) {
        free(v21);
      }
    }
  }
  return v8;
}

void mlir::mps::GatherOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::GeluOpGenericAdaptorBase::GeluOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.gelu", 8, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::GeluOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::GetCoordOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      int v44 = 3;
      long long v45 = "expected DictionaryAttr to set properties";
      uint64_t v46 = 41;
      uint64_t v26 = &v44;
      char v27 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v40 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          char v27 = (char *)v48;
          uint64_t v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          uint64_t v26 = &v44;
          char v27 = (char *)v48;
        }
      }
      uint64_t v28 = &v27[24 * v49];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
    if (!v56) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      unint64_t v31 = v55;
      unsigned int v32 = __p;
      if (v55 != __p)
      {
        do
          unint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unsigned int v32 = __p;
      }
      long long v55 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v52;
    if (!v52) {
      goto LABEL_43;
    }
    uint64_t v33 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "result_type", 0xBuLL);
  if (!v8) {
    return 1;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    int v44 = 3;
    uint64_t v46 = 56;
    uint64_t v10 = &v44;
    uint64_t v11 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        int64_t v41 = (char *)&v44 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v11 = (char *)v48;
        uint64_t v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v10 = &v44;
        uint64_t v11 = (char *)v48;
      }
    }
    uint64_t v12 = &v11[24 * v49];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v49;
    if (v47[0])
    {
      uint64_t v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      uint64_t v15 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v42 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v15 = (char *)v48;
          uint64_t v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v14 = &v44;
          uint64_t v15 = (char *)v48;
        }
      }
      uint64_t v16 = &v15[24 * v49];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)uint64_t v16 = v17;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
  }
  if (!v56) {
    return 0;
  }
  unsigned int v18 = __p;
  if (__p)
  {
    __int16 v19 = v55;
    uint64_t v20 = __p;
    if (v55 != __p)
    {
      do
        __int16 v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      uint64_t v20 = __p;
    }
    long long v55 = v18;
    operator delete(v20);
  }
  uint64_t v21 = v52;
  if (v52)
  {
    uint64_t v22 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v25 = *--v22;
      uint64_t v24 = v25;
      void *v22 = 0;
      if (v25) {
        MEMORY[0x21667D390](v24, 0x1000C8077774924);
      }
    }
    while (v22 != v21);
LABEL_41:
    uint64_t v23 = v52;
LABEL_42:
    uint64_t v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51) {
    free(v48);
  }
  return 0;
}

uint64_t mlir::mps::GetCoordOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x263EF8340];
  uint64_t v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"result_type", 11, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  uint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

BOOL mlir::mps::GetCoordOp::verifyInvariantsImpl(mlir::mps::GetCoordOp *this)
{
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(void *)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  uint64_t v7 = v2;
  if (!mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v3, (void **)"result_type", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps4(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v4 = *(void *)this - 16;
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps24(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
}

void mlir::mps::GetCoordOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::GreaterThanOpGenericAdaptorBase::GreaterThanOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.greater", 11, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::GreaterThanOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::GreaterThanOrEqualToOpGenericAdaptorBase::GreaterThanOrEqualToOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.greater_equal", 17, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::GreaterThanOrEqualToOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::HammingDistanceOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::HammingDistanceOp::verifyInvariantsImpl(mlir::mps::HammingDistanceOp *this)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(void *)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  if (v3)
  {
    v18[0] = v2;
    if (mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v3, (void **)"resultElementType", (const char *)0x11, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps4(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v18)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps27(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps27(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u))
    {
      if (*(_DWORD *)(*(void *)this + 36)) {
        uint64_t v4 = *(void *)this - 16;
      }
      else {
        uint64_t v4 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v16 = (void **)"requires attribute 'resultElementType'";
    __int16 v17 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, &v16, (uint64_t)v18);
    uint64_t v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v18);
    if (v18[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
    }
    if (v25)
    {
      uint64_t v7 = __p;
      if (__p)
      {
        BOOL v8 = v24;
        uint64_t v9 = __p;
        if (v24 != __p)
        {
          do
            BOOL v8 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v8 - 1);
          while (v8 != v7);
          uint64_t v9 = __p;
        }
        uint64_t v24 = v7;
        operator delete(v9);
      }
      uint64_t v10 = v21;
      if (v21)
      {
        uint64_t v11 = v22;
        uint64_t v12 = v21;
        if (v22 != v21)
        {
          do
          {
            uint64_t v14 = *--v11;
            uint64_t v13 = v14;
            void *v11 = 0;
            if (v14) {
              MEMORY[0x21667D390](v13, 0x1000C8077774924);
            }
          }
          while (v11 != v10);
          uint64_t v12 = v21;
        }
        uint64_t v22 = v10;
        operator delete(v12);
      }
      if (v19 != &v20) {
        free(v19);
      }
    }
  }
  return v6;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps27(uint64_t a1, uint64_t a2, void **a3, void **a4, unsigned int a5)
{
  uint64_t v66 = *MEMORY[0x263EF8340];
  uint64_t v10 = *(void *)a2;
  uint64_t v11 = *(void **)(*(void *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)v51, 32)) {
      return 1;
    }
  }
  __int16 v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    int v53 = 3;
    int v54 = " #";
    uint64_t v55 = 2;
    uint64_t v14 = &v53;
    uint64_t v15 = (char *)v57;
    if (v58 >= v59)
    {
      unint64_t v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        int64_t v47 = (char *)&v53 - (unsigned char *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        uint64_t v15 = (char *)v57;
        uint64_t v14 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        uint64_t v14 = &v53;
        uint64_t v15 = (char *)v57;
      }
    }
    uint64_t v16 = &v15[24 * v58];
    long long v17 = *(_OWORD *)v14;
    *((void *)v16 + 2) = *((void *)v14 + 2);
    *(_OWORD *)uint64_t v16 = v17;
    uint64_t v18 = ++v58;
    if (v56[0])
    {
      int v53 = 5;
      int v54 = (const char *)a5;
      __int16 v19 = &v53;
      uint64_t v20 = (char *)v57;
      if (v18 >= v59)
      {
        unint64_t v42 = v18 + 1;
        BOOL v43 = (char *)v57 + 24 * v18 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          int64_t v48 = (char *)&v53 - (unsigned char *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          uint64_t v20 = (char *)v57;
          __int16 v19 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          __int16 v19 = &v53;
          uint64_t v20 = (char *)v57;
        }
      }
      uint64_t v21 = &v20[24 * v58];
      long long v22 = *(_OWORD *)v19;
      *((void *)v21 + 2) = *((void *)v19 + 2);
      *(_OWORD *)uint64_t v21 = v22;
      uint64_t v23 = ++v58;
      if (v56[0])
      {
        int v53 = 3;
        int v54 = " must be tensor of 32-bit unsigned integer values, but got ";
        uint64_t v55 = 59;
        uint64_t v24 = &v53;
        char v25 = (char *)v57;
        if (v23 >= v59)
        {
          unint64_t v44 = v23 + 1;
          BOOL v45 = (char *)v57 + 24 * v23 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            int64_t v49 = (char *)&v53 - (unsigned char *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            char v25 = (char *)v57;
            uint64_t v24 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            uint64_t v24 = &v53;
            char v25 = (char *)v57;
          }
        }
        uint64_t v26 = &v25[24 * v58];
        long long v27 = *(_OWORD *)v24;
        *((void *)v26 + 2) = *((void *)v24 + 2);
        *(_OWORD *)uint64_t v26 = v27;
        ++v58;
        if (v56[0])
        {
          uint64_t v28 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          long long v29 = (char *)v57;
          if (v58 >= v59)
          {
            unint64_t v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              int64_t v50 = (char *)&v53 - (unsigned char *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              long long v29 = (char *)v57;
              uint64_t v28 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              uint64_t v28 = &v53;
              long long v29 = (char *)v57;
            }
          }
          uint64_t v30 = &v29[24 * v58];
          long long v31 = *(_OWORD *)v28;
          *((void *)v30 + 2) = *((void *)v28 + 2);
          *(_OWORD *)uint64_t v30 = v31;
          ++v58;
        }
      }
    }
  }
  uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  }
  if (v65)
  {
    unsigned int v32 = __p;
    if (__p)
    {
      uint64_t v33 = v64;
      uint64_t v34 = __p;
      if (v64 != __p)
      {
        do
          uint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        uint64_t v34 = __p;
      }
      unint64_t v64 = v32;
      operator delete(v34);
    }
    uint64_t v35 = v61;
    if (v61)
    {
      uint64_t v36 = v62;
      unint64_t v37 = v61;
      if (v62 != v61)
      {
        do
        {
          uint64_t v39 = *--v36;
          uint64_t v38 = v39;
          void *v36 = 0;
          if (v39) {
            MEMORY[0x21667D390](v38, 0x1000C8077774924);
          }
        }
        while (v36 != v35);
        unint64_t v37 = v61;
      }
      unint64_t v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60) {
      free(v57);
    }
  }
  return v13;
}

void mlir::mps::HammingDistanceOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::HermiteanToRealFFTOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v109 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v95 = v6;
  if (!v6)
  {
    a3(v99, a4);
    if (v99[0])
    {
      int v96 = 3;
      unint64_t v97 = "expected DictionaryAttr to set properties";
      uint64_t v98 = 41;
      uint64_t v26 = &v96;
      long long v27 = (char *)v100;
      if (v101 >= v102)
      {
        unint64_t v79 = v101 + 1;
        if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
        {
          int64_t v87 = (char *)&v96 - (unsigned char *)v100;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v79, 24);
          long long v27 = (char *)v100;
          uint64_t v26 = (int *)((char *)v100 + v87);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v79, 24);
          uint64_t v26 = &v96;
          long long v27 = (char *)v100;
        }
      }
      uint64_t v28 = &v27[24 * v101];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v101;
      if (v99[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v99);
      }
    }
    if (!v108) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      long long v31 = v107;
      unsigned int v32 = __p;
      if (v107 != __p)
      {
        do
          long long v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unsigned int v32 = __p;
      }
      unint64_t v107 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v104;
    if (!v104) {
      goto LABEL_101;
    }
    uint64_t v33 = v105;
    uint64_t v23 = v104;
    if (v105 == v104) {
      goto LABEL_100;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_99;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v95, "inverse", 7uLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v99, a4);
      if (v99[0])
      {
        int v96 = 3;
        uint64_t v98 = 52;
        uint64_t v10 = &v96;
        uint64_t v11 = (char *)v100;
        if (v101 >= v102)
        {
          unint64_t v80 = v101 + 1;
          if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
          {
            int64_t v88 = (char *)&v96 - (unsigned char *)v100;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v80, 24);
            uint64_t v11 = (char *)v100;
            uint64_t v10 = (int *)((char *)v100 + v88);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v80, 24);
            uint64_t v10 = &v96;
            uint64_t v11 = (char *)v100;
          }
        }
        uint64_t v12 = &v11[24 * v101];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = *((void *)v10 + 2);
        *(_OWORD *)uint64_t v12 = v13;
        ++v101;
        if (v99[0])
        {
          uint64_t v14 = &v96;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v96, v9);
          uint64_t v15 = (char *)v100;
          if (v101 >= v102)
          {
            unint64_t v81 = v101 + 1;
            if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
            {
              int64_t v89 = (char *)&v96 - (unsigned char *)v100;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v81, 24);
              uint64_t v15 = (char *)v100;
              uint64_t v14 = (int *)((char *)v100 + v89);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v81, 24);
              uint64_t v14 = &v96;
              uint64_t v15 = (char *)v100;
            }
          }
          uint64_t v16 = &v15[24 * v101];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = *((void *)v14 + 2);
          *(_OWORD *)uint64_t v16 = v17;
          ++v101;
          if (v99[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v99);
          }
        }
      }
      if (!v108) {
        return 0;
      }
      uint64_t v18 = __p;
      if (__p)
      {
        __int16 v19 = v107;
        uint64_t v20 = __p;
        if (v107 != __p)
        {
          do
            __int16 v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          uint64_t v20 = __p;
        }
        unint64_t v107 = v18;
        operator delete(v20);
      }
      uint64_t v21 = v104;
      if (!v104) {
        goto LABEL_101;
      }
      long long v22 = v105;
      uint64_t v23 = v104;
      if (v105 == v104) {
        goto LABEL_100;
      }
      do
      {
        uint64_t v25 = *--v22;
        uint64_t v24 = v25;
        void *v22 = 0;
        if (v25) {
          MEMORY[0x21667D390](v24, 0x1000C8077774924);
        }
      }
      while (v22 != v21);
      goto LABEL_99;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v95, "round_to_odd", 0xCuLL);
  if (v36)
  {
    uint64_t v37 = v36;
    if (*(_UNKNOWN **)(*(void *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v99, a4);
      if (v99[0])
      {
        int v96 = 3;
        uint64_t v98 = 57;
        uint64_t v38 = &v96;
        uint64_t v39 = (char *)v100;
        if (v101 >= v102)
        {
          unint64_t v82 = v101 + 1;
          if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
          {
            int64_t v90 = (char *)&v96 - (unsigned char *)v100;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v82, 24);
            uint64_t v39 = (char *)v100;
            uint64_t v38 = (int *)((char *)v100 + v90);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v82, 24);
            uint64_t v38 = &v96;
            uint64_t v39 = (char *)v100;
          }
        }
        int64_t v40 = &v39[24 * v101];
        long long v41 = *(_OWORD *)v38;
        *((void *)v40 + 2) = *((void *)v38 + 2);
        *(_OWORD *)int64_t v40 = v41;
        ++v101;
        if (v99[0])
        {
          unint64_t v42 = &v96;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v96, v37);
          BOOL v43 = (char *)v100;
          if (v101 >= v102)
          {
            unint64_t v83 = v101 + 1;
            if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
            {
              int64_t v91 = (char *)&v96 - (unsigned char *)v100;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v83, 24);
              BOOL v43 = (char *)v100;
              unint64_t v42 = (int *)((char *)v100 + v91);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v83, 24);
              unint64_t v42 = &v96;
              BOOL v43 = (char *)v100;
            }
          }
          unint64_t v44 = &v43[24 * v101];
          long long v45 = *(_OWORD *)v42;
          *((void *)v44 + 2) = *((void *)v42 + 2);
          *(_OWORD *)unint64_t v44 = v45;
          ++v101;
          if (v99[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v99);
          }
        }
      }
      if (!v108) {
        return 0;
      }
      unint64_t v46 = __p;
      if (__p)
      {
        int64_t v47 = v107;
        int64_t v48 = __p;
        if (v107 != __p)
        {
          do
            int64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          int64_t v48 = __p;
        }
        unint64_t v107 = v46;
        operator delete(v48);
      }
      uint64_t v21 = v104;
      if (!v104) {
        goto LABEL_101;
      }
      int64_t v49 = v105;
      uint64_t v23 = v104;
      if (v105 == v104) {
        goto LABEL_100;
      }
      do
      {
        uint64_t v51 = *--v49;
        uint64_t v50 = v51;
        *int64_t v49 = 0;
        if (v51) {
          MEMORY[0x21667D390](v50, 0x1000C8077774924);
        }
      }
      while (v49 != v21);
      goto LABEL_99;
    }
    a1[1] = v36;
  }
  uint64_t v52 = mlir::DictionaryAttr::get((uint64_t)&v95, "scaling_mode", 0xCuLL);
  if (!v52)
  {
    a3(v99, a4);
    if (v99[0])
    {
      int v96 = 3;
      unint64_t v97 = "expected key entry for scaling_mode in DictionaryAttr to set Properties.";
      uint64_t v98 = 72;
      unint64_t v68 = &v96;
      int64_t v69 = (char *)v100;
      if (v101 >= v102)
      {
        unint64_t v85 = v101 + 1;
        if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
        {
          int64_t v93 = (char *)&v96 - (unsigned char *)v100;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v85, 24);
          int64_t v69 = (char *)v100;
          unint64_t v68 = (int *)((char *)v100 + v93);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v85, 24);
          unint64_t v68 = &v96;
          int64_t v69 = (char *)v100;
        }
      }
      int64_t v70 = &v69[24 * v101];
      long long v71 = *(_OWORD *)v68;
      *((void *)v70 + 2) = *((void *)v68 + 2);
      *(_OWORD *)int64_t v70 = v71;
      ++v101;
      if (v99[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v99);
      }
    }
    if (!v108) {
      return 0;
    }
    int64_t v72 = __p;
    if (__p)
    {
      int64_t v73 = v107;
      int64_t v74 = __p;
      if (v107 != __p)
      {
        do
          int64_t v73 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v73 - 1);
        while (v73 != v72);
        int64_t v74 = __p;
      }
      unint64_t v107 = v72;
      operator delete(v74);
    }
    uint64_t v21 = v104;
    if (!v104) {
      goto LABEL_101;
    }
    uint64_t v75 = v105;
    uint64_t v23 = v104;
    if (v105 == v104) {
      goto LABEL_100;
    }
    do
    {
      uint64_t v77 = *--v75;
      uint64_t v76 = v77;
      *uint64_t v75 = 0;
      if (v77) {
        MEMORY[0x21667D390](v76, 0x1000C8077774924);
      }
    }
    while (v75 != v21);
    goto LABEL_99;
  }
  uint64_t v53 = v52;
  if (*(_UNKNOWN **)(*(void *)v52 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id)
  {
    a1[2] = v52;
    return 1;
  }
  a3(v99, a4);
  if (v99[0])
  {
    int v96 = 3;
    uint64_t v98 = 57;
    int v54 = &v96;
    uint64_t v55 = (char *)v100;
    if (v101 >= v102)
    {
      unint64_t v84 = v101 + 1;
      if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
      {
        int64_t v92 = (char *)&v96 - (unsigned char *)v100;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v84, 24);
        uint64_t v55 = (char *)v100;
        int v54 = (int *)((char *)v100 + v92);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v84, 24);
        int v54 = &v96;
        uint64_t v55 = (char *)v100;
      }
    }
    char v56 = &v55[24 * v101];
    long long v57 = *(_OWORD *)v54;
    *((void *)v56 + 2) = *((void *)v54 + 2);
    *(_OWORD *)char v56 = v57;
    ++v101;
    if (v99[0])
    {
      unsigned int v58 = &v96;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v96, v53);
      unsigned int v59 = (char *)v100;
      if (v101 >= v102)
      {
        unint64_t v86 = v101 + 1;
        if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
        {
          int64_t v94 = (char *)&v96 - (unsigned char *)v100;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v86, 24);
          unsigned int v59 = (char *)v100;
          unsigned int v58 = (int *)((char *)v100 + v94);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v86, 24);
          unsigned int v58 = &v96;
          unsigned int v59 = (char *)v100;
        }
      }
      uint64_t v60 = &v59[24 * v101];
      long long v61 = *(_OWORD *)v58;
      *((void *)v60 + 2) = *((void *)v58 + 2);
      *(_OWORD *)uint64_t v60 = v61;
      ++v101;
      if (v99[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v99);
      }
    }
  }
  if (v108)
  {
    unint64_t v62 = __p;
    if (__p)
    {
      unint64_t v63 = v107;
      unint64_t v64 = __p;
      if (v107 != __p)
      {
        do
          unint64_t v63 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v63 - 1);
        while (v63 != v62);
        unint64_t v64 = __p;
      }
      unint64_t v107 = v62;
      operator delete(v64);
    }
    uint64_t v21 = v104;
    if (!v104) {
      goto LABEL_101;
    }
    char v65 = v105;
    uint64_t v23 = v104;
    if (v105 == v104)
    {
LABEL_100:
      unint64_t v105 = v21;
      operator delete(v23);
LABEL_101:
      if (v100 != v103) {
        free(v100);
      }
      return 0;
    }
    do
    {
      uint64_t v67 = *--v65;
      uint64_t v66 = v67;
      *char v65 = 0;
      if (v67) {
        MEMORY[0x21667D390](v66, 0x1000C8077774924);
      }
    }
    while (v65 != v21);
LABEL_99:
    uint64_t v23 = v104;
    goto LABEL_100;
  }
  return 0;
}

uint64_t mlir::mps::HermiteanToRealFFTOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v27[6] = *MEMORY[0x263EF8340];
  uint64_t v24 = a1;
  uint64_t v25 = v27;
  uint64_t v26 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v24, (uint64_t)"inverse", 7, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v26;
  if (v26 >= HIDWORD(v26))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
    unsigned int v6 = v26;
  }
  uint64_t v7 = (uint64_t *)((char *)v25 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v26 + 1;
  LODWORD(v26) = v26 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v24, (uint64_t)"round_to_odd", 12, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v26;
    if (v26 >= HIDWORD(v26))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
      unsigned int v13 = v26;
    }
    uint64_t v14 = (uint64_t *)((char *)v25 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v26 + 1;
    LODWORD(v26) = v26 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v24, (uint64_t)"scaling_mode", 12, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v26;
    if (v26 >= HIDWORD(v26))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
      unsigned int v19 = v26;
    }
    uint64_t v20 = (uint64_t *)((char *)v25 + 16 * v19);
    uint64_t *v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v26 + 1;
    LODWORD(v26) = v26 + 1;
  }
  uint64_t v21 = v25;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v25 == v27) {
      return DictionaryAttr;
    }
    goto LABEL_16;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v24, (uint64_t *)v25, v8);
  uint64_t v21 = v25;
  if (v25 != v27) {
LABEL_16:
  }
    free(v21);
  return DictionaryAttr;
}

uint64_t mlir::mps::HermiteanToRealFFTOp::setInherentAttr(uint64_t result, char *__s1, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = result;
  if (a3 == 12)
  {
    uint64_t result = memcmp(__s1, "round_to_odd", 0xCuLL);
    if (result)
    {
      if (*(void *)__s1 == 0x5F676E696C616373 && *((_DWORD *)__s1 + 2) == 1701080941)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          *(void *)(v6 + 16) = v9;
        }
        else
        {
          *(void *)(v6 + 16) = 0;
        }
      }
    }
    else if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
        uint64_t v11 = a4;
      }
      else {
        uint64_t v11 = 0;
      }
      *(void *)(v6 + 8) = v11;
    }
    else
    {
      *(void *)(v6 + 8) = 0;
    }
  }
  else if (a3 == 7 && *(_DWORD *)__s1 == 1702260329 && *(_DWORD *)(__s1 + 3) == 1702064741)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
        uint64_t v10 = a4;
      }
      else {
        uint64_t v10 = 0;
      }
      *(void *)uint64_t result = v10;
    }
    else
    {
      *(void *)uint64_t result = 0;
    }
  }
  return result;
}

BOOL mlir::mps::HermiteanToRealFFTOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v8, (void **)"inverse", (const char *)7, a3, a4))
  {
    uint64_t v9 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v9, (void **)"round_to_odd", (const char *)0xC, a3, a4))
    {
      uint64_t v10 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps27(v10, (void **)"scaling_mode", (const char *)0xC, a3, a4))
      {
        return 1;
      }
    }
  }
  return result;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::HermiteanToRealFFTOp::verifyInvariantsImpl(mlir::mps::HermiteanToRealFFTOp *this)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = v3[2];
  if (v4)
  {
    uint64_t v6 = *v3;
    uint64_t v5 = v3[1];
    v21[0] = v2;
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps27(v4, (void **)"scaling_mode", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps27(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v21))return 0; {
    v21[0] = *(void *)this;
    }
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v6, (void **)"inverse", (const char *)7, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v21))return 0; {
    v21[0] = *(void *)this;
    }
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (void **)"round_to_odd", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v21))return 0; {
    if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps19(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0))return 0;
    }
    if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 1u))
    {
      if (*(_DWORD *)(*(void *)this + 36)) {
        uint64_t v7 = *(void *)this - 16;
      }
      else {
        uint64_t v7 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    unsigned int v19 = (void **)"requires attribute 'scaling_mode'";
    __int16 v20 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, &v19, (uint64_t)v21);
    uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v21);
    if (v21[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v21);
    }
    if (v28)
    {
      uint64_t v10 = __p;
      if (__p)
      {
        uint64_t v11 = v27;
        uint64_t v12 = __p;
        if (v27 != __p)
        {
          do
            uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
          while (v11 != v10);
          uint64_t v12 = __p;
        }
        long long v27 = v10;
        operator delete(v12);
      }
      unsigned int v13 = v24;
      if (v24)
      {
        uint64_t v14 = v25;
        uint64_t v15 = v24;
        if (v25 != v24)
        {
          do
          {
            uint64_t v17 = *--v14;
            uint64_t v16 = v17;
            *uint64_t v14 = 0;
            if (v17) {
              MEMORY[0x21667D390](v16, 0x1000C8077774924);
            }
          }
          while (v14 != v13);
          uint64_t v15 = v24;
        }
        uint64_t v25 = v13;
        operator delete(v15);
      }
      if (v22 != &v23) {
        free(v22);
      }
    }
  }
  return v9;
}

void mlir::mps::HermiteanToRealFFTOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::IdentityOpGenericAdaptorBase::IdentityOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.identity", 12, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::IdentityOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::ImToColOp::getInherentAttr(int a1, void *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xDuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(void *)__s1 != 0x79616C5F61746164 || *(void *)(__s1 + 3) != 0x74756F79616C5F61) {
        return 0;
      }
      return *a2;
    case 0xCuLL:
      if (memcmp(__s1, "kernel_sizes", __n)) {
        return 0;
      }
      return a2[3];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n)) {
        return 0;
      }
      return a2[1];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n)) {
        return 0;
      }
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::ImToColOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, uint64_t a4)
{
  unint64_t v5 = (void *)result;
  switch(a3)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v5[4] = v11;
        }
        else
        {
          v5[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
            uint64_t v7 = a4;
          }
          else {
            uint64_t v7 = 0;
          }
          *(void *)uint64_t result = v7;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xCuLL:
      uint64_t result = memcmp(__s1, "kernel_sizes", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v5[3] = v8;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          v5[1] = v9;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          v5[2] = v10;
        }
        else
        {
          v5[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::ImToColOp::verifyInvariantsImpl(mlir::mps::ImToColOp *this)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v3 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = *(_DWORD **)v3;
  if (*(void *)v3)
  {
    unint64_t v5 = *(void **)(v3 + 8);
    if (v5)
    {
      unint64_t v6 = *(void ***)(v3 + 16);
      if (v6)
      {
        uint64_t v7 = *(void **)(v3 + 24);
        if (v7)
        {
          uint64_t v8 = *(void **)(v3 + 32);
          if (v8)
          {
            v47[0] = v2;
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v7, (void **)"kernel_sizes", (const char *)0xC, (void (*)(void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0; {
            v47[0] = *(void *)this;
            }
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v8, (void **)"strides", (const char *)7, (void (*)(void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0; {
            v47[0] = *(void *)this;
            }
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v5, (void **)"dilation_rates", (const char *)0xE, (void (*)(void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0; {
            v47[0] = *(void *)this;
            }
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0; {
            v47[0] = *(void *)this;
            }
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(v4, (void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps10(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0))
            {
              return 0;
            }
            if (*(_DWORD *)(*(void *)this + 36)) {
              uint64_t v9 = *(void *)this - 16;
            }
            else {
              uint64_t v9 = 0;
            }
            uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v9, 0);
            return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
          }
          v45[0] = (void **)"requires attribute 'strides'";
          __int16 v46 = 259;
          mlir::OpState::emitOpError((uint64_t *)this, v45, (uint64_t)v47);
          uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
          if (v47[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
          }
          if (v54)
          {
            uint64_t v38 = __p;
            if (__p)
            {
              uint64_t v39 = v53;
              int64_t v40 = __p;
              if (v53 != __p)
              {
                do
                  uint64_t v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v39 - 1);
                while (v39 != v38);
                int64_t v40 = __p;
              }
              uint64_t v53 = v38;
              operator delete(v40);
            }
            uint64_t v15 = v50;
            if (!v50) {
              goto LABEL_92;
            }
            long long v41 = v51;
            uint64_t v17 = v50;
            if (v51 == v50)
            {
LABEL_91:
              uint64_t v51 = v15;
              operator delete(v17);
LABEL_92:
              if (v48 != &v49) {
                free(v48);
              }
              return v11;
            }
            do
            {
              uint64_t v43 = *--v41;
              uint64_t v42 = v43;
              *long long v41 = 0;
              if (v43) {
                MEMORY[0x21667D390](v42, 0x1000C8077774924);
              }
            }
            while (v41 != v15);
LABEL_90:
            uint64_t v17 = v50;
            goto LABEL_91;
          }
        }
        else
        {
          v45[0] = (void **)"requires attribute 'kernel_sizes'";
          __int16 v46 = 259;
          mlir::OpState::emitOpError((uint64_t *)this, v45, (uint64_t)v47);
          uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
          if (v47[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
          }
          if (v54)
          {
            unsigned int v32 = __p;
            if (__p)
            {
              uint64_t v33 = v53;
              uint64_t v34 = __p;
              if (v53 != __p)
              {
                do
                  uint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
                while (v33 != v32);
                uint64_t v34 = __p;
              }
              uint64_t v53 = v32;
              operator delete(v34);
            }
            uint64_t v15 = v50;
            if (!v50) {
              goto LABEL_92;
            }
            uint64_t v35 = v51;
            uint64_t v17 = v50;
            if (v51 == v50) {
              goto LABEL_91;
            }
            do
            {
              uint64_t v37 = *--v35;
              uint64_t v36 = v37;
              void *v35 = 0;
              if (v37) {
                MEMORY[0x21667D390](v36, 0x1000C8077774924);
              }
            }
            while (v35 != v15);
            goto LABEL_90;
          }
        }
      }
      else
      {
        v45[0] = (void **)"requires attribute 'explicit_padding'";
        __int16 v46 = 259;
        mlir::OpState::emitOpError((uint64_t *)this, v45, (uint64_t)v47);
        uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
        if (v47[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
        }
        if (v54)
        {
          uint64_t v26 = __p;
          if (__p)
          {
            long long v27 = v53;
            char v28 = __p;
            if (v53 != __p)
            {
              do
                long long v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
              while (v27 != v26);
              char v28 = __p;
            }
            uint64_t v53 = v26;
            operator delete(v28);
          }
          uint64_t v15 = v50;
          if (!v50) {
            goto LABEL_92;
          }
          uint64_t v29 = v51;
          uint64_t v17 = v50;
          if (v51 == v50) {
            goto LABEL_91;
          }
          do
          {
            uint64_t v31 = *--v29;
            uint64_t v30 = v31;
            *uint64_t v29 = 0;
            if (v31) {
              MEMORY[0x21667D390](v30, 0x1000C8077774924);
            }
          }
          while (v29 != v15);
          goto LABEL_90;
        }
      }
    }
    else
    {
      v45[0] = (void **)"requires attribute 'dilation_rates'";
      __int16 v46 = 259;
      mlir::OpState::emitOpError((uint64_t *)this, v45, (uint64_t)v47);
      uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
      if (v54)
      {
        __int16 v20 = __p;
        if (__p)
        {
          uint64_t v21 = v53;
          long long v22 = __p;
          if (v53 != __p)
          {
            do
              uint64_t v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
            while (v21 != v20);
            long long v22 = __p;
          }
          uint64_t v53 = v20;
          operator delete(v22);
        }
        uint64_t v15 = v50;
        if (!v50) {
          goto LABEL_92;
        }
        uint64_t v23 = v51;
        uint64_t v17 = v50;
        if (v51 == v50) {
          goto LABEL_91;
        }
        do
        {
          uint64_t v25 = *--v23;
          uint64_t v24 = v25;
          *uint64_t v23 = 0;
          if (v25) {
            MEMORY[0x21667D390](v24, 0x1000C8077774924);
          }
        }
        while (v23 != v15);
        goto LABEL_90;
      }
    }
  }
  else
  {
    v45[0] = (void **)"requires attribute 'data_layout'";
    __int16 v46 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v45, (uint64_t)v47);
    uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
    if (v47[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
    if (v54)
    {
      uint64_t v12 = __p;
      if (__p)
      {
        unsigned int v13 = v53;
        uint64_t v14 = __p;
        if (v53 != __p)
        {
          do
            unsigned int v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          uint64_t v14 = __p;
        }
        uint64_t v53 = v12;
        operator delete(v14);
      }
      uint64_t v15 = v50;
      if (!v50) {
        goto LABEL_92;
      }
      uint64_t v16 = v51;
      uint64_t v17 = v50;
      if (v51 == v50) {
        goto LABEL_91;
      }
      do
      {
        uint64_t v19 = *--v16;
        uint64_t v18 = v19;
        void *v16 = 0;
        if (v19) {
          MEMORY[0x21667D390](v18, 0x1000C8077774924);
        }
      }
      while (v16 != v15);
      goto LABEL_90;
    }
  }
  return v11;
}

void mlir::mps::ImToColOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::ImaginaryPartOpGenericAdaptorBase::ImaginaryPartOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.imaginary_part", 18, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ImaginaryPartOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::InitRandomPhiloxStateOpGenericAdaptorBase::InitRandomPhiloxStateOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.init_random_philox_state", 28, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::InitRandomPhiloxStateOp::verifyInvariantsImpl(mlir::mps::InitRandomPhiloxStateOp *this)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps28(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps28(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps28(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 2u))
  {
    return 0;
  }
  uint64_t v2 = *(_DWORD *)(*(void *)this + 36) ? *(void *)this - 16 : 0;
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  uint64_t v4 = *(void *)this;
  unint64_t v5 = (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v6 = *v5;
  uint64_t v7 = (void *)*((void *)*v5 + 17);
  if (v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v7 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v58[0] = *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8;
    v58[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v6 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v58);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32))
    {
      uint64_t v9 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v5 + 8);
      uint64_t v51 = v5;
      uint64_t v52 = v9;
      Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v51);
      uint64_t v68 = 7;
      if (v11 == 1 && *Shape == v68) {
        return 1;
      }
    }
  }
  if (*((_UNKNOWN **)*v5 + 17) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    uint64_t v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v5 + 8);
    uint64_t v55 = v5;
    char v56 = (const char *)v12;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v55);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)) {
      return 1;
    }
  }
  __int16 v53 = 261;
  uint64_t v51 = (void **)"result";
  uint64_t v52 = 6;
  mlir::Operation::emitOpError(v4, &v51, (uint64_t)v58);
  if (v58[0])
  {
    LODWORD(v55) = 3;
    char v56 = " #";
    uint64_t v57 = 2;
    unsigned int v13 = &v55;
    uint64_t v14 = (char *)v59;
    if (v60 >= v61)
    {
      unint64_t v41 = v60 + 1;
      if (v59 <= &v55 && (char *)v59 + 24 * v60 > (char *)&v55)
      {
        int64_t v47 = (char *)&v55 - (unsigned char *)v59;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v41, 24);
        uint64_t v14 = (char *)v59;
        unsigned int v13 = (void ***)((char *)v59 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v41, 24);
        unsigned int v13 = &v55;
        uint64_t v14 = (char *)v59;
      }
    }
    uint64_t v15 = &v14[24 * v60];
    long long v16 = *(_OWORD *)v13;
    *((void *)v15 + 2) = v13[2];
    *(_OWORD *)uint64_t v15 = v16;
    uint64_t v17 = ++v60;
    if (v58[0])
    {
      LODWORD(v55) = 5;
      char v56 = 0;
      uint64_t v18 = &v55;
      uint64_t v19 = (char *)v59;
      if (v17 >= v61)
      {
        unint64_t v42 = v17 + 1;
        BOOL v43 = (char *)v59 + 24 * v17 > (char *)&v55;
        if (v59 <= &v55 && v43)
        {
          int64_t v48 = (char *)&v55 - (unsigned char *)v59;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v42, 24);
          uint64_t v19 = (char *)v59;
          uint64_t v18 = (void ***)((char *)v59 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v42, 24);
          uint64_t v18 = &v55;
          uint64_t v19 = (char *)v59;
        }
      }
      __int16 v20 = &v19[24 * v60];
      long long v21 = *(_OWORD *)v18;
      *((void *)v20 + 2) = v18[2];
      *(_OWORD *)__int16 v20 = v21;
      uint64_t v22 = ++v60;
      if (v58[0])
      {
        LODWORD(v55) = 3;
        char v56 = " must be static-shape defined tensor with shape equal to [7] or unranked tensor of 32-bit signed integer values, but got ";
        uint64_t v57 = 121;
        uint64_t v23 = &v55;
        uint64_t v24 = (char *)v59;
        if (v22 >= v61)
        {
          unint64_t v44 = v22 + 1;
          BOOL v45 = (char *)v59 + 24 * v22 > (char *)&v55;
          if (v59 <= &v55 && v45)
          {
            int64_t v49 = (char *)&v55 - (unsigned char *)v59;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v44, 24);
            uint64_t v24 = (char *)v59;
            uint64_t v23 = (void ***)((char *)v59 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v44, 24);
            uint64_t v23 = &v55;
            uint64_t v24 = (char *)v59;
          }
        }
        uint64_t v25 = &v24[24 * v60];
        long long v26 = *(_OWORD *)v23;
        *((void *)v25 + 2) = v23[2];
        *(_OWORD *)uint64_t v25 = v26;
        ++v60;
        if (v58[0])
        {
          long long v27 = &v55;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v55, (uint64_t)v5);
          char v28 = (char *)v59;
          if (v60 >= v61)
          {
            unint64_t v46 = v60 + 1;
            if (v59 <= &v55 && (char *)v59 + 24 * v60 > (char *)&v55)
            {
              int64_t v50 = (char *)&v55 - (unsigned char *)v59;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v46, 24);
              char v28 = (char *)v59;
              long long v27 = (void ***)((char *)v59 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v46, 24);
              long long v27 = &v55;
              char v28 = (char *)v59;
            }
          }
          uint64_t v29 = &v28[24 * v60];
          long long v30 = *(_OWORD *)v27;
          *((void *)v29 + 2) = v27[2];
          *(_OWORD *)uint64_t v29 = v30;
          ++v60;
        }
      }
    }
  }
  char v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v58);
  if (v58[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v58);
  }
  if (v67)
  {
    unsigned int v32 = __p;
    if (__p)
    {
      uint64_t v33 = v66;
      uint64_t v34 = __p;
      if (v66 != __p)
      {
        do
          uint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        uint64_t v34 = __p;
      }
      uint64_t v66 = v32;
      operator delete(v34);
    }
    uint64_t v35 = v63;
    if (v63)
    {
      uint64_t v36 = v64;
      uint64_t v37 = v63;
      if (v64 != v63)
      {
        do
        {
          uint64_t v39 = *--v36;
          uint64_t v38 = v39;
          void *v36 = 0;
          if (v39) {
            MEMORY[0x21667D390](v38, 0x1000C8077774924);
          }
        }
        while (v36 != v35);
        uint64_t v37 = v63;
      }
      unint64_t v64 = v35;
      operator delete(v37);
    }
    if (v59 != v62) {
      free(v59);
    }
  }
  return v31 != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps28(uint64_t a1, void **a2, void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v82 = *MEMORY[0x263EF8340];
  uint64_t v10 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    goto LABEL_4;
  }
  v71[0] = a2;
  v71[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  int ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v71);
  uint64_t v10 = *a2;
  if (!ArgOperands
    || (unsigned int v61 = a2,
        uint64_t v62 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1)),
        mlir::ShapedType::getShape((mlir::ShapedType *)&v61),
        uint64_t v10 = *a2,
        v12))
  {
LABEL_4:
    unsigned int v13 = (void *)v10[17];
    if (v13 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v13 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_12;
    }
    goto LABEL_9;
  }
  uint64_t v48 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  uint64_t v68 = a2;
  uint64_t v69 = v48;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v68);
  if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)) {
    return 1;
  }
  uint64_t v10 = *a2;
  int64_t v49 = (void *)*((void *)*a2 + 17);
  if (v49 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v49 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
LABEL_9:
    uint64_t v15 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
    v66[0] = a2;
    v66[1] = v15;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v66);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
    {
      uint64_t v16 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v65[0] = a2;
      v65[1] = v16;
      Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v65);
      uint64_t v81 = 1;
      if (v18 == 1 && *Shape == v81) {
        return 1;
      }
    }
  }
LABEL_12:
  if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    uint64_t v19 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    v64[0] = a2;
    v64[1] = v19;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v64);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
  }
  __int16 v63 = 261;
  unsigned int v61 = a3;
  uint64_t v62 = a4;
  mlir::Operation::emitOpError(a1, &v61, (uint64_t)v71);
  if (v71[0])
  {
    LODWORD(v68) = 3;
    uint64_t v69 = (uint64_t)" #";
    uint64_t v70 = 2;
    long long v21 = &v68;
    uint64_t v22 = (char *)v72;
    if (v73 >= v74)
    {
      unint64_t v51 = v73 + 1;
      if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
      {
        int64_t v57 = (char *)&v68 - (unsigned char *)v72;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v51, 24);
        uint64_t v22 = (char *)v72;
        long long v21 = (void ***)((char *)v72 + v57);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v51, 24);
        long long v21 = &v68;
        uint64_t v22 = (char *)v72;
      }
    }
    uint64_t v23 = &v22[24 * v73];
    long long v24 = *(_OWORD *)v21;
    *((void *)v23 + 2) = v21[2];
    *(_OWORD *)uint64_t v23 = v24;
    uint64_t v25 = ++v73;
    if (v71[0])
    {
      LODWORD(v68) = 5;
      uint64_t v69 = a5;
      long long v26 = &v68;
      long long v27 = (char *)v72;
      if (v25 >= v74)
      {
        unint64_t v52 = v25 + 1;
        BOOL v53 = (char *)v72 + 24 * v25 > (char *)&v68;
        if (v72 <= &v68 && v53)
        {
          int64_t v58 = (char *)&v68 - (unsigned char *)v72;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v52, 24);
          long long v27 = (char *)v72;
          long long v26 = (void ***)((char *)v72 + v58);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v52, 24);
          long long v26 = &v68;
          long long v27 = (char *)v72;
        }
      }
      char v28 = &v27[24 * v73];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)char v28 = v29;
      uint64_t v30 = ++v73;
      if (v71[0])
      {
        LODWORD(v68) = 3;
        uint64_t v69 = (uint64_t)" must be 0D tensor of 64-bit signed integer values or static-shape defined tensor with shape equa"
                       "l to [1] or unranked tensor of 64-bit signed integer values, but got ";
        uint64_t v70 = 166;
        char v31 = &v68;
        unsigned int v32 = (char *)v72;
        if (v30 >= v74)
        {
          unint64_t v54 = v30 + 1;
          BOOL v55 = (char *)v72 + 24 * v30 > (char *)&v68;
          if (v72 <= &v68 && v55)
          {
            int64_t v59 = (char *)&v68 - (unsigned char *)v72;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
            unsigned int v32 = (char *)v72;
            char v31 = (void ***)((char *)v72 + v59);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
            char v31 = &v68;
            unsigned int v32 = (char *)v72;
          }
        }
        uint64_t v33 = &v32[24 * v73];
        long long v34 = *(_OWORD *)v31;
        *((void *)v33 + 2) = v31[2];
        *(_OWORD *)uint64_t v33 = v34;
        ++v73;
        if (v71[0])
        {
          uint64_t v35 = &v68;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v68, (uint64_t)a2);
          uint64_t v36 = (char *)v72;
          if (v73 >= v74)
          {
            unint64_t v56 = v73 + 1;
            if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
            {
              int64_t v60 = (char *)&v68 - (unsigned char *)v72;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
              uint64_t v36 = (char *)v72;
              uint64_t v35 = (void ***)((char *)v72 + v60);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
              uint64_t v35 = &v68;
              uint64_t v36 = (char *)v72;
            }
          }
          uint64_t v37 = &v36[24 * v73];
          long long v38 = *(_OWORD *)v35;
          *((void *)v37 + 2) = v35[2];
          *(_OWORD *)uint64_t v37 = v38;
          ++v73;
        }
      }
    }
  }
  uint64_t v20 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v71);
  if (v71[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v71);
  }
  if (v80)
  {
    uint64_t v39 = __p;
    if (__p)
    {
      int64_t v40 = v79;
      unint64_t v41 = __p;
      if (v79 != __p)
      {
        do
          int64_t v40 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v40 - 1);
        while (v40 != v39);
        unint64_t v41 = __p;
      }
      unint64_t v79 = v39;
      operator delete(v41);
    }
    unint64_t v42 = v76;
    if (v76)
    {
      BOOL v43 = v77;
      unint64_t v44 = v76;
      if (v77 != v76)
      {
        do
        {
          uint64_t v46 = *--v43;
          uint64_t v45 = v46;
          void *v43 = 0;
          if (v46) {
            MEMORY[0x21667D390](v45, 0x1000C8077774924);
          }
        }
        while (v43 != v42);
        unint64_t v44 = v76;
      }
      uint64_t v77 = v42;
      operator delete(v44);
    }
    if (v72 != v75) {
      free(v72);
    }
  }
  return v20;
}

void mlir::mps::InitRandomPhiloxStateOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::InstanceNormOpGenericAdaptorBase::InstanceNormOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  unint64_t v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.instance_norm", 17, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void *mlir::mps::detail::InstanceNormOpGenericAdaptorBase::getEpsilon@<X0>(mlir::mps::detail::InstanceNormOpGenericAdaptorBase *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *((void *)this + 3);
  return mlir::FloatAttr::getValue((mlir::FloatAttr *)&v3, a2);
}

uint64_t mlir::mps::InstanceNormOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      int v44 = 3;
      uint64_t v45 = "expected DictionaryAttr to set properties";
      uint64_t v46 = 41;
      long long v26 = &v44;
      long long v27 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v40 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          long long v27 = (char *)v48;
          long long v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          long long v26 = &v44;
          long long v27 = (char *)v48;
        }
      }
      char v28 = &v27[24 * v49];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)char v28 = v29;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
    if (!v56) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      char v31 = v55;
      unsigned int v32 = __p;
      if (v55 != __p)
      {
        do
          char v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unsigned int v32 = __p;
      }
      BOOL v55 = v30;
      operator delete(v32);
    }
    long long v21 = v52;
    if (!v52) {
      goto LABEL_43;
    }
    uint64_t v33 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "epsilon", 7uLL);
  if (!v8) {
    return 1;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    int v44 = 3;
    uint64_t v46 = 52;
    uint64_t v10 = &v44;
    uint64_t v11 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        int64_t v41 = (char *)&v44 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v11 = (char *)v48;
        uint64_t v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        uint64_t v10 = &v44;
        uint64_t v11 = (char *)v48;
      }
    }
    uint64_t v12 = &v11[24 * v49];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v49;
    if (v47[0])
    {
      uint64_t v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      uint64_t v15 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          int64_t v42 = (char *)&v44 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v15 = (char *)v48;
          uint64_t v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          uint64_t v14 = &v44;
          uint64_t v15 = (char *)v48;
        }
      }
      uint64_t v16 = &v15[24 * v49];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)uint64_t v16 = v17;
      ++v49;
      if (v47[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      }
    }
  }
  if (!v56) {
    return 0;
  }
  uint64_t v18 = __p;
  if (__p)
  {
    uint64_t v19 = v55;
    uint64_t v20 = __p;
    if (v55 != __p)
    {
      do
        uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      uint64_t v20 = __p;
    }
    BOOL v55 = v18;
    operator delete(v20);
  }
  long long v21 = v52;
  if (v52)
  {
    uint64_t v22 = v53;
    uint64_t v23 = v52;
    if (v53 == v52) {
      goto LABEL_42;
    }
    do
    {
      uint64_t v25 = *--v22;
      uint64_t v24 = v25;
      void *v22 = 0;
      if (v25) {
        MEMORY[0x21667D390](v24, 0x1000C8077774924);
      }
    }
    while (v22 != v21);
LABEL_41:
    uint64_t v23 = v52;
LABEL_42:
    BOOL v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51) {
    free(v48);
  }
  return 0;
}

uint64_t mlir::mps::InstanceNormOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x263EF8340];
  uint64_t v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"epsilon", 7, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  uint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::InstanceNormOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::InstanceNormOp::verifyInvariantsImpl(mlir::mps::InstanceNormOp *this)
{
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(void ***)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  uint64_t v7 = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(v3, (void **)"epsilon", (const char *)7, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v4 = *(void *)this - 16;
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
}

void mlir::mps::InstanceNormOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::IsFiniteOpGenericAdaptorBase::IsFiniteOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.is_finite", 13, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::IsFiniteOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::IsInfiniteOpGenericAdaptorBase::IsInfiniteOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.is_infinite", 15, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::IsInfiniteOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::IsNaNOpGenericAdaptorBase::IsNaNOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.is_nan", 10, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::IsNaNOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::LPNormOpGenericAdaptorBase::LPNormOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  unint64_t v5 = a2[11];
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.lp_norm", 11, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::LPNormOp::verifyInvariantsImpl(mlir::mps::LPNormOp *this)
{
  uint64_t v78 = *MEMORY[0x263EF8340];
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0))return 0; {
  uint64_t v2 = *(void *)this;
  }
  uint64_t v3 = (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v4 = *v3;
  if (*((_UNKNOWN **)*v3 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v67[0] = *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
    v67[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v4 + 1));
    int ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v67);
    uint64_t v4 = *v3;
    if (ArgOperands)
    {
      uint64_t v57 = v3;
      uint64_t v58 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v4 + 1));
      mlir::ShapedType::getShape((mlir::ShapedType *)&v57);
      uint64_t v4 = *v3;
      if (!v6)
      {
        uint64_t v44 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v4 + 1));
        unint64_t v64 = v3;
        uint64_t v65 = v44;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v64);
        if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isF16((mlir::Type *)&OperandRange)
          || mlir::Type::isF32((mlir::Type *)&OperandRange)
          || mlir::Type::isBF16((mlir::Type *)&OperandRange)
          || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
        {
          goto LABEL_68;
        }
        uint64_t v4 = *v3;
        uint64_t v45 = (void *)*((void *)*v3 + 17);
        if (v45 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
          && v45 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
        {
          goto LABEL_25;
        }
LABEL_10:
        uint64_t v9 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v4 + 1));
        v62[0] = v3;
        v62[1] = v9;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v62);
        if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isF16((mlir::Type *)&OperandRange)
          || mlir::Type::isF32((mlir::Type *)&OperandRange)
          || mlir::Type::isBF16((mlir::Type *)&OperandRange)
          || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
        {
          uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v3 + 8);
          v61[0] = v3;
          v61[1] = v10;
          Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v61);
          uint64_t v77 = 1;
          if (v12 == 1 && *Shape == v77) {
            goto LABEL_68;
          }
        }
        goto LABEL_25;
      }
    }
  }
  uint64_t v7 = (void *)v4[17];
  if (v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v7 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    goto LABEL_10;
  }
LABEL_25:
  if (*((_UNKNOWN **)*v3 + 17) != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
    || (uint64_t v40 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v3 + 8),
        v60[0] = v3,
        v60[1] = v40,
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v60),
        !mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1))
    && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
    && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
    && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
    && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
    && !mlir::Type::isF16((mlir::Type *)&OperandRange)
    && !mlir::Type::isF32((mlir::Type *)&OperandRange)
    && !mlir::Type::isBF16((mlir::Type *)&OperandRange)
    && *(_UNKNOWN **)(*(void *)OperandRange + 136) != &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
  {
    __int16 v59 = 261;
    uint64_t v57 = (void **)"operand";
    uint64_t v58 = 7;
    mlir::Operation::emitOpError(v2, &v57, (uint64_t)v67);
    if (v67[0])
    {
      LODWORD(v64) = 3;
      uint64_t v65 = (uint64_t)" #";
      uint64_t v66 = 2;
      long long v13 = &v64;
      uint64_t v14 = (char *)v68;
      if (v69 >= v70)
      {
        unint64_t v47 = v69 + 1;
        if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
        {
          int64_t v53 = (char *)&v64 - (unsigned char *)v68;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v47, 24);
          uint64_t v14 = (char *)v68;
          long long v13 = (void ***)((char *)v68 + v53);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v47, 24);
          long long v13 = &v64;
          uint64_t v14 = (char *)v68;
        }
      }
      uint64_t v15 = &v14[24 * v69];
      long long v16 = *(_OWORD *)v13;
      *((void *)v15 + 2) = v13[2];
      *(_OWORD *)uint64_t v15 = v16;
      uint64_t v17 = ++v69;
      if (v67[0])
      {
        LODWORD(v64) = 5;
        uint64_t v65 = 1;
        uint64_t v18 = &v64;
        uint64_t v19 = (char *)v68;
        if (v17 >= v70)
        {
          unint64_t v48 = v17 + 1;
          BOOL v49 = (char *)v68 + 24 * v17 > (char *)&v64;
          if (v68 <= &v64 && v49)
          {
            int64_t v54 = (char *)&v64 - (unsigned char *)v68;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v48, 24);
            uint64_t v19 = (char *)v68;
            uint64_t v18 = (void ***)((char *)v68 + v54);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v48, 24);
            uint64_t v18 = &v64;
            uint64_t v19 = (char *)v68;
          }
        }
        uint64_t v20 = &v19[24 * v69];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        uint64_t v22 = ++v69;
        if (v67[0])
        {
          LODWORD(v64) = 3;
          uint64_t v65 = (uint64_t)" must be 0D tensor of mps native type values or static-shape defined tensor with shape equal to"
                         " [1] or unranked tensor of mps native type values, but got ";
          uint64_t v66 = 154;
          uint64_t v23 = &v64;
          uint64_t v24 = (char *)v68;
          if (v22 >= v70)
          {
            unint64_t v50 = v22 + 1;
            BOOL v51 = (char *)v68 + 24 * v22 > (char *)&v64;
            if (v68 <= &v64 && v51)
            {
              int64_t v55 = (char *)&v64 - (unsigned char *)v68;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v50, 24);
              uint64_t v24 = (char *)v68;
              uint64_t v23 = (void ***)((char *)v68 + v55);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v50, 24);
              uint64_t v23 = &v64;
              uint64_t v24 = (char *)v68;
            }
          }
          uint64_t v25 = &v24[24 * v69];
          long long v26 = *(_OWORD *)v23;
          *((void *)v25 + 2) = v23[2];
          *(_OWORD *)uint64_t v25 = v26;
          ++v69;
          if (v67[0])
          {
            long long v27 = &v64;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v64, (uint64_t)v3);
            char v28 = (char *)v68;
            if (v69 >= v70)
            {
              unint64_t v52 = v69 + 1;
              if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
              {
                int64_t v56 = (char *)&v64 - (unsigned char *)v68;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v52, 24);
                char v28 = (char *)v68;
                long long v27 = (void ***)((char *)v68 + v56);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v52, 24);
                long long v27 = &v64;
                char v28 = (char *)v68;
              }
            }
            long long v29 = &v28[24 * v69];
            long long v30 = *(_OWORD *)v27;
            *((void *)v29 + 2) = v27[2];
            *(_OWORD *)long long v29 = v30;
            ++v69;
          }
        }
      }
    }
    char v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v67);
    if (v67[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
    }
    if (v76)
    {
      unsigned int v32 = __p;
      if (__p)
      {
        uint64_t v33 = v75;
        uint64_t v34 = __p;
        if (v75 != __p)
        {
          do
            uint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
          while (v33 != v32);
          uint64_t v34 = __p;
        }
        uint64_t v75 = v32;
        operator delete(v34);
      }
      uint64_t v35 = v72;
      if (v72)
      {
        uint64_t v36 = v73;
        unint64_t v37 = v72;
        if (v73 != v72)
        {
          do
          {
            uint64_t v39 = *--v36;
            uint64_t v38 = v39;
            void *v36 = 0;
            if (v39) {
              MEMORY[0x21667D390](v38, 0x1000C8077774924);
            }
          }
          while (v36 != v35);
          unint64_t v37 = v72;
        }
        unsigned int v73 = v35;
        operator delete(v37);
      }
      if (v68 != v71) {
        free(v68);
      }
    }
    if (!v31) {
      return 0;
    }
  }
LABEL_68:
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 2u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 120) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 3u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v41 = *(void *)this - 16;
  }
  else {
    uint64_t v41 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v41, 0);
  return mlir::tensor::__mlir_ods_local_type_constraint_TensorOps0(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
}

void mlir::mps::LPNormOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::LSTMGradientOp::getAsmResultNames(uint64_t *a1, void (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  if (*(_DWORD *)(*a1 + 36)) {
    uint64_t v5 = *a1 - 16;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  a2(a3, NextResultAtOffset, "gradient_output_sequence", 24);
  if (*(_DWORD *)(*a1 + 36)) {
    uint64_t v7 = *a1 - 16;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 1);
  uint64_t v9 = mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0);
  a2(a3, v9, "gradient_recurrent_weight", 25);
  if (*(_DWORD *)(*a1 + 36)) {
    uint64_t v10 = *a1 - 16;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 2);
  uint64_t v12 = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
  a2(a3, v12, "gradient_input_state", 20);
  if (*(_DWORD *)(*a1 + 36)) {
    uint64_t v13 = *a1 - 16;
  }
  else {
    uint64_t v13 = 0;
  }
  uint64_t v14 = mlir::detail::OpResultImpl::getNextResultAtOffset(v13, 3);
  uint64_t v15 = mlir::detail::OpResultImpl::getNextResultAtOffset(v14, 0);
  a2(a3, v15, "gradient_input_cell", 19);
  uint64_t v16 = *a1;
  int v17 = *(_DWORD *)(*a1 + 36);
  uint64_t v18 = v16 - 16;
  if (v17) {
    uint64_t v19 = v18;
  }
  else {
    uint64_t v19 = 0;
  }
  uint64_t result = mlir::detail::OpResultImpl::getNextResultAtOffset(v19, 4);
  if (v17 != 4)
  {
    uint64_t v21 = mlir::detail::OpResultImpl::getNextResultAtOffset(result, 0);
    return ((uint64_t (*)(uint64_t, uint64_t, const char *, uint64_t))a2)(a3, v21, "gradient_peephole", 17);
  }
  return result;
}

uint64_t mlir::mps::LSTMGradientOp::getODSResults(mlir::mps::LSTMGradientOp *this, unsigned int a2)
{
  if (a2)
  {
    if (a2 >= 8)
    {
      int32x4_t v4 = (int32x4_t)xmmword_211EE3A90;
      unsigned int v3 = a2 & 0xFFFFFFF8;
      int32x4_t v5 = 0uLL;
      v6.i64[0] = 0x400000004;
      v6.i64[1] = 0x400000004;
      v7.i64[0] = 0x800000008;
      v7.i64[1] = 0x800000008;
      unsigned int v8 = a2 & 0xFFFFFFF8;
      int32x4_t v9 = 0uLL;
      do
      {
        int32x4_t v5 = vsubq_s32(v5, vceqq_s32(v4, v6));
        int32x4_t v9 = vsubq_s32(v9, vceqzq_s32(v4));
        int32x4_t v4 = vaddq_s32(v4, v7);
        v8 -= 8;
      }
      while (v8);
      int v2 = vaddvq_s32(vaddq_s32(v9, v5));
      if (v3 == a2) {
        goto LABEL_11;
      }
    }
    else
    {
      int v2 = 0;
      unsigned int v3 = 0;
    }
    do
    {
      if (v3 == 4) {
        ++v2;
      }
      ++v3;
    }
    while (a2 != v3);
  }
  else
  {
    int v2 = 0;
  }
LABEL_11:
  int v10 = *(_DWORD *)(*(void *)this + 36);
  if (v10) {
    uint64_t result = *(void *)this - 16;
  }
  else {
    uint64_t result = 0;
  }
  if (a2 + (v10 - 5) * v2) {
    return mlir::detail::OpResultImpl::getNextResultAtOffset(result, a2 + (v10 - 5) * v2);
  }
  return result;
}

BOOL mlir::mps::LSTMGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v84 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v70 = v6;
  if (!v6)
  {
    a3(v74, a4);
    if (v74[0])
    {
      LODWORD(v71) = 3;
      int64_t v72 = "expected DictionaryAttr to set properties";
      uint64_t v73 = 41;
      long long v26 = &v71;
      long long v27 = (char *)v75;
      if (v76 >= v77)
      {
        unint64_t v60 = v76 + 1;
        if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
        {
          int64_t v65 = (char *)&v71 - (unsigned char *)v75;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v60, 24);
          long long v27 = (char *)v75;
          long long v26 = (uint64_t *)((char *)v75 + v65);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v60, 24);
          long long v26 = &v71;
          long long v27 = (char *)v75;
        }
      }
      char v28 = &v27[24 * v76];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)char v28 = v29;
      ++v76;
      if (v74[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
      }
    }
    if (!v83) {
      return 0;
    }
    long long v30 = __p;
    if (__p)
    {
      char v31 = v82;
      unsigned int v32 = __p;
      if (v82 != __p)
      {
        do
          char v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unsigned int v32 = __p;
      }
      uint64_t v82 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v79;
    if (!v79) {
      goto LABEL_64;
    }
    uint64_t v33 = v80;
    uint64_t v23 = v79;
    if (v80 == v79)
    {
LABEL_63:
      char v80 = v21;
      operator delete(v23);
LABEL_64:
      if (v75 != v78) {
        free(v75);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
LABEL_62:
    uint64_t v23 = v79;
    goto LABEL_63;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v70, "cell_activation", 0xFuLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
      if (v74[0])
      {
        LODWORD(v71) = 3;
        uint64_t v73 = 60;
        int v10 = &v71;
        uint64_t v11 = (char *)v75;
        if (v76 >= v77)
        {
          unint64_t v61 = v76 + 1;
          if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
          {
            int64_t v66 = (char *)&v71 - (unsigned char *)v75;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v61, 24);
            uint64_t v11 = (char *)v75;
            int v10 = (uint64_t *)((char *)v75 + v66);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v61, 24);
            int v10 = &v71;
            uint64_t v11 = (char *)v75;
          }
        }
        uint64_t v12 = &v11[24 * v76];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = v10[2];
        *(_OWORD *)uint64_t v12 = v13;
        ++v76;
        if (v74[0])
        {
          uint64_t v14 = &v71;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v71, v9);
          uint64_t v15 = (char *)v75;
          if (v76 >= v77)
          {
            unint64_t v62 = v76 + 1;
            if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
            {
              int64_t v67 = (char *)&v71 - (unsigned char *)v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v62, 24);
              uint64_t v15 = (char *)v75;
              uint64_t v14 = (uint64_t *)((char *)v75 + v67);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v62, 24);
              uint64_t v14 = &v71;
              uint64_t v15 = (char *)v75;
            }
          }
          uint64_t v16 = &v15[24 * v76];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = v14[2];
          *(_OWORD *)uint64_t v16 = v17;
          ++v76;
          if (v74[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
          }
        }
      }
      if (!v83) {
        return 0;
      }
      uint64_t v18 = __p;
      if (__p)
      {
        uint64_t v19 = v82;
        uint64_t v20 = __p;
        if (v82 != __p)
        {
          do
            uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          uint64_t v20 = __p;
        }
        uint64_t v82 = v18;
        operator delete(v20);
      }
      uint64_t v21 = v79;
      if (!v79) {
        goto LABEL_64;
      }
      uint64_t v22 = v80;
      uint64_t v23 = v79;
      if (v80 == v79) {
        goto LABEL_63;
      }
      do
      {
        uint64_t v25 = *--v22;
        uint64_t v24 = v25;
        void *v22 = 0;
        if (v25) {
          MEMORY[0x21667D390](v24, 0x1000C8077774924);
        }
      }
      while (v22 != v21);
      goto LABEL_62;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v70, "fgate_activation", 0x10uLL);
  if (v36)
  {
    uint64_t v37 = v36;
    if (*(_UNKNOWN **)(*(void *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
      if (v74[0])
      {
        LODWORD(v71) = 3;
        uint64_t v73 = 61;
        uint64_t v38 = &v71;
        uint64_t v39 = (char *)v75;
        if (v76 >= v77)
        {
          unint64_t v63 = v76 + 1;
          if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
          {
            int64_t v68 = (char *)&v71 - (unsigned char *)v75;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v63, 24);
            uint64_t v39 = (char *)v75;
            uint64_t v38 = (uint64_t *)((char *)v75 + v68);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v63, 24);
            uint64_t v38 = &v71;
            uint64_t v39 = (char *)v75;
          }
        }
        uint64_t v40 = &v39[24 * v76];
        long long v41 = *(_OWORD *)v38;
        *((void *)v40 + 2) = v38[2];
        *(_OWORD *)uint64_t v40 = v41;
        ++v76;
        if (v74[0])
        {
          int64_t v42 = &v71;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v71, v37);
          uint64_t v43 = (char *)v75;
          if (v76 >= v77)
          {
            unint64_t v64 = v76 + 1;
            if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
            {
              int64_t v69 = (char *)&v71 - (unsigned char *)v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v64, 24);
              uint64_t v43 = (char *)v75;
              int64_t v42 = (uint64_t *)((char *)v75 + v69);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v64, 24);
              int64_t v42 = &v71;
              uint64_t v43 = (char *)v75;
            }
          }
          uint64_t v44 = &v43[24 * v76];
          long long v45 = *(_OWORD *)v42;
          *((void *)v44 + 2) = v42[2];
          *(_OWORD *)uint64_t v44 = v45;
          ++v76;
          if (v74[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
          }
        }
      }
      if (!v83) {
        return 0;
      }
      uint64_t v46 = __p;
      if (__p)
      {
        unint64_t v47 = v82;
        unint64_t v48 = __p;
        if (v82 != __p)
        {
          do
            unint64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          unint64_t v48 = __p;
        }
        uint64_t v82 = v46;
        operator delete(v48);
      }
      uint64_t v21 = v79;
      if (!v79) {
        goto LABEL_64;
      }
      BOOL v49 = v80;
      uint64_t v23 = v79;
      if (v80 == v79) {
        goto LABEL_63;
      }
      do
      {
        uint64_t v51 = *--v49;
        uint64_t v50 = v51;
        *BOOL v49 = 0;
        if (v51) {
          MEMORY[0x21667D390](v50, 0x1000C8077774924);
        }
      }
      while (v49 != v21);
      goto LABEL_62;
    }
    a1[1] = v36;
  }
  uint64_t v52 = mlir::DictionaryAttr::get((uint64_t)&v70, "gate_layout", 0xBuLL);
  uint64_t v71 = v52;
  if (v52)
  {
    if (*(_UNKNOWN **)(*(void *)v52 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id)
    {
      a3(v74, a4);
LABEL_83:
      mlir::InFlightDiagnostic::append<mlir::Attribute>(v53, &v71);
LABEL_84:
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v74);
      return 0;
    }
    a1[2] = v52;
  }
  uint64_t v54 = mlir::DictionaryAttr::get((uint64_t)&v70, "igate_activation", 0x10uLL);
  uint64_t v71 = v54;
  if (v54)
  {
    if (*(_UNKNOWN **)(*(void *)v54 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
LABEL_82:
      uint64_t v53 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v74, v55);
      goto LABEL_83;
    }
    a1[3] = v54;
  }
  uint64_t v56 = mlir::DictionaryAttr::get((uint64_t)&v70, "ogate_activation", 0x10uLL);
  uint64_t v71 = v56;
  if (v56)
  {
    if (*(_UNKNOWN **)(*(void *)v56 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
      goto LABEL_82;
    }
    a1[4] = v56;
  }
  uint64_t v57 = mlir::DictionaryAttr::get((uint64_t)&v70, "zgate_activation", 0x10uLL);
  uint64_t v71 = v57;
  if (v57)
  {
    if (*(_UNKNOWN **)(*(void *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
      goto LABEL_82;
    }
    a1[5] = v57;
  }
  __int16 v59 = (void *)mlir::DictionaryAttr::get((uint64_t)&v70, "operandSegmentSizes", 0x13uLL);
  if (!v59)
  {
    __int16 v59 = (void *)mlir::DictionaryAttr::get((uint64_t)&v70, "operand_segment_sizes", 0x15uLL);
    if (!v59)
    {
      a3(v74, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v74, "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.");
      goto LABEL_84;
    }
  }
  return mlir::convertFromAttribute(a1 + 6, (const char *)0xA, v59, a3, a4) != 0;
}

uint64_t mlir::mps::LSTMGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v53[6] = *MEMORY[0x263EF8340];
  uint64_t v50 = a1;
  uint64_t v51 = v53;
  uint64_t v52 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v50, (uint64_t)"cell_activation", 15, *a2);
    uint64_t v6 = v5;
    unsigned int v7 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v7 = v52;
    }
    uint64_t v8 = (uint64_t *)((char *)v51 + 16 * v7);
    *uint64_t v8 = NamedAttr;
    v8[1] = v6;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v9 = a2[1];
  if (v9)
  {
    uint64_t v10 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"fgate_activation", 16, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v13 = v52;
    }
    uint64_t v14 = (uint64_t *)((char *)v51 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"gate_layout", 11, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v19 = v52;
    }
    uint64_t v20 = (uint64_t *)((char *)v51 + 16 * v19);
    uint64_t *v20 = v16;
    v20[1] = v18;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"igate_activation", 16, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v25 = v52;
    }
    long long v26 = (uint64_t *)((char *)v51 + 16 * v25);
    uint64_t *v26 = v22;
    v26[1] = v24;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"ogate_activation", 16, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v31 = v52;
    }
    unsigned int v32 = (uint64_t *)((char *)v51 + 16 * v31);
    uint64_t *v32 = v28;
    v32[1] = v30;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v33 = a2[5];
  if (v33)
  {
    uint64_t v34 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"zgate_activation", 16, v33);
    uint64_t v36 = v35;
    unsigned int v37 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      unsigned int v37 = v52;
    }
    uint64_t v38 = (uint64_t *)((char *)v51 + 16 * v37);
    uint64_t *v38 = v34;
    v38[1] = v36;
    LODWORD(v52) = v52 + 1;
  }
  uint64_t v39 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 10);
  uint64_t v40 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"operandSegmentSizes", 19, v39);
  uint64_t v42 = v41;
  unsigned int v43 = v52;
  if (v52 >= HIDWORD(v52))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
    unsigned int v43 = v52;
  }
  uint64_t v44 = (uint64_t *)((char *)v51 + 16 * v43);
  uint64_t *v44 = v40;
  v44[1] = v42;
  BOOL v45 = __CFADD__(v52, 1);
  uint64_t v46 = (v52 + 1);
  LODWORD(v52) = v52 + 1;
  if (v45)
  {
    uint64_t DictionaryAttr = 0;
    unint64_t v48 = v51;
    if (v51 == v53) {
      return DictionaryAttr;
    }
    goto LABEL_32;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v50, (uint64_t *)v51, v46);
  unint64_t v48 = v51;
  if (v51 != v53) {
LABEL_32:
  }
    free(v48);
  return DictionaryAttr;
}

unint64_t mlir::mps::LSTMGradientOp::computePropertiesHash(unint64_t *a1)
{
  uint64_t v101 = *MEMORY[0x263EF8340];
  unint64_t v1 = *a1;
  int v2 = &unk_267770000;
  {
    unsigned int v76 = a1;
    unint64_t v83 = v1;
    int v2 = &unk_267770000;
    int v42 = v41;
    a1 = v76;
    unint64_t v1 = v83;
    if (v42)
    {
      unint64_t v43 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v43 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v43;
      a1 = v76;
      unint64_t v1 = v83;
      int v2 = (void *)&unk_267770000;
    }
  }
  uint64_t v3 = v2[385];
  unint64_t v4 = a1[1];
  {
    unsigned int v77 = a1;
    unint64_t v84 = v1;
    unint64_t v64 = v4;
    uint64_t v69 = v3;
    unint64_t v4 = v64;
    uint64_t v3 = v69;
    int v2 = &unk_267770000;
    int v45 = v44;
    a1 = v77;
    unint64_t v1 = v84;
    if (v45)
    {
      unint64_t v46 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v46 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v46;
      unint64_t v4 = v64;
      uint64_t v3 = v69;
      a1 = v77;
      unint64_t v1 = v84;
      int v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v5 = HIDWORD(v4);
  unint64_t v6 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v4) ^ HIDWORD(v4));
  unint64_t v96 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) ^ ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) >> 47));
  unint64_t v7 = a1[2];
  {
    uint64_t v78 = a1;
    unint64_t v85 = v1;
    unint64_t v65 = v7;
    uint64_t v70 = v3;
    unint64_t v7 = v65;
    uint64_t v3 = v70;
    int v2 = &unk_267770000;
    int v48 = v47;
    a1 = v78;
    unint64_t v1 = v85;
    if (v48)
    {
      unint64_t v49 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v49 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v49;
      unint64_t v7 = v65;
      uint64_t v3 = v70;
      a1 = v78;
      unint64_t v1 = v85;
      int v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v8 = HIDWORD(v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v7) ^ HIDWORD(v7));
  unint64_t v95 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
  unint64_t v10 = a1[3];
  {
    unint64_t v79 = a1;
    unint64_t v86 = v1;
    unint64_t v66 = v10;
    uint64_t v71 = v3;
    unint64_t v10 = v66;
    uint64_t v3 = v71;
    int v2 = &unk_267770000;
    int v51 = v50;
    a1 = v79;
    unint64_t v1 = v86;
    if (v51)
    {
      unint64_t v52 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v52 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v52;
      unint64_t v10 = v66;
      uint64_t v3 = v71;
      a1 = v79;
      unint64_t v1 = v86;
      int v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v11 = HIDWORD(v10);
  unint64_t v12 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v10) ^ HIDWORD(v10));
  unint64_t v94 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v11 ^ (v12 >> 47) ^ v12)) ^ ((0x9DDFEA08EB382D69 * (v11 ^ (v12 >> 47) ^ v12)) >> 47));
  unint64_t v13 = a1[4];
  {
    char v80 = a1;
    unint64_t v87 = v1;
    unint64_t v67 = v13;
    uint64_t v72 = v3;
    unint64_t v13 = v67;
    uint64_t v3 = v72;
    int v2 = &unk_267770000;
    int v54 = v53;
    a1 = v80;
    unint64_t v1 = v87;
    if (v54)
    {
      unint64_t v55 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v55 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v55;
      unint64_t v13 = v67;
      uint64_t v3 = v72;
      a1 = v80;
      unint64_t v1 = v87;
      int v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v14 = HIDWORD(v13);
  unint64_t v15 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v13) ^ HIDWORD(v13));
  unint64_t v93 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v14 ^ (v15 >> 47) ^ v15)) ^ ((0x9DDFEA08EB382D69 * (v14 ^ (v15 >> 47) ^ v15)) >> 47));
  unint64_t v16 = a1[5];
  {
    uint64_t v81 = a1;
    unint64_t v88 = v1;
    unint64_t v68 = v16;
    uint64_t v73 = v3;
    unint64_t v16 = v68;
    uint64_t v3 = v73;
    int v2 = &unk_267770000;
    int v57 = v56;
    a1 = v81;
    unint64_t v1 = v88;
    if (v57)
    {
      unint64_t v58 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v58 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v58;
      unint64_t v16 = v68;
      uint64_t v3 = v73;
      a1 = v81;
      unint64_t v1 = v88;
      int v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v17 = HIDWORD(v16);
  unint64_t v18 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v16) ^ HIDWORD(v16));
  unint64_t v92 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v17 ^ (v18 >> 47) ^ v18)) ^ ((0x9DDFEA08EB382D69 * (v17 ^ (v18 >> 47) ^ v18)) >> 47));
  {
    uint64_t v82 = a1;
    unint64_t v89 = v1;
    uint64_t v74 = v3;
    unint64_t v1 = v89;
    int v2 = &unk_267770000;
    int v60 = v59;
    uint64_t v3 = v74;
    a1 = v82;
    if (v60)
    {
      unint64_t v61 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v61 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v61;
      uint64_t v3 = v74;
      a1 = v82;
      unint64_t v1 = v89;
      int v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v19 = a1[7];
  unint64_t v20 = a1[8];
  unint64_t v21 = a1[9];
  uint64_t v22 = a1[6] - 0x3C5A37A36834CED9 * v21 - 0x6E18B188484051E8;
  uint64_t v23 = __ROR8__(v22 + v21, 52);
  unint64_t v24 = v22 + v19;
  uint64_t v25 = __ROR8__(v24, 7);
  unint64_t v26 = v24 + v20;
  uint64_t v27 = v25 + __ROR8__(a1[6] - 0x3C5A37A36834CED9 * v21 - 0x6E18B188484051E8, 37) + v23;
  unint64_t v28 = v20 + v19;
  unint64_t v29 = a1[10];
  uint64_t v30 = __ROR8__(v28 + v29, 52);
  uint64_t v31 = v27 + __ROR8__(v26, 31);
  uint64_t v32 = __ROR8__(v28, 37);
  unint64_t v33 = v28 + v20;
  uint64_t v34 = __ROR8__(v33, 7);
  unint64_t v35 = v33 + v21;
  unint64_t v36 = v26 + v21 + v32 + v30 + v34 + __ROR8__(v35, 31);
  unint64_t v37 = ((0xC3A5C85C97CB3127
        * ((0xC3A5C85C97CB3127 * (v35 + v29 + v31) - 0x651E95C4D06FBFB1 * v36) ^ ((0xC3A5C85C97CB3127
                                                                                     * (v35 + v29 + v31)
                                                                                     - 0x651E95C4D06FBFB1 * v36) >> 47))) ^ v2[385])
      + v31;
  unint64_t v91 = 0x9AE16A3B2F90404FLL * (v37 ^ (v37 >> 47));
  uint64_t v99 = 0;
  memset(v98, 0, sizeof(v98));
  memset(v97, 0, sizeof(v97));
  {
    unint64_t v90 = v1;
    uint64_t v75 = v3;
    uint64_t v3 = v75;
    unint64_t v1 = v90;
    int v2 = &unk_267770000;
    if (v62)
    {
      unint64_t v63 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v63 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v63;
      uint64_t v3 = v75;
      unint64_t v1 = v90;
      int v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v38 = HIDWORD(v1);
  unint64_t v39 = 0x9DDFEA08EB382D69 * ((v3 + 8 * v1) ^ HIDWORD(v1));
  uint64_t v100 = v2[385];
  *(void *)&v97[0] = 0x9DDFEA08EB382D69
                     * ((0x9DDFEA08EB382D69 * (v38 ^ (v39 >> 47) ^ v39)) ^ ((0x9DDFEA08EB382D69
                                                                             * (v38 ^ (v39 >> 47) ^ v39)) >> 47));
  return llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>((llvm::hashing::detail::hash_combine_recursive_helper *)v97, 0, (void *)v97 + 1, (char *)v98, (uint64_t *)&v96, (uint64_t *)&v95, (uint64_t *)&v94, (uint64_t *)&v93, (uint64_t *)&v92, (uint64_t *)&v91);
}

uint64_t mlir::mps::LSTMGradientOp::getInherentAttr(mlir::MLIRContext *a1, void *a2, char *__s1, size_t __n)
{
  uint64_t result = 0;
  switch(__n)
  {
    case 0xBuLL:
      if (memcmp(__s1, "gate_layout", __n)) {
        goto LABEL_23;
      }
      return a2[2];
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x14uLL:
      goto LABEL_23;
    case 0xFuLL:
      if (*(void *)__s1 != 0x7463615F6C6C6563 || *(void *)(__s1 + 7) != 0x6E6F697461766974) {
        goto LABEL_23;
      }
      return *a2;
    case 0x10uLL:
      if (!memcmp(__s1, "fgate_activation", __n))
      {
        uint64_t result = a2[1];
      }
      else if (!memcmp(__s1, "igate_activation", __n))
      {
        uint64_t result = a2[3];
      }
      else if (*(void *)__s1 == 0x63615F657461676FLL && *((void *)__s1 + 1) == 0x6E6F697461766974)
      {
        uint64_t result = a2[4];
      }
      else if (*(void *)__s1 == 0x63615F657461677ALL && *((void *)__s1 + 1) == 0x6E6F697461766974)
      {
        uint64_t result = a2[5];
      }
      else
      {
LABEL_23:
        uint64_t result = 0;
      }
      break;
    case 0x13uLL:
      if (memcmp(__s1, "operandSegmentSizes", __n)) {
        goto LABEL_23;
      }
      goto LABEL_25;
    case 0x15uLL:
      if (memcmp(__s1, "operand_segment_sizes", __n)) {
        goto LABEL_23;
      }
LABEL_25:
      uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 10);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::mps::LSTMGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, void *a4)
{
  unint64_t v7 = (void *)result;
  switch(__n)
  {
    case 0xBuLL:
      uint64_t result = memcmp(__s1, "gate_layout", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id) {
            unint64_t v15 = a4;
          }
          else {
            unint64_t v15 = 0;
          }
          v7[2] = v15;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    case 0xFuLL:
      if (*(void *)__s1 == 0x7463615F6C6C6563 && *(void *)(__s1 + 7) == 0x6E6F697461766974)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
            unint64_t v9 = a4;
          }
          else {
            unint64_t v9 = 0;
          }
          *(void *)uint64_t result = v9;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "fgate_activation", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "igate_activation", __n);
        if (result)
        {
          if (*(void *)__s1 == 0x63615F657461676FLL && *((void *)__s1 + 1) == 0x6E6F697461766974)
          {
            if (a4)
            {
              if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
                unint64_t v18 = a4;
              }
              else {
                unint64_t v18 = 0;
              }
              uint64_t v7[4] = v18;
            }
            else
            {
              uint64_t v7[4] = 0;
            }
          }
          else if (*(void *)__s1 == 0x63615F657461677ALL && *((void *)__s1 + 1) == 0x6E6F697461766974)
          {
            if (a4)
            {
              if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
                unint64_t v12 = a4;
              }
              else {
                unint64_t v12 = 0;
              }
              v7[5] = v12;
            }
            else
            {
              v7[5] = 0;
            }
          }
        }
        else if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
            unint64_t v17 = a4;
          }
          else {
            unint64_t v17 = 0;
          }
          v7[3] = v17;
        }
        else
        {
          v7[3] = 0;
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
          unint64_t v16 = a4;
        }
        else {
          unint64_t v16 = 0;
        }
        v7[1] = v16;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x13uLL:
      uint64_t result = memcmp(__s1, "operandSegmentSizes", __n);
      if (!result) {
        goto LABEL_33;
      }
      break;
    case 0x15uLL:
      uint64_t result = memcmp(__s1, "operand_segment_sizes", __n);
      if (!result)
      {
LABEL_33:
        if (a4)
        {
          uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
          unint64_t v13 = result ? a4 : 0;
          unint64_t v19 = v13;
          if (result)
          {
            uint64_t result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v19);
            if (result == 10)
            {
              uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v19);
              if (v14) {
                uint64_t result = (uint64_t)memmove(v7 + 6, (const void *)result, 4 * v14);
              }
            }
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::LSTMGradientOp::populateInherentAttrs(mlir::MLIRContext *a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"cell_activation", 15, *a2);
  }
  uint64_t v6 = a2[1];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"fgate_activation", 16, v6);
  }
  uint64_t v7 = a2[2];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"gate_layout", 11, v7);
  }
  uint64_t v8 = a2[3];
  if (v8) {
    mlir::NamedAttrList::append(a3, (uint64_t)"igate_activation", 16, v8);
  }
  uint64_t v9 = a2[4];
  if (v9) {
    mlir::NamedAttrList::append(a3, (uint64_t)"ogate_activation", 16, v9);
  }
  uint64_t v10 = a2[5];
  if (v10) {
    mlir::NamedAttrList::append(a3, (uint64_t)"zgate_activation", 16, v10);
  }
  uint64_t v11 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 10);

  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v11);
}

BOOL mlir::mps::LSTMGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v8, (void **)"cell_activation", (const char *)0xF, a3, a4))
  {
    uint64_t v9 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v9, (void **)"fgate_activation", (const char *)0x10, a3, a4))
    {
      uint64_t v10 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps30(v10, (void **)"gate_layout", (const char *)0xB, a3, a4))
      {
        uint64_t v11 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v11, (void **)"igate_activation", (const char *)0x10, a3, a4))
        {
          uint64_t v12 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v12, (void **)"ogate_activation", (const char *)0x10, a3, a4))
          {
            uint64_t v13 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v13, (void **)"zgate_activation", (const char *)0x10, a3, a4))
            {
              return 1;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps30(uint64_t a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      unint64_t v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid LSTM gate layout";
        uint64_t v31 = 54;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    unint64_t v16 = __p;
    if (__p)
    {
      unint64_t v17 = v42;
      unint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          unint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        unint64_t v18 = __p;
      }
      int v42 = v16;
      operator delete(v18);
    }
    unint64_t v19 = v39;
    if (v39)
    {
      unint64_t v20 = v40;
      unint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        unint64_t v21 = v39;
      }
      uint64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

BOOL mlir::mps::LSTMGradientOp::readProperties(uint64_t a1, uint64_t a2)
{
  v10[24] = *MEMORY[0x263EF8340];
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMGradientOpGenericAdaptorBase::Properties>(a2);
  if (!mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 1)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::LSTMGateLayoutAttr>(a1, v3 + 2)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 3)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 4))
  {
    return 0;
  }
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) <= 5)
  {
    uint64_t v9 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v9)) {
      return 0;
    }
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v9) >= 11)
    {
      v7[0] = (uint64_t)"size mismatch for operand/result_segment_size";
      __int16 v8 = 259;
      (*(void (**)(void *__return_ptr, uint64_t, uint64_t *))(*(void *)a1 + 16))(v10, a1, v7);
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v10);
      return 0;
    }
    unint64_t v4 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v9);
    if (v5) {
      memmove(v3 + 6, v4, 4 * v5);
    }
  }
  if (mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 5))
  {
    v7[0] = a1;
    v7[1] = (uint64_t)(v3 + 6);
    return mlir::mps::LSTMGradientOp::readProperties(mlir::DialectBytecodeReader &,mlir::OperationState &)::$_0::operator()(v7) != 0;
  }
  return 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMGradientOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::LSTMGateLayoutAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  uint64_t v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    uint64_t v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        uint64_t v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    __int16 v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)__int16 v8 = v9;
    ++v47;
  }
  uint64_t v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::LSTMGateLayoutAttr]";
  unint64_t v41 = 79;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    uint64_t v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      long long v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          long long v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      unint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)unint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        unint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unint64_t v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unint64_t v19 = (char *)v46;
            unint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unint64_t v18 = &v40;
            unint64_t v19 = (char *)v46;
          }
        }
        unint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)unint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      unint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          unint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      int v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      int v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

uint64_t mlir::mps::LSTMGradientOp::readProperties(mlir::DialectBytecodeReader &,mlir::OperationState &)::$_0::operator()(uint64_t *a1)
{
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)*a1 + 40))(*a1) < 6) {
    return 1;
  }
  uint64_t v2 = *a1;
  uint64_t v3 = (_DWORD *)a1[1];

  return mlir::DialectBytecodeReader::readSparseArray<int>(v2, v3, (const char *)0xA);
}

uint64_t mlir::mps::LSTMGradientOp::writeProperties(uint64_t a1, uint64_t a2)
{
  if (HIBYTE(*(_DWORD *)(*(void *)a1 + 44))) {
    unint64_t v4 = *(void *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(void *)a1 + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)v4);
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 8));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 16));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 24));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 32));
  if ((*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2) <= 5)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(void *)a1 + 24));
    uint64_t v6 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v4 + 48, 10);
    (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, v6);
  }
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 40));
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2);
  if (result >= 6)
  {
    return mlir::DialectBytecodeWriter::writeSparseArray<int>(a2, (int *)(v4 + 48), 10);
  }
  return result;
}

mlir::MLIRContext *mlir::mps::LSTMGradientOp::populateDefaultProperties(uint64_t a1, mlir::MLIRContext **a2)
{
  uint64_t v12 = *(void **)(a1 + 8);
  uint64_t result = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  unint64_t v4 = result;
  if (a2[3])
  {
    if (a2[1]) {
      goto LABEL_3;
    }
  }
  else
  {
    unsigned int v11 = 3;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(result);
    uint64_t v12 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
    unint64_t v13 = v4;
    uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v11);
    a2[3] = result;
    if (a2[1])
    {
LABEL_3:
      if (a2[5]) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }
  unsigned int v11 = 3;
  uint64_t v6 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  uint64_t v12 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  unint64_t v13 = v4;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v6, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v11);
  a2[1] = result;
  if (a2[5])
  {
LABEL_4:
    if (a2[4]) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }
LABEL_10:
  unsigned int v11 = 2;
  uint64_t v7 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  uint64_t v12 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  unint64_t v13 = v4;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v7, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v11);
  a2[5] = result;
  if (a2[4])
  {
LABEL_5:
    if (*a2) {
      goto LABEL_6;
    }
    goto LABEL_12;
  }
LABEL_11:
  unsigned int v11 = 3;
  __int16 v8 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  uint64_t v12 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  unint64_t v13 = v4;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v8, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v11);
  a2[4] = result;
  if (*a2)
  {
LABEL_6:
    if (a2[2]) {
      return result;
    }
LABEL_13:
    unsigned int v11 = 0;
    unint64_t v10 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
    uint64_t v12 = &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id;
    unint64_t v13 = v4;
    uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::LSTMGateLayoutAttrStorage,mlir::mps::LSTMGateLayout>(v10, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25LSTMGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18LSTMGateLayoutAttrEJNS2_14LSTMGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id, &v11);
    a2[2] = result;
    return result;
  }
LABEL_12:
  unsigned int v11 = 2;
  long long v9 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  uint64_t v12 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  unint64_t v13 = v4;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v9, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v11);
  *a2 = result;
  if (!a2[2]) {
    goto LABEL_13;
  }
  return result;
}

uint64_t mlir::mps::LSTMGradientOp::verifyInvariantsImpl(mlir::mps::LSTMGradientOp *this)
{
  v122[24] = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  uint64_t v7 = v3[2];
  uint64_t v6 = v3[3];
  uint64_t v8 = v3[4];
  uint64_t v9 = v3[5];
  v122[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v6, (void **)"igate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v122))return 0; {
  v122[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v5, (void **)"fgate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v122))return 0; {
  v122[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v9, (void **)"zgate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v122))return 0; {
  v122[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v8, (void **)"ogate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v122))return 0; {
  v122[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v4, (void **)"cell_activation", (const char *)0xF, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v122))return 0; {
  v122[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps30(v7, (void **)"gate_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps30(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v122))return 0; {
  unsigned int v121 = 0;
  }
  unint64_t v10 = *(unsigned int *)(*(void *)this + 44);
  uint64_t v11 = *(void *)this + 16 * ((v10 >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v11 = 0;
  }
  uint64_t v12 = *(unsigned int *)(v11 + 48);
  if ((v10 & 0x800000) != 0)
  {
    uint64_t v13 = *(void *)(*(void *)this + 72);
    if (v12) {
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v13 = 0;
    if (v12)
    {
LABEL_14:
      uint64_t v14 = v13 + 24;
      do
      {
        uint64_t v15 = *(void *)this;
        unint64_t v16 = *(void *)(*(void *)v14 + 8) & 0xFFFFFFFFFFFFFFF8;
        unsigned int v17 = v121++;
        if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v15, v16, (void **)"operand", (void **)7, v17))return 0; {
        v14 += 32;
        }
      }
      while (--v12);
    }
  }
  uint64_t ODSOperands = mlir::mps::GRUGradientOp::getODSOperands(this, 1u);
  if (v19)
  {
    uint64_t v20 = v19;
    uint64_t v21 = ODSOperands + 24;
    do
    {
      uint64_t v22 = *(void *)this;
      unint64_t v23 = *(void *)(*(void *)v21 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v24 = v121++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v22, v23, (void **)"operand", (void **)7, v24))return 0; {
      v21 += 32;
      }
    }
    while (--v20);
  }
  uint64_t v25 = mlir::mps::GRUGradientOp::getODSOperands(this, 2u);
  if (v26)
  {
    uint64_t v27 = v26;
    uint64_t v28 = v25 + 24;
    do
    {
      uint64_t v29 = *(void *)this;
      unint64_t v30 = *(void *)(*(void *)v28 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v31 = v121++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v29, v30, (void **)"operand", (void **)7, v31))return 0; {
      v28 += 32;
      }
    }
    while (--v27);
  }
  uint64_t v32 = mlir::mps::GRUGradientOp::getODSOperands(this, 3u);
  if (v33)
  {
    uint64_t v34 = v33;
    uint64_t v35 = v32 + 24;
    do
    {
      uint64_t v36 = *(void *)this;
      unint64_t v37 = *(void *)(*(void *)v35 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v38 = v121++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v36, v37, (void **)"operand", (void **)7, v38))return 0; {
      v35 += 32;
      }
    }
    while (--v34);
  }
  uint64_t v39 = mlir::mps::GRUGradientOp::getODSOperands(this, 4u);
  uint64_t v41 = v40;
  if (v40 >= 2) {
    goto LABEL_45;
  }
  if (v40)
  {
    uint64_t v42 = *(void *)(v39 + 24);
    uint64_t v43 = *(void *)this;
    unint64_t v44 = *(void *)(v42 + 8) & 0xFFFFFFFFFFFFFFF8;
    unsigned int v45 = v121++;
    if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v43, v44, (void **)"operand", (void **)7, v45))return 0; {
  }
    }
  uint64_t v46 = mlir::mps::GRUGradientOp::getODSOperands(this, 5u);
  uint64_t v41 = v47;
  if (v47 < 2)
  {
    if (v47)
    {
      uint64_t v48 = *(void *)(v46 + 24);
      uint64_t v49 = *(void *)this;
      unint64_t v50 = *(void *)(v48 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v51 = v121++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v49, v50, (void **)"operand", (void **)7, v51))return 0; {
    }
      }
    uint64_t v52 = mlir::mps::GRUGradientOp::getODSOperands(this, 6u);
    uint64_t v41 = v53;
    if (v53 < 2)
    {
      if (v53)
      {
        uint64_t v54 = *(void *)(v52 + 24);
        uint64_t v55 = *(void *)this;
        unint64_t v56 = *(void *)(v54 + 8) & 0xFFFFFFFFFFFFFFF8;
        unsigned int v57 = v121++;
        if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v55, v56, (void **)"operand", (void **)7, v57))return 0; {
      }
        }
      uint64_t v58 = mlir::mps::GRUGradientOp::getODSOperands(this, 7u);
      uint64_t v41 = v59;
      if (v59 < 2)
      {
        if (v59)
        {
          uint64_t v60 = *(void *)(v58 + 24);
          uint64_t v61 = *(void *)this;
          unint64_t v62 = *(void *)(v60 + 8) & 0xFFFFFFFFFFFFFFF8;
          unsigned int v63 = v121++;
          if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v61, v62, (void **)"operand", (void **)7, v63))return 0; {
        }
          }
        uint64_t v64 = mlir::mps::GRUGradientOp::getODSOperands(this, 8u);
        uint64_t v41 = v65;
        if (v65 < 2)
        {
          if (!v65
            || (uint64_t v66 = *(void *)(v64 + 24),
                uint64_t v67 = *(void *)this,
                unint64_t v68 = (void **)(*(void *)(v66 + 8) & 0xFFFFFFFFFFFFFFF8),
                unsigned int v69 = v121,
                ++v121,
                mlir::mps::__mlir_ods_local_type_constraint_MPSOps31(v67, v68, (void **)"operand", 7, v69)))
          {
            uint64_t v70 = mlir::mps::GRUGradientOp::getODSOperands(this, 9u);
            uint64_t v41 = v71;
            if (v71 >= 2) {
              goto LABEL_45;
            }
            if (!v71
              || (uint64_t v76 = *(void *)(v70 + 24),
                  uint64_t v77 = *(void *)this,
                  unint64_t v78 = *(void *)(v76 + 8) & 0xFFFFFFFFFFFFFFF8,
                  unsigned int v79 = v121,
                  ++v121,
                  mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v77, v78, (void **)"operand", (void **)7, v79)))
            {
              unsigned int v121 = 0;
              uint64_t ODSResults = mlir::mps::LSTMGradientOp::getODSResults(this, 0);
              if (v81)
              {
                uint64_t v82 = ODSResults;
                uint64_t v83 = v81;
                uint64_t v84 = 0;
                while (1)
                {
                  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v82, v84);
                  uint64_t v86 = *(void *)this;
                  unint64_t v87 = *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8;
                  unsigned int v121 = v84 + 1;
                  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v86, v87, (void **)"result", (void **)6, v84))break; {
                  if (v83 == ++v84)
                  }
                    goto LABEL_57;
                }
              }
              else
              {
                LODWORD(v84) = 0;
LABEL_57:
                uint64_t v88 = mlir::mps::LSTMGradientOp::getODSResults(this, 1u);
                if (v89)
                {
                  uint64_t v90 = v88;
                  uint64_t v91 = v89;
                  uint64_t v92 = 0;
                  while (1)
                  {
                    uint64_t v93 = mlir::detail::OpResultImpl::getNextResultAtOffset(v90, v92);
                    uint64_t v94 = *(void *)this;
                    unint64_t v95 = *(void *)(v93 + 8) & 0xFFFFFFFFFFFFFFF8;
                    unsigned int v121 = v84 + v92 + 1;
                    if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v94, v95, (void **)"result", (void **)6, (int)v84 + (int)v92))break; {
                    if (v91 == ++v92)
                    }
                    {
                      LODWORD(v84) = v84 + v92;
                      goto LABEL_62;
                    }
                  }
                }
                else
                {
LABEL_62:
                  uint64_t v96 = mlir::mps::LSTMGradientOp::getODSResults(this, 2u);
                  if (v97)
                  {
                    uint64_t v98 = v96;
                    uint64_t v99 = v97;
                    uint64_t v100 = 0;
                    while (1)
                    {
                      uint64_t v101 = mlir::detail::OpResultImpl::getNextResultAtOffset(v98, v100);
                      uint64_t v102 = *(void *)this;
                      unint64_t v103 = *(void *)(v101 + 8) & 0xFFFFFFFFFFFFFFF8;
                      unsigned int v121 = v84 + v100 + 1;
                      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v102, v103, (void **)"result", (void **)6, (int)v84 + (int)v100))break; {
                      if (v99 == ++v100)
                      }
                      {
                        LODWORD(v84) = v84 + v100;
                        goto LABEL_67;
                      }
                    }
                  }
                  else
                  {
LABEL_67:
                    uint64_t v104 = mlir::mps::LSTMGradientOp::getODSResults(this, 3u);
                    if (v105)
                    {
                      uint64_t v106 = v104;
                      uint64_t v107 = v105;
                      uint64_t v108 = 0;
                      while (1)
                      {
                        uint64_t v109 = mlir::detail::OpResultImpl::getNextResultAtOffset(v106, v108);
                        uint64_t v110 = *(void *)this;
                        unint64_t v111 = *(void *)(v109 + 8) & 0xFFFFFFFFFFFFFFF8;
                        unsigned int v121 = v84 + v108 + 1;
                        if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v110, v111, (void **)"result", (void **)6, (int)v84 + (int)v108))break; {
                        if (v107 == ++v108)
                        }
                        {
                          LODWORD(v84) = v84 + v108;
                          goto LABEL_72;
                        }
                      }
                    }
                    else
                    {
LABEL_72:
                      uint64_t v112 = mlir::mps::LSTMGradientOp::getODSResults(this, 4u);
                      uint64_t v114 = v113;
                      if (v113 >= 2)
                      {
                        v119[0] = (void **)"result group starting at #";
                        __int16 v120 = 259;
                        mlir::OpState::emitOpError((uint64_t *)this, v119, (uint64_t)v122);
                        uint64_t v115 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v122, &v121);
                        uint64_t v73 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v115, " requires 0 or 1 element, but found ");
                        uint64_t v118 = v114;
                        goto LABEL_46;
                      }
                      if (!v113) {
                        return 1;
                      }
                      uint64_t v116 = mlir::detail::OpResultImpl::getNextResultAtOffset(v112, 0);
                      if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(v116 + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, v84))return 1; {
                    }
                      }
                  }
                }
              }
            }
          }
          return 0;
        }
      }
    }
  }
LABEL_45:
  v119[0] = (void **)"operand group starting at #";
  __int16 v120 = 259;
  mlir::OpState::emitOpError((uint64_t *)this, v119, (uint64_t)v122);
  uint64_t v72 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v122, &v121);
  uint64_t v73 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v72, " requires 0 or 1 element, but found ");
  uint64_t v118 = v41;
LABEL_46:
  uint64_t v74 = mlir::InFlightDiagnostic::operator<<<unsigned long &>(v73, &v118);
  uint64_t v75 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v74);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v122);
  return v75;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps31(uint64_t a1, void **a2, void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v72 = *MEMORY[0x263EF8340];
  unint64_t v10 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    goto LABEL_17;
  }
  v62[0] = a2;
  v62[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v62)) {
    goto LABEL_17;
  }
  uint64_t v11 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
  uint64_t v54 = a2;
  uint64_t v55 = v11;
  mlir::ShapedType::getShape((mlir::ShapedType *)&v54);
  if (v12)
  {
    uint64_t v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    unint64_t v59 = a2;
    uint64_t v60 = v13;
    mlir::ShapedType::getShape((mlir::ShapedType *)&v59);
    if (v14 != 1) {
      goto LABEL_17;
    }
  }
  uint64_t v15 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
  v57[0] = a2;
  v57[1] = v15;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v57);
  if (mlir::Type::isF16((mlir::Type *)&OperandRange)
    || mlir::Type::isF32((mlir::Type *)&OperandRange)
    || mlir::Type::isBF16((mlir::Type *)&OperandRange)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
  {
    return 1;
  }
LABEL_17:
  __int16 v56 = 261;
  uint64_t v54 = a3;
  uint64_t v55 = a4;
  mlir::Operation::emitOpError(a1, &v54, (uint64_t)v62);
  if (v62[0])
  {
    LODWORD(v59) = 3;
    uint64_t v60 = (uint64_t)" #";
    uint64_t v61 = 2;
    unsigned int v17 = &v59;
    unint64_t v18 = (char *)v63;
    if (v64 >= v65)
    {
      unint64_t v44 = v64 + 1;
      if (v63 <= &v59 && (char *)v63 + 24 * v64 > (char *)&v59)
      {
        int64_t v50 = (char *)&v59 - (unsigned char *)v63;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v44, 24);
        unint64_t v18 = (char *)v63;
        unsigned int v17 = (void ***)((char *)v63 + v50);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v44, 24);
        unsigned int v17 = &v59;
        unint64_t v18 = (char *)v63;
      }
    }
    uint64_t v19 = &v18[24 * v64];
    long long v20 = *(_OWORD *)v17;
    *((void *)v19 + 2) = v17[2];
    *(_OWORD *)uint64_t v19 = v20;
    uint64_t v21 = ++v64;
    if (v62[0])
    {
      LODWORD(v59) = 5;
      uint64_t v60 = a5;
      uint64_t v22 = &v59;
      unint64_t v23 = (char *)v63;
      if (v21 >= v65)
      {
        unint64_t v45 = v21 + 1;
        BOOL v46 = (char *)v63 + 24 * v21 > (char *)&v59;
        if (v63 <= &v59 && v46)
        {
          int64_t v51 = (char *)&v59 - (unsigned char *)v63;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v45, 24);
          unint64_t v23 = (char *)v63;
          uint64_t v22 = (void ***)((char *)v63 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v45, 24);
          uint64_t v22 = &v59;
          unint64_t v23 = (char *)v63;
        }
      }
      unsigned int v24 = &v23[24 * v64];
      long long v25 = *(_OWORD *)v22;
      *((void *)v24 + 2) = v22[2];
      *(_OWORD *)unsigned int v24 = v25;
      uint64_t v26 = ++v64;
      if (v62[0])
      {
        LODWORD(v59) = 3;
        uint64_t v60 = (uint64_t)" must be 0D/1D tensor of floating point or int values, but got ";
        uint64_t v61 = 63;
        uint64_t v27 = &v59;
        uint64_t v28 = (char *)v63;
        if (v26 >= v65)
        {
          unint64_t v47 = v26 + 1;
          BOOL v48 = (char *)v63 + 24 * v26 > (char *)&v59;
          if (v63 <= &v59 && v48)
          {
            int64_t v52 = (char *)&v59 - (unsigned char *)v63;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v47, 24);
            uint64_t v28 = (char *)v63;
            uint64_t v27 = (void ***)((char *)v63 + v52);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v47, 24);
            uint64_t v27 = &v59;
            uint64_t v28 = (char *)v63;
          }
        }
        uint64_t v29 = &v28[24 * v64];
        long long v30 = *(_OWORD *)v27;
        *((void *)v29 + 2) = v27[2];
        *(_OWORD *)uint64_t v29 = v30;
        ++v64;
        if (v62[0])
        {
          unsigned int v31 = &v59;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v59, (uint64_t)a2);
          uint64_t v32 = (char *)v63;
          if (v64 >= v65)
          {
            unint64_t v49 = v64 + 1;
            if (v63 <= &v59 && (char *)v63 + 24 * v64 > (char *)&v59)
            {
              int64_t v53 = (char *)&v59 - (unsigned char *)v63;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v49, 24);
              uint64_t v32 = (char *)v63;
              unsigned int v31 = (void ***)((char *)v63 + v53);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v49, 24);
              unsigned int v31 = &v59;
              uint64_t v32 = (char *)v63;
            }
          }
          uint64_t v33 = &v32[24 * v64];
          long long v34 = *(_OWORD *)v31;
          *((void *)v33 + 2) = v31[2];
          *(_OWORD *)uint64_t v33 = v34;
          ++v64;
        }
      }
    }
  }
  uint64_t v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v62);
  if (v62[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v62);
  }
  if (v71)
  {
    uint64_t v35 = __p;
    if (__p)
    {
      uint64_t v36 = v70;
      unint64_t v37 = __p;
      if (v70 != __p)
      {
        do
          uint64_t v36 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v36 - 1);
        while (v36 != v35);
        unint64_t v37 = __p;
      }
      uint64_t v70 = v35;
      operator delete(v37);
    }
    unsigned int v38 = v67;
    if (v67)
    {
      uint64_t v39 = v68;
      unint64_t v40 = v67;
      if (v68 != v67)
      {
        do
        {
          uint64_t v42 = *--v39;
          uint64_t v41 = v42;
          void *v39 = 0;
          if (v42) {
            MEMORY[0x21667D390](v41, 0x1000C8077774924);
          }
        }
        while (v39 != v38);
        unint64_t v40 = v67;
      }
      unint64_t v68 = v38;
      operator delete(v40);
    }
    if (v63 != v66) {
      free(v63);
    }
  }
  return v16;
}

void mlir::mps::LSTMGradientOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::LSTMOp::getAsmResultNames(uint64_t *a1, void (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  if (*(_DWORD *)(*a1 + 36)) {
    uint64_t v5 = *a1 - 16;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  a2(a3, NextResultAtOffset, "result", 6);
  if (*(_DWORD *)(*a1 + 36)) {
    uint64_t v7 = *a1 - 16;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 1);
  uint64_t v9 = mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0);
  a2(a3, v9, "output_cell", 11);
  uint64_t v10 = *a1;
  int v11 = *(_DWORD *)(*a1 + 36);
  uint64_t v12 = v10 - 16;
  if (v11) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  uint64_t result = mlir::detail::OpResultImpl::getNextResultAtOffset(v13, 2);
  if (v11 != 2)
  {
    uint64_t v15 = mlir::detail::OpResultImpl::getNextResultAtOffset(result, 0);
    return ((uint64_t (*)(uint64_t, uint64_t, const char *, uint64_t))a2)(a3, v15, "training_state", 14);
  }
  return result;
}

uint64_t mlir::mps::LSTMOp::getODSResults(mlir::mps::LSTMOp *this, unsigned int a2)
{
  if (a2)
  {
    if (a2 >= 8)
    {
      int32x4_t v4 = (int32x4_t)xmmword_211EE3A90;
      unsigned int v3 = a2 & 0xFFFFFFF8;
      int32x4_t v5 = 0uLL;
      v6.i64[0] = 0x100000001;
      v6.i64[1] = 0x100000001;
      v7.i64[0] = 0x300000003;
      v7.i64[1] = 0x300000003;
      v8.i64[0] = 0x800000008;
      v8.i64[1] = 0x800000008;
      unsigned int v9 = a2 & 0xFFFFFFF8;
      int32x4_t v10 = 0uLL;
      do
      {
        int32x4_t v5 = vsubq_s32(v5, (int32x4_t)vcgtq_u32((uint32x4_t)v4, v6));
        int32x4_t v10 = vsubq_s32(v10, (int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32((int32x4_t)(*(_OWORD *)&v4 & __PAIR128__(0xFFFFFFFEFFFFFFFELL, 0xFFFFFFFEFFFFFFFELL)), v7)));
        int32x4_t v4 = vaddq_s32(v4, v8);
        v9 -= 8;
      }
      while (v9);
      int v2 = vaddvq_s32(vaddq_s32(v10, v5));
      if (v3 == a2) {
        goto LABEL_11;
      }
    }
    else
    {
      int v2 = 0;
      unsigned int v3 = 0;
    }
    do
    {
      if (v3 > 1) {
        ++v2;
      }
      ++v3;
    }
    while (a2 != v3);
  }
  else
  {
    int v2 = 0;
  }
LABEL_11:
  int v11 = *(_DWORD *)(*(void *)this + 36);
  if (v11) {
    uint64_t result = *(void *)this - 16;
  }
  else {
    uint64_t result = 0;
  }
  if (a2 + (v11 - 3) * v2) {
    return mlir::detail::OpResultImpl::getNextResultAtOffset(result, a2 + (v11 - 3) * v2);
  }
  return result;
}

BOOL mlir::mps::LSTMOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v85 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v71 = v6;
  if (!v6)
  {
    a3(v75, a4);
    if (v75[0])
    {
      LODWORD(v72) = 3;
      uint64_t v73 = "expected DictionaryAttr to set properties";
      uint64_t v74 = 41;
      uint64_t v26 = &v72;
      uint64_t v27 = (char *)v76;
      if (v77 >= v78)
      {
        unint64_t v61 = v77 + 1;
        if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
        {
          int64_t v66 = (char *)&v72 - (unsigned char *)v76;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v61, 24);
          uint64_t v27 = (char *)v76;
          uint64_t v26 = (uint64_t *)((char *)v76 + v66);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v61, 24);
          uint64_t v26 = &v72;
          uint64_t v27 = (char *)v76;
        }
      }
      uint64_t v28 = &v27[24 * v77];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)uint64_t v28 = v29;
      ++v77;
      if (v75[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v75);
      }
    }
    if (!v84) {
      return 0;
    }
    long long v30 = __p;
    if (__p)
    {
      unsigned int v31 = v83;
      uint64_t v32 = __p;
      if (v83 != __p)
      {
        do
          unsigned int v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        uint64_t v32 = __p;
      }
      uint64_t v83 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v80;
    if (!v80) {
      goto LABEL_64;
    }
    uint64_t v33 = v81;
    unint64_t v23 = v80;
    if (v81 == v80)
    {
LABEL_63:
      uint64_t v81 = v21;
      operator delete(v23);
LABEL_64:
      if (v76 != v79) {
        free(v76);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
LABEL_62:
    unint64_t v23 = v80;
    goto LABEL_63;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v71, "cell_activation", 0xFuLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v75, a4);
      if (v75[0])
      {
        LODWORD(v72) = 3;
        uint64_t v74 = 60;
        int32x4_t v10 = &v72;
        int v11 = (char *)v76;
        if (v77 >= v78)
        {
          unint64_t v62 = v77 + 1;
          if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
          {
            int64_t v67 = (char *)&v72 - (unsigned char *)v76;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v62, 24);
            int v11 = (char *)v76;
            int32x4_t v10 = (uint64_t *)((char *)v76 + v67);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v62, 24);
            int32x4_t v10 = &v72;
            int v11 = (char *)v76;
          }
        }
        uint64_t v12 = &v11[24 * v77];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = v10[2];
        *(_OWORD *)uint64_t v12 = v13;
        ++v77;
        if (v75[0])
        {
          uint64_t v14 = &v72;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v72, v9);
          uint64_t v15 = (char *)v76;
          if (v77 >= v78)
          {
            unint64_t v63 = v77 + 1;
            if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
            {
              int64_t v68 = (char *)&v72 - (unsigned char *)v76;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v63, 24);
              uint64_t v15 = (char *)v76;
              uint64_t v14 = (uint64_t *)((char *)v76 + v68);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v63, 24);
              uint64_t v14 = &v72;
              uint64_t v15 = (char *)v76;
            }
          }
          uint64_t v16 = &v15[24 * v77];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = v14[2];
          *(_OWORD *)uint64_t v16 = v17;
          ++v77;
          if (v75[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v75);
          }
        }
      }
      if (!v84) {
        return 0;
      }
      unint64_t v18 = __p;
      if (__p)
      {
        uint64_t v19 = v83;
        long long v20 = __p;
        if (v83 != __p)
        {
          do
            uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          long long v20 = __p;
        }
        uint64_t v83 = v18;
        operator delete(v20);
      }
      uint64_t v21 = v80;
      if (!v80) {
        goto LABEL_64;
      }
      uint64_t v22 = v81;
      unint64_t v23 = v80;
      if (v81 == v80) {
        goto LABEL_63;
      }
      do
      {
        uint64_t v25 = *--v22;
        uint64_t v24 = v25;
        void *v22 = 0;
        if (v25) {
          MEMORY[0x21667D390](v24, 0x1000C8077774924);
        }
      }
      while (v22 != v21);
      goto LABEL_62;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v71, "fgate_activation", 0x10uLL);
  if (v36)
  {
    uint64_t v37 = v36;
    if (*(_UNKNOWN **)(*(void *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v75, a4);
      if (v75[0])
      {
        LODWORD(v72) = 3;
        uint64_t v74 = 61;
        unsigned int v38 = &v72;
        uint64_t v39 = (char *)v76;
        if (v77 >= v78)
        {
          unint64_t v64 = v77 + 1;
          if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
          {
            int64_t v69 = (char *)&v72 - (unsigned char *)v76;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v64, 24);
            uint64_t v39 = (char *)v76;
            unsigned int v38 = (uint64_t *)((char *)v76 + v69);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v64, 24);
            unsigned int v38 = &v72;
            uint64_t v39 = (char *)v76;
          }
        }
        unint64_t v40 = &v39[24 * v77];
        long long v41 = *(_OWORD *)v38;
        *((void *)v40 + 2) = v38[2];
        *(_OWORD *)unint64_t v40 = v41;
        ++v77;
        if (v75[0])
        {
          uint64_t v42 = &v72;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v72, v37);
          uint64_t v43 = (char *)v76;
          if (v77 >= v78)
          {
            unint64_t v65 = v77 + 1;
            if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
            {
              int64_t v70 = (char *)&v72 - (unsigned char *)v76;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v65, 24);
              uint64_t v43 = (char *)v76;
              uint64_t v42 = (uint64_t *)((char *)v76 + v70);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v65, 24);
              uint64_t v42 = &v72;
              uint64_t v43 = (char *)v76;
            }
          }
          unint64_t v44 = &v43[24 * v77];
          long long v45 = *(_OWORD *)v42;
          *((void *)v44 + 2) = v42[2];
          *(_OWORD *)unint64_t v44 = v45;
          ++v77;
          if (v75[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v75);
          }
        }
      }
      if (!v84) {
        return 0;
      }
      BOOL v46 = __p;
      if (__p)
      {
        unint64_t v47 = v83;
        BOOL v48 = __p;
        if (v83 != __p)
        {
          do
            unint64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          BOOL v48 = __p;
        }
        uint64_t v83 = v46;
        operator delete(v48);
      }
      uint64_t v21 = v80;
      if (!v80) {
        goto LABEL_64;
      }
      unint64_t v49 = v81;
      unint64_t v23 = v80;
      if (v81 == v80) {
        goto LABEL_63;
      }
      do
      {
        uint64_t v51 = *--v49;
        uint64_t v50 = v51;
        *unint64_t v49 = 0;
        if (v51) {
          MEMORY[0x21667D390](v50, 0x1000C8077774924);
        }
      }
      while (v49 != v21);
      goto LABEL_62;
    }
    a1[1] = v36;
  }
  uint64_t v52 = mlir::DictionaryAttr::get((uint64_t)&v71, "gate_layout", 0xBuLL);
  uint64_t v72 = v52;
  if (v52)
  {
    if (*(_UNKNOWN **)(*(void *)v52 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id)
    {
      a3(v75, a4);
LABEL_87:
      mlir::InFlightDiagnostic::append<mlir::Attribute>(v53, &v72);
LABEL_88:
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v75);
      return 0;
    }
    a1[2] = v52;
  }
  uint64_t v54 = mlir::DictionaryAttr::get((uint64_t)&v71, "igate_activation", 0x10uLL);
  uint64_t v72 = v54;
  if (v54)
  {
    if (*(_UNKNOWN **)(*(void *)v54 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v75, a4);
LABEL_86:
      uint64_t v53 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v75, v55);
      goto LABEL_87;
    }
    a1[3] = v54;
  }
  uint64_t v56 = mlir::DictionaryAttr::get((uint64_t)&v71, "ogate_activation", 0x10uLL);
  uint64_t v72 = v56;
  if (v56)
  {
    if (*(_UNKNOWN **)(*(void *)v56 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v75, a4);
      goto LABEL_86;
    }
    a1[4] = v56;
  }
  uint64_t v57 = mlir::DictionaryAttr::get((uint64_t)&v71, "training", 8uLL);
  uint64_t v72 = v57;
  if (v57)
  {
    if (*(_UNKNOWN **)(*(void *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v75, a4);
      goto LABEL_87;
    }
    a1[5] = v57;
  }
  uint64_t v58 = mlir::DictionaryAttr::get((uint64_t)&v71, "zgate_activation", 0x10uLL);
  uint64_t v72 = v58;
  if (v58)
  {
    if (*(_UNKNOWN **)(*(void *)v58 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v75, a4);
      goto LABEL_86;
    }
    a1[6] = v58;
  }
  uint64_t v60 = (void *)mlir::DictionaryAttr::get((uint64_t)&v71, "operandSegmentSizes", 0x13uLL);
  if (!v60)
  {
    uint64_t v60 = (void *)mlir::DictionaryAttr::get((uint64_t)&v71, "operand_segment_sizes", 0x15uLL);
    if (!v60)
    {
      a3(v75, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v75, "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.");
      goto LABEL_88;
    }
  }
  return mlir::convertFromAttribute(a1 + 7, (const char *)7, v60, a3, a4) != 0;
}

uint64_t mlir::mps::LSTMOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v59[6] = *MEMORY[0x263EF8340];
  uint64_t v56 = a1;
  uint64_t v57 = v59;
  uint64_t v58 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v56, (uint64_t)"cell_activation", 15, *a2);
    uint64_t v6 = v5;
    unsigned int v7 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v7 = v58;
    }
    uint64_t v8 = (uint64_t *)((char *)v57 + 16 * v7);
    *uint64_t v8 = NamedAttr;
    v8[1] = v6;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v9 = a2[1];
  if (v9)
  {
    uint64_t v10 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"fgate_activation", 16, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v13 = v58;
    }
    uint64_t v14 = (uint64_t *)((char *)v57 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"gate_layout", 11, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v19 = v58;
    }
    long long v20 = (uint64_t *)((char *)v57 + 16 * v19);
    uint64_t *v20 = v16;
    v20[1] = v18;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"igate_activation", 16, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v25 = v58;
    }
    uint64_t v26 = (uint64_t *)((char *)v57 + 16 * v25);
    uint64_t *v26 = v22;
    v26[1] = v24;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"ogate_activation", 16, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v31 = v58;
    }
    uint64_t v32 = (uint64_t *)((char *)v57 + 16 * v31);
    uint64_t *v32 = v28;
    v32[1] = v30;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v33 = a2[5];
  if (v33)
  {
    uint64_t v34 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"training", 8, v33);
    uint64_t v36 = v35;
    unsigned int v37 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v37 = v58;
    }
    unsigned int v38 = (uint64_t *)((char *)v57 + 16 * v37);
    uint64_t *v38 = v34;
    v38[1] = v36;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v39 = a2[6];
  if (v39)
  {
    uint64_t v40 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"zgate_activation", 16, v39);
    uint64_t v42 = v41;
    unsigned int v43 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      unsigned int v43 = v58;
    }
    unint64_t v44 = (uint64_t *)((char *)v57 + 16 * v43);
    uint64_t *v44 = v40;
    v44[1] = v42;
    LODWORD(v58) = v58 + 1;
  }
  uint64_t v45 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 7), 7);
  uint64_t v46 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"operandSegmentSizes", 19, v45);
  uint64_t v48 = v47;
  unsigned int v49 = v58;
  if (v58 >= HIDWORD(v58))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
    unsigned int v49 = v58;
  }
  uint64_t v50 = (uint64_t *)((char *)v57 + 16 * v49);
  *uint64_t v50 = v46;
  v50[1] = v48;
  BOOL v51 = __CFADD__(v58, 1);
  uint64_t v52 = (v58 + 1);
  LODWORD(v58) = v58 + 1;
  if (v51)
  {
    uint64_t DictionaryAttr = 0;
    uint64_t v54 = v57;
    if (v57 == v59) {
      return DictionaryAttr;
    }
    goto LABEL_36;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v56, (uint64_t *)v57, v52);
  uint64_t v54 = v57;
  if (v57 != v59) {
LABEL_36:
  }
    free(v54);
  return DictionaryAttr;
}

unint64_t mlir::mps::LSTMOp::computePropertiesHash(unint64_t *a1)
{
  uint64_t v114 = *MEMORY[0x263EF8340];
  unint64_t v1 = *a1;
  int v2 = &unk_267770000;
  {
    uint64_t v86 = a1;
    unint64_t v94 = v1;
    int v2 = &unk_267770000;
    int v33 = v32;
    a1 = v86;
    unint64_t v1 = v94;
    if (v33)
    {
      unint64_t v34 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v34 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v34;
      a1 = v86;
      unint64_t v1 = v94;
      int v2 = (void *)&unk_267770000;
    }
  }
  uint64_t v3 = v2[385];
  unint64_t v4 = a1[1];
  {
    unint64_t v87 = a1;
    unint64_t v95 = v1;
    uint64_t v70 = v3;
    unint64_t v78 = v4;
    uint64_t v3 = v70;
    unint64_t v4 = v78;
    int v2 = &unk_267770000;
    int v36 = v35;
    a1 = v87;
    unint64_t v1 = v95;
    if (v36)
    {
      unint64_t v37 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v37 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v37;
      uint64_t v3 = v70;
      unint64_t v4 = v78;
      a1 = v87;
      unint64_t v1 = v95;
      int v2 = (void *)&unk_267770000;
    }
  }
  uint64_t v5 = v2[385];
  unint64_t v6 = a1[2];
  {
    uint64_t v88 = a1;
    unint64_t v96 = v1;
    uint64_t v71 = v3;
    unint64_t v79 = v4;
    unint64_t v58 = v6;
    uint64_t v63 = v5;
    unint64_t v6 = v58;
    uint64_t v5 = v63;
    uint64_t v3 = v71;
    unint64_t v4 = v79;
    int v2 = &unk_267770000;
    int v39 = v38;
    a1 = v88;
    unint64_t v1 = v96;
    if (v39)
    {
      unint64_t v40 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v40 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v40;
      unint64_t v6 = v58;
      uint64_t v5 = v63;
      uint64_t v3 = v71;
      unint64_t v4 = v79;
      a1 = v88;
      unint64_t v1 = v96;
      int v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v7 = HIDWORD(v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v6) ^ HIDWORD(v6));
  unint64_t v108 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) ^ ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) >> 47));
  unint64_t v9 = a1[3];
  {
    uint64_t v89 = a1;
    unint64_t v97 = v1;
    uint64_t v72 = v3;
    unint64_t v80 = v4;
    unint64_t v59 = v9;
    uint64_t v64 = v5;
    unint64_t v9 = v59;
    uint64_t v5 = v64;
    uint64_t v3 = v72;
    unint64_t v4 = v80;
    int v2 = &unk_267770000;
    int v42 = v41;
    a1 = v89;
    unint64_t v1 = v97;
    if (v42)
    {
      unint64_t v43 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v43 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v43;
      unint64_t v9 = v59;
      uint64_t v5 = v64;
      uint64_t v3 = v72;
      unint64_t v4 = v80;
      a1 = v89;
      unint64_t v1 = v97;
      int v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v10 = HIDWORD(v9);
  unint64_t v11 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v9) ^ HIDWORD(v9));
  unint64_t v107 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) ^ ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) >> 47));
  unint64_t v12 = a1[4];
  {
    uint64_t v90 = a1;
    unint64_t v98 = v1;
    uint64_t v73 = v3;
    unint64_t v81 = v4;
    unint64_t v60 = v12;
    uint64_t v65 = v5;
    unint64_t v12 = v60;
    uint64_t v5 = v65;
    uint64_t v3 = v73;
    unint64_t v4 = v81;
    int v2 = &unk_267770000;
    int v45 = v44;
    a1 = v90;
    unint64_t v1 = v98;
    if (v45)
    {
      unint64_t v46 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v46 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v46;
      unint64_t v12 = v60;
      uint64_t v5 = v65;
      uint64_t v3 = v73;
      unint64_t v4 = v81;
      a1 = v90;
      unint64_t v1 = v98;
      int v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v13 = HIDWORD(v12);
  unint64_t v14 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v12) ^ HIDWORD(v12));
  unint64_t v106 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) ^ ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) >> 47));
  unint64_t v15 = a1[5];
  {
    uint64_t v91 = a1;
    unint64_t v99 = v1;
    uint64_t v74 = v3;
    unint64_t v82 = v4;
    unint64_t v61 = v15;
    uint64_t v66 = v5;
    unint64_t v15 = v61;
    uint64_t v5 = v66;
    uint64_t v3 = v74;
    unint64_t v4 = v82;
    int v2 = &unk_267770000;
    int v48 = v47;
    a1 = v91;
    unint64_t v1 = v99;
    if (v48)
    {
      unint64_t v49 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v49 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v49;
      unint64_t v15 = v61;
      uint64_t v5 = v66;
      uint64_t v3 = v74;
      unint64_t v4 = v82;
      a1 = v91;
      unint64_t v1 = v99;
      int v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v16 = HIDWORD(v15);
  unint64_t v17 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v15) ^ HIDWORD(v15));
  unint64_t v105 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) ^ ((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) >> 47));
  unint64_t v18 = a1[6];
  {
    uint64_t v92 = a1;
    unint64_t v100 = v1;
    uint64_t v75 = v3;
    unint64_t v83 = v4;
    unint64_t v62 = v18;
    uint64_t v67 = v5;
    unint64_t v18 = v62;
    uint64_t v5 = v67;
    uint64_t v3 = v75;
    unint64_t v4 = v83;
    int v2 = &unk_267770000;
    int v51 = v50;
    a1 = v92;
    unint64_t v1 = v100;
    if (v51)
    {
      unint64_t v52 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v52 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v52;
      unint64_t v18 = v62;
      uint64_t v5 = v67;
      uint64_t v3 = v75;
      unint64_t v4 = v83;
      a1 = v92;
      unint64_t v1 = v100;
      int v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v19 = HIDWORD(v18);
  unint64_t v20 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v18) ^ HIDWORD(v18));
  unint64_t v104 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v19 ^ (v20 >> 47) ^ v20)) ^ ((0x9DDFEA08EB382D69 * (v19 ^ (v20 >> 47) ^ v20)) >> 47));
  {
    uint64_t v93 = a1;
    unint64_t v101 = v1;
    uint64_t v76 = v3;
    unint64_t v84 = v4;
    uint64_t v68 = v5;
    uint64_t v5 = v68;
    uint64_t v3 = v76;
    unint64_t v1 = v101;
    int v2 = &unk_267770000;
    int v54 = v53;
    unint64_t v4 = v84;
    a1 = v93;
    if (v54)
    {
      unint64_t v55 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v55 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v55;
      uint64_t v5 = v68;
      uint64_t v3 = v76;
      unint64_t v4 = v84;
      a1 = v93;
      unint64_t v1 = v101;
      int v2 = (void *)&unk_267770000;
    }
  }
  uint64_t v21 = v2[385];
  unint64_t v22 = a1[8];
  unint64_t v23 = 0xB492B66FBE98F273 * a1[7];
  unint64_t v24 = 0x9AE16A3B2F90404FLL * *(unint64_t *)((char *)a1 + 76);
  uint64_t v25 = __ROR8__(v23 - v22, 43)
      - 0x3C5A37A36834CED9 * *(unint64_t *)((char *)a1 + 68)
      + __ROR8__(v24 ^ v21, 30);
  uint64_t v26 = v21 + __ROR8__(v22 ^ 0xC949D7C7509E6557, 20) + v23 - v24 + 28;
  unint64_t v103 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69
         * (v26 ^ ((0x9DDFEA08EB382D69 * (v25 ^ v26)) >> 47) ^ (0x9DDFEA08EB382D69 * (v25 ^ v26)))) ^ ((0x9DDFEA08EB382D69 * (v26 ^ ((0x9DDFEA08EB382D69 * (v25 ^ v26)) >> 47) ^ (0x9DDFEA08EB382D69 * (v25 ^ v26)))) >> 47));
  uint64_t v112 = 0;
  memset(v111, 0, sizeof(v111));
  memset(v110, 0, sizeof(v110));
  long long v109 = 0u;
  {
    unint64_t v102 = v1;
    uint64_t v77 = v3;
    unint64_t v85 = v4;
    uint64_t v69 = v5;
    uint64_t v5 = v69;
    uint64_t v3 = v77;
    unint64_t v4 = v85;
    unint64_t v1 = v102;
    int v2 = &unk_267770000;
    if (v56)
    {
      unint64_t v57 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v57 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v57;
      uint64_t v5 = v69;
      uint64_t v3 = v77;
      unint64_t v4 = v85;
      unint64_t v1 = v102;
      int v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v27 = 0x9DDFEA08EB382D69 * ((v5 + 8 * v4) ^ HIDWORD(v4));
  unint64_t v28 = 0x9DDFEA08EB382D69 * (HIDWORD(v4) ^ (v27 >> 47) ^ v27);
  unint64_t v29 = HIDWORD(v1);
  unint64_t v30 = 0x9DDFEA08EB382D69 * ((v3 + 8 * v1) ^ HIDWORD(v1));
  uint64_t v113 = v2[385];
  *(void *)&long long v109 = 0x9DDFEA08EB382D69
                   * ((0x9DDFEA08EB382D69 * (v29 ^ (v30 >> 47) ^ v30)) ^ ((0x9DDFEA08EB382D69
                                                                           * (v29 ^ (v30 >> 47) ^ v30)) >> 47));
  *((void *)&v109 + 1) = 0x9DDFEA08EB382D69 * (v28 ^ (v28 >> 47));
  return llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>((llvm::hashing::detail::hash_combine_recursive_helper *)&v109, 0, v110, (char *)v111, (uint64_t *)&v108, (uint64_t *)&v107, (uint64_t *)&v106, (uint64_t *)&v105, (uint64_t *)&v104, (uint64_t *)&v103);
}

uint64_t mlir::mps::LSTMOp::getInherentAttr(mlir::MLIRContext *a1, void *a2, char *__s1, size_t __n)
{
  uint64_t result = 0;
  switch(__n)
  {
    case 8uLL:
      if (memcmp(__s1, "training", __n)) {
        goto LABEL_21;
      }
      return a2[5];
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x14uLL:
      goto LABEL_21;
    case 0xBuLL:
      if (memcmp(__s1, "gate_layout", __n)) {
        goto LABEL_21;
      }
      return a2[2];
    case 0xFuLL:
      if (*(void *)__s1 != 0x7463615F6C6C6563 || *(void *)(__s1 + 7) != 0x6E6F697461766974) {
        goto LABEL_21;
      }
      return *a2;
    case 0x10uLL:
      if (!memcmp(__s1, "fgate_activation", __n))
      {
        uint64_t result = a2[1];
      }
      else if (!memcmp(__s1, "igate_activation", __n))
      {
        uint64_t result = a2[3];
      }
      else if (*(void *)__s1 == 0x63615F657461676FLL && *((void *)__s1 + 1) == 0x6E6F697461766974)
      {
        uint64_t result = a2[4];
      }
      else if (!memcmp(__s1, "zgate_activation", __n))
      {
        uint64_t result = a2[6];
      }
      else
      {
LABEL_21:
        uint64_t result = 0;
      }
      break;
    case 0x13uLL:
      if (memcmp(__s1, "operandSegmentSizes", __n)) {
        goto LABEL_21;
      }
      goto LABEL_23;
    case 0x15uLL:
      if (memcmp(__s1, "operand_segment_sizes", __n)) {
        goto LABEL_21;
      }
LABEL_23:
      uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 7), 7);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::mps::LSTMOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, void *a4)
{
  unint64_t v7 = (void *)result;
  switch(__n)
  {
    case 8uLL:
      uint64_t result = memcmp(__s1, "training", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
            unint64_t v15 = a4;
          }
          else {
            unint64_t v15 = 0;
          }
          v7[5] = v15;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      uint64_t result = memcmp(__s1, "gate_layout", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id) {
            unint64_t v8 = a4;
          }
          else {
            unint64_t v8 = 0;
          }
          v7[2] = v8;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    case 0xFuLL:
      if (*(void *)__s1 == 0x7463615F6C6C6563 && *(void *)(__s1 + 7) == 0x6E6F697461766974)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
            unint64_t v10 = a4;
          }
          else {
            unint64_t v10 = 0;
          }
          *(void *)uint64_t result = v10;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "fgate_activation", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "igate_activation", __n);
        if (result)
        {
          if (*(void *)__s1 == 0x63615F657461676FLL && *((void *)__s1 + 1) == 0x6E6F697461766974)
          {
            if (a4)
            {
              if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
                unint64_t v18 = a4;
              }
              else {
                unint64_t v18 = 0;
              }
              uint64_t v7[4] = v18;
            }
            else
            {
              uint64_t v7[4] = 0;
            }
          }
          else
          {
            uint64_t result = memcmp(__s1, "zgate_activation", __n);
            if (!result)
            {
              if (a4)
              {
                if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
                  unint64_t v12 = a4;
                }
                else {
                  unint64_t v12 = 0;
                }
                v7[6] = v12;
              }
              else
              {
                v7[6] = 0;
              }
            }
          }
        }
        else if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
            unint64_t v17 = a4;
          }
          else {
            unint64_t v17 = 0;
          }
          v7[3] = v17;
        }
        else
        {
          v7[3] = 0;
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id) {
          unint64_t v16 = a4;
        }
        else {
          unint64_t v16 = 0;
        }
        v7[1] = v16;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x13uLL:
      uint64_t result = memcmp(__s1, "operandSegmentSizes", __n);
      if (!result) {
        goto LABEL_35;
      }
      break;
    case 0x15uLL:
      uint64_t result = memcmp(__s1, "operand_segment_sizes", __n);
      if (!result)
      {
LABEL_35:
        if (a4)
        {
          uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
          unint64_t v13 = result ? a4 : 0;
          unint64_t v19 = v13;
          if (result)
          {
            uint64_t result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v19);
            if (result == 7)
            {
              uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v19);
              if (v14) {
                uint64_t result = (uint64_t)memmove(v7 + 7, (const void *)result, 4 * v14);
              }
            }
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::LSTMOp::populateInherentAttrs(mlir::MLIRContext *a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"cell_activation", 15, *a2);
  }
  uint64_t v6 = a2[1];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"fgate_activation", 16, v6);
  }
  uint64_t v7 = a2[2];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"gate_layout", 11, v7);
  }
  uint64_t v8 = a2[3];
  if (v8) {
    mlir::NamedAttrList::append(a3, (uint64_t)"igate_activation", 16, v8);
  }
  uint64_t v9 = a2[4];
  if (v9) {
    mlir::NamedAttrList::append(a3, (uint64_t)"ogate_activation", 16, v9);
  }
  uint64_t v10 = a2[5];
  if (v10) {
    mlir::NamedAttrList::append(a3, (uint64_t)"training", 8, v10);
  }
  uint64_t v11 = a2[6];
  if (v11) {
    mlir::NamedAttrList::append(a3, (uint64_t)"zgate_activation", 16, v11);
  }
  uint64_t v12 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 7), 7);

  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v12);
}

BOOL mlir::mps::LSTMOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v8, (void **)"cell_activation", (const char *)0xF, a3, a4))
  {
    uint64_t v9 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v9, (void **)"fgate_activation", (const char *)0x10, a3, a4))
    {
      uint64_t v10 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps30(v10, (void **)"gate_layout", (const char *)0xB, a3, a4))
      {
        uint64_t v11 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v11, (void **)"igate_activation", (const char *)0x10, a3, a4))
        {
          uint64_t v12 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v12, (void **)"ogate_activation", (const char *)0x10, a3, a4))
          {
            uint64_t v13 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 40));
            if (!v13
              || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v13, (void **)"training", (const char *)8, a3, a4))
            {
              uint64_t v14 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v14, (void **)"zgate_activation", (const char *)0x10, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

BOOL mlir::mps::LSTMOp::readProperties(uint64_t a1, uint64_t a2)
{
  v10[24] = *MEMORY[0x263EF8340];
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMOpGenericAdaptorBase::Properties>(a2);
  if (!mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 1)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::LSTMGateLayoutAttr>(a1, v3 + 2)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 3)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 4))
  {
    return 0;
  }
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) <= 5)
  {
    uint64_t v9 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v9)) {
      return 0;
    }
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v9) >= 8)
    {
      v7[0] = (uint64_t)"size mismatch for operand/result_segment_size";
      __int16 v8 = 259;
      (*(void (**)(void *__return_ptr, uint64_t, uint64_t *))(*(void *)a1 + 16))(v10, a1, v7);
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v10);
      return 0;
    }
    unint64_t v4 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v9);
    if (v5) {
      memmove(v3 + 7, v4, 4 * v5);
    }
  }
  if (mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 5)
    && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 6))
  {
    v7[0] = a1;
    v7[1] = (uint64_t)(v3 + 7);
    return mlir::mps::GRUGradientOp::readProperties(mlir::DialectBytecodeReader &,mlir::OperationState &)::$_0::operator()(v7) != 0;
  }
  return 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::mps::LSTMOp::writeProperties(uint64_t a1, uint64_t a2)
{
  if (HIBYTE(*(_DWORD *)(*(void *)a1 + 44))) {
    unint64_t v4 = *(void *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(void *)a1 + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)v4);
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 8));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 16));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 24));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 32));
  if ((*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2) <= 5)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(void *)a1 + 24));
    uint64_t v6 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v4 + 56, 7);
    (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, v6);
  }
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 40));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 48));
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2);
  if (result >= 6)
  {
    return mlir::DialectBytecodeWriter::writeSparseArray<int>(a2, (int *)(v4 + 56), 7);
  }
  return result;
}

BOOL mlir::mps::LSTMOp::getTraining(mlir::mps::LSTMOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  return *(void *)(v1 + 40) != 0;
}

mlir::MLIRContext *mlir::mps::LSTMOp::populateDefaultProperties(uint64_t a1, mlir::MLIRContext **a2)
{
  uint64_t v12 = *(void **)(a1 + 8);
  uint64_t result = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  unint64_t v4 = result;
  if (a2[3])
  {
    if (a2[1]) {
      goto LABEL_3;
    }
  }
  else
  {
    unsigned int v11 = 3;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(result);
    uint64_t v12 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
    uint64_t v13 = v4;
    uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v11);
    a2[3] = result;
    if (a2[1])
    {
LABEL_3:
      if (a2[6]) {
        goto LABEL_4;
      }
      goto LABEL_10;
    }
  }
  unsigned int v11 = 3;
  uint64_t v6 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  uint64_t v12 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  uint64_t v13 = v4;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v6, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v11);
  a2[1] = result;
  if (a2[6])
  {
LABEL_4:
    if (a2[4]) {
      goto LABEL_5;
    }
    goto LABEL_11;
  }
LABEL_10:
  unsigned int v11 = 2;
  uint64_t v7 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  uint64_t v12 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  uint64_t v13 = v4;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v7, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v11);
  a2[6] = result;
  if (a2[4])
  {
LABEL_5:
    if (*a2) {
      goto LABEL_6;
    }
    goto LABEL_12;
  }
LABEL_11:
  unsigned int v11 = 3;
  __int16 v8 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  uint64_t v12 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  uint64_t v13 = v4;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v8, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v11);
  a2[4] = result;
  if (*a2)
  {
LABEL_6:
    if (a2[2]) {
      return result;
    }
LABEL_13:
    unsigned int v11 = 0;
    uint64_t v10 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
    uint64_t v12 = &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id;
    uint64_t v13 = v4;
    uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::LSTMGateLayoutAttrStorage,mlir::mps::LSTMGateLayout>(v10, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25LSTMGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18LSTMGateLayoutAttrEJNS2_14LSTMGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id, &v11);
    a2[2] = result;
    return result;
  }
LABEL_12:
  unsigned int v11 = 2;
  uint64_t v9 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  uint64_t v12 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  uint64_t v13 = v4;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v9, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v11);
  *a2 = result;
  if (!a2[2]) {
    goto LABEL_13;
  }
  return result;
}

uint64_t mlir::mps::LSTMOp::verifyInvariantsImpl(mlir::mps::LSTMOp *this)
{
  v87[24] = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  uint64_t v7 = v3[2];
  uint64_t v6 = v3[3];
  uint64_t v9 = v3[4];
  uint64_t v8 = v3[5];
  uint64_t v10 = v3[6];
  v87[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v6, (void **)"igate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v87))return 0; {
  v87[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v5, (void **)"fgate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v87))return 0; {
  v87[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v10, (void **)"zgate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v87))return 0; {
  v87[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v9, (void **)"ogate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v87))return 0; {
  v87[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v4, (void **)"cell_activation", (const char *)0xF, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v87))return 0; {
  v87[0] = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps30(v7, (void **)"gate_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps30(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v87))return 0; {
  v87[0] = *(void *)this;
  }
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v8, (void **)"training", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v87))return 0; {
  unsigned int v86 = 0;
  }
  unint64_t v11 = *(unsigned int *)(*(void *)this + 44);
  uint64_t v12 = *(void *)this + 16 * ((v11 >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v12 = 0;
  }
  uint64_t v13 = *(unsigned int *)(v12 + 56);
  if ((v11 & 0x800000) != 0)
  {
    uint64_t v14 = *(void *)(*(void *)this + 72);
    if (v13) {
      goto LABEL_15;
    }
  }
  else
  {
    uint64_t v14 = 0;
    if (v13)
    {
LABEL_15:
      uint64_t v15 = v14 + 24;
      do
      {
        uint64_t v16 = *(void *)this;
        unint64_t v17 = *(void *)(*(void *)v15 + 8) & 0xFFFFFFFFFFFFFFF8;
        unsigned int v18 = v86++;
        if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v16, v17, (void **)"operand", (void **)7, v18))return 0; {
        v15 += 32;
        }
      }
      while (--v13);
    }
  }
  uint64_t ODSOperands = mlir::mps::GRUOp::getODSOperands(this, 1u);
  if (v20)
  {
    uint64_t v21 = v20;
    uint64_t v22 = ODSOperands + 24;
    do
    {
      uint64_t v23 = *(void *)this;
      unint64_t v24 = *(void *)(*(void *)v22 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v25 = v86++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v23, v24, (void **)"operand", (void **)7, v25))return 0; {
      v22 += 32;
      }
    }
    while (--v21);
  }
  uint64_t v26 = mlir::mps::GRUOp::getODSOperands(this, 2u);
  uint64_t v28 = v27;
  if (v27 >= 2) {
    goto LABEL_35;
  }
  if (v27)
  {
    uint64_t v29 = *(void *)(v26 + 24);
    uint64_t v30 = *(void *)this;
    unint64_t v31 = *(void *)(v29 + 8) & 0xFFFFFFFFFFFFFFF8;
    unsigned int v32 = v86++;
    if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v30, v31, (void **)"operand", (void **)7, v32))return 0; {
  }
    }
  uint64_t v33 = mlir::mps::GRUOp::getODSOperands(this, 3u);
  uint64_t v28 = v34;
  if (v34 < 2)
  {
    if (v34)
    {
      uint64_t v35 = *(void *)(v33 + 24);
      uint64_t v36 = *(void *)this;
      unint64_t v37 = *(void *)(v35 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v38 = v86++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v36, v37, (void **)"operand", (void **)7, v38))return 0; {
    }
      }
    uint64_t v39 = mlir::mps::GRUOp::getODSOperands(this, 4u);
    uint64_t v28 = v40;
    if (v40 < 2)
    {
      if (v40)
      {
        uint64_t v41 = *(void *)(v39 + 24);
        uint64_t v42 = *(void *)this;
        unint64_t v43 = *(void *)(v41 + 8) & 0xFFFFFFFFFFFFFFF8;
        unsigned int v44 = v86++;
        if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v42, v43, (void **)"operand", (void **)7, v44))return 0; {
      }
        }
      uint64_t v45 = mlir::mps::GRUOp::getODSOperands(this, 5u);
      uint64_t v28 = v46;
      if (v46 < 2)
      {
        if (!v46
          || (uint64_t v47 = *(void *)(v45 + 24),
              uint64_t v48 = *(void *)this,
              unint64_t v49 = *(void *)(v47 + 8) & 0xFFFFFFFFFFFFFFF8,
              unsigned int v50 = v86,
              ++v86,
              mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v48, v49, (void **)"operand", (void **)7, v50)))
        {
          uint64_t v51 = mlir::mps::GRUOp::getODSOperands(this, 6u);
          uint64_t v28 = v52;
          if (v52 >= 2) {
            goto LABEL_35;
          }
          if (!v52
            || (uint64_t v57 = *(void *)(v51 + 24),
                uint64_t v58 = *(void *)this,
                unint64_t v59 = (void **)(*(void *)(v57 + 8) & 0xFFFFFFFFFFFFFFF8),
                unsigned int v60 = v86,
                ++v86,
                mlir::mps::__mlir_ods_local_type_constraint_MPSOps31(v58, v59, (void **)"operand", 7, v60)))
          {
            unsigned int v86 = 0;
            uint64_t ODSResults = mlir::mps::LSTMOp::getODSResults(this, 0);
            if (v62)
            {
              uint64_t v63 = ODSResults;
              uint64_t v64 = v62;
              uint64_t v65 = 0;
              while (1)
              {
                uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v63, v65);
                uint64_t v67 = *(void *)this;
                unint64_t v68 = *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8;
                unsigned int v86 = v65 + 1;
                if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v67, v68, (void **)"result", (void **)6, v65))break; {
                if (v64 == ++v65)
                }
                  goto LABEL_45;
              }
            }
            else
            {
              LODWORD(v65) = 0;
LABEL_45:
              uint64_t v69 = mlir::mps::LSTMOp::getODSResults(this, 1u);
              if (v70)
              {
                uint64_t v71 = v69;
                uint64_t v72 = v70;
                uint64_t v73 = 0;
                while (1)
                {
                  uint64_t v74 = mlir::detail::OpResultImpl::getNextResultAtOffset(v71, v73);
                  uint64_t v75 = *(void *)this;
                  unint64_t v76 = *(void *)(v74 + 8) & 0xFFFFFFFFFFFFFFF8;
                  unsigned int v86 = v65 + v73 + 1;
                  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v75, v76, (void **)"result", (void **)6, (int)v65 + (int)v73))break; {
                  if (v72 == ++v73)
                  }
                  {
                    LODWORD(v65) = v65 + v73;
                    goto LABEL_50;
                  }
                }
              }
              else
              {
LABEL_50:
                uint64_t v77 = mlir::mps::LSTMOp::getODSResults(this, 2u);
                uint64_t v79 = v78;
                if (v78 >= 2)
                {
                  v84[0] = (void **)"result group starting at #";
                  __int16 v85 = 259;
                  mlir::OpState::emitOpError((uint64_t *)this, v84, (uint64_t)v87);
                  uint64_t v80 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v87, &v86);
                  uint64_t v54 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v80, " requires 0 or 1 element, but found ");
                  uint64_t v83 = v79;
                  goto LABEL_36;
                }
                if (!v78) {
                  return 1;
                }
                uint64_t v81 = mlir::detail::OpResultImpl::getNextResultAtOffset(v77, 0);
                if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(v81 + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, v65))return 1; {
              }
                }
            }
          }
        }
        return 0;
      }
    }
  }
LABEL_35:
  v84[0] = (void **)"operand group starting at #";
  __int16 v85 = 259;
  mlir::OpState::emitOpError((uint64_t *)this, v84, (uint64_t)v87);
  uint64_t v53 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v87, &v86);
  uint64_t v54 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v53, " requires 0 or 1 element, but found ");
  uint64_t v83 = v28;
LABEL_36:
  uint64_t v55 = mlir::InFlightDiagnostic::operator<<<unsigned long &>(v54, &v83);
  uint64_t v56 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v55);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v87);
  return v56;
}

void mlir::mps::LSTMOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::LeakyReluOpGenericAdaptorBase::LeakyReluOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.leaky_relu", 14, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::LeakyReluOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::LessThanOpGenericAdaptorBase::LessThanOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.less", 8, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::LessThanOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::LessThanOrEqualToOpGenericAdaptorBase::LessThanOrEqualToOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.less_equal", 14, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::LessThanOrEqualToOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::LocalConvolutionDataGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v117 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v103 = v6;
  if (!v6)
  {
    a3(v107, a4);
    if (v107[0])
    {
      int v104 = 3;
      unint64_t v105 = "expected DictionaryAttr to set properties";
      uint64_t v106 = 41;
      uint64_t v26 = &v104;
      unint64_t v27 = (char *)v108;
      if (v109 >= v110)
      {
        unint64_t v86 = v109 + 1;
        if (v108 <= &v104 && (char *)v108 + 24 * v109 > (char *)&v104)
        {
          int64_t v94 = (char *)&v104 - (unsigned char *)v108;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v86, 24);
          unint64_t v27 = (char *)v108;
          uint64_t v26 = (int *)((char *)v108 + v94);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v86, 24);
          uint64_t v26 = &v104;
          unint64_t v27 = (char *)v108;
        }
      }
      uint64_t v28 = &v27[24 * v109];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v109;
      if (v107[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v107);
      }
    }
    if (!v116) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      unint64_t v31 = v115;
      unsigned int v32 = __p;
      if (v115 != __p)
      {
        do
          unint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unsigned int v32 = __p;
      }
      uint64_t v115 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v112;
    if (!v112) {
      goto LABEL_114;
    }
    uint64_t v33 = v113;
    uint64_t v23 = v112;
    if (v113 == v112)
    {
LABEL_113:
      uint64_t v113 = v21;
      operator delete(v23);
LABEL_114:
      if (v108 != v111) {
        free(v108);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
LABEL_112:
    uint64_t v23 = v112;
    goto LABEL_113;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v103, "data_layout", 0xBuLL);
  if (!v8)
  {
    a3(v107, a4);
    if (v107[0])
    {
      int v104 = 3;
      unint64_t v105 = "expected key entry for data_layout in DictionaryAttr to set Properties.";
      uint64_t v106 = 71;
      uint64_t v36 = &v104;
      unint64_t v37 = (char *)v108;
      if (v109 >= v110)
      {
        unint64_t v88 = v109 + 1;
        if (v108 <= &v104 && (char *)v108 + 24 * v109 > (char *)&v104)
        {
          int64_t v96 = (char *)&v104 - (unsigned char *)v108;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v88, 24);
          unint64_t v37 = (char *)v108;
          uint64_t v36 = (int *)((char *)v108 + v96);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v88, 24);
          uint64_t v36 = &v104;
          unint64_t v37 = (char *)v108;
        }
      }
      unsigned int v38 = &v37[24 * v109];
      long long v39 = *(_OWORD *)v36;
      *((void *)v38 + 2) = *((void *)v36 + 2);
      *(_OWORD *)unsigned int v38 = v39;
      ++v109;
      if (v107[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v107);
      }
    }
    if (!v116) {
      return 0;
    }
    unint64_t v40 = __p;
    if (__p)
    {
      uint64_t v41 = v115;
      uint64_t v42 = __p;
      if (v115 != __p)
      {
        do
          uint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        uint64_t v42 = __p;
      }
      uint64_t v115 = v40;
      operator delete(v42);
    }
    uint64_t v21 = v112;
    if (!v112) {
      goto LABEL_114;
    }
    unint64_t v43 = v113;
    uint64_t v23 = v112;
    if (v113 == v112) {
      goto LABEL_113;
    }
    do
    {
      uint64_t v45 = *--v43;
      uint64_t v44 = v45;
      void *v43 = 0;
      if (v45) {
        MEMORY[0x21667D390](v44, 0x1000C8077774924);
      }
    }
    while (v43 != v21);
    goto LABEL_112;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    a3(v107, a4);
    if (v107[0])
    {
      int v104 = 3;
      uint64_t v106 = 56;
      uint64_t v10 = &v104;
      uint64_t v11 = (char *)v108;
      if (v109 >= v110)
      {
        unint64_t v87 = v109 + 1;
        if (v108 <= &v104 && (char *)v108 + 24 * v109 > (char *)&v104)
        {
          int64_t v95 = (char *)&v104 - (unsigned char *)v108;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v87, 24);
          uint64_t v11 = (char *)v108;
          uint64_t v10 = (int *)((char *)v108 + v95);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v87, 24);
          uint64_t v10 = &v104;
          uint64_t v11 = (char *)v108;
        }
      }
      uint64_t v12 = &v11[24 * v109];
      long long v13 = *(_OWORD *)v10;
      *((void *)v12 + 2) = *((void *)v10 + 2);
      *(_OWORD *)uint64_t v12 = v13;
      ++v109;
      if (v107[0])
      {
        uint64_t v14 = &v104;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v104, v9);
        uint64_t v15 = (char *)v108;
        if (v109 >= v110)
        {
          unint64_t v89 = v109 + 1;
          if (v108 <= &v104 && (char *)v108 + 24 * v109 > (char *)&v104)
          {
            int64_t v97 = (char *)&v104 - (unsigned char *)v108;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v89, 24);
            uint64_t v15 = (char *)v108;
            uint64_t v14 = (int *)((char *)v108 + v97);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v89, 24);
            uint64_t v14 = &v104;
            uint64_t v15 = (char *)v108;
          }
        }
        uint64_t v16 = &v15[24 * v109];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = *((void *)v14 + 2);
        *(_OWORD *)uint64_t v16 = v17;
        ++v109;
        if (v107[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v107);
        }
      }
    }
    if (!v116) {
      return 0;
    }
    unsigned int v18 = __p;
    if (__p)
    {
      unint64_t v19 = v115;
      uint64_t v20 = __p;
      if (v115 != __p)
      {
        do
          unint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        uint64_t v20 = __p;
      }
      uint64_t v115 = v18;
      operator delete(v20);
    }
    uint64_t v21 = v112;
    if (!v112) {
      goto LABEL_114;
    }
    uint64_t v22 = v113;
    uint64_t v23 = v112;
    if (v113 == v112) {
      goto LABEL_113;
    }
    do
    {
      uint64_t v25 = *--v22;
      uint64_t v24 = v25;
      void *v22 = 0;
      if (v25) {
        MEMORY[0x21667D390](v24, 0x1000C8077774924);
      }
    }
    while (v22 != v21);
    goto LABEL_112;
  }
  *a1 = v8;
  uint64_t v46 = mlir::DictionaryAttr::get((uint64_t)&v103, "dilation_rates", 0xEuLL);
  if (!v46)
  {
    a3(v107, a4);
    if (v107[0])
    {
      int v104 = 3;
      unint64_t v105 = "expected key entry for dilation_rates in DictionaryAttr to set Properties.";
      uint64_t v106 = 74;
      uint64_t v51 = &v104;
      unint64_t v52 = (char *)v108;
      if (v109 >= v110)
      {
        unint64_t v90 = v109 + 1;
        if (v108 <= &v104 && (char *)v108 + 24 * v109 > (char *)&v104)
        {
          int64_t v98 = (char *)&v104 - (unsigned char *)v108;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v90, 24);
          unint64_t v52 = (char *)v108;
          uint64_t v51 = (int *)((char *)v108 + v98);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v90, 24);
          uint64_t v51 = &v104;
          unint64_t v52 = (char *)v108;
        }
      }
      uint64_t v53 = &v52[24 * v109];
      long long v54 = *(_OWORD *)v51;
      *((void *)v53 + 2) = *((void *)v51 + 2);
      *(_OWORD *)uint64_t v53 = v54;
      ++v109;
      if (v107[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v107);
      }
    }
    if (!v116) {
      return 0;
    }
    uint64_t v55 = __p;
    if (__p)
    {
      uint64_t v56 = v115;
      uint64_t v57 = __p;
      if (v115 != __p)
      {
        do
          uint64_t v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
        while (v56 != v55);
        uint64_t v57 = __p;
      }
      uint64_t v115 = v55;
      operator delete(v57);
    }
    uint64_t v21 = v112;
    if (!v112) {
      goto LABEL_114;
    }
    uint64_t v58 = v113;
    uint64_t v23 = v112;
    if (v113 == v112) {
      goto LABEL_113;
    }
    do
    {
      uint64_t v60 = *--v58;
      uint64_t v59 = v60;
      *uint64_t v58 = 0;
      if (v60) {
        MEMORY[0x21667D390](v59, 0x1000C8077774924);
      }
    }
    while (v58 != v21);
    goto LABEL_112;
  }
  uint64_t v47 = v46;
  if ((mlir::DenseIntElementsAttr::classof(v46) & 1) == 0)
  {
    a3(v107, a4);
    if (v107[0])
    {
      int v104 = 3;
      uint64_t v106 = 59;
      unint64_t v61 = &v104;
      uint64_t v62 = (char *)v108;
      if (v109 >= v110)
      {
        unint64_t v91 = v109 + 1;
        if (v108 <= &v104 && (char *)v108 + 24 * v109 > (char *)&v104)
        {
          int64_t v99 = (char *)&v104 - (unsigned char *)v108;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v91, 24);
          uint64_t v62 = (char *)v108;
          unint64_t v61 = (int *)((char *)v108 + v99);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v91, 24);
          unint64_t v61 = &v104;
          uint64_t v62 = (char *)v108;
        }
      }
      uint64_t v63 = &v62[24 * v109];
      long long v64 = *(_OWORD *)v61;
      *((void *)v63 + 2) = *((void *)v61 + 2);
      *(_OWORD *)uint64_t v63 = v64;
      ++v109;
      if (v107[0])
      {
        uint64_t v65 = &v104;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v104, v47);
        uint64_t v66 = (char *)v108;
        if (v109 >= v110)
        {
          unint64_t v92 = v109 + 1;
          if (v108 <= &v104 && (char *)v108 + 24 * v109 > (char *)&v104)
          {
            int64_t v100 = (char *)&v104 - (unsigned char *)v108;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v92, 24);
            uint64_t v66 = (char *)v108;
            uint64_t v65 = (int *)((char *)v108 + v100);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v92, 24);
            uint64_t v65 = &v104;
            uint64_t v66 = (char *)v108;
          }
        }
        uint64_t v67 = &v66[24 * v109];
        long long v68 = *(_OWORD *)v65;
        *((void *)v67 + 2) = *((void *)v65 + 2);
        *(_OWORD *)uint64_t v67 = v68;
        ++v109;
        if (v107[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v107);
        }
      }
    }
    if (!v116) {
      return 0;
    }
    uint64_t v69 = __p;
    if (__p)
    {
      uint64_t v70 = v115;
      uint64_t v71 = __p;
      if (v115 != __p)
      {
        do
          uint64_t v70 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v70 - 1);
        while (v70 != v69);
        uint64_t v71 = __p;
      }
      uint64_t v115 = v69;
      operator delete(v71);
    }
    uint64_t v21 = v112;
    if (!v112) {
      goto LABEL_114;
    }
    uint64_t v72 = v113;
    uint64_t v23 = v112;
    if (v113 == v112) {
      goto LABEL_113;
    }
    do
    {
      uint64_t v74 = *--v72;
      uint64_t v73 = v74;
      *uint64_t v72 = 0;
      if (v74) {
        MEMORY[0x21667D390](v73, 0x1000C8077774924);
      }
    }
    while (v72 != v21);
    goto LABEL_112;
  }
  a1[1] = v47;
  uint64_t v48 = mlir::DictionaryAttr::get((uint64_t)&v103, "kernel_sizes", 0xCuLL);
  uint64_t v102 = v48;
  if (!v48)
  {
    a3(v107, a4);
    if (v107[0])
    {
      int v104 = 3;
      unint64_t v105 = "expected key entry for kernel_sizes in DictionaryAttr to set Properties.";
      uint64_t v106 = 72;
      uint64_t v75 = &v104;
      unint64_t v76 = (char *)v108;
      if (v109 >= v110)
      {
        unint64_t v93 = v109 + 1;
        if (v108 <= &v104 && (char *)v108 + 24 * v109 > (char *)&v104)
        {
          int64_t v101 = (char *)&v104 - (unsigned char *)v108;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v93, 24);
          unint64_t v76 = (char *)v108;
          uint64_t v75 = (int *)((char *)v108 + v101);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v93, 24);
          uint64_t v75 = &v104;
          unint64_t v76 = (char *)v108;
        }
      }
      uint64_t v77 = &v76[24 * v109];
      long long v78 = *(_OWORD *)v75;
      *((void *)v77 + 2) = *((void *)v75 + 2);
      *(_OWORD *)uint64_t v77 = v78;
      ++v109;
      if (v107[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v107);
      }
    }
    if (!v116) {
      return 0;
    }
    uint64_t v79 = __p;
    if (__p)
    {
      uint64_t v80 = v115;
      uint64_t v81 = __p;
      if (v115 != __p)
      {
        do
          uint64_t v80 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v80 - 1);
        while (v80 != v79);
        uint64_t v81 = __p;
      }
      uint64_t v115 = v79;
      operator delete(v81);
    }
    uint64_t v21 = v112;
    if (!v112) {
      goto LABEL_114;
    }
    unint64_t v82 = v113;
    uint64_t v23 = v112;
    if (v113 == v112) {
      goto LABEL_113;
    }
    do
    {
      uint64_t v84 = *--v82;
      uint64_t v83 = v84;
      void *v82 = 0;
      if (v84) {
        MEMORY[0x21667D390](v83, 0x1000C8077774924);
      }
    }
    while (v82 != v21);
    goto LABEL_112;
  }
  uint64_t v49 = v48;
  if (mlir::DenseIntElementsAttr::classof(v48))
  {
    a1[2] = v49;
    return 1;
  }
  a3(v107, a4);
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v85, &v102);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v107);
  return 0;
}

uint64_t mlir::mps::LocalConvolutionDataGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v27[6] = *MEMORY[0x263EF8340];
  uint64_t v24 = a1;
  uint64_t v25 = v27;
  uint64_t v26 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v24, (uint64_t)"data_layout", 11, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v26;
  if (v26 >= HIDWORD(v26))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
    unsigned int v6 = v26;
  }
  uint64_t v7 = (uint64_t *)((char *)v25 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v26 + 1;
  LODWORD(v26) = v26 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v24, (uint64_t)"dilation_rates", 14, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v26;
    if (v26 >= HIDWORD(v26))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
      unsigned int v13 = v26;
    }
    uint64_t v14 = (uint64_t *)((char *)v25 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v26 + 1;
    LODWORD(v26) = v26 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v24, (uint64_t)"kernel_sizes", 12, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v26;
    if (v26 >= HIDWORD(v26))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
      unsigned int v19 = v26;
    }
    uint64_t v20 = (uint64_t *)((char *)v25 + 16 * v19);
    uint64_t *v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v26 + 1;
    LODWORD(v26) = v26 + 1;
  }
  uint64_t v21 = v25;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v25 == v27) {
      return DictionaryAttr;
    }
    goto LABEL_16;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v24, (uint64_t *)v25, v8);
  uint64_t v21 = v25;
  if (v25 != v27) {
LABEL_16:
  }
    free(v21);
  return DictionaryAttr;
}

uint64_t mlir::mps::LocalConvolutionDataGradientOp::setInherentAttr(uint64_t result, char *__s1, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = result;
  if (a3 == 14)
  {
    uint64_t result = memcmp(__s1, "dilation_rates", 0xEuLL);
    if (!result)
    {
      if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v7 = a4;
        }
        else {
          uint64_t v7 = 0;
        }
        *(void *)(v5 + 8) = v7;
      }
      else
      {
        *(void *)(v5 + 8) = 0;
      }
    }
  }
  else if (a3 == 12)
  {
    uint64_t result = memcmp(__s1, "kernel_sizes", 0xCuLL);
    if (!result)
    {
      if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v8 = a4;
        }
        else {
          uint64_t v8 = 0;
        }
        *(void *)(v5 + 16) = v8;
      }
      else
      {
        *(void *)(v5 + 16) = 0;
      }
    }
  }
  else if (a3 == 11 && *(void *)__s1 == 0x79616C5F61746164 && *(void *)(__s1 + 3) == 0x74756F79616C5F61)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      *(void *)uint64_t result = v9;
    }
    else
    {
      *(void *)uint64_t result = 0;
    }
  }
  return result;
}

BOOL mlir::mps::LocalConvolutionDataGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v8, (void **)"data_layout", (const char *)0xB, a3, a4))
  {
    uint64_t v9 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps31(v9, (void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))a3, a4))
    {
      uint64_t v10 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps31(v10, (void **)"kernel_sizes", (const char *)0xC, (void (*)(void **__return_ptr, uint64_t))a3, a4))
      {
        return 1;
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps31(void **a1, void **a2, const char *a3, void (*a4)(void **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1)) {
    goto LABEL_9;
  }
  uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  uint64_t v41 = a1;
  uint64_t v42 = (const char *)v10;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v41);
  uint64_t v12 = Type;
  if (Type) {
    Type = (void *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  }
  uint64_t v45 = v12;
  uint64_t v46 = Type;
  Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v45);
  uint64_t v56 = 2;
  if (v14 == 1 && *Shape == v56)
  {
    unsigned int v38 = a1;
    v39[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v38);
    v39[1] = v15;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v39);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
  }
LABEL_9:
  a4(&v45, a5);
  if (v45)
  {
    LODWORD(v41) = 3;
    uint64_t v42 = "attribute '";
    uint64_t v43 = 11;
    uint64_t v17 = &v41;
    uint64_t v18 = (char *)v47;
    if (v48 >= v49)
    {
      unint64_t v34 = v48 + 1;
      if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
      {
        int64_t v36 = (char *)&v41 - (unsigned char *)v47;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        uint64_t v18 = (char *)v47;
        uint64_t v17 = (void ***)((char *)v47 + v36);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        uint64_t v17 = &v41;
        uint64_t v18 = (char *)v47;
      }
    }
    unsigned int v19 = &v18[24 * v48];
    long long v20 = *(_OWORD *)v17;
    *((void *)v19 + 2) = v17[2];
    *(_OWORD *)unsigned int v19 = v20;
    ++v48;
    if (v45)
    {
      __int16 v44 = 261;
      uint64_t v41 = a2;
      uint64_t v42 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
      if (v45)
      {
        LODWORD(v41) = 3;
        uint64_t v42 = "' failed to satisfy constraint: ui64 elements attribute of shape {2}";
        uint64_t v43 = 68;
        uint64_t v21 = &v41;
        uint64_t v22 = (char *)v47;
        if (v48 >= v49)
        {
          unint64_t v35 = v48 + 1;
          if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
          {
            int64_t v37 = (char *)&v41 - (unsigned char *)v47;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            uint64_t v22 = (char *)v47;
            uint64_t v21 = (void ***)((char *)v47 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            uint64_t v21 = &v41;
            uint64_t v22 = (char *)v47;
          }
        }
        uint64_t v23 = &v22[24 * v48];
        long long v24 = *(_OWORD *)v21;
        *((void *)v23 + 2) = v21[2];
        *(_OWORD *)uint64_t v23 = v24;
        ++v48;
      }
    }
  }
  uint64_t v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v45);
  if (v45) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v45);
  }
  if (v55)
  {
    uint64_t v25 = __p;
    if (__p)
    {
      uint64_t v26 = v54;
      unint64_t v27 = __p;
      if (v54 != __p)
      {
        do
          uint64_t v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        unint64_t v27 = __p;
      }
      long long v54 = v25;
      operator delete(v27);
    }
    uint64_t v28 = v51;
    if (v51)
    {
      long long v29 = v52;
      uint64_t v30 = v51;
      if (v52 != v51)
      {
        do
        {
          uint64_t v32 = *--v29;
          uint64_t v31 = v32;
          *long long v29 = 0;
          if (v32) {
            MEMORY[0x21667D390](v31, 0x1000C8077774924);
          }
        }
        while (v29 != v28);
        uint64_t v30 = v51;
      }
      unint64_t v52 = v28;
      operator delete(v30);
    }
    if (v47 != v50) {
      free(v47);
    }
  }
  return v16;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionDataGradientOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::LocalConvolutionDataGradientOp::verifyInvariantsImpl(mlir::mps::LocalConvolutionDataGradientOp *this)
{
  uint64_t v41 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  if (*v3)
  {
    uint64_t v5 = (void **)v3[1];
    if (v5)
    {
      unsigned int v6 = (void **)v3[2];
      if (v6)
      {
        v33[0] = v2;
        if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v4, (void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v33))return 0; {
        v33[0] = *(void *)this;
        }
        if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps31(v6, (void **)"kernel_sizes", (const char *)0xC, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps31(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v33))return 0; {
        v33[0] = *(void *)this;
        }
        if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps31(v5, (void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps31(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v33)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u))
        {
          return 0;
        }
        if (*(_DWORD *)(*(void *)this + 36)) {
          uint64_t v7 = *(void *)this - 16;
        }
        else {
          uint64_t v7 = 0;
        }
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0);
        return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
      }
      v31[0] = (void **)"requires attribute 'kernel_sizes'";
      __int16 v32 = 259;
      mlir::OpState::emitOpError((uint64_t *)this, v31, (uint64_t)v33);
      uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v33);
      if (v33[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v33);
      }
      if (v40)
      {
        long long v24 = __p;
        if (__p)
        {
          uint64_t v25 = v39;
          uint64_t v26 = __p;
          if (v39 != __p)
          {
            do
              uint64_t v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
            while (v25 != v24);
            uint64_t v26 = __p;
          }
          long long v39 = v24;
          operator delete(v26);
        }
        unsigned int v13 = v36;
        if (!v36) {
          goto LABEL_61;
        }
        unint64_t v27 = v37;
        uint64_t v15 = v36;
        if (v37 == v36)
        {
LABEL_60:
          int64_t v37 = v13;
          operator delete(v15);
LABEL_61:
          if (v34 != &v35) {
            free(v34);
          }
          return v9;
        }
        do
        {
          uint64_t v29 = *--v27;
          uint64_t v28 = v29;
          void *v27 = 0;
          if (v29) {
            MEMORY[0x21667D390](v28, 0x1000C8077774924);
          }
        }
        while (v27 != v13);
LABEL_59:
        uint64_t v15 = v36;
        goto LABEL_60;
      }
    }
    else
    {
      v31[0] = (void **)"requires attribute 'dilation_rates'";
      __int16 v32 = 259;
      mlir::OpState::emitOpError((uint64_t *)this, v31, (uint64_t)v33);
      uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v33);
      if (v33[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v33);
      }
      if (v40)
      {
        uint64_t v18 = __p;
        if (__p)
        {
          unsigned int v19 = v39;
          long long v20 = __p;
          if (v39 != __p)
          {
            do
              unsigned int v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
            while (v19 != v18);
            long long v20 = __p;
          }
          long long v39 = v18;
          operator delete(v20);
        }
        unsigned int v13 = v36;
        if (!v36) {
          goto LABEL_61;
        }
        uint64_t v21 = v37;
        uint64_t v15 = v36;
        if (v37 == v36) {
          goto LABEL_60;
        }
        do
        {
          uint64_t v23 = *--v21;
          uint64_t v22 = v23;
          void *v21 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v21 != v13);
        goto LABEL_59;
      }
    }
  }
  else
  {
    v31[0] = (void **)"requires attribute 'data_layout'";
    __int16 v32 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v31, (uint64_t)v33);
    uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v33);
    if (v33[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v33);
    }
    if (v40)
    {
      uint64_t v10 = __p;
      if (__p)
      {
        uint64_t v11 = v39;
        uint64_t v12 = __p;
        if (v39 != __p)
        {
          do
            uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
          while (v11 != v10);
          uint64_t v12 = __p;
        }
        long long v39 = v10;
        operator delete(v12);
      }
      unsigned int v13 = v36;
      if (!v36) {
        goto LABEL_61;
      }
      uint64_t v14 = v37;
      uint64_t v15 = v36;
      if (v37 == v36) {
        goto LABEL_60;
      }
      do
      {
        uint64_t v17 = *--v14;
        uint64_t v16 = v17;
        *uint64_t v14 = 0;
        if (v17) {
          MEMORY[0x21667D390](v16, 0x1000C8077774924);
        }
      }
      while (v14 != v13);
      goto LABEL_59;
    }
  }
  return v9;
}

void mlir::mps::LocalConvolutionDataGradientOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

void mlir::mps::LocalConvolutionOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionWeightGradientOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

void mlir::mps::LocalConvolutionWeightGradientOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::LogarithmBase10OpGenericAdaptorBase::LogarithmBase10OpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.logarithm_base_10", 21, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::LogarithmBase10Op::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::LogarithmBase2OpGenericAdaptorBase::LogarithmBase2OpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.logarithm_base_2", 20, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::LogarithmBase2Op::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::LogarithmOpGenericAdaptorBase::LogarithmOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.logarithm", 13, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::LogarithmOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::MatMulOpGenericAdaptorBase::MatMulOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v5 = (_OWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  }
  else {
    unint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v11, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v11;
  *(_OWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 40) = v8;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.matmul", 10, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::MatMulOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v77 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v63 = v6;
  if (!v6)
  {
    a3(v67, a4);
    if (v67[0])
    {
      int v64 = 3;
      uint64_t v65 = "expected DictionaryAttr to set properties";
      uint64_t v66 = 41;
      unsigned int v13 = &v64;
      uint64_t v14 = (char *)v68;
      if (v69 >= v70)
      {
        unint64_t v53 = v69 + 1;
        if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
        {
          int64_t v58 = (char *)&v64 - (unsigned char *)v68;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v53, 24);
          uint64_t v14 = (char *)v68;
          unsigned int v13 = (int *)((char *)v68 + v58);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v53, 24);
          unsigned int v13 = &v64;
          uint64_t v14 = (char *)v68;
        }
      }
      uint64_t v15 = &v14[24 * v69];
      long long v16 = *(_OWORD *)v13;
      *((void *)v15 + 2) = *((void *)v13 + 2);
      *(_OWORD *)uint64_t v15 = v16;
      ++v69;
      if (v67[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
      }
    }
    if (!v76) {
      return 0;
    }
    uint64_t v17 = __p;
    if (__p)
    {
      uint64_t v18 = v75;
      unsigned int v19 = __p;
      if (v75 != __p)
      {
        do
          uint64_t v18 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v18 - 1);
        while (v18 != v17);
        unsigned int v19 = __p;
      }
      uint64_t v75 = v17;
      operator delete(v19);
    }
    long long v20 = v72;
    if (!v72) {
      goto LABEL_66;
    }
    uint64_t v21 = v73;
    uint64_t v22 = v72;
    if (v73 == v72) {
      goto LABEL_65;
    }
    do
    {
      uint64_t v24 = *--v21;
      uint64_t v23 = v24;
      void *v21 = 0;
      if (v24) {
        MEMORY[0x21667D390](v23, 0x1000C8077774924);
      }
    }
    while (v21 != v20);
    goto LABEL_64;
  }
  long long v8 = (void *)mlir::DictionaryAttr::get((uint64_t)&v63, "transpose_lhs", 0xDuLL);
  if (v8)
  {
    uint64_t v9 = (uint64_t)v8;
    if (!mlir::BoolAttr::classof(v8))
    {
      a3(v67, a4);
      if (v67[0])
      {
        int v64 = 3;
        uint64_t v66 = 58;
        uint64_t v25 = &v64;
        uint64_t v26 = (char *)v68;
        if (v69 >= v70)
        {
          unint64_t v54 = v69 + 1;
          if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
          {
            int64_t v59 = (char *)&v64 - (unsigned char *)v68;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v54, 24);
            uint64_t v26 = (char *)v68;
            uint64_t v25 = (int *)((char *)v68 + v59);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v54, 24);
            uint64_t v25 = &v64;
            uint64_t v26 = (char *)v68;
          }
        }
        unint64_t v27 = &v26[24 * v69];
        long long v28 = *(_OWORD *)v25;
        *((void *)v27 + 2) = *((void *)v25 + 2);
        *(_OWORD *)unint64_t v27 = v28;
        ++v69;
        if (v67[0])
        {
          uint64_t v29 = &v64;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v64, v9);
          uint64_t v30 = (char *)v68;
          if (v69 >= v70)
          {
            unint64_t v56 = v69 + 1;
            if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
            {
              int64_t v61 = (char *)&v64 - (unsigned char *)v68;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v56, 24);
              uint64_t v30 = (char *)v68;
              uint64_t v29 = (int *)((char *)v68 + v61);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v56, 24);
              uint64_t v29 = &v64;
              uint64_t v30 = (char *)v68;
            }
          }
          uint64_t v31 = &v30[24 * v69];
          long long v32 = *(_OWORD *)v29;
          *((void *)v31 + 2) = *((void *)v29 + 2);
          *(_OWORD *)uint64_t v31 = v32;
          ++v69;
          if (v67[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
          }
        }
      }
      if (!v76) {
        return 0;
      }
      uint64_t v33 = __p;
      if (__p)
      {
        unint64_t v34 = v75;
        uint64_t v35 = __p;
        if (v75 != __p)
        {
          do
            unint64_t v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
          while (v34 != v33);
          uint64_t v35 = __p;
        }
        uint64_t v75 = v33;
        operator delete(v35);
      }
      long long v20 = v72;
      if (!v72) {
        goto LABEL_66;
      }
      int64_t v36 = v73;
      uint64_t v22 = v72;
      if (v73 == v72) {
        goto LABEL_65;
      }
      do
      {
        uint64_t v38 = *--v36;
        uint64_t v37 = v38;
        void *v36 = 0;
        if (v38) {
          MEMORY[0x21667D390](v37, 0x1000C8077774924);
        }
      }
      while (v36 != v20);
      goto LABEL_64;
    }
    *a1 = v9;
  }
  uint64_t v10 = (void *)mlir::DictionaryAttr::get((uint64_t)&v63, "transpose_rhs", 0xDuLL);
  if (!v10) {
    return 1;
  }
  uint64_t v11 = (uint64_t)v10;
  if (mlir::BoolAttr::classof(v10))
  {
    a1[1] = v11;
    return 1;
  }
  a3(v67, a4);
  if (v67[0])
  {
    int v64 = 3;
    uint64_t v66 = 58;
    long long v39 = &v64;
    char v40 = (char *)v68;
    if (v69 >= v70)
    {
      unint64_t v55 = v69 + 1;
      if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
      {
        int64_t v60 = (char *)&v64 - (unsigned char *)v68;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v55, 24);
        char v40 = (char *)v68;
        long long v39 = (int *)((char *)v68 + v60);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v55, 24);
        long long v39 = &v64;
        char v40 = (char *)v68;
      }
    }
    uint64_t v41 = &v40[24 * v69];
    long long v42 = *(_OWORD *)v39;
    *((void *)v41 + 2) = *((void *)v39 + 2);
    *(_OWORD *)uint64_t v41 = v42;
    ++v69;
    if (v67[0])
    {
      uint64_t v43 = &v64;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v64, v11);
      __int16 v44 = (char *)v68;
      if (v69 >= v70)
      {
        unint64_t v57 = v69 + 1;
        if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
        {
          int64_t v62 = (char *)&v64 - (unsigned char *)v68;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v57, 24);
          __int16 v44 = (char *)v68;
          uint64_t v43 = (int *)((char *)v68 + v62);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v57, 24);
          uint64_t v43 = &v64;
          __int16 v44 = (char *)v68;
        }
      }
      uint64_t v45 = &v44[24 * v69];
      long long v46 = *(_OWORD *)v43;
      *((void *)v45 + 2) = *((void *)v43 + 2);
      *(_OWORD *)uint64_t v45 = v46;
      ++v69;
      if (v67[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
      }
    }
  }
  if (v76)
  {
    uint64_t v47 = __p;
    if (__p)
    {
      unsigned int v48 = v75;
      unsigned int v49 = __p;
      if (v75 != __p)
      {
        do
          unsigned int v48 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v48 - 1);
        while (v48 != v47);
        unsigned int v49 = __p;
      }
      uint64_t v75 = v47;
      operator delete(v49);
    }
    long long v20 = v72;
    if (!v72) {
      goto LABEL_66;
    }
    unsigned int v50 = v73;
    uint64_t v22 = v72;
    if (v73 == v72)
    {
LABEL_65:
      uint64_t v73 = v20;
      operator delete(v22);
LABEL_66:
      if (v68 != v71) {
        free(v68);
      }
      return 0;
    }
    do
    {
      uint64_t v52 = *--v50;
      uint64_t v51 = v52;
      *unsigned int v50 = 0;
      if (v52) {
        MEMORY[0x21667D390](v51, 0x1000C8077774924);
      }
    }
    while (v50 != v20);
LABEL_64:
    uint64_t v22 = v72;
    goto LABEL_65;
  }
  return 0;
}

uint64_t mlir::mps::MatMulOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v21[6] = *MEMORY[0x263EF8340];
  uint64_t v18 = a1;
  unsigned int v19 = v21;
  uint64_t v20 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"transpose_lhs", 13, *a2);
    uint64_t v5 = v4;
    unsigned int v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      unsigned int v6 = v20;
    }
    uint64_t v7 = (uint64_t *)((char *)v19 + 16 * v6);
    uint64_t *v7 = NamedAttr;
    v7[1] = v5;
    unsigned int v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    uint64_t v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      uint64_t v10 = (uint64_t *)v19;
      if (v8) {
        goto LABEL_6;
      }
LABEL_13:
      uint64_t DictionaryAttr = 0;
      if (v10 == v21) {
        return DictionaryAttr;
      }
      goto LABEL_7;
    }
  }
  else
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_5;
    }
  }
  uint64_t v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"transpose_rhs", 13, v9);
  uint64_t v15 = v14;
  unsigned int v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    unsigned int v16 = v20;
  }
  uint64_t v17 = (uint64_t *)((char *)v19 + 16 * v16);
  uint64_t *v17 = v13;
  v17[1] = v15;
  unsigned int v8 = v20 + 1;
  LODWORD(v20) = v8;
  uint64_t v10 = (uint64_t *)v19;
  if (!v8) {
    goto LABEL_13;
  }
LABEL_6:
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  uint64_t v10 = (uint64_t *)v19;
  if (v19 != v21) {
LABEL_7:
  }
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::MatMulOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::MatMulOp::verifyInvariantsImpl(mlir::mps::MatMulOp *this)
{
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v3 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = *(void **)v3;
  uint64_t v5 = *(void **)(v3 + 8);
  uint64_t v9 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps2(v4, (void **)"transpose_lhs", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps17(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v9))return 0; {
  uint64_t v9 = *(void *)this;
  }
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps2(v5, (void **)"transpose_rhs", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps17(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v9)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps26(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps26(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v6 = *(void *)this - 16;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps26(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
}

void mlir::mps::MatMulOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::MaterializeSparseTensorOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v55 = v6;
  if (!v6)
  {
    a3(v59, a4);
    if (v59[0])
    {
      int v56 = 3;
      unint64_t v57 = "expected DictionaryAttr to set properties";
      uint64_t v58 = 41;
      uint64_t v26 = &v56;
      unint64_t v27 = (char *)v60;
      if (v61 >= v62)
      {
        unint64_t v47 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          int64_t v51 = (char *)&v56 - (unsigned char *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          unint64_t v27 = (char *)v60;
          uint64_t v26 = (int *)((char *)v60 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          uint64_t v26 = &v56;
          unint64_t v27 = (char *)v60;
        }
      }
      long long v28 = &v27[24 * v61];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)long long v28 = v29;
      ++v61;
      if (v59[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
      }
    }
    if (!v68) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      uint64_t v31 = v67;
      long long v32 = __p;
      if (v67 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        long long v32 = __p;
      }
      uint64_t v67 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v64;
    if (!v64) {
      goto LABEL_59;
    }
    uint64_t v33 = v65;
    uint64_t v23 = v64;
    if (v65 == v64) {
      goto LABEL_58;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_57;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v55, "storage_type", 0xCuLL);
  if (!v8)
  {
    a3(v59, a4);
    if (v59[0])
    {
      int v56 = 3;
      unint64_t v57 = "expected key entry for storage_type in DictionaryAttr to set Properties.";
      uint64_t v58 = 72;
      int64_t v36 = &v56;
      uint64_t v37 = (char *)v60;
      if (v61 >= v62)
      {
        unint64_t v49 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          int64_t v53 = (char *)&v56 - (unsigned char *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          uint64_t v37 = (char *)v60;
          int64_t v36 = (int *)((char *)v60 + v53);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          int64_t v36 = &v56;
          uint64_t v37 = (char *)v60;
        }
      }
      uint64_t v38 = &v37[24 * v61];
      long long v39 = *(_OWORD *)v36;
      *((void *)v38 + 2) = *((void *)v36 + 2);
      *(_OWORD *)uint64_t v38 = v39;
      ++v61;
      if (v59[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
      }
    }
    if (!v68) {
      return 0;
    }
    char v40 = __p;
    if (__p)
    {
      uint64_t v41 = v67;
      long long v42 = __p;
      if (v67 != __p)
      {
        do
          uint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        long long v42 = __p;
      }
      uint64_t v67 = v40;
      operator delete(v42);
    }
    uint64_t v21 = v64;
    if (!v64) {
      goto LABEL_59;
    }
    uint64_t v43 = v65;
    uint64_t v23 = v64;
    if (v65 == v64) {
      goto LABEL_58;
    }
    do
    {
      uint64_t v45 = *--v43;
      uint64_t v44 = v45;
      void *v43 = 0;
      if (v45) {
        MEMORY[0x21667D390](v44, 0x1000C8077774924);
      }
    }
    while (v43 != v21);
    goto LABEL_57;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v59, a4);
  if (v59[0])
  {
    int v56 = 3;
    uint64_t v58 = 57;
    uint64_t v10 = &v56;
    uint64_t v11 = (char *)v60;
    if (v61 >= v62)
    {
      unint64_t v48 = v61 + 1;
      if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
      {
        int64_t v52 = (char *)&v56 - (unsigned char *)v60;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        uint64_t v11 = (char *)v60;
        uint64_t v10 = (int *)((char *)v60 + v52);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        uint64_t v10 = &v56;
        uint64_t v11 = (char *)v60;
      }
    }
    uint64_t v12 = &v11[24 * v61];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v61;
    if (v59[0])
    {
      uint64_t v14 = &v56;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v56, v9);
      uint64_t v15 = (char *)v60;
      if (v61 >= v62)
      {
        unint64_t v50 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          int64_t v54 = (char *)&v56 - (unsigned char *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          uint64_t v15 = (char *)v60;
          uint64_t v14 = (int *)((char *)v60 + v54);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          uint64_t v14 = &v56;
          uint64_t v15 = (char *)v60;
        }
      }
      unsigned int v16 = &v15[24 * v61];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)unsigned int v16 = v17;
      ++v61;
      if (v59[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
      }
    }
  }
  if (v68)
  {
    uint64_t v18 = __p;
    if (__p)
    {
      unsigned int v19 = v67;
      uint64_t v20 = __p;
      if (v67 != __p)
      {
        do
          unsigned int v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        uint64_t v20 = __p;
      }
      uint64_t v67 = v18;
      operator delete(v20);
    }
    uint64_t v21 = v64;
    if (!v64) {
      goto LABEL_59;
    }
    uint64_t v22 = v65;
    uint64_t v23 = v64;
    if (v65 == v64)
    {
LABEL_58:
      uint64_t v65 = v21;
      operator delete(v23);
LABEL_59:
      if (v60 != v63) {
        free(v60);
      }
      return 0;
    }
    do
    {
      uint64_t v25 = *--v22;
      uint64_t v24 = v25;
      void *v22 = 0;
      if (v25) {
        MEMORY[0x21667D390](v24, 0x1000C8077774924);
      }
    }
    while (v22 != v21);
LABEL_57:
    uint64_t v23 = v64;
    goto LABEL_58;
  }
  return 0;
}

uint64_t mlir::mps::MaterializeSparseTensorOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x263EF8340];
  uint64_t v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"storage_type", 12, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  uint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps32(uint64_t a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    BOOL v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        BOOL v8 = (char *)v35;
        uint64_t v7 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        BOOL v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      long long v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid SparseTensorStorage";
        uint64_t v31 = 57;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        long long v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)long long v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    unsigned int v16 = __p;
    if (__p)
    {
      long long v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          long long v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      long long v42 = v16;
      operator delete(v18);
    }
    unsigned int v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      uint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        uint64_t v21 = v39;
      }
      char v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::MaterializeSparseTensorOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::SparseTensorStorageAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  unsigned int v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    uint64_t v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        uint64_t v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    BOOL v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)BOOL v8 = v9;
    ++v47;
  }
  char v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::SparseTensorStorageAttr]";
  unint64_t v41 = 84;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    char v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      long long v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          long long v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      unsigned int v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)unsigned int v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unsigned int v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unsigned int v19 = (char *)v46;
            uint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unsigned int v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      uint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      int64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      int64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

BOOL mlir::mps::MaterializeSparseTensorOp::verifyInvariantsImpl(void ***this)
{
  uint64_t v184 = *MEMORY[0x263EF8340];
  uint64_t v2 = *this;
  uint64_t v3 = (uint64_t)(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (v3)
  {
    uint64_t v173 = v2;
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps32(v3, (void **)"storage_type", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps32(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v173))return 0; {
    uint64_t v4 = (uint64_t)*this;
    }
    unsigned int v5 = (void **)(*(void *)(*((void *)(*this)[9] + 3) + 8) & 0xFFFFFFFFFFFFFFF8);
    uint64_t v6 = *v5;
    uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
    BOOL v8 = (void *)*((void *)*v5 + 17);
    if (v8 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      uint64_t v21 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v6 + 8);
      uint64_t v173 = v5;
      uint64_t v174 = v21;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v173);
      if (mlir::Type::isF32((mlir::Type *)&OperandRange))
      {
LABEL_57:
        uint64_t v49 = (uint64_t)*this;
        if ((*((unsigned char *)*this + 46) & 0x80) == 0)
        {
          uint64_t v51 = -1;
          uint64_t v52 = 32;
          goto LABEL_60;
        }
        uint64_t v50 = *(unsigned int *)(v49 + 68);
        uint64_t v51 = v50 - 1;
        if (v50 != 1)
        {
          uint64_t v52 = *(void *)(v49 + 72) + 32;
LABEL_60:
          uint64_t v53 = 0;
          unsigned int v54 = 1;
          do
          {
            uint64_t v55 = (uint64_t)*this;
            int v56 = (void **)(*(void *)(*(void *)(v52 + 32 * v53 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
            unint64_t v57 = *v56;
            uint64_t v58 = (void *)*((void *)*v56 + 17);
            if (v58 == v7)
            {
              uint64_t v63 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v57 + 8);
              uint64_t v173 = v56;
              uint64_t v174 = v63;
              uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v173);
              if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
                || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
              {
                goto LABEL_62;
              }
              unint64_t v57 = *v56;
              if (*((_UNKNOWN **)*v56 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
              {
LABEL_65:
                uint64_t v59 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v57 + 8);
                int64_t v164 = v56;
                uint64_t v165 = v59;
                if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v164))
                {
                  uint64_t v60 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v56 + 8);
                  uint64_t v170 = v56;
                  int v171 = (const char *)v60;
                  mlir::ShapedType::getShape((mlir::ShapedType *)&v170);
                  if (v61 == 1)
                  {
                    uint64_t v62 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v56 + 8);
                    int64_t v167 = v56;
                    uint64_t v168 = v62;
                    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v167);
                    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
                      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
                    {
                      goto LABEL_62;
                    }
                  }
                }
              }
            }
            else if (v58 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
            {
              goto LABEL_65;
            }
            __int16 v166 = 261;
            int64_t v164 = (void **)"operand";
            uint64_t v165 = 7;
            mlir::Operation::emitOpError(v55, &v164, (uint64_t)&v173);
            if (v173)
            {
              LODWORD(v170) = 3;
              int v171 = " #";
              uint64_t v172 = 2;
              int v64 = (char *)v175;
              if (v176 >= v177)
              {
                unint64_t v92 = v176 + 1;
                if (v175 <= &v170 && (char *)v175 + 24 * v176 > (char *)&v170)
                {
                  int64_t v98 = (char *)&v170 - (unsigned char *)v175;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v92, 24);
                  int v64 = (char *)v175;
                  uint64_t v65 = (void ***)((char *)v175 + v98);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v92, 24);
                  uint64_t v65 = &v170;
                  int v64 = (char *)v175;
                }
              }
              else
              {
                uint64_t v65 = &v170;
              }
              uint64_t v66 = &v64[24 * v176];
              long long v67 = *(_OWORD *)v65;
              *((void *)v66 + 2) = v65[2];
              *(_OWORD *)uint64_t v66 = v67;
              uint64_t v68 = ++v176;
              if (v173)
              {
                LODWORD(v170) = 5;
                int v171 = (const char *)v54;
                uint64_t v69 = (char *)v175;
                if (v68 >= v177)
                {
                  unint64_t v93 = v68 + 1;
                  BOOL v94 = (char *)v175 + 24 * v68 > (char *)&v170;
                  if (v175 <= &v170 && v94)
                  {
                    int64_t v99 = (char *)&v170 - (unsigned char *)v175;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v93, 24);
                    uint64_t v69 = (char *)v175;
                    unsigned int v70 = (void ***)((char *)v175 + v99);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v93, 24);
                    unsigned int v70 = &v170;
                    uint64_t v69 = (char *)v175;
                  }
                }
                else
                {
                  unsigned int v70 = &v170;
                }
                uint64_t v71 = &v69[24 * v176];
                long long v72 = *(_OWORD *)v70;
                *((void *)v71 + 2) = v70[2];
                *(_OWORD *)uint64_t v71 = v72;
                uint64_t v73 = ++v176;
                if (v173)
                {
                  LODWORD(v170) = 3;
                  int v171 = " must be variadic of unranked tensor of 32/64-bit signed integer values or 1D tensor of 32/64-b"
                         "it signed integer values, but got ";
                  uint64_t v172 = 129;
                  uint64_t v74 = (char *)v175;
                  if (v73 >= v177)
                  {
                    unint64_t v95 = v73 + 1;
                    BOOL v96 = (char *)v175 + 24 * v73 > (char *)&v170;
                    if (v175 <= &v170 && v96)
                    {
                      int64_t v100 = (char *)&v170 - (unsigned char *)v175;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v95, 24);
                      uint64_t v74 = (char *)v175;
                      uint64_t v75 = (void ***)((char *)v175 + v100);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v95, 24);
                      uint64_t v75 = &v170;
                      uint64_t v74 = (char *)v175;
                    }
                  }
                  else
                  {
                    uint64_t v75 = &v170;
                  }
                  char v76 = &v74[24 * v176];
                  long long v77 = *(_OWORD *)v75;
                  *((void *)v76 + 2) = v75[2];
                  *(_OWORD *)char v76 = v77;
                  ++v176;
                  if (v173)
                  {
                    long long v78 = &v170;
                    mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v170, (uint64_t)v56);
                    uint64_t v79 = (char *)v175;
                    if (v176 >= v177)
                    {
                      unint64_t v97 = v176 + 1;
                      if (v175 <= &v170 && (char *)v175 + 24 * v176 > (char *)&v170)
                      {
                        int64_t v101 = (char *)&v170 - (unsigned char *)v175;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v97, 24);
                        uint64_t v79 = (char *)v175;
                        long long v78 = (void ***)((char *)v175 + v101);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v97, 24);
                        long long v78 = &v170;
                        uint64_t v79 = (char *)v175;
                      }
                    }
                    uint64_t v80 = &v79[24 * v176];
                    long long v81 = *(_OWORD *)v78;
                    *((void *)v80 + 2) = v78[2];
                    *(_OWORD *)uint64_t v80 = v81;
                    ++v176;
                  }
                }
              }
            }
            char v82 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v173);
            if (v173) {
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v173);
            }
            if (v183)
            {
              uint64_t v83 = __p;
              if (__p)
              {
                uint64_t v84 = v182;
                uint64_t v85 = __p;
                if (v182 != __p)
                {
                  do
                    uint64_t v84 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v84 - 1);
                  while (v84 != v83);
                  uint64_t v85 = __p;
                }
                int64_t v182 = v83;
                operator delete(v85);
              }
              unint64_t v86 = v179;
              if (v179)
              {
                unint64_t v87 = v7;
                unint64_t v88 = v180;
                unint64_t v89 = v179;
                if (v180 != v179)
                {
                  do
                  {
                    uint64_t v91 = *--v88;
                    uint64_t v90 = v91;
                    *unint64_t v88 = 0;
                    if (v91) {
                      MEMORY[0x21667D390](v90, 0x1000C8077774924);
                    }
                  }
                  while (v88 != v86);
                  unint64_t v89 = v179;
                }
                unint64_t v180 = v86;
                operator delete(v89);
                uint64_t v7 = v87;
              }
              if (v175 != v178) {
                free(v175);
              }
            }
            if (!v82) {
              return 0;
            }
LABEL_62:
            ++v54;
            ++v53;
          }
          while (v53 != v51);
        }
        if (*((_DWORD *)*this + 9)) {
          uint64_t v102 = (uint64_t)(*this - 2);
        }
        else {
          uint64_t v102 = 0;
        }
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v102, 0);
        uint64_t v104 = (uint64_t)*this;
        unint64_t v105 = (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
        uint64_t v106 = (void *)*((void *)*v105 + 17);
        if (v106 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id || v106 == v7)
        {
          uint64_t v108 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v105 + 8);
          uint64_t v173 = v105;
          uint64_t v174 = v108;
          uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v173);
          if (mlir::Type::isF32((mlir::Type *)&OperandRange))
          {
            uint64_t v109 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v105 + 8);
            int64_t v164 = v105;
            uint64_t v165 = v109;
            if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v164))
            {
              Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v164);
              if (v111)
              {
                uint64_t v112 = 8 * v111;
                while (*Shape != 0x8000000000000000)
                {
                  ++Shape;
                  v112 -= 8;
                  if (!v112) {
                    goto LABEL_133;
                  }
                }
              }
              else
              {
LABEL_133:
                uint64_t v113 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v105 + 8);
                uint64_t v170 = v105;
                int v171 = (const char *)v113;
                if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v170))
                {
                  uint64_t v114 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v105 + 8);
                  int64_t v167 = v105;
                  uint64_t v168 = v114;
                  mlir::ShapedType::getShape((mlir::ShapedType *)&v167);
                  if (v115 == 2) {
                    return 1;
                  }
                }
              }
            }
          }
        }
        __int16 v166 = 261;
        int64_t v164 = (void **)"result";
        uint64_t v165 = 6;
        mlir::Operation::emitOpError(v104, &v164, (uint64_t)&v173);
        if (v173)
        {
          LODWORD(v170) = 3;
          int v171 = " #";
          uint64_t v172 = 2;
          char v116 = &v170;
          uint64_t v117 = (char *)v175;
          if (v176 >= v177)
          {
            unint64_t v145 = v176 + 1;
            if (v175 <= &v170 && (char *)v175 + 24 * v176 > (char *)&v170)
            {
              int64_t v157 = (char *)&v170 - (unsigned char *)v175;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v145, 24);
              uint64_t v117 = (char *)v175;
              char v116 = (void ***)((char *)v175 + v157);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v145, 24);
              char v116 = &v170;
              uint64_t v117 = (char *)v175;
            }
          }
          uint64_t v118 = &v117[24 * v176];
          long long v119 = *(_OWORD *)v116;
          *((void *)v118 + 2) = v116[2];
          *(_OWORD *)uint64_t v118 = v119;
          uint64_t v120 = ++v176;
          if (v173)
          {
            LODWORD(v170) = 5;
            int v171 = 0;
            unsigned int v121 = &v170;
            uint64_t v122 = (char *)v175;
            if (v120 >= v177)
            {
              unint64_t v148 = v120 + 1;
              BOOL v149 = (char *)v175 + 24 * v120 > (char *)&v170;
              if (v175 <= &v170 && v149)
              {
                int64_t v159 = (char *)&v170 - (unsigned char *)v175;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v148, 24);
                uint64_t v122 = (char *)v175;
                unsigned int v121 = (void ***)((char *)v175 + v159);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v148, 24);
                unsigned int v121 = &v170;
                uint64_t v122 = (char *)v175;
              }
            }
            uint64_t v123 = &v122[24 * v176];
            long long v124 = *(_OWORD *)v121;
            *((void *)v123 + 2) = v121[2];
            *(_OWORD *)uint64_t v123 = v124;
            uint64_t v125 = ++v176;
            if (v173)
            {
              LODWORD(v170) = 3;
              int v171 = " must be static-shape defined tensor with rank equal to any of:2, but got ";
              uint64_t v172 = 74;
              BOOL v126 = &v170;
              unint64_t v127 = (char *)v175;
              if (v125 >= v177)
              {
                unint64_t v152 = v125 + 1;
                BOOL v153 = (char *)v175 + 24 * v125 > (char *)&v170;
                if (v175 <= &v170 && v153)
                {
                  int64_t v161 = (char *)&v170 - (unsigned char *)v175;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v152, 24);
                  unint64_t v127 = (char *)v175;
                  BOOL v126 = (void ***)((char *)v175 + v161);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v152, 24);
                  BOOL v126 = &v170;
                  unint64_t v127 = (char *)v175;
                }
              }
              BOOL v128 = &v127[24 * v176];
              long long v129 = *(_OWORD *)v126;
              *((void *)v128 + 2) = v126[2];
              *(_OWORD *)BOOL v128 = v129;
              ++v176;
              if (v173)
              {
                char v130 = &v170;
                mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v170, (uint64_t)v105);
                uint64_t v131 = (char *)v175;
                if (v176 >= v177)
                {
                  unint64_t v155 = v176 + 1;
                  if (v175 <= &v170 && (char *)v175 + 24 * v176 > (char *)&v170)
                  {
                    int64_t v163 = (char *)&v170 - (unsigned char *)v175;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v155, 24);
                    uint64_t v131 = (char *)v175;
                    char v130 = (void ***)((char *)v175 + v163);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v155, 24);
                    char v130 = &v170;
                    uint64_t v131 = (char *)v175;
                  }
                }
                BOOL v132 = &v131[24 * v176];
                long long v133 = *(_OWORD *)v130;
                *((void *)v132 + 2) = v130[2];
                *(_OWORD *)BOOL v132 = v133;
                ++v176;
              }
            }
          }
        }
        char v134 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v173);
        if (v173) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v173);
        }
        if (v183)
        {
          int64_t v135 = __p;
          if (__p)
          {
            int64_t v136 = v182;
            int64_t v137 = __p;
            if (v182 != __p)
            {
              do
                int64_t v136 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v136 - 1);
              while (v136 != v135);
              int64_t v137 = __p;
            }
            int64_t v182 = v135;
            operator delete(v137);
          }
          int64_t v138 = v179;
          if (v179)
          {
            int64_t v139 = v180;
            int64_t v140 = v179;
            if (v180 != v179)
            {
              do
              {
                uint64_t v142 = *--v139;
                uint64_t v141 = v142;
                *int64_t v139 = 0;
                if (v142) {
                  MEMORY[0x21667D390](v141, 0x1000C8077774924);
                }
              }
              while (v139 != v138);
              int64_t v140 = v179;
            }
            unint64_t v180 = v138;
            operator delete(v140);
          }
          if (v175 != v178) {
            free(v175);
          }
        }
        return v134 != 0;
      }
      uint64_t v6 = *v5;
      if (*((_UNKNOWN **)*v5 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
      {
LABEL_25:
        __int16 v166 = 261;
        int64_t v164 = (void **)"operand";
        uint64_t v165 = 7;
        mlir::Operation::emitOpError(v4, &v164, (uint64_t)&v173);
        if (v173)
        {
          LODWORD(v170) = 3;
          int v171 = " #";
          uint64_t v172 = 2;
          uint64_t v22 = &v170;
          uint64_t v23 = (char *)v175;
          if (v176 >= v177)
          {
            unint64_t v144 = v176 + 1;
            if (v175 <= &v170 && (char *)v175 + 24 * v176 > (char *)&v170)
            {
              int64_t v156 = (char *)&v170 - (unsigned char *)v175;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v144, 24);
              uint64_t v23 = (char *)v175;
              uint64_t v22 = (void ***)((char *)v175 + v156);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v144, 24);
              uint64_t v22 = &v170;
              uint64_t v23 = (char *)v175;
            }
          }
          uint64_t v24 = &v23[24 * v176];
          long long v25 = *(_OWORD *)v22;
          *((void *)v24 + 2) = v22[2];
          *(_OWORD *)uint64_t v24 = v25;
          uint64_t v26 = ++v176;
          if (v173)
          {
            LODWORD(v170) = 5;
            int v171 = 0;
            int64_t v27 = &v170;
            int64_t v28 = (char *)v175;
            if (v26 >= v177)
            {
              unint64_t v146 = v26 + 1;
              BOOL v147 = (char *)v175 + 24 * v26 > (char *)&v170;
              if (v175 <= &v170 && v147)
              {
                int64_t v158 = (char *)&v170 - (unsigned char *)v175;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v146, 24);
                int64_t v28 = (char *)v175;
                int64_t v27 = (void ***)((char *)v175 + v158);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v146, 24);
                int64_t v27 = &v170;
                int64_t v28 = (char *)v175;
              }
            }
            uint64_t v29 = &v28[24 * v176];
            long long v30 = *(_OWORD *)v27;
            *((void *)v29 + 2) = v27[2];
            *(_OWORD *)uint64_t v29 = v30;
            uint64_t v31 = ++v176;
            if (v173)
            {
              LODWORD(v170) = 3;
              int v171 = " must be unranked tensor of 32-bit float values or 1D tensor of 32-bit float values, but got ";
              uint64_t v172 = 93;
              unint64_t v32 = &v170;
              unint64_t v33 = (char *)v175;
              if (v31 >= v177)
              {
                unint64_t v150 = v31 + 1;
                BOOL v151 = (char *)v175 + 24 * v31 > (char *)&v170;
                if (v175 <= &v170 && v151)
                {
                  int64_t v160 = (char *)&v170 - (unsigned char *)v175;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v150, 24);
                  unint64_t v33 = (char *)v175;
                  unint64_t v32 = (void ***)((char *)v175 + v160);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v150, 24);
                  unint64_t v32 = &v170;
                  unint64_t v33 = (char *)v175;
                }
              }
              unint64_t v34 = &v33[24 * v176];
              long long v35 = *(_OWORD *)v32;
              *((void *)v34 + 2) = v32[2];
              *(_OWORD *)unint64_t v34 = v35;
              ++v176;
              if (v173)
              {
                int64_t v36 = &v170;
                mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v170, (uint64_t)v5);
                int64_t v37 = (char *)v175;
                if (v176 >= v177)
                {
                  unint64_t v154 = v176 + 1;
                  if (v175 <= &v170 && (char *)v175 + 24 * v176 > (char *)&v170)
                  {
                    int64_t v162 = (char *)&v170 - (unsigned char *)v175;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v154, 24);
                    int64_t v37 = (char *)v175;
                    int64_t v36 = (void ***)((char *)v175 + v162);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v154, 24);
                    int64_t v36 = &v170;
                    int64_t v37 = (char *)v175;
                  }
                }
                uint64_t v38 = &v37[24 * v176];
                long long v39 = *(_OWORD *)v36;
                *((void *)v38 + 2) = v36[2];
                *(_OWORD *)uint64_t v38 = v39;
                ++v176;
              }
            }
          }
        }
        char v40 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v173);
        if (v173) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v173);
        }
        if (v183)
        {
          unint64_t v41 = __p;
          if (__p)
          {
            uint64_t v42 = v182;
            __int16 v43 = __p;
            if (v182 != __p)
            {
              do
                uint64_t v42 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v42 - 1);
              while (v42 != v41);
              __int16 v43 = __p;
            }
            int64_t v182 = v41;
            operator delete(v43);
          }
          uint64_t v44 = v179;
          if (v179)
          {
            uint64_t v45 = v180;
            long long v46 = v179;
            if (v180 != v179)
            {
              do
              {
                uint64_t v48 = *--v45;
                uint64_t v47 = v48;
                void *v45 = 0;
                if (v48) {
                  MEMORY[0x21667D390](v47, 0x1000C8077774924);
                }
              }
              while (v45 != v44);
              long long v46 = v179;
            }
            unint64_t v180 = v44;
            operator delete(v46);
          }
          if (v175 != v178) {
            free(v175);
          }
        }
        if (!v40) {
          return 0;
        }
        goto LABEL_57;
      }
    }
    else if (v8 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
      goto LABEL_25;
    }
    int64_t v164 = v5;
    uint64_t v165 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v6 + 8);
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v164))
    {
      uint64_t v9 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v5 + 8);
      uint64_t v170 = v5;
      int v171 = (const char *)v9;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v170);
      if (v10 == 1)
      {
        uint64_t v11 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v5 + 8);
        int64_t v167 = v5;
        uint64_t v168 = v11;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v167);
        if (mlir::Type::isF32((mlir::Type *)&OperandRange)) {
          goto LABEL_57;
        }
      }
    }
    goto LABEL_25;
  }
  int64_t v164 = (void **)"requires attribute 'storage_type'";
  __int16 v166 = 259;
  mlir::OpState::emitOpError((uint64_t *)this, &v164, (uint64_t)&v173);
  uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v173);
  if (v173) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v173);
  }
  if (v183)
  {
    unint64_t v13 = __p;
    if (__p)
    {
      long long v14 = v182;
      uint64_t v15 = __p;
      if (v182 != __p)
      {
        do
          long long v14 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v14 - 1);
        while (v14 != v13);
        uint64_t v15 = __p;
      }
      int64_t v182 = v13;
      operator delete(v15);
    }
    unsigned int v16 = v179;
    if (v179)
    {
      long long v17 = v180;
      uint64_t v18 = v179;
      if (v180 != v179)
      {
        do
        {
          uint64_t v20 = *--v17;
          uint64_t v19 = v20;
          void *v17 = 0;
          if (v20) {
            MEMORY[0x21667D390](v19, 0x1000C8077774924);
          }
        }
        while (v17 != v16);
        uint64_t v18 = v179;
      }
      unint64_t v180 = v16;
      operator delete(v18);
    }
    if (v175 != v178) {
      free(v175);
    }
  }
  return v12;
}

void mlir::mps::MaterializeSparseTensorOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::MatrixDecompositionLUOpGenericAdaptorBase::MatrixDecompositionLUOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.matrix_decomposition_lu", 27, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::MatrixDecompositionLUOp::verifyInvariantsImpl(mlir::mps::MatrixDecompositionLUOp *this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps35(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0))return 0; {
  uint64_t v2 = *(_DWORD *)(*(void *)this + 36) ? *(void *)this - 16 : 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps35(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0))return 0; {
  uint64_t v4 = *(_DWORD *)(*(void *)this + 36) ? *(void *)this - 16 : 0;
  }
  uint64_t v5 = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 1);
  uint64_t v6 = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps36(*(void *)this, (void **)(*(void *)(v6 + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 1u))return 0; {
  if (*(_DWORD *)(*(void *)this + 36))
  }
    uint64_t v7 = *(void *)this - 16;
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 2);
  uint64_t v9 = mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps24(*(void *)this, *(void *)(v9 + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 2u) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps35(uint64_t a1, void **a2, void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v72 = *MEMORY[0x263EF8340];
  uint64_t v10 = *a2;
  uint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v62[0] = a2;
    v62[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v62);
    if (mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
      return 1;
    }
    uint64_t v10 = *a2;
    __int16 v43 = (void *)*((void *)*a2 + 17);
    if (v43 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v43 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_11;
    }
  }
  else if (v11 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id {
         && v11 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  }
  {
    goto LABEL_11;
  }
  uint64_t v55 = a2;
  uint64_t v56 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v55);
  if (mlir::Type::isF16((mlir::Type *)&OperandRange)
    || mlir::Type::isF32((mlir::Type *)&OperandRange)
    || mlir::Type::isBF16((mlir::Type *)&OperandRange))
  {
    uint64_t v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    uint64_t v59 = a2;
    uint64_t v60 = v13;
    mlir::ShapedType::getShape((mlir::ShapedType *)&v59);
    if (v14 >= 2) {
      return 1;
    }
  }
LABEL_11:
  __int16 v57 = 261;
  uint64_t v55 = a3;
  uint64_t v56 = a4;
  mlir::Operation::emitOpError(a1, &v55, (uint64_t)v62);
  if (v62[0])
  {
    LODWORD(v59) = 3;
    uint64_t v60 = (uint64_t)" #";
    uint64_t v61 = 2;
    uint64_t v15 = &v59;
    unsigned int v16 = (char *)v63;
    if (v64 >= v65)
    {
      unint64_t v45 = v64 + 1;
      if (v63 <= &v59 && (char *)v63 + 24 * v64 > (char *)&v59)
      {
        int64_t v51 = (char *)&v59 - (unsigned char *)v63;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v45, 24);
        unsigned int v16 = (char *)v63;
        uint64_t v15 = (void ***)((char *)v63 + v51);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v45, 24);
        uint64_t v15 = &v59;
        unsigned int v16 = (char *)v63;
      }
    }
    long long v17 = &v16[24 * v64];
    long long v18 = *(_OWORD *)v15;
    *((void *)v17 + 2) = v15[2];
    *(_OWORD *)long long v17 = v18;
    uint64_t v19 = ++v64;
    if (v62[0])
    {
      LODWORD(v59) = 5;
      uint64_t v60 = a5;
      uint64_t v20 = &v59;
      uint64_t v21 = (char *)v63;
      if (v19 >= v65)
      {
        unint64_t v46 = v19 + 1;
        BOOL v47 = (char *)v63 + 24 * v19 > (char *)&v59;
        if (v63 <= &v59 && v47)
        {
          int64_t v52 = (char *)&v59 - (unsigned char *)v63;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v46, 24);
          uint64_t v21 = (char *)v63;
          uint64_t v20 = (void ***)((char *)v63 + v52);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v46, 24);
          uint64_t v20 = &v59;
          uint64_t v21 = (char *)v63;
        }
      }
      uint64_t v22 = &v21[24 * v64];
      long long v23 = *(_OWORD *)v20;
      *((void *)v22 + 2) = v20[2];
      *(_OWORD *)uint64_t v22 = v23;
      uint64_t v24 = ++v64;
      if (v62[0])
      {
        LODWORD(v59) = 3;
        uint64_t v60 = (uint64_t)" must be unranked tensor of floating point values or ranked tensor type with rank equal to or gre"
                       "ater than 2, but got ";
        uint64_t v61 = 118;
        long long v25 = &v59;
        uint64_t v26 = (char *)v63;
        if (v24 >= v65)
        {
          unint64_t v48 = v24 + 1;
          BOOL v49 = (char *)v63 + 24 * v24 > (char *)&v59;
          if (v63 <= &v59 && v49)
          {
            int64_t v53 = (char *)&v59 - (unsigned char *)v63;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v48, 24);
            uint64_t v26 = (char *)v63;
            long long v25 = (void ***)((char *)v63 + v53);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v48, 24);
            long long v25 = &v59;
            uint64_t v26 = (char *)v63;
          }
        }
        int64_t v27 = &v26[24 * v64];
        long long v28 = *(_OWORD *)v25;
        *((void *)v27 + 2) = v25[2];
        *(_OWORD *)int64_t v27 = v28;
        ++v64;
        if (v62[0])
        {
          uint64_t v29 = &v59;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v59, (uint64_t)a2);
          long long v30 = (char *)v63;
          if (v64 >= v65)
          {
            unint64_t v50 = v64 + 1;
            if (v63 <= &v59 && (char *)v63 + 24 * v64 > (char *)&v59)
            {
              int64_t v54 = (char *)&v59 - (unsigned char *)v63;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v50, 24);
              long long v30 = (char *)v63;
              uint64_t v29 = (void ***)((char *)v63 + v54);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v50, 24);
              uint64_t v29 = &v59;
              long long v30 = (char *)v63;
            }
          }
          uint64_t v31 = &v30[24 * v64];
          long long v32 = *(_OWORD *)v29;
          *((void *)v31 + 2) = v29[2];
          *(_OWORD *)uint64_t v31 = v32;
          ++v64;
        }
      }
    }
  }
  uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v62);
  if (v62[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v62);
  }
  if (v71)
  {
    unint64_t v34 = __p;
    if (__p)
    {
      long long v35 = v70;
      int64_t v36 = __p;
      if (v70 != __p)
      {
        do
          long long v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        int64_t v36 = __p;
      }
      unsigned int v70 = v34;
      operator delete(v36);
    }
    int64_t v37 = v67;
    if (v67)
    {
      uint64_t v38 = v68;
      long long v39 = v67;
      if (v68 != v67)
      {
        do
        {
          uint64_t v41 = *--v38;
          uint64_t v40 = v41;
          void *v38 = 0;
          if (v41) {
            MEMORY[0x21667D390](v40, 0x1000C8077774924);
          }
        }
        while (v38 != v37);
        long long v39 = v67;
      }
      uint64_t v68 = v37;
      operator delete(v39);
    }
    if (v63 != v66) {
      free(v63);
    }
  }
  return v33;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps36(uint64_t a1, void **a2, void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v72 = *MEMORY[0x263EF8340];
  uint64_t v10 = *a2;
  uint64_t v11 = (void *)*((void *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v62[0] = a2;
    v62[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v62);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)) {
      return 1;
    }
    uint64_t v10 = *a2;
    unsigned int v16 = (void *)*((void *)*a2 + 17);
    if (v16 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v16 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_16;
    }
  }
  else if (v11 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id {
         && v11 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  }
  {
    goto LABEL_16;
  }
  uint64_t v55 = a2;
  uint64_t v56 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v55);
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
  {
    uint64_t v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    uint64_t v59 = a2;
    uint64_t v60 = v13;
    mlir::ShapedType::getShape((mlir::ShapedType *)&v59);
    if (v14 >= 2) {
      return 1;
    }
  }
LABEL_16:
  __int16 v57 = 261;
  uint64_t v55 = a3;
  uint64_t v56 = a4;
  mlir::Operation::emitOpError(a1, &v55, (uint64_t)v62);
  if (v62[0])
  {
    LODWORD(v59) = 3;
    uint64_t v60 = (uint64_t)" #";
    uint64_t v61 = 2;
    long long v18 = &v59;
    uint64_t v19 = (char *)v63;
    if (v64 >= v65)
    {
      unint64_t v45 = v64 + 1;
      if (v63 <= &v59 && (char *)v63 + 24 * v64 > (char *)&v59)
      {
        int64_t v51 = (char *)&v59 - (unsigned char *)v63;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v45, 24);
        uint64_t v19 = (char *)v63;
        long long v18 = (void ***)((char *)v63 + v51);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v45, 24);
        long long v18 = &v59;
        uint64_t v19 = (char *)v63;
      }
    }
    uint64_t v20 = &v19[24 * v64];
    long long v21 = *(_OWORD *)v18;
    *((void *)v20 + 2) = v18[2];
    *(_OWORD *)uint64_t v20 = v21;
    uint64_t v22 = ++v64;
    if (v62[0])
    {
      LODWORD(v59) = 5;
      uint64_t v60 = a5;
      long long v23 = &v59;
      uint64_t v24 = (char *)v63;
      if (v22 >= v65)
      {
        unint64_t v46 = v22 + 1;
        BOOL v47 = (char *)v63 + 24 * v22 > (char *)&v59;
        if (v63 <= &v59 && v47)
        {
          int64_t v52 = (char *)&v59 - (unsigned char *)v63;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v46, 24);
          uint64_t v24 = (char *)v63;
          long long v23 = (void ***)((char *)v63 + v52);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v46, 24);
          long long v23 = &v59;
          uint64_t v24 = (char *)v63;
        }
      }
      long long v25 = &v24[24 * v64];
      long long v26 = *(_OWORD *)v23;
      *((void *)v25 + 2) = v23[2];
      *(_OWORD *)long long v25 = v26;
      uint64_t v27 = ++v64;
      if (v62[0])
      {
        LODWORD(v59) = 3;
        uint64_t v60 = (uint64_t)" must be unranked tensor of 32-bit unsigned integer values or ranked tensor type with rank equal "
                       "to or greater than 2, but got ";
        uint64_t v61 = 127;
        long long v28 = &v59;
        uint64_t v29 = (char *)v63;
        if (v27 >= v65)
        {
          unint64_t v48 = v27 + 1;
          BOOL v49 = (char *)v63 + 24 * v27 > (char *)&v59;
          if (v63 <= &v59 && v49)
          {
            int64_t v53 = (char *)&v59 - (unsigned char *)v63;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v48, 24);
            uint64_t v29 = (char *)v63;
            long long v28 = (void ***)((char *)v63 + v53);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v48, 24);
            long long v28 = &v59;
            uint64_t v29 = (char *)v63;
          }
        }
        long long v30 = &v29[24 * v64];
        long long v31 = *(_OWORD *)v28;
        *((void *)v30 + 2) = v28[2];
        *(_OWORD *)long long v30 = v31;
        ++v64;
        if (v62[0])
        {
          long long v32 = &v59;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v59, (uint64_t)a2);
          uint64_t v33 = (char *)v63;
          if (v64 >= v65)
          {
            unint64_t v50 = v64 + 1;
            if (v63 <= &v59 && (char *)v63 + 24 * v64 > (char *)&v59)
            {
              int64_t v54 = (char *)&v59 - (unsigned char *)v63;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v50, 24);
              uint64_t v33 = (char *)v63;
              long long v32 = (void ***)((char *)v63 + v54);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v50, 24);
              long long v32 = &v59;
              uint64_t v33 = (char *)v63;
            }
          }
          unint64_t v34 = &v33[24 * v64];
          long long v35 = *(_OWORD *)v32;
          *((void *)v34 + 2) = v32[2];
          *(_OWORD *)unint64_t v34 = v35;
          ++v64;
        }
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v62);
  if (v62[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v62);
  }
  if (v71)
  {
    int64_t v36 = __p;
    if (__p)
    {
      int64_t v37 = v70;
      uint64_t v38 = __p;
      if (v70 != __p)
      {
        do
          int64_t v37 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v37 - 1);
        while (v37 != v36);
        uint64_t v38 = __p;
      }
      unsigned int v70 = v36;
      operator delete(v38);
    }
    long long v39 = v67;
    if (v67)
    {
      uint64_t v40 = v68;
      uint64_t v41 = v67;
      if (v68 != v67)
      {
        do
        {
          uint64_t v43 = *--v40;
          uint64_t v42 = v43;
          *uint64_t v40 = 0;
          if (v43) {
            MEMORY[0x21667D390](v42, 0x1000C8077774924);
          }
        }
        while (v40 != v39);
        uint64_t v41 = v67;
      }
      uint64_t v68 = v39;
      operator delete(v41);
    }
    if (v63 != v66) {
      free(v63);
    }
  }
  return v15;
}

void mlir::mps::MatrixDecompositionLUOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::MatrixInverseOpGenericAdaptorBase::MatrixInverseOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  unint64_t v5 = a2[11];
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.matrix_inverse", 18, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::MatrixInverseOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::MatrixSolverLUOpGenericAdaptorBase::MatrixSolverLUOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  unint64_t v5 = a2[11];
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.matrix_solver_lu", 20, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::MatrixSolverLUOp::verifyInvariantsImpl(mlir::mps::MatrixSolverLUOp *this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps35(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps36(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps35(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 2u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v2 = *(void *)this - 16;
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps35(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
}

void mlir::mps::MatrixSolverLUOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::MaximumOpGenericAdaptorBase::MaximumOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.maximum", 11, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::MaximumOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::MinimumOpGenericAdaptorBase::MinimumOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.minimum", 11, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::MinimumOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::ModuloOpGenericAdaptorBase::ModuloOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.modulo", 10, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ModuloOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::MultiplyOpGenericAdaptorBase::MultiplyOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.multiply", 12, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::MultiplyOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::NReluOpGenericAdaptorBase::NReluOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.n_relu", 10, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::NReluOp::verifyInvariantsImpl(mlir::mps::NReluOp *this)
{
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 2u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v2 = *(void *)this - 16;
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
}

void mlir::mps::NReluOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::NandOpGenericAdaptorBase::NandOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.nand", 8, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::NandOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::NegativeOpGenericAdaptorBase::NegativeOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.negative", 12, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::NegativeOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::NonMaximumSuppressionOp::getODSOperands(mlir::mps::NonMaximumSuppressionOp *this, unsigned int a2)
{
  if (a2)
  {
    if (a2 >= 8)
    {
      int32x4_t v4 = (int32x4_t)xmmword_211EE3A90;
      unsigned int v3 = a2 & 0xFFFFFFF8;
      int32x4_t v5 = 0uLL;
      v6.i64[0] = 0x200000002;
      v6.i64[1] = 0x200000002;
      v7.i64[0] = 0x100000001;
      v7.i64[1] = 0x100000001;
      v8.i64[0] = 0x800000008;
      v8.i64[1] = 0x800000008;
      unsigned int v9 = a2 & 0xFFFFFFF8;
      int32x4_t v10 = 0uLL;
      do
      {
        int32x4_t v5 = vsubq_s32(v5, vceqq_s32(v4, v6));
        int32x4_t v10 = vsubq_s32(v10, vceqq_s32(v4, v7));
        int32x4_t v4 = vaddq_s32(v4, v8);
        v9 -= 8;
      }
      while (v9);
      int v2 = vaddvq_s32(vaddq_s32(v10, v5));
      if (v3 == a2) {
        goto LABEL_11;
      }
    }
    else
    {
      int v2 = 0;
      unsigned int v3 = 0;
    }
    do
    {
      if (v3 == 2) {
        ++v2;
      }
      ++v3;
    }
    while (a2 != v3);
  }
  else
  {
    int v2 = 0;
  }
LABEL_11:
  uint64_t v11 = *(void *)this;
  if ((*(unsigned char *)(*(void *)this + 46) & 0x80) != 0)
  {
    int v12 = *(_DWORD *)(v11 + 68);
    uint64_t v13 = *(void *)(v11 + 72);
  }
  else
  {
    int v12 = 0;
    uint64_t v13 = 0;
  }
  return v13 + 32 * (a2 + (v12 - 5) * v2);
}

uint64_t mlir::mps::NonMaximumSuppressionOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v79 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v65 = v6;
  if (!v6)
  {
    a3(v69, a4);
    if (v69[0])
    {
      LODWORD(v66) = 3;
      long long v67 = "expected DictionaryAttr to set properties";
      uint64_t v68 = 41;
      long long v26 = &v66;
      uint64_t v27 = (char *)v70;
      if (v71 >= v72)
      {
        unint64_t v55 = v71 + 1;
        if (v70 <= &v66 && (char *)v70 + 24 * v71 > (char *)&v66)
        {
          int64_t v60 = (char *)&v66 - (unsigned char *)v70;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v55, 24);
          uint64_t v27 = (char *)v70;
          long long v26 = (uint64_t *)((char *)v70 + v60);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v55, 24);
          long long v26 = &v66;
          uint64_t v27 = (char *)v70;
        }
      }
      long long v28 = &v27[24 * v71];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)long long v28 = v29;
      ++v71;
      if (v69[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v69);
      }
    }
    if (!v78) {
      return 0;
    }
    long long v30 = __p;
    if (__p)
    {
      long long v31 = v77;
      long long v32 = __p;
      if (v77 != __p)
      {
        do
          long long v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        long long v32 = __p;
      }
      long long v77 = v30;
      operator delete(v32);
    }
    long long v21 = v74;
    if (!v74) {
      goto LABEL_64;
    }
    uint64_t v33 = v75;
    long long v23 = v74;
    if (v75 == v74)
    {
LABEL_63:
      uint64_t v75 = v21;
      operator delete(v23);
LABEL_64:
      if (v70 != v73) {
        free(v70);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
LABEL_62:
    long long v23 = v74;
    goto LABEL_63;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v65, "coordinate_mode", 0xFuLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id)
    {
      a3(v69, a4);
      if (v69[0])
      {
        LODWORD(v66) = 3;
        uint64_t v68 = 60;
        int32x4_t v10 = &v66;
        uint64_t v11 = (char *)v70;
        if (v71 >= v72)
        {
          unint64_t v56 = v71 + 1;
          if (v70 <= &v66 && (char *)v70 + 24 * v71 > (char *)&v66)
          {
            int64_t v61 = (char *)&v66 - (unsigned char *)v70;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v56, 24);
            uint64_t v11 = (char *)v70;
            int32x4_t v10 = (uint64_t *)((char *)v70 + v61);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v56, 24);
            int32x4_t v10 = &v66;
            uint64_t v11 = (char *)v70;
          }
        }
        int v12 = &v11[24 * v71];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = v10[2];
        *(_OWORD *)int v12 = v13;
        ++v71;
        if (v69[0])
        {
          uint64_t v14 = &v66;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v66, v9);
          uint64_t v15 = (char *)v70;
          if (v71 >= v72)
          {
            unint64_t v57 = v71 + 1;
            if (v70 <= &v66 && (char *)v70 + 24 * v71 > (char *)&v66)
            {
              int64_t v62 = (char *)&v66 - (unsigned char *)v70;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v57, 24);
              uint64_t v15 = (char *)v70;
              uint64_t v14 = (uint64_t *)((char *)v70 + v62);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v57, 24);
              uint64_t v14 = &v66;
              uint64_t v15 = (char *)v70;
            }
          }
          unsigned int v16 = &v15[24 * v71];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = v14[2];
          *(_OWORD *)unsigned int v16 = v17;
          ++v71;
          if (v69[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v69);
          }
        }
      }
      if (!v78) {
        return 0;
      }
      long long v18 = __p;
      if (__p)
      {
        uint64_t v19 = v77;
        uint64_t v20 = __p;
        if (v77 != __p)
        {
          do
            uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          uint64_t v20 = __p;
        }
        long long v77 = v18;
        operator delete(v20);
      }
      long long v21 = v74;
      if (!v74) {
        goto LABEL_64;
      }
      uint64_t v22 = v75;
      long long v23 = v74;
      if (v75 == v74) {
        goto LABEL_63;
      }
      do
      {
        uint64_t v25 = *--v22;
        uint64_t v24 = v25;
        void *v22 = 0;
        if (v25) {
          MEMORY[0x21667D390](v24, 0x1000C8077774924);
        }
      }
      while (v22 != v21);
      goto LABEL_62;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v65, "max_boxes", 9uLL);
  if (v36)
  {
    uint64_t v37 = v36;
    if (*(_UNKNOWN **)(*(void *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      a3(v69, a4);
      if (v69[0])
      {
        LODWORD(v66) = 3;
        uint64_t v68 = 54;
        uint64_t v38 = &v66;
        long long v39 = (char *)v70;
        if (v71 >= v72)
        {
          unint64_t v58 = v71 + 1;
          if (v70 <= &v66 && (char *)v70 + 24 * v71 > (char *)&v66)
          {
            int64_t v63 = (char *)&v66 - (unsigned char *)v70;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v58, 24);
            long long v39 = (char *)v70;
            uint64_t v38 = (uint64_t *)((char *)v70 + v63);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v58, 24);
            uint64_t v38 = &v66;
            long long v39 = (char *)v70;
          }
        }
        uint64_t v40 = &v39[24 * v71];
        long long v41 = *(_OWORD *)v38;
        *((void *)v40 + 2) = v38[2];
        *(_OWORD *)uint64_t v40 = v41;
        ++v71;
        if (v69[0])
        {
          uint64_t v42 = &v66;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v66, v37);
          uint64_t v43 = (char *)v70;
          if (v71 >= v72)
          {
            unint64_t v59 = v71 + 1;
            if (v70 <= &v66 && (char *)v70 + 24 * v71 > (char *)&v66)
            {
              int64_t v64 = (char *)&v66 - (unsigned char *)v70;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v59, 24);
              uint64_t v43 = (char *)v70;
              uint64_t v42 = (uint64_t *)((char *)v70 + v64);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v59, 24);
              uint64_t v42 = &v66;
              uint64_t v43 = (char *)v70;
            }
          }
          uint64_t v44 = &v43[24 * v71];
          long long v45 = *(_OWORD *)v42;
          *((void *)v44 + 2) = v42[2];
          *(_OWORD *)uint64_t v44 = v45;
          ++v71;
          if (v69[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v69);
          }
        }
      }
      if (!v78) {
        return 0;
      }
      unint64_t v46 = __p;
      if (__p)
      {
        BOOL v47 = v77;
        unint64_t v48 = __p;
        if (v77 != __p)
        {
          do
            BOOL v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          unint64_t v48 = __p;
        }
        long long v77 = v46;
        operator delete(v48);
      }
      long long v21 = v74;
      if (!v74) {
        goto LABEL_64;
      }
      BOOL v49 = v75;
      long long v23 = v74;
      if (v75 == v74) {
        goto LABEL_63;
      }
      do
      {
        uint64_t v51 = *--v49;
        uint64_t v50 = v51;
        *BOOL v49 = 0;
        if (v51) {
          MEMORY[0x21667D390](v50, 0x1000C8077774924);
        }
      }
      while (v49 != v21);
      goto LABEL_62;
    }
    a1[1] = v36;
  }
  uint64_t v52 = mlir::DictionaryAttr::get((uint64_t)&v65, "per_class_suppression", 0x15uLL);
  uint64_t v66 = v52;
  if (!v52) {
    return 1;
  }
  if (*(_UNKNOWN **)(*(void *)v52 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    a1[2] = v52;
    return 1;
  }
  a3(v69, a4);
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v53, &v66);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v69);
  return 0;
}

uint64_t mlir::mps::NonMaximumSuppressionOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v27[6] = *MEMORY[0x263EF8340];
  uint64_t v24 = a1;
  uint64_t v25 = v27;
  uint64_t v26 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v24, (uint64_t)"coordinate_mode", 15, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v26;
  if (v26 >= HIDWORD(v26))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
    unsigned int v6 = v26;
  }
  int32x4_t v7 = (uint64_t *)((char *)v25 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v26 + 1;
  LODWORD(v26) = v26 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v24, (uint64_t)"max_boxes", 9, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v26;
    if (v26 >= HIDWORD(v26))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
      unsigned int v13 = v26;
    }
    uint64_t v14 = (uint64_t *)((char *)v25 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v26 + 1;
    LODWORD(v26) = v26 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v24, (uint64_t)"per_class_suppression", 21, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v26;
    if (v26 >= HIDWORD(v26))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
      unsigned int v19 = v26;
    }
    uint64_t v20 = (uint64_t *)((char *)v25 + 16 * v19);
    uint64_t *v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v26 + 1;
    LODWORD(v26) = v26 + 1;
  }
  long long v21 = v25;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v25 == v27) {
      return DictionaryAttr;
    }
    goto LABEL_16;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v24, (uint64_t *)v25, v8);
  long long v21 = v25;
  if (v25 != v27) {
LABEL_16:
  }
    free(v21);
  return DictionaryAttr;
}

uint64_t mlir::mps::NonMaximumSuppressionOp::setInherentAttr(uint64_t result, char *__s1, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = result;
  if (a3 == 9)
  {
    uint64_t result = memcmp(__s1, "max_boxes", 9uLL);
    if (!result)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
          uint64_t v7 = a4;
        }
        else {
          uint64_t v7 = 0;
        }
        *(void *)(v5 + 8) = v7;
      }
      else
      {
        *(void *)(v5 + 8) = 0;
      }
    }
  }
  else if (a3 == 21)
  {
    uint64_t result = memcmp(__s1, "per_class_suppression", 0x15uLL);
    if (!result)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
          uint64_t v8 = a4;
        }
        else {
          uint64_t v8 = 0;
        }
        *(void *)(v5 + 16) = v8;
      }
      else
      {
        *(void *)(v5 + 16) = 0;
      }
    }
  }
  else if (a3 == 15 && *(void *)__s1 == 0x616E6964726F6F63 && *(void *)(__s1 + 7) == 0x65646F6D5F657461)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      *(void *)uint64_t result = v9;
    }
    else
    {
      *(void *)uint64_t result = 0;
    }
  }
  return result;
}

BOOL mlir::mps::NonMaximumSuppressionOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps23(v8, (void **)"coordinate_mode", (const char *)0xF, a3, a4))
  {
    uint64_t v9 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v9, (void **)"max_boxes", (const char *)9, a3, a4))
    {
      uint64_t v10 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v10, (void **)"per_class_suppression", (const char *)0x15, a3, a4))
      {
        return 1;
      }
    }
  }
  return result;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::NonMaximumSuppressionOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::NonMaximumSuppressionOp::verifyInvariantsImpl(void ***this)
{
  uint64_t v151 = *MEMORY[0x263EF8340];
  int v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    unsigned int v3 = (uint64_t *)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    unsigned int v3 = 0;
  }
  uint64_t v5 = *v3;
  uint64_t v4 = (void **)v3[1];
  uint64_t v6 = v3[2];
  int64_t v140 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v6, (void **)"per_class_suppression", (const char *)0x15, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v140))return 0; {
  int64_t v140 = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps23(v5, (void **)"coordinate_mode", (const char *)0xF, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps23(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v140))return 0; {
  int64_t v140 = *this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v4, (void **)"max_boxes", (const char *)9, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v140))return 0; {
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps9((uint64_t)*this, (void **)(*(void *)(*((void *)(*this)[9] + 3) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0))return 0;
  }
  uint64_t v7 = (uint64_t)*this;
  uint64_t v8 = (void **)(*(void *)(*((void *)(*this)[9] + 7) + 8) & 0xFFFFFFFFFFFFFFF8);
  LODWORD(v134) = 2;
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps9(v7, v8, (void **)"operand", 7, 1u)) {
    return 0;
  }
  uint64_t v9 = (uint64_t)*this;
  if ((*((unsigned char *)*this + 46) & 0x80) == 0)
  {
    uint64_t v11 = 4294967292;
    goto LABEL_11;
  }
  uint64_t v10 = (*(_DWORD *)(v9 + 68) - 2);
  uint64_t v11 = v10 - 2;
  if ((unint64_t)(v10 - 2) <= 1)
  {
    if (v10 != 2)
    {
      uint64_t v16 = *(void *)(v9 + 72) + 88;
      uint64_t v17 = 2;
      while (mlir::mps::__mlir_ods_local_type_constraint_MPSOps24((uint64_t)*this, *(void *)(*(void *)v16 + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, v17))
      {
        ++v17;
        v16 += 32;
        if (v10 == v17) {
          goto LABEL_18;
        }
      }
      return 0;
    }
    LODWORD(v17) = 2;
LABEL_18:
    uint64_t ODSOperands = mlir::mps::NonMaximumSuppressionOp::getODSOperands((mlir::mps::NonMaximumSuppressionOp *)this, 3u);
    if (v19)
    {
      uint64_t v20 = v19;
      uint64_t v21 = ODSOperands + 24;
      while (mlir::mps::__mlir_ods_local_type_constraint_MPSOps37((uint64_t)*this, (void **)(*(void *)(*(void *)v21 + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, v17))
      {
        LODWORD(v17) = v17 + 1;
        v21 += 32;
        if (!--v20) {
          goto LABEL_22;
        }
      }
      return 0;
    }
LABEL_22:
    uint64_t v22 = mlir::mps::NonMaximumSuppressionOp::getODSOperands((mlir::mps::NonMaximumSuppressionOp *)this, 4u);
    if (v23)
    {
      uint64_t v24 = v23;
      uint64_t v25 = v22 + 24;
      while (mlir::mps::__mlir_ods_local_type_constraint_MPSOps37((uint64_t)*this, (void **)(*(void *)(*(void *)v25 + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, v17))
      {
        LODWORD(v17) = v17 + 1;
        v25 += 32;
        if (!--v24) {
          goto LABEL_26;
        }
      }
      return 0;
    }
LABEL_26:
    if (*((_DWORD *)*this + 9)) {
      uint64_t v26 = (uint64_t)(*this - 2);
    }
    else {
      uint64_t v26 = 0;
    }
    uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v26, 0);
    uint64_t v28 = (uint64_t)*this;
    long long v29 = (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
    long long v30 = *v29;
    long long v31 = (void *)*((void *)*v29 + 17);
    if (v31 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      uint64_t v35 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v30 + 8);
      int64_t v140 = v29;
      uint64_t v141 = v35;
      v133[0] = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v140);
      if (mlir::Type::isSignedInteger((mlir::Type *)v133, 32) || mlir::Type::isSignedInteger((mlir::Type *)v133, 64)) {
        goto LABEL_67;
      }
      long long v30 = *v29;
      if (*((_UNKNOWN **)*v29 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
      {
LABEL_31:
        BOOL v128 = v29;
        uint64_t v129 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v30 + 8);
        if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v128))
        {
          uint64_t v32 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v29 + 8);
          uint64_t v137 = (uint64_t)v29;
          uint64_t v138 = v32;
          mlir::ShapedType::getShape((mlir::ShapedType *)&v137);
          if (v33 == 3)
          {
            uint64_t v34 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v29 + 8);
            char v134 = v29;
            uint64_t v135 = v34;
            v133[0] = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v134);
            if (mlir::Type::isSignedInteger((mlir::Type *)v133, 32)
              || mlir::Type::isSignedInteger((mlir::Type *)v133, 64))
            {
              goto LABEL_67;
            }
          }
        }
      }
    }
    else if (v31 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
      goto LABEL_31;
    }
    __int16 v130 = 261;
    BOOL v128 = (void **)"result";
    uint64_t v129 = 6;
    mlir::Operation::emitOpError(v28, &v128, (uint64_t)&v140);
    if (v140)
    {
      LODWORD(v137) = 3;
      uint64_t v138 = (uint64_t)" #";
      uint64_t v139 = 2;
      uint64_t v36 = &v137;
      uint64_t v37 = (char *)v142;
      if (v143 >= v144)
      {
        unint64_t v108 = v143 + 1;
        if (v142 <= &v137 && (char *)v142 + 24 * v143 > (char *)&v137)
        {
          int64_t v120 = (char *)&v137 - (unsigned char *)v142;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v108, 24);
          uint64_t v37 = (char *)v142;
          uint64_t v36 = (uint64_t *)((char *)v142 + v120);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v108, 24);
          uint64_t v36 = &v137;
          uint64_t v37 = (char *)v142;
        }
      }
      uint64_t v38 = &v37[24 * v143];
      long long v39 = *(_OWORD *)v36;
      *((void *)v38 + 2) = v36[2];
      *(_OWORD *)uint64_t v38 = v39;
      uint64_t v40 = ++v143;
      if (v140)
      {
        LODWORD(v137) = 5;
        uint64_t v138 = 0;
        long long v41 = &v137;
        uint64_t v42 = (char *)v142;
        if (v40 >= v144)
        {
          unint64_t v110 = v40 + 1;
          BOOL v111 = (char *)v142 + 24 * v40 > (char *)&v137;
          if (v142 <= &v137 && v111)
          {
            int64_t v122 = (char *)&v137 - (unsigned char *)v142;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v110, 24);
            uint64_t v42 = (char *)v142;
            long long v41 = (uint64_t *)((char *)v142 + v122);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v110, 24);
            long long v41 = &v137;
            uint64_t v42 = (char *)v142;
          }
        }
        uint64_t v43 = &v42[24 * v143];
        long long v44 = *(_OWORD *)v41;
        *((void *)v43 + 2) = v41[2];
        *(_OWORD *)uint64_t v43 = v44;
        uint64_t v45 = ++v143;
        if (v140)
        {
          LODWORD(v137) = 3;
          uint64_t v138 = (uint64_t)" must be unranked tensor of mps index type values or 3D tensor of mps index type values, but got ";
          uint64_t v139 = 97;
          unint64_t v46 = &v137;
          BOOL v47 = (char *)v142;
          if (v45 >= v144)
          {
            unint64_t v114 = v45 + 1;
            BOOL v115 = (char *)v142 + 24 * v45 > (char *)&v137;
            if (v142 <= &v137 && v115)
            {
              int64_t v124 = (char *)&v137 - (unsigned char *)v142;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v114, 24);
              BOOL v47 = (char *)v142;
              unint64_t v46 = (uint64_t *)((char *)v142 + v124);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v114, 24);
              unint64_t v46 = &v137;
              BOOL v47 = (char *)v142;
            }
          }
          unint64_t v48 = &v47[24 * v143];
          long long v49 = *(_OWORD *)v46;
          *((void *)v48 + 2) = v46[2];
          *(_OWORD *)unint64_t v48 = v49;
          ++v143;
          if (v140)
          {
            uint64_t v50 = &v137;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v137, (uint64_t)v29);
            uint64_t v51 = (char *)v142;
            if (v143 >= v144)
            {
              unint64_t v118 = v143 + 1;
              if (v142 <= &v137 && (char *)v142 + 24 * v143 > (char *)&v137)
              {
                int64_t v126 = (char *)&v137 - (unsigned char *)v142;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v118, 24);
                uint64_t v51 = (char *)v142;
                uint64_t v50 = (uint64_t *)((char *)v142 + v126);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v118, 24);
                uint64_t v50 = &v137;
                uint64_t v51 = (char *)v142;
              }
            }
            uint64_t v52 = &v51[24 * v143];
            long long v53 = *(_OWORD *)v50;
            *((void *)v52 + 2) = v50[2];
            *(_OWORD *)uint64_t v52 = v53;
            ++v143;
          }
        }
      }
    }
    char v54 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v140);
    if (v140) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v140);
    }
    if (v150)
    {
      unint64_t v55 = __p;
      if (__p)
      {
        unint64_t v56 = v149;
        unint64_t v57 = __p;
        if (v149 != __p)
        {
          do
            unint64_t v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
          while (v56 != v55);
          unint64_t v57 = __p;
        }
        BOOL v149 = v55;
        operator delete(v57);
      }
      unint64_t v58 = v146;
      if (v146)
      {
        unint64_t v59 = v147;
        int64_t v60 = v146;
        if (v147 != v146)
        {
          do
          {
            uint64_t v62 = *--v59;
            uint64_t v61 = v62;
            *unint64_t v59 = 0;
            if (v62) {
              MEMORY[0x21667D390](v61, 0x1000C8077774924);
            }
          }
          while (v59 != v58);
          int64_t v60 = v146;
        }
        BOOL v147 = v58;
        operator delete(v60);
      }
      if (v142 != v145) {
        free(v142);
      }
    }
    if (!v54) {
      return 0;
    }
LABEL_67:
    if (*((_DWORD *)*this + 9)) {
      uint64_t v63 = (uint64_t)(*this - 2);
    }
    else {
      uint64_t v63 = 0;
    }
    uint64_t v64 = mlir::detail::OpResultImpl::getNextResultAtOffset(v63, 1);
    uint64_t v65 = mlir::detail::OpResultImpl::getNextResultAtOffset(v64, 0);
    uint64_t v66 = (uint64_t)*this;
    long long v67 = (void **)(*(void *)(v65 + 8) & 0xFFFFFFFFFFFFFFF8);
    uint64_t v68 = (_UNKNOWN **)*v67;
    if (*((_UNKNOWN **)*v67 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
      uint64_t v69 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v68 + 1));
      int64_t v140 = v67;
      uint64_t v141 = v69;
      int ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v140);
      uint64_t v68 = (_UNKNOWN **)*v67;
      if (ArgOperands)
      {
        uint64_t v71 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v68 + 1));
        BOOL v128 = v67;
        uint64_t v129 = v71;
        mlir::ShapedType::getShape((mlir::ShapedType *)&v128);
        uint64_t v68 = (_UNKNOWN **)*v67;
        if (!v72)
        {
          uint64_t v73 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v68 + 1));
          uint64_t v137 = (uint64_t)v67;
          uint64_t v138 = v73;
          uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v137);
          if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)) {
            return 1;
          }
          uint64_t v68 = (_UNKNOWN **)*v67;
        }
      }
    }
    if (v68[17] != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
      goto LABEL_80;
    }
    uint64_t v74 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v68 + 1));
    char v134 = v67;
    uint64_t v135 = v74;
    int v75 = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v134);
    uint64_t v68 = (_UNKNOWN **)*v67;
    if (!v75) {
      goto LABEL_80;
    }
    uint64_t v76 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v68 + 1));
    v133[0] = v67;
    v133[1] = v76;
    mlir::ShapedType::getShape((mlir::ShapedType *)v133);
    uint64_t v68 = (_UNKNOWN **)*v67;
    if (v77 != 1) {
      goto LABEL_80;
    }
    uint64_t v78 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v68 + 1));
    v132[0] = v67;
    v132[1] = v78;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v132);
    if (!mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
    {
      uint64_t v68 = (_UNKNOWN **)*v67;
LABEL_80:
      if (v68[17] == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
      {
        uint64_t v79 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v68 + 1));
        v131[0] = v67;
        v131[1] = v79;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v131);
        if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)) {
          return 1;
        }
      }
      __int16 v130 = 261;
      BOOL v128 = (void **)"result";
      uint64_t v129 = 6;
      mlir::Operation::emitOpError(v66, &v128, (uint64_t)&v140);
      if (v140)
      {
        LODWORD(v137) = 3;
        uint64_t v138 = (uint64_t)" #";
        uint64_t v139 = 2;
        uint64_t v80 = &v137;
        long long v81 = (char *)v142;
        if (v143 >= v144)
        {
          unint64_t v109 = v143 + 1;
          if (v142 <= &v137 && (char *)v142 + 24 * v143 > (char *)&v137)
          {
            int64_t v121 = (char *)&v137 - (unsigned char *)v142;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v109, 24);
            long long v81 = (char *)v142;
            uint64_t v80 = (uint64_t *)((char *)v142 + v121);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v109, 24);
            uint64_t v80 = &v137;
            long long v81 = (char *)v142;
          }
        }
        char v82 = &v81[24 * v143];
        long long v83 = *(_OWORD *)v80;
        *((void *)v82 + 2) = v80[2];
        *(_OWORD *)char v82 = v83;
        uint64_t v84 = ++v143;
        if (v140)
        {
          LODWORD(v137) = 5;
          uint64_t v138 = 1;
          uint64_t v85 = &v137;
          unint64_t v86 = (char *)v142;
          if (v84 >= v144)
          {
            unint64_t v112 = v84 + 1;
            BOOL v113 = (char *)v142 + 24 * v84 > (char *)&v137;
            if (v142 <= &v137 && v113)
            {
              int64_t v123 = (char *)&v137 - (unsigned char *)v142;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v112, 24);
              unint64_t v86 = (char *)v142;
              uint64_t v85 = (uint64_t *)((char *)v142 + v123);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v112, 24);
              uint64_t v85 = &v137;
              unint64_t v86 = (char *)v142;
            }
          }
          unint64_t v87 = &v86[24 * v143];
          long long v88 = *(_OWORD *)v85;
          *((void *)v87 + 2) = v85[2];
          *(_OWORD *)unint64_t v87 = v88;
          uint64_t v89 = ++v143;
          if (v140)
          {
            LODWORD(v137) = 3;
            uint64_t v138 = (uint64_t)" must be 0D tensor of 32-bit unsigned integer values or 1D tensor of 32-bit unsigned integer"
                            " values or unranked tensor of 32-bit unsigned integer values, but got ";
            uint64_t v139 = 162;
            uint64_t v90 = &v137;
            uint64_t v91 = (char *)v142;
            if (v89 >= v144)
            {
              unint64_t v116 = v89 + 1;
              BOOL v117 = (char *)v142 + 24 * v89 > (char *)&v137;
              if (v142 <= &v137 && v117)
              {
                int64_t v125 = (char *)&v137 - (unsigned char *)v142;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v116, 24);
                uint64_t v91 = (char *)v142;
                uint64_t v90 = (uint64_t *)((char *)v142 + v125);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v116, 24);
                uint64_t v90 = &v137;
                uint64_t v91 = (char *)v142;
              }
            }
            unint64_t v92 = &v91[24 * v143];
            long long v93 = *(_OWORD *)v90;
            *((void *)v92 + 2) = v90[2];
            *(_OWORD *)unint64_t v92 = v93;
            ++v143;
            if (v140)
            {
              BOOL v94 = &v137;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v137, (uint64_t)v67);
              unint64_t v95 = (char *)v142;
              if (v143 >= v144)
              {
                unint64_t v119 = v143 + 1;
                if (v142 <= &v137 && (char *)v142 + 24 * v143 > (char *)&v137)
                {
                  int64_t v127 = (char *)&v137 - (unsigned char *)v142;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v119, 24);
                  unint64_t v95 = (char *)v142;
                  BOOL v94 = (uint64_t *)((char *)v142 + v127);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v142, v145, v119, 24);
                  BOOL v94 = &v137;
                  unint64_t v95 = (char *)v142;
                }
              }
              BOOL v96 = &v95[24 * v143];
              long long v97 = *(_OWORD *)v94;
              *((void *)v96 + 2) = v94[2];
              *(_OWORD *)BOOL v96 = v97;
              ++v143;
            }
          }
        }
      }
      char v98 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v140);
      if (v140) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v140);
      }
      if (v150)
      {
        int64_t v99 = __p;
        if (__p)
        {
          int64_t v100 = v149;
          int64_t v101 = __p;
          if (v149 != __p)
          {
            do
              int64_t v100 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v100 - 1);
            while (v100 != v99);
            int64_t v101 = __p;
          }
          BOOL v149 = v99;
          operator delete(v101);
        }
        uint64_t v102 = v146;
        if (v146)
        {
          uint64_t v103 = v147;
          uint64_t v104 = v146;
          if (v147 != v146)
          {
            do
            {
              uint64_t v106 = *--v103;
              uint64_t v105 = v106;
              *uint64_t v103 = 0;
              if (v106) {
                MEMORY[0x21667D390](v105, 0x1000C8077774924);
              }
            }
            while (v103 != v102);
            uint64_t v104 = v146;
          }
          BOOL v147 = v102;
          operator delete(v104);
        }
        if (v142 != v145) {
          free(v142);
        }
      }
      return v98 != 0;
    }
    return 1;
  }
LABEL_11:
  BOOL v128 = (void **)"operand group starting at #";
  __int16 v130 = 259;
  mlir::OpState::emitOpError((uint64_t *)this, &v128, (uint64_t)&v140);
  uint64_t v12 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)&v140, (unsigned int *)&v134);
  uint64_t v13 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v12, " requires 0 or 1 element, but found ");
  uint64_t v137 = v11;
  uint64_t v14 = mlir::InFlightDiagnostic::operator<<<unsigned long &>(v13, &v137);
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v14);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v140);
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps37(uint64_t a1, void **a2, void **a3, uint64_t a4, unsigned int a5)
{
  uint64_t v82 = *MEMORY[0x263EF8340];
  uint64_t v10 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
    goto LABEL_4;
  }
  v71[0] = a2;
  v71[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  int ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v71);
  uint64_t v10 = *a2;
  if (!ArgOperands) {
    goto LABEL_4;
  }
  uint64_t v61 = a2;
  uint64_t v62 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  mlir::ShapedType::getShape((mlir::ShapedType *)&v61);
  uint64_t v10 = *a2;
  if (!v12)
  {
    uint64_t v47 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
    uint64_t v68 = a2;
    uint64_t v69 = v47;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v68);
    if (mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
      return 1;
    }
    uint64_t v10 = *a2;
    long long v49 = (void *)*((void *)*a2 + 17);
    if (v49 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v49 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_14;
    }
  }
  else
  {
LABEL_4:
    uint64_t v13 = (void *)v10[17];
    if (v13 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v13 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_14;
    }
  }
  uint64_t v15 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  v66[0] = a2;
  v66[1] = v15;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v66);
  if (mlir::Type::isF16((mlir::Type *)&OperandRange)
    || mlir::Type::isF32((mlir::Type *)&OperandRange)
    || mlir::Type::isBF16((mlir::Type *)&OperandRange))
  {
    uint64_t v16 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    v65[0] = a2;
    v65[1] = v16;
    Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v65);
    uint64_t v81 = 1;
    if (v18 == 1 && *Shape == v81) {
      return 1;
    }
  }
LABEL_14:
  if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    uint64_t v46 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    v64[0] = a2;
    v64[1] = v46;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v64);
    if (mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
      return 1;
    }
  }
  __int16 v63 = 261;
  uint64_t v61 = a3;
  uint64_t v62 = a4;
  mlir::Operation::emitOpError(a1, &v61, (uint64_t)v71);
  if (v71[0])
  {
    LODWORD(v68) = 3;
    uint64_t v69 = (uint64_t)" #";
    uint64_t v70 = 2;
    uint64_t v19 = &v68;
    uint64_t v20 = (char *)v72;
    if (v73 >= v74)
    {
      unint64_t v51 = v73 + 1;
      if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
      {
        int64_t v57 = (char *)&v68 - (unsigned char *)v72;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v51, 24);
        uint64_t v20 = (char *)v72;
        uint64_t v19 = (void ***)((char *)v72 + v57);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v51, 24);
        uint64_t v19 = &v68;
        uint64_t v20 = (char *)v72;
      }
    }
    uint64_t v21 = &v20[24 * v73];
    long long v22 = *(_OWORD *)v19;
    *((void *)v21 + 2) = v19[2];
    *(_OWORD *)uint64_t v21 = v22;
    uint64_t v23 = ++v73;
    if (v71[0])
    {
      LODWORD(v68) = 5;
      uint64_t v69 = a5;
      uint64_t v24 = &v68;
      uint64_t v25 = (char *)v72;
      if (v23 >= v74)
      {
        unint64_t v52 = v23 + 1;
        BOOL v53 = (char *)v72 + 24 * v23 > (char *)&v68;
        if (v72 <= &v68 && v53)
        {
          int64_t v58 = (char *)&v68 - (unsigned char *)v72;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v52, 24);
          uint64_t v25 = (char *)v72;
          uint64_t v24 = (void ***)((char *)v72 + v58);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v52, 24);
          uint64_t v24 = &v68;
          uint64_t v25 = (char *)v72;
        }
      }
      uint64_t v26 = &v25[24 * v73];
      long long v27 = *(_OWORD *)v24;
      *((void *)v26 + 2) = v24[2];
      *(_OWORD *)uint64_t v26 = v27;
      uint64_t v28 = ++v73;
      if (v71[0])
      {
        LODWORD(v68) = 3;
        uint64_t v69 = (uint64_t)" must be 0D tensor of floating point values or static-shape defined tensor with shape equal to [1"
                       "] or unranked tensor of floating point values, but got ";
        uint64_t v70 = 152;
        long long v29 = &v68;
        long long v30 = (char *)v72;
        if (v28 >= v74)
        {
          unint64_t v54 = v28 + 1;
          BOOL v55 = (char *)v72 + 24 * v28 > (char *)&v68;
          if (v72 <= &v68 && v55)
          {
            int64_t v59 = (char *)&v68 - (unsigned char *)v72;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
            long long v30 = (char *)v72;
            long long v29 = (void ***)((char *)v72 + v59);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
            long long v29 = &v68;
            long long v30 = (char *)v72;
          }
        }
        long long v31 = &v30[24 * v73];
        long long v32 = *(_OWORD *)v29;
        *((void *)v31 + 2) = v29[2];
        *(_OWORD *)long long v31 = v32;
        ++v73;
        if (v71[0])
        {
          uint64_t v33 = &v68;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v68, (uint64_t)a2);
          uint64_t v34 = (char *)v72;
          if (v73 >= v74)
          {
            unint64_t v56 = v73 + 1;
            if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
            {
              int64_t v60 = (char *)&v68 - (unsigned char *)v72;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
              uint64_t v34 = (char *)v72;
              uint64_t v33 = (void ***)((char *)v72 + v60);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
              uint64_t v33 = &v68;
              uint64_t v34 = (char *)v72;
            }
          }
          uint64_t v35 = &v34[24 * v73];
          long long v36 = *(_OWORD *)v33;
          *((void *)v35 + 2) = v33[2];
          *(_OWORD *)uint64_t v35 = v36;
          ++v73;
        }
      }
    }
  }
  uint64_t v37 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v71);
  if (v71[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v71);
  }
  if (v80)
  {
    uint64_t v38 = __p;
    if (__p)
    {
      long long v39 = v79;
      uint64_t v40 = __p;
      if (v79 != __p)
      {
        do
          long long v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v39 - 1);
        while (v39 != v38);
        uint64_t v40 = __p;
      }
      uint64_t v79 = v38;
      operator delete(v40);
    }
    long long v41 = v76;
    if (v76)
    {
      uint64_t v42 = v77;
      uint64_t v43 = v76;
      if (v77 != v76)
      {
        do
        {
          uint64_t v45 = *--v42;
          uint64_t v44 = v45;
          *uint64_t v42 = 0;
          if (v45) {
            MEMORY[0x21667D390](v44, 0x1000C8077774924);
          }
        }
        while (v42 != v41);
        uint64_t v43 = v76;
      }
      uint64_t v77 = v41;
      operator delete(v43);
    }
    if (v72 != v75) {
      free(v72);
    }
  }
  return v37;
}

void mlir::mps::NonMaximumSuppressionOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::NonZeroOpGenericAdaptorBase::NonZeroOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.non_zero", 12, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::NonZeroOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::NorOpGenericAdaptorBase::NorOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.nor", 7, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::NorOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::NormalizationOpGenericAdaptorBase::NormalizationOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  unint64_t v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.normalization", 17, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::NormalizationOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v55 = v6;
  if (!v6)
  {
    a3(v59, a4);
    if (v59[0])
    {
      int v56 = 3;
      int64_t v57 = "expected DictionaryAttr to set properties";
      uint64_t v58 = 41;
      uint64_t v26 = &v56;
      long long v27 = (char *)v60;
      if (v61 >= v62)
      {
        unint64_t v47 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          int64_t v51 = (char *)&v56 - (unsigned char *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          long long v27 = (char *)v60;
          uint64_t v26 = (int *)((char *)v60 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          uint64_t v26 = &v56;
          long long v27 = (char *)v60;
        }
      }
      uint64_t v28 = &v27[24 * v61];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v61;
      if (v59[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
      }
    }
    if (!v68) {
      return 0;
    }
    long long v30 = __p;
    if (__p)
    {
      long long v31 = v67;
      long long v32 = __p;
      if (v67 != __p)
      {
        do
          long long v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        long long v32 = __p;
      }
      long long v67 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v64;
    if (!v64) {
      goto LABEL_59;
    }
    uint64_t v33 = v65;
    uint64_t v23 = v64;
    if (v65 == v64) {
      goto LABEL_58;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_57;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v55, "epsilon", 7uLL);
  if (!v8)
  {
    a3(v59, a4);
    if (v59[0])
    {
      int v56 = 3;
      int64_t v57 = "expected key entry for epsilon in DictionaryAttr to set Properties.";
      uint64_t v58 = 67;
      long long v36 = &v56;
      uint64_t v37 = (char *)v60;
      if (v61 >= v62)
      {
        unint64_t v49 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          int64_t v53 = (char *)&v56 - (unsigned char *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          uint64_t v37 = (char *)v60;
          long long v36 = (int *)((char *)v60 + v53);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          long long v36 = &v56;
          uint64_t v37 = (char *)v60;
        }
      }
      uint64_t v38 = &v37[24 * v61];
      long long v39 = *(_OWORD *)v36;
      *((void *)v38 + 2) = *((void *)v36 + 2);
      *(_OWORD *)uint64_t v38 = v39;
      ++v61;
      if (v59[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
      }
    }
    if (!v68) {
      return 0;
    }
    uint64_t v40 = __p;
    if (__p)
    {
      long long v41 = v67;
      uint64_t v42 = __p;
      if (v67 != __p)
      {
        do
          long long v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        uint64_t v42 = __p;
      }
      long long v67 = v40;
      operator delete(v42);
    }
    uint64_t v21 = v64;
    if (!v64) {
      goto LABEL_59;
    }
    uint64_t v43 = v65;
    uint64_t v23 = v64;
    if (v65 == v64) {
      goto LABEL_58;
    }
    do
    {
      uint64_t v45 = *--v43;
      uint64_t v44 = v45;
      void *v43 = 0;
      if (v45) {
        MEMORY[0x21667D390](v44, 0x1000C8077774924);
      }
    }
    while (v43 != v21);
    goto LABEL_57;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v59, a4);
  if (v59[0])
  {
    int v56 = 3;
    uint64_t v58 = 52;
    uint64_t v10 = &v56;
    uint64_t v11 = (char *)v60;
    if (v61 >= v62)
    {
      unint64_t v48 = v61 + 1;
      if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
      {
        int64_t v52 = (char *)&v56 - (unsigned char *)v60;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        uint64_t v11 = (char *)v60;
        uint64_t v10 = (int *)((char *)v60 + v52);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        uint64_t v10 = &v56;
        uint64_t v11 = (char *)v60;
      }
    }
    uint64_t v12 = &v11[24 * v61];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v61;
    if (v59[0])
    {
      uint64_t v14 = &v56;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v56, v9);
      uint64_t v15 = (char *)v60;
      if (v61 >= v62)
      {
        unint64_t v50 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          int64_t v54 = (char *)&v56 - (unsigned char *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          uint64_t v15 = (char *)v60;
          uint64_t v14 = (int *)((char *)v60 + v54);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          uint64_t v14 = &v56;
          uint64_t v15 = (char *)v60;
        }
      }
      uint64_t v16 = &v15[24 * v61];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)uint64_t v16 = v17;
      ++v61;
      if (v59[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
      }
    }
  }
  if (v68)
  {
    uint64_t v18 = __p;
    if (__p)
    {
      uint64_t v19 = v67;
      uint64_t v20 = __p;
      if (v67 != __p)
      {
        do
          uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        uint64_t v20 = __p;
      }
      long long v67 = v18;
      operator delete(v20);
    }
    uint64_t v21 = v64;
    if (!v64) {
      goto LABEL_59;
    }
    long long v22 = v65;
    uint64_t v23 = v64;
    if (v65 == v64)
    {
LABEL_58:
      uint64_t v65 = v21;
      operator delete(v23);
LABEL_59:
      if (v60 != v63) {
        free(v60);
      }
      return 0;
    }
    do
    {
      uint64_t v25 = *--v22;
      uint64_t v24 = v25;
      void *v22 = 0;
      if (v25) {
        MEMORY[0x21667D390](v24, 0x1000C8077774924);
      }
    }
    while (v22 != v21);
LABEL_57:
    uint64_t v23 = v64;
    goto LABEL_58;
  }
  return 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::NormalizationOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::FloatAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  unint64_t v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    uint64_t v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        uint64_t v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  uint64_t v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::FloatAttr]";
  unint64_t v41 = 65;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    uint64_t v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      uint64_t v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          uint64_t v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        uint64_t v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v19 = (char *)v46;
            uint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            uint64_t v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      uint64_t v24 = v53;
      uint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        uint64_t v25 = __p;
      }
      int64_t v53 = v23;
      operator delete(v25);
    }
    uint64_t v26 = v50;
    if (v50)
    {
      long long v27 = v51;
      uint64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        uint64_t v28 = v50;
      }
      int64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

void *mlir::mps::NormalizationOp::getEpsilon@<X0>(mlir::mps::NormalizationOp *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3 = *(void *)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  return mlir::FloatAttr::getValue((mlir::FloatAttr *)&v3, a2);
}

BOOL mlir::mps::NormalizationOp::verifyInvariantsImpl(mlir::mps::NormalizationOp *this)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(void ***)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  if (v3)
  {
    v18[0] = v2;
    if (mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(v3, (void **)"epsilon", (const char *)7, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v18)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this,
                            *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8,
                            (void **)"operand",
                            (void **)7,
                            2u)
      && mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 120) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 3u)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 152) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 4u))
    {
      if (*(_DWORD *)(*(void *)this + 36)) {
        uint64_t v4 = *(void *)this - 16;
      }
      else {
        uint64_t v4 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v16 = (void **)"requires attribute 'epsilon'";
    __int16 v17 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, &v16, (uint64_t)v18);
    uint64_t v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v18);
    if (v18[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
    }
    if (v25)
    {
      uint64_t v8 = __p;
      if (__p)
      {
        long long v9 = v24;
        unint64_t v10 = __p;
        if (v24 != __p)
        {
          do
            long long v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
          while (v9 != v8);
          unint64_t v10 = __p;
        }
        uint64_t v24 = v8;
        operator delete(v10);
      }
      unint64_t v11 = v21;
      if (v21)
      {
        uint64_t v12 = v22;
        unint64_t v13 = v21;
        if (v22 != v21)
        {
          do
          {
            uint64_t v15 = *--v12;
            uint64_t v14 = v15;
            void *v12 = 0;
            if (v15) {
              MEMORY[0x21667D390](v14, 0x1000C8077774924);
            }
          }
          while (v12 != v11);
          unint64_t v13 = v21;
        }
        uint64_t v22 = v11;
        operator delete(v13);
      }
      if (v19 != &v20) {
        free(v19);
      }
    }
  }
  return v6;
}

void mlir::mps::NormalizationOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::NotEqualToOpGenericAdaptorBase::NotEqualToOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.not_equal", 13, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::NotEqualToOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::NotOpGenericAdaptorBase::NotOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.not", 7, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::NotOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::OneHotOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::OneHotOp::verifyInvariantsImpl(mlir::mps::OneHotOp *this)
{
  uint64_t v90 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(void *)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  if (v3)
  {
    v79[0] = v2;
    if (!mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v3, (void **)"resultElementType", (const char *)0x11, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps4(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v79)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0))
    {
      return 0;
    }
    uint64_t v4 = *(void *)this;
    unint64_t v5 = (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
    unint64_t v6 = *v5;
    if (*((_UNKNOWN **)*v5 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
      goto LABEL_7;
    }
    uint64_t v7 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v6 + 1));
    v79[0] = v5;
    v79[1] = v7;
    int ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v79);
    unint64_t v6 = *v5;
    if (!ArgOperands) {
      goto LABEL_7;
    }
    uint64_t v69 = v5;
    uint64_t v70 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v6 + 1));
    mlir::ShapedType::getShape((mlir::ShapedType *)&v69);
    unint64_t v6 = *v5;
    if (!v9)
    {
      uint64_t v56 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v6 + 1));
      uint64_t v76 = v5;
      uint64_t v77 = v56;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v76);
      if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
      {
        goto LABEL_66;
      }
      unint64_t v6 = *v5;
      int64_t v57 = (void *)*((void *)*v5 + 17);
      if (v57 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
        && v57 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
      {
        goto LABEL_16;
      }
    }
    else
    {
LABEL_7:
      unint64_t v10 = (void *)v6[17];
      if (v10 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
        && v10 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
      {
        goto LABEL_16;
      }
    }
    uint64_t v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v6 + 1));
    v74[0] = v5;
    v74[1] = v12;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v74);
    if (!mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
      || (uint64_t v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v5 + 8),
          v73[0] = v5,
          v73[1] = v13,
          Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)v73),
          uint64_t v89 = 1,
          v15 != 1)
      || *Shape != v89)
    {
LABEL_16:
      if (*((_UNKNOWN **)*v5 + 17) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
      {
        uint64_t v52 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v5 + 8);
        v72[0] = v5;
        v72[1] = v52;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v72);
        if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
        {
          goto LABEL_66;
        }
      }
      __int16 v71 = 261;
      uint64_t v69 = (void **)"operand";
      uint64_t v70 = 7;
      mlir::Operation::emitOpError(v4, &v69, (uint64_t)v79);
      if (v79[0])
      {
        LODWORD(v76) = 3;
        uint64_t v77 = (uint64_t)" #";
        uint64_t v78 = 2;
        uint64_t v16 = &v76;
        __int16 v17 = (char *)v80;
        if (v81 >= v82)
        {
          unint64_t v59 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            int64_t v65 = (char *)&v76 - (unsigned char *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v59, 24);
            __int16 v17 = (char *)v80;
            uint64_t v16 = (void ***)((char *)v80 + v65);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v59, 24);
            uint64_t v16 = &v76;
            __int16 v17 = (char *)v80;
          }
        }
        uint64_t v18 = &v17[24 * v81];
        long long v19 = *(_OWORD *)v16;
        *((void *)v18 + 2) = v16[2];
        *(_OWORD *)uint64_t v18 = v19;
        uint64_t v20 = ++v81;
        if (v79[0])
        {
          LODWORD(v76) = 5;
          uint64_t v77 = 1;
          long long v21 = &v76;
          uint64_t v22 = (char *)v80;
          if (v20 >= v82)
          {
            unint64_t v60 = v20 + 1;
            BOOL v61 = (char *)v80 + 24 * v20 > (char *)&v76;
            if (v80 <= &v76 && v61)
            {
              int64_t v66 = (char *)&v76 - (unsigned char *)v80;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v60, 24);
              uint64_t v22 = (char *)v80;
              long long v21 = (void ***)((char *)v80 + v66);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v60, 24);
              long long v21 = &v76;
              uint64_t v22 = (char *)v80;
            }
          }
          uint64_t v23 = &v22[24 * v81];
          long long v24 = *(_OWORD *)v21;
          *((void *)v23 + 2) = v21[2];
          *(_OWORD *)uint64_t v23 = v24;
          uint64_t v25 = ++v81;
          if (v79[0])
          {
            LODWORD(v76) = 3;
            uint64_t v77 = (uint64_t)" must be 0D tensor of 32-bit unsigned integer or 64-bit unsigned integer values or static-sha"
                           "pe defined tensor with shape equal to [1] or unranked tensor of 32-bit unsigned integer or 64"
                           "-bit unsigned integer values, but got ";
            uint64_t v78 = 224;
            uint64_t v26 = &v76;
            long long v27 = (char *)v80;
            if (v25 >= v82)
            {
              unint64_t v62 = v25 + 1;
              BOOL v63 = (char *)v80 + 24 * v25 > (char *)&v76;
              if (v80 <= &v76 && v63)
              {
                int64_t v67 = (char *)&v76 - (unsigned char *)v80;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v62, 24);
                long long v27 = (char *)v80;
                uint64_t v26 = (void ***)((char *)v80 + v67);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v62, 24);
                uint64_t v26 = &v76;
                long long v27 = (char *)v80;
              }
            }
            uint64_t v28 = &v27[24 * v81];
            long long v29 = *(_OWORD *)v26;
            *((void *)v28 + 2) = v26[2];
            *(_OWORD *)uint64_t v28 = v29;
            ++v81;
            if (v79[0])
            {
              uint64_t v30 = &v76;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, (uint64_t)v5);
              long long v31 = (char *)v80;
              if (v81 >= v82)
              {
                unint64_t v64 = v81 + 1;
                if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
                {
                  int64_t v68 = (char *)&v76 - (unsigned char *)v80;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
                  long long v31 = (char *)v80;
                  uint64_t v30 = (void ***)((char *)v80 + v68);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
                  uint64_t v30 = &v76;
                  long long v31 = (char *)v80;
                }
              }
              unint64_t v32 = &v31[24 * v81];
              long long v33 = *(_OWORD *)v30;
              *((void *)v32 + 2) = v30[2];
              *(_OWORD *)unint64_t v32 = v33;
              ++v81;
            }
          }
        }
      }
      char v34 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v79);
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
      if (v88)
      {
        int64_t v35 = __p;
        if (__p)
        {
          int64_t v36 = v87;
          int64_t v37 = __p;
          if (v87 != __p)
          {
            do
              int64_t v36 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v36 - 1);
            while (v36 != v35);
            int64_t v37 = __p;
          }
          unint64_t v87 = v35;
          operator delete(v37);
        }
        uint64_t v38 = v84;
        if (v84)
        {
          uint64_t v39 = v85;
          uint64_t v40 = v84;
          if (v85 != v84)
          {
            do
            {
              uint64_t v42 = *--v39;
              uint64_t v41 = v42;
              void *v39 = 0;
              if (v42) {
                MEMORY[0x21667D390](v41, 0x1000C8077774924);
              }
            }
            while (v39 != v38);
            uint64_t v40 = v84;
          }
          uint64_t v85 = v38;
          operator delete(v40);
        }
        if (v80 != v83) {
          free(v80);
        }
      }
      if (v34) {
        goto LABEL_66;
      }
      return 0;
    }
LABEL_66:
    if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 2u))return 0; {
    if (*(_DWORD *)(*(void *)this + 36))
    }
      uint64_t v53 = *(void *)this - 16;
    else {
      uint64_t v53 = 0;
    }
    uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v53, 0);
    return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
  }
  uint64_t v69 = (void **)"requires attribute 'resultElementType'";
  __int16 v71 = 259;
  mlir::OpState::emitOpError((uint64_t *)this, &v69, (uint64_t)v79);
  uint64_t v43 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v79);
  if (v79[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
  }
  if (v88)
  {
    uint64_t v44 = __p;
    if (__p)
    {
      uint64_t v45 = v87;
      uint64_t v46 = __p;
      if (v87 != __p)
      {
        do
          uint64_t v45 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v45 - 1);
        while (v45 != v44);
        uint64_t v46 = __p;
      }
      unint64_t v87 = v44;
      operator delete(v46);
    }
    unsigned int v47 = v84;
    if (v84)
    {
      unsigned int v48 = v85;
      unint64_t v49 = v84;
      if (v85 != v84)
      {
        do
        {
          uint64_t v51 = *--v48;
          uint64_t v50 = v51;
          void *v48 = 0;
          if (v51) {
            MEMORY[0x21667D390](v50, 0x1000C8077774924);
          }
        }
        while (v48 != v47);
        unint64_t v49 = v84;
      }
      uint64_t v85 = v47;
      operator delete(v49);
    }
    if (v80 != v83) {
      free(v80);
    }
  }
  return v43;
}

void mlir::mps::OneHotOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::OrOpGenericAdaptorBase::OrOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.or", 6, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::OrOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::PReluOpGenericAdaptorBase::PReluOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.prelu", 9, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::PReluOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::PadGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v55 = v6;
  if (!v6)
  {
    a3(v59, a4);
    if (v59[0])
    {
      int v56 = 3;
      int64_t v57 = "expected DictionaryAttr to set properties";
      uint64_t v58 = 41;
      uint64_t v26 = &v56;
      long long v27 = (char *)v60;
      if (v61 >= v62)
      {
        unint64_t v47 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          int64_t v51 = (char *)&v56 - (unsigned char *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          long long v27 = (char *)v60;
          uint64_t v26 = (int *)((char *)v60 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          uint64_t v26 = &v56;
          long long v27 = (char *)v60;
        }
      }
      uint64_t v28 = &v27[24 * v61];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)uint64_t v28 = v29;
      ++v61;
      if (v59[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
      }
    }
    if (!v68) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      long long v31 = v67;
      unint64_t v32 = __p;
      if (v67 != __p)
      {
        do
          long long v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unint64_t v32 = __p;
      }
      int64_t v67 = v30;
      operator delete(v32);
    }
    long long v21 = v64;
    if (!v64) {
      goto LABEL_59;
    }
    long long v33 = v65;
    uint64_t v23 = v64;
    if (v65 == v64) {
      goto LABEL_58;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *long long v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_57;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v55, "paddingMode", 0xBuLL);
  if (!v8)
  {
    a3(v59, a4);
    if (v59[0])
    {
      int v56 = 3;
      int64_t v57 = "expected key entry for paddingMode in DictionaryAttr to set Properties.";
      uint64_t v58 = 71;
      int64_t v36 = &v56;
      int64_t v37 = (char *)v60;
      if (v61 >= v62)
      {
        unint64_t v49 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          int64_t v53 = (char *)&v56 - (unsigned char *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          int64_t v37 = (char *)v60;
          int64_t v36 = (int *)((char *)v60 + v53);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          int64_t v36 = &v56;
          int64_t v37 = (char *)v60;
        }
      }
      uint64_t v38 = &v37[24 * v61];
      long long v39 = *(_OWORD *)v36;
      *((void *)v38 + 2) = *((void *)v36 + 2);
      *(_OWORD *)uint64_t v38 = v39;
      ++v61;
      if (v59[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
      }
    }
    if (!v68) {
      return 0;
    }
    uint64_t v40 = __p;
    if (__p)
    {
      uint64_t v41 = v67;
      uint64_t v42 = __p;
      if (v67 != __p)
      {
        do
          uint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        uint64_t v42 = __p;
      }
      int64_t v67 = v40;
      operator delete(v42);
    }
    long long v21 = v64;
    if (!v64) {
      goto LABEL_59;
    }
    uint64_t v43 = v65;
    uint64_t v23 = v64;
    if (v65 == v64) {
      goto LABEL_58;
    }
    do
    {
      uint64_t v45 = *--v43;
      uint64_t v44 = v45;
      void *v43 = 0;
      if (v45) {
        MEMORY[0x21667D390](v44, 0x1000C8077774924);
      }
    }
    while (v43 != v21);
    goto LABEL_57;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v59, a4);
  if (v59[0])
  {
    int v56 = 3;
    uint64_t v58 = 56;
    unint64_t v10 = &v56;
    uint64_t v11 = (char *)v60;
    if (v61 >= v62)
    {
      unint64_t v48 = v61 + 1;
      if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
      {
        int64_t v52 = (char *)&v56 - (unsigned char *)v60;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        uint64_t v11 = (char *)v60;
        unint64_t v10 = (int *)((char *)v60 + v52);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        unint64_t v10 = &v56;
        uint64_t v11 = (char *)v60;
      }
    }
    uint64_t v12 = &v11[24 * v61];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v61;
    if (v59[0])
    {
      uint64_t v14 = &v56;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v56, v9);
      uint64_t v15 = (char *)v60;
      if (v61 >= v62)
      {
        unint64_t v50 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          int64_t v54 = (char *)&v56 - (unsigned char *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          uint64_t v15 = (char *)v60;
          uint64_t v14 = (int *)((char *)v60 + v54);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          uint64_t v14 = &v56;
          uint64_t v15 = (char *)v60;
        }
      }
      uint64_t v16 = &v15[24 * v61];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)uint64_t v16 = v17;
      ++v61;
      if (v59[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
      }
    }
  }
  if (v68)
  {
    uint64_t v18 = __p;
    if (__p)
    {
      long long v19 = v67;
      uint64_t v20 = __p;
      if (v67 != __p)
      {
        do
          long long v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        uint64_t v20 = __p;
      }
      int64_t v67 = v18;
      operator delete(v20);
    }
    long long v21 = v64;
    if (!v64) {
      goto LABEL_59;
    }
    uint64_t v22 = v65;
    uint64_t v23 = v64;
    if (v65 == v64)
    {
LABEL_58:
      int64_t v65 = v21;
      operator delete(v23);
LABEL_59:
      if (v60 != v63) {
        free(v60);
      }
      return 0;
    }
    do
    {
      uint64_t v25 = *--v22;
      uint64_t v24 = v25;
      void *v22 = 0;
      if (v25) {
        MEMORY[0x21667D390](v24, 0x1000C8077774924);
      }
    }
    while (v22 != v21);
LABEL_57:
    uint64_t v23 = v64;
    goto LABEL_58;
  }
  return 0;
}

uint64_t mlir::mps::PadGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x263EF8340];
  uint64_t v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"paddingMode", 11, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  uint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps33(uint64_t a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    BOOL v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        BOOL v8 = (char *)v35;
        uint64_t v7 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        BOOL v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      long long v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid PaddingMode";
        uint64_t v31 = 49;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        long long v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)long long v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = __p;
    if (__p)
    {
      long long v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          long long v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      uint64_t v42 = v16;
      operator delete(v18);
    }
    long long v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      long long v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        long long v21 = v39;
      }
      uint64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::PadGradientOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  unsigned int v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    uint64_t v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        uint64_t v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    BOOL v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)BOOL v8 = v9;
    ++v47;
  }
  uint64_t v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::PaddingModeAttr]";
  unint64_t v41 = 76;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    uint64_t v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      long long v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          long long v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        long long v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            long long v19 = (char *)v46;
            uint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            long long v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      uint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      int64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      int64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

BOOL mlir::mps::PadGradientOp::verifyInvariantsImpl(mlir::mps::PadGradientOp *this)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(void *)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  if (v3)
  {
    v18[0] = v2;
    if (mlir::mps::__mlir_ods_local_attr_constraint_MPSOps33(v3, (void **)"paddingMode", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps33(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v18)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 1u)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps24(*(void *)this,
                            *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8,
                            (void **)"operand",
                            (void **)7,
                            2u))
    {
      if (*(_DWORD *)(*(void *)this + 36)) {
        uint64_t v4 = *(void *)this - 16;
      }
      else {
        uint64_t v4 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v16 = (void **)"requires attribute 'paddingMode'";
    __int16 v17 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, &v16, (uint64_t)v18);
    uint64_t v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v18);
    if (v18[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
    }
    if (v25)
    {
      uint64_t v7 = __p;
      if (__p)
      {
        BOOL v8 = v24;
        long long v9 = __p;
        if (v24 != __p)
        {
          do
            BOOL v8 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v8 - 1);
          while (v8 != v7);
          long long v9 = __p;
        }
        uint64_t v24 = v7;
        operator delete(v9);
      }
      unint64_t v10 = v21;
      if (v21)
      {
        unint64_t v11 = v22;
        uint64_t v12 = v21;
        if (v22 != v21)
        {
          do
          {
            uint64_t v14 = *--v11;
            uint64_t v13 = v14;
            void *v11 = 0;
            if (v14) {
              MEMORY[0x21667D390](v13, 0x1000C8077774924);
            }
          }
          while (v11 != v10);
          uint64_t v12 = v21;
        }
        uint64_t v22 = v10;
        operator delete(v12);
      }
      if (v19 != &v20) {
        free(v19);
      }
    }
  }
  return v6;
}

void mlir::mps::PadGradientOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::PadOpGenericAdaptorBase::PadOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  unsigned int v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.pad", 7, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::PadOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

void mlir::mps::PadOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  v30[2] = *MEMORY[0x263EF8340];
  uint64_t v23 = a4;
  uint64_t v24 = a3;
  uint64_t v22 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v24, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v23, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  long long v9 = *a1;
  unsigned int v25 = a6;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v9);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id;
  uint64_t v29 = (uint64_t)v9;
  uint64_t v11 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingModeAttrStorage,mlir::mps::PaddingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail22PaddingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_15PaddingModeAttrEJNS2_11PaddingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id, &v25);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::PadOpGenericAdaptorBase::Properties>(a2) = v11;
  __src = v30;
  uint64_t v29 = 0x200000000;
  uint64_t v12 = *a1;
  uint64_t v13 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v27, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v16 = *(uint64_t **)(a2 + 256);
  mlir::ValueRange::ValueRange(v26, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::PadOp::inferReturnTypes(v12, v13, 1, v27[0], v27[1], Dictionary, v16, v17, v26[0], v26[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v18 = __src;
  }
  uint64_t v19 = v29;
  uint64_t v20 = *(unsigned int *)(a2 + 72);
  unint64_t v21 = v20 + v29;
  if (v21 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v21, 8);
    LODWORD(v20) = *(_DWORD *)(a2 + 72);
  }
  if (v19)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v20), v18, 8 * v19);
    LODWORD(v20) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v20 + v19;
  if (__src != v30) {
    free(__src);
  }
}

BOOL mlir::mps::PadOp::verifyInvariantsImpl(mlir::mps::PadOp *this)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(void *)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  if (v3)
  {
    v18[0] = v2;
    if (mlir::mps::__mlir_ods_local_attr_constraint_MPSOps33(v3, (void **)"paddingMode", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps33(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v18)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps24(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this,
                            (void **)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8),
                            (void **)"operand",
                            7,
                            2u))
    {
      if (*(_DWORD *)(*(void *)this + 36)) {
        uint64_t v4 = *(void *)this - 16;
      }
      else {
        uint64_t v4 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*(void *)this, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v16 = (void **)"requires attribute 'paddingMode'";
    __int16 v17 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, &v16, (uint64_t)v18);
    uint64_t v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v18);
    if (v18[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
    }
    if (v25)
    {
      uint64_t v7 = __p;
      if (__p)
      {
        BOOL v8 = v24;
        long long v9 = __p;
        if (v24 != __p)
        {
          do
            BOOL v8 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v8 - 1);
          while (v8 != v7);
          long long v9 = __p;
        }
        uint64_t v24 = v7;
        operator delete(v9);
      }
      unint64_t v10 = v21;
      if (v21)
      {
        uint64_t v11 = v22;
        uint64_t v12 = v21;
        if (v22 != v21)
        {
          do
          {
            uint64_t v14 = *--v11;
            uint64_t v13 = v14;
            void *v11 = 0;
            if (v14) {
              MEMORY[0x21667D390](v13, 0x1000C8077774924);
            }
          }
          while (v11 != v10);
          uint64_t v12 = v21;
        }
        uint64_t v22 = v10;
        operator delete(v12);
      }
      if (v19 != &v20) {
        free(v19);
      }
    }
  }
  return v6;
}

void mlir::mps::PadOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::PermuteOpGenericAdaptorBase::PermuteOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  unint64_t v5 = a2[11];
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.permute", 11, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::PermuteOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::PlaceholderOpGenericAdaptorBase::PlaceholderOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.placeholder", 15, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::PlaceholderOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::PoolAvgGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v87 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v73 = v6;
  if (!v6)
  {
    a3(v77, a4);
    if (v77[0])
    {
      LODWORD(v74) = 3;
      int v75 = "expected DictionaryAttr to set properties";
      uint64_t v76 = 41;
      uint64_t v26 = &v74;
      int64_t v27 = (char *)v78;
      if (v79 >= v80)
      {
        unint64_t v63 = v79 + 1;
        if (v78 <= &v74 && (char *)v78 + 24 * v79 > (char *)&v74)
        {
          int64_t v68 = (char *)&v74 - (unsigned char *)v78;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v63, 24);
          int64_t v27 = (char *)v78;
          uint64_t v26 = (uint64_t *)((char *)v78 + v68);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v63, 24);
          uint64_t v26 = &v74;
          int64_t v27 = (char *)v78;
        }
      }
      int64_t v28 = &v27[24 * v79];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)int64_t v28 = v29;
      ++v79;
      if (v77[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v77);
      }
    }
    if (!v86) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      uint64_t v31 = v85;
      unint64_t v32 = __p;
      if (v85 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unint64_t v32 = __p;
      }
      uint64_t v85 = v30;
      operator delete(v32);
    }
    unint64_t v21 = v82;
    if (!v82) {
      goto LABEL_71;
    }
    unint64_t v33 = v83;
    uint64_t v23 = v82;
    if (v83 == v82)
    {
LABEL_70:
      long long v83 = v21;
      operator delete(v23);
LABEL_71:
      if (v78 != v81) {
        free(v78);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *unint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_69;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v73, "ceil_mode", 9uLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v77, a4);
      if (v77[0])
      {
        LODWORD(v74) = 3;
        uint64_t v76 = 54;
        unint64_t v10 = &v74;
        uint64_t v11 = (char *)v78;
        if (v79 >= v80)
        {
          unint64_t v64 = v79 + 1;
          if (v78 <= &v74 && (char *)v78 + 24 * v79 > (char *)&v74)
          {
            int64_t v69 = (char *)&v74 - (unsigned char *)v78;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v64, 24);
            uint64_t v11 = (char *)v78;
            unint64_t v10 = (uint64_t *)((char *)v78 + v69);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v64, 24);
            unint64_t v10 = &v74;
            uint64_t v11 = (char *)v78;
          }
        }
        uint64_t v12 = &v11[24 * v79];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = v10[2];
        *(_OWORD *)uint64_t v12 = v13;
        ++v79;
        if (v77[0])
        {
          uint64_t v14 = &v74;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v74, v9);
          uint64_t v15 = (char *)v78;
          if (v79 >= v80)
          {
            unint64_t v65 = v79 + 1;
            if (v78 <= &v74 && (char *)v78 + 24 * v79 > (char *)&v74)
            {
              int64_t v70 = (char *)&v74 - (unsigned char *)v78;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v65, 24);
              uint64_t v15 = (char *)v78;
              uint64_t v14 = (uint64_t *)((char *)v78 + v70);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v65, 24);
              uint64_t v14 = &v74;
              uint64_t v15 = (char *)v78;
            }
          }
          uint64_t v16 = &v15[24 * v79];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = v14[2];
          *(_OWORD *)uint64_t v16 = v17;
          ++v79;
          if (v77[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v77);
          }
        }
      }
      if (!v86) {
        return 0;
      }
      uint64_t v18 = __p;
      if (__p)
      {
        uint64_t v19 = v85;
        uint64_t v20 = __p;
        if (v85 != __p)
        {
          do
            uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          uint64_t v20 = __p;
        }
        uint64_t v85 = v18;
        operator delete(v20);
      }
      unint64_t v21 = v82;
      if (!v82) {
        goto LABEL_71;
      }
      uint64_t v22 = v83;
      uint64_t v23 = v82;
      if (v83 == v82) {
        goto LABEL_70;
      }
      do
      {
        uint64_t v25 = *--v22;
        uint64_t v24 = v25;
        void *v22 = 0;
        if (v25) {
          MEMORY[0x21667D390](v24, 0x1000C8077774924);
        }
      }
      while (v22 != v21);
      goto LABEL_69;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v73, "dilation_rates", 0xEuLL);
  if (v36)
  {
    uint64_t v37 = v36;
    if (mlir::DenseIntElementsAttr::classof(v36))
    {
      a1[1] = v37;
      goto LABEL_45;
    }
    a3(v77, a4);
    if (v77[0])
    {
      LODWORD(v74) = 3;
      uint64_t v76 = 59;
      uint64_t v42 = &v74;
      __int16 v43 = (char *)v78;
      if (v79 >= v80)
      {
        unint64_t v66 = v79 + 1;
        if (v78 <= &v74 && (char *)v78 + 24 * v79 > (char *)&v74)
        {
          int64_t v71 = (char *)&v74 - (unsigned char *)v78;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v66, 24);
          __int16 v43 = (char *)v78;
          uint64_t v42 = (uint64_t *)((char *)v78 + v71);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v66, 24);
          uint64_t v42 = &v74;
          __int16 v43 = (char *)v78;
        }
      }
      uint64_t v44 = &v43[24 * v79];
      long long v45 = *(_OWORD *)v42;
      *((void *)v44 + 2) = v42[2];
      *(_OWORD *)uint64_t v44 = v45;
      ++v79;
      if (v77[0])
      {
        uint64_t v46 = &v74;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v74, v37);
        unsigned int v47 = (char *)v78;
        if (v79 >= v80)
        {
          unint64_t v67 = v79 + 1;
          if (v78 <= &v74 && (char *)v78 + 24 * v79 > (char *)&v74)
          {
            int64_t v72 = (char *)&v74 - (unsigned char *)v78;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v67, 24);
            unsigned int v47 = (char *)v78;
            uint64_t v46 = (uint64_t *)((char *)v78 + v72);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v81, v67, 24);
            uint64_t v46 = &v74;
            unsigned int v47 = (char *)v78;
          }
        }
        unsigned int v48 = &v47[24 * v79];
        long long v49 = *(_OWORD *)v46;
        *((void *)v48 + 2) = v46[2];
        *(_OWORD *)unsigned int v48 = v49;
        ++v79;
        if (v77[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v77);
        }
      }
    }
    if (!v86) {
      return 0;
    }
    unint64_t v50 = __p;
    if (__p)
    {
      int64_t v51 = v85;
      int64_t v52 = __p;
      if (v85 != __p)
      {
        do
          int64_t v51 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v51 - 1);
        while (v51 != v50);
        int64_t v52 = __p;
      }
      uint64_t v85 = v50;
      operator delete(v52);
    }
    unint64_t v21 = v82;
    if (!v82) {
      goto LABEL_71;
    }
    int64_t v53 = v83;
    uint64_t v23 = v82;
    if (v83 == v82) {
      goto LABEL_70;
    }
    do
    {
      uint64_t v55 = *--v53;
      uint64_t v54 = v55;
      void *v53 = 0;
      if (v55) {
        MEMORY[0x21667D390](v54, 0x1000C8077774924);
      }
    }
    while (v53 != v21);
LABEL_69:
    uint64_t v23 = v82;
    goto LABEL_70;
  }
LABEL_45:
  uint64_t v38 = mlir::DictionaryAttr::get((uint64_t)&v73, "explicit_padding", 0x10uLL);
  uint64_t v74 = v38;
  if (v38)
  {
    uint64_t v39 = v38;
    if (!mlir::DenseIntElementsAttr::classof(v38))
    {
      a3(v77, a4);
      goto LABEL_74;
    }
    a1[2] = v39;
  }
  uint64_t v40 = mlir::DictionaryAttr::get((uint64_t)&v73, "include_zero_pad", 0x10uLL);
  uint64_t v74 = v40;
  if (v40)
  {
    if (*(_UNKNOWN **)(*(void *)v40 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v77, a4);
LABEL_74:
      uint64_t v56 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v77, v41);
LABEL_89:
      mlir::InFlightDiagnostic::append<mlir::Attribute>(v56, &v74);
      goto LABEL_90;
    }
    a1[3] = v40;
  }
  uint64_t v57 = mlir::DictionaryAttr::get((uint64_t)&v73, "padding_style", 0xDuLL);
  uint64_t v74 = v57;
  if (v57)
  {
    if (*(_UNKNOWN **)(*(void *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
    {
      a3(v77, a4);
      goto LABEL_89;
    }
    a1[4] = v57;
  }
  uint64_t v58 = mlir::DictionaryAttr::get((uint64_t)&v73, "strides", 7uLL);
  uint64_t v74 = v58;
  if (v58)
  {
    uint64_t v59 = v58;
    if (!mlir::DenseIntElementsAttr::classof(v58))
    {
      a3(v77, a4);
      goto LABEL_89;
    }
    a1[5] = v59;
  }
  uint64_t v60 = mlir::DictionaryAttr::get((uint64_t)&v73, "window_sizes", 0xCuLL);
  uint64_t v74 = v60;
  if (v60)
  {
    uint64_t v61 = v60;
    if (mlir::DenseIntElementsAttr::classof(v60))
    {
      a1[6] = v61;
      return 1;
    }
    a3(v77, a4);
    goto LABEL_89;
  }
  a3(v77, a4);
  mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v77, "expected key entry for window_sizes in DictionaryAttr to set Properties.");
LABEL_90:
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v77);
  return 0;
}

uint64_t mlir::mps::PoolAvgGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v51[6] = *MEMORY[0x263EF8340];
  unsigned int v48 = a1;
  long long v49 = v51;
  uint64_t v50 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v48, (uint64_t)"ceil_mode", 9, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v50;
  if (v50 >= HIDWORD(v50))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
    unsigned int v6 = v50;
  }
  uint64_t v7 = (uint64_t *)((char *)v49 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v50 + 1;
  LODWORD(v50) = v50 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"dilation_rates", 14, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v13 = v50;
    }
    uint64_t v14 = (uint64_t *)((char *)v49 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"explicit_padding", 16, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v19 = v50;
    }
    uint64_t v20 = (uint64_t *)((char *)v49 + 16 * v19);
    uint64_t *v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"include_zero_pad", 16, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v25 = v50;
    }
    uint64_t v26 = (uint64_t *)((char *)v49 + 16 * v25);
    uint64_t *v26 = v22;
    v26[1] = v24;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"padding_style", 13, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v31 = v50;
    }
    unint64_t v32 = (uint64_t *)((char *)v49 + 16 * v31);
    uint64_t *v32 = v28;
    v32[1] = v30;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v33 = a2[5];
  if (v33)
  {
    uint64_t v34 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"strides", 7, v33);
    uint64_t v36 = v35;
    unsigned int v37 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v37 = v50;
    }
    uint64_t v38 = (uint64_t *)((char *)v49 + 16 * v37);
    uint64_t *v38 = v34;
    v38[1] = v36;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  uint64_t v39 = a2[6];
  if (v39)
  {
    uint64_t v40 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"window_sizes", 12, v39);
    uint64_t v42 = v41;
    unsigned int v43 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      unsigned int v43 = v50;
    }
    uint64_t v44 = (uint64_t *)((char *)v49 + 16 * v43);
    uint64_t *v44 = v40;
    v44[1] = v42;
    unsigned int v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  long long v45 = v49;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v49 == v51) {
      return DictionaryAttr;
    }
    goto LABEL_32;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v48, (uint64_t *)v49, v8);
  long long v45 = v49;
  if (v49 != v51) {
LABEL_32:
  }
    free(v45);
  return DictionaryAttr;
}

uint64_t mlir::mps::PoolAvgGradientOp::getInherentAttr(int a1, void *a2, void *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[5];
    case 8uLL:
    case 0xAuLL:
    case 0xBuLL:
    case 0xFuLL:
      return 0;
    case 9uLL:
      if (*__s1 != 0x646F6D5F6C696563 || *((unsigned char *)__s1 + 8) != 101) {
        return 0;
      }
      return *a2;
    case 0xCuLL:
      if (memcmp(__s1, "window_sizes", __n)) {
        return 0;
      }
      return a2[6];
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[4];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n)) {
        return 0;
      }
      return a2[1];
    case 0x10uLL:
      if (!memcmp(__s1, "explicit_padding", __n)) {
        return a2[2];
      }
      if (*__s1 != 0x5F6564756C636E69 || __s1[1] != 0x6461705F6F72657ALL) {
        return 0;
      }
      return a2[3];
    default:
      return 0;
  }
}

uint64_t mlir::mps::PoolAvgGradientOp::setInherentAttr(uint64_t result, void *__s1, size_t a3, uint64_t a4)
{
  unsigned int v6 = (void *)result;
  switch(a3)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v14 = a4;
          }
          else {
            uint64_t v14 = 0;
          }
          v6[5] = v14;
        }
        else
        {
          v6[5] = 0;
        }
      }
      break;
    case 9uLL:
      if (*__s1 == 0x646F6D5F6C696563 && *((unsigned char *)__s1 + 8) == 101)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          *(void *)uint64_t result = v8;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xCuLL:
      uint64_t result = memcmp(__s1, "window_sizes", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          v6[6] = v9;
        }
        else
        {
          v6[6] = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          v6[4] = v10;
        }
        else
        {
          v6[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v6[1] = v11;
        }
        else
        {
          v6[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", a3);
      if (result)
      {
        if (*__s1 == 0x5F6564756C636E69 && __s1[1] == 0x6461705F6F72657ALL)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
              uint64_t v13 = a4;
            }
            else {
              uint64_t v13 = 0;
            }
            v6[3] = v13;
          }
          else
          {
            v6[3] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v15 = a4;
        }
        else {
          uint64_t v15 = 0;
        }
        void v6[2] = v15;
      }
      else
      {
        void v6[2] = 0;
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::PoolAvgGradientOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"ceil_mode", 9, *a2);
  }
  uint64_t v5 = a2[1];
  if (v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"dilation_rates", 14, v5);
  }
  uint64_t v6 = a2[2];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"explicit_padding", 16, v6);
  }
  uint64_t v7 = a2[3];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"include_zero_pad", 16, v7);
  }
  uint64_t v8 = a2[4];
  if (v8) {
    mlir::NamedAttrList::append(a3, (uint64_t)"padding_style", 13, v8);
  }
  uint64_t v9 = a2[5];
  if (v9) {
    mlir::NamedAttrList::append(a3, (uint64_t)"strides", 7, v9);
  }
  uint64_t v10 = a2[6];
  if (v10)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"window_sizes", 12, v10);
  }
}

BOOL mlir::mps::PoolAvgGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v8, (void **)"ceil_mode", (const char *)9, a3, a4))
  {
    uint64_t v9 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))a3, a4))
    {
      uint64_t v10 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps34(v10, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))a3, a4))
      {
        uint64_t v11 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v11, (void **)"include_zero_pad", (const char *)0x10, a3, a4))
        {
          uint64_t v12 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v12, (void **)"padding_style", (const char *)0xD, a3, a4))
          {
            uint64_t v13 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v13, (void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))a3, a4))
            {
              uint64_t v14 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v14, (void **)"window_sizes", (const char *)0xC, (void (*)(void **__return_ptr, uint64_t))a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps34(void **a1, void **a2, const char *a3, void (*a4)(void **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1)) {
    goto LABEL_9;
  }
  uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  uint64_t v41 = a1;
  uint64_t v42 = (const char *)v10;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v41);
  uint64_t v12 = Type;
  if (Type) {
    Type = (void *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  }
  long long v45 = v12;
  uint64_t v46 = Type;
  Shape = (void *)mlir::ShapedType::getShape((mlir::ShapedType *)&v45);
  uint64_t v56 = 8;
  if (v14 == 1 && *Shape == v56)
  {
    uint64_t v38 = a1;
    v39[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v38);
    v39[1] = v15;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v39);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
  }
LABEL_9:
  a4(&v45, a5);
  if (v45)
  {
    LODWORD(v41) = 3;
    uint64_t v42 = "attribute '";
    uint64_t v43 = 11;
    uint64_t v17 = &v41;
    uint64_t v18 = (char *)v47;
    if (v48 >= v49)
    {
      unint64_t v34 = v48 + 1;
      if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
      {
        int64_t v36 = (char *)&v41 - (unsigned char *)v47;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        uint64_t v18 = (char *)v47;
        uint64_t v17 = (void ***)((char *)v47 + v36);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        uint64_t v17 = &v41;
        uint64_t v18 = (char *)v47;
      }
    }
    unsigned int v19 = &v18[24 * v48];
    long long v20 = *(_OWORD *)v17;
    *((void *)v19 + 2) = v17[2];
    *(_OWORD *)unsigned int v19 = v20;
    ++v48;
    if (v45)
    {
      __int16 v44 = 261;
      uint64_t v41 = a2;
      uint64_t v42 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
      if (v45)
      {
        LODWORD(v41) = 3;
        uint64_t v42 = "' failed to satisfy constraint: ui64 elements attribute of shape {8}";
        uint64_t v43 = 68;
        uint64_t v21 = &v41;
        uint64_t v22 = (char *)v47;
        if (v48 >= v49)
        {
          unint64_t v35 = v48 + 1;
          if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
          {
            int64_t v37 = (char *)&v41 - (unsigned char *)v47;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            uint64_t v22 = (char *)v47;
            uint64_t v21 = (void ***)((char *)v47 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            uint64_t v21 = &v41;
            uint64_t v22 = (char *)v47;
          }
        }
        uint64_t v23 = &v22[24 * v48];
        long long v24 = *(_OWORD *)v21;
        *((void *)v23 + 2) = v21[2];
        *(_OWORD *)uint64_t v23 = v24;
        ++v48;
      }
    }
  }
  uint64_t v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v45);
  if (v45) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v45);
  }
  if (v55)
  {
    unsigned int v25 = __p;
    if (__p)
    {
      uint64_t v26 = v54;
      uint64_t v27 = __p;
      if (v54 != __p)
      {
        do
          uint64_t v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        uint64_t v27 = __p;
      }
      uint64_t v54 = v25;
      operator delete(v27);
    }
    uint64_t v28 = v51;
    if (v51)
    {
      uint64_t v29 = v52;
      uint64_t v30 = v51;
      if (v52 != v51)
      {
        do
        {
          uint64_t v32 = *--v29;
          uint64_t v31 = v32;
          *uint64_t v29 = 0;
          if (v32) {
            MEMORY[0x21667D390](v31, 0x1000C8077774924);
          }
        }
        while (v29 != v28);
        uint64_t v30 = v51;
      }
      int64_t v52 = v28;
      operator delete(v30);
    }
    if (v47 != v50) {
      free(v47);
    }
  }
  return v16;
}

BOOL mlir::mps::PoolAvgGradientOp::readProperties(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::PoolAvgGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::PoolAvgGradientOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::PaddingStyleAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  uint64_t v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    uint64_t v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        uint64_t v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  uint64_t v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::PaddingStyleAttr]";
  unint64_t v41 = 77;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    uint64_t v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      uint64_t v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          uint64_t v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unsigned int v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unsigned int v19 = (char *)v46;
            uint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unsigned int v19 = (char *)v46;
          }
        }
        long long v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)long long v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      long long v24 = v53;
      unsigned int v25 = __p;
      if (v53 != __p)
      {
        do
          long long v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unsigned int v25 = __p;
      }
      int64_t v53 = v23;
      operator delete(v25);
    }
    uint64_t v26 = v50;
    if (v50)
    {
      uint64_t v27 = v51;
      uint64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        uint64_t v28 = v50;
      }
      int64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

mlir::MLIRContext *mlir::mps::PoolAvgGradientOp::populateDefaultProperties(uint64_t a1, void *a2)
{
  v17[1] = *MEMORY[0x263EF8340];
  *(void *)&long long v15 = *(void *)(a1 + 8);
  uint64_t result = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v15);
  uint64_t v14 = result;
  if (a2[5])
  {
    if (a2[1]) {
      goto LABEL_3;
    }
  }
  else
  {
    v17[0] = 4;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)&v14, 0x40u, 0);
    uint64_t v5 = (void *)mlir::RankedTensorType::get((uint64_t)v17, 1, IntegerType, 0);
    uint64_t v6 = v5;
    if (v5) {
      uint64_t v7 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
    }
    else {
      uint64_t v7 = 0;
    }
    long long v15 = xmmword_211F23850;
    long long v16 = unk_211F23860;
    uint64_t result = (mlir::MLIRContext *)mlir::DenseElementsAttr::getFromRawBuffer(v6, v7, &v15, 32, 8, 1, 0);
    a2[5] = result;
    if (a2[1])
    {
LABEL_3:
      if (a2[4]) {
        return result;
      }
LABEL_13:
      uint64_t v12 = v14;
      LODWORD(v17[0]) = 2;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v14);
      *(void *)&long long v15 = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
      *((void *)&v15 + 1) = v12;
      uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v15, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, (unsigned int *)v17);
      a2[4] = result;
      return result;
    }
  }
  v17[0] = 4;
  uint64_t v8 = mlir::Builder::getIntegerType((mlir::Builder *)&v14, 0x40u, 0);
  long long v9 = (void *)mlir::RankedTensorType::get((uint64_t)v17, 1, v8, 0);
  unint64_t v10 = v9;
  if (v9) {
    uint64_t v11 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v9 + 8);
  }
  else {
    uint64_t v11 = 0;
  }
  long long v15 = xmmword_211F23850;
  long long v16 = unk_211F23860;
  uint64_t result = (mlir::MLIRContext *)mlir::DenseElementsAttr::getFromRawBuffer(v10, v11, &v15, 32, 8, 1, 0);
  a2[1] = result;
  if (!a2[4]) {
    goto LABEL_13;
  }
  return result;
}

BOOL mlir::mps::PoolAvgGradientOp::verifyInvariantsImpl(mlir::mps::PoolAvgGradientOp *this)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = (void **)v3[6];
  if (v4)
  {
    uint64_t v5 = *v3;
    uint64_t v6 = (void **)v3[1];
    uint64_t v8 = (void **)v3[2];
    uint64_t v7 = v3[3];
    uint64_t v9 = v3[4];
    unint64_t v10 = (void **)v3[5];
    v25[0] = v2;
    if (mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v4, (void **)"window_sizes", (const char *)0xC, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v25)&& (v25[0] = *(void *)this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v10, (void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v25))&& (v25[0] = *(void *)this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v6, (void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v25))
      && (v25[0] = *(void *)this,
          mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v9, (void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v25))&& (v25[0] = *(void *)this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps34(v8, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps34(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v25))&& (v25[0] = *(void *)this, mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (void **)"ceil_mode", (const char *)9, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v25))
      && (v25[0] = *(void *)this,
          mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (void **)"include_zero_pad", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v25))&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u))
    {
      if (*(_DWORD *)(*(void *)this + 36)) {
        uint64_t v11 = *(void *)this - 16;
      }
      else {
        uint64_t v11 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v23 = (void **)"requires attribute 'window_sizes'";
    __int16 v24 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, &v23, (uint64_t)v25);
    uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v25);
    if (v25[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v25);
    }
    if (v32)
    {
      long long v15 = __p;
      if (__p)
      {
        long long v16 = v31;
        long long v17 = __p;
        if (v31 != __p)
        {
          do
            long long v16 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v16 - 1);
          while (v16 != v15);
          long long v17 = __p;
        }
        uint64_t v31 = v15;
        operator delete(v17);
      }
      uint64_t v18 = v28;
      if (v28)
      {
        unsigned int v19 = v29;
        long long v20 = v28;
        if (v29 != v28)
        {
          do
          {
            uint64_t v22 = *--v19;
            uint64_t v21 = v22;
            *unsigned int v19 = 0;
            if (v22) {
              MEMORY[0x21667D390](v21, 0x1000C8077774924);
            }
          }
          while (v19 != v18);
          long long v20 = v28;
        }
        uint64_t v29 = v18;
        operator delete(v20);
      }
      if (v26 != &v27) {
        free(v26);
      }
    }
  }
  return v13;
}

void mlir::mps::PoolAvgGradientOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::PoolAvgOpGenericAdaptorBase::PoolAvgOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v5;
  long long v9 = *(_OWORD *)(v5 + 16);
  long long v10 = *(_OWORD *)(v5 + 32);
  *(void *)(a1 + 72) = *(void *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.pooling_average", 19, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::PoolAvgOp::getInherentAttr(int a1, void *a2, void *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[5];
    case 8uLL:
    case 0xAuLL:
    case 0xBuLL:
    case 0xFuLL:
      return 0;
    case 9uLL:
      if (*__s1 != 0x646F6D5F6C696563 || *((unsigned char *)__s1 + 8) != 101) {
        return 0;
      }
      return *a2;
    case 0xCuLL:
      if (memcmp(__s1, "window_sizes", __n)) {
        return 0;
      }
      return a2[6];
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[4];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n)) {
        return 0;
      }
      return a2[1];
    case 0x10uLL:
      if (!memcmp(__s1, "explicit_padding", __n)) {
        return a2[2];
      }
      if (*__s1 != 0x5F6564756C636E69 || __s1[1] != 0x6461705F6F72657ALL) {
        return 0;
      }
      return a2[3];
    default:
      return 0;
  }
}

uint64_t mlir::mps::PoolAvgOp::setInherentAttr(uint64_t result, void *__s1, size_t a3, uint64_t a4)
{
  unint64_t v6 = (void *)result;
  switch(a3)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v14 = a4;
          }
          else {
            uint64_t v14 = 0;
          }
          v6[5] = v14;
        }
        else
        {
          v6[5] = 0;
        }
      }
      break;
    case 9uLL:
      if (*__s1 == 0x646F6D5F6C696563 && *((unsigned char *)__s1 + 8) == 101)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          *(void *)uint64_t result = v8;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xCuLL:
      uint64_t result = memcmp(__s1, "window_sizes", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          v6[6] = v9;
        }
        else
        {
          v6[6] = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          v6[4] = v10;
        }
        else
        {
          v6[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v6[1] = v11;
        }
        else
        {
          v6[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", a3);
      if (result)
      {
        if (*__s1 == 0x5F6564756C636E69 && __s1[1] == 0x6461705F6F72657ALL)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
              uint64_t v13 = a4;
            }
            else {
              uint64_t v13 = 0;
            }
            v6[3] = v13;
          }
          else
          {
            v6[3] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v15 = a4;
        }
        else {
          uint64_t v15 = 0;
        }
        void v6[2] = v15;
      }
      else
      {
        void v6[2] = 0;
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::PoolAvgOp::readProperties(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::PoolAvgOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::PoolAvgOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::mps::PoolAvgOp::getWindowSizes(mlir::mps::PoolAvgOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  return *(void *)(v1 + 48);
}

uint64_t mlir::mps::PoolAvgOp::getExplicitPadding(mlir::mps::PoolAvgOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  return *(void *)(v1 + 16);
}

BOOL mlir::mps::PoolAvgOp::verifyInvariantsImpl(mlir::mps::PoolAvgOp *this)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    uint64_t v3 = 0;
  }
  unint64_t v4 = (void **)v3[6];
  if (v4)
  {
    uint64_t v5 = *v3;
    unint64_t v6 = (void **)v3[1];
    uint64_t v8 = (void **)v3[2];
    uint64_t v7 = v3[3];
    uint64_t v9 = v3[4];
    uint64_t v10 = (void **)v3[5];
    v25[0] = v2;
    if (mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v4, (void **)"window_sizes", (const char *)0xC, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v25)&& (v25[0] = *(void *)this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v10, (void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v25))&& (v25[0] = *(void *)this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v6, (void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v25))
      && (v25[0] = *(void *)this,
          mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v9, (void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v25))&& (v25[0] = *(void *)this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps34(v8, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps34(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v25))&& (v25[0] = *(void *)this, mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (void **)"ceil_mode", (const char *)9, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v25))
      && (v25[0] = *(void *)this,
          mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (void **)"include_zero_pad", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v25))&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0))
    {
      if (*(_DWORD *)(*(void *)this + 36)) {
        uint64_t v11 = *(void *)this - 16;
      }
      else {
        uint64_t v11 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v23 = (void **)"requires attribute 'window_sizes'";
    __int16 v24 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, &v23, (uint64_t)v25);
    uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v25);
    if (v25[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v25);
    }
    if (v32)
    {
      uint64_t v15 = __p;
      if (__p)
      {
        long long v16 = v31;
        long long v17 = __p;
        if (v31 != __p)
        {
          do
            long long v16 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v16 - 1);
          while (v16 != v15);
          long long v17 = __p;
        }
        uint64_t v31 = v15;
        operator delete(v17);
      }
      uint64_t v18 = v28;
      if (v28)
      {
        unsigned int v19 = v29;
        long long v20 = v28;
        if (v29 != v28)
        {
          do
          {
            uint64_t v22 = *--v19;
            uint64_t v21 = v22;
            *unsigned int v19 = 0;
            if (v22) {
              MEMORY[0x21667D390](v21, 0x1000C8077774924);
            }
          }
          while (v19 != v18);
          long long v20 = v28;
        }
        uint64_t v29 = v18;
        operator delete(v20);
      }
      if (v26 != &v27) {
        free(v26);
      }
    }
  }
  return v13;
}

void mlir::mps::PoolAvgOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::PoolL2NormGradientOp::getInherentAttr(int a1, void *a2, void *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[5];
    case 8uLL:
    case 0xAuLL:
    case 0xBuLL:
    case 0xFuLL:
      return 0;
    case 9uLL:
      if (*__s1 != 0x646F6D5F6C696563 || *((unsigned char *)__s1 + 8) != 101) {
        return 0;
      }
      return *a2;
    case 0xCuLL:
      if (memcmp(__s1, "window_sizes", __n)) {
        return 0;
      }
      return a2[6];
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[4];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n)) {
        return 0;
      }
      return a2[1];
    case 0x10uLL:
      if (!memcmp(__s1, "explicit_padding", __n)) {
        return a2[2];
      }
      if (*__s1 != 0x5F6564756C636E69 || __s1[1] != 0x6461705F6F72657ALL) {
        return 0;
      }
      return a2[3];
    default:
      return 0;
  }
}

uint64_t mlir::mps::PoolL2NormGradientOp::setInherentAttr(uint64_t result, void *__s1, size_t a3, uint64_t a4)
{
  unint64_t v6 = (void *)result;
  switch(a3)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v14 = a4;
          }
          else {
            uint64_t v14 = 0;
          }
          v6[5] = v14;
        }
        else
        {
          v6[5] = 0;
        }
      }
      break;
    case 9uLL:
      if (*__s1 == 0x646F6D5F6C696563 && *((unsigned char *)__s1 + 8) == 101)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          *(void *)uint64_t result = v8;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xCuLL:
      uint64_t result = memcmp(__s1, "window_sizes", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          v6[6] = v9;
        }
        else
        {
          v6[6] = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          v6[4] = v10;
        }
        else
        {
          v6[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v6[1] = v11;
        }
        else
        {
          v6[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", a3);
      if (result)
      {
        if (*__s1 == 0x5F6564756C636E69 && __s1[1] == 0x6461705F6F72657ALL)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
              uint64_t v13 = a4;
            }
            else {
              uint64_t v13 = 0;
            }
            v6[3] = v13;
          }
          else
          {
            v6[3] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v15 = a4;
        }
        else {
          uint64_t v15 = 0;
        }
        void v6[2] = v15;
      }
      else
      {
        void v6[2] = 0;
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::PoolL2NormGradientOp::readProperties(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::PoolL2NormGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::PoolL2NormGradientOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

void mlir::mps::PoolL2NormGradientOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::PoolL2NormOpGenericAdaptorBase::PoolL2NormOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v5;
  long long v9 = *(_OWORD *)(v5 + 16);
  long long v10 = *(_OWORD *)(v5 + 32);
  *(void *)(a1 + 72) = *(void *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.pooling_l2_norm", 19, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::PoolL2NormOp::getInherentAttr(int a1, void *a2, void *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[5];
    case 8uLL:
    case 0xAuLL:
    case 0xBuLL:
    case 0xFuLL:
      return 0;
    case 9uLL:
      if (*__s1 != 0x646F6D5F6C696563 || *((unsigned char *)__s1 + 8) != 101) {
        return 0;
      }
      return *a2;
    case 0xCuLL:
      if (memcmp(__s1, "window_sizes", __n)) {
        return 0;
      }
      return a2[6];
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[4];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n)) {
        return 0;
      }
      return a2[1];
    case 0x10uLL:
      if (!memcmp(__s1, "explicit_padding", __n)) {
        return a2[2];
      }
      if (*__s1 != 0x5F6564756C636E69 || __s1[1] != 0x6461705F6F72657ALL) {
        return 0;
      }
      return a2[3];
    default:
      return 0;
  }
}

uint64_t mlir::mps::PoolL2NormOp::setInherentAttr(uint64_t result, void *__s1, size_t a3, uint64_t a4)
{
  unint64_t v6 = (void *)result;
  switch(a3)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v14 = a4;
          }
          else {
            uint64_t v14 = 0;
          }
          v6[5] = v14;
        }
        else
        {
          v6[5] = 0;
        }
      }
      break;
    case 9uLL:
      if (*__s1 == 0x646F6D5F6C696563 && *((unsigned char *)__s1 + 8) == 101)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          *(void *)uint64_t result = v8;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xCuLL:
      uint64_t result = memcmp(__s1, "window_sizes", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          v6[6] = v9;
        }
        else
        {
          v6[6] = 0;
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          v6[4] = v10;
        }
        else
        {
          v6[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", a3);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v6[1] = v11;
        }
        else
        {
          v6[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", a3);
      if (result)
      {
        if (*__s1 == 0x5F6564756C636E69 && __s1[1] == 0x6461705F6F72657ALL)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
              uint64_t v13 = a4;
            }
            else {
              uint64_t v13 = 0;
            }
            v6[3] = v13;
          }
          else
          {
            v6[3] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v15 = a4;
        }
        else {
          uint64_t v15 = 0;
        }
        void v6[2] = v15;
      }
      else
      {
        void v6[2] = 0;
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::PoolL2NormOp::readProperties(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::PoolL2NormOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::PoolL2NormOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

void mlir::mps::PoolL2NormOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::PoolMaxGradientOp::getODSOperands(mlir::mps::PoolMaxGradientOp *this, unsigned int a2)
{
  unint64_t v2 = *(unsigned int *)(*(void *)this + 44);
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    uint64_t v3 = *(void *)this + 16 * ((v2 >> 23) & 1) + 64;
  }
  else {
    uint64_t v3 = 0;
  }
  if (!a2)
  {
    uint64_t v6 = 0;
    goto LABEL_14;
  }
  if (a2 >= 8)
  {
    uint64_t v4 = a2 & 0xFFFFFFF8;
    uint64_t v7 = (int32x4_t *)(v3 + 88);
    int32x4_t v8 = 0uLL;
    uint64_t v9 = v4;
    int32x4_t v10 = 0uLL;
    do
    {
      int32x4_t v8 = vaddq_s32(v7[-1], v8);
      int32x4_t v10 = vaddq_s32(*v7, v10);
      v7 += 2;
      v9 -= 8;
    }
    while (v9);
    unsigned int v5 = vaddvq_s32(vaddq_s32(v10, v8));
    if (v4 == a2) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v4 = 0;
    unsigned int v5 = 0;
  }
  uint64_t v11 = a2 - v4;
  uint64_t v12 = (int *)(v3 + 4 * v4 + 72);
  do
  {
    int v13 = *v12++;
    v5 += v13;
    --v11;
  }
  while (v11);
LABEL_13:
  uint64_t v6 = v5;
LABEL_14:
  if ((v2 & 0x800000) != 0) {
    return *(void *)(*(void *)this + 72) + 32 * v6;
  }
  else {
    return 32 * v6;
  }
}

BOOL mlir::mps::PoolMaxGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v90 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v76 = v6;
  if (!v6)
  {
    a3(v80, a4);
    if (v80[0])
    {
      LODWORD(v77) = 3;
      uint64_t v78 = "expected DictionaryAttr to set properties";
      uint64_t v79 = 41;
      uint64_t v26 = &v77;
      uint64_t v27 = (char *)v81;
      if (v82 >= v83)
      {
        unint64_t v66 = v82 + 1;
        if (v81 <= &v77 && (char *)v81 + 24 * v82 > (char *)&v77)
        {
          int64_t v71 = (char *)&v77 - (unsigned char *)v81;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v81, v84, v66, 24);
          uint64_t v27 = (char *)v81;
          uint64_t v26 = (uint64_t *)((char *)v81 + v71);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v81, v84, v66, 24);
          uint64_t v26 = &v77;
          uint64_t v27 = (char *)v81;
        }
      }
      uint64_t v28 = &v27[24 * v82];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)uint64_t v28 = v29;
      ++v82;
      if (v80[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v80);
      }
    }
    if (!v89) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      uint64_t v31 = v88;
      char v32 = __p;
      if (v88 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        char v32 = __p;
      }
      char v88 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v85;
    if (!v85) {
      goto LABEL_71;
    }
    uint64_t v33 = v86;
    uint64_t v23 = v85;
    if (v86 == v85)
    {
LABEL_70:
      char v86 = v21;
      operator delete(v23);
LABEL_71:
      if (v81 != v84) {
        free(v81);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *uint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_69;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v76, "ceil_mode", 9uLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v80, a4);
      if (v80[0])
      {
        LODWORD(v77) = 3;
        uint64_t v79 = 54;
        int32x4_t v10 = &v77;
        uint64_t v11 = (char *)v81;
        if (v82 >= v83)
        {
          unint64_t v67 = v82 + 1;
          if (v81 <= &v77 && (char *)v81 + 24 * v82 > (char *)&v77)
          {
            int64_t v72 = (char *)&v77 - (unsigned char *)v81;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v81, v84, v67, 24);
            uint64_t v11 = (char *)v81;
            int32x4_t v10 = (uint64_t *)((char *)v81 + v72);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v81, v84, v67, 24);
            int32x4_t v10 = &v77;
            uint64_t v11 = (char *)v81;
          }
        }
        uint64_t v12 = &v11[24 * v82];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = v10[2];
        *(_OWORD *)uint64_t v12 = v13;
        ++v82;
        if (v80[0])
        {
          uint64_t v14 = &v77;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v77, v9);
          uint64_t v15 = (char *)v81;
          if (v82 >= v83)
          {
            unint64_t v68 = v82 + 1;
            if (v81 <= &v77 && (char *)v81 + 24 * v82 > (char *)&v77)
            {
              int64_t v73 = (char *)&v77 - (unsigned char *)v81;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v81, v84, v68, 24);
              uint64_t v15 = (char *)v81;
              uint64_t v14 = (uint64_t *)((char *)v81 + v73);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v81, v84, v68, 24);
              uint64_t v14 = &v77;
              uint64_t v15 = (char *)v81;
            }
          }
          long long v16 = &v15[24 * v82];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = v14[2];
          *(_OWORD *)long long v16 = v17;
          ++v82;
          if (v80[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v80);
          }
        }
      }
      if (!v89) {
        return 0;
      }
      uint64_t v18 = __p;
      if (__p)
      {
        unsigned int v19 = v88;
        long long v20 = __p;
        if (v88 != __p)
        {
          do
            unsigned int v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          long long v20 = __p;
        }
        char v88 = v18;
        operator delete(v20);
      }
      uint64_t v21 = v85;
      if (!v85) {
        goto LABEL_71;
      }
      uint64_t v22 = v86;
      uint64_t v23 = v85;
      if (v86 == v85) {
        goto LABEL_70;
      }
      do
      {
        uint64_t v25 = *--v22;
        uint64_t v24 = v25;
        void *v22 = 0;
        if (v25) {
          MEMORY[0x21667D390](v24, 0x1000C8077774924);
        }
      }
      while (v22 != v21);
      goto LABEL_69;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v76, "dilation_rates", 0xEuLL);
  if (v36)
  {
    uint64_t v37 = v36;
    if (mlir::DenseIntElementsAttr::classof(v36))
    {
      a1[1] = v37;
      goto LABEL_45;
    }
    a3(v80, a4);
    if (v80[0])
    {
      LODWORD(v77) = 3;
      uint64_t v79 = 59;
      uint64_t v42 = &v77;
      __int16 v43 = (char *)v81;
      if (v82 >= v83)
      {
        unint64_t v69 = v82 + 1;
        if (v81 <= &v77 && (char *)v81 + 24 * v82 > (char *)&v77)
        {
          int64_t v74 = (char *)&v77 - (unsigned char *)v81;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v81, v84, v69, 24);
          __int16 v43 = (char *)v81;
          uint64_t v42 = (uint64_t *)((char *)v81 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v81, v84, v69, 24);
          uint64_t v42 = &v77;
          __int16 v43 = (char *)v81;
        }
      }
      uint64_t v44 = &v43[24 * v82];
      long long v45 = *(_OWORD *)v42;
      *((void *)v44 + 2) = v42[2];
      *(_OWORD *)uint64_t v44 = v45;
      ++v82;
      if (v80[0])
      {
        uint64_t v46 = &v77;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v77, v37);
        unsigned int v47 = (char *)v81;
        if (v82 >= v83)
        {
          unint64_t v70 = v82 + 1;
          if (v81 <= &v77 && (char *)v81 + 24 * v82 > (char *)&v77)
          {
            int64_t v75 = (char *)&v77 - (unsigned char *)v81;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v81, v84, v70, 24);
            unsigned int v47 = (char *)v81;
            uint64_t v46 = (uint64_t *)((char *)v81 + v75);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v81, v84, v70, 24);
            uint64_t v46 = &v77;
            unsigned int v47 = (char *)v81;
          }
        }
        unsigned int v48 = &v47[24 * v82];
        long long v49 = *(_OWORD *)v46;
        *((void *)v48 + 2) = v46[2];
        *(_OWORD *)unsigned int v48 = v49;
        ++v82;
        if (v80[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v80);
        }
      }
    }
    if (!v89) {
      return 0;
    }
    uint64_t v50 = __p;
    if (__p)
    {
      int64_t v51 = v88;
      int64_t v52 = __p;
      if (v88 != __p)
      {
        do
          int64_t v51 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v51 - 1);
        while (v51 != v50);
        int64_t v52 = __p;
      }
      char v88 = v50;
      operator delete(v52);
    }
    uint64_t v21 = v85;
    if (!v85) {
      goto LABEL_71;
    }
    int64_t v53 = v86;
    uint64_t v23 = v85;
    if (v86 == v85) {
      goto LABEL_70;
    }
    do
    {
      uint64_t v55 = *--v53;
      uint64_t v54 = v55;
      void *v53 = 0;
      if (v55) {
        MEMORY[0x21667D390](v54, 0x1000C8077774924);
      }
    }
    while (v53 != v21);
LABEL_69:
    uint64_t v23 = v85;
    goto LABEL_70;
  }
LABEL_45:
  uint64_t v38 = mlir::DictionaryAttr::get((uint64_t)&v76, "explicit_padding", 0x10uLL);
  uint64_t v77 = v38;
  if (v38)
  {
    uint64_t v39 = v38;
    if (!mlir::DenseIntElementsAttr::classof(v38))
    {
      a3(v80, a4);
      goto LABEL_74;
    }
    a1[2] = v39;
  }
  uint64_t v40 = mlir::DictionaryAttr::get((uint64_t)&v76, "include_zero_pad", 0x10uLL);
  uint64_t v77 = v40;
  if (v40)
  {
    if (*(_UNKNOWN **)(*(void *)v40 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v80, a4);
LABEL_74:
      uint64_t v56 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v80, v41);
LABEL_98:
      mlir::InFlightDiagnostic::append<mlir::Attribute>(v56, &v77);
LABEL_99:
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v80);
      return 0;
    }
    a1[3] = v40;
  }
  uint64_t v57 = mlir::DictionaryAttr::get((uint64_t)&v76, "indices_mode", 0xCuLL);
  uint64_t v77 = v57;
  if (v57)
  {
    if (*(_UNKNOWN **)(*(void *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id)
    {
      a3(v80, a4);
      goto LABEL_74;
    }
    a1[4] = v57;
  }
  uint64_t v58 = mlir::DictionaryAttr::get((uint64_t)&v76, "indices_result_type", 0x13uLL);
  uint64_t v77 = v58;
  if (v58)
  {
    if (*(_UNKNOWN **)(*(void *)v58 + 136) != &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
    {
      a3(v80, a4);
      goto LABEL_98;
    }
    a1[5] = v58;
  }
  uint64_t v59 = mlir::DictionaryAttr::get((uint64_t)&v76, "padding_style", 0xDuLL);
  uint64_t v77 = v59;
  if (v59)
  {
    if (*(_UNKNOWN **)(*(void *)v59 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
    {
      a3(v80, a4);
      goto LABEL_98;
    }
    a1[6] = v59;
  }
  uint64_t v60 = mlir::DictionaryAttr::get((uint64_t)&v76, "strides", 7uLL);
  uint64_t v77 = v60;
  if (v60)
  {
    uint64_t v61 = v60;
    if (!mlir::DenseIntElementsAttr::classof(v60))
    {
      a3(v80, a4);
      goto LABEL_98;
    }
    a1[7] = v61;
  }
  uint64_t v62 = mlir::DictionaryAttr::get((uint64_t)&v76, "window_sizes", 0xCuLL);
  uint64_t v77 = v62;
  if (!v62)
  {
    a3(v80, a4);
    mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v80, "expected key entry for window_sizes in DictionaryAttr to set Properties.");
    goto LABEL_99;
  }
  uint64_t v63 = v62;
  if ((mlir::DenseIntElementsAttr::classof(v62) & 1) == 0)
  {
    a3(v80, a4);
    goto LABEL_74;
  }
  a1[8] = v63;
  unint64_t v64 = (void *)mlir::DictionaryAttr::get((uint64_t)&v76, "operandSegmentSizes", 0x13uLL);
  if (!v64)
  {
    unint64_t v64 = (void *)mlir::DictionaryAttr::get((uint64_t)&v76, "operand_segment_sizes", 0x15uLL);
    if (!v64)
    {
      a3(v80, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v80, "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.");
      goto LABEL_99;
    }
  }
  return mlir::convertFromAttribute(a1 + 9, (const char *)4, v64, a3, a4) != 0;
}

uint64_t mlir::mps::PoolMaxGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v71[6] = *MEMORY[0x263EF8340];
  unint64_t v68 = a1;
  unint64_t v69 = v71;
  uint64_t v70 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v68, (uint64_t)"ceil_mode", 9, *a2);
    uint64_t v6 = v5;
    unsigned int v7 = v70;
    if (v70 >= HIDWORD(v70))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v71, v70 + 1, 16);
      unsigned int v7 = v70;
    }
    uint64_t v8 = (uint64_t *)((char *)v69 + 16 * v7);
    *uint64_t v8 = NamedAttr;
    v8[1] = v6;
    LODWORD(v70) = v70 + 1;
  }
  uint64_t v9 = a2[1];
  if (v9)
  {
    uint64_t v10 = mlir::Builder::getNamedAttr(&v68, (uint64_t)"dilation_rates", 14, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v70;
    if (v70 >= HIDWORD(v70))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v71, v70 + 1, 16);
      unsigned int v13 = v70;
    }
    uint64_t v14 = (uint64_t *)((char *)v69 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    LODWORD(v70) = v70 + 1;
  }
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v68, (uint64_t)"explicit_padding", 16, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v70;
    if (v70 >= HIDWORD(v70))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v71, v70 + 1, 16);
      unsigned int v19 = v70;
    }
    long long v20 = (uint64_t *)((char *)v69 + 16 * v19);
    uint64_t *v20 = v16;
    v20[1] = v18;
    LODWORD(v70) = v70 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v68, (uint64_t)"include_zero_pad", 16, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v70;
    if (v70 >= HIDWORD(v70))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v71, v70 + 1, 16);
      unsigned int v25 = v70;
    }
    uint64_t v26 = (uint64_t *)((char *)v69 + 16 * v25);
    uint64_t *v26 = v22;
    v26[1] = v24;
    LODWORD(v70) = v70 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v68, (uint64_t)"indices_mode", 12, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v70;
    if (v70 >= HIDWORD(v70))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v71, v70 + 1, 16);
      unsigned int v31 = v70;
    }
    char v32 = (uint64_t *)((char *)v69 + 16 * v31);
    uint64_t *v32 = v28;
    v32[1] = v30;
    LODWORD(v70) = v70 + 1;
  }
  uint64_t v33 = a2[5];
  if (v33)
  {
    uint64_t v34 = mlir::Builder::getNamedAttr(&v68, (uint64_t)"indices_result_type", 19, v33);
    uint64_t v36 = v35;
    unsigned int v37 = v70;
    if (v70 >= HIDWORD(v70))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v71, v70 + 1, 16);
      unsigned int v37 = v70;
    }
    uint64_t v38 = (uint64_t *)((char *)v69 + 16 * v37);
    uint64_t *v38 = v34;
    v38[1] = v36;
    LODWORD(v70) = v70 + 1;
  }
  uint64_t v39 = a2[6];
  if (v39)
  {
    uint64_t v40 = mlir::Builder::getNamedAttr(&v68, (uint64_t)"padding_style", 13, v39);
    uint64_t v42 = v41;
    unsigned int v43 = v70;
    if (v70 >= HIDWORD(v70))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v71, v70 + 1, 16);
      unsigned int v43 = v70;
    }
    uint64_t v44 = (uint64_t *)((char *)v69 + 16 * v43);
    uint64_t *v44 = v40;
    v44[1] = v42;
    LODWORD(v70) = v70 + 1;
  }
  uint64_t v45 = a2[7];
  if (v45)
  {
    uint64_t v46 = mlir::Builder::getNamedAttr(&v68, (uint64_t)"strides", 7, v45);
    uint64_t v48 = v47;
    unsigned int v49 = v70;
    if (v70 >= HIDWORD(v70))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v71, v70 + 1, 16);
      unsigned int v49 = v70;
    }
    uint64_t v50 = (uint64_t *)((char *)v69 + 16 * v49);
    *uint64_t v50 = v46;
    v50[1] = v48;
    LODWORD(v70) = v70 + 1;
  }
  uint64_t v51 = a2[8];
  if (v51)
  {
    uint64_t v52 = mlir::Builder::getNamedAttr(&v68, (uint64_t)"window_sizes", 12, v51);
    uint64_t v54 = v53;
    unsigned int v55 = v70;
    if (v70 >= HIDWORD(v70))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v71, v70 + 1, 16);
      unsigned int v55 = v70;
    }
    uint64_t v56 = (uint64_t *)((char *)v69 + 16 * v55);
    *uint64_t v56 = v52;
    v56[1] = v54;
    LODWORD(v70) = v70 + 1;
  }
  uint64_t v57 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 9), 4);
  uint64_t v58 = mlir::Builder::getNamedAttr(&v68, (uint64_t)"operandSegmentSizes", 19, v57);
  uint64_t v60 = v59;
  unsigned int v61 = v70;
  if (v70 >= HIDWORD(v70))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v71, v70 + 1, 16);
    unsigned int v61 = v70;
  }
  uint64_t v62 = (uint64_t *)((char *)v69 + 16 * v61);
  *uint64_t v62 = v58;
  v62[1] = v60;
  BOOL v63 = __CFADD__(v70, 1);
  uint64_t v64 = (v70 + 1);
  LODWORD(v70) = v70 + 1;
  if (v63)
  {
    uint64_t DictionaryAttr = 0;
    unint64_t v66 = v69;
    if (v69 == v71) {
      return DictionaryAttr;
    }
    goto LABEL_44;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v68, (uint64_t *)v69, v64);
  unint64_t v66 = v69;
  if (v69 != v71) {
LABEL_44:
  }
    free(v66);
  return DictionaryAttr;
}

unint64_t mlir::mps::PoolMaxGradientOp::computePropertiesHash(unint64_t *a1)
{
  unint64_t v1 = *a1;
  unint64_t v2 = &unk_267770000;
  {
    unint64_t v64 = v1;
    int64_t v73 = a1;
    unint64_t v2 = &unk_267770000;
    int v35 = v34;
    unint64_t v1 = v64;
    a1 = v73;
    if (v35)
    {
      unint64_t v36 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v36 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v36;
      unint64_t v1 = v64;
      a1 = v73;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v3 = HIDWORD(v1);
  unint64_t v4 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v1) ^ HIDWORD(v1));
  unint64_t v92 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  unint64_t v5 = a1[1];
  {
    unint64_t v65 = v5;
    int64_t v74 = a1;
    unint64_t v2 = &unk_267770000;
    int v38 = v37;
    unint64_t v5 = v65;
    a1 = v74;
    if (v38)
    {
      unint64_t v39 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v39 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v39;
      unint64_t v5 = v65;
      a1 = v74;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v6 = HIDWORD(v5);
  unint64_t v7 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v5) ^ HIDWORD(v5));
  unint64_t v91 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
  unint64_t v8 = a1[2];
  {
    unint64_t v66 = v8;
    int64_t v75 = a1;
    unint64_t v2 = &unk_267770000;
    int v41 = v40;
    unint64_t v8 = v66;
    a1 = v75;
    if (v41)
    {
      unint64_t v42 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v42 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v42;
      unint64_t v8 = v66;
      a1 = v75;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v9 = HIDWORD(v8);
  unint64_t v10 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v8) ^ HIDWORD(v8));
  unint64_t v90 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) ^ ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) >> 47));
  unint64_t v11 = a1[3];
  {
    unint64_t v67 = v11;
    uint64_t v76 = a1;
    unint64_t v2 = &unk_267770000;
    int v44 = v43;
    unint64_t v11 = v67;
    a1 = v76;
    if (v44)
    {
      unint64_t v45 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v45 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v45;
      unint64_t v11 = v67;
      a1 = v76;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v12 = HIDWORD(v11);
  unint64_t v13 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v11) ^ HIDWORD(v11));
  unint64_t v89 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v12 ^ (v13 >> 47) ^ v13)) ^ ((0x9DDFEA08EB382D69 * (v12 ^ (v13 >> 47) ^ v13)) >> 47));
  unint64_t v14 = a1[4];
  {
    unint64_t v68 = v14;
    uint64_t v77 = a1;
    unint64_t v2 = &unk_267770000;
    int v47 = v46;
    unint64_t v14 = v68;
    a1 = v77;
    if (v47)
    {
      unint64_t v48 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v48 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v48;
      unint64_t v14 = v68;
      a1 = v77;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v15 = HIDWORD(v14);
  unint64_t v16 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v14) ^ HIDWORD(v14));
  unint64_t v88 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v15 ^ (v16 >> 47) ^ v16)) ^ ((0x9DDFEA08EB382D69 * (v15 ^ (v16 >> 47) ^ v16)) >> 47));
  unint64_t v17 = a1[5];
  {
    unint64_t v69 = v17;
    uint64_t v78 = a1;
    unint64_t v2 = &unk_267770000;
    int v50 = v49;
    unint64_t v17 = v69;
    a1 = v78;
    if (v50)
    {
      unint64_t v51 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v51 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v51;
      unint64_t v17 = v69;
      a1 = v78;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v18 = HIDWORD(v17);
  unint64_t v19 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v17) ^ HIDWORD(v17));
  unint64_t v87 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v18 ^ (v19 >> 47) ^ v19)) ^ ((0x9DDFEA08EB382D69 * (v18 ^ (v19 >> 47) ^ v19)) >> 47));
  unint64_t v20 = a1[6];
  {
    unint64_t v70 = v20;
    uint64_t v79 = a1;
    unint64_t v2 = &unk_267770000;
    int v53 = v52;
    unint64_t v20 = v70;
    a1 = v79;
    if (v53)
    {
      unint64_t v54 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v54 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v54;
      unint64_t v20 = v70;
      a1 = v79;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v21 = HIDWORD(v20);
  unint64_t v22 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v20) ^ HIDWORD(v20));
  unint64_t v86 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v21 ^ (v22 >> 47) ^ v22)) ^ ((0x9DDFEA08EB382D69 * (v21 ^ (v22 >> 47) ^ v22)) >> 47));
  unint64_t v23 = a1[7];
  {
    unint64_t v71 = v23;
    unsigned int v80 = a1;
    unint64_t v2 = &unk_267770000;
    int v56 = v55;
    unint64_t v23 = v71;
    a1 = v80;
    if (v56)
    {
      unint64_t v57 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v57 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v57;
      unint64_t v23 = v71;
      a1 = v80;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v24 = HIDWORD(v23);
  unint64_t v25 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v23) ^ HIDWORD(v23));
  unint64_t v85 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v24 ^ (v25 >> 47) ^ v25)) ^ ((0x9DDFEA08EB382D69 * (v24 ^ (v25 >> 47) ^ v25)) >> 47));
  unint64_t v26 = a1[8];
  {
    unint64_t v72 = v26;
    unsigned int v81 = a1;
    unint64_t v2 = &unk_267770000;
    int v59 = v58;
    unint64_t v26 = v72;
    a1 = v81;
    if (v59)
    {
      unint64_t v60 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v60 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v60;
      unint64_t v26 = v72;
      a1 = v81;
      unint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v27 = HIDWORD(v26);
  unint64_t v28 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v26) ^ HIDWORD(v26));
  unint64_t v84 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v27 ^ (v28 >> 47) ^ v28)) ^ ((0x9DDFEA08EB382D69 * (v27 ^ (v28 >> 47) ^ v28)) >> 47));
  {
    unsigned int v82 = a1;
    unint64_t v2 = &unk_267770000;
    int v62 = v61;
    a1 = v82;
    if (v62)
    {
      unint64_t v63 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v63 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v63;
      unint64_t v2 = (void *)&unk_267770000;
      a1 = v82;
    }
  }
  unint64_t v29 = a1[10];
  unint64_t v30 = a1[9] ^ v2[385];
  uint64_t v31 = __ROR8__(v29 + 16, 16);
  unint64_t v32 = 0x9DDFEA08EB382D69
      * (v31 ^ ((0x9DDFEA08EB382D69 * (v30 ^ v31)) >> 47) ^ (0x9DDFEA08EB382D69 * (v30 ^ v31)));
  unint64_t v83 = (0x9DDFEA08EB382D69 * (v32 ^ (v32 >> 47))) ^ v29;
  return llvm::hash_combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>(&v92, (uint64_t *)&v91, (uint64_t *)&v90, (uint64_t *)&v89, (uint64_t *)&v88, (uint64_t *)&v87, (uint64_t *)&v86, (uint64_t *)&v85, (uint64_t *)&v84, (uint64_t *)&v83);
}

unint64_t llvm::hash_combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>(void *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9, uint64_t *a10)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t v30 = 0;
  memset(v29, 0, sizeof(v29));
  memset(v28, 0, sizeof(v28));
  {
    unint64_t v23 = a2;
    unint64_t v24 = a1;
    a2 = v23;
    a1 = v24;
    if (v21)
    {
      unint64_t v22 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v22 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v22;
      a2 = v23;
      a1 = v24;
    }
  }
  uint64_t v16 = *a1;
  uint64_t v31 = llvm::hashing::detail::get_execution_seed(void)::seed;
  *(void *)&v28[0] = v16;
  unint64_t v25 = 0;
  unint64_t v17 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v28, (uint64_t *)&v25, (void *)v28 + 1, (unint64_t)v29, *a2);
  unint64_t v26 = v25;
  unint64_t v18 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v28, (uint64_t *)&v26, v17, (unint64_t)v29, *a3);
  unint64_t v27 = v26;
  unint64_t v19 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v28, (uint64_t *)&v27, v18, (unint64_t)v29, *a4);
  return llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>((llvm::hashing::detail::hash_combine_recursive_helper *)v28, v27, v19, (char *)v29, a5, a6, a7, a8, a9, a10);
}

uint64_t mlir::mps::PoolMaxGradientOp::getInherentAttr(mlir::MLIRContext *a1, void *a2, void *__s1, size_t __n)
{
  uint64_t result = 0;
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[7];
    case 8uLL:
    case 0xAuLL:
    case 0xBuLL:
    case 0xFuLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x14uLL:
      return 0;
    case 9uLL:
      if (*__s1 != 0x646F6D5F6C696563 || *((unsigned char *)__s1 + 8) != 101) {
        return 0;
      }
      return *a2;
    case 0xCuLL:
      if (!memcmp(__s1, "indices_mode", __n)) {
        return a2[4];
      }
      if (memcmp(__s1, "window_sizes", __n)) {
        return 0;
      }
      return a2[8];
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[6];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n)) {
        return 0;
      }
      return a2[1];
    case 0x10uLL:
      if (!memcmp(__s1, "explicit_padding", __n)) {
        return a2[2];
      }
      if (*__s1 == 0x5F6564756C636E69 && __s1[1] == 0x6461705F6F72657ALL) {
        return a2[3];
      }
      return 0;
    case 0x13uLL:
      if (!memcmp(__s1, "indices_result_type", __n)) {
        return a2[5];
      }
      if (!memcmp(__s1, "operandSegmentSizes", __n)) {
        return mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 9), 4);
      }
      return 0;
    case 0x15uLL:
      if (memcmp(__s1, "operand_segment_sizes", __n)) {
        return 0;
      }
      return mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 9), 4);
    default:
      return result;
  }
}

uint64_t mlir::mps::PoolMaxGradientOp::setInherentAttr(uint64_t result, void *__s1, size_t __n, void *a4)
{
  unint64_t v7 = (void *)result;
  switch(__n)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof((uint64_t)a4);
          if (result) {
            unint64_t v17 = a4;
          }
          else {
            unint64_t v17 = 0;
          }
          v7[7] = v17;
        }
        else
        {
          v7[7] = 0;
        }
      }
      break;
    case 9uLL:
      if (*__s1 == 0x646F6D5F6C696563 && *((unsigned char *)__s1 + 8) == 101)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
            unint64_t v9 = a4;
          }
          else {
            unint64_t v9 = 0;
          }
          *(void *)uint64_t result = v9;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xCuLL:
      uint64_t result = memcmp(__s1, "indices_mode", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "window_sizes", __n);
        if (!result)
        {
          if (a4)
          {
            uint64_t result = mlir::DenseIntElementsAttr::classof((uint64_t)a4);
            if (result) {
              unint64_t v10 = a4;
            }
            else {
              unint64_t v10 = 0;
            }
            v7[8] = v10;
          }
          else
          {
            v7[8] = 0;
          }
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id) {
          unint64_t v18 = a4;
        }
        else {
          unint64_t v18 = 0;
        }
        uint64_t v7[4] = v18;
      }
      else
      {
        uint64_t v7[4] = 0;
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            unint64_t v11 = a4;
          }
          else {
            unint64_t v11 = 0;
          }
          v7[6] = v11;
        }
        else
        {
          v7[6] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof((uint64_t)a4);
          if (result) {
            unint64_t v12 = a4;
          }
          else {
            unint64_t v12 = 0;
          }
          v7[1] = v12;
        }
        else
        {
          v7[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", __n);
      if (result)
      {
        if (*__s1 == 0x5F6564756C636E69 && __s1[1] == 0x6461705F6F72657ALL)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
              unint64_t v14 = a4;
            }
            else {
              unint64_t v14 = 0;
            }
            v7[3] = v14;
          }
          else
          {
            v7[3] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof((uint64_t)a4);
        if (result) {
          unint64_t v19 = a4;
        }
        else {
          unint64_t v19 = 0;
        }
        v7[2] = v19;
      }
      else
      {
        v7[2] = 0;
      }
      break;
    case 0x13uLL:
      uint64_t result = memcmp(__s1, "indices_result_type", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "operandSegmentSizes", __n);
        if (!result) {
          goto LABEL_48;
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id) {
          unint64_t v20 = a4;
        }
        else {
          unint64_t v20 = 0;
        }
        v7[5] = v20;
      }
      else
      {
        v7[5] = 0;
      }
      break;
    case 0x15uLL:
      uint64_t result = memcmp(__s1, "operand_segment_sizes", __n);
      if (!result)
      {
LABEL_48:
        if (a4)
        {
          uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
          unint64_t v15 = result ? a4 : 0;
          int v21 = v15;
          if (result)
          {
            uint64_t result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v21);
            if (result == 4)
            {
              uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v21);
              if (v16) {
                uint64_t result = (uint64_t)memmove(v7 + 9, (const void *)result, 4 * v16);
              }
            }
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::PoolMaxGradientOp::populateInherentAttrs(mlir::MLIRContext *a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"ceil_mode", 9, *a2);
  }
  uint64_t v6 = a2[1];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"dilation_rates", 14, v6);
  }
  uint64_t v7 = a2[2];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"explicit_padding", 16, v7);
  }
  uint64_t v8 = a2[3];
  if (v8) {
    mlir::NamedAttrList::append(a3, (uint64_t)"include_zero_pad", 16, v8);
  }
  uint64_t v9 = a2[4];
  if (v9) {
    mlir::NamedAttrList::append(a3, (uint64_t)"indices_mode", 12, v9);
  }
  uint64_t v10 = a2[5];
  if (v10) {
    mlir::NamedAttrList::append(a3, (uint64_t)"indices_result_type", 19, v10);
  }
  uint64_t v11 = a2[6];
  if (v11) {
    mlir::NamedAttrList::append(a3, (uint64_t)"padding_style", 13, v11);
  }
  uint64_t v12 = a2[7];
  if (v12) {
    mlir::NamedAttrList::append(a3, (uint64_t)"strides", 7, v12);
  }
  uint64_t v13 = a2[8];
  if (v13) {
    mlir::NamedAttrList::append(a3, (uint64_t)"window_sizes", 12, v13);
  }
  uint64_t v14 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 9), 4);

  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v14);
}

BOOL mlir::mps::PoolMaxGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  if (v8
    && !mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v8, (void **)"ceil_mode", (const char *)9, a3, a4))
  {
    return 0;
  }
  uint64_t v9 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
  if (v9)
  {
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))a3, a4))return 0; {
  }
    }
  uint64_t v10 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
  if (v10)
  {
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps34(v10, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))a3, a4))return 0; {
  }
    }
  uint64_t v11 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
  if (v11)
  {
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v11, (void **)"include_zero_pad", (const char *)0x10, a3, a4))return 0; {
  }
    }
  uint64_t v12 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
  if (v12)
  {
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps35(v12, (void **)"indices_mode", (const char *)0xC, a3, a4))return 0; {
  }
    }
  uint64_t v13 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 40));
  if (v13)
  {
    if (!mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v13, (void **)"indices_result_type", (const char *)0x13, a3, a4))return 0; {
  }
    }
  uint64_t v14 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 48));
  if (v14)
  {
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v14, (void **)"padding_style", (const char *)0xD, a3, a4))return 0; {
  }
    }
  unint64_t v15 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 56));
  if (v15)
  {
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v15, (void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))a3, a4))return 0; {
  }
    }
  uint64_t v16 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 64));
  return !v16
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v16, (void **)"window_sizes", (const char *)0xC, (void (*)(void **__return_ptr, uint64_t))a3, a4);
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps35(uint64_t a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      unint64_t v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: max pool return indices mode";
        uint64_t v31 = 60;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        uint64_t v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)uint64_t v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = __p;
    if (__p)
    {
      unint64_t v17 = v42;
      unint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          unint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        unint64_t v18 = __p;
      }
      unint64_t v42 = v16;
      operator delete(v18);
    }
    unint64_t v19 = v39;
    if (v39)
    {
      unint64_t v20 = v40;
      int v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        int v21 = v39;
      }
      int v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

BOOL mlir::mps::PoolMaxGradientOp::readProperties(uint64_t a1, uint64_t a2)
{
  v10[24] = *MEMORY[0x263EF8340];
  unint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::PoolMaxGradientOpGenericAdaptorBase::Properties>(a2);
  if (!mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 3)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::PoolIndicesModeAttr>(a1, v3 + 4)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::TypeAttr>(a1, v3 + 5))
  {
    return 0;
  }
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) <= 5)
  {
    uint64_t v9 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v9)) {
      return 0;
    }
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v9) >= 5)
    {
      v7[0] = (uint64_t)"size mismatch for operand/result_segment_size";
      __int16 v8 = 259;
      (*(void (**)(void *__return_ptr, uint64_t, uint64_t *))(*(void *)a1 + 16))(v10, a1, v7);
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v10);
      return 0;
    }
    unint64_t v4 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v9);
    if (v5) {
      memmove(v3 + 9, v4, 4 * v5);
    }
  }
  if (mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 6)
    && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 7)
    && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 8))
  {
    v7[0] = a1;
    v7[1] = (uint64_t)(v3 + 9);
    return mlir::mps::PoolMaxGradientOp::readProperties(mlir::DialectBytecodeReader &,mlir::OperationState &)::$_0::operator()(v7) != 0;
  }
  return 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::PoolMaxGradientOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::PoolIndicesModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  uint64_t v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    uint64_t v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        uint64_t v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    __int16 v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)__int16 v8 = v9;
    ++v47;
  }
  int v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::PoolIndicesModeAttr]";
  unint64_t v41 = 80;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    int v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      long long v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          long long v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        unint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unint64_t v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unint64_t v19 = (char *)v46;
            unint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unint64_t v18 = &v40;
            unint64_t v19 = (char *)v46;
          }
        }
        unint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)unint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      unint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          unint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      int v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      unint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

uint64_t mlir::mps::PoolMaxGradientOp::readProperties(mlir::DialectBytecodeReader &,mlir::OperationState &)::$_0::operator()(uint64_t *a1)
{
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)*a1 + 40))(*a1) < 6) {
    return 1;
  }
  uint64_t v2 = *a1;
  unint64_t v3 = (_DWORD *)a1[1];

  return mlir::DialectBytecodeReader::readSparseArray<int>(v2, v3, (const char *)4);
}

uint64_t mlir::mps::PoolMaxGradientOp::writeProperties(uint64_t a1, uint64_t a2)
{
  if (HIBYTE(*(_DWORD *)(*(void *)a1 + 44))) {
    unint64_t v4 = *(void *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(void *)a1 + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)v4);
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 8));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 16));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 24));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 32));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 40));
  if ((*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2) <= 5)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(void *)a1 + 24));
    uint64_t v6 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v4 + 72, 4);
    (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, v6);
  }
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 48));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 56));
  (*(void (**)(uint64_t, void))(*(void *)a2 + 16))(a2, *(void *)(v4 + 64));
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2);
  if (result >= 6)
  {
    return mlir::DialectBytecodeWriter::writeSparseArray<int>(a2, (int *)(v4 + 72), 4);
  }
  return result;
}

mlir::MLIRContext *mlir::mps::PoolMaxGradientOp::populateDefaultProperties(uint64_t a1, void *a2)
{
  v19[1] = *MEMORY[0x263EF8340];
  *(void *)&long long v17 = *(void *)(a1 + 8);
  uint64_t result = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v17);
  uint64_t v16 = result;
  if (a2[7])
  {
    if (a2[1]) {
      goto LABEL_3;
    }
  }
  else
  {
    v19[0] = 4;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)&v16, 0x40u, 0);
    uint64_t v5 = (void *)mlir::RankedTensorType::get((uint64_t)v19, 1, IntegerType, 0);
    uint64_t v6 = v5;
    if (v5) {
      uint64_t v7 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
    }
    else {
      uint64_t v7 = 0;
    }
    long long v17 = xmmword_211F23850;
    long long v18 = unk_211F23860;
    uint64_t result = (mlir::MLIRContext *)mlir::DenseElementsAttr::getFromRawBuffer(v6, v7, &v17, 32, 8, 1, 0);
    a2[7] = result;
    if (a2[1])
    {
LABEL_3:
      if (a2[6]) {
        goto LABEL_4;
      }
      goto LABEL_14;
    }
  }
  v19[0] = 4;
  uint64_t v8 = mlir::Builder::getIntegerType((mlir::Builder *)&v16, 0x40u, 0);
  long long v9 = (void *)mlir::RankedTensorType::get((uint64_t)v19, 1, v8, 0);
  unint64_t v10 = v9;
  if (v9) {
    uint64_t v11 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v9 + 8);
  }
  else {
    uint64_t v11 = 0;
  }
  long long v17 = xmmword_211F23850;
  long long v18 = unk_211F23860;
  uint64_t result = (mlir::MLIRContext *)mlir::DenseElementsAttr::getFromRawBuffer(v10, v11, &v17, 32, 8, 1, 0);
  a2[1] = result;
  if (a2[6])
  {
LABEL_4:
    if (a2[4]) {
      return result;
    }
LABEL_15:
    long long v14 = v16;
    LODWORD(v19[0]) = 0;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v16);
    *(void *)&long long v17 = &mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id;
    *((void *)&v17 + 1) = v14;
    uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::PoolIndicesModeAttrStorage,mlir::mps::PoolIndicesMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail26PoolIndicesModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_19PoolIndicesModeAttrEJNS2_15PoolIndicesModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v17, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id, (unsigned int *)v19);
    a2[4] = result;
    return result;
  }
LABEL_14:
  uint64_t v12 = v16;
  LODWORD(v19[0]) = 2;
  unint64_t v13 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v16);
  *(void *)&long long v17 = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  *((void *)&v17 + 1) = v12;
  uint64_t result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(v13, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v17, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, (unsigned int *)v19);
  a2[6] = result;
  if (!a2[4]) {
    goto LABEL_15;
  }
  return result;
}

BOOL mlir::mps::PoolMaxGradientOp::verifyInvariantsImpl(mlir::mps::PoolMaxGradientOp *this)
{
  uint64_t v67 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    unint64_t v3 = 0;
  }
  unint64_t v4 = (void **)v3[8];
  if (v4)
  {
    uint64_t v5 = *v3;
    uint64_t v6 = (void **)v3[1];
    uint64_t v8 = (void **)v3[2];
    uint64_t v7 = v3[3];
    uint64_t v10 = v3[4];
    uint64_t v9 = v3[5];
    uint64_t v11 = v3[6];
    uint64_t v12 = (void **)v3[7];
    v59[0] = v2;
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v4, (void **)"window_sizes", (const char *)0xC, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0; {
    v59[0] = *(void *)this;
    }
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v12, (void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0; {
    v59[0] = *(void *)this;
    }
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v6, (void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0; {
    v59[0] = *(void *)this;
    }
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v11, (void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0; {
    v59[0] = *(void *)this;
    }
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps34(v8, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps34(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0; {
    v59[0] = *(void *)this;
    }
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (void **)"ceil_mode", (const char *)9, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0; {
    v59[0] = *(void *)this;
    }
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (void **)"include_zero_pad", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0; {
    v59[0] = *(void *)this;
    }
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps35(v10, (void **)"indices_mode", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps35(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0; {
    v59[0] = *(void *)this;
    }
    if (!mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v9, (void **)"indices_result_type", (const char *)0x13, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps4(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0; {
    unsigned int v56 = 0;
    }
    unint64_t v13 = *(unsigned int *)(*(void *)this + 44);
    uint64_t v14 = *(void *)this + 16 * ((v13 >> 23) & 1) + 64;
    if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
      uint64_t v14 = 0;
    }
    uint64_t v15 = *(unsigned int *)(v14 + 72);
    if ((v13 & 0x800000) != 0)
    {
      uint64_t v16 = *(void *)(*(void *)this + 72);
      if (v15) {
        goto LABEL_18;
      }
    }
    else
    {
      uint64_t v16 = 0;
      if (v15)
      {
LABEL_18:
        uint64_t v17 = v16 + 24;
        do
        {
          uint64_t v18 = *(void *)this;
          unint64_t v19 = *(void *)(*(void *)v17 + 8) & 0xFFFFFFFFFFFFFFF8;
          unsigned int v20 = v56++;
          if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v18, v19, (void **)"operand", (void **)7, v20))return 0; {
          v17 += 32;
          }
        }
        while (--v15);
      }
    }
    uint64_t ODSOperands = mlir::mps::PoolMaxGradientOp::getODSOperands(this, 1u);
    uint64_t v23 = v22;
    if (v22 >= 2) {
      goto LABEL_28;
    }
    if (v22)
    {
      uint64_t v24 = *(void *)(ODSOperands + 24);
      uint64_t v25 = *(void *)this;
      unint64_t v26 = *(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v27 = v56++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v25, v26, (void **)"operand", (void **)7, v27))return 0; {
    }
      }
    uint64_t v28 = mlir::mps::PoolMaxGradientOp::getODSOperands(this, 2u);
    uint64_t v23 = v29;
    if (v29 >= 2)
    {
LABEL_28:
      v57[0] = (void **)"operand group starting at #";
      __int16 v58 = 259;
      mlir::OpState::emitOpError((uint64_t *)this, v57, (uint64_t)v59);
      uint64_t v36 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v59, &v56);
      uint64_t v37 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v36, " requires 0 or 1 element, but found ");
      uint64_t v55 = v23;
      uint64_t v38 = mlir::InFlightDiagnostic::operator<<<unsigned long &>(v37, &v55);
      uint64_t v39 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v38);
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v59);
      return v39;
    }
    if (v29)
    {
      uint64_t v30 = *(void *)(v28 + 24);
      uint64_t v31 = *(void *)this;
      unint64_t v32 = *(void *)(v30 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v33 = v56++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v31, v32, (void **)"operand", (void **)7, v33))return 0; {
    }
      }
    uint64_t v34 = mlir::mps::PoolMaxGradientOp::getODSOperands(this, 3u);
    uint64_t v23 = v35;
    if (v35 >= 2) {
      goto LABEL_28;
    }
    if (v35)
    {
      uint64_t v48 = *(void *)(v34 + 24);
      uint64_t v49 = *(void *)this;
      unint64_t v50 = *(void *)(v48 + 8) & 0xFFFFFFFFFFFFFFF8;
      unsigned int v51 = v56++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v49, v50, (void **)"operand", (void **)7, v51))return 0; {
    }
      }
    if (*(_DWORD *)(*(void *)this + 36)) {
      uint64_t v52 = *(void *)this - 16;
    }
    else {
      uint64_t v52 = 0;
    }
    uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v52, 0);
    return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
  }
  else
  {
    v57[0] = (void **)"requires attribute 'window_sizes'";
    __int16 v58 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, v57, (uint64_t)v59);
    uint64_t v39 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v59);
    if (v59[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (v66)
    {
      int v40 = __p;
      if (__p)
      {
        unint64_t v41 = v65;
        uint64_t v42 = __p;
        if (v65 != __p)
        {
          do
            unint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
          while (v41 != v40);
          uint64_t v42 = __p;
        }
        unint64_t v65 = v40;
        operator delete(v42);
      }
      __int16 v43 = v62;
      if (v62)
      {
        uint64_t v44 = v63;
        uint64_t v45 = v62;
        if (v63 != v62)
        {
          do
          {
            uint64_t v47 = *--v44;
            uint64_t v46 = v47;
            void *v44 = 0;
            if (v47) {
              MEMORY[0x21667D390](v46, 0x1000C8077774924);
            }
          }
          while (v44 != v43);
          uint64_t v45 = v62;
        }
        unint64_t v63 = v43;
        operator delete(v45);
      }
      if (v60 != &v61) {
        free(v60);
      }
    }
  }
  return v39;
}

void mlir::mps::PoolMaxGradientOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::PoolMaxOpGenericAdaptorBase::PoolMaxOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v5;
  long long v8 = *(_OWORD *)(v5 + 16);
  long long v9 = *(_OWORD *)(v5 + 32);
  long long v10 = *(_OWORD *)(v5 + 48);
  *(void *)(a1 + 88) = *(void *)(v5 + 64);
  *(_OWORD *)(a1 + 72) = v10;
  *(_OWORD *)(a1 + 56) = v9;
  *(_OWORD *)(a1 + 40) = v8;
  *(_OWORD *)(a1 + 96) = *(_OWORD *)v13;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.pooling_max", 15, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::PoolMaxOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v89 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v75 = v6;
  if (!v6)
  {
    a3(v79, a4);
    if (v79[0])
    {
      LODWORD(v76) = 3;
      uint64_t v77 = "expected DictionaryAttr to set properties";
      uint64_t v78 = 41;
      unint64_t v26 = &v76;
      unsigned int v27 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v65 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v70 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
          unsigned int v27 = (char *)v80;
          unint64_t v26 = (uint64_t *)((char *)v80 + v70);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
          unint64_t v26 = &v76;
          unsigned int v27 = (char *)v80;
        }
      }
      uint64_t v28 = &v27[24 * v81];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)uint64_t v28 = v29;
      ++v81;
      if (v79[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      uint64_t v31 = v87;
      unint64_t v32 = __p;
      if (v87 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unint64_t v32 = __p;
      }
      unint64_t v87 = v30;
      operator delete(v32);
    }
    long long v21 = v84;
    if (!v84) {
      goto LABEL_71;
    }
    unsigned int v33 = v85;
    uint64_t v23 = v84;
    if (v85 == v84)
    {
LABEL_70:
      unint64_t v85 = v21;
      operator delete(v23);
LABEL_71:
      if (v80 != v83) {
        free(v80);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *unsigned int v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
    goto LABEL_69;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v75, "ceil_mode", 9uLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v79, a4);
      if (v79[0])
      {
        LODWORD(v76) = 3;
        uint64_t v78 = 54;
        long long v10 = &v76;
        uint64_t v11 = (char *)v80;
        if (v81 >= v82)
        {
          unint64_t v66 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            int64_t v71 = (char *)&v76 - (unsigned char *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
            uint64_t v11 = (char *)v80;
            long long v10 = (uint64_t *)((char *)v80 + v71);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
            long long v10 = &v76;
            uint64_t v11 = (char *)v80;
          }
        }
        uint64_t v12 = &v11[24 * v81];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = v10[2];
        *(_OWORD *)uint64_t v12 = v13;
        ++v81;
        if (v79[0])
        {
          uint64_t v14 = &v76;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v9);
          uint64_t v15 = (char *)v80;
          if (v81 >= v82)
          {
            unint64_t v67 = v81 + 1;
            if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
            {
              int64_t v72 = (char *)&v76 - (unsigned char *)v80;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
              uint64_t v15 = (char *)v80;
              uint64_t v14 = (uint64_t *)((char *)v80 + v72);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
              uint64_t v14 = &v76;
              uint64_t v15 = (char *)v80;
            }
          }
          uint64_t v16 = &v15[24 * v81];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = v14[2];
          *(_OWORD *)uint64_t v16 = v17;
          ++v81;
          if (v79[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
          }
        }
      }
      if (!v88) {
        return 0;
      }
      uint64_t v18 = __p;
      if (__p)
      {
        unint64_t v19 = v87;
        unsigned int v20 = __p;
        if (v87 != __p)
        {
          do
            unint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          unsigned int v20 = __p;
        }
        unint64_t v87 = v18;
        operator delete(v20);
      }
      long long v21 = v84;
      if (!v84) {
        goto LABEL_71;
      }
      unint64_t v22 = v85;
      uint64_t v23 = v84;
      if (v85 == v84) {
        goto LABEL_70;
      }
      do
      {
        uint64_t v25 = *--v22;
        uint64_t v24 = v25;
        void *v22 = 0;
        if (v25) {
          MEMORY[0x21667D390](v24, 0x1000C8077774924);
        }
      }
      while (v22 != v21);
      goto LABEL_69;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v75, "dilation_rates", 0xEuLL);
  if (v36)
  {
    uint64_t v37 = v36;
    if (mlir::DenseIntElementsAttr::classof(v36))
    {
      a1[1] = v37;
      goto LABEL_45;
    }
    a3(v79, a4);
    if (v79[0])
    {
      LODWORD(v76) = 3;
      uint64_t v78 = 59;
      uint64_t v42 = &v76;
      __int16 v43 = (char *)v80;
      if (v81 >= v82)
      {
        unint64_t v68 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          int64_t v73 = (char *)&v76 - (unsigned char *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          __int16 v43 = (char *)v80;
          uint64_t v42 = (uint64_t *)((char *)v80 + v73);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          uint64_t v42 = &v76;
          __int16 v43 = (char *)v80;
        }
      }
      uint64_t v44 = &v43[24 * v81];
      long long v45 = *(_OWORD *)v42;
      *((void *)v44 + 2) = v42[2];
      *(_OWORD *)uint64_t v44 = v45;
      ++v81;
      if (v79[0])
      {
        uint64_t v46 = &v76;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v37);
        uint64_t v47 = (char *)v80;
        if (v81 >= v82)
        {
          unint64_t v69 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            int64_t v74 = (char *)&v76 - (unsigned char *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v69, 24);
            uint64_t v47 = (char *)v80;
            uint64_t v46 = (uint64_t *)((char *)v80 + v74);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v69, 24);
            uint64_t v46 = &v76;
            uint64_t v47 = (char *)v80;
          }
        }
        uint64_t v48 = &v47[24 * v81];
        long long v49 = *(_OWORD *)v46;
        *((void *)v48 + 2) = v46[2];
        *(_OWORD *)uint64_t v48 = v49;
        ++v81;
        if (v79[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
        }
      }
    }
    if (!v88) {
      return 0;
    }
    unint64_t v50 = __p;
    if (__p)
    {
      unsigned int v51 = v87;
      uint64_t v52 = __p;
      if (v87 != __p)
      {
        do
          unsigned int v51 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v51 - 1);
        while (v51 != v50);
        uint64_t v52 = __p;
      }
      unint64_t v87 = v50;
      operator delete(v52);
    }
    long long v21 = v84;
    if (!v84) {
      goto LABEL_71;
    }
    int v53 = v85;
    uint64_t v23 = v84;
    if (v85 == v84) {
      goto LABEL_70;
    }
    do
    {
      uint64_t v55 = *--v53;
      uint64_t v54 = v55;
      void *v53 = 0;
      if (v55) {
        MEMORY[0x21667D390](v54, 0x1000C8077774924);
      }
    }
    while (v53 != v21);
LABEL_69:
    uint64_t v23 = v84;
    goto LABEL_70;
  }
LABEL_45:
  uint64_t v38 = mlir::DictionaryAttr::get((uint64_t)&v75, "explicit_padding", 0x10uLL);
  uint64_t v76 = v38;
  if (v38)
  {
    uint64_t v39 = v38;
    if (!mlir::DenseIntElementsAttr::classof(v38))
    {
      a3(v79, a4);
      goto LABEL_74;
    }
    a1[2] = v39;
  }
  uint64_t v40 = mlir::DictionaryAttr::get((uint64_t)&v75, "include_zero_pad", 0x10uLL);
  uint64_t v76 = v40;
  if (v40)
  {
    if (*(_UNKNOWN **)(*(void *)v40 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v79, a4);
      goto LABEL_74;
    }
    a1[3] = v40;
  }
  uint64_t v57 = mlir::DictionaryAttr::get((uint64_t)&v75, "indices_mode", 0xCuLL);
  uint64_t v76 = v57;
  if (v57)
  {
    if (*(_UNKNOWN **)(*(void *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id)
    {
      a3(v79, a4);
      goto LABEL_74;
    }
    a1[4] = v57;
  }
  uint64_t v58 = mlir::DictionaryAttr::get((uint64_t)&v75, "indices_result_type", 0x13uLL);
  uint64_t v76 = v58;
  if (v58)
  {
    if (*(_UNKNOWN **)(*(void *)v58 + 136) != &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
    {
      a3(v79, a4);
      goto LABEL_95;
    }
    a1[5] = v58;
  }
  uint64_t v59 = mlir::DictionaryAttr::get((uint64_t)&v75, "padding_style", 0xDuLL);
  uint64_t v76 = v59;
  if (v59)
  {
    if (*(_UNKNOWN **)(*(void *)v59 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
    {
      a3(v79, a4);
      goto LABEL_95;
    }
    a1[6] = v59;
  }
  uint64_t v60 = mlir::DictionaryAttr::get((uint64_t)&v75, "strides", 7uLL);
  uint64_t v76 = v60;
  if (v60)
  {
    uint64_t v61 = v60;
    if (!mlir::DenseIntElementsAttr::classof(v60))
    {
      a3(v79, a4);
      goto LABEL_95;
    }
    a1[7] = v61;
  }
  uint64_t v62 = mlir::DictionaryAttr::get((uint64_t)&v75, "window_sizes", 0xCuLL);
  uint64_t v76 = v62;
  if (!v62)
  {
    a3(v79, a4);
    mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v79, "expected key entry for window_sizes in DictionaryAttr to set Properties.");
    goto LABEL_96;
  }
  uint64_t v63 = v62;
  if (mlir::DenseIntElementsAttr::classof(v62))
  {
    a1[8] = v63;
    return 1;
  }
  a3(v79, a4);
LABEL_74:
  uint64_t v56 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v79, v41);
LABEL_95:
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v56, &v76);
LABEL_96:
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v79);
  return 0;
}

uint64_t mlir::mps::PoolMaxOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v63[6] = *MEMORY[0x263EF8340];
  uint64_t v60 = a1;
  uint64_t v61 = v63;
  uint64_t v62 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v60, (uint64_t)"ceil_mode", 9, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v62;
  if (v62 >= HIDWORD(v62))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v63, v62 + 1, 16);
    unsigned int v6 = v62;
  }
  uint64_t v7 = (uint64_t *)((char *)v61 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v62 + 1;
  LODWORD(v62) = v62 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v60, (uint64_t)"dilation_rates", 14, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v62;
    if (v62 >= HIDWORD(v62))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v63, v62 + 1, 16);
      unsigned int v13 = v62;
    }
    uint64_t v14 = (uint64_t *)((char *)v61 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v62 + 1;
    LODWORD(v62) = v62 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v60, (uint64_t)"explicit_padding", 16, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v62;
    if (v62 >= HIDWORD(v62))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v63, v62 + 1, 16);
      unsigned int v19 = v62;
    }
    unsigned int v20 = (uint64_t *)((char *)v61 + 16 * v19);
    uint64_t *v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v62 + 1;
    LODWORD(v62) = v62 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v60, (uint64_t)"include_zero_pad", 16, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v62;
    if (v62 >= HIDWORD(v62))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v63, v62 + 1, 16);
      unsigned int v25 = v62;
    }
    unint64_t v26 = (uint64_t *)((char *)v61 + 16 * v25);
    uint64_t *v26 = v22;
    v26[1] = v24;
    unsigned int v8 = v62 + 1;
    LODWORD(v62) = v62 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v60, (uint64_t)"indices_mode", 12, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v62;
    if (v62 >= HIDWORD(v62))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v63, v62 + 1, 16);
      unsigned int v31 = v62;
    }
    unint64_t v32 = (uint64_t *)((char *)v61 + 16 * v31);
    uint64_t *v32 = v28;
    v32[1] = v30;
    unsigned int v8 = v62 + 1;
    LODWORD(v62) = v62 + 1;
  }
  uint64_t v33 = a2[5];
  if (v33)
  {
    uint64_t v34 = mlir::Builder::getNamedAttr(&v60, (uint64_t)"indices_result_type", 19, v33);
    uint64_t v36 = v35;
    unsigned int v37 = v62;
    if (v62 >= HIDWORD(v62))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v63, v62 + 1, 16);
      unsigned int v37 = v62;
    }
    uint64_t v38 = (uint64_t *)((char *)v61 + 16 * v37);
    uint64_t *v38 = v34;
    v38[1] = v36;
    unsigned int v8 = v62 + 1;
    LODWORD(v62) = v62 + 1;
  }
  uint64_t v39 = a2[6];
  if (v39)
  {
    uint64_t v40 = mlir::Builder::getNamedAttr(&v60, (uint64_t)"padding_style", 13, v39);
    uint64_t v42 = v41;
    unsigned int v43 = v62;
    if (v62 >= HIDWORD(v62))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v63, v62 + 1, 16);
      unsigned int v43 = v62;
    }
    uint64_t v44 = (uint64_t *)((char *)v61 + 16 * v43);
    uint64_t *v44 = v40;
    v44[1] = v42;
    unsigned int v8 = v62 + 1;
    LODWORD(v62) = v62 + 1;
  }
  uint64_t v45 = a2[7];
  if (v45)
  {
    uint64_t v46 = mlir::Builder::getNamedAttr(&v60, (uint64_t)"strides", 7, v45);
    uint64_t v48 = v47;
    unsigned int v49 = v62;
    if (v62 >= HIDWORD(v62))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v63, v62 + 1, 16);
      unsigned int v49 = v62;
    }
    unint64_t v50 = (uint64_t *)((char *)v61 + 16 * v49);
    *unint64_t v50 = v46;
    v50[1] = v48;
    unsigned int v8 = v62 + 1;
    LODWORD(v62) = v62 + 1;
  }
  uint64_t v51 = a2[8];
  if (v51)
  {
    uint64_t v52 = mlir::Builder::getNamedAttr(&v60, (uint64_t)"window_sizes", 12, v51);
    uint64_t v54 = v53;
    unsigned int v55 = v62;
    if (v62 >= HIDWORD(v62))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v63, v62 + 1, 16);
      unsigned int v55 = v62;
    }
    uint64_t v56 = (uint64_t *)((char *)v61 + 16 * v55);
    *uint64_t v56 = v52;
    v56[1] = v54;
    unsigned int v8 = v62 + 1;
    LODWORD(v62) = v62 + 1;
  }
  uint64_t v57 = v61;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v61 == v63) {
      return DictionaryAttr;
    }
    goto LABEL_40;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v60, (uint64_t *)v61, v8);
  uint64_t v57 = v61;
  if (v61 != v63) {
LABEL_40:
  }
    free(v57);
  return DictionaryAttr;
}

unint64_t mlir::mps::PoolMaxOp::computePropertiesHash(unint64_t *a1)
{
  unint64_t v1 = *a1;
  uint64_t v2 = &unk_267770000;
  {
    unint64_t v56 = v1;
    unint64_t v64 = a1;
    uint64_t v2 = &unk_267770000;
    int v31 = v30;
    unint64_t v1 = v56;
    a1 = v64;
    if (v31)
    {
      unint64_t v32 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v32 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v32;
      unint64_t v1 = v56;
      a1 = v64;
      uint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v3 = HIDWORD(v1);
  unint64_t v4 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v1) ^ HIDWORD(v1));
  unint64_t v81 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  unint64_t v5 = a1[1];
  {
    unint64_t v57 = v5;
    unint64_t v65 = a1;
    uint64_t v2 = &unk_267770000;
    int v34 = v33;
    unint64_t v5 = v57;
    a1 = v65;
    if (v34)
    {
      unint64_t v35 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v35 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v35;
      unint64_t v5 = v57;
      a1 = v65;
      uint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v6 = HIDWORD(v5);
  unint64_t v7 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v5) ^ HIDWORD(v5));
  unint64_t v80 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
  unint64_t v8 = a1[2];
  {
    unint64_t v58 = v8;
    unint64_t v66 = a1;
    uint64_t v2 = &unk_267770000;
    int v37 = v36;
    unint64_t v8 = v58;
    a1 = v66;
    if (v37)
    {
      unint64_t v38 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v38 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v38;
      unint64_t v8 = v58;
      a1 = v66;
      uint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v9 = HIDWORD(v8);
  unint64_t v10 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v8) ^ HIDWORD(v8));
  unint64_t v79 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) ^ ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) >> 47));
  unint64_t v11 = a1[3];
  {
    unint64_t v59 = v11;
    unint64_t v67 = a1;
    uint64_t v2 = &unk_267770000;
    int v40 = v39;
    unint64_t v11 = v59;
    a1 = v67;
    if (v40)
    {
      unint64_t v41 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v41 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v41;
      unint64_t v11 = v59;
      a1 = v67;
      uint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v12 = HIDWORD(v11);
  unint64_t v13 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v11) ^ HIDWORD(v11));
  unint64_t v78 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v12 ^ (v13 >> 47) ^ v13)) ^ ((0x9DDFEA08EB382D69 * (v12 ^ (v13 >> 47) ^ v13)) >> 47));
  unint64_t v14 = a1[4];
  {
    unint64_t v60 = v14;
    unint64_t v68 = a1;
    uint64_t v2 = &unk_267770000;
    int v43 = v42;
    unint64_t v14 = v60;
    a1 = v68;
    if (v43)
    {
      unint64_t v44 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v44 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v44;
      unint64_t v14 = v60;
      a1 = v68;
      uint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v15 = HIDWORD(v14);
  unint64_t v16 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v14) ^ HIDWORD(v14));
  unint64_t v77 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v15 ^ (v16 >> 47) ^ v16)) ^ ((0x9DDFEA08EB382D69 * (v15 ^ (v16 >> 47) ^ v16)) >> 47));
  unint64_t v17 = a1[5];
  {
    unint64_t v61 = v17;
    unint64_t v69 = a1;
    uint64_t v2 = &unk_267770000;
    int v46 = v45;
    unint64_t v17 = v61;
    a1 = v69;
    if (v46)
    {
      unint64_t v47 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v47 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v47;
      unint64_t v17 = v61;
      a1 = v69;
      uint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v18 = HIDWORD(v17);
  unint64_t v19 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v17) ^ HIDWORD(v17));
  unint64_t v76 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v18 ^ (v19 >> 47) ^ v19)) ^ ((0x9DDFEA08EB382D69 * (v18 ^ (v19 >> 47) ^ v19)) >> 47));
  unint64_t v20 = a1[6];
  {
    unint64_t v62 = v20;
    int64_t v70 = a1;
    uint64_t v2 = &unk_267770000;
    int v49 = v48;
    unint64_t v20 = v62;
    a1 = v70;
    if (v49)
    {
      unint64_t v50 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v50 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v50;
      unint64_t v20 = v62;
      a1 = v70;
      uint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v21 = HIDWORD(v20);
  unint64_t v22 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v20) ^ HIDWORD(v20));
  unint64_t v75 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v21 ^ (v22 >> 47) ^ v22)) ^ ((0x9DDFEA08EB382D69 * (v21 ^ (v22 >> 47) ^ v22)) >> 47));
  unint64_t v23 = a1[7];
  {
    unint64_t v63 = v23;
    int64_t v71 = a1;
    uint64_t v2 = &unk_267770000;
    int v52 = v51;
    unint64_t v23 = v63;
    a1 = v71;
    if (v52)
    {
      unint64_t v53 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v53 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v53;
      unint64_t v23 = v63;
      a1 = v71;
      uint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v24 = HIDWORD(v23);
  unint64_t v25 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v23) ^ HIDWORD(v23));
  unint64_t v74 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v24 ^ (v25 >> 47) ^ v25)) ^ ((0x9DDFEA08EB382D69 * (v24 ^ (v25 >> 47) ^ v25)) >> 47));
  unint64_t v26 = a1[8];
  {
    unint64_t v72 = v26;
    unint64_t v26 = v72;
    uint64_t v2 = &unk_267770000;
    if (v54)
    {
      unint64_t v55 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v55 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v55;
      unint64_t v26 = v72;
      uint64_t v2 = (void *)&unk_267770000;
    }
  }
  unint64_t v27 = HIDWORD(v26);
  unint64_t v28 = 0x9DDFEA08EB382D69 * ((v2[385] + 8 * v26) ^ HIDWORD(v26));
  unint64_t v73 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v27 ^ (v28 >> 47) ^ v28)) ^ ((0x9DDFEA08EB382D69 * (v27 ^ (v28 >> 47) ^ v28)) >> 47));
  return llvm::hash_combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>(&v81, (uint64_t *)&v80, (uint64_t *)&v79, (uint64_t *)&v78, (uint64_t *)&v77, (uint64_t *)&v76, (uint64_t *)&v75, (uint64_t *)&v74, (uint64_t *)&v73);
}

unint64_t llvm::hash_combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>(void *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7, uint64_t *a8, uint64_t *a9)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v27 = 0;
  memset(v26, 0, sizeof(v26));
  memset(v25, 0, sizeof(v25));
  {
    unint64_t v21 = a2;
    unint64_t v22 = a1;
    a2 = v21;
    a1 = v22;
    if (v19)
    {
      unint64_t v20 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v20 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v20;
      a2 = v21;
      a1 = v22;
    }
  }
  uint64_t v15 = *a1;
  uint64_t v28 = llvm::hashing::detail::get_execution_seed(void)::seed;
  *(void *)&v25[0] = v15;
  unint64_t v23 = 0;
  unint64_t v16 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v25, (uint64_t *)&v23, (void *)v25 + 1, (unint64_t)v26, *a2);
  unint64_t v24 = v23;
  unint64_t v17 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v25, (uint64_t *)&v24, v16, (unint64_t)v26, *a3);
  return llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>((llvm::hashing::detail::hash_combine_recursive_helper *)v25, v24, v17, (char *)v26, a4, a5, a6, a7, a8, a9);
}

uint64_t mlir::mps::PoolMaxOp::getInherentAttr(int a1, void *a2, void *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n)) {
        return 0;
      }
      return a2[7];
    case 8uLL:
    case 0xAuLL:
    case 0xBuLL:
    case 0xFuLL:
    case 0x11uLL:
    case 0x12uLL:
      return 0;
    case 9uLL:
      if (*__s1 != 0x646F6D5F6C696563 || *((unsigned char *)__s1 + 8) != 101) {
        return 0;
      }
      return *a2;
    case 0xCuLL:
      if (!memcmp(__s1, "indices_mode", __n)) {
        return a2[4];
      }
      if (memcmp(__s1, "window_sizes", __n)) {
        return 0;
      }
      return a2[8];
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n)) {
        return 0;
      }
      return a2[6];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n)) {
        return 0;
      }
      return a2[1];
    case 0x10uLL:
      if (!memcmp(__s1, "explicit_padding", __n)) {
        return a2[2];
      }
      if (*__s1 != 0x5F6564756C636E69 || __s1[1] != 0x6461705F6F72657ALL) {
        return 0;
      }
      return a2[3];
    case 0x13uLL:
      if (memcmp(__s1, "indices_result_type", __n)) {
        return 0;
      }
      return a2[5];
    default:
      return 0;
  }
}

uint64_t mlir::mps::PoolMaxOp::setInherentAttr(uint64_t result, void *__s1, size_t __n, uint64_t a4)
{
  unint64_t v7 = (void *)result;
  switch(__n)
  {
    case 7uLL:
      uint64_t result = memcmp(__s1, "strides", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v16 = a4;
          }
          else {
            uint64_t v16 = 0;
          }
          v7[7] = v16;
        }
        else
        {
          v7[7] = 0;
        }
      }
      break;
    case 9uLL:
      if (*__s1 == 0x646F6D5F6C696563 && *((unsigned char *)__s1 + 8) == 101)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          *(void *)uint64_t result = v9;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 0xCuLL:
      uint64_t result = memcmp(__s1, "indices_mode", __n);
      if (result)
      {
        uint64_t result = memcmp(__s1, "window_sizes", __n);
        if (!result)
        {
          if (a4)
          {
            uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
            if (result) {
              uint64_t v10 = a4;
            }
            else {
              uint64_t v10 = 0;
            }
            v7[8] = v10;
          }
          else
          {
            v7[8] = 0;
          }
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id) {
          uint64_t v17 = a4;
        }
        else {
          uint64_t v17 = 0;
        }
        uint64_t v7[4] = v17;
      }
      else
      {
        uint64_t v7[4] = 0;
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "padding_style", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          v7[6] = v11;
        }
        else
        {
          v7[6] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "dilation_rates", __n);
      if (!result)
      {
        if (a4)
        {
          uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
          if (result) {
            uint64_t v12 = a4;
          }
          else {
            uint64_t v12 = 0;
          }
          v7[1] = v12;
        }
        else
        {
          v7[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      uint64_t result = memcmp(__s1, "explicit_padding", __n);
      if (result)
      {
        if (*__s1 == 0x5F6564756C636E69 && __s1[1] == 0x6461705F6F72657ALL)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
              uint64_t v14 = a4;
            }
            else {
              uint64_t v14 = 0;
            }
            v7[3] = v14;
          }
          else
          {
            v7[3] = 0;
          }
        }
      }
      else if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof(a4);
        if (result) {
          uint64_t v18 = a4;
        }
        else {
          uint64_t v18 = 0;
        }
        v7[2] = v18;
      }
      else
      {
        v7[2] = 0;
      }
      break;
    case 0x13uLL:
      uint64_t result = memcmp(__s1, "indices_result_type", __n);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id) {
            uint64_t v15 = a4;
          }
          else {
            uint64_t v15 = 0;
          }
          v7[5] = v15;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::PoolMaxOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"ceil_mode", 9, *a2);
  }
  uint64_t v5 = a2[1];
  if (v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"dilation_rates", 14, v5);
  }
  uint64_t v6 = a2[2];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"explicit_padding", 16, v6);
  }
  uint64_t v7 = a2[3];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"include_zero_pad", 16, v7);
  }
  uint64_t v8 = a2[4];
  if (v8) {
    mlir::NamedAttrList::append(a3, (uint64_t)"indices_mode", 12, v8);
  }
  uint64_t v9 = a2[5];
  if (v9) {
    mlir::NamedAttrList::append(a3, (uint64_t)"indices_result_type", 19, v9);
  }
  uint64_t v10 = a2[6];
  if (v10) {
    mlir::NamedAttrList::append(a3, (uint64_t)"padding_style", 13, v10);
  }
  uint64_t v11 = a2[7];
  if (v11) {
    mlir::NamedAttrList::append(a3, (uint64_t)"strides", 7, v11);
  }
  uint64_t v12 = a2[8];
  if (v12)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"window_sizes", 12, v12);
  }
}

BOOL mlir::mps::PoolMaxOp::readProperties(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::PoolMaxOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::PoolIndicesModeAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::TypeAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 6)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 7)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 8) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::PoolMaxOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::mps::PoolMaxOp::getWindowSizes(mlir::mps::PoolMaxOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  return *(void *)(v1 + 64);
}

uint64_t mlir::mps::PoolMaxOp::getStrides(mlir::mps::PoolMaxOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  return *(void *)(v1 + 56);
}

BOOL mlir::mps::PoolMaxOp::verifyInvariantsImpl(mlir::mps::PoolMaxOp *this)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    unint64_t v3 = 0;
  }
  unint64_t v4 = (void **)v3[8];
  if (v4)
  {
    uint64_t v5 = *v3;
    uint64_t v6 = (void **)v3[1];
    uint64_t v8 = (void **)v3[2];
    uint64_t v7 = v3[3];
    uint64_t v10 = v3[4];
    uint64_t v9 = v3[5];
    uint64_t v11 = v3[6];
    uint64_t v12 = (void **)v3[7];
    v30[0] = v2;
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v4, (void **)"window_sizes", (const char *)0xC, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30))return 0; {
    v30[0] = *(void *)this;
    }
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v12, (void **)"strides", (const char *)7, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30))return 0; {
    v30[0] = *(void *)this;
    }
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v6, (void **)"dilation_rates", (const char *)0xE, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30))return 0; {
    v30[0] = *(void *)this;
    }
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v11, (void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30))return 0; {
    v30[0] = *(void *)this;
    }
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps34(v8, (void **)"explicit_padding", (const char *)0x10, (void (*)(void **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps34(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30))return 0; {
    v30[0] = *(void *)this;
    }
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (void **)"ceil_mode", (const char *)9, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30))return 0; {
    v30[0] = *(void *)this;
    }
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (void **)"include_zero_pad", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30))return 0; {
    v30[0] = *(void *)this;
    }
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps35(v10, (void **)"indices_mode", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps35(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30))return 0; {
    v30[0] = *(void *)this;
    }
    if (!mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v9, (void **)"indices_result_type", (const char *)0x13, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps4(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0))
    {
      return 0;
    }
    uint64_t v13 = *(_DWORD *)(*(void *)this + 36) ? *(void *)this - 16 : 0;
    uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v13, 0);
    if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0))
    {
      if (*(_DWORD *)(*(void *)this + 36)) {
        uint64_t v15 = *(void *)this - 16;
      }
      else {
        uint64_t v15 = 0;
      }
      uint64_t v16 = mlir::detail::OpResultImpl::getNextResultAtOffset(v15, 1);
      uint64_t v17 = mlir::detail::OpResultImpl::getNextResultAtOffset(v16, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps24(*(void *)this, *(void *)(v17 + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 1u) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v28 = (void **)"requires attribute 'window_sizes'";
    __int16 v29 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, &v28, (uint64_t)v30);
    uint64_t v18 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v30);
    if (v30[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v30);
    }
    if (v37)
    {
      unint64_t v20 = __p;
      if (__p)
      {
        unint64_t v21 = v36;
        unint64_t v22 = __p;
        if (v36 != __p)
        {
          do
            unint64_t v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
          while (v21 != v20);
          unint64_t v22 = __p;
        }
        int v36 = v20;
        operator delete(v22);
      }
      unint64_t v23 = v33;
      if (v33)
      {
        unint64_t v24 = v34;
        unint64_t v25 = v33;
        if (v34 != v33)
        {
          do
          {
            uint64_t v27 = *--v24;
            uint64_t v26 = v27;
            *unint64_t v24 = 0;
            if (v27) {
              MEMORY[0x21667D390](v26, 0x1000C8077774924);
            }
          }
          while (v24 != v23);
          unint64_t v25 = v33;
        }
        int v34 = v23;
        operator delete(v25);
      }
      if (v31 != &v32) {
        free(v31);
      }
    }
  }
  return v18;
}

void mlir::mps::PoolMaxOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::PowerOpGenericAdaptorBase::PowerOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  unint64_t v5 = *((unsigned int *)this + 11);
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.power", 9, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::PowerOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::PruningGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v79 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v65 = v6;
  if (!v6)
  {
    a3(v69, a4);
    if (v69[0])
    {
      LODWORD(v66) = 3;
      unint64_t v67 = "expected DictionaryAttr to set properties";
      uint64_t v68 = 41;
      uint64_t v26 = &v66;
      uint64_t v27 = (char *)v70;
      if (v71 >= v72)
      {
        unint64_t v55 = v71 + 1;
        if (v70 <= &v66 && (char *)v70 + 24 * v71 > (char *)&v66)
        {
          int64_t v60 = (char *)&v66 - (unsigned char *)v70;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v55, 24);
          uint64_t v27 = (char *)v70;
          uint64_t v26 = (uint64_t *)((char *)v70 + v60);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v55, 24);
          uint64_t v26 = &v66;
          uint64_t v27 = (char *)v70;
        }
      }
      uint64_t v28 = &v27[24 * v71];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)uint64_t v28 = v29;
      ++v71;
      if (v69[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v69);
      }
    }
    if (!v78) {
      return 0;
    }
    int v30 = __p;
    if (__p)
    {
      int v31 = v77;
      uint64_t v32 = __p;
      if (v77 != __p)
      {
        do
          int v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        uint64_t v32 = __p;
      }
      unint64_t v77 = v30;
      operator delete(v32);
    }
    unint64_t v21 = v74;
    if (!v74) {
      goto LABEL_64;
    }
    int v33 = v75;
    unint64_t v23 = v74;
    if (v75 == v74)
    {
LABEL_63:
      unint64_t v75 = v21;
      operator delete(v23);
LABEL_64:
      if (v70 != v73) {
        free(v70);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *int v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
LABEL_62:
    unint64_t v23 = v74;
    goto LABEL_63;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v65, "pruning_metric", 0xEuLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id)
    {
      a3(v69, a4);
      if (v69[0])
      {
        LODWORD(v66) = 3;
        uint64_t v68 = 59;
        uint64_t v10 = &v66;
        uint64_t v11 = (char *)v70;
        if (v71 >= v72)
        {
          unint64_t v56 = v71 + 1;
          if (v70 <= &v66 && (char *)v70 + 24 * v71 > (char *)&v66)
          {
            int64_t v61 = (char *)&v66 - (unsigned char *)v70;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v56, 24);
            uint64_t v11 = (char *)v70;
            uint64_t v10 = (uint64_t *)((char *)v70 + v61);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v56, 24);
            uint64_t v10 = &v66;
            uint64_t v11 = (char *)v70;
          }
        }
        uint64_t v12 = &v11[24 * v71];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = v10[2];
        *(_OWORD *)uint64_t v12 = v13;
        ++v71;
        if (v69[0])
        {
          uint64_t v14 = &v66;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v66, v9);
          uint64_t v15 = (char *)v70;
          if (v71 >= v72)
          {
            unint64_t v57 = v71 + 1;
            if (v70 <= &v66 && (char *)v70 + 24 * v71 > (char *)&v66)
            {
              int64_t v62 = (char *)&v66 - (unsigned char *)v70;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v57, 24);
              uint64_t v15 = (char *)v70;
              uint64_t v14 = (uint64_t *)((char *)v70 + v62);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v57, 24);
              uint64_t v14 = &v66;
              uint64_t v15 = (char *)v70;
            }
          }
          uint64_t v16 = &v15[24 * v71];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = v14[2];
          *(_OWORD *)uint64_t v16 = v17;
          ++v71;
          if (v69[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v69);
          }
        }
      }
      if (!v78) {
        return 0;
      }
      uint64_t v18 = __p;
      if (__p)
      {
        int v19 = v77;
        unint64_t v20 = __p;
        if (v77 != __p)
        {
          do
            int v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          unint64_t v20 = __p;
        }
        unint64_t v77 = v18;
        operator delete(v20);
      }
      unint64_t v21 = v74;
      if (!v74) {
        goto LABEL_64;
      }
      unint64_t v22 = v75;
      unint64_t v23 = v74;
      if (v75 == v74) {
        goto LABEL_63;
      }
      do
      {
        uint64_t v25 = *--v22;
        uint64_t v24 = v25;
        void *v22 = 0;
        if (v25) {
          MEMORY[0x21667D390](v24, 0x1000C8077774924);
        }
      }
      while (v22 != v21);
      goto LABEL_62;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v65, "pruning_structure", 0x11uLL);
  if (v36)
  {
    uint64_t v37 = v36;
    if (*(_UNKNOWN **)(*(void *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id)
    {
      a3(v69, a4);
      if (v69[0])
      {
        LODWORD(v66) = 3;
        uint64_t v68 = 62;
        uint64_t v38 = &v66;
        int v39 = (char *)v70;
        if (v71 >= v72)
        {
          unint64_t v58 = v71 + 1;
          if (v70 <= &v66 && (char *)v70 + 24 * v71 > (char *)&v66)
          {
            int64_t v63 = (char *)&v66 - (unsigned char *)v70;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v58, 24);
            int v39 = (char *)v70;
            uint64_t v38 = (uint64_t *)((char *)v70 + v63);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v58, 24);
            uint64_t v38 = &v66;
            int v39 = (char *)v70;
          }
        }
        int v40 = &v39[24 * v71];
        long long v41 = *(_OWORD *)v38;
        *((void *)v40 + 2) = v38[2];
        *(_OWORD *)int v40 = v41;
        ++v71;
        if (v69[0])
        {
          int v42 = &v66;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v66, v37);
          int v43 = (char *)v70;
          if (v71 >= v72)
          {
            unint64_t v59 = v71 + 1;
            if (v70 <= &v66 && (char *)v70 + 24 * v71 > (char *)&v66)
            {
              int64_t v64 = (char *)&v66 - (unsigned char *)v70;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v59, 24);
              int v43 = (char *)v70;
              int v42 = (uint64_t *)((char *)v70 + v64);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v59, 24);
              int v42 = &v66;
              int v43 = (char *)v70;
            }
          }
          unint64_t v44 = &v43[24 * v71];
          long long v45 = *(_OWORD *)v42;
          *((void *)v44 + 2) = v42[2];
          *(_OWORD *)unint64_t v44 = v45;
          ++v71;
          if (v69[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v69);
          }
        }
      }
      if (!v78) {
        return 0;
      }
      int v46 = __p;
      if (__p)
      {
        unint64_t v47 = v77;
        int v48 = __p;
        if (v77 != __p)
        {
          do
            unint64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          int v48 = __p;
        }
        unint64_t v77 = v46;
        operator delete(v48);
      }
      unint64_t v21 = v74;
      if (!v74) {
        goto LABEL_64;
      }
      int v49 = v75;
      unint64_t v23 = v74;
      if (v75 == v74) {
        goto LABEL_63;
      }
      do
      {
        uint64_t v51 = *--v49;
        uint64_t v50 = v51;
        *int v49 = 0;
        if (v51) {
          MEMORY[0x21667D390](v50, 0x1000C8077774924);
        }
      }
      while (v49 != v21);
      goto LABEL_62;
    }
    a1[1] = v36;
  }
  uint64_t v52 = mlir::DictionaryAttr::get((uint64_t)&v65, "sparsity", 8uLL);
  uint64_t v66 = v52;
  if (!v52) {
    return 1;
  }
  if (*(_UNKNOWN **)(*(void *)v52 + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    a1[2] = v52;
    return 1;
  }
  a3(v69, a4);
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v53, &v66);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v69);
  return 0;
}

uint64_t mlir::mps::PruningGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v27[6] = *MEMORY[0x263EF8340];
  uint64_t v24 = a1;
  uint64_t v25 = v27;
  uint64_t v26 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v24, (uint64_t)"pruning_metric", 14, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v26;
  if (v26 >= HIDWORD(v26))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
    unsigned int v6 = v26;
  }
  uint64_t v7 = (uint64_t *)((char *)v25 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v26 + 1;
  LODWORD(v26) = v26 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v24, (uint64_t)"pruning_structure", 17, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v26;
    if (v26 >= HIDWORD(v26))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
      unsigned int v13 = v26;
    }
    uint64_t v14 = (uint64_t *)((char *)v25 + 16 * v13);
    *uint64_t v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v26 + 1;
    LODWORD(v26) = v26 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v24, (uint64_t)"sparsity", 8, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v26;
    if (v26 >= HIDWORD(v26))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
      unsigned int v19 = v26;
    }
    unint64_t v20 = (uint64_t *)((char *)v25 + 16 * v19);
    uint64_t *v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v26 + 1;
    LODWORD(v26) = v26 + 1;
  }
  unint64_t v21 = v25;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v25 == v27) {
      return DictionaryAttr;
    }
    goto LABEL_16;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v24, (uint64_t *)v25, v8);
  unint64_t v21 = v25;
  if (v25 != v27) {
LABEL_16:
  }
    free(v21);
  return DictionaryAttr;
}

uint64_t mlir::mps::PruningGradientOp::setInherentAttr(uint64_t result, char *__s1, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = result;
  if (a3 == 8)
  {
    uint64_t result = memcmp(__s1, "sparsity", 8uLL);
    if (!result)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id) {
          uint64_t v7 = a4;
        }
        else {
          uint64_t v7 = 0;
        }
        *(void *)(v5 + 16) = v7;
      }
      else
      {
        *(void *)(v5 + 16) = 0;
      }
    }
  }
  else if (a3 == 17)
  {
    uint64_t result = memcmp(__s1, "pruning_structure", 0x11uLL);
    if (!result)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id) {
          uint64_t v8 = a4;
        }
        else {
          uint64_t v8 = 0;
        }
        *(void *)(v5 + 8) = v8;
      }
      else
      {
        *(void *)(v5 + 8) = 0;
      }
    }
  }
  else if (a3 == 14 && *(void *)__s1 == 0x5F676E696E757270 && *(void *)(__s1 + 6) == 0x63697274656D5F67)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      *(void *)uint64_t result = v9;
    }
    else
    {
      *(void *)uint64_t result = 0;
    }
  }
  return result;
}

BOOL mlir::mps::PruningGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps36(v8, (void **)"pruning_metric", (const char *)0xE, a3, a4))
  {
    uint64_t v9 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps37(v9, (void **)"pruning_structure", (const char *)0x11, a3, a4))
    {
      uint64_t v10 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(v10, (void **)"sparsity", (const char *)8, a3, a4))
      {
        return 1;
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps36(uint64_t a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    int v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      long long v29 = a2;
      int v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        int v30 = "' failed to satisfy constraint: pruning metrics";
        uint64_t v31 = 47;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        unsigned int v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)unsigned int v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = __p;
    if (__p)
    {
      uint64_t v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          uint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      int v42 = v16;
      operator delete(v18);
    }
    unsigned int v19 = v39;
    if (v39)
    {
      unint64_t v20 = v40;
      unint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        unint64_t v21 = v39;
      }
      int v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps37(uint64_t a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    int v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      long long v29 = a2;
      int v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        int v30 = "' failed to satisfy constraint: pruning structure";
        uint64_t v31 = 49;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        unsigned int v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)unsigned int v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = __p;
    if (__p)
    {
      uint64_t v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          uint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      int v42 = v16;
      operator delete(v18);
    }
    unsigned int v19 = v39;
    if (v39)
    {
      unint64_t v20 = v40;
      unint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        unint64_t v21 = v39;
      }
      int v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::PruningGradientOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::PruningMetricAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  uint64_t v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unsigned int v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        unsigned int v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unsigned int v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  int v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::PruningMetricAttr]";
  unint64_t v41 = 78;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    int v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      long long v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          long long v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unsigned int v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unsigned int v19 = (char *)v46;
            uint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unsigned int v19 = (char *)v46;
          }
        }
        unint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)unint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      uint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      uint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      uint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::PruningStructureAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  uint64_t v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unsigned int v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        unsigned int v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unsigned int v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  int v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::PruningStructureAttr]";
  unint64_t v41 = 81;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    int v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      long long v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          long long v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unsigned int v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unsigned int v19 = (char *)v46;
            uint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unsigned int v19 = (char *)v46;
          }
        }
        unint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)unint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      uint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      uint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      uint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

mlir::Float32Type *mlir::mps::PruningGradientOp::populateDefaultProperties(uint64_t a1, mlir::Float32Type **a2)
{
  unint64_t v11 = *(void **)(a1 + 8);
  uint64_t result = (mlir::Float32Type *)mlir::Attribute::getContext((mlir::Attribute *)&v11);
  uint64_t v5 = result;
  long long v9 = result;
  if (*a2)
  {
    if (a2[1]) {
      goto LABEL_3;
    }
  }
  else
  {
    unsigned int v10 = 0;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(result);
    unint64_t v11 = &mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id;
    uint64_t v12 = v5;
    uint64_t result = (mlir::Float32Type *)mlir::StorageUniquer::get<mlir::mps::detail::PruningMetricAttrStorage,mlir::mps::PruningMetric>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24PruningMetricAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17PruningMetricAttrEJNS2_13PruningMetricEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v11, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id, &v10);
    *a2 = result;
    if (a2[1])
    {
LABEL_3:
      if (a2[2]) {
        return result;
      }
LABEL_7:
      uint64_t F32Type = mlir::Builder::getF32Type(&v9, v4);
      uint64_t result = mlir::Builder::getFloatAttr(0.5, (uint64_t)&v9, F32Type);
      a2[2] = result;
      return result;
    }
  }
  unsigned int v10 = 1;
  uint64_t v7 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v5);
  unint64_t v11 = &mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id;
  uint64_t v12 = v5;
  uint64_t result = (mlir::Float32Type *)mlir::StorageUniquer::get<mlir::mps::detail::PruningStructureAttrStorage,mlir::mps::PruningStructure>(v7, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27PruningStructureAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20PruningStructureAttrEJNS2_16PruningStructureEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v11, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id, &v10);
  a2[1] = result;
  if (!a2[2]) {
    goto LABEL_7;
  }
  return result;
}

BOOL mlir::mps::PruningGradientOp::verifyInvariantsImpl(mlir::mps::PruningGradientOp *this)
{
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  unsigned int v6 = (void **)v3[2];
  uint64_t v10 = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps36(v4, (void **)"pruning_metric", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps36(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v10))return 0; {
  uint64_t v10 = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps37(v5, (void **)"pruning_structure", (const char *)0x11, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps37(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v10))return 0; {
  uint64_t v10 = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(v6, (void **)"sparsity", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v10)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 1u))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v7 = *(void *)this - 16;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
}

void mlir::mps::PruningGradientOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::PruningOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

BOOL mlir::mps::PruningOp::verifyInvariantsImpl(mlir::mps::PruningOp *this)
{
  uint64_t v2 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v3 = (uint64_t *)(*(void *)this
  }
                   + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1)
                   + 64);
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = *v3;
  uint64_t v5 = v3[1];
  unsigned int v6 = (void **)v3[2];
  uint64_t v10 = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps36(v4, (void **)"pruning_metric", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps36(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v10))return 0; {
  uint64_t v10 = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps37(v5, (void **)"pruning_structure", (const char *)0x11, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps37(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v10))return 0; {
  uint64_t v10 = *(void *)this;
  }
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(v6, (void **)"sparsity", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v10)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0))
  {
    return 0;
  }
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v7 = *(void *)this - 16;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*(void *)this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
}

void mlir::mps::PruningOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::detail::QuantizeOpGenericAdaptorBase::QuantizeOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (_OWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v11, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  long long v8 = *(_OWORD *)v11;
  *(_OWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 40) = v8;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "mps.quantize", 12, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::QuantizeOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

void mlir::mps::QuantizeOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v29[2] = *MEMORY[0x263EF8340];
  uint64_t v23 = a4;
  uint64_t v24 = a3;
  uint64_t v22 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v24, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v23, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  *(void *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::QuantizeOpGenericAdaptorBase::Properties>(a2)
            + 8) = a6;
  if (a7) {
    *(void *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::QuantizeOpGenericAdaptorBase::Properties>(a2) = a7;
  }
  __src = v29;
  uint64_t v28 = 0x200000000;
  unint64_t v11 = *a1;
  mlir::ValueRange::ValueRange(v26, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  long long v14 = *(long long **)(a2 + 256);
  mlir::ValueRange::ValueRange(v25, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::QuantizeOp::inferReturnTypes(v11, v15, v16, v26[0], v26[1], Dictionary, v14, v17, v25[0], v25[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v18 = __src;
  }
  uint64_t v19 = v28;
  uint64_t v20 = *(unsigned int *)(a2 + 72);
  unint64_t v21 = v20 + v28;
  if (v21 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v21, 8);
    LODWORD(v20) = *(_DWORD *)(a2 + 72);
  }
  if (v19)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v20), v18, 8 * v19);
    LODWORD(v20) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v20 + v19;
  if (__src != v29) {
    free(__src);
  }
}

BOOL mlir::mps::QuantizeOp::verifyInvariantsImpl(void ***this)
{
  uint64_t v128 = *MEMORY[0x263EF8340];
  uint64_t v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    unint64_t v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    unint64_t v3 = 0;
  }
  uint64_t v4 = *(void *)(v3 + 8);
  if (v4)
  {
    uint64_t v5 = *(void ***)v3;
    BOOL v117 = v2;
    if (!mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v4, (void **)"dtype", (const char *)5, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps4(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v117))return 0; {
    BOOL v117 = *this;
    }
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v5, (void **)"axis", (const char *)4, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v117)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6((uint64_t)*this, *(void *)(*((void *)(*this)[9] + 3) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0))
    {
      return 0;
    }
    uint64_t v6 = (uint64_t)*this;
    uint64_t v7 = (void **)(*(void *)(*((void *)(*this)[9] + 7) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (*((_UNKNOWN **)*v7 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
      goto LABEL_60;
    }
    uint64_t v8 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v7 + 8);
    BOOL v117 = v7;
    uint64_t v118 = v8;
    if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v117)) {
      goto LABEL_60;
    }
    uint64_t v9 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v7 + 8);
    unint64_t v108 = v7;
    uint64_t v109 = v9;
    mlir::ShapedType::getShape((mlir::ShapedType *)&v108);
    if (v10)
    {
      uint64_t v11 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v7 + 8);
      unint64_t v114 = v7;
      uint64_t v115 = v11;
      mlir::ShapedType::getShape((mlir::ShapedType *)&v114);
      if (v12 != 1) {
        goto LABEL_60;
      }
    }
    uint64_t v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v7 + 8);
    BOOL v111 = v7;
    uint64_t v112 = v13;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v111);
    if (!mlir::Type::isF16((mlir::Type *)&OperandRange)
      && !mlir::Type::isF32((mlir::Type *)&OperandRange)
      && !mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
LABEL_60:
      __int16 v110 = 261;
      unint64_t v108 = (void **)"operand";
      uint64_t v109 = 7;
      mlir::Operation::emitOpError(v6, &v108, (uint64_t)&v117);
      if (v117)
      {
        LODWORD(v114) = 3;
        uint64_t v115 = (uint64_t)" #";
        uint64_t v116 = 2;
        long long v14 = &v114;
        uint64_t v15 = (char *)v119;
        if (v120 >= v121)
        {
          unint64_t v88 = v120 + 1;
          if (v119 <= &v114 && (char *)v119 + 24 * v120 > (char *)&v114)
          {
            int64_t v100 = (char *)&v114 - (unsigned char *)v119;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v119, v122, v88, 24);
            uint64_t v15 = (char *)v119;
            long long v14 = (void ***)((char *)v119 + v100);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v119, v122, v88, 24);
            long long v14 = &v114;
            uint64_t v15 = (char *)v119;
          }
        }
        int v16 = &v15[24 * v120];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = v14[2];
        *(_OWORD *)int v16 = v17;
        uint64_t v18 = ++v120;
        if (v117)
        {
          LODWORD(v114) = 5;
          uint64_t v115 = 1;
          uint64_t v19 = &v114;
          uint64_t v20 = (char *)v119;
          if (v18 >= v121)
          {
            unint64_t v90 = v18 + 1;
            BOOL v91 = (char *)v119 + 24 * v18 > (char *)&v114;
            if (v119 <= &v114 && v91)
            {
              int64_t v102 = (char *)&v114 - (unsigned char *)v119;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v119, v122, v90, 24);
              uint64_t v20 = (char *)v119;
              uint64_t v19 = (void ***)((char *)v119 + v102);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v119, v122, v90, 24);
              uint64_t v19 = &v114;
              uint64_t v20 = (char *)v119;
            }
          }
          unint64_t v21 = &v20[24 * v120];
          long long v22 = *(_OWORD *)v19;
          *((void *)v21 + 2) = v19[2];
          *(_OWORD *)unint64_t v21 = v22;
          uint64_t v23 = ++v120;
          if (v117)
          {
            LODWORD(v114) = 3;
            uint64_t v115 = (uint64_t)" must be 0D/1D tensor of floating point values, but got ";
            uint64_t v116 = 56;
            uint64_t v24 = &v114;
            unint64_t v25 = (char *)v119;
            if (v23 >= v121)
            {
              unint64_t v94 = v23 + 1;
              BOOL v95 = (char *)v119 + 24 * v23 > (char *)&v114;
              if (v119 <= &v114 && v95)
              {
                int64_t v104 = (char *)&v114 - (unsigned char *)v119;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v119, v122, v94, 24);
                unint64_t v25 = (char *)v119;
                uint64_t v24 = (void ***)((char *)v119 + v104);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v119, v122, v94, 24);
                uint64_t v24 = &v114;
                unint64_t v25 = (char *)v119;
              }
            }
            unint64_t v26 = &v25[24 * v120];
            long long v27 = *(_OWORD *)v24;
            *((void *)v26 + 2) = v24[2];
            *(_OWORD *)unint64_t v26 = v27;
            ++v120;
            if (v117)
            {
              uint64_t v28 = &v114;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v114, (uint64_t)v7);
              uint64_t v29 = (char *)v119;
              if (v120 >= v121)
              {
                unint64_t v98 = v120 + 1;
                if (v119 <= &v114 && (char *)v119 + 24 * v120 > (char *)&v114)
                {
                  int64_t v106 = (char *)&v114 - (unsigned char *)v119;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v119, v122, v98, 24);
                  uint64_t v29 = (char *)v119;
                  uint64_t v28 = (void ***)((char *)v119 + v106);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v119, v122, v98, 24);
                  uint64_t v28 = &v114;
                  uint64_t v29 = (char *)v119;
                }
              }
              uint64_t v30 = &v29[24 * v120];
              long long v31 = *(_OWORD *)v28;
              *((void *)v30 + 2) = v28[2];
              *(_OWORD *)uint64_t v30 = v31;
              ++v120;
            }
          }
        }
      }
      char v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v117);
      if (v117) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v117);
      }
      if (v127)
      {
        unint64_t v33 = __p;
        if (__p)
        {
          unint64_t v34 = v126;
          int64_t v35 = __p;
          if (v126 != __p)
          {
            do
              unint64_t v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
            while (v34 != v33);
            int64_t v35 = __p;
          }
          int64_t v126 = v33;
          operator delete(v35);
        }
        int64_t v36 = v123;
        if (v123)
        {
          int64_t v37 = v124;
          uint64_t v38 = v123;
          if (v124 != v123)
          {
            do
            {
              uint64_t v40 = *--v37;
              uint64_t v39 = v40;
              void *v37 = 0;
              if (v40) {
                MEMORY[0x21667D390](v39, 0x1000C8077774924);
              }
            }
            while (v37 != v36);
            uint64_t v38 = v123;
          }
          int64_t v124 = v36;
          operator delete(v38);
        }
        if (v119 != v122) {
          free(v119);
        }
      }
      if (!v32) {
        return 0;
      }
    }
    uint64_t v50 = (uint64_t)*this;
    uint64_t v51 = (void **)(*(void *)(*((void *)(*this)[9] + 11) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (*((_UNKNOWN **)*v51 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
      uint64_t v52 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v51 + 8);
      BOOL v117 = v51;
      uint64_t v118 = v52;
      if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v117))
      {
        uint64_t v53 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v51 + 8);
        unint64_t v108 = v51;
        uint64_t v109 = v53;
        mlir::ShapedType::getShape((mlir::ShapedType *)&v108);
        if (!v54
          || (uint64_t v55 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v51 + 8),
              unint64_t v114 = v51,
              uint64_t v115 = v55,
              mlir::ShapedType::getShape((mlir::ShapedType *)&v114),
              v56 == 1))
        {
          uint64_t v57 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v51 + 8);
          BOOL v111 = v51;
          uint64_t v112 = v57;
          uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v111);
          if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 2)
            || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 4)
            || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
            || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
            || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
            || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 1)
            || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 2)
            || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 4)
            || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
            || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
            || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
            || *(_UNKNOWN **)(*(void *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::mps::NF4Type,void>::id)
          {
            goto LABEL_145;
          }
        }
      }
    }
    __int16 v110 = 261;
    unint64_t v108 = (void **)"operand";
    uint64_t v109 = 7;
    mlir::Operation::emitOpError(v50, &v108, (uint64_t)&v117);
    if (v117)
    {
      LODWORD(v114) = 3;
      uint64_t v115 = (uint64_t)" #";
      uint64_t v116 = 2;
      unint64_t v58 = &v114;
      unint64_t v59 = (char *)v119;
      if (v120 >= v121)
      {
        unint64_t v89 = v120 + 1;
        if (v119 <= &v114 && (char *)v119 + 24 * v120 > (char *)&v114)
        {
          int64_t v101 = (char *)&v114 - (unsigned char *)v119;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v119, v122, v89, 24);
          unint64_t v59 = (char *)v119;
          unint64_t v58 = (void ***)((char *)v119 + v101);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v119, v122, v89, 24);
          unint64_t v58 = &v114;
          unint64_t v59 = (char *)v119;
        }
      }
      int64_t v60 = &v59[24 * v120];
      long long v61 = *(_OWORD *)v58;
      *((void *)v60 + 2) = v58[2];
      *(_OWORD *)int64_t v60 = v61;
      uint64_t v62 = ++v120;
      if (v117)
      {
        LODWORD(v114) = 5;
        uint64_t v115 = 2;
        int64_t v63 = &v114;
        int64_t v64 = (char *)v119;
        if (v62 >= v121)
        {
          unint64_t v92 = v62 + 1;
          BOOL v93 = (char *)v119 + 24 * v62 > (char *)&v114;
          if (v119 <= &v114 && v93)
          {
            int64_t v103 = (char *)&v114 - (unsigned char *)v119;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v119, v122, v92, 24);
            int64_t v64 = (char *)v119;
            int64_t v63 = (void ***)((char *)v119 + v103);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v119, v122, v92, 24);
            int64_t v63 = &v114;
            int64_t v64 = (char *)v119;
          }
        }
        uint64_t v65 = &v64[24 * v120];
        long long v66 = *(_OWORD *)v63;
        *((void *)v65 + 2) = v63[2];
        *(_OWORD *)uint64_t v65 = v66;
        uint64_t v67 = ++v120;
        if (v117)
        {
          LODWORD(v114) = 3;
          uint64_t v115 = (uint64_t)" must be 0D/1D tensor of quantized values, but got ";
          uint64_t v116 = 51;
          uint64_t v68 = &v114;
          unint64_t v69 = (char *)v119;
          if (v67 >= v121)
          {
            unint64_t v96 = v67 + 1;
            BOOL v97 = (char *)v119 + 24 * v67 > (char *)&v114;
            if (v119 <= &v114 && v97)
            {
              int64_t v105 = (char *)&v114 - (unsigned char *)v119;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v119, v122, v96, 24);
              unint64_t v69 = (char *)v119;
              uint64_t v68 = (void ***)((char *)v119 + v105);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v119, v122, v96, 24);
              uint64_t v68 = &v114;
              unint64_t v69 = (char *)v119;
            }
          }
          int64_t v70 = &v69[24 * v120];
          long long v71 = *(_OWORD *)v68;
          *((void *)v70 + 2) = v68[2];
          *(_OWORD *)int64_t v70 = v71;
          ++v120;
          if (v117)
          {
            unsigned int v72 = &v114;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v114, (uint64_t)v51);
            unint64_t v73 = (char *)v119;
            if (v120 >= v121)
            {
              unint64_t v99 = v120 + 1;
              if (v119 <= &v114 && (char *)v119 + 24 * v120 > (char *)&v114)
              {
                int64_t v107 = (char *)&v114 - (unsigned char *)v119;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v119, v122, v99, 24);
                unint64_t v73 = (char *)v119;
                unsigned int v72 = (void ***)((char *)v119 + v107);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v119, v122, v99, 24);
                unsigned int v72 = &v114;
                unint64_t v73 = (char *)v119;
              }
            }
            unint64_t v74 = &v73[24 * v120];
            long long v75 = *(_OWORD *)v72;
            *((void *)v74 + 2) = v72[2];
            *(_OWORD *)unint64_t v74 = v75;
            ++v120;
          }
        }
      }
    }
    char v76 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v117);
    if (v117) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v117);
    }
    if (v127)
    {
      unint64_t v77 = __p;
      if (__p)
      {
        char v78 = v126;
        uint64_t v79 = __p;
        if (v126 != __p)
        {
          do
            char v78 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v78 - 1);
          while (v78 != v77);
          uint64_t v79 = __p;
        }
        int64_t v126 = v77;
        operator delete(v79);
      }
      unint64_t v80 = v123;
      if (v123)
      {
        unint64_t v81 = v124;
        unsigned int v82 = v123;
        if (v124 != v123)
        {
          do
          {
            uint64_t v84 = *--v81;
            uint64_t v83 = v84;
            void *v81 = 0;
            if (v84) {
              MEMORY[0x21667D390](v83, 0x1000C8077774924);
            }
          }
          while (v81 != v80);
          unsigned int v82 = v123;
        }
        int64_t v124 = v80;
        operator delete(v82);
      }
      if (v119 != v122) {
        free(v119);
      }
    }
    if (v76)
    {
LABEL_145:
      if (*((_DWORD *)*this + 9)) {
        uint64_t v85 = (uint64_t)(*this - 2);
      }
      else {
        uint64_t v85 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v85, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6((uint64_t)*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    unint64_t v108 = (void **)"requires attribute 'dtype'";
    __int16 v110 = 259;
    mlir::OpState::emitOpError((uint64_t *)this, &v108, (uint64_t)&v117);
    uint64_t v41 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v117);
    if (v117) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v117);
    }
    if (v127)
    {
      uint64_t v42 = __p;
      if (__p)
      {
        __int16 v43 = v126;
        uint64_t v44 = __p;
        if (v126 != __p)
        {
          do
            __int16 v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
          while (v43 != v42);
          uint64_t v44 = __p;
        }
        int64_t v126 = v42;
        operator delete(v44);
      }
      uint64_t v45 = v123;
      if (v123)
      {
        int v46 = v124;
        unsigned int v47 = v123;
        if (v124 != v123)
        {
          do
          {
            uint64_t v49 = *--v46;
            uint64_t v48 = v49;
            void *v46 = 0;
            if (v49) {
              MEMORY[0x21667D390](v48, 0x1000C8077774924);
            }
          }
          while (v46 != v45);
          unsigned int v47 = v123;
        }
        int64_t v124 = v45;
        operator delete(v47);
      }
      if (v119 != v122) {
        free(v119);
      }
    }
  }
  return v41;
}

void mlir::mps::QuantizeOp::getCanonicalizationPatterns()
{
  mlir::PatternBenefit::PatternBenefit(&v0, 1);
  operator new();
}

uint64_t mlir::mps::RandomNormalOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v92 = *MEMORY[0x263EF8340];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v78 = v6;
  if (!v6)
  {
    a3(v82, a4);
    if (v82[0])
    {
      LODWORD(v79) = 3;
      unint64_t v80 = "expected DictionaryAttr to set properties";
      uint64_t v81 = 41;
      unint64_t v26 = &v79;
      long long v27 = (char *)v83;
      if (v84 >= v85)
      {
        unint64_t v66 = v84 + 1;
        if (v83 <= &v79 && (char *)v83 + 24 * v84 > (char *)&v79)
        {
          int64_t v72 = (char *)&v79 - (unsigned char *)v83;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v83, v86, v66, 24);
          long long v27 = (char *)v83;
          unint64_t v26 = (uint64_t *)((char *)v83 + v72);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v83, v86, v66, 24);
          unint64_t v26 = &v79;
          long long v27 = (char *)v83;
        }
      }
      uint64_t v28 = &v27[24 * v84];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)uint64_t v28 = v29;
      ++v84;
      if (v82[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v82);
      }
    }
    if (!v91) {
      return 0;
    }
    uint64_t v30 = __p;
    if (__p)
    {
      long long v31 = v90;
      char v32 = __p;
      if (v90 != __p)
      {
        do
          long long v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        char v32 = __p;
      }
      unint64_t v90 = v30;
      operator delete(v32);
    }
    unint64_t v21 = v87;
    if (!v87) {
      goto LABEL_80;
    }
    unint64_t v33 = v88;
    uint64_t v23 = v87;
    if (v88 == v87)
    {
LABEL_79:
      unint64_t v88 = v21;
      operator delete(v23);
LABEL_80:
      if (v83 != v86) {
        free(v83);
      }
      return 0;
    }
    do
    {
      uint64_t v35 = *--v33;
      uint64_t v34 = v35;
      *unint64_t v33 = 0;
      if (v35) {
        MEMORY[0x21667D390](v34, 0x1000C8077774924);
      }
    }
    while (v33 != v21);
LABEL_78:
    uint64_t v23 = v87;
    goto LABEL_79;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v78, "mean", 4uLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
    {
      a3(v82, a4);
      if (v82[0])
      {
        LODWORD(v79) = 3;
        uint64_t v81 = 49;
        uint64_t v10 = &v79;
        uint64_t v11 = (char *)v83;
        if (v84 >= v85)
        {
          unint64_t v67 = v84 + 1;
          if (v83 <= &v79 && (char *)v83 + 24 * v84 > (char *)&v79)
          {
            int64_t v73 = (char *)&v79 - (unsigned char *)v83;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v83, v86, v67, 24);
            uint64_t v11 = (char *)v83;
            uint64_t v10 = (uint64_t *)((char *)v83 + v73);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v83, v86, v67, 24);
            uint64_t v10 = &v79;
            uint64_t v11 = (char *)v83;
          }
        }
        uint64_t v12 = &v11[24 * v84];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = v10[2];
        *(_OWORD *)uint64_t v12 = v13;
        ++v84;
        if (v82[0])
        {
          long long v14 = &v79;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v79, v9);
          uint64_t v15 = (char *)v83;
          if (v84 >= v85)
          {
            unint64_t v68 = v84 + 1;
            if (v83 <= &v79 && (char *)v83 + 24 * v84 > (char *)&v79)
            {
              int64_t v74 = (char *)&v79 - (unsigned char *)v83;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v83, v86, v68, 24);
              uint64_t v15 = (char *)v83;
              long long v14 = (uint64_t *)((char *)v83 + v74);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v83, v86, v68, 24);
              long long v14 = &v79;
              uint64_t v15 = (char *)v83;
            }
          }
          int v16 = &v15[24 * v84];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = v14[2];
          *(_OWORD *)int v16 = v17;
          ++v84;
          if (v82[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v82);
          }
        }
      }
      if (!v91) {
        return 0;
      }
      uint64_t v18 = __p;
      if (__p)
      {
        uint64_t v19 = v90;
        uint64_t v20 = __p;
        if (v90 != __p)
        {
          do
            uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          uint64_t v20 = __p;
        }
        unint64_t v90 = v18;
        operator delete(v20);
      }
      unint64_t v21 = v87;
      if (!v87) {
        goto LABEL_80;
      }
      long long v22 = v88;
      uint64_t v23 = v87;
      if (v88 == v87) {
        goto LABEL_79;
      }
      do
      {
        uint64_t v25 = *--v22;
        uint64_t v24 = v25;
        void *v22 = 0;
        if (v25) {
          MEMORY[0x21667D390](v24, 0x1000C8077774924);
        }
      }
      while (v22 != v21);
      goto LABEL_78;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v78, "result_element_type", 0x13uLL);
  if (!v36)
  {
    a3(v82, a4);
    if (v82[0])
    {
      LODWORD(v79) = 3;
      unint64_t v80 = "expected key entry for result_element_type in DictionaryAttr to set Properties.";
      uint64_t v81 = 79;
      uint64_t v52 = &v79;
      uint64_t v53 = (char *)v83;
      if (v84 >= v85)
      {
        unint64_t v70 = v84 + 1;
        if (v83 <= &v79 && (char *)v83 + 24 * v84 > (char *)&v79)
        {
          int64_t v76 = (char *)&v79 - (unsigned char *)v83;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v83, v86, v70, 24);
          uint64_t v53 = (char *)v83;
          uint64_t v52 = (uint64_t *)((char *)v83 + v76);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v83, v86, v70, 24);
          uint64_t v52 = &v79;
          uint64_t v53 = (char *)v83;
        }
      }
      uint64_t v54 = &v53[24 * v84];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = v52[2];
      *(_OWORD *)uint64_t v54 = v55;
      ++v84;
      if (v82[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v82);
      }
    }
    if (!v91) {
      return 0;
    }
    uint64_t v56 = __p;
    if (__p)
    {
      uint64_t v57 = v90;
      unint64_t v58 = __p;
      if (v90 != __p)
      {
        do
          uint64_t v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        unint64_t v58 = __p;
      }
      unint64_t v90 = v56;
      operator delete(v58);
    }
    unint64_t v21 = v87;
    if (!v87) {
      goto LABEL_80;
    }
    unint64_t v59 = v88;
    uint64_t v23 = v87;
    if (v88 == v87) {
      goto LABEL_79;
    }
    do
    {
      uint64_t v61 = *--v59;
      uint64_t v60 = v61;
      *unint64_t v59 = 0;
      if (v61) {
        MEMORY[0x21667D390](v60, 0x1000C8077774924);
      }
    }
    while (v59 != v21);
    goto LABEL_78;
  }
  uint64_t v37 = v36;
  if (*(_UNKNOWN **)(*(void *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
  {
    a3(v82, a4);
    if (v82[0])
    {
      LODWORD(v79) = 3;
      uint64_t v81 = 64;
      uint64_t v38 = &v79;
      uint64_t v39 = (char *)v83;
      if (v84 >= v85)
      {
        unint64_t v69 = v84 + 1;
        if (v83 <= &v79 && (char *)v83 + 24 * v84 > (char *)&v79)
        {
          int64_t v75 = (char *)&v79 - (unsigned char *)v83;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v83, v86, v69, 24);
          uint64_t v39 = (char *)v83;
          uint64_t v38 = (uint64_t *)((char *)v83 + v75);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v83, v86, v69, 24);
          uint64_t v38 = &v79;
          uint64_t v39 = (char *)v83;
        }
      }
      uint64_t v40 = &v39[24 * v84];
      long long v41 = *(_OWORD *)v38;
      *((void *)v40 + 2) = v38[2];
      *(_OWORD *)uint64_t v40 = v41;
      ++v84;
      if (v82[0])
      {
        uint64_t v42 = &v79;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v79, v37);
        __int16 v43 = (char *)v83;
        if (v84 >= v85)
        {
          unint64_t v71 = v84 + 1;
          if (v83 <= &v79 && (char *)v83 + 24 * v84 > (char *)&v79)
          {
            int64_t v77 = (char *)&v79 - (unsigned char *)v83;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v83, v86, v71, 24);
            __int16 v43 = (char *)v83;
            uint64_t v42 = (uint64_t *)((char *)v83 + v77);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v83, v86, v71, 24);
            uint64_t v42 = &v79;
            __int16 v43 = (char *)v83;
          }
        }
        uint64_t v44 = &v43[24 * v84];
        long long v45 = *(_OWORD *)v42;
        *((void *)v44 + 2) = v42[2];
        *(_OWORD *)uint64_t v44 = v45;
        ++v84;
        if (v82[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v82);
        }
      }
    }
    if (!v91) {
      return 0;
    }
    int v46 = __p;
    if (__p)
    {
      unsigned int v47 = v90;
      uint64_t v48 = __p;
      if (v90 != __p)
      {
        do
          unsigned int v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        uint64_t v48 = __p;
      }
      unint64_t v90 = v46;
      operator delete(v48);
    }
    unint64_t v21 = v87;
    if (!v87) {
      goto LABEL_80;
    }
    uint64_t v49 = v88;
    uint64_t v23 = v87;
    if (v88 == v87) {
      goto LABEL_79;
    }
    do
    {
      uint64_t v51 = *--v49;
      uint64_t v50 = v51;
      *uint64_t v49 = 0;
      if (v51) {
        MEMORY[0x21667D390](v50, 0x1000C8077774924);
      }
    }
    while (v49 != v21);
    goto LABEL_78;
  }
  a1[1] = v36;
  uint64_t v63 = mlir::DictionaryAttr::get((uint64_t)&v78, "sampling_method", 0xFuLL);
  uint64_t v79 = v63;
  if (!v63)
  {
LABEL_88:
    uint64_t v65 = mlir::DictionaryAttr::get((uint64_t)&v78, "std_dev", 7uLL);
    uint64_t v79 = v65;
    if (v65)
    {
      if (*(_UNKNOWN **)(*(void *)v65 + 136) != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
      {
        a3(v82, a4);
        goto LABEL_91;
      }
      a1[3] = v65;
    }
    return 1;
  }
  if (*(_UNKNOWN **)(*(void *)v63 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id)
  {
    a1[2] = v63;
    goto LABEL_88;
  }
  a3(v82, a4);
LABEL_91:
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v64, &v79);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v82);
  return 0;
}

uint64_t mlir::mps::RandomNormalOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v33[6] = *MEMORY[0x263EF8340];
  uint64_t v30 = a1;
  long long v31 = v33;
  uint64_t v32 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v30, (uint64_t)"mean", 4, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v32;
  if (v32 >= HIDWORD(v32))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v31, v33, v32 + 1, 16);
    unsigned int v6 = v32;
  }
  uint64_t v7 = (uint64_t *)((char *)v31 + 16 * v6);
  uint64_t *v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v32 + 1;
  LODWORD(v32) = v32 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v30, (uint64_t)"result_element_type", 19, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v32;
    if (v32 >= HIDWORD(v32))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v31, v33, v32 + 1, 16);
      unsigned int v13 = v32;
    }
    long long v14 = (uint64_t *)((char *)v31 + 16 * v13);
    *long long v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v32 + 1;
    LODWORD(v32) = v32 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v30, (uint64_t)"sampling_method", 15, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v32;
    if (v32 >= HIDWORD(v32))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v31, v33, v32 + 1, 16);
      unsigned int v19 = v32;
    }
    uint64_t v20 = (uint64_t *)((char *)v31 + 16 * v19);
    uint64_t *v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v32 + 1;
    LODWORD(v32) = v32 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v30, (uint64_t)"std_dev", 7, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v32;
    if (v32 >= HIDWORD(v32))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v31, v33, v32 + 1, 16);
      unsigned int v25 = v32;
    }
    unint64_t v26 = (uint64_t *)((char *)v31 + 16 * v25);
    uint64_t *v26 = v22;
    v26[1] = v24;
    unsigned int v8 = v32 + 1;
    LODWORD(v32) = v32 + 1;
  }
  long long v27 = v31;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v31 == v33) {
      return DictionaryAttr;
    }
    goto LABEL_20;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v30, (uint64_t *)v31, v8);
  long long v27 = v31;
  if (v31 != v33) {
LABEL_20:
  }
    free(v27);
  return DictionaryAttr;
}

uint64_t mlir::mps::RandomNormalOp::getInherentAttr(int a1, void *a2, _DWORD *__s1, size_t __n)
{
  switch(__n)
  {
    case 4uLL:
      if (*__s1 != 1851876717) {
        return 0;
      }
      return *a2;
    case 5uLL:
    case 6uLL:
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xBuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0x10uLL:
    case 0x11uLL:
    case 0x12uLL:
      return 0;
    case 7uLL:
      if (memcmp(__s1, "std_dev", __n)) {
        return 0;
      }
      return a2[3];
    case 0xFuLL:
      if (memcmp(__s1, "sampling_method", __n)) {
        return 0;
      }
      return a2[2];
    case 0x13uLL:
      if (memcmp(__s1, "result_element_type", __n)) {
        return 0;
      }
      return a2[1];
    default:
      return 0;
  }
}

uint64_t mlir::mps::RandomNormalOp::setInherentAttr(uint64_t result, _DWORD *__s1, size_t a3, uint64_t a4)
{
  uint64_t v5 = (void *)result;
  switch(a3)
  {
    case 4uLL:
      if (*__s1 == 1851876717)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          *(void *)uint64_t result = v9;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      break;
    case 7uLL:
      uint64_t result = memcmp(__s1, "std_dev", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id) {
            uint64_t v6 = a4;
          }
          else {
            uint64_t v6 = 0;
          }
          v5[3] = v6;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0xFuLL:
      uint64_t result = memcmp(__s1, "sampling_method", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id) {
            uint64_t v7 = a4;
          }
          else {
            uint64_t v7 = 0;
          }
          v5[2] = v7;
        }
        else
        {
          v5[2] = 0;
        }
      }
      break;
    case 0x13uLL:
      uint64_t result = memcmp(__s1, "result_element_type", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v5[1] = v8;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::RandomNormalOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = (void **)mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(v8, (void **)"mean", (const char *)4, a3, a4))
  {
    uint64_t v9 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v9, (void **)"result_element_type", (const char *)0x13, a3, a4))
    {
      uint64_t v10 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps38(v10, (void **)"sampling_method", (const char *)0xF, a3, a4))
      {
        uint64_t v11 = (void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(v11, (void **)"std_dev", (const char *)7, a3, a4))
        {
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps38(uint64_t a1, void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  if (!a1
    || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    uint64_t v7 = &v29;
    uint64_t v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v8 = (char *)v35;
        uint64_t v7 = (void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        uint64_t v7 = &v29;
        uint64_t v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      long long v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: valid NormalSamplingMethod";
        uint64_t v31 = 58;
        uint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            uint64_t v11 = (void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        unsigned int v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)unsigned int v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = __p;
    if (__p)
    {
      uint64_t v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          uint64_t v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      uint64_t v42 = v16;
      operator delete(v18);
    }
    unsigned int v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      uint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = *--v20;
          uint64_t v22 = v23;
          void *v20 = 0;
          if (v23) {
            MEMORY[0x21667D390](v22, 0x1000C8077774924);
          }
        }
        while (v20 != v19);
        uint64_t v21 = v39;
      }
      uint64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::RandomNormalOpGenericAdaptorBase::Properties>(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 256);
  if (!result) {
    operator new();
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::NormalSamplingMethodAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  uint64_t v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    uint64_t v6 = &v40;
    uint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v7 = (char *)v46;
        uint64_t v6 = (void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        uint64_t v6 = &v40;
        uint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  uint64_t v40 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::NormalSamplingMethodAttr]";
  unint64_t v41 = 85;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    uint64_t v40 = (void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      long long v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          long long v14 = (void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          long long v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unsigned int v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unsigned int v19 = (char *)v46;
            uint64_t v18 = (void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unsigned int v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = __p;
    if (__p)
    {
      uint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      uint64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = *--v27;
          uint64_t v29 = v30;
          void *v27 = 0;
          if (v30) {
            MEMORY[0x21667D390](v29, 0x1000C8077774924);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      uint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}