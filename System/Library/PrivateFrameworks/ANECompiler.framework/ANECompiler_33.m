uint64_t mlir::RegisteredOperationName::Model<mlir::mps::NotOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::NotOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::NotOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    v10 = __p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::NotOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::NotOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::NotOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::NotOp>>(uint64_t a1)
{
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::NotOp>::getEffects;
  v3 = &unk_267771000;
  {
    v12 = v2;
    v3 = (void *)&unk_267771000;
    v2 = v12;
    if (v4)
    {
      v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      v3 = (void *)&unk_267771000;
      v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::NotOp>>(uint64_t a1)
{
  v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::NotOp>::isCompatibleReturnTypes;
  v3 = &unk_267771000;
  {
    v12 = v2;
    v3 = (void *)&unk_267771000;
    v2 = v12;
    if (v4)
    {
      v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      v3 = (void *)&unk_267771000;
      v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::NotOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::NotOp>>(uint64_t a1)
{
  v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::NotOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::NotOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::NotOp>::isCompatibleReturnTypes;
  v3 = &unk_267771000;
  {
    v12 = v2;
    v3 = (void *)&unk_267771000;
    v2 = v12;
    if (v4)
    {
      v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      v3 = (void *)&unk_267771000;
      v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::NotOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::NotOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::NotOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::NotOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::NotOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  v24 = "mps.not";
  uint64_t v25 = 7;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::NotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::NotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::NotOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::NotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::NotOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::NotOpGenericAdaptorBase::NotOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::NotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::NotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::NotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ACosOp>,mlir::OpTrait::OneResult<mlir::mps::ACosOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ACosOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ACosOp>,mlir::OpTrait::OneOperand<mlir::mps::ACosOp>,mlir::OpTrait::OpInvariants<mlir::mps::ACosOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ACosOp>,mlir::OpTrait::Stitchable<mlir::mps::ACosOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ACosOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ACosOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::NotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.one_hot", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::OneHotOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36E620;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 17
    && (*(void *)a3 == 0x6C45746C75736572 ? (BOOL v7 = *(void *)(a3 + 8) == 0x707954746E656D65) : (BOOL v7 = 0),
        v7 ? (BOOL v8 = *(unsigned char *)(a3 + 16) == 101) : (BOOL v8 = 0),
        v8))
  {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v11);
  if (v7 == 17)
  {
    BOOL v8 = *(void *)result == 0x6C45746C75736572 && *(void *)(result + 8) == 0x707954746E656D65;
    if (v8 && *(unsigned char *)(result + 16) == 101)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id) {
          uint64_t v10 = a4;
        }
        else {
          uint64_t v10 = 0;
        }
        *uint64_t v5 = v10;
      }
      else
      {
        *uint64_t v5 = 0;
      }
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"resultElementType", 17, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v7, (void **)"resultElementType", (const char *)0x11, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::CastOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::CastOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::OneHotOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::OneHotOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::TypeAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 16))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, void *a4, uint64_t a5, uint64_t a6, unint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::OneHotOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, void *a4, uint64_t a5, uint64_t a6, unint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::OneHotOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::OneHotOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, void *a4, uint64_t a5, uint64_t a6, unint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  uint64_t v27 = *MEMORY[0x263EF8340];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::OneHotOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.one_hot";
    v25[1] = 11;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::OneHotOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::OneHotOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::OneHotOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  unint64_t v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  uint64_t v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.one_hot", 11, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)3)) {
    return 0;
  }
  unint64_t v6 = a1;
  if (!mlir::mps::OneHotOp::verifyInvariantsImpl((mlir::mps::OneHotOp *)&v6)) {
    return 0;
  }
  unint64_t v6 = a1;
  return mlir::mps::OneHotOp::verify((mlir::mps::OneHotOp *)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::OneHotOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::OrOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::OrOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::OrOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::OrOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.or", 6, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::OrOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36B740;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OrOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::OrOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OrOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::OrOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::OrOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::OrOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OrOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OrOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OrOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OrOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::OrOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OrOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OrOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OrOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      unint64_t v11 = v32;
      uint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          unint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OrOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OrOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::OrOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::OrOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::OrOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::OrOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::OrOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::OrOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::OrOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::OrOp>::inferReturnTypes(mlir::Float32Type *a1, uint64_t a2, uint64_t a3, mlir::MLIRContext *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::OrOp>::refineReturnTypes(mlir::Float32Type *a1, uint64_t a2, char a3, mlir::MLIRContext *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::OrOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::OrOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::OrOp>::refineReturnTypes(mlir::Float32Type *a1, uint64_t a2, char a3, mlir::MLIRContext *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.or";
    v25[1] = 6;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::OrOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::OrOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::OrOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::OrOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::OrOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  mlir::mps::detail::OrOpGenericAdaptorBase::OrOpGenericAdaptorBase((uint64_t)v15, this);
  uint64_t v16 = a2;
  uint64_t v17 = a3;
  v14[0] = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v14[1] = v8;
  if (v14[0] && (unint64_t v9 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v14, v16, v17), v9 >= 8))
  {
    unint64_t v10 = v9;
    if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    {
      uint64_t v11 = *(unsigned int *)(a4 + 8);
      if (v11 >= *(_DWORD *)(a4 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
        LODWORD(v11) = *(_DWORD *)(a4 + 8);
      }
      *(void *)(*(void *)a4 + 8 * v11) = v10;
      ++*(_DWORD *)(a4 + 8);
      return 1;
    }
    uint64_t v12 = 1;
    if (*(_DWORD *)(a4 + 8)) {
      return v12;
    }
  }
  else
  {
    uint64_t v12 = 0;
    if (*(_DWORD *)(a4 + 8)) {
      return v12;
    }
  }
  if (mlir::OpTrait::impl::foldCommutative((uint64_t)this, a2, a3)) {
    return 1;
  }
  return v12;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ATan2Op>,mlir::OpTrait::OneResult<mlir::mps::ATan2Op>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ATan2Op>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ATan2Op>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::ATan2Op>,mlir::OpTrait::OpInvariants<mlir::mps::ATan2Op>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ATan2Op>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ATan2Op>,mlir::OpTrait::ResultsBroadcastableShape<mlir::mps::ATan2Op>,mlir::OpTrait::Stitchable<mlir::mps::ATan2Op>,mlir::InferTypeOpInterface::Trait<mlir::mps::ATan2Op>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ATan2Op>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::OrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::PReluOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PReluOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PReluOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PReluOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.prelu", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PReluOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36D9A0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PReluOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PReluOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PReluOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PReluOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PReluOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PReluOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PReluOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PReluOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PReluOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PReluOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::PReluOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PReluOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PReluOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PReluOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      uint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PReluOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PReluOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PReluOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PReluOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PReluOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PReluOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PReluOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PReluOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PReluOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PReluOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  if (a5)
  {
    unint64_t v11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    uint64_t v12 = *(unsigned int *)(a11 + 8);
    if (v12 >= *(_DWORD *)(a11 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v12 + 1, 8);
      LODWORD(v12) = *(_DWORD *)(a11 + 8);
    }
    *(void *)(*(void *)a11 + 8 * v12) = v11;
    ++*(_DWORD *)(a11 + 8);
    return 1;
  }
  else
  {
    return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands");
  }
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PReluOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PReluOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PReluOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PReluOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  int v21 = v23;
  uint64_t v22 = 0x400000000;
  unsigned int v26 = a4;
  uint64_t v27 = a5;
  if (a5)
  {
    *((void *)v21 + v22) = *(void *)(mlir::ValueRange::dereference_iterator(&v26, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    unsigned int v13 = v22 + 1;
    LODWORD(v22) = v22 + 1;
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands"))
    {
      uint64_t v16 = 0;
      uint64_t v17 = v21;
      if (v21 == v23) {
        return v16;
      }
      goto LABEL_17;
    }
    unsigned int v13 = v22;
  }
  mlir::ValueRange::ValueRange(v20, (uint64_t)v21, v13);
  mlir::ValueRange::ValueRange(v19, *(void *)a11, *(unsigned int *)(a11 + 8));
  v24[0] = &unk_26C380E60;
  uint64_t v25 = v24;
  v28 = &v26;
  unsigned int v26 = (const char *)&unk_26C380E60;
  if (v28 == &v26)
  {
    (*((void (**)(const char **))v26 + 4))(&v26);
    uint64_t v15 = v25;
    if (v25 != v24) {
      goto LABEL_9;
    }
LABEL_15:
    (*(void (**)(void *))(v24[0] + 32))(v24);
    if (v14) {
      goto LABEL_12;
    }
    goto LABEL_16;
  }
  if (v28) {
    (*((void (**)(const char **))*v28 + 5))(v28);
  }
  uint64_t v15 = v25;
  if (v25 == v24) {
    goto LABEL_15;
  }
LABEL_9:
  if (v15) {
    (*(void (**)(void *))(*v15 + 40))(v15);
  }
  if (v14)
  {
LABEL_12:
    uint64_t v16 = 1;
    uint64_t v17 = v21;
    if (v21 == v23) {
      return v16;
    }
    goto LABEL_17;
  }
LABEL_16:
  unsigned int v26 = "mps.prelu";
  uint64_t v27 = 9;
  uint64_t v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v26, "' op inferred type(s) ", (uint64_t)&v21, " are incompatible with return type(s) of operation ", a11);
  uint64_t v17 = v21;
  if (v21 != v23) {
LABEL_17:
  }
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PReluOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PReluOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unsigned int v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PReluOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PReluOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PReluOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::PReluOpGenericAdaptorBase::PReluOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2))
  {
    return 0;
  }
  unint64_t v6 = a1;
  return mlir::mps::FloorDivideOp::verifyInvariantsImpl((mlir::mps::FloorDivideOp *)&v6);
}

BOOL mlir::Op<mlir::mps::PReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.pad_gradient", 16, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PadGradientOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C366790;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 11
    && (*a3 == 0x4D676E6964646170 ? (BOOL v7 = *(void *)((char *)a3 + 3) == 0x65646F4D676E6964) : (BOOL v7 = 0), v7))
  {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else
  {
    return 0;
  }
}

void *mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 11 && *result == 0x4D676E6964646170 && *(void *)((char *)result + 3) == 0x65646F4D676E6964)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      *uint64_t v5 = v9;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"paddingMode", 11, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps33(v7, (void **)"paddingMode", (const char *)0xB, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::PadGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::PadGradientOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::PadGradientOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::PadGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingModeAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 16))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::PadGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PadGradientOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PadGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v22 = v24;
  uint64_t v23 = 0x400000000;
  if (mlir::mps::PadGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, v18, v19, (uint64_t)&v22))
  {
    mlir::ValueRange::ValueRange(v21, (uint64_t)v22, v23);
    mlir::ValueRange::ValueRange(v20, *(void *)a11, *(unsigned int *)(a11 + 8));
    v25[0] = &unk_26C380E60;
    unsigned int v26 = v25;
    v28 = v27;
    v27[0] = &unk_26C380E60;
    if (v28 == v27)
    {
      (*(void (**)(void *))(v27[0] + 32))(v27);
      unint64_t v14 = v26;
      if (v26 != v25) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v28) {
        (*(void (**)(void *))(*v28 + 40))(v28);
      }
      unint64_t v14 = v26;
      if (v26 != v25)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v22;
          if (v22 == v24) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v25[0] + 32))(v25);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v27[0] = "mps.pad_gradient";
    v27[1] = 16;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v27, "' op inferred type(s) ", (uint64_t)&v22, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v22;
    if (v22 == v24) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v22;
  if (v22 != v24) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PadGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PadGradientOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PadGradientOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  unint64_t v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  uint64_t v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.pad_gradient", 16, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)3))
  {
    return 0;
  }
  unint64_t v6 = a1;
  return mlir::mps::PadGradientOp::verifyInvariantsImpl((mlir::mps::PadGradientOp *)&v6);
}

BOOL mlir::Op<mlir::mps::PadGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PadOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PadOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PadOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PadOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.pad", 7, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PadOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36BE48;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 11
    && (*a3 == 0x4D676E6964646170 ? (BOOL v7 = *(void *)((char *)a3 + 3) == 0x65646F4D676E6964) : (BOOL v7 = 0), v7))
  {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else
  {
    return 0;
  }
}

void *mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 11 && *result == 0x4D676E6964646170 && *(void *)((char *)result + 3) == 0x65646F4D676E6964)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      *uint64_t v5 = v9;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"paddingMode", 11, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps33(v7, (void **)"paddingMode", (const char *)0xB, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::PadGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::PadGradientOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::PadOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PadOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PadOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PadOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PadOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::PadOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingModeAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PadOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 16))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PadOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PadOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PadOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PadOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PadOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PadOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PadOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::PadOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PadOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PadOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PadOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PadOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::PadOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.pad";
    v25[1] = 7;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PadOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PadOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PadOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PadOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PadOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  unint64_t v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  uint64_t v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.pad", 7, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)3)) {
    return 0;
  }
  unint64_t v6 = a1;
  if (!mlir::mps::PadOp::verifyInvariantsImpl((mlir::mps::PadOp *)&v6)) {
    return 0;
  }
  unint64_t v6 = a1;
  return mlir::mps::PadOp::verify((mlir::mps::PadOp *)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::PadOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::PermuteOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PermuteOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PermuteOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PermuteOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.permute", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36EF80;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PermuteOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PermuteOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PermuteOp>::foldHook(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                      + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PermuteOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PermuteOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PermuteOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PermuteOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PermuteOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PermuteOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PermuteOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::PermuteOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PermuteOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PermuteOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PermuteOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      unint64_t v11 = v32;
      uint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          unint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PermuteOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PermuteOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PermuteOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PermuteOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PermuteOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PermuteOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PermuteOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PermuteOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PermuteOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PermuteOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::PermuteOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PermuteOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PermuteOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PermuteOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PermuteOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v22 = v24;
  uint64_t v23 = 0x400000000;
  if (mlir::mps::PermuteOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, v18, v19, (uint64_t)&v22))
  {
    mlir::ValueRange::ValueRange(v21, (uint64_t)v22, v23);
    mlir::ValueRange::ValueRange(v20, *(void *)a11, *(unsigned int *)(a11 + 8));
    v25[0] = &unk_26C380E60;
    unsigned int v26 = v25;
    v28 = v27;
    v27[0] = &unk_26C380E60;
    if (v28 == v27)
    {
      (*(void (**)(void *))(v27[0] + 32))(v27);
      unint64_t v14 = v26;
      if (v26 != v25) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v28) {
        (*(void (**)(void *))(*v28 + 40))(v28);
      }
      unint64_t v14 = v26;
      if (v26 != v25)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v22;
          if (v22 == v24) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v25[0] + 32))(v25);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v27[0] = "mps.permute";
    v27[1] = 11;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v27, "' op inferred type(s) ", (uint64_t)&v22, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v22;
    if (v22 == v24) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v22;
  if (v22 != v24) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PermuteOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PermuteOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PermuteOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PermuteOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PermuteOp>(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::PermuteOpGenericAdaptorBase::PermuteOpGenericAdaptorBase((uint64_t)v14, a1);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)a1);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if (a1 - 4 != (unsigned int *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)) {
    return 0;
  }
  unint64_t v6 = a1;
  if (!mlir::mps::BroadcastToOp::verifyInvariantsImpl((mlir::mps::BroadcastToOp *)&v6)) {
    return 0;
  }
  unint64_t v6 = a1;
  return mlir::mps::PermuteOp::verify((mlir::mps::PermuteOp *)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::PermuteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PlaceholderOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    unint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PlaceholderOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    unint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PlaceholderOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PlaceholderOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PlaceholderOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        unint64_t v5 = v7;
      }
      else {
        unint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PlaceholderOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PlaceholderOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PlaceholderOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PlaceholderOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PlaceholderOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::PlaceholderOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PlaceholderOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PlaceholderOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PlaceholderOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PlaceholderOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PlaceholderOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PlaceholderOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PlaceholderOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PlaceholderOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<mlir::mps::PlaceholderOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::foldSingleResultHook<mlir::mps::PlaceholderOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::PlaceholderOpGenericAdaptorBase::PlaceholderOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v105 = a1;
    v1 = (void *)&unk_267771000;
    int v22 = v21;
    a1 = v105;
    if (v22)
    {
      v112 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v113 = 83;
      unint64_t v23 = llvm::StringRef::find((uint64_t *)&v112, "DesiredTypeName = ", 0x12uLL, 0);
      if (v113 >= v23) {
        unint64_t v24 = v23;
      }
      else {
        unint64_t v24 = v113;
      }
      uint64_t v25 = &v112[v24];
      unint64_t v26 = v113 - v24;
      if (v113 - v24 >= 0x12) {
        uint64_t v27 = 18;
      }
      else {
        uint64_t v27 = v113 - v24;
      }
      unint64_t v28 = v26 - v27;
      if (v28 >= v28 - 1) {
        uint64_t v29 = v28 - 1;
      }
      else {
        uint64_t v29 = v28;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v25[v27], v29);
      v1 = (void *)&unk_267771000;
      a1 = v105;
    }
  }
  uint64_t v2 = v1[23];
  char v3 = &unk_267771000;
  {
    uint64_t v106 = a1;
    uint64_t v99 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v99;
    int v31 = v30;
    a1 = v106;
    if (v31)
    {
      v112 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v113 = 81;
      unint64_t v32 = llvm::StringRef::find((uint64_t *)&v112, "DesiredTypeName = ", 0x12uLL, 0);
      if (v113 >= v32) {
        unint64_t v33 = v32;
      }
      else {
        unint64_t v33 = v113;
      }
      uint64_t v34 = &v112[v33];
      unint64_t v35 = v113 - v33;
      if (v113 - v33 >= 0x12) {
        uint64_t v36 = 18;
      }
      else {
        uint64_t v36 = v113 - v33;
      }
      unint64_t v37 = v35 - v36;
      if (v37 >= v37 - 1) {
        uint64_t v38 = v37 - 1;
      }
      else {
        uint64_t v38 = v37;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v34[v36], v38);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v99;
      a1 = v106;
    }
  }
  uint64_t v4 = v3[25];
  unint64_t v5 = &unk_267771000;
  {
    uint64_t v107 = a1;
    uint64_t v94 = v4;
    uint64_t v100 = v2;
    unint64_t v5 = (void *)&unk_267771000;
    uint64_t v4 = v94;
    uint64_t v2 = v100;
    int v40 = v39;
    a1 = v107;
    if (v40)
    {
      v112 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<Empty>]";
      unint64_t v113 = 110;
      unint64_t v41 = llvm::StringRef::find((uint64_t *)&v112, "DesiredTypeName = ", 0x12uLL, 0);
      if (v113 >= v41) {
        unint64_t v42 = v41;
      }
      else {
        unint64_t v42 = v113;
      }
      v43 = &v112[v42];
      unint64_t v44 = v113 - v42;
      if (v113 - v42 >= 0x12) {
        uint64_t v45 = 18;
      }
      else {
        uint64_t v45 = v113 - v42;
      }
      unint64_t v46 = v44 - v45;
      if (v46 >= v46 - 1) {
        uint64_t v47 = v46 - 1;
      }
      else {
        uint64_t v47 = v46;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v43[v45], v47);
      unint64_t v5 = (void *)&unk_267771000;
      uint64_t v4 = v94;
      uint64_t v2 = v100;
      a1 = v107;
    }
  }
  uint64_t v6 = v5[431];
  uint64_t v7 = &unk_267770000;
  {
    uint64_t v108 = a1;
    uint64_t v95 = v4;
    uint64_t v101 = v2;
    uint64_t v90 = v6;
    uint64_t v7 = (void *)&unk_267770000;
    uint64_t v6 = v90;
    uint64_t v4 = v95;
    uint64_t v2 = v101;
    int v49 = v48;
    a1 = v108;
    if (v49)
    {
      v112 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v113 = 86;
      unint64_t v50 = llvm::StringRef::find((uint64_t *)&v112, "DesiredTypeName = ", 0x12uLL, 0);
      if (v113 >= v50) {
        unint64_t v51 = v50;
      }
      else {
        unint64_t v51 = v113;
      }
      v52 = &v112[v51];
      unint64_t v53 = v113 - v51;
      if (v113 - v51 >= 0x12) {
        uint64_t v54 = 18;
      }
      else {
        uint64_t v54 = v113 - v51;
      }
      unint64_t v55 = v53 - v54;
      if (v55 >= v55 - 1) {
        uint64_t v56 = v55 - 1;
      }
      else {
        uint64_t v56 = v55;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      uint64_t v7 = (void *)&unk_267770000;
      uint64_t v6 = v90;
      uint64_t v4 = v95;
      uint64_t v2 = v101;
      a1 = v108;
    }
  }
  uint64_t v8 = v7[431];
  uint64_t v9 = &unk_267770000;
  {
    uint64_t v109 = a1;
    uint64_t v96 = v4;
    uint64_t v102 = v2;
    uint64_t v87 = v8;
    uint64_t v91 = v6;
    uint64_t v9 = (void *)&unk_267770000;
    uint64_t v8 = v87;
    uint64_t v6 = v91;
    uint64_t v4 = v96;
    uint64_t v2 = v102;
    int v58 = v57;
    a1 = v109;
    if (v58)
    {
      v112 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroOperands<Empty>]";
      unint64_t v113 = 84;
      unint64_t v59 = llvm::StringRef::find((uint64_t *)&v112, "DesiredTypeName = ", 0x12uLL, 0);
      if (v113 >= v59) {
        unint64_t v60 = v59;
      }
      else {
        unint64_t v60 = v113;
      }
      v61 = &v112[v60];
      unint64_t v62 = v113 - v60;
      if (v113 - v60 >= 0x12) {
        uint64_t v63 = 18;
      }
      else {
        uint64_t v63 = v113 - v60;
      }
      unint64_t v64 = v62 - v63;
      if (v64 >= v64 - 1) {
        uint64_t v65 = v64 - 1;
      }
      else {
        uint64_t v65 = v64;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      uint64_t v9 = (void *)&unk_267770000;
      uint64_t v8 = v87;
      uint64_t v6 = v91;
      uint64_t v4 = v96;
      uint64_t v2 = v102;
      a1 = v109;
    }
  }
  uint64_t v10 = v9[433];
  uint64_t v11 = &unk_267770000;
  {
    uint64_t v110 = a1;
    uint64_t v97 = v4;
    uint64_t v103 = v2;
    uint64_t v88 = v8;
    uint64_t v92 = v6;
    uint64_t v85 = v10;
    uint64_t v11 = (void *)&unk_267770000;
    uint64_t v10 = v85;
    uint64_t v8 = v88;
    uint64_t v6 = v92;
    uint64_t v4 = v97;
    uint64_t v2 = v103;
    int v67 = v66;
    a1 = v110;
    if (v67)
    {
      v112 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v113 = 84;
      unint64_t v68 = llvm::StringRef::find((uint64_t *)&v112, "DesiredTypeName = ", 0x12uLL, 0);
      if (v113 >= v68) {
        unint64_t v69 = v68;
      }
      else {
        unint64_t v69 = v113;
      }
      v70 = &v112[v69];
      unint64_t v71 = v113 - v69;
      if (v113 - v69 >= 0x12) {
        uint64_t v72 = 18;
      }
      else {
        uint64_t v72 = v113 - v69;
      }
      unint64_t v73 = v71 - v72;
      if (v73 >= v73 - 1) {
        uint64_t v74 = v73 - 1;
      }
      else {
        uint64_t v74 = v73;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      uint64_t v11 = (void *)&unk_267770000;
      uint64_t v10 = v85;
      uint64_t v8 = v88;
      uint64_t v6 = v92;
      uint64_t v4 = v97;
      uint64_t v2 = v103;
      a1 = v110;
    }
  }
  uint64_t v12 = v11[435];
  unint64_t v13 = &unk_267771000;
  {
    uint64_t v111 = a1;
    uint64_t v98 = v4;
    uint64_t v104 = v2;
    uint64_t v89 = v8;
    uint64_t v93 = v6;
    uint64_t v84 = v12;
    uint64_t v86 = v10;
    unint64_t v13 = (void *)&unk_267771000;
    uint64_t v12 = v84;
    uint64_t v10 = v86;
    uint64_t v8 = v89;
    uint64_t v6 = v93;
    uint64_t v4 = v98;
    uint64_t v2 = v104;
    int v76 = v75;
    a1 = v111;
    if (v76)
    {
      v112 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v113 = 93;
      unint64_t v77 = llvm::StringRef::find((uint64_t *)&v112, "DesiredTypeName = ", 0x12uLL, 0);
      if (v113 >= v77) {
        unint64_t v78 = v77;
      }
      else {
        unint64_t v78 = v113;
      }
      v79 = &v112[v78];
      unint64_t v80 = v113 - v78;
      if (v113 - v78 >= 0x12) {
        uint64_t v81 = 18;
      }
      else {
        uint64_t v81 = v113 - v78;
      }
      unint64_t v82 = v80 - v81;
      if (v82 >= v82 - 1) {
        uint64_t v83 = v82 - 1;
      }
      else {
        uint64_t v83 = v82;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      unint64_t v13 = (void *)&unk_267771000;
      uint64_t v12 = v84;
      uint64_t v10 = v86;
      uint64_t v8 = v89;
      uint64_t v6 = v93;
      uint64_t v4 = v98;
      uint64_t v2 = v104;
      a1 = v111;
    }
  }
  return v2 == a1 || v4 == a1 || v6 == a1 || v8 == a1 || v10 == a1 || v12 == a1 || v13[31] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::PlaceholderOp>,mlir::OpTrait::OneResult<mlir::mps::PlaceholderOp>,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::mps::PlaceholderOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::PlaceholderOp>,mlir::OpTrait::ZeroOperands<mlir::mps::PlaceholderOp>,mlir::OpTrait::OpInvariants<mlir::mps::PlaceholderOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::PlaceholderOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::PlaceholderOp>,mlir::OpTrait::OneResult<mlir::mps::PlaceholderOp>,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::mps::PlaceholderOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::PlaceholderOp>,mlir::OpTrait::ZeroOperands<mlir::mps::PlaceholderOp>,mlir::OpTrait::OpInvariants<mlir::mps::PlaceholderOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::PlaceholderOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyZeroOperands(a1, v5))
  {
    return 0;
  }
  if (*((_DWORD *)a1 + 9)) {
    uint64_t v6 = (uint64_t)a1 - 16;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
  return mlir::tensor::__mlir_ods_local_type_constraint_TensorOps0((uint64_t)a1, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0) != 0;
}

uint64_t mlir::Op<mlir::mps::PlaceholderOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgGradientOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.pooling_average_gradient", 28, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PoolAvgGradientOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C3691C0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, size_t a4)
{
  int Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::mps::PoolAvgGradientOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::PoolAvgGradientOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::mps::PoolAvgGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::PoolAvgGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::getOpPropertyByteSize()
{
  return 56;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  if (a4)
  {
    long long v4 = *a4;
    long long v5 = a4[1];
    long long v6 = a4[2];
    *(void *)(a3 + 48) = *((void *)a4 + 6);
    *(_OWORD *)(a3 + 16) = v5;
    *(_OWORD *)(a3 + 32) = v6;
    *(_OWORD *)a3 = v4;
  }
  else
  {
    *(void *)(a3 + 48) = 0;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return mlir::mps::PoolAvgGradientOp::populateDefaultProperties(a2, (void *)a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, void *a3)
{
  return mlir::mps::PoolAvgGradientOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::PoolAvgGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::mps::PoolAvgGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  long long v4 = *(_OWORD *)(a3 + 16);
  long long v5 = *(_OWORD *)(a3 + 32);
  *(void *)(a2 + 48) = *(void *)(a3 + 48);
  *(_OWORD *)(a2 + 16) = v4;
  *(_OWORD *)(a2 + 32) = v5;
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  if (*a3 != *a2) {
    return 0;
  }
  if (a3[1] != a2[1]) {
    return 0;
  }
  if (a3[2] != a2[2]) {
    return 0;
  }
  if (a3[3] != a2[3]) {
    return 0;
  }
  if (a3[4] != a2[4]) {
    return 0;
  }
  if (a3[5] == a2[5]) {
    return a3[6] == a2[6];
  }
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgGradientOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::Conv2DDataGradientOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgGradientOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgGradientOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgGradientOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[1]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[2]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[3]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[4]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[5]);
  uint64_t v5 = v4[6];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgGradientOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgGradientOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgGradientOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgGradientOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgGradientOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::inferPool4DGradientOpReturnTypes(a1, a2, a4, a5, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PoolAvgGradientOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PoolAvgGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::inferPool4DGradientOpReturnTypes(a1, a2, a4, a5, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    unint64_t v24 = v23;
    unint64_t v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.pooling_average_gradient";
    v25[1] = 28;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgGradientOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PoolAvgGradientOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PoolAvgGradientOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    uint64_t v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  }
  else {
    uint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v30, v12, v11);
  uint64_t v20 = v8;
  v21[0] = 0;
  char v22 = 0;
  long long v13 = *(_OWORD *)(v10 + 16);
  long long v23 = *(_OWORD *)v10;
  long long v24 = v13;
  long long v25 = *(_OWORD *)(v10 + 32);
  uint64_t v26 = *(void *)(v10 + 48);
  long long v27 = *(_OWORD *)v30;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22) {
      char v22 = 0;
    }
    mlir::OperationName::OperationName(v21, "mps.pooling_average_gradient", 28, Context);
    char v22 = 1;
  }
  uint64_t v28 = a2;
  uint64_t v29 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v30[0] = result;
  v30[1] = v16;
  if (result)
  {
    unint64_t v17 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v30, v28, v29);
    if (v17 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v18 = v17;
      if (a1 - 16 != (v17 & ((uint64_t)(v17 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v19 = *(unsigned int *)(a4 + 8);
        if (v19 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v19 + 1, 8);
          LODWORD(v19) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v19) = v18;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (unint64_t v6 = a1, mlir::mps::PoolAvgGradientOp::verifyInvariantsImpl((mlir::mps::PoolAvgGradientOp *)&v6)))
  {
    return mlir::mps::verifyPooling4D<mlir::mps::PoolAvgOp>((uint64_t)a1, *(void *)(*((void *)a1 + 9) + 56), *(void *)(*((void *)a1 + 9) + 24)) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::PoolAvgGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.pooling_average", 19, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PoolAvgOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      size_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36F048;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, size_t a4)
{
  int Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::mps::PoolAvgOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::PoolAvgOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::mps::PoolAvgGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::PoolAvgGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::getOpPropertyByteSize()
{
  return 56;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  if (a4)
  {
    long long v4 = *a4;
    long long v5 = a4[1];
    long long v6 = a4[2];
    *(void *)(a3 + 48) = *((void *)a4 + 6);
    *(_OWORD *)(a3 + 16) = v5;
    *(_OWORD *)(a3 + 32) = v6;
    *(_OWORD *)a3 = v4;
  }
  else
  {
    *(void *)(a3 + 48) = 0;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return mlir::mps::PoolAvgGradientOp::populateDefaultProperties(a2, (void *)a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, void *a3)
{
  return mlir::mps::PoolAvgGradientOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::PoolAvgGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::mps::PoolAvgGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  long long v4 = *(_OWORD *)(a3 + 16);
  long long v5 = *(_OWORD *)(a3 + 32);
  *(void *)(a2 + 48) = *(void *)(a3 + 48);
  *(_OWORD *)(a2 + 16) = v4;
  *(_OWORD *)(a2 + 32) = v5;
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  if (*a3 != *a2) {
    return 0;
  }
  if (a3[1] != a2[1]) {
    return 0;
  }
  if (a3[2] != a2[2]) {
    return 0;
  }
  if (a3[3] != a2[3]) {
    return 0;
  }
  if (a3[4] != a2[4]) {
    return 0;
  }
  if (a3[5] == a2[5]) {
    return a3[6] == a2[6];
  }
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolAvgOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::Conv2DDataGradientOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[1]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[2]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[3]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[4]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[5]);
  uint64_t v5 = v4[6];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, long long a9, uint64_t a10)
{
  return mlir::mps::PoolAvgOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, long long a9, uint64_t a10)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PoolAvgOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PoolAvgOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, long long a9, uint64_t a10)
{
  char v10 = a3;
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v19 = v21;
  uint64_t v20 = 0x400000000;
  if (mlir::mps::PoolAvgOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, (uint64_t)&v19))
  {
    mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
    mlir::ValueRange::ValueRange(v17, *(void *)a10, *(unsigned int *)(a10 + 8));
    v22[0] = &unk_26C380E60;
    long long v23 = v22;
    long long v25 = v24;
    v24[0] = &unk_26C380E60;
    if (v25 == v24)
    {
      (*(void (**)(void *))(v24[0] + 32))(v24);
      unint64_t v13 = v23;
      if (v23 != v22) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v25) {
        (*(void (**)(void *))(*v25 + 40))(v25);
      }
      unint64_t v13 = v23;
      if (v23 != v22)
      {
LABEL_6:
        if (v13) {
          (*(void (**)(void *))(*v13 + 40))(v13);
        }
        if (v12)
        {
LABEL_9:
          uint64_t v14 = 1;
          uint64_t v15 = v19;
          if (v19 == v21) {
            return v14;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v12) {
      goto LABEL_9;
    }
LABEL_16:
    v24[0] = "mps.pooling_average";
    v24[1] = 19;
    uint64_t v14 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v10, "'", (uint64_t)v24, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a10);
    uint64_t v15 = v19;
    if (v19 == v21) {
      return v14;
    }
    goto LABEL_12;
  }
  uint64_t v14 = 0;
  uint64_t v15 = v19;
  if (v19 != v21) {
LABEL_12:
  }
    free(v15);
  return v14;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    char v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolAvgOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PoolAvgOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PoolAvgOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    uint64_t v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  }
  else {
    uint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v30, v12, v11);
  uint64_t v20 = v8;
  v21[0] = 0;
  char v22 = 0;
  long long v13 = *(_OWORD *)(v10 + 16);
  long long v23 = *(_OWORD *)v10;
  long long v24 = v13;
  long long v25 = *(_OWORD *)(v10 + 32);
  uint64_t v26 = *(void *)(v10 + 48);
  long long v27 = *(_OWORD *)v30;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22) {
      char v22 = 0;
    }
    mlir::OperationName::OperationName(v21, "mps.pooling_average", 19, Context);
    char v22 = 1;
  }
  uint64_t v28 = a2;
  uint64_t v29 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v30[0] = result;
  v30[1] = v16;
  if (result)
  {
    unint64_t v17 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v30, v28, v29);
    if (v17 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v18 = v17;
      if (a1 - 16 != (v17 & ((uint64_t)(v17 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v19 = *(unsigned int *)(a4 + 8);
        if (v19 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v19 + 1, 8);
          LODWORD(v19) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v19) = v18;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (size_t v7 = a1, mlir::mps::PoolAvgOp::verifyInvariantsImpl((mlir::mps::PoolAvgOp *)&v7)))
  {
    return mlir::mps::verifyPooling4D<mlir::mps::PoolAvgOp>((uint64_t)a1, *(void *)(*((void *)a1 + 9) + 24), 0) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::PoolAvgOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormGradientOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.pooling_l2_norm_gradient", 28, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PoolL2NormGradientOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      size_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36A228;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, size_t a4)
{
  int Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::mps::PoolL2NormGradientOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::PoolL2NormGradientOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::mps::PoolAvgGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::PoolAvgGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::getOpPropertyByteSize()
{
  return 56;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  if (a4)
  {
    long long v4 = *a4;
    long long v5 = a4[1];
    long long v6 = a4[2];
    *(void *)(a3 + 48) = *((void *)a4 + 6);
    *(_OWORD *)(a3 + 16) = v5;
    *(_OWORD *)(a3 + 32) = v6;
    *(_OWORD *)a3 = v4;
  }
  else
  {
    *(void *)(a3 + 48) = 0;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return mlir::mps::PoolAvgGradientOp::populateDefaultProperties(a2, (void *)a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, void *a3)
{
  return mlir::mps::PoolAvgGradientOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::PoolAvgGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::mps::PoolAvgGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  long long v4 = *(_OWORD *)(a3 + 16);
  long long v5 = *(_OWORD *)(a3 + 32);
  *(void *)(a2 + 48) = *(void *)(a3 + 48);
  *(_OWORD *)(a2 + 16) = v4;
  *(_OWORD *)(a2 + 32) = v5;
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  if (*a3 != *a2) {
    return 0;
  }
  if (a3[1] != a2[1]) {
    return 0;
  }
  if (a3[2] != a2[2]) {
    return 0;
  }
  if (a3[3] != a2[3]) {
    return 0;
  }
  if (a3[4] != a2[4]) {
    return 0;
  }
  if (a3[5] == a2[5]) {
    return a3[6] == a2[6];
  }
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormGradientOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::Conv2DDataGradientOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormGradientOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormGradientOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormGradientOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[1]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[2]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[3]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[4]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[5]);
  uint64_t v5 = v4[6];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormGradientOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormGradientOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormGradientOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormGradientOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormGradientOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::inferPool4DGradientOpReturnTypes(a1, a2, a4, a5, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PoolL2NormGradientOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PoolL2NormGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::inferPool4DGradientOpReturnTypes(a1, a2, a4, a5, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    long long v24 = v23;
    uint64_t v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.pooling_l2_norm_gradient";
    v25[1] = 28;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormGradientOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PoolL2NormGradientOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PoolL2NormGradientOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    uint64_t v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  }
  else {
    uint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v30, v12, v11);
  uint64_t v20 = v8;
  v21[0] = 0;
  char v22 = 0;
  long long v13 = *(_OWORD *)(v10 + 16);
  long long v23 = *(_OWORD *)v10;
  long long v24 = v13;
  long long v25 = *(_OWORD *)(v10 + 32);
  uint64_t v26 = *(void *)(v10 + 48);
  long long v27 = *(_OWORD *)v30;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22) {
      char v22 = 0;
    }
    mlir::OperationName::OperationName(v21, "mps.pooling_l2_norm_gradient", 28, Context);
    char v22 = 1;
  }
  uint64_t v28 = a2;
  uint64_t v29 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v30[0] = result;
  v30[1] = v16;
  if (result)
  {
    unint64_t v17 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v30, v28, v29);
    if (v17 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v18 = v17;
      if (a1 - 16 != (v17 & ((uint64_t)(v17 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v19 = *(unsigned int *)(a4 + 8);
        if (v19 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v19 + 1, 8);
          LODWORD(v19) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v19) = v18;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (unint64_t v6 = a1, mlir::mps::PoolAvgGradientOp::verifyInvariantsImpl((mlir::mps::PoolAvgGradientOp *)&v6)))
  {
    return mlir::mps::verifyPooling4D<mlir::mps::PoolAvgOp>((uint64_t)a1, *(void *)(*((void *)a1 + 9) + 56), *(void *)(*((void *)a1 + 9) + 24)) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::PoolL2NormGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.pooling_l2_norm", 19, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PoolL2NormOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      size_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C366088;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, size_t a4)
{
  int Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::mps::PoolL2NormOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::PoolL2NormOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::mps::PoolAvgGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::PoolAvgGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::getOpPropertyByteSize()
{
  return 56;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  if (a4)
  {
    long long v4 = *a4;
    long long v5 = a4[1];
    long long v6 = a4[2];
    *(void *)(a3 + 48) = *((void *)a4 + 6);
    *(_OWORD *)(a3 + 16) = v5;
    *(_OWORD *)(a3 + 32) = v6;
    *(_OWORD *)a3 = v4;
  }
  else
  {
    *(void *)(a3 + 48) = 0;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return mlir::mps::PoolAvgGradientOp::populateDefaultProperties(a2, (void *)a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, void *a3)
{
  return mlir::mps::PoolAvgGradientOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::PoolAvgGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::mps::PoolAvgGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  long long v4 = *(_OWORD *)(a3 + 16);
  long long v5 = *(_OWORD *)(a3 + 32);
  *(void *)(a2 + 48) = *(void *)(a3 + 48);
  *(_OWORD *)(a2 + 16) = v4;
  *(_OWORD *)(a2 + 32) = v5;
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  if (*a3 != *a2) {
    return 0;
  }
  if (a3[1] != a2[1]) {
    return 0;
  }
  if (a3[2] != a2[2]) {
    return 0;
  }
  if (a3[3] != a2[3]) {
    return 0;
  }
  if (a3[4] != a2[4]) {
    return 0;
  }
  if (a3[5] == a2[5]) {
    return a3[6] == a2[6];
  }
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolL2NormOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::Conv2DDataGradientOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[1]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[2]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[3]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[4]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[5]);
  uint64_t v5 = v4[6];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, long long a9, uint64_t a10)
{
  return mlir::mps::PoolL2NormOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, long long a9, uint64_t a10)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PoolL2NormOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PoolL2NormOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, long long a9, uint64_t a10)
{
  char v10 = a3;
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v19 = v21;
  uint64_t v20 = 0x400000000;
  if (mlir::mps::PoolL2NormOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, (uint64_t)&v19))
  {
    mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
    mlir::ValueRange::ValueRange(v17, *(void *)a10, *(unsigned int *)(a10 + 8));
    v22[0] = &unk_26C380E60;
    long long v23 = v22;
    long long v25 = v24;
    v24[0] = &unk_26C380E60;
    if (v25 == v24)
    {
      (*(void (**)(void *))(v24[0] + 32))(v24);
      unint64_t v13 = v23;
      if (v23 != v22) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v25) {
        (*(void (**)(void *))(*v25 + 40))(v25);
      }
      unint64_t v13 = v23;
      if (v23 != v22)
      {
LABEL_6:
        if (v13) {
          (*(void (**)(void *))(*v13 + 40))(v13);
        }
        if (v12)
        {
LABEL_9:
          uint64_t v14 = 1;
          uint64_t v15 = v19;
          if (v19 == v21) {
            return v14;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v12) {
      goto LABEL_9;
    }
LABEL_16:
    v24[0] = "mps.pooling_l2_norm";
    v24[1] = 19;
    uint64_t v14 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v10, "'", (uint64_t)v24, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a10);
    uint64_t v15 = v19;
    if (v19 == v21) {
      return v14;
    }
    goto LABEL_12;
  }
  uint64_t v14 = 0;
  uint64_t v15 = v19;
  if (v19 != v21) {
LABEL_12:
  }
    free(v15);
  return v14;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    char v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolL2NormOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PoolL2NormOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PoolL2NormOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    uint64_t v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  }
  else {
    uint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v30, v12, v11);
  uint64_t v20 = v8;
  v21[0] = 0;
  char v22 = 0;
  long long v13 = *(_OWORD *)(v10 + 16);
  long long v23 = *(_OWORD *)v10;
  long long v24 = v13;
  long long v25 = *(_OWORD *)(v10 + 32);
  uint64_t v26 = *(void *)(v10 + 48);
  long long v27 = *(_OWORD *)v30;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22) {
      char v22 = 0;
    }
    mlir::OperationName::OperationName(v21, "mps.pooling_l2_norm", 19, Context);
    char v22 = 1;
  }
  uint64_t v28 = a2;
  uint64_t v29 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v30[0] = result;
  v30[1] = v16;
  if (result)
  {
    unint64_t v17 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v30, v28, v29);
    if (v17 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v18 = v17;
      if (a1 - 16 != (v17 & ((uint64_t)(v17 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v19 = *(unsigned int *)(a4 + 8);
        if (v19 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v19 + 1, 8);
          LODWORD(v19) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v19) = v18;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (size_t v7 = a1, mlir::mps::PoolAvgOp::verifyInvariantsImpl((mlir::mps::PoolAvgOp *)&v7)))
  {
    return mlir::mps::verifyPooling4D<mlir::mps::PoolAvgOp>((uint64_t)a1, *(void *)(*((void *)a1 + 9) + 24), 0) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::PoolL2NormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxGradientOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.pooling_max_gradient", 24, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PoolMaxGradientOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      size_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C369288;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, size_t a4)
{
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::mps::PoolMaxGradientOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::PoolMaxGradientOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::mps::PoolMaxGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::PoolMaxGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::getOpPropertyByteSize()
{
  return 88;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    long long v4 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)(a3 + 16) = v4;
    long long v5 = *(_OWORD *)(a4 + 32);
    long long v6 = *(_OWORD *)(a4 + 48);
    long long v7 = *(_OWORD *)(a4 + 64);
    *(void *)(a3 + 80) = *(void *)(a4 + 80);
    *(_OWORD *)(a3 + 48) = v6;
    *(_OWORD *)(a3 + 64) = v7;
    *(_OWORD *)(a3 + 32) = v5;
  }
  else
  {
    *(void *)(a3 + 80) = 0;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return mlir::mps::PoolMaxGradientOp::populateDefaultProperties(a2, (void *)a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, void *a3)
{
  return mlir::mps::PoolMaxGradientOp::populateDefaultProperties(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::PoolMaxGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::mps::PoolMaxGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  long long v3 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v3;
  __n128 result = *(__n128 *)(a3 + 32);
  long long v5 = *(_OWORD *)(a3 + 48);
  long long v6 = *(_OWORD *)(a3 + 64);
  *(void *)(a2 + 80) = *(void *)(a3 + 80);
  *(_OWORD *)(a2 + 48) = v5;
  *(_OWORD *)(a2 + 64) = v6;
  *(__n128 *)(a2 + 32) = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  if (*a3 != *a2) {
    return 0;
  }
  if (a3[1] != a2[1]) {
    return 0;
  }
  if (a3[2] != a2[2]) {
    return 0;
  }
  if (a3[3] != a2[3]) {
    return 0;
  }
  if (a3[4] != a2[4]) {
    return 0;
  }
  if (a3[5] != a2[5]) {
    return 0;
  }
  if (a3[6] != a2[6]) {
    return 0;
  }
  if (a3[7] != a2[7]) {
    return 0;
  }
  if (a3[8] != a2[8]) {
    return 0;
  }
  return a3[9] == a2[9] && a3[10] == a2[10];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxGradientOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::PoolMaxGradientOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxGradientOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxGradientOp>::writeProperties;
  long long v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    long long v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      long long v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      long long v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxGradientOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::mps::PoolMaxGradientOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxGradientOp>::getEffects;
  long long v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    long long v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      long long v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      long long v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxGradientOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxGradientOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxGradientOp>::isCompatibleReturnTypes;
  long long v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    long long v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      long long v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      long long v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxGradientOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::inferPool4DGradientOpReturnTypes(a1, a2, a4, a5, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PoolMaxGradientOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PoolMaxGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::inferPool4DGradientOpReturnTypes(a1, a2, a4, a5, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    long long v24 = v23;
    uint64_t v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.pooling_max_gradient";
    v25[1] = 24;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxGradientOp>::isCompatibleReturnTypes;
  long long v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    long long v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      long long v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      long long v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PoolMaxGradientOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PoolMaxGradientOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    uint64_t v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  }
  else {
    uint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v33, v12, v11);
  long long v13 = *(_OWORD *)(v10 + 48);
  long long v26 = *(_OWORD *)(v10 + 32);
  long long v27 = v13;
  long long v28 = *(_OWORD *)(v10 + 64);
  long long v14 = *(_OWORD *)(v10 + 16);
  long long v24 = *(_OWORD *)v10;
  uint64_t v21 = v8;
  v22[0] = 0;
  char v23 = 0;
  uint64_t v29 = *(void *)(v10 + 80);
  long long v25 = v14;
  long long v30 = *(_OWORD *)v33;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v21);
    if (v23) {
      char v23 = 0;
    }
    mlir::OperationName::OperationName(v22, "mps.pooling_max_gradient", 24, Context);
    char v23 = 1;
  }
  uint64_t v31 = a2;
  uint64_t v32 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v33[0] = result;
  v33[1] = v17;
  if (result)
  {
    unint64_t v18 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v33, v31, v32);
    if (v18 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v19 = v18;
      if (a1 - 16 != (v18 & ((uint64_t)(v18 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v20 = *(unsigned int *)(a4 + 8);
        if (v20 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v20 + 1, 8);
          LODWORD(v20) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v20) = v19;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v187 = a1;
    v1 = (void *)&unk_267771000;
    int v34 = v33;
    a1 = v187;
    if (v34)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v199 = 83;
      unint64_t v35 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v35) {
        unint64_t v36 = v35;
      }
      else {
        unint64_t v36 = v199;
      }
      unint64_t v37 = &v198[v36];
      unint64_t v38 = v199 - v36;
      if (v199 - v36 >= 0x12) {
        uint64_t v39 = 18;
      }
      else {
        uint64_t v39 = v199 - v36;
      }
      unint64_t v40 = v38 - v39;
      if (v40 >= v40 - 1) {
        uint64_t v41 = v40 - 1;
      }
      else {
        uint64_t v41 = v40;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v37[v39], v41);
      v1 = (void *)&unk_267771000;
      a1 = v187;
    }
  }
  uint64_t v2 = v1[23];
  long long v3 = &unk_267771000;
  {
    uint64_t v177 = v2;
    uint64_t v188 = a1;
    long long v3 = (void *)&unk_267771000;
    int v43 = v42;
    uint64_t v2 = v177;
    a1 = v188;
    if (v43)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v199 = 81;
      unint64_t v44 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v44) {
        unint64_t v45 = v44;
      }
      else {
        unint64_t v45 = v199;
      }
      unint64_t v46 = &v198[v45];
      unint64_t v47 = v199 - v45;
      if (v199 - v45 >= 0x12) {
        uint64_t v48 = 18;
      }
      else {
        uint64_t v48 = v199 - v45;
      }
      unint64_t v49 = v47 - v48;
      if (v49 >= v49 - 1) {
        uint64_t v50 = v49 - 1;
      }
      else {
        uint64_t v50 = v49;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v46[v48], v50);
      long long v3 = (void *)&unk_267771000;
      uint64_t v2 = v177;
      a1 = v188;
    }
  }
  uint64_t v4 = v3[25];
  unint64_t v5 = &unk_267771000;
  {
    uint64_t v178 = v2;
    uint64_t v189 = a1;
    uint64_t v168 = v4;
    unint64_t v5 = (void *)&unk_267771000;
    uint64_t v4 = v168;
    uint64_t v2 = v178;
    int v52 = v51;
    a1 = v189;
    if (v52)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      unint64_t v199 = 104;
      unint64_t v53 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v53) {
        unint64_t v54 = v53;
      }
      else {
        unint64_t v54 = v199;
      }
      unint64_t v55 = &v198[v54];
      unint64_t v56 = v199 - v54;
      if (v199 - v54 >= 0x12) {
        uint64_t v57 = 18;
      }
      else {
        uint64_t v57 = v199 - v54;
      }
      unint64_t v58 = v56 - v57;
      if (v58 >= v58 - 1) {
        uint64_t v59 = v58 - 1;
      }
      else {
        uint64_t v59 = v58;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v55[v57], v59);
      unint64_t v5 = (void *)&unk_267771000;
      uint64_t v4 = v168;
      uint64_t v2 = v178;
      a1 = v189;
    }
  }
  uint64_t v6 = v5[318];
  long long v7 = &unk_267770000;
  {
    uint64_t v179 = v2;
    uint64_t v190 = a1;
    uint64_t v169 = v4;
    uint64_t v160 = v6;
    long long v7 = (void *)&unk_267770000;
    uint64_t v6 = v160;
    uint64_t v4 = v169;
    uint64_t v2 = v179;
    int v61 = v60;
    a1 = v190;
    if (v61)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v199 = 86;
      unint64_t v62 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v62) {
        unint64_t v63 = v62;
      }
      else {
        unint64_t v63 = v199;
      }
      unint64_t v64 = &v198[v63];
      unint64_t v65 = v199 - v63;
      if (v199 - v63 >= 0x12) {
        uint64_t v66 = 18;
      }
      else {
        uint64_t v66 = v199 - v63;
      }
      unint64_t v67 = v65 - v66;
      if (v67 >= v67 - 1) {
        uint64_t v68 = v67 - 1;
      }
      else {
        uint64_t v68 = v67;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v64[v66], v68);
      long long v7 = (void *)&unk_267770000;
      uint64_t v6 = v160;
      uint64_t v4 = v169;
      uint64_t v2 = v179;
      a1 = v190;
    }
  }
  uint64_t v8 = v7[431];
  unint64_t v9 = &unk_267771000;
  {
    uint64_t v180 = v2;
    uint64_t v191 = a1;
    uint64_t v170 = v4;
    uint64_t v153 = v8;
    uint64_t v161 = v6;
    unint64_t v9 = (void *)&unk_267771000;
    uint64_t v8 = v153;
    uint64_t v6 = v161;
    uint64_t v4 = v170;
    uint64_t v2 = v180;
    int v70 = v69;
    a1 = v191;
    if (v70)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>]";
      unint64_t v199 = 97;
      unint64_t v71 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v71) {
        unint64_t v72 = v71;
      }
      else {
        unint64_t v72 = v199;
      }
      unint64_t v73 = &v198[v72];
      unint64_t v74 = v199 - v72;
      if (v199 - v72 >= 0x12) {
        uint64_t v75 = 18;
      }
      else {
        uint64_t v75 = v199 - v72;
      }
      unint64_t v76 = v74 - v75;
      if (v76 >= v76 - 1) {
        uint64_t v77 = v76 - 1;
      }
      else {
        uint64_t v77 = v76;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v73[v75], v77);
      unint64_t v9 = (void *)&unk_267771000;
      uint64_t v8 = v153;
      uint64_t v6 = v161;
      uint64_t v4 = v170;
      uint64_t v2 = v180;
      a1 = v191;
    }
  }
  uint64_t v10 = v9[433];
  unint64_t v11 = &unk_267772000;
  {
    uint64_t v181 = v2;
    uint64_t v192 = a1;
    uint64_t v171 = v4;
    uint64_t v154 = v8;
    uint64_t v162 = v6;
    uint64_t v147 = v10;
    unint64_t v11 = (void *)&unk_267772000;
    uint64_t v10 = v147;
    uint64_t v8 = v154;
    uint64_t v6 = v162;
    uint64_t v4 = v171;
    uint64_t v2 = v181;
    int v79 = v78;
    a1 = v192;
    if (v79)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AttrSizedOperandSegments<Empty>]";
      unint64_t v199 = 96;
      unint64_t v80 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v80) {
        unint64_t v81 = v80;
      }
      else {
        unint64_t v81 = v199;
      }
      unint64_t v82 = &v198[v81];
      unint64_t v83 = v199 - v81;
      if (v199 - v81 >= 0x12) {
        uint64_t v84 = 18;
      }
      else {
        uint64_t v84 = v199 - v81;
      }
      unint64_t v85 = v83 - v84;
      if (v85 >= v85 - 1) {
        uint64_t v86 = v85 - 1;
      }
      else {
        uint64_t v86 = v85;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v82[v84], v86);
      unint64_t v11 = (void *)&unk_267772000;
      uint64_t v10 = v147;
      uint64_t v8 = v154;
      uint64_t v6 = v162;
      uint64_t v4 = v171;
      uint64_t v2 = v181;
      a1 = v192;
    }
  }
  uint64_t v12 = v11[47];
  long long v13 = &unk_267770000;
  {
    uint64_t v182 = v2;
    uint64_t v193 = a1;
    uint64_t v172 = v4;
    uint64_t v155 = v8;
    uint64_t v163 = v6;
    uint64_t v142 = v12;
    uint64_t v148 = v10;
    long long v13 = (void *)&unk_267770000;
    uint64_t v12 = v142;
    uint64_t v10 = v148;
    uint64_t v8 = v155;
    uint64_t v6 = v163;
    uint64_t v4 = v172;
    uint64_t v2 = v182;
    int v88 = v87;
    a1 = v193;
    if (v88)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v199 = 84;
      unint64_t v89 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v89) {
        unint64_t v90 = v89;
      }
      else {
        unint64_t v90 = v199;
      }
      uint64_t v91 = &v198[v90];
      unint64_t v92 = v199 - v90;
      if (v199 - v90 >= 0x12) {
        uint64_t v93 = 18;
      }
      else {
        uint64_t v93 = v199 - v90;
      }
      unint64_t v94 = v92 - v93;
      if (v94 >= v94 - 1) {
        uint64_t v95 = v94 - 1;
      }
      else {
        uint64_t v95 = v94;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v91[v93], v95);
      long long v13 = (void *)&unk_267770000;
      uint64_t v12 = v142;
      uint64_t v10 = v148;
      uint64_t v8 = v155;
      uint64_t v6 = v163;
      uint64_t v4 = v172;
      uint64_t v2 = v182;
      a1 = v193;
    }
  }
  uint64_t v14 = v13[435];
  uint64_t v15 = &unk_267771000;
  {
    uint64_t v183 = v2;
    uint64_t v194 = a1;
    uint64_t v173 = v4;
    uint64_t v156 = v8;
    uint64_t v164 = v6;
    uint64_t v143 = v12;
    uint64_t v149 = v10;
    uint64_t v138 = v14;
    uint64_t v15 = (void *)&unk_267771000;
    uint64_t v14 = v138;
    uint64_t v12 = v143;
    uint64_t v10 = v149;
    uint64_t v8 = v156;
    uint64_t v6 = v164;
    uint64_t v4 = v173;
    uint64_t v2 = v183;
    int v97 = v96;
    a1 = v194;
    if (v97)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v199 = 89;
      unint64_t v98 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v98) {
        unint64_t v99 = v98;
      }
      else {
        unint64_t v99 = v199;
      }
      uint64_t v100 = &v198[v99];
      unint64_t v101 = v199 - v99;
      if (v199 - v99 >= 0x12) {
        uint64_t v102 = 18;
      }
      else {
        uint64_t v102 = v199 - v99;
      }
      unint64_t v103 = v101 - v102;
      if (v103 >= v103 - 1) {
        uint64_t v104 = v103 - 1;
      }
      else {
        uint64_t v104 = v103;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v100[v102], v104);
      uint64_t v15 = (void *)&unk_267771000;
      uint64_t v14 = v138;
      uint64_t v12 = v143;
      uint64_t v10 = v149;
      uint64_t v8 = v156;
      uint64_t v6 = v164;
      uint64_t v4 = v173;
      uint64_t v2 = v183;
      a1 = v194;
    }
  }
  uint64_t v16 = v15[320];
  unint64_t v17 = &unk_267771000;
  {
    uint64_t v184 = v2;
    uint64_t v195 = a1;
    uint64_t v174 = v4;
    uint64_t v157 = v8;
    uint64_t v165 = v6;
    uint64_t v144 = v12;
    uint64_t v150 = v10;
    uint64_t v135 = v16;
    uint64_t v139 = v14;
    unint64_t v17 = (void *)&unk_267771000;
    uint64_t v16 = v135;
    uint64_t v14 = v139;
    uint64_t v12 = v144;
    uint64_t v10 = v150;
    uint64_t v8 = v157;
    uint64_t v6 = v165;
    uint64_t v4 = v174;
    uint64_t v2 = v184;
    int v106 = v105;
    a1 = v195;
    if (v106)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v199 = 93;
      unint64_t v107 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v107) {
        unint64_t v108 = v107;
      }
      else {
        unint64_t v108 = v199;
      }
      uint64_t v109 = &v198[v108];
      unint64_t v110 = v199 - v108;
      if (v199 - v108 >= 0x12) {
        uint64_t v111 = 18;
      }
      else {
        uint64_t v111 = v199 - v108;
      }
      unint64_t v112 = v110 - v111;
      if (v112 >= v112 - 1) {
        uint64_t v113 = v112 - 1;
      }
      else {
        uint64_t v113 = v112;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v109[v111], v113);
      unint64_t v17 = (void *)&unk_267771000;
      uint64_t v16 = v135;
      uint64_t v14 = v139;
      uint64_t v12 = v144;
      uint64_t v10 = v150;
      uint64_t v8 = v157;
      uint64_t v6 = v165;
      uint64_t v4 = v174;
      uint64_t v2 = v184;
      a1 = v195;
    }
  }
  uint64_t v18 = v17[31];
  unint64_t v19 = &unk_267771000;
  {
    uint64_t v185 = v2;
    uint64_t v196 = a1;
    uint64_t v175 = v4;
    uint64_t v158 = v8;
    uint64_t v166 = v6;
    uint64_t v145 = v12;
    uint64_t v151 = v10;
    uint64_t v136 = v16;
    uint64_t v140 = v14;
    uint64_t v133 = v18;
    unint64_t v19 = (void *)&unk_267771000;
    uint64_t v18 = v133;
    uint64_t v16 = v136;
    uint64_t v14 = v140;
    uint64_t v12 = v145;
    uint64_t v10 = v151;
    uint64_t v8 = v158;
    uint64_t v6 = v166;
    uint64_t v4 = v175;
    uint64_t v2 = v185;
    int v115 = v114;
    a1 = v196;
    if (v115)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v199 = 90;
      unint64_t v116 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v116) {
        unint64_t v117 = v116;
      }
      else {
        unint64_t v117 = v199;
      }
      v118 = &v198[v117];
      unint64_t v119 = v199 - v117;
      if (v199 - v117 >= 0x12) {
        uint64_t v120 = 18;
      }
      else {
        uint64_t v120 = v199 - v117;
      }
      unint64_t v121 = v119 - v120;
      if (v121 >= v121 - 1) {
        uint64_t v122 = v121 - 1;
      }
      else {
        uint64_t v122 = v121;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v118[v120], v122);
      unint64_t v19 = (void *)&unk_267771000;
      uint64_t v18 = v133;
      uint64_t v16 = v136;
      uint64_t v14 = v140;
      uint64_t v12 = v145;
      uint64_t v10 = v151;
      uint64_t v8 = v158;
      uint64_t v6 = v166;
      uint64_t v4 = v175;
      uint64_t v2 = v185;
      a1 = v196;
    }
  }
  uint64_t v20 = v19[37];
  uint64_t v21 = &unk_267771000;
  {
    uint64_t v186 = v2;
    uint64_t v197 = a1;
    uint64_t v176 = v4;
    uint64_t v159 = v8;
    uint64_t v167 = v6;
    uint64_t v146 = v12;
    uint64_t v152 = v10;
    uint64_t v137 = v16;
    uint64_t v141 = v14;
    uint64_t v132 = v20;
    uint64_t v134 = v18;
    uint64_t v21 = (void *)&unk_267771000;
    uint64_t v20 = v132;
    uint64_t v18 = v134;
    uint64_t v16 = v137;
    uint64_t v14 = v141;
    uint64_t v12 = v146;
    uint64_t v10 = v152;
    uint64_t v8 = v159;
    uint64_t v6 = v167;
    uint64_t v4 = v176;
    uint64_t v2 = v186;
    int v124 = v123;
    a1 = v197;
    if (v124)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      unint64_t v199 = 100;
      unint64_t v125 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v125) {
        unint64_t v126 = v125;
      }
      else {
        unint64_t v126 = v199;
      }
      v127 = &v198[v126];
      unint64_t v128 = v199 - v126;
      if (v199 - v126 >= 0x12) {
        uint64_t v129 = 18;
      }
      else {
        uint64_t v129 = v199 - v126;
      }
      unint64_t v130 = v128 - v129;
      if (v130 >= v130 - 1) {
        uint64_t v131 = v130 - 1;
      }
      else {
        uint64_t v131 = v130;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v127[v129], v131);
      uint64_t v21 = (void *)&unk_267771000;
      uint64_t v20 = v132;
      uint64_t v18 = v134;
      uint64_t v16 = v137;
      uint64_t v14 = v141;
      uint64_t v12 = v146;
      uint64_t v10 = v152;
      uint64_t v8 = v159;
      uint64_t v6 = v167;
      uint64_t v4 = v176;
      uint64_t v2 = v186;
      a1 = v197;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v21[41] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::PoolMaxGradientOp>,mlir::OpTrait::OneResult<mlir::mps::PoolMaxGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::PoolMaxGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::PoolMaxGradientOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::mps::PoolMaxGradientOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::mps::PoolMaxGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::PoolMaxGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::PoolMaxGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::PoolMaxGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::PoolMaxGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::PoolMaxGradientOp>>((mlir::OpTrait::impl *)a1, a2))return 0; {
  unint64_t v3 = *(unsigned int *)(a1 + 44);
  }
  uint64_t v4 = a1 + 16 * ((v3 >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(a1 + 44))) {
    uint64_t v4 = 0;
  }
  int v5 = *(_DWORD *)(v4 + 76);
  if ((v3 & 0x800000) == 0)
  {
    uint64_t v6 = 0;
    if (v5) {
      goto LABEL_6;
    }
LABEL_9:
    uint64_t v7 = 0;
    return mlir::mps::verifyPooling4D<mlir::mps::PoolMaxGradientOp>(a1, v7, *(void *)(*(void *)(a1 + 72) + 24)) != 0;
  }
  uint64_t v6 = *(void *)(a1 + 72);
  if (!v5) {
    goto LABEL_9;
  }
LABEL_6:
  uint64_t v7 = *(void *)(v6 + 32 * *(unsigned int *)(v4 + 72) + 24);
  return mlir::mps::verifyPooling4D<mlir::mps::PoolMaxGradientOp>(a1, v7, *(void *)(*(void *)(a1 + 72) + 24)) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::PoolMaxGradientOp>,mlir::OpTrait::OneResult<mlir::mps::PoolMaxGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::PoolMaxGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::PoolMaxGradientOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::mps::PoolMaxGradientOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::mps::PoolMaxGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::PoolMaxGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::PoolMaxGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::PoolMaxGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::PoolMaxGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::PoolMaxGradientOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)1)
    || !mlir::OpTrait::impl::verifyOperandSizeAttr((uint64_t)a1, "operandSegmentSizes", 0x13uLL))
  {
    return 0;
  }
  uint64_t v6 = a1;
  return mlir::mps::PoolMaxGradientOp::verifyInvariantsImpl((mlir::mps::PoolMaxGradientOp *)&v6);
}

BOOL mlir::Op<mlir::mps::PoolMaxGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.pooling_max", 15, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PoolMaxOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36F110;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, size_t a4)
{
  int Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::mps::PoolMaxOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::PoolMaxOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::mps::PoolMaxOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::PoolMaxGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::getOpPropertyByteSize()
{
  return 72;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4)
  {
    *(_OWORD *)a3 = *(_OWORD *)a4;
    long long v4 = *(_OWORD *)(a4 + 16);
    long long v5 = *(_OWORD *)(a4 + 32);
    long long v6 = *(_OWORD *)(a4 + 48);
    *(void *)(a3 + 64) = *(void *)(a4 + 64);
    *(_OWORD *)(a3 + 32) = v5;
    *(_OWORD *)(a3 + 48) = v6;
    *(_OWORD *)(a3 + 16) = v4;
  }
  else
  {
    *(void *)(a3 + 64) = 0;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
  }
  return mlir::mps::PoolMaxGradientOp::populateDefaultProperties(a2, (void *)a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, void *a3)
{
  return mlir::mps::PoolMaxGradientOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::PoolMaxOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::mps::PoolMaxOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)a2 = *(_OWORD *)a3;
  __n128 result = *(__n128 *)(a3 + 16);
  long long v4 = *(_OWORD *)(a3 + 32);
  long long v5 = *(_OWORD *)(a3 + 48);
  *(void *)(a2 + 64) = *(void *)(a3 + 64);
  *(_OWORD *)(a2 + 32) = v4;
  *(_OWORD *)(a2 + 48) = v5;
  *(__n128 *)(a2 + 16) = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  if (*a3 != *a2) {
    return 0;
  }
  if (a3[1] != a2[1]) {
    return 0;
  }
  if (a3[2] != a2[2]) {
    return 0;
  }
  if (a3[3] != a2[3]) {
    return 0;
  }
  if (a3[4] != a2[4]) {
    return 0;
  }
  if (a3[5] != a2[5]) {
    return 0;
  }
  if (a3[6] != a2[6]) {
    return 0;
  }
  if (a3[7] == a2[7]) {
    return a3[8] == a2[8];
  }
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::PoolMaxOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::PoolMaxOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[1]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[2]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[3]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[4]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[5]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[6]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[7]);
  uint64_t v5 = v4[8];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, long long a9, uint64_t a10)
{
  return mlir::mps::PoolMaxOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, long long a9, uint64_t a10)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PoolMaxOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PoolMaxOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, long long a9, uint64_t a10)
{
  char v10 = a3;
  uint64_t v26 = *MEMORY[0x263EF8340];
  unint64_t v19 = v21;
  uint64_t v20 = 0x400000000;
  if (mlir::mps::PoolMaxOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, (uint64_t)&v19))
  {
    mlir::ValueRange::ValueRange(v18, (uint64_t)v19, v20);
    mlir::ValueRange::ValueRange(v17, *(void *)a10, *(unsigned int *)(a10 + 8));
    v22[0] = &unk_26C380E60;
    char v23 = v22;
    long long v25 = v24;
    v24[0] = &unk_26C380E60;
    if (v25 == v24)
    {
      (*(void (**)(void *))(v24[0] + 32))(v24);
      unint64_t v13 = v23;
      if (v23 != v22) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v25) {
        (*(void (**)(void *))(*v25 + 40))(v25);
      }
      unint64_t v13 = v23;
      if (v23 != v22)
      {
LABEL_6:
        if (v13) {
          (*(void (**)(void *))(*v13 + 40))(v13);
        }
        if (v12)
        {
LABEL_9:
          uint64_t v14 = 1;
          uint64_t v15 = v19;
          if (v19 == v21) {
            return v14;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v12) {
      goto LABEL_9;
    }
LABEL_16:
    v24[0] = "mps.pooling_max";
    v24[1] = 15;
    uint64_t v14 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v10, "'", (uint64_t)v24, "' op inferred type(s) ", (uint64_t)&v19, " are incompatible with return type(s) of operation ", a10);
    uint64_t v15 = v19;
    if (v19 == v21) {
      return v14;
    }
    goto LABEL_12;
  }
  uint64_t v14 = 0;
  uint64_t v15 = v19;
  if (v19 != v21) {
LABEL_12:
  }
    free(v15);
  return v14;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    char v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  void *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>::getDefaultDialect;
  char v3 = &unk_267771000;
  {
    char v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      unint64_t v14 = 72;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[346], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>::getAsmResultNames(uint64_t a1, uint64_t a2, void (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v6 = a2 - 16;
  if (*(_DWORD *)(a2 + 36)) {
    uint64_t v7 = a2 - 16;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0);
  a3(a4, NextResultAtOffset, "result", 6);
  if (*(_DWORD *)(a2 + 36)) {
    uint64_t v9 = v6;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = mlir::detail::OpResultImpl::getNextResultAtOffset(v9, 1);
  uint64_t v11 = mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0);

  return ((uint64_t (*)(uint64_t, uint64_t, const char *, uint64_t))a3)(a4, v11, "indices", 7);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::PoolMaxOp>::getDefaultDialect()
{
  return &byte_211F4AA5D;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::foldHook<mlir::mps::PoolMaxOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::foldHook<mlir::mps::PoolMaxOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    uint64_t v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  }
  else {
    uint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v29, v12, v11);
  long long v13 = *(_OWORD *)v10;
  long long v22 = *(_OWORD *)(v10 + 16);
  long long v14 = *(_OWORD *)(v10 + 48);
  long long v23 = *(_OWORD *)(v10 + 32);
  long long v24 = v14;
  uint64_t v18 = v8;
  v19[0] = 0;
  char v20 = 0;
  uint64_t v25 = *(void *)(v10 + 64);
  long long v21 = v13;
  long long v26 = *(_OWORD *)v29;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v18);
    if (v20) {
      char v20 = 0;
    }
    mlir::OperationName::OperationName(v19, "mps.pooling_max", 15, Context);
    char v20 = 1;
  }
  uint64_t v27 = a2;
  uint64_t v28 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v29[0] = result;
  v29[1] = v17;
  if (result) {
    return mlir::RegionBranchOpInterface::getEntrySuccessorRegions(v29, v27, v28, a4);
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v165 = a1;
    v1 = (void *)&unk_267771000;
    int v31 = v30;
    a1 = v165;
    if (v31)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v176 = 83;
      unint64_t v32 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v32) {
        unint64_t v33 = v32;
      }
      else {
        unint64_t v33 = v176;
      }
      int v34 = &v175[v33];
      unint64_t v35 = v176 - v33;
      if (v176 - v33 >= 0x12) {
        uint64_t v36 = 18;
      }
      else {
        uint64_t v36 = v176 - v33;
      }
      unint64_t v37 = v35 - v36;
      if (v37 >= v37 - 1) {
        uint64_t v38 = v37 - 1;
      }
      else {
        uint64_t v38 = v37;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v34[v36], v38);
      v1 = (void *)&unk_267771000;
      a1 = v165;
    }
  }
  uint64_t v2 = v1[23];
  char v3 = &unk_267771000;
  {
    uint64_t v156 = v2;
    uint64_t v166 = a1;
    char v3 = (void *)&unk_267771000;
    int v40 = v39;
    uint64_t v2 = v156;
    a1 = v166;
    if (v40)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NResults<2>::Impl<Empty>]";
      unint64_t v176 = 89;
      unint64_t v41 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v41) {
        unint64_t v42 = v41;
      }
      else {
        unint64_t v42 = v176;
      }
      int v43 = &v175[v42];
      unint64_t v44 = v176 - v42;
      if (v176 - v42 >= 0x12) {
        uint64_t v45 = 18;
      }
      else {
        uint64_t v45 = v176 - v42;
      }
      unint64_t v46 = v44 - v45;
      if (v46 >= v46 - 1) {
        uint64_t v47 = v46 - 1;
      }
      else {
        uint64_t v47 = v46;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::NResults<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NResults<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v43[v45], v47);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v156;
      a1 = v166;
    }
  }
  uint64_t v4 = v3[348];
  unint64_t v5 = &unk_267770000;
  {
    uint64_t v157 = v2;
    uint64_t v167 = a1;
    uint64_t v148 = v4;
    unint64_t v5 = (void *)&unk_267770000;
    uint64_t v4 = v148;
    int v49 = v48;
    uint64_t v2 = v157;
    a1 = v167;
    if (v49)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v176 = 86;
      unint64_t v50 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v50) {
        unint64_t v51 = v50;
      }
      else {
        unint64_t v51 = v176;
      }
      int v52 = &v175[v51];
      unint64_t v53 = v176 - v51;
      if (v176 - v51 >= 0x12) {
        uint64_t v54 = 18;
      }
      else {
        uint64_t v54 = v176 - v51;
      }
      unint64_t v55 = v53 - v54;
      if (v55 >= v55 - 1) {
        uint64_t v56 = v55 - 1;
      }
      else {
        uint64_t v56 = v55;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      unint64_t v5 = (void *)&unk_267770000;
      uint64_t v4 = v148;
      uint64_t v2 = v157;
      a1 = v167;
    }
  }
  uint64_t v6 = v5[431];
  uint64_t v7 = &unk_267771000;
  {
    uint64_t v158 = v2;
    uint64_t v168 = a1;
    uint64_t v141 = v6;
    uint64_t v149 = v4;
    uint64_t v7 = (void *)&unk_267771000;
    uint64_t v6 = v141;
    uint64_t v4 = v149;
    int v58 = v57;
    uint64_t v2 = v158;
    a1 = v168;
    if (v58)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      unint64_t v176 = 82;
      unint64_t v59 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v59) {
        unint64_t v60 = v59;
      }
      else {
        unint64_t v60 = v176;
      }
      int v61 = &v175[v60];
      unint64_t v62 = v176 - v60;
      if (v176 - v60 >= 0x12) {
        uint64_t v63 = 18;
      }
      else {
        uint64_t v63 = v176 - v60;
      }
      unint64_t v64 = v62 - v63;
      if (v64 >= v64 - 1) {
        uint64_t v65 = v64 - 1;
      }
      else {
        uint64_t v65 = v64;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      uint64_t v7 = (void *)&unk_267771000;
      uint64_t v6 = v141;
      uint64_t v4 = v149;
      uint64_t v2 = v158;
      a1 = v168;
    }
  }
  uint64_t v8 = v7[29];
  unint64_t v9 = &unk_267770000;
  {
    uint64_t v159 = v2;
    uint64_t v169 = a1;
    uint64_t v142 = v6;
    uint64_t v150 = v4;
    uint64_t v135 = v8;
    unint64_t v9 = (void *)&unk_267770000;
    uint64_t v8 = v135;
    uint64_t v6 = v142;
    uint64_t v4 = v150;
    int v67 = v66;
    uint64_t v2 = v159;
    a1 = v169;
    if (v67)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v176 = 84;
      unint64_t v68 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v68) {
        unint64_t v69 = v68;
      }
      else {
        unint64_t v69 = v176;
      }
      int v70 = &v175[v69];
      unint64_t v71 = v176 - v69;
      if (v176 - v69 >= 0x12) {
        uint64_t v72 = 18;
      }
      else {
        uint64_t v72 = v176 - v69;
      }
      unint64_t v73 = v71 - v72;
      if (v73 >= v73 - 1) {
        uint64_t v74 = v73 - 1;
      }
      else {
        uint64_t v74 = v73;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      unint64_t v9 = (void *)&unk_267770000;
      uint64_t v8 = v135;
      uint64_t v6 = v142;
      uint64_t v4 = v150;
      uint64_t v2 = v159;
      a1 = v169;
    }
  }
  uint64_t v10 = v9[435];
  unint64_t v11 = &unk_267771000;
  {
    uint64_t v160 = v2;
    uint64_t v170 = a1;
    uint64_t v143 = v6;
    uint64_t v151 = v4;
    uint64_t v130 = v10;
    uint64_t v136 = v8;
    unint64_t v11 = (void *)&unk_267771000;
    uint64_t v10 = v130;
    uint64_t v8 = v136;
    uint64_t v6 = v143;
    uint64_t v4 = v151;
    int v76 = v75;
    uint64_t v2 = v160;
    a1 = v170;
    if (v76)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v176 = 89;
      unint64_t v77 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v77) {
        unint64_t v78 = v77;
      }
      else {
        unint64_t v78 = v176;
      }
      int v79 = &v175[v78];
      unint64_t v80 = v176 - v78;
      if (v176 - v78 >= 0x12) {
        uint64_t v81 = 18;
      }
      else {
        uint64_t v81 = v176 - v78;
      }
      unint64_t v82 = v80 - v81;
      if (v82 >= v82 - 1) {
        uint64_t v83 = v82 - 1;
      }
      else {
        uint64_t v83 = v82;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      unint64_t v11 = (void *)&unk_267771000;
      uint64_t v10 = v130;
      uint64_t v8 = v136;
      uint64_t v6 = v143;
      uint64_t v4 = v151;
      uint64_t v2 = v160;
      a1 = v170;
    }
  }
  uint64_t v12 = v11[320];
  long long v13 = &unk_267771000;
  {
    uint64_t v161 = v2;
    uint64_t v171 = a1;
    uint64_t v144 = v6;
    uint64_t v152 = v4;
    uint64_t v131 = v10;
    uint64_t v137 = v8;
    uint64_t v126 = v12;
    long long v13 = (void *)&unk_267771000;
    uint64_t v12 = v126;
    uint64_t v10 = v131;
    uint64_t v8 = v137;
    uint64_t v6 = v144;
    uint64_t v4 = v152;
    int v85 = v84;
    uint64_t v2 = v161;
    a1 = v171;
    if (v85)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v176 = 93;
      unint64_t v86 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v86) {
        unint64_t v87 = v86;
      }
      else {
        unint64_t v87 = v176;
      }
      int v88 = &v175[v87];
      unint64_t v89 = v176 - v87;
      if (v176 - v87 >= 0x12) {
        uint64_t v90 = 18;
      }
      else {
        uint64_t v90 = v176 - v87;
      }
      unint64_t v91 = v89 - v90;
      if (v91 >= v91 - 1) {
        uint64_t v92 = v91 - 1;
      }
      else {
        uint64_t v92 = v91;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      long long v13 = (void *)&unk_267771000;
      uint64_t v12 = v126;
      uint64_t v10 = v131;
      uint64_t v8 = v137;
      uint64_t v6 = v144;
      uint64_t v4 = v152;
      uint64_t v2 = v161;
      a1 = v171;
    }
  }
  uint64_t v14 = v13[31];
  uint64_t v15 = &unk_267771000;
  {
    uint64_t v162 = v2;
    uint64_t v172 = a1;
    uint64_t v145 = v6;
    uint64_t v153 = v4;
    uint64_t v132 = v10;
    uint64_t v138 = v8;
    uint64_t v123 = v14;
    uint64_t v127 = v12;
    uint64_t v15 = (void *)&unk_267771000;
    uint64_t v14 = v123;
    uint64_t v12 = v127;
    uint64_t v10 = v132;
    uint64_t v8 = v138;
    uint64_t v6 = v145;
    uint64_t v4 = v153;
    int v94 = v93;
    uint64_t v2 = v162;
    a1 = v172;
    if (v94)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v176 = 90;
      unint64_t v95 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v95) {
        unint64_t v96 = v95;
      }
      else {
        unint64_t v96 = v176;
      }
      int v97 = &v175[v96];
      unint64_t v98 = v176 - v96;
      if (v176 - v96 >= 0x12) {
        uint64_t v99 = 18;
      }
      else {
        uint64_t v99 = v176 - v96;
      }
      unint64_t v100 = v98 - v99;
      if (v100 >= v100 - 1) {
        uint64_t v101 = v100 - 1;
      }
      else {
        uint64_t v101 = v100;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      uint64_t v15 = (void *)&unk_267771000;
      uint64_t v14 = v123;
      uint64_t v12 = v127;
      uint64_t v10 = v132;
      uint64_t v8 = v138;
      uint64_t v6 = v145;
      uint64_t v4 = v153;
      uint64_t v2 = v162;
      a1 = v172;
    }
  }
  uint64_t v16 = v15[37];
  unint64_t v17 = &unk_267771000;
  {
    uint64_t v163 = v2;
    uint64_t v173 = a1;
    uint64_t v146 = v6;
    uint64_t v154 = v4;
    uint64_t v133 = v10;
    uint64_t v139 = v8;
    uint64_t v124 = v14;
    uint64_t v128 = v12;
    uint64_t v121 = v16;
    unint64_t v17 = (void *)&unk_267771000;
    uint64_t v16 = v121;
    uint64_t v14 = v124;
    uint64_t v12 = v128;
    uint64_t v10 = v133;
    uint64_t v8 = v139;
    uint64_t v6 = v146;
    uint64_t v4 = v154;
    int v103 = v102;
    uint64_t v2 = v163;
    a1 = v173;
    if (v103)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      unint64_t v176 = 100;
      unint64_t v104 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v104) {
        unint64_t v105 = v104;
      }
      else {
        unint64_t v105 = v176;
      }
      int v106 = &v175[v105];
      unint64_t v107 = v176 - v105;
      if (v176 - v105 >= 0x12) {
        uint64_t v108 = 18;
      }
      else {
        uint64_t v108 = v176 - v105;
      }
      unint64_t v109 = v107 - v108;
      if (v109 >= v109 - 1) {
        uint64_t v110 = v109 - 1;
      }
      else {
        uint64_t v110 = v109;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      unint64_t v17 = (void *)&unk_267771000;
      uint64_t v16 = v121;
      uint64_t v14 = v124;
      uint64_t v12 = v128;
      uint64_t v10 = v133;
      uint64_t v8 = v139;
      uint64_t v6 = v146;
      uint64_t v4 = v154;
      uint64_t v2 = v163;
      a1 = v173;
    }
  }
  uint64_t v18 = v17[41];
  unint64_t v19 = &unk_267771000;
  {
    uint64_t v164 = v2;
    uint64_t v174 = a1;
    uint64_t v147 = v6;
    uint64_t v155 = v4;
    uint64_t v134 = v10;
    uint64_t v140 = v8;
    uint64_t v125 = v14;
    uint64_t v129 = v12;
    uint64_t v120 = v18;
    uint64_t v122 = v16;
    unint64_t v19 = (void *)&unk_267771000;
    uint64_t v18 = v120;
    uint64_t v16 = v122;
    uint64_t v14 = v125;
    uint64_t v12 = v129;
    uint64_t v10 = v134;
    uint64_t v8 = v140;
    uint64_t v6 = v147;
    uint64_t v4 = v155;
    int v112 = v111;
    uint64_t v2 = v164;
    a1 = v174;
    if (v112)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      unint64_t v176 = 86;
      unint64_t v113 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v113) {
        unint64_t v114 = v113;
      }
      else {
        unint64_t v114 = v176;
      }
      int v115 = &v175[v114];
      unint64_t v116 = v176 - v114;
      if (v176 - v114 >= 0x12) {
        uint64_t v117 = 18;
      }
      else {
        uint64_t v117 = v176 - v114;
      }
      unint64_t v118 = v116 - v117;
      if (v118 >= v118 - 1) {
        uint64_t v119 = v118 - 1;
      }
      else {
        uint64_t v119 = v118;
      }
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      unint64_t v19 = (void *)&unk_267771000;
      uint64_t v18 = v120;
      uint64_t v16 = v122;
      uint64_t v14 = v125;
      uint64_t v12 = v129;
      uint64_t v10 = v134;
      uint64_t v8 = v140;
      uint64_t v6 = v147;
      uint64_t v4 = v155;
      uint64_t v2 = v164;
      a1 = v174;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v19[350] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyNResults(a1, (mlir::Operation *)2)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v3)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v4)
    && (uint64_t v6 = a1, mlir::mps::PoolMaxOp::verifyInvariantsImpl((mlir::mps::PoolMaxOp *)&v6)))
  {
    return mlir::mps::verifyPooling4D<mlir::mps::PoolMaxOp>((uint64_t)a1, *(void *)(*((void *)a1 + 9) + 24), 0) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::PoolMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::PowerOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PowerOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PowerOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PowerOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.power", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PowerOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36DA68;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PowerOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PowerOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PowerOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PowerOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PowerOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PowerOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PowerOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PowerOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PowerOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PowerOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::PowerOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PowerOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PowerOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PowerOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    long long v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      unint64_t v11 = v32;
      uint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          unint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      int v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PowerOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PowerOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PowerOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PowerOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PowerOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PowerOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PowerOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PowerOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PowerOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PowerOp>::inferReturnTypes(mlir::Float32Type *a1, uint64_t a2, uint64_t a3, mlir::MLIRContext *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PowerOp>::refineReturnTypes(mlir::Float32Type *a1, uint64_t a2, char a3, mlir::MLIRContext *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PowerOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PowerOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PowerOp>::refineReturnTypes(mlir::Float32Type *a1, uint64_t a2, char a3, mlir::MLIRContext *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    long long v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.power";
    v25[1] = 9;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PowerOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PowerOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PowerOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PowerOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PowerOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::PowerOpGenericAdaptorBase::PowerOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ATan2Op>,mlir::OpTrait::OneResult<mlir::mps::ATan2Op>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ATan2Op>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ATan2Op>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::ATan2Op>,mlir::OpTrait::OpInvariants<mlir::mps::ATan2Op>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ATan2Op>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ATan2Op>,mlir::OpTrait::ResultsBroadcastableShape<mlir::mps::ATan2Op>,mlir::OpTrait::Stitchable<mlir::mps::ATan2Op>,mlir::InferTypeOpInterface::Trait<mlir::mps::ATan2Op>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ATan2Op>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::PowerOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.prune_gradient", 18, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PruningGradientOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C369350;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  unint64_t v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  char v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0) {
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v6 & 2) == 0) {
      llvm::deallocate_buffer(v8[0], v8[1]);
    }
  }
  return v5;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v7 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v7 = 0;
  }
  switch(a4)
  {
    case 8:
      if (*(void *)a3 != 0x7974697372617073) {
        return 0;
      }
      return v7[2];
    case 17:
      if (*(void *)a3 != 0x5F676E696E757270
        || *(void *)(a3 + 8) != 0x7275746375727473
        || *(unsigned char *)(a3 + 16) != 101)
      {
        return 0;
      }
      return v7[1];
    case 14:
      if (*(void *)a3 != 0x5F676E696E757270 || *(void *)(a3 + 6) != 0x63697274656D5F67) {
        return 0;
      }
      return *v7;
    default:
      return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::PruningGradientOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  if (*v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"pruning_metric", 14, *v5);
  }
  uint64_t v6 = v5[1];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"pruning_structure", 17, v6);
  }
  uint64_t v7 = v5[2];
  if (v7)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"sparsity", 8, v7);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::PruningGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::getOpPropertyByteSize()
{
  return 24;
}

mlir::Float32Type *mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  if (a4)
  {
    long long v4 = *a4;
    *(void *)(a3 + 16) = *((void *)a4 + 2);
    *(_OWORD *)a3 = v4;
  }
  else
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
  }
  return mlir::mps::PruningGradientOp::populateDefaultProperties(a2, (mlir::Float32Type **)a3);
}

mlir::Float32Type *mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::Float32Type **a3)
{
  return mlir::mps::PruningGradientOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::PruningGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::mps::PruningGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  *a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  if (*a3 != *a2) {
    return 0;
  }
  if (a3[1] == a2[1]) {
    return a3[2] == a2[2];
  }
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningGradientOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::memref::PrefetchOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::PruningGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::PruningMetricAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::PruningStructureAttr>(a1, v3 + 1)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::FloatAttr>(a1, v3 + 2) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[1]);
  uint64_t v5 = v4[2];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 24);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PruningGradientOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PruningGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  long long v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  long long v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  long long v24 = "mps.prune_gradient";
  uint64_t v25 = 18;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unsigned int v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PruningGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PruningGradientOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PruningGradientOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    uint64_t v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  }
  else {
    uint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v27, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  long long v22 = *(_OWORD *)v10;
  uint64_t v23 = *(void *)(v10 + 16);
  long long v24 = *(_OWORD *)v27;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.prune_gradient", 18, Context);
    char v21 = 1;
  }
  uint64_t v25 = a2;
  uint64_t v26 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v27[0] = result;
  v27[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v27, v25, v26);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v187 = a1;
    v1 = (void *)&unk_267771000;
    int v34 = v33;
    a1 = v187;
    if (v34)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v199 = 83;
      unint64_t v35 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v35) {
        unint64_t v36 = v35;
      }
      else {
        unint64_t v36 = v199;
      }
      unint64_t v37 = &v198[v36];
      unint64_t v38 = v199 - v36;
      if (v199 - v36 >= 0x12) {
        uint64_t v39 = 18;
      }
      else {
        uint64_t v39 = v199 - v36;
      }
      unint64_t v40 = v38 - v39;
      if (v40 >= v40 - 1) {
        uint64_t v41 = v40 - 1;
      }
      else {
        uint64_t v41 = v40;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v37[v39], v41);
      v1 = (void *)&unk_267771000;
      a1 = v187;
    }
  }
  uint64_t v2 = v1[23];
  char v3 = &unk_267771000;
  {
    uint64_t v177 = v2;
    uint64_t v188 = a1;
    char v3 = (void *)&unk_267771000;
    int v43 = v42;
    uint64_t v2 = v177;
    a1 = v188;
    if (v43)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v199 = 81;
      unint64_t v44 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v44) {
        unint64_t v45 = v44;
      }
      else {
        unint64_t v45 = v199;
      }
      unint64_t v46 = &v198[v45];
      unint64_t v47 = v199 - v45;
      if (v199 - v45 >= 0x12) {
        uint64_t v48 = 18;
      }
      else {
        uint64_t v48 = v199 - v45;
      }
      unint64_t v49 = v47 - v48;
      if (v49 >= v49 - 1) {
        uint64_t v50 = v49 - 1;
      }
      else {
        uint64_t v50 = v49;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v46[v48], v50);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v177;
      a1 = v188;
    }
  }
  uint64_t v4 = v3[25];
  unint64_t v5 = &unk_267771000;
  {
    uint64_t v178 = v2;
    uint64_t v189 = a1;
    uint64_t v168 = v4;
    unint64_t v5 = (void *)&unk_267771000;
    uint64_t v4 = v168;
    uint64_t v2 = v178;
    int v52 = v51;
    a1 = v189;
    if (v52)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      unint64_t v199 = 104;
      unint64_t v53 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v53) {
        unint64_t v54 = v53;
      }
      else {
        unint64_t v54 = v199;
      }
      unint64_t v55 = &v198[v54];
      unint64_t v56 = v199 - v54;
      if (v199 - v54 >= 0x12) {
        uint64_t v57 = 18;
      }
      else {
        uint64_t v57 = v199 - v54;
      }
      unint64_t v58 = v56 - v57;
      if (v58 >= v58 - 1) {
        uint64_t v59 = v58 - 1;
      }
      else {
        uint64_t v59 = v58;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v55[v57], v59);
      unint64_t v5 = (void *)&unk_267771000;
      uint64_t v4 = v168;
      uint64_t v2 = v178;
      a1 = v189;
    }
  }
  uint64_t v6 = v5[318];
  uint64_t v7 = &unk_267770000;
  {
    uint64_t v179 = v2;
    uint64_t v190 = a1;
    uint64_t v169 = v4;
    uint64_t v160 = v6;
    uint64_t v7 = (void *)&unk_267770000;
    uint64_t v6 = v160;
    uint64_t v4 = v169;
    uint64_t v2 = v179;
    int v61 = v60;
    a1 = v190;
    if (v61)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v199 = 86;
      unint64_t v62 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v62) {
        unint64_t v63 = v62;
      }
      else {
        unint64_t v63 = v199;
      }
      unint64_t v64 = &v198[v63];
      unint64_t v65 = v199 - v63;
      if (v199 - v63 >= 0x12) {
        uint64_t v66 = 18;
      }
      else {
        uint64_t v66 = v199 - v63;
      }
      unint64_t v67 = v65 - v66;
      if (v67 >= v67 - 1) {
        uint64_t v68 = v67 - 1;
      }
      else {
        uint64_t v68 = v67;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v64[v66], v68);
      uint64_t v7 = (void *)&unk_267770000;
      uint64_t v6 = v160;
      uint64_t v4 = v169;
      uint64_t v2 = v179;
      a1 = v190;
    }
  }
  uint64_t v8 = v7[431];
  unint64_t v9 = &unk_267771000;
  {
    uint64_t v180 = v2;
    uint64_t v191 = a1;
    uint64_t v170 = v4;
    uint64_t v153 = v8;
    uint64_t v161 = v6;
    unint64_t v9 = (void *)&unk_267771000;
    uint64_t v8 = v153;
    uint64_t v6 = v161;
    uint64_t v4 = v170;
    uint64_t v2 = v180;
    int v70 = v69;
    a1 = v191;
    if (v70)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      unint64_t v199 = 90;
      unint64_t v71 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v71) {
        unint64_t v72 = v71;
      }
      else {
        unint64_t v72 = v199;
      }
      unint64_t v73 = &v198[v72];
      unint64_t v74 = v199 - v72;
      if (v199 - v72 >= 0x12) {
        uint64_t v75 = 18;
      }
      else {
        uint64_t v75 = v199 - v72;
      }
      unint64_t v76 = v74 - v75;
      if (v76 >= v76 - 1) {
        uint64_t v77 = v76 - 1;
      }
      else {
        uint64_t v77 = v76;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v73[v75], v77);
      unint64_t v9 = (void *)&unk_267771000;
      uint64_t v8 = v153;
      uint64_t v6 = v161;
      uint64_t v4 = v170;
      uint64_t v2 = v180;
      a1 = v191;
    }
  }
  uint64_t v10 = v9[89];
  unint64_t v11 = &unk_267770000;
  {
    uint64_t v181 = v2;
    uint64_t v192 = a1;
    uint64_t v171 = v4;
    uint64_t v154 = v8;
    uint64_t v162 = v6;
    uint64_t v147 = v10;
    unint64_t v11 = (void *)&unk_267770000;
    uint64_t v10 = v147;
    uint64_t v8 = v154;
    uint64_t v6 = v162;
    uint64_t v4 = v171;
    uint64_t v2 = v181;
    int v79 = v78;
    a1 = v192;
    if (v79)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v199 = 84;
      unint64_t v80 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v80) {
        unint64_t v81 = v80;
      }
      else {
        unint64_t v81 = v199;
      }
      unint64_t v82 = &v198[v81];
      unint64_t v83 = v199 - v81;
      if (v199 - v81 >= 0x12) {
        uint64_t v84 = 18;
      }
      else {
        uint64_t v84 = v199 - v81;
      }
      unint64_t v85 = v83 - v84;
      if (v85 >= v85 - 1) {
        uint64_t v86 = v85 - 1;
      }
      else {
        uint64_t v86 = v85;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v82[v84], v86);
      unint64_t v11 = (void *)&unk_267770000;
      uint64_t v10 = v147;
      uint64_t v8 = v154;
      uint64_t v6 = v162;
      uint64_t v4 = v171;
      uint64_t v2 = v181;
      a1 = v192;
    }
  }
  uint64_t v12 = v11[435];
  char v13 = &unk_267771000;
  {
    uint64_t v182 = v2;
    uint64_t v193 = a1;
    uint64_t v172 = v4;
    uint64_t v155 = v8;
    uint64_t v163 = v6;
    uint64_t v142 = v12;
    uint64_t v148 = v10;
    char v13 = (void *)&unk_267771000;
    uint64_t v12 = v142;
    uint64_t v10 = v148;
    uint64_t v8 = v155;
    uint64_t v6 = v163;
    uint64_t v4 = v172;
    uint64_t v2 = v182;
    int v88 = v87;
    a1 = v193;
    if (v88)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v199 = 89;
      unint64_t v89 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v89) {
        unint64_t v90 = v89;
      }
      else {
        unint64_t v90 = v199;
      }
      unint64_t v91 = &v198[v90];
      unint64_t v92 = v199 - v90;
      if (v199 - v90 >= 0x12) {
        uint64_t v93 = 18;
      }
      else {
        uint64_t v93 = v199 - v90;
      }
      unint64_t v94 = v92 - v93;
      if (v94 >= v94 - 1) {
        uint64_t v95 = v94 - 1;
      }
      else {
        uint64_t v95 = v94;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v91[v93], v95);
      char v13 = (void *)&unk_267771000;
      uint64_t v12 = v142;
      uint64_t v10 = v148;
      uint64_t v8 = v155;
      uint64_t v6 = v163;
      uint64_t v4 = v172;
      uint64_t v2 = v182;
      a1 = v193;
    }
  }
  uint64_t v14 = v13[320];
  unint64_t v15 = &unk_267771000;
  {
    uint64_t v183 = v2;
    uint64_t v194 = a1;
    uint64_t v173 = v4;
    uint64_t v156 = v8;
    uint64_t v164 = v6;
    uint64_t v143 = v12;
    uint64_t v149 = v10;
    uint64_t v138 = v14;
    unint64_t v15 = (void *)&unk_267771000;
    uint64_t v14 = v138;
    uint64_t v12 = v143;
    uint64_t v10 = v149;
    uint64_t v8 = v156;
    uint64_t v6 = v164;
    uint64_t v4 = v173;
    uint64_t v2 = v183;
    int v97 = v96;
    a1 = v194;
    if (v97)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultType<Empty>]";
      unint64_t v199 = 97;
      unint64_t v98 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v98) {
        unint64_t v99 = v98;
      }
      else {
        unint64_t v99 = v199;
      }
      unint64_t v100 = &v198[v99];
      unint64_t v101 = v199 - v99;
      if (v199 - v99 >= 0x12) {
        uint64_t v102 = 18;
      }
      else {
        uint64_t v102 = v199 - v99;
      }
      unint64_t v103 = v101 - v102;
      if (v103 >= v103 - 1) {
        uint64_t v104 = v103 - 1;
      }
      else {
        uint64_t v104 = v103;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v100[v102], v104);
      unint64_t v15 = (void *)&unk_267771000;
      uint64_t v14 = v138;
      uint64_t v12 = v143;
      uint64_t v10 = v149;
      uint64_t v8 = v156;
      uint64_t v6 = v164;
      uint64_t v4 = v173;
      uint64_t v2 = v183;
      a1 = v194;
    }
  }
  uint64_t v16 = v15[328];
  unint64_t v17 = &unk_267771000;
  {
    uint64_t v184 = v2;
    uint64_t v195 = a1;
    uint64_t v174 = v4;
    uint64_t v157 = v8;
    uint64_t v165 = v6;
    uint64_t v144 = v12;
    uint64_t v150 = v10;
    uint64_t v135 = v16;
    uint64_t v139 = v14;
    unint64_t v17 = (void *)&unk_267771000;
    uint64_t v16 = v135;
    uint64_t v14 = v139;
    uint64_t v12 = v144;
    uint64_t v10 = v150;
    uint64_t v8 = v157;
    uint64_t v6 = v165;
    uint64_t v4 = v174;
    uint64_t v2 = v184;
    int v106 = v105;
    a1 = v195;
    if (v106)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v199 = 93;
      unint64_t v107 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v107) {
        unint64_t v108 = v107;
      }
      else {
        unint64_t v108 = v199;
      }
      unint64_t v109 = &v198[v108];
      unint64_t v110 = v199 - v108;
      if (v199 - v108 >= 0x12) {
        uint64_t v111 = 18;
      }
      else {
        uint64_t v111 = v199 - v108;
      }
      unint64_t v112 = v110 - v111;
      if (v112 >= v112 - 1) {
        uint64_t v113 = v112 - 1;
      }
      else {
        uint64_t v113 = v112;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v109[v111], v113);
      unint64_t v17 = (void *)&unk_267771000;
      uint64_t v16 = v135;
      uint64_t v14 = v139;
      uint64_t v12 = v144;
      uint64_t v10 = v150;
      uint64_t v8 = v157;
      uint64_t v6 = v165;
      uint64_t v4 = v174;
      uint64_t v2 = v184;
      a1 = v195;
    }
  }
  uint64_t v18 = v17[31];
  uint64_t v19 = &unk_267771000;
  {
    uint64_t v185 = v2;
    uint64_t v196 = a1;
    uint64_t v175 = v4;
    uint64_t v158 = v8;
    uint64_t v166 = v6;
    uint64_t v145 = v12;
    uint64_t v151 = v10;
    uint64_t v136 = v16;
    uint64_t v140 = v14;
    uint64_t v133 = v18;
    uint64_t v19 = (void *)&unk_267771000;
    uint64_t v18 = v133;
    uint64_t v16 = v136;
    uint64_t v14 = v140;
    uint64_t v12 = v145;
    uint64_t v10 = v151;
    uint64_t v8 = v158;
    uint64_t v6 = v166;
    uint64_t v4 = v175;
    uint64_t v2 = v185;
    int v115 = v114;
    a1 = v196;
    if (v115)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v199 = 90;
      unint64_t v116 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v116) {
        unint64_t v117 = v116;
      }
      else {
        unint64_t v117 = v199;
      }
      unint64_t v118 = &v198[v117];
      unint64_t v119 = v199 - v117;
      if (v199 - v117 >= 0x12) {
        uint64_t v120 = 18;
      }
      else {
        uint64_t v120 = v199 - v117;
      }
      unint64_t v121 = v119 - v120;
      if (v121 >= v121 - 1) {
        uint64_t v122 = v121 - 1;
      }
      else {
        uint64_t v122 = v121;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v118[v120], v122);
      uint64_t v19 = (void *)&unk_267771000;
      uint64_t v18 = v133;
      uint64_t v16 = v136;
      uint64_t v14 = v140;
      uint64_t v12 = v145;
      uint64_t v10 = v151;
      uint64_t v8 = v158;
      uint64_t v6 = v166;
      uint64_t v4 = v175;
      uint64_t v2 = v185;
      a1 = v196;
    }
  }
  uint64_t v20 = v19[37];
  char v21 = &unk_267771000;
  {
    uint64_t v186 = v2;
    uint64_t v197 = a1;
    uint64_t v176 = v4;
    uint64_t v159 = v8;
    uint64_t v167 = v6;
    uint64_t v146 = v12;
    uint64_t v152 = v10;
    uint64_t v137 = v16;
    uint64_t v141 = v14;
    uint64_t v132 = v20;
    uint64_t v134 = v18;
    char v21 = (void *)&unk_267771000;
    uint64_t v20 = v132;
    uint64_t v18 = v134;
    uint64_t v16 = v137;
    uint64_t v14 = v141;
    uint64_t v12 = v146;
    uint64_t v10 = v152;
    uint64_t v8 = v159;
    uint64_t v6 = v167;
    uint64_t v4 = v176;
    uint64_t v2 = v186;
    int v124 = v123;
    a1 = v197;
    if (v124)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      unint64_t v199 = 100;
      unint64_t v125 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v125) {
        unint64_t v126 = v125;
      }
      else {
        unint64_t v126 = v199;
      }
      uint64_t v127 = &v198[v126];
      unint64_t v128 = v199 - v126;
      if (v199 - v126 >= 0x12) {
        uint64_t v129 = 18;
      }
      else {
        uint64_t v129 = v199 - v126;
      }
      unint64_t v130 = v128 - v129;
      if (v130 >= v130 - 1) {
        uint64_t v131 = v130 - 1;
      }
      else {
        uint64_t v131 = v130;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v127[v129], v131);
      char v21 = (void *)&unk_267771000;
      uint64_t v20 = v132;
      uint64_t v18 = v134;
      uint64_t v16 = v137;
      uint64_t v14 = v141;
      uint64_t v12 = v146;
      uint64_t v10 = v152;
      uint64_t v8 = v159;
      uint64_t v6 = v167;
      uint64_t v4 = v176;
      uint64_t v2 = v186;
      a1 = v197;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v21[41] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::PruningGradientOp>,mlir::OpTrait::OneResult<mlir::mps::PruningGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::PruningGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::PruningGradientOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::PruningGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::PruningGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::PruningGradientOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::PruningGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::PruningGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::PruningGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::PruningGradientOp>>(a1, a2))return 0; {
  uint64_t v4 = a1;
  }
  return mlir::mps::PruningOp::verify((mlir::mps::PruningOp *)&v4) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::PruningGradientOp>,mlir::OpTrait::OneResult<mlir::mps::PruningGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::PruningGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::PruningGradientOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::PruningGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::PruningGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::PruningGradientOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::PruningGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::PruningGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::PruningGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::PruningGradientOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (uint64_t v7 = a1, mlir::mps::PruningGradientOp::verifyInvariantsImpl((mlir::mps::PruningGradientOp *)&v7)))
  {
    return mlir::OpTrait::impl::verifySameOperandsAndResultType(a1, v5) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::PruningGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.prune", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PruningOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36F1D8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  unint64_t v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  char v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0) {
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v6 & 2) == 0) {
      llvm::deallocate_buffer(v8[0], v8[1]);
    }
  }
  return v5;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                       + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v7 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v7 = 0;
  }
  switch(a4)
  {
    case 8:
      if (*(void *)a3 != 0x7974697372617073) {
        return 0;
      }
      return v7[2];
    case 17:
      if (*(void *)a3 != 0x5F676E696E757270
        || *(void *)(a3 + 8) != 0x7275746375727473
        || *(unsigned char *)(a3 + 16) != 101)
      {
        return 0;
      }
      return v7[1];
    case 14:
      if (*(void *)a3 != 0x5F676E696E757270 || *(void *)(a3 + 6) != 0x63697274656D5F67) {
        return 0;
      }
      return *v7;
    default:
      return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::PruningGradientOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  if (*v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"pruning_metric", 14, *v5);
  }
  uint64_t v6 = v5[1];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"pruning_structure", 17, v6);
  }
  uint64_t v7 = v5[2];
  if (v7)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"sparsity", 8, v7);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::PruningGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::getOpPropertyByteSize()
{
  return 24;
}

mlir::Float32Type *mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  if (a4)
  {
    long long v4 = *a4;
    *(void *)(a3 + 16) = *((void *)a4 + 2);
    *(_OWORD *)a3 = v4;
  }
  else
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
  }
  return mlir::mps::PruningGradientOp::populateDefaultProperties(a2, (mlir::Float32Type **)a3);
}

mlir::Float32Type *mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::Float32Type **a3)
{
  return mlir::mps::PruningGradientOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::PruningGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::mps::PruningGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  *a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  if (*a3 != *a2) {
    return 0;
  }
  if (a3[1] == a2[1]) {
    return a3[2] == a2[2];
  }
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::PruningOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::memref::PrefetchOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::PruningOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::PruningMetricAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::PruningStructureAttr>(a1, v3 + 1)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::FloatAttr>(a1, v3 + 2) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[1]);
  uint64_t v5 = v4[2];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 24);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PruningOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::PruningOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  long long v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  uint64_t v26 = &v24;
  long long v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  long long v24 = "mps.prune";
  uint64_t v25 = 9;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unsigned int v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::PruningOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PruningOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::PruningOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    uint64_t v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  }
  else {
    uint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v27, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  long long v22 = *(_OWORD *)v10;
  uint64_t v23 = *(void *)(v10 + 16);
  long long v24 = *(_OWORD *)v27;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.prune", 9, Context);
    char v21 = 1;
  }
  uint64_t v25 = a2;
  uint64_t v26 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v27[0] = result;
  v27[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v27, v25, v26);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v187 = a1;
    v1 = (void *)&unk_267771000;
    int v34 = v33;
    a1 = v187;
    if (v34)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v199 = 83;
      unint64_t v35 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v35) {
        unint64_t v36 = v35;
      }
      else {
        unint64_t v36 = v199;
      }
      unint64_t v37 = &v198[v36];
      unint64_t v38 = v199 - v36;
      if (v199 - v36 >= 0x12) {
        uint64_t v39 = 18;
      }
      else {
        uint64_t v39 = v199 - v36;
      }
      unint64_t v40 = v38 - v39;
      if (v40 >= v40 - 1) {
        uint64_t v41 = v40 - 1;
      }
      else {
        uint64_t v41 = v40;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v37[v39], v41);
      v1 = (void *)&unk_267771000;
      a1 = v187;
    }
  }
  uint64_t v2 = v1[23];
  char v3 = &unk_267771000;
  {
    uint64_t v177 = v2;
    uint64_t v188 = a1;
    char v3 = (void *)&unk_267771000;
    int v43 = v42;
    uint64_t v2 = v177;
    a1 = v188;
    if (v43)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v199 = 81;
      unint64_t v44 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v44) {
        unint64_t v45 = v44;
      }
      else {
        unint64_t v45 = v199;
      }
      unint64_t v46 = &v198[v45];
      unint64_t v47 = v199 - v45;
      if (v199 - v45 >= 0x12) {
        uint64_t v48 = 18;
      }
      else {
        uint64_t v48 = v199 - v45;
      }
      unint64_t v49 = v47 - v48;
      if (v49 >= v49 - 1) {
        uint64_t v50 = v49 - 1;
      }
      else {
        uint64_t v50 = v49;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v46[v48], v50);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v177;
      a1 = v188;
    }
  }
  uint64_t v4 = v3[25];
  unint64_t v5 = &unk_267771000;
  {
    uint64_t v178 = v2;
    uint64_t v189 = a1;
    uint64_t v168 = v4;
    unint64_t v5 = (void *)&unk_267771000;
    uint64_t v4 = v168;
    uint64_t v2 = v178;
    int v52 = v51;
    a1 = v189;
    if (v52)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      unint64_t v199 = 104;
      unint64_t v53 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v53) {
        unint64_t v54 = v53;
      }
      else {
        unint64_t v54 = v199;
      }
      unint64_t v55 = &v198[v54];
      unint64_t v56 = v199 - v54;
      if (v199 - v54 >= 0x12) {
        uint64_t v57 = 18;
      }
      else {
        uint64_t v57 = v199 - v54;
      }
      unint64_t v58 = v56 - v57;
      if (v58 >= v58 - 1) {
        uint64_t v59 = v58 - 1;
      }
      else {
        uint64_t v59 = v58;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v55[v57], v59);
      unint64_t v5 = (void *)&unk_267771000;
      uint64_t v4 = v168;
      uint64_t v2 = v178;
      a1 = v189;
    }
  }
  uint64_t v6 = v5[318];
  uint64_t v7 = &unk_267770000;
  {
    uint64_t v179 = v2;
    uint64_t v190 = a1;
    uint64_t v169 = v4;
    uint64_t v160 = v6;
    uint64_t v7 = (void *)&unk_267770000;
    uint64_t v6 = v160;
    uint64_t v4 = v169;
    uint64_t v2 = v179;
    int v61 = v60;
    a1 = v190;
    if (v61)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v199 = 86;
      unint64_t v62 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v62) {
        unint64_t v63 = v62;
      }
      else {
        unint64_t v63 = v199;
      }
      unint64_t v64 = &v198[v63];
      unint64_t v65 = v199 - v63;
      if (v199 - v63 >= 0x12) {
        uint64_t v66 = 18;
      }
      else {
        uint64_t v66 = v199 - v63;
      }
      unint64_t v67 = v65 - v66;
      if (v67 >= v67 - 1) {
        uint64_t v68 = v67 - 1;
      }
      else {
        uint64_t v68 = v67;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v64[v66], v68);
      uint64_t v7 = (void *)&unk_267770000;
      uint64_t v6 = v160;
      uint64_t v4 = v169;
      uint64_t v2 = v179;
      a1 = v190;
    }
  }
  uint64_t v8 = v7[431];
  unint64_t v9 = &unk_267771000;
  {
    uint64_t v180 = v2;
    uint64_t v191 = a1;
    uint64_t v170 = v4;
    uint64_t v153 = v8;
    uint64_t v161 = v6;
    unint64_t v9 = (void *)&unk_267771000;
    uint64_t v8 = v153;
    uint64_t v6 = v161;
    uint64_t v4 = v170;
    uint64_t v2 = v180;
    int v70 = v69;
    a1 = v191;
    if (v70)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      unint64_t v199 = 82;
      unint64_t v71 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v71) {
        unint64_t v72 = v71;
      }
      else {
        unint64_t v72 = v199;
      }
      unint64_t v73 = &v198[v72];
      unint64_t v74 = v199 - v72;
      if (v199 - v72 >= 0x12) {
        uint64_t v75 = 18;
      }
      else {
        uint64_t v75 = v199 - v72;
      }
      unint64_t v76 = v74 - v75;
      if (v76 >= v76 - 1) {
        uint64_t v77 = v76 - 1;
      }
      else {
        uint64_t v77 = v76;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v73[v75], v77);
      unint64_t v9 = (void *)&unk_267771000;
      uint64_t v8 = v153;
      uint64_t v6 = v161;
      uint64_t v4 = v170;
      uint64_t v2 = v180;
      a1 = v191;
    }
  }
  uint64_t v10 = v9[29];
  unint64_t v11 = &unk_267770000;
  {
    uint64_t v181 = v2;
    uint64_t v192 = a1;
    uint64_t v171 = v4;
    uint64_t v154 = v8;
    uint64_t v162 = v6;
    uint64_t v147 = v10;
    unint64_t v11 = (void *)&unk_267770000;
    uint64_t v10 = v147;
    uint64_t v8 = v154;
    uint64_t v6 = v162;
    uint64_t v4 = v171;
    uint64_t v2 = v181;
    int v79 = v78;
    a1 = v192;
    if (v79)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v199 = 84;
      unint64_t v80 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v80) {
        unint64_t v81 = v80;
      }
      else {
        unint64_t v81 = v199;
      }
      unint64_t v82 = &v198[v81];
      unint64_t v83 = v199 - v81;
      if (v199 - v81 >= 0x12) {
        uint64_t v84 = 18;
      }
      else {
        uint64_t v84 = v199 - v81;
      }
      unint64_t v85 = v83 - v84;
      if (v85 >= v85 - 1) {
        uint64_t v86 = v85 - 1;
      }
      else {
        uint64_t v86 = v85;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v82[v84], v86);
      unint64_t v11 = (void *)&unk_267770000;
      uint64_t v10 = v147;
      uint64_t v8 = v154;
      uint64_t v6 = v162;
      uint64_t v4 = v171;
      uint64_t v2 = v181;
      a1 = v192;
    }
  }
  uint64_t v12 = v11[435];
  char v13 = &unk_267771000;
  {
    uint64_t v182 = v2;
    uint64_t v193 = a1;
    uint64_t v172 = v4;
    uint64_t v155 = v8;
    uint64_t v163 = v6;
    uint64_t v142 = v12;
    uint64_t v148 = v10;
    char v13 = (void *)&unk_267771000;
    uint64_t v12 = v142;
    uint64_t v10 = v148;
    uint64_t v8 = v155;
    uint64_t v6 = v163;
    uint64_t v4 = v172;
    uint64_t v2 = v182;
    int v88 = v87;
    a1 = v193;
    if (v88)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v199 = 89;
      unint64_t v89 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v89) {
        unint64_t v90 = v89;
      }
      else {
        unint64_t v90 = v199;
      }
      unint64_t v91 = &v198[v90];
      unint64_t v92 = v199 - v90;
      if (v199 - v90 >= 0x12) {
        uint64_t v93 = 18;
      }
      else {
        uint64_t v93 = v199 - v90;
      }
      unint64_t v94 = v92 - v93;
      if (v94 >= v94 - 1) {
        uint64_t v95 = v94 - 1;
      }
      else {
        uint64_t v95 = v94;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v91[v93], v95);
      char v13 = (void *)&unk_267771000;
      uint64_t v12 = v142;
      uint64_t v10 = v148;
      uint64_t v8 = v155;
      uint64_t v6 = v163;
      uint64_t v4 = v172;
      uint64_t v2 = v182;
      a1 = v193;
    }
  }
  uint64_t v14 = v13[320];
  unint64_t v15 = &unk_267771000;
  {
    uint64_t v183 = v2;
    uint64_t v194 = a1;
    uint64_t v173 = v4;
    uint64_t v156 = v8;
    uint64_t v164 = v6;
    uint64_t v143 = v12;
    uint64_t v149 = v10;
    uint64_t v138 = v14;
    unint64_t v15 = (void *)&unk_267771000;
    uint64_t v14 = v138;
    uint64_t v12 = v143;
    uint64_t v10 = v149;
    uint64_t v8 = v156;
    uint64_t v6 = v164;
    uint64_t v4 = v173;
    uint64_t v2 = v183;
    int v97 = v96;
    a1 = v194;
    if (v97)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultType<Empty>]";
      unint64_t v199 = 97;
      unint64_t v98 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v98) {
        unint64_t v99 = v98;
      }
      else {
        unint64_t v99 = v199;
      }
      unint64_t v100 = &v198[v99];
      unint64_t v101 = v199 - v99;
      if (v199 - v99 >= 0x12) {
        uint64_t v102 = 18;
      }
      else {
        uint64_t v102 = v199 - v99;
      }
      unint64_t v103 = v101 - v102;
      if (v103 >= v103 - 1) {
        uint64_t v104 = v103 - 1;
      }
      else {
        uint64_t v104 = v103;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v100[v102], v104);
      unint64_t v15 = (void *)&unk_267771000;
      uint64_t v14 = v138;
      uint64_t v12 = v143;
      uint64_t v10 = v149;
      uint64_t v8 = v156;
      uint64_t v6 = v164;
      uint64_t v4 = v173;
      uint64_t v2 = v183;
      a1 = v194;
    }
  }
  uint64_t v16 = v15[328];
  unint64_t v17 = &unk_267771000;
  {
    uint64_t v184 = v2;
    uint64_t v195 = a1;
    uint64_t v174 = v4;
    uint64_t v157 = v8;
    uint64_t v165 = v6;
    uint64_t v144 = v12;
    uint64_t v150 = v10;
    uint64_t v135 = v16;
    uint64_t v139 = v14;
    unint64_t v17 = (void *)&unk_267771000;
    uint64_t v16 = v135;
    uint64_t v14 = v139;
    uint64_t v12 = v144;
    uint64_t v10 = v150;
    uint64_t v8 = v157;
    uint64_t v6 = v165;
    uint64_t v4 = v174;
    uint64_t v2 = v184;
    int v106 = v105;
    a1 = v195;
    if (v106)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v199 = 93;
      unint64_t v107 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v107) {
        unint64_t v108 = v107;
      }
      else {
        unint64_t v108 = v199;
      }
      unint64_t v109 = &v198[v108];
      unint64_t v110 = v199 - v108;
      if (v199 - v108 >= 0x12) {
        uint64_t v111 = 18;
      }
      else {
        uint64_t v111 = v199 - v108;
      }
      unint64_t v112 = v110 - v111;
      if (v112 >= v112 - 1) {
        uint64_t v113 = v112 - 1;
      }
      else {
        uint64_t v113 = v112;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v109[v111], v113);
      unint64_t v17 = (void *)&unk_267771000;
      uint64_t v16 = v135;
      uint64_t v14 = v139;
      uint64_t v12 = v144;
      uint64_t v10 = v150;
      uint64_t v8 = v157;
      uint64_t v6 = v165;
      uint64_t v4 = v174;
      uint64_t v2 = v184;
      a1 = v195;
    }
  }
  uint64_t v18 = v17[31];
  uint64_t v19 = &unk_267771000;
  {
    uint64_t v185 = v2;
    uint64_t v196 = a1;
    uint64_t v175 = v4;
    uint64_t v158 = v8;
    uint64_t v166 = v6;
    uint64_t v145 = v12;
    uint64_t v151 = v10;
    uint64_t v136 = v16;
    uint64_t v140 = v14;
    uint64_t v133 = v18;
    uint64_t v19 = (void *)&unk_267771000;
    uint64_t v18 = v133;
    uint64_t v16 = v136;
    uint64_t v14 = v140;
    uint64_t v12 = v145;
    uint64_t v10 = v151;
    uint64_t v8 = v158;
    uint64_t v6 = v166;
    uint64_t v4 = v175;
    uint64_t v2 = v185;
    int v115 = v114;
    a1 = v196;
    if (v115)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v199 = 90;
      unint64_t v116 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v116) {
        unint64_t v117 = v116;
      }
      else {
        unint64_t v117 = v199;
      }
      unint64_t v118 = &v198[v117];
      unint64_t v119 = v199 - v117;
      if (v199 - v117 >= 0x12) {
        uint64_t v120 = 18;
      }
      else {
        uint64_t v120 = v199 - v117;
      }
      unint64_t v121 = v119 - v120;
      if (v121 >= v121 - 1) {
        uint64_t v122 = v121 - 1;
      }
      else {
        uint64_t v122 = v121;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v118[v120], v122);
      uint64_t v19 = (void *)&unk_267771000;
      uint64_t v18 = v133;
      uint64_t v16 = v136;
      uint64_t v14 = v140;
      uint64_t v12 = v145;
      uint64_t v10 = v151;
      uint64_t v8 = v158;
      uint64_t v6 = v166;
      uint64_t v4 = v175;
      uint64_t v2 = v185;
      a1 = v196;
    }
  }
  uint64_t v20 = v19[37];
  char v21 = &unk_267771000;
  {
    uint64_t v186 = v2;
    uint64_t v197 = a1;
    uint64_t v176 = v4;
    uint64_t v159 = v8;
    uint64_t v167 = v6;
    uint64_t v146 = v12;
    uint64_t v152 = v10;
    uint64_t v137 = v16;
    uint64_t v141 = v14;
    uint64_t v132 = v20;
    uint64_t v134 = v18;
    char v21 = (void *)&unk_267771000;
    uint64_t v20 = v132;
    uint64_t v18 = v134;
    uint64_t v16 = v137;
    uint64_t v14 = v141;
    uint64_t v12 = v146;
    uint64_t v10 = v152;
    uint64_t v8 = v159;
    uint64_t v6 = v167;
    uint64_t v4 = v176;
    uint64_t v2 = v186;
    int v124 = v123;
    a1 = v197;
    if (v124)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      unint64_t v199 = 100;
      unint64_t v125 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v125) {
        unint64_t v126 = v125;
      }
      else {
        unint64_t v126 = v199;
      }
      uint64_t v127 = &v198[v126];
      unint64_t v128 = v199 - v126;
      if (v199 - v126 >= 0x12) {
        uint64_t v129 = 18;
      }
      else {
        uint64_t v129 = v199 - v126;
      }
      unint64_t v130 = v128 - v129;
      if (v130 >= v130 - 1) {
        uint64_t v131 = v130 - 1;
      }
      else {
        uint64_t v131 = v130;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v127[v129], v131);
      char v21 = (void *)&unk_267771000;
      uint64_t v20 = v132;
      uint64_t v18 = v134;
      uint64_t v16 = v137;
      uint64_t v14 = v141;
      uint64_t v12 = v146;
      uint64_t v10 = v152;
      uint64_t v8 = v159;
      uint64_t v6 = v167;
      uint64_t v4 = v176;
      uint64_t v2 = v186;
      a1 = v197;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v21[41] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneOperand(a1, v5)) {
    return 0;
  }
  uint64_t v8 = a1;
  if (!mlir::mps::PruningOp::verifyInvariantsImpl((mlir::mps::PruningOp *)&v8)
    || !mlir::OpTrait::impl::verifySameOperandsAndResultType(a1, v6))
  {
    return 0;
  }
  uint64_t v8 = a1;
  return mlir::mps::PruningOp::verify((mlir::mps::PruningOp *)&v8) != 0;
}

BOOL mlir::Op<mlir::mps::PruningOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.quantize", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::QuantizeOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C364E90;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v7 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v7 = 0;
  }
  if (a4 == 5)
  {
    if (*(_DWORD *)a3 == 1887007844 && *(unsigned char *)(a3 + 4) == 101) {
      return v7[1];
    }
    return 0;
  }
  if (a4 != 4 || *(_DWORD *)a3 != 1936291937) {
    return 0;
  }
  return *v7;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v11);
  if (v7 == 5)
  {
    if (*(_DWORD *)result == 1887007844 && *(unsigned char *)(result + 4) == 101)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id) {
          uint64_t v9 = a4;
        }
        else {
          uint64_t v9 = 0;
        }
        v5[1] = v9;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else if (v7 == 4 && *(_DWORD *)result == 1936291937)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
        uint64_t v10 = a4;
      }
      else {
        uint64_t v10 = 0;
      }
      *uint64_t v5 = v10;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  if (*v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"axis", 4, *v5);
  }
  uint64_t v6 = v5[1];
  if (v6)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"dtype", 5, v6);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9 = (void **)mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  BOOL result = 0;
  if (!v9
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v9, (void **)"axis", (const char *)4, a4, a5))
  {
    uint64_t v10 = mlir::NamedAttrList::get(a3, *(void *)(*(void *)(a2 + 96) + 8));
    if (!v10
      || mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v10, (void **)"dtype", (const char *)5, a4, a5))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::getOpPropertyByteSize()
{
  return 16;
}

void mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    *(_OWORD *)a3 = *a4;
  }
  else
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::DequantizeOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::DequantizeOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2 && a3[1] == a2[1];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::QuantizeOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::ModuleOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::QuantizeOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::TypeAttr>(a1, v3 + 1) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *v4);
  uint64_t v5 = v4[1];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::QuantizeOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::QuantizeOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::QuantizeOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::QuantizeOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    long long v24 = v23;
    uint64_t v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.quantize";
    v25[1] = 12;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::QuantizeOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::QuantizeOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::QuantizeOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    unint64_t v10 = (long long *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  }
  else {
    unint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  long long v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.quantize", 12, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)3)) {
    return 0;
  }
  unint64_t v6 = (void **)a1;
  if (!mlir::mps::QuantizeOp::verifyInvariantsImpl(&v6)) {
    return 0;
  }
  unint64_t v6 = (void **)a1;
  return mlir::mps::QuantizeOp::verify((mlir::mps::QuantizeOp *)&v6);
}

BOOL mlir::Op<mlir::mps::QuantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.random_normal", 17, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RandomNormalOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C3674D8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::getInherentAttr(uint64_t a1, uint64_t a2, _DWORD *a3, size_t a4)
{
  int Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::mps::RandomNormalOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::RandomNormalOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  if (*v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"mean", 4, *v5);
  }
  uint64_t v6 = v5[1];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"result_element_type", 19, v6);
  }
  uint64_t v7 = v5[2];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"sampling_method", 15, v7);
  }
  uint64_t v8 = v5[3];
  if (v8)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"std_dev", 7, v8);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::RandomNormalOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::getOpPropertyByteSize()
{
  return 32;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    long long v4 = a4[1];
    *(_OWORD *)a3 = *a4;
    *(_OWORD *)(a3 + 16) = v4;
  }
  else
  {
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
  }
  return mlir::mps::RandomNormalOp::populateDefaultProperties(a2, (mlir::MLIRContext **)a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::mps::RandomNormalOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::RandomNormalOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  int Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::mps::RandomNormalOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::copyProperties(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  long long v4 = *(_OWORD *)(a3 + 16);
  *a2 = *(_OWORD *)a3;
  a2[1] = v4;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  if (*a3 != *a2) {
    return 0;
  }
  if (a3[1] != a2[1]) {
    return 0;
  }
  if (a3[2] == a2[2]) {
    return a3[3] == a2[3];
  }
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomNormalOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::pdl_interp::FuncOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::RandomNormalOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::FloatAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::TypeAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::NormalSamplingMethodAttr>(a1, v3 + 2)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::FloatAttr>(a1, v3 + 3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 16))(a3, v4[1]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[2]);
  uint64_t v5 = v4[3];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 24);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, long long *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::RandomNormalOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, long long *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::RandomNormalOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::RandomNormalOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, long long *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::RandomNormalOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    uint64_t v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.random_normal";
    v25[1] = 17;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RandomNormalOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::RandomNormalOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::RandomNormalOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    unint64_t v10 = (long long *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  }
  else {
    unint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v28, v12, v11);
  uint64_t v20 = v8;
  v21[0] = 0;
  char v22 = 0;
  long long v13 = v10[1];
  long long v23 = *v10;
  long long v24 = v13;
  long long v25 = *(_OWORD *)v28;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22) {
      char v22 = 0;
    }
    mlir::OperationName::OperationName(v21, "mps.random_normal", 17, Context);
    char v22 = 1;
  }
  uint64_t v26 = a2;
  uint64_t v27 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v28[0] = result;
  v28[1] = v16;
  if (result)
  {
    unint64_t v17 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v28, v26, v27);
    if (v17 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v18 = v17;
      if (a1 - 16 != (v17 & ((uint64_t)(v17 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v19 = *(unsigned int *)(a4 + 8);
        if (v19 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v19 + 1, 8);
          LODWORD(v19) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v19) = v18;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2))
  {
    return 0;
  }
  unint64_t v6 = a1;
  return mlir::mps::RandomNormalOp::verifyInvariantsImpl((mlir::mps::RandomNormalOp *)&v6);
}

BOOL mlir::Op<mlir::mps::RandomNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomTruncatedNormalOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RandomTruncatedNormalOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomTruncatedNormalOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RandomTruncatedNormalOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.random_truncated_normal", 27, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RandomTruncatedNormalOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36AEA8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::mps::RandomTruncatedNormalOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::RandomTruncatedNormalOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::mps::RandomTruncatedNormalOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::RandomTruncatedNormalOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::getOpPropertyByteSize()
{
  return 48;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  if (a4)
  {
    long long v4 = *a4;
    long long v5 = a4[2];
    *(_OWORD *)(a3 + 16) = a4[1];
    *(_OWORD *)(a3 + 32) = v5;
    *(_OWORD *)a3 = v4;
  }
  else
  {
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return mlir::mps::RandomTruncatedNormalOp::populateDefaultProperties(a2, (mlir::MLIRContext **)a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::mps::RandomTruncatedNormalOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::RandomTruncatedNormalOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::mps::RandomTruncatedNormalOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  long long v4 = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(a2 + 32) = v4;
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  if (*a3 != *a2) {
    return 0;
  }
  if (a3[1] != a2[1]) {
    return 0;
  }
  if (a3[2] != a2[2]) {
    return 0;
  }
  if (a3[3] != a2[3]) {
    return 0;
  }
  if (a3[4] == a2[4]) {
    return a3[5] == a2[5];
  }
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomTruncatedNormalOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::memref::GlobalOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomTruncatedNormalOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomTruncatedNormalOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomTruncatedNormalOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomTruncatedNormalOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[1]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[2]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 16))(a3, v4[3]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[4]);
  uint64_t v5 = v4[5];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 24);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RandomTruncatedNormalOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RandomTruncatedNormalOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomTruncatedNormalOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomTruncatedNormalOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomTruncatedNormalOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomTruncatedNormalOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomTruncatedNormalOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, long long *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::RandomTruncatedNormalOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomTruncatedNormalOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, long long *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::RandomTruncatedNormalOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomTruncatedNormalOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::RandomTruncatedNormalOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, long long *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::RandomTruncatedNormalOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    long long v24 = v23;
    uint64_t v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.random_truncated_normal";
    v25[1] = 27;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RandomTruncatedNormalOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RandomTruncatedNormalOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RandomTruncatedNormalOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::RandomTruncatedNormalOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::RandomTruncatedNormalOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    unint64_t v10 = (long long *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  }
  else {
    unint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v29, v12, v11);
  uint64_t v20 = v8;
  v21[0] = 0;
  char v22 = 0;
  long long v13 = v10[1];
  long long v23 = *v10;
  long long v24 = v13;
  long long v25 = v10[2];
  long long v26 = *(_OWORD *)v29;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22) {
      char v22 = 0;
    }
    mlir::OperationName::OperationName(v21, "mps.random_truncated_normal", 27, Context);
    char v22 = 1;
  }
  uint64_t v27 = a2;
  uint64_t v28 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v29[0] = result;
  v29[1] = v16;
  if (result)
  {
    unint64_t v17 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v29, v27, v28);
    if (v17 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v18 = v17;
      if (a1 - 16 != (v17 & ((uint64_t)(v17 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v19 = *(unsigned int *)(a4 + 8);
        if (v19 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v19 + 1, 8);
          LODWORD(v19) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v19) = v18;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2))
  {
    return 0;
  }
  unint64_t v6 = a1;
  return mlir::mps::RandomTruncatedNormalOp::verifyInvariantsImpl((mlir::mps::RandomTruncatedNormalOp *)&v6);
}

BOOL mlir::Op<mlir::mps::RandomTruncatedNormalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.random_uniform", 18, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RandomUniformOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      size_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C368220;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 19
    && (*a3 == 0x655F746C75736572 ? (BOOL v7 = a3[1] == 0x745F746E656D656CLL) : (BOOL v7 = 0),
        v7 ? (BOOL v8 = *(void *)((char *)a3 + 11) == 0x657079745F746E65) : (BOOL v8 = 0),
        v8))
  {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else
  {
    return 0;
  }
}

void *mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v11);
  if (v7 == 19)
  {
    BOOL v8 = *result == 0x655F746C75736572 && result[1] == 0x745F746E656D656CLL;
    if (v8 && *(void *)((char *)result + 11) == 0x657079745F746E65)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id) {
          uint64_t v10 = a4;
        }
        else {
          uint64_t v10 = 0;
        }
        *uint64_t v5 = v10;
      }
      else
      {
        *uint64_t v5 = 0;
      }
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"result_element_type", 19, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v7, (void **)"result_element_type", (const char *)0x13, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::RandomUniformOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::RandomUniformOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::RandomUniformOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::RandomUniformOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::TypeAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 16))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, unint64_t *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::RandomUniformOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, unint64_t *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::RandomUniformOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::RandomUniformOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, unint64_t *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::RandomUniformOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    long long v24 = v23;
    long long v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.random_uniform";
    v25[1] = 18;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RandomUniformOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::RandomUniformOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::RandomUniformOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  unint64_t v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  uint64_t v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.random_uniform", 18, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)4))
  {
    return 0;
  }
  unint64_t v6 = a1;
  return mlir::mps::RandomUniformOp::verifyInvariantsImpl((mlir::mps::RandomUniformOp *)&v6);
}

BOOL mlir::Op<mlir::mps::RandomUniformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::RankOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RankOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RankOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RankOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.rank", 8, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RankOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36CA00;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RankOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RankOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RankOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RankOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::RankOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RankOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RankOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RankOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RankOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RankOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::RankOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RankOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RankOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RankOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      unint64_t v11 = v32;
      uint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          unint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      uint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RankOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RankOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RankOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RankOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RankOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RankOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RankOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RankOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RankOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RankOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::RankOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RankOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::RankOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RankOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::RankOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v22 = v24;
  uint64_t v23 = 0x400000000;
  if (mlir::mps::RankOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, v18, v19, (uint64_t)&v22))
  {
    mlir::ValueRange::ValueRange(v21, (uint64_t)v22, v23);
    mlir::ValueRange::ValueRange(v20, *(void *)a11, *(unsigned int *)(a11 + 8));
    v25[0] = &unk_26C380E60;
    unsigned int v26 = v25;
    uint64_t v28 = v27;
    v27[0] = &unk_26C380E60;
    if (v28 == v27)
    {
      (*(void (**)(void *))(v27[0] + 32))(v27);
      unint64_t v14 = v26;
      if (v26 != v25) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v28) {
        (*(void (**)(void *))(*v28 + 40))(v28);
      }
      unint64_t v14 = v26;
      if (v26 != v25)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v22;
          if (v22 == v24) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v25[0] + 32))(v25);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v27[0] = "mps.rank";
    v27[1] = 8;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v27, "' op inferred type(s) ", (uint64_t)&v22, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v22;
    if (v22 == v24) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v22;
  if (v22 != v24) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RankOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RankOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RankOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::RankOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::RankOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::RankOpGenericAdaptorBase::RankOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::RankOp>,mlir::OpTrait::OneResult<mlir::mps::RankOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::RankOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::RankOp>,mlir::OpTrait::OneOperand<mlir::mps::RankOp>,mlir::OpTrait::OpInvariants<mlir::mps::RankOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::RankOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::RankOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::RankOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::RankOp>,mlir::OpTrait::OneResult<mlir::mps::RankOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::RankOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::RankOp>,mlir::OpTrait::OneOperand<mlir::mps::RankOp>,mlir::OpTrait::OpInvariants<mlir::mps::RankOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::RankOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::RankOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::RankOp>>(uint64_t a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    || !mlir::OpTrait::impl::verifyOneOperand((mlir::OpTrait::impl *)a1, v5)
    || !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(a1, (void **)(*(void *)(*(void *)(*(void *)(a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0))
  {
    return 0;
  }
  if (*(_DWORD *)(a1 + 36)) {
    uint64_t v6 = a1 - 16;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(a1, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
}

BOOL mlir::Op<mlir::mps::RankOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReadDataFromFileOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReadDataFromFileOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::ReadDataFromFileOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.read_data_from_file", 23, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReadDataFromFileOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C38CBB0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  unint64_t v11 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
      + 2;
  BOOL v6 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v10, a2);
  char v7 = v11;
  if (v11 >= 8)
  {
    if ((v11 & 4) != 0)
    {
      if ((v11 & 2) != 0) {
        uint64_t v8 = v10;
      }
      else {
        uint64_t v8 = (llvm **)v10[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v11 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v8, v2, v3, v4, v5);
    }
    if ((v7 & 2) == 0) {
      llvm::deallocate_buffer(v10[0], v10[1]);
    }
  }
  return v6;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t v10 = (unint64_t)&llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v9, a2, a3, a4, a5);
  char v7 = v10;
  if (v10 >= 8)
  {
    if ((v10 & 4) != 0)
    {
      if ((v10 & 2) != 0) {
        uint64_t v8 = v9;
      }
      else {
        uint64_t v8 = (llvm **)v9[0];
      }
      uint64_t result = (*(BOOL (**)(uint64_t, uint64_t))((v10 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v8, v6);
    }
    if ((v7 & 2) == 0) {
      llvm::deallocate_buffer(v9[0], v9[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v7 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v7 = 0;
  }
  switch(a4)
  {
    case 6:
      if (*(_DWORD *)a3 != 1936090735 || *(_WORD *)(a3 + 4) != 29797) {
        return 0;
      }
      return v7[2];
    case 11:
      if (*(void *)a3 != 0x6D79735F656C6966 || *(void *)(a3 + 3) != 0x6C6F626D79735F65) {
        return 0;
      }
      return v7[1];
    case 9:
      if (*(void *)a3 != 0x7461705F656C6966 || *(unsigned char *)(a3 + 8) != 104) {
        return 0;
      }
      return *v7;
    default:
      return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::ReadDataFromFileOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  if (*v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"file_path", 9, *v5);
  }
  uint64_t v6 = v5[1];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"file_symbol", 11, v6);
  }
  uint64_t v7 = v5[2];
  if (v7)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"offset", 6, v7);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::ReadDataFromFileOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::getOpPropertyByteSize()
{
  return 24;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  if (a4)
  {
    long long v4 = *a4;
    *(void *)(a3 + 16) = *((void *)a4 + 2);
    *(_OWORD *)a3 = v4;
  }
  else
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ReadDataFromFileOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::mps::ReadDataFromFileOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  *a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  if (*a3 != *a2) {
    return 0;
  }
  if (a3[1] == a2[1]) {
    return a3[2] == a2[2];
  }
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadDataFromFileOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::memref::PrefetchOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReadDataFromFileOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReadDataFromFileOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReadDataFromFileOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReadDataFromFileOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ReadDataFromFileOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::StringAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::StringAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 2) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReadDataFromFileOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 16))(a3, *v4);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[1]);
  uint64_t v5 = v4[2];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReadDataFromFileOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReadDataFromFileOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::ReadDataFromFileOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::ReadDataFromFileOp>::downgradeToVersion;
  char v3 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  {
    uint64_t v12 = v2;
    char v3 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DowngraderInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::DowngraderInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[420], v2);
}

void mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::ReadDataFromFileOp>::downgradeToVersion(uint64_t a1@<X1>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v3 = a1;
  mlir::mps::ReadDataFromFileOp::downgradeToVersion(&v3, a2, a3);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::foldSingleResultHook<mlir::mps::ReadDataFromFileOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::foldSingleResultHook<mlir::mps::ReadDataFromFileOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    uint64_t v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  }
  else {
    uint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v27, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  long long v22 = *(_OWORD *)v10;
  uint64_t v23 = *(void *)(v10 + 16);
  long long v24 = *(_OWORD *)v27;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.read_data_from_file", 23, Context);
    char v21 = 1;
  }
  uint64_t v25 = a2;
  uint64_t v26 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v27[0] = result;
  v27[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v27, v25, v26);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v144 = a1;
    v1 = (void *)&unk_267771000;
    int v28 = v27;
    a1 = v144;
    if (v28)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v154 = 83;
      unint64_t v29 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v29) {
        unint64_t v30 = v29;
      }
      else {
        unint64_t v30 = v154;
      }
      int v31 = &v153[v30];
      unint64_t v32 = v154 - v30;
      if (v154 - v30 >= 0x12) {
        uint64_t v33 = 18;
      }
      else {
        uint64_t v33 = v154 - v30;
      }
      unint64_t v34 = v32 - v33;
      if (v34 >= v34 - 1) {
        uint64_t v35 = v34 - 1;
      }
      else {
        uint64_t v35 = v34;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v31[v33], v35);
      v1 = (void *)&unk_267771000;
      a1 = v144;
    }
  }
  uint64_t v2 = v1[23];
  uint64_t v3 = &unk_267771000;
  {
    uint64_t v136 = v2;
    uint64_t v145 = a1;
    uint64_t v3 = (void *)&unk_267771000;
    int v37 = v36;
    uint64_t v2 = v136;
    a1 = v145;
    if (v37)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v154 = 81;
      unint64_t v38 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v38) {
        unint64_t v39 = v38;
      }
      else {
        unint64_t v39 = v154;
      }
      unint64_t v40 = &v153[v39];
      unint64_t v41 = v154 - v39;
      if (v154 - v39 >= 0x12) {
        uint64_t v42 = 18;
      }
      else {
        uint64_t v42 = v154 - v39;
      }
      unint64_t v43 = v41 - v42;
      if (v43 >= v43 - 1) {
        uint64_t v44 = v43 - 1;
      }
      else {
        uint64_t v44 = v43;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      uint64_t v3 = (void *)&unk_267771000;
      uint64_t v2 = v136;
      a1 = v145;
    }
  }
  uint64_t v4 = v3[25];
  unint64_t v5 = &unk_267771000;
  {
    uint64_t v137 = v2;
    uint64_t v146 = a1;
    uint64_t v129 = v4;
    unint64_t v5 = (void *)&unk_267771000;
    uint64_t v4 = v129;
    int v46 = v45;
    uint64_t v2 = v137;
    a1 = v146;
    if (v46)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      unint64_t v154 = 104;
      unint64_t v47 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v47) {
        unint64_t v48 = v47;
      }
      else {
        unint64_t v48 = v154;
      }
      unint64_t v49 = &v153[v48];
      unint64_t v50 = v154 - v48;
      if (v154 - v48 >= 0x12) {
        uint64_t v51 = 18;
      }
      else {
        uint64_t v51 = v154 - v48;
      }
      unint64_t v52 = v50 - v51;
      if (v52 >= v52 - 1) {
        uint64_t v53 = v52 - 1;
      }
      else {
        uint64_t v53 = v52;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      unint64_t v5 = (void *)&unk_267771000;
      uint64_t v4 = v129;
      uint64_t v2 = v137;
      a1 = v146;
    }
  }
  uint64_t v6 = v5[318];
  uint64_t v7 = &unk_267770000;
  {
    uint64_t v138 = v2;
    uint64_t v147 = a1;
    uint64_t v123 = v6;
    uint64_t v130 = v4;
    uint64_t v7 = (void *)&unk_267770000;
    uint64_t v6 = v123;
    uint64_t v4 = v130;
    int v55 = v54;
    uint64_t v2 = v138;
    a1 = v147;
    if (v55)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v154 = 86;
      unint64_t v56 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v56) {
        unint64_t v57 = v56;
      }
      else {
        unint64_t v57 = v154;
      }
      unint64_t v58 = &v153[v57];
      unint64_t v59 = v154 - v57;
      if (v154 - v57 >= 0x12) {
        uint64_t v60 = 18;
      }
      else {
        uint64_t v60 = v154 - v57;
      }
      unint64_t v61 = v59 - v60;
      if (v61 >= v61 - 1) {
        uint64_t v62 = v61 - 1;
      }
      else {
        uint64_t v62 = v61;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      uint64_t v7 = (void *)&unk_267770000;
      uint64_t v6 = v123;
      uint64_t v4 = v130;
      uint64_t v2 = v138;
      a1 = v147;
    }
  }
  uint64_t v8 = v7[431];
  unint64_t v9 = &unk_267770000;
  {
    uint64_t v139 = v2;
    uint64_t v148 = a1;
    uint64_t v124 = v6;
    uint64_t v131 = v4;
    uint64_t v118 = v8;
    unint64_t v9 = (void *)&unk_267770000;
    uint64_t v8 = v118;
    uint64_t v6 = v124;
    uint64_t v4 = v131;
    int v64 = v63;
    uint64_t v2 = v139;
    a1 = v148;
    if (v64)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroOperands<Empty>]";
      unint64_t v154 = 84;
      unint64_t v65 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v65) {
        unint64_t v66 = v65;
      }
      else {
        unint64_t v66 = v154;
      }
      unint64_t v67 = &v153[v66];
      unint64_t v68 = v154 - v66;
      if (v154 - v66 >= 0x12) {
        uint64_t v69 = 18;
      }
      else {
        uint64_t v69 = v154 - v66;
      }
      unint64_t v70 = v68 - v69;
      if (v70 >= v70 - 1) {
        uint64_t v71 = v70 - 1;
      }
      else {
        uint64_t v71 = v70;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      unint64_t v9 = (void *)&unk_267770000;
      uint64_t v8 = v118;
      uint64_t v6 = v124;
      uint64_t v4 = v131;
      uint64_t v2 = v139;
      a1 = v148;
    }
  }
  uint64_t v10 = v9[433];
  unint64_t v11 = &unk_267770000;
  {
    uint64_t v140 = v2;
    uint64_t v149 = a1;
    uint64_t v125 = v6;
    uint64_t v132 = v4;
    uint64_t v114 = v10;
    uint64_t v119 = v8;
    unint64_t v11 = (void *)&unk_267770000;
    uint64_t v10 = v114;
    uint64_t v8 = v119;
    uint64_t v6 = v125;
    uint64_t v4 = v132;
    int v73 = v72;
    uint64_t v2 = v140;
    a1 = v149;
    if (v73)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v154 = 84;
      unint64_t v74 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v74) {
        unint64_t v75 = v74;
      }
      else {
        unint64_t v75 = v154;
      }
      unint64_t v76 = &v153[v75];
      unint64_t v77 = v154 - v75;
      if (v154 - v75 >= 0x12) {
        uint64_t v78 = 18;
      }
      else {
        uint64_t v78 = v154 - v75;
      }
      unint64_t v79 = v77 - v78;
      if (v79 >= v79 - 1) {
        uint64_t v80 = v79 - 1;
      }
      else {
        uint64_t v80 = v79;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      unint64_t v11 = (void *)&unk_267770000;
      uint64_t v10 = v114;
      uint64_t v8 = v119;
      uint64_t v6 = v125;
      uint64_t v4 = v132;
      uint64_t v2 = v140;
      a1 = v149;
    }
  }
  uint64_t v12 = v11[435];
  char v13 = &unk_267771000;
  {
    uint64_t v141 = v2;
    uint64_t v150 = a1;
    uint64_t v126 = v6;
    uint64_t v133 = v4;
    uint64_t v115 = v10;
    uint64_t v120 = v8;
    uint64_t v111 = v12;
    char v13 = (void *)&unk_267771000;
    uint64_t v12 = v111;
    uint64_t v10 = v115;
    uint64_t v8 = v120;
    uint64_t v6 = v126;
    uint64_t v4 = v133;
    int v82 = v81;
    uint64_t v2 = v141;
    a1 = v150;
    if (v82)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v154 = 89;
      unint64_t v83 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v83) {
        unint64_t v84 = v83;
      }
      else {
        unint64_t v84 = v154;
      }
      unint64_t v85 = &v153[v84];
      unint64_t v86 = v154 - v84;
      if (v154 - v84 >= 0x12) {
        uint64_t v87 = 18;
      }
      else {
        uint64_t v87 = v154 - v84;
      }
      unint64_t v88 = v86 - v87;
      if (v88 >= v88 - 1) {
        uint64_t v89 = v88 - 1;
      }
      else {
        uint64_t v89 = v88;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      char v13 = (void *)&unk_267771000;
      uint64_t v12 = v111;
      uint64_t v10 = v115;
      uint64_t v8 = v120;
      uint64_t v6 = v126;
      uint64_t v4 = v133;
      uint64_t v2 = v141;
      a1 = v150;
    }
  }
  uint64_t v14 = v13[320];
  unint64_t v15 = &unk_267771000;
  {
    uint64_t v142 = v2;
    uint64_t v151 = a1;
    uint64_t v127 = v6;
    uint64_t v134 = v4;
    uint64_t v116 = v10;
    uint64_t v121 = v8;
    uint64_t v109 = v14;
    uint64_t v112 = v12;
    unint64_t v15 = (void *)&unk_267771000;
    uint64_t v14 = v109;
    uint64_t v12 = v112;
    uint64_t v10 = v116;
    uint64_t v8 = v121;
    uint64_t v6 = v127;
    uint64_t v4 = v134;
    int v91 = v90;
    uint64_t v2 = v142;
    a1 = v151;
    if (v91)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v154 = 93;
      unint64_t v92 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v92) {
        unint64_t v93 = v92;
      }
      else {
        unint64_t v93 = v154;
      }
      unint64_t v94 = &v153[v93];
      unint64_t v95 = v154 - v93;
      if (v154 - v93 >= 0x12) {
        uint64_t v96 = 18;
      }
      else {
        uint64_t v96 = v154 - v93;
      }
      unint64_t v97 = v95 - v96;
      if (v97 >= v97 - 1) {
        uint64_t v98 = v97 - 1;
      }
      else {
        uint64_t v98 = v97;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      unint64_t v15 = (void *)&unk_267771000;
      uint64_t v14 = v109;
      uint64_t v12 = v112;
      uint64_t v10 = v116;
      uint64_t v8 = v121;
      uint64_t v6 = v127;
      uint64_t v4 = v134;
      uint64_t v2 = v142;
      a1 = v151;
    }
  }
  uint64_t v16 = v15[31];
  unint64_t v17 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  {
    uint64_t v143 = v2;
    uint64_t v152 = a1;
    uint64_t v128 = v6;
    uint64_t v135 = v4;
    uint64_t v117 = v10;
    uint64_t v122 = v8;
    uint64_t v110 = v14;
    uint64_t v113 = v12;
    uint64_t v108 = v16;
    unint64_t v17 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    uint64_t v16 = v108;
    uint64_t v14 = v110;
    uint64_t v12 = v113;
    uint64_t v10 = v117;
    uint64_t v8 = v122;
    uint64_t v6 = v128;
    uint64_t v4 = v135;
    int v100 = v99;
    uint64_t v2 = v143;
    a1 = v152;
    if (v100)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DowngraderInterface::Trait<Empty>]";
      unint64_t v154 = 89;
      unint64_t v101 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v101) {
        unint64_t v102 = v101;
      }
      else {
        unint64_t v102 = v154;
      }
      unint64_t v103 = &v153[v102];
      unint64_t v104 = v154 - v102;
      if (v154 - v102 >= 0x12) {
        uint64_t v105 = 18;
      }
      else {
        uint64_t v105 = v154 - v102;
      }
      unint64_t v106 = v104 - v105;
      if (v106 >= v106 - 1) {
        uint64_t v107 = v106 - 1;
      }
      else {
        uint64_t v107 = v106;
      }
      mlir::detail::TypeIDResolver<mlir::DowngraderInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DowngraderInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      unint64_t v17 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      uint64_t v16 = v108;
      uint64_t v14 = v110;
      uint64_t v12 = v113;
      uint64_t v10 = v117;
      uint64_t v8 = v122;
      uint64_t v6 = v128;
      uint64_t v4 = v135;
      uint64_t v2 = v143;
      a1 = v152;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v17[422] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyZeroOperands(a1, v5))
  {
    return 0;
  }
  uint64_t v7 = a1;
  return mlir::mps::ReadDataFromFileOp::verifyInvariantsImpl((mlir::mps::ReadDataFromFileOp *)&v7);
}

uint64_t mlir::Op<mlir::mps::ReadDataFromFileOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReadVariableOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReadVariableOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReadVariableOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::ReadVariableOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReadVariableOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.read_variable", 17, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReadVariableOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C3675A0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadVariableOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReadVariableOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadVariableOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReadVariableOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReadVariableOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReadVariableOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadVariableOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadVariableOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadVariableOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadVariableOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReadVariableOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadVariableOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadVariableOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadVariableOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    long long v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      unint64_t v11 = v32;
      uint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          unint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadVariableOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadVariableOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReadVariableOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReadVariableOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReadVariableOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReadVariableOp>::getEffects(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReadVariableOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReadVariableOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReadVariableOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::ReadVariableOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::ReadVariableOp>::downgradeToVersion;
  char v3 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  {
    uint64_t v12 = v2;
    char v3 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DowngraderInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::DowngraderInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[420], v2);
}

void mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::ReadVariableOp>::downgradeToVersion(uint64_t a1@<X1>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t v3 = a1;
  mlir::mps::UnrealizedFoldOp::downgradeToVersion(&v3, a2, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReadVariableOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReadVariableOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReadVariableOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReadVariableOp>::isCompatibleReturnTypes;
  uint64_t v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    uint64_t v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      uint64_t v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReadVariableOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReadVariableOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReadVariableOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReadVariableOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReadVariableOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  long long v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  long long v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  long long v24 = "mps.read_variable";
  uint64_t v25 = 17;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::ReadVariableOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::ReadVariableOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::ReadVariableOpGenericAdaptorBase::ReadVariableOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v187 = a1;
    v1 = (void *)&unk_267771000;
    int v34 = v33;
    a1 = v187;
    if (v34)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v199 = 83;
      unint64_t v35 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v35) {
        unint64_t v36 = v35;
      }
      else {
        unint64_t v36 = v199;
      }
      int v37 = &v198[v36];
      unint64_t v38 = v199 - v36;
      if (v199 - v36 >= 0x12) {
        uint64_t v39 = 18;
      }
      else {
        uint64_t v39 = v199 - v36;
      }
      unint64_t v40 = v38 - v39;
      if (v40 >= v40 - 1) {
        uint64_t v41 = v40 - 1;
      }
      else {
        uint64_t v41 = v40;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v37[v39], v41);
      v1 = (void *)&unk_267771000;
      a1 = v187;
    }
  }
  uint64_t v2 = v1[23];
  uint64_t v3 = &unk_267771000;
  {
    uint64_t v177 = v2;
    uint64_t v188 = a1;
    uint64_t v3 = (void *)&unk_267771000;
    int v43 = v42;
    uint64_t v2 = v177;
    a1 = v188;
    if (v43)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v199 = 81;
      unint64_t v44 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v44) {
        unint64_t v45 = v44;
      }
      else {
        unint64_t v45 = v199;
      }
      int v46 = &v198[v45];
      unint64_t v47 = v199 - v45;
      if (v199 - v45 >= 0x12) {
        uint64_t v48 = 18;
      }
      else {
        uint64_t v48 = v199 - v45;
      }
      unint64_t v49 = v47 - v48;
      if (v49 >= v49 - 1) {
        uint64_t v50 = v49 - 1;
      }
      else {
        uint64_t v50 = v49;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v46[v48], v50);
      uint64_t v3 = (void *)&unk_267771000;
      uint64_t v2 = v177;
      a1 = v188;
    }
  }
  uint64_t v4 = v3[25];
  unint64_t v5 = &unk_267771000;
  {
    uint64_t v178 = v2;
    uint64_t v189 = a1;
    uint64_t v168 = v4;
    unint64_t v5 = (void *)&unk_267771000;
    uint64_t v4 = v168;
    uint64_t v2 = v178;
    int v52 = v51;
    a1 = v189;
    if (v52)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<Empty>]";
      unint64_t v199 = 110;
      unint64_t v53 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v53) {
        unint64_t v54 = v53;
      }
      else {
        unint64_t v54 = v199;
      }
      int v55 = &v198[v54];
      unint64_t v56 = v199 - v54;
      if (v199 - v54 >= 0x12) {
        uint64_t v57 = 18;
      }
      else {
        uint64_t v57 = v199 - v54;
      }
      unint64_t v58 = v56 - v57;
      if (v58 >= v58 - 1) {
        uint64_t v59 = v58 - 1;
      }
      else {
        uint64_t v59 = v58;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v55[v57], v59);
      unint64_t v5 = (void *)&unk_267771000;
      uint64_t v4 = v168;
      uint64_t v2 = v178;
      a1 = v189;
    }
  }
  uint64_t v6 = v5[431];
  uint64_t v7 = &unk_267770000;
  {
    uint64_t v179 = v2;
    uint64_t v190 = a1;
    uint64_t v169 = v4;
    uint64_t v160 = v6;
    uint64_t v7 = (void *)&unk_267770000;
    uint64_t v6 = v160;
    uint64_t v4 = v169;
    uint64_t v2 = v179;
    int v61 = v60;
    a1 = v190;
    if (v61)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v199 = 86;
      unint64_t v62 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v62) {
        unint64_t v63 = v62;
      }
      else {
        unint64_t v63 = v199;
      }
      int v64 = &v198[v63];
      unint64_t v65 = v199 - v63;
      if (v199 - v63 >= 0x12) {
        uint64_t v66 = 18;
      }
      else {
        uint64_t v66 = v199 - v63;
      }
      unint64_t v67 = v65 - v66;
      if (v67 >= v67 - 1) {
        uint64_t v68 = v67 - 1;
      }
      else {
        uint64_t v68 = v67;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v64[v66], v68);
      uint64_t v7 = (void *)&unk_267770000;
      uint64_t v6 = v160;
      uint64_t v4 = v169;
      uint64_t v2 = v179;
      a1 = v190;
    }
  }
  uint64_t v8 = v7[431];
  uint64_t v9 = &unk_267771000;
  {
    uint64_t v180 = v2;
    uint64_t v191 = a1;
    uint64_t v170 = v4;
    uint64_t v153 = v8;
    uint64_t v161 = v6;
    uint64_t v9 = (void *)&unk_267771000;
    uint64_t v8 = v153;
    uint64_t v6 = v161;
    uint64_t v4 = v170;
    uint64_t v2 = v180;
    int v70 = v69;
    a1 = v191;
    if (v70)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      unint64_t v199 = 82;
      unint64_t v71 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v71) {
        unint64_t v72 = v71;
      }
      else {
        unint64_t v72 = v199;
      }
      int v73 = &v198[v72];
      unint64_t v74 = v199 - v72;
      if (v199 - v72 >= 0x12) {
        uint64_t v75 = 18;
      }
      else {
        uint64_t v75 = v199 - v72;
      }
      unint64_t v76 = v74 - v75;
      if (v76 >= v76 - 1) {
        uint64_t v77 = v76 - 1;
      }
      else {
        uint64_t v77 = v76;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v73[v75], v77);
      uint64_t v9 = (void *)&unk_267771000;
      uint64_t v8 = v153;
      uint64_t v6 = v161;
      uint64_t v4 = v170;
      uint64_t v2 = v180;
      a1 = v191;
    }
  }
  uint64_t v10 = v9[29];
  uint64_t v11 = &unk_267770000;
  {
    uint64_t v181 = v2;
    uint64_t v192 = a1;
    uint64_t v171 = v4;
    uint64_t v154 = v8;
    uint64_t v162 = v6;
    uint64_t v147 = v10;
    uint64_t v11 = (void *)&unk_267770000;
    uint64_t v10 = v147;
    uint64_t v8 = v154;
    uint64_t v6 = v162;
    uint64_t v4 = v171;
    uint64_t v2 = v181;
    int v79 = v78;
    a1 = v192;
    if (v79)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v199 = 84;
      unint64_t v80 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v80) {
        unint64_t v81 = v80;
      }
      else {
        unint64_t v81 = v199;
      }
      int v82 = &v198[v81];
      unint64_t v83 = v199 - v81;
      if (v199 - v81 >= 0x12) {
        uint64_t v84 = 18;
      }
      else {
        uint64_t v84 = v199 - v81;
      }
      unint64_t v85 = v83 - v84;
      if (v85 >= v85 - 1) {
        uint64_t v86 = v85 - 1;
      }
      else {
        uint64_t v86 = v85;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v82[v84], v86);
      uint64_t v11 = (void *)&unk_267770000;
      uint64_t v10 = v147;
      uint64_t v8 = v154;
      uint64_t v6 = v162;
      uint64_t v4 = v171;
      uint64_t v2 = v181;
      a1 = v192;
    }
  }
  uint64_t v12 = v11[435];
  char v13 = &unk_267771000;
  {
    uint64_t v182 = v2;
    uint64_t v193 = a1;
    uint64_t v172 = v4;
    uint64_t v155 = v8;
    uint64_t v163 = v6;
    uint64_t v142 = v12;
    uint64_t v148 = v10;
    char v13 = (void *)&unk_267771000;
    uint64_t v12 = v142;
    uint64_t v10 = v148;
    uint64_t v8 = v155;
    uint64_t v6 = v163;
    uint64_t v4 = v172;
    uint64_t v2 = v182;
    int v88 = v87;
    a1 = v193;
    if (v88)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v199 = 93;
      unint64_t v89 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v89) {
        unint64_t v90 = v89;
      }
      else {
        unint64_t v90 = v199;
      }
      int v91 = &v198[v90];
      unint64_t v92 = v199 - v90;
      if (v199 - v90 >= 0x12) {
        uint64_t v93 = 18;
      }
      else {
        uint64_t v93 = v199 - v90;
      }
      unint64_t v94 = v92 - v93;
      if (v94 >= v94 - 1) {
        uint64_t v95 = v94 - 1;
      }
      else {
        uint64_t v95 = v94;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v91[v93], v95);
      char v13 = (void *)&unk_267771000;
      uint64_t v12 = v142;
      uint64_t v10 = v148;
      uint64_t v8 = v155;
      uint64_t v6 = v163;
      uint64_t v4 = v172;
      uint64_t v2 = v182;
      a1 = v193;
    }
  }
  uint64_t v14 = v13[31];
  uint64_t v15 = &unk_267771000;
  {
    uint64_t v183 = v2;
    uint64_t v194 = a1;
    uint64_t v173 = v4;
    uint64_t v156 = v8;
    uint64_t v164 = v6;
    uint64_t v143 = v12;
    uint64_t v149 = v10;
    uint64_t v138 = v14;
    uint64_t v15 = (void *)&unk_267771000;
    uint64_t v14 = v138;
    uint64_t v12 = v143;
    uint64_t v10 = v149;
    uint64_t v8 = v156;
    uint64_t v6 = v164;
    uint64_t v4 = v173;
    uint64_t v2 = v183;
    int v97 = v96;
    a1 = v194;
    if (v97)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultType<Empty>]";
      unint64_t v199 = 97;
      unint64_t v98 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v98) {
        unint64_t v99 = v98;
      }
      else {
        unint64_t v99 = v199;
      }
      int v100 = &v198[v99];
      unint64_t v101 = v199 - v99;
      if (v199 - v99 >= 0x12) {
        uint64_t v102 = 18;
      }
      else {
        uint64_t v102 = v199 - v99;
      }
      unint64_t v103 = v101 - v102;
      if (v103 >= v103 - 1) {
        uint64_t v104 = v103 - 1;
      }
      else {
        uint64_t v104 = v103;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v100[v102], v104);
      uint64_t v15 = (void *)&unk_267771000;
      uint64_t v14 = v138;
      uint64_t v12 = v143;
      uint64_t v10 = v149;
      uint64_t v8 = v156;
      uint64_t v6 = v164;
      uint64_t v4 = v173;
      uint64_t v2 = v183;
      a1 = v194;
    }
  }
  uint64_t v16 = v15[328];
  uint64_t v17 = &unk_267771000;
  {
    uint64_t v184 = v2;
    uint64_t v195 = a1;
    uint64_t v174 = v4;
    uint64_t v157 = v8;
    uint64_t v165 = v6;
    uint64_t v144 = v12;
    uint64_t v150 = v10;
    uint64_t v135 = v16;
    uint64_t v139 = v14;
    uint64_t v17 = (void *)&unk_267771000;
    uint64_t v16 = v135;
    uint64_t v14 = v139;
    uint64_t v12 = v144;
    uint64_t v10 = v150;
    uint64_t v8 = v157;
    uint64_t v6 = v165;
    uint64_t v4 = v174;
    uint64_t v2 = v184;
    int v106 = v105;
    a1 = v195;
    if (v106)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      unint64_t v199 = 100;
      unint64_t v107 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v107) {
        unint64_t v108 = v107;
      }
      else {
        unint64_t v108 = v199;
      }
      uint64_t v109 = &v198[v108];
      unint64_t v110 = v199 - v108;
      if (v199 - v108 >= 0x12) {
        uint64_t v111 = 18;
      }
      else {
        uint64_t v111 = v199 - v108;
      }
      unint64_t v112 = v110 - v111;
      if (v112 >= v112 - 1) {
        uint64_t v113 = v112 - 1;
      }
      else {
        uint64_t v113 = v112;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v109[v111], v113);
      uint64_t v17 = (void *)&unk_267771000;
      uint64_t v16 = v135;
      uint64_t v14 = v139;
      uint64_t v12 = v144;
      uint64_t v10 = v150;
      uint64_t v8 = v157;
      uint64_t v6 = v165;
      uint64_t v4 = v174;
      uint64_t v2 = v184;
      a1 = v195;
    }
  }
  uint64_t v18 = v17[41];
  unint64_t v19 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  {
    uint64_t v185 = v2;
    uint64_t v196 = a1;
    uint64_t v175 = v4;
    uint64_t v158 = v8;
    uint64_t v166 = v6;
    uint64_t v145 = v12;
    uint64_t v151 = v10;
    uint64_t v136 = v16;
    uint64_t v140 = v14;
    uint64_t v133 = v18;
    unint64_t v19 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    uint64_t v18 = v133;
    uint64_t v16 = v136;
    uint64_t v14 = v140;
    uint64_t v12 = v145;
    uint64_t v10 = v151;
    uint64_t v8 = v158;
    uint64_t v6 = v166;
    uint64_t v4 = v175;
    uint64_t v2 = v185;
    int v115 = v114;
    a1 = v196;
    if (v115)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DowngraderInterface::Trait<Empty>]";
      unint64_t v199 = 89;
      unint64_t v116 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v116) {
        unint64_t v117 = v116;
      }
      else {
        unint64_t v117 = v199;
      }
      uint64_t v118 = &v198[v117];
      unint64_t v119 = v199 - v117;
      if (v199 - v117 >= 0x12) {
        uint64_t v120 = 18;
      }
      else {
        uint64_t v120 = v199 - v117;
      }
      unint64_t v121 = v119 - v120;
      if (v121 >= v121 - 1) {
        uint64_t v122 = v121 - 1;
      }
      else {
        uint64_t v122 = v121;
      }
      mlir::detail::TypeIDResolver<mlir::DowngraderInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DowngraderInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v118[v120], v122);
      unint64_t v19 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      uint64_t v18 = v133;
      uint64_t v16 = v136;
      uint64_t v14 = v140;
      uint64_t v12 = v145;
      uint64_t v10 = v151;
      uint64_t v8 = v158;
      uint64_t v6 = v166;
      uint64_t v4 = v175;
      uint64_t v2 = v185;
      a1 = v196;
    }
  }
  uint64_t v20 = v19[422];
  int v21 = &unk_267771000;
  {
    uint64_t v186 = v2;
    uint64_t v197 = a1;
    uint64_t v176 = v4;
    uint64_t v159 = v8;
    uint64_t v167 = v6;
    uint64_t v146 = v12;
    uint64_t v152 = v10;
    uint64_t v137 = v16;
    uint64_t v141 = v14;
    uint64_t v132 = v20;
    uint64_t v134 = v18;
    int v21 = (void *)&unk_267771000;
    uint64_t v20 = v132;
    uint64_t v18 = v134;
    uint64_t v16 = v137;
    uint64_t v14 = v141;
    uint64_t v12 = v146;
    uint64_t v10 = v152;
    uint64_t v8 = v159;
    uint64_t v6 = v167;
    uint64_t v4 = v176;
    uint64_t v2 = v186;
    int v124 = v123;
    a1 = v197;
    if (v124)
    {
      v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v199 = 90;
      unint64_t v125 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v125) {
        unint64_t v126 = v125;
      }
      else {
        unint64_t v126 = v199;
      }
      uint64_t v127 = &v198[v126];
      unint64_t v128 = v199 - v126;
      if (v199 - v126 >= 0x12) {
        uint64_t v129 = 18;
      }
      else {
        uint64_t v129 = v199 - v126;
      }
      unint64_t v130 = v128 - v129;
      if (v130 >= v130 - 1) {
        uint64_t v131 = v130 - 1;
      }
      else {
        uint64_t v131 = v130;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v127[v129], v131);
      int v21 = (void *)&unk_267771000;
      uint64_t v20 = v132;
      uint64_t v18 = v134;
      uint64_t v16 = v137;
      uint64_t v14 = v141;
      uint64_t v12 = v146;
      uint64_t v10 = v152;
      uint64_t v8 = v159;
      uint64_t v6 = v167;
      uint64_t v4 = v176;
      uint64_t v2 = v186;
      a1 = v197;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v21[37] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ReadVariableOp>,mlir::OpTrait::OneResult<mlir::mps::ReadVariableOp>,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::mps::ReadVariableOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ReadVariableOp>,mlir::OpTrait::OneOperand<mlir::mps::ReadVariableOp>,mlir::OpTrait::OpInvariants<mlir::mps::ReadVariableOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ReadVariableOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ReadVariableOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ReadVariableOp>,mlir::DowngraderInterface::Trait<mlir::mps::ReadVariableOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ReadVariableOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ReadVariableOp>,mlir::OpTrait::OneResult<mlir::mps::ReadVariableOp>,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::mps::ReadVariableOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ReadVariableOp>,mlir::OpTrait::OneOperand<mlir::mps::ReadVariableOp>,mlir::OpTrait::OpInvariants<mlir::mps::ReadVariableOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ReadVariableOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ReadVariableOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ReadVariableOp>,mlir::DowngraderInterface::Trait<mlir::mps::ReadVariableOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ReadVariableOp>>(uint64_t a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand((mlir::OpTrait::impl *)a1, v5)
    && mlir::tensor::__mlir_ods_local_type_constraint_TensorOps0(a1, *(void *)(*(void *)(*(void *)(a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0)&& (*(_DWORD *)(a1 + 36) ? (uint64_t v6 = a1 - 16) : (uint64_t v6 = 0), NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0), mlir::tensor::__mlir_ods_local_type_constraint_TensorOps0(a1, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"result", (void **)6, 0)))
  {
    return mlir::OpTrait::impl::verifySameOperandsAndResultType((mlir::OpTrait::impl *)a1, v8) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::ReadVariableOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::RealPartOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RealPartOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RealPartOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RealPartOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.real_part", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RealPartOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C364F58;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealPartOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RealPartOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealPartOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RealPartOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::RealPartOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RealPartOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealPartOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealPartOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealPartOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealPartOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::RealPartOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealPartOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealPartOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealPartOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    long long v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      uint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealPartOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealPartOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealPartOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RealPartOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RealPartOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RealPartOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RealPartOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RealPartOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RealPartOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RealPartOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::RealPartOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RealPartOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::RealPartOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RealPartOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::RealPartOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  uint64_t v27 = *MEMORY[0x263EF8340];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::RealPartOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    long long v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.real_part";
    v25[1] = 13;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RealPartOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RealPartOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RealPartOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::RealPartOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::RealPartOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::RealPartOpGenericAdaptorBase::RealPartOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::OneResult<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::OneOperand<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::OpInvariants<mlir::mps::ImaginaryPartOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::SameOperandsAndResultShape<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::Stitchable<mlir::mps::ImaginaryPartOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ImaginaryPartOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ImaginaryPartOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::RealPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.real_to_hermitean_fft", 25, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RealToHermiteanFFTOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36A2F0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v7 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v7 = 0;
  }
  if (a4 == 12)
  {
    if (*(void *)a3 != 0x5F676E696C616373 || *(_DWORD *)(a3 + 8) != 1701080941) {
      return 0;
    }
    return v7[1];
  }
  else
  {
    if (a4 != 7) {
      return 0;
    }
    if (*(_DWORD *)a3 != 1702260329 || *(_DWORD *)(a3 + 3) != 1702064741) {
      return 0;
    }
    return *v7;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v12);
  if (v7 == 12)
  {
    if (*(void *)result == 0x5F676E696C616373 && *(_DWORD *)(result + 8) == 1701080941)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id) {
          uint64_t v10 = a4;
        }
        else {
          uint64_t v10 = 0;
        }
        v5[1] = v10;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else if (v7 == 7 && *(_DWORD *)result == 1702260329 && *(_DWORD *)(result + 3) == 1702064741)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
        uint64_t v11 = a4;
      }
      else {
        uint64_t v11 = 0;
      }
      *uint64_t v5 = v11;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  if (*v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"inverse", 7, *v5);
  }
  uint64_t v6 = v5[1];
  if (v6)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"scaling_mode", 12, v6);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  BOOL result = 0;
  if (!v9
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v9, (void **)"inverse", (const char *)7, a4, a5))
  {
    uint64_t v10 = mlir::NamedAttrList::get(a3, *(void *)(*(void *)(a2 + 96) + 8));
    if (!v10
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps27(v10, (void **)"scaling_mode", (const char *)0xC, a4, a5))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::getOpPropertyByteSize()
{
  return 16;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    *(_OWORD *)a3 = *a4;
  }
  else
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::FastFourierTransformOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::FastFourierTransformOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2 && a3[1] == a2[1];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::RealToHermiteanFFTOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::ModuleOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::RealToHermiteanFFTOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::FFTScalingModeAttr>(a1, v3 + 1) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *v4);
  uint64_t v5 = v4[1];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::RealToHermiteanFFTOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::RealToHermiteanFFTOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::RealToHermiteanFFTOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  uint64_t v27 = *MEMORY[0x263EF8340];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::RealToHermiteanFFTOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    long long v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.real_to_hermitean_fft";
    v25[1] = 25;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RealToHermiteanFFTOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::RealToHermiteanFFTOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::RealToHermiteanFFTOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    unint64_t v10 = (long long *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  }
  else {
    unint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  long long v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.real_to_hermitean_fft", 25, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (unint64_t v6 = a1, mlir::mps::RealToHermiteanFFTOp::verifyInvariantsImpl((mlir::mps::RealToHermiteanFFTOp *)&v6)))
  {
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::RealToHermiteanFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.reciprocal", 14, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReciprocalOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C366150;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    long long v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      unint64_t v11 = v32;
      uint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          unint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReciprocalOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReciprocalOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  uint64_t v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  uint64_t v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  uint64_t v24 = "mps.reciprocal";
  uint64_t v25 = 14;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::ReciprocalOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::ReciprocalOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::ReciprocalOpGenericAdaptorBase::ReciprocalOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ACosOp>,mlir::OpTrait::OneResult<mlir::mps::ACosOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ACosOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ACosOp>,mlir::OpTrait::OneOperand<mlir::mps::ACosOp>,mlir::OpTrait::OpInvariants<mlir::mps::ACosOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ACosOp>,mlir::OpTrait::Stitchable<mlir::mps::ACosOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ACosOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ACosOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::ReciprocalOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalSquareRootOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalSquareRootOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalSquareRootOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalSquareRootOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalSquareRootOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.reciprocal_square_root", 26, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReciprocalSquareRootOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C38CC90;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalSquareRootOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalSquareRootOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalSquareRootOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalSquareRootOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalSquareRootOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  unint64_t v11 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
      + 2;
  BOOL v6 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v10, a2);
  char v7 = v11;
  if (v11 >= 8)
  {
    if ((v11 & 4) != 0)
    {
      if ((v11 & 2) != 0) {
        uint64_t v8 = v10;
      }
      else {
        uint64_t v8 = (llvm **)v10[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v11 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v8, v2, v3, v4, v5);
    }
    if ((v7 & 2) == 0) {
      llvm::deallocate_buffer(v10[0], v10[1]);
    }
  }
  return v6;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalSquareRootOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalSquareRootOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unint64_t v10 = (unint64_t)&llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v9, a2, a3, a4, a5);
  char v7 = v10;
  if (v10 >= 8)
  {
    if ((v10 & 4) != 0)
    {
      if ((v10 & 2) != 0) {
        uint64_t v8 = v9;
      }
      else {
        uint64_t v8 = (llvm **)v9[0];
      }
      uint64_t result = (*(BOOL (**)(uint64_t, uint64_t))((v10 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v8, v6);
    }
    if ((v7 & 2) == 0) {
      llvm::deallocate_buffer(v9[0], v9[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalSquareRootOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalSquareRootOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalSquareRootOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalSquareRootOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalSquareRootOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalSquareRootOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalSquareRootOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    long long v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    unint64_t v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      uint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    char v13 = v29;
    if (v29)
    {
      unint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalSquareRootOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalSquareRootOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReciprocalSquareRootOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalSquareRootOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalSquareRootOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalSquareRootOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalSquareRootOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalSquareRootOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalSquareRootOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalSquareRootOp>::downgradeToVersion;
  char v3 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  {
    uint64_t v12 = v2;
    char v3 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DowngraderInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::DowngraderInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[420], v2);
}

ZinIrHalH13g *mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalSquareRootOp>::downgradeToVersion@<X0>(uint64_t a1@<X1>, void *a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v5 = a1;
  return mlir::mps::ReciprocalSquareRootOp::downgradeToVersion((ZinIrHalH13g *)&v5, a2, a3, a4);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalSquareRootOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalSquareRootOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalSquareRootOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalSquareRootOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalSquareRootOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalSquareRootOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReciprocalSquareRootOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReciprocalSquareRootOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReciprocalSquareRootOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  uint64_t v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  uint64_t v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  uint64_t v24 = "mps.reciprocal_square_root";
  uint64_t v25 = 26;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::ReciprocalSquareRootOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::ReciprocalSquareRootOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::ReciprocalSquareRootOpGenericAdaptorBase::ReciprocalSquareRootOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v234 = a1;
    v1 = (void *)&unk_267771000;
    int v40 = v39;
    a1 = v234;
    if (v40)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v248 = 83;
      unint64_t v41 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v41) {
        unint64_t v42 = v41;
      }
      else {
        unint64_t v42 = v248;
      }
      int v43 = &v247[v42];
      unint64_t v44 = v248 - v42;
      if (v248 - v42 >= 0x12) {
        uint64_t v45 = 18;
      }
      else {
        uint64_t v45 = v248 - v42;
      }
      unint64_t v46 = v44 - v45;
      if (v46 >= v46 - 1) {
        uint64_t v47 = v46 - 1;
      }
      else {
        uint64_t v47 = v46;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v43[v45], v47);
      v1 = (void *)&unk_267771000;
      a1 = v234;
    }
  }
  uint64_t v2 = v1[23];
  char v3 = &unk_267771000;
  {
    uint64_t v222 = v2;
    uint64_t v235 = a1;
    char v3 = (void *)&unk_267771000;
    int v49 = v48;
    uint64_t v2 = v222;
    a1 = v235;
    if (v49)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v248 = 81;
      unint64_t v50 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v50) {
        unint64_t v51 = v50;
      }
      else {
        unint64_t v51 = v248;
      }
      int v52 = &v247[v51];
      unint64_t v53 = v248 - v51;
      if (v248 - v51 >= 0x12) {
        uint64_t v54 = 18;
      }
      else {
        uint64_t v54 = v248 - v51;
      }
      unint64_t v55 = v53 - v54;
      if (v55 >= v55 - 1) {
        uint64_t v56 = v55 - 1;
      }
      else {
        uint64_t v56 = v55;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v222;
      a1 = v235;
    }
  }
  uint64_t v4 = v3[25];
  unint64_t v5 = &unk_267771000;
  {
    uint64_t v223 = v2;
    uint64_t v236 = a1;
    uint64_t v211 = v4;
    unint64_t v5 = (void *)&unk_267771000;
    uint64_t v4 = v211;
    uint64_t v2 = v223;
    int v58 = v57;
    a1 = v236;
    if (v58)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      unint64_t v248 = 104;
      unint64_t v59 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v59) {
        unint64_t v60 = v59;
      }
      else {
        unint64_t v60 = v248;
      }
      int v61 = &v247[v60];
      unint64_t v62 = v248 - v60;
      if (v248 - v60 >= 0x12) {
        uint64_t v63 = 18;
      }
      else {
        uint64_t v63 = v248 - v60;
      }
      unint64_t v64 = v62 - v63;
      if (v64 >= v64 - 1) {
        uint64_t v65 = v64 - 1;
      }
      else {
        uint64_t v65 = v64;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      unint64_t v5 = (void *)&unk_267771000;
      uint64_t v4 = v211;
      uint64_t v2 = v223;
      a1 = v236;
    }
  }
  uint64_t v6 = v5[318];
  uint64_t v7 = &unk_267770000;
  {
    uint64_t v224 = v2;
    uint64_t v237 = a1;
    uint64_t v201 = v6;
    uint64_t v212 = v4;
    uint64_t v7 = (void *)&unk_267770000;
    uint64_t v6 = v201;
    uint64_t v4 = v212;
    int v67 = v66;
    uint64_t v2 = v224;
    a1 = v237;
    if (v67)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v248 = 86;
      unint64_t v68 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v68) {
        unint64_t v69 = v68;
      }
      else {
        unint64_t v69 = v248;
      }
      int v70 = &v247[v69];
      unint64_t v71 = v248 - v69;
      if (v248 - v69 >= 0x12) {
        uint64_t v72 = 18;
      }
      else {
        uint64_t v72 = v248 - v69;
      }
      unint64_t v73 = v71 - v72;
      if (v73 >= v73 - 1) {
        uint64_t v74 = v73 - 1;
      }
      else {
        uint64_t v74 = v73;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      uint64_t v7 = (void *)&unk_267770000;
      uint64_t v6 = v201;
      uint64_t v4 = v212;
      uint64_t v2 = v224;
      a1 = v237;
    }
  }
  uint64_t v8 = v7[431];
  uint64_t v9 = &unk_267771000;
  {
    uint64_t v225 = v2;
    uint64_t v238 = a1;
    uint64_t v202 = v6;
    uint64_t v213 = v4;
    uint64_t v192 = v8;
    uint64_t v9 = (void *)&unk_267771000;
    uint64_t v8 = v192;
    uint64_t v6 = v202;
    uint64_t v4 = v213;
    int v76 = v75;
    uint64_t v2 = v225;
    a1 = v238;
    if (v76)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      unint64_t v248 = 82;
      unint64_t v77 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v77) {
        unint64_t v78 = v77;
      }
      else {
        unint64_t v78 = v248;
      }
      int v79 = &v247[v78];
      unint64_t v80 = v248 - v78;
      if (v248 - v78 >= 0x12) {
        uint64_t v81 = 18;
      }
      else {
        uint64_t v81 = v248 - v78;
      }
      unint64_t v82 = v80 - v81;
      if (v82 >= v82 - 1) {
        uint64_t v83 = v82 - 1;
      }
      else {
        uint64_t v83 = v82;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      uint64_t v9 = (void *)&unk_267771000;
      uint64_t v8 = v192;
      uint64_t v6 = v202;
      uint64_t v4 = v213;
      uint64_t v2 = v225;
      a1 = v238;
    }
  }
  uint64_t v10 = v9[29];
  uint64_t v11 = &unk_267770000;
  {
    uint64_t v226 = v2;
    uint64_t v239 = a1;
    uint64_t v203 = v6;
    uint64_t v214 = v4;
    uint64_t v184 = v10;
    uint64_t v193 = v8;
    uint64_t v11 = (void *)&unk_267770000;
    uint64_t v10 = v184;
    uint64_t v8 = v193;
    uint64_t v6 = v203;
    uint64_t v4 = v214;
    int v85 = v84;
    uint64_t v2 = v226;
    a1 = v239;
    if (v85)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v248 = 84;
      unint64_t v86 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v86) {
        unint64_t v87 = v86;
      }
      else {
        unint64_t v87 = v248;
      }
      int v88 = &v247[v87];
      unint64_t v89 = v248 - v87;
      if (v248 - v87 >= 0x12) {
        uint64_t v90 = 18;
      }
      else {
        uint64_t v90 = v248 - v87;
      }
      unint64_t v91 = v89 - v90;
      if (v91 >= v91 - 1) {
        uint64_t v92 = v91 - 1;
      }
      else {
        uint64_t v92 = v91;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      uint64_t v11 = (void *)&unk_267770000;
      uint64_t v10 = v184;
      uint64_t v8 = v193;
      uint64_t v6 = v203;
      uint64_t v4 = v214;
      uint64_t v2 = v226;
      a1 = v239;
    }
  }
  uint64_t v12 = v11[435];
  char v13 = &unk_267771000;
  {
    uint64_t v227 = v2;
    uint64_t v240 = a1;
    uint64_t v204 = v6;
    uint64_t v215 = v4;
    uint64_t v185 = v10;
    uint64_t v194 = v8;
    uint64_t v177 = v12;
    char v13 = (void *)&unk_267771000;
    uint64_t v12 = v177;
    uint64_t v10 = v185;
    uint64_t v8 = v194;
    uint64_t v6 = v204;
    uint64_t v4 = v215;
    int v94 = v93;
    uint64_t v2 = v227;
    a1 = v240;
    if (v94)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v248 = 93;
      unint64_t v95 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v95) {
        unint64_t v96 = v95;
      }
      else {
        unint64_t v96 = v248;
      }
      int v97 = &v247[v96];
      unint64_t v98 = v248 - v96;
      if (v248 - v96 >= 0x12) {
        uint64_t v99 = 18;
      }
      else {
        uint64_t v99 = v248 - v96;
      }
      unint64_t v100 = v98 - v99;
      if (v100 >= v100 - 1) {
        uint64_t v101 = v100 - 1;
      }
      else {
        uint64_t v101 = v100;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      char v13 = (void *)&unk_267771000;
      uint64_t v12 = v177;
      uint64_t v10 = v185;
      uint64_t v8 = v194;
      uint64_t v6 = v204;
      uint64_t v4 = v215;
      uint64_t v2 = v227;
      a1 = v240;
    }
  }
  uint64_t v14 = v13[31];
  uint64_t v15 = &unk_267771000;
  {
    uint64_t v228 = v2;
    uint64_t v241 = a1;
    uint64_t v205 = v6;
    uint64_t v216 = v4;
    uint64_t v186 = v10;
    uint64_t v195 = v8;
    uint64_t v171 = v14;
    uint64_t v178 = v12;
    uint64_t v15 = (void *)&unk_267771000;
    uint64_t v14 = v171;
    uint64_t v12 = v178;
    uint64_t v10 = v186;
    uint64_t v8 = v195;
    uint64_t v6 = v205;
    uint64_t v4 = v216;
    int v103 = v102;
    uint64_t v2 = v228;
    a1 = v241;
    if (v103)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultElementType<Empty>]";
      unint64_t v248 = 104;
      unint64_t v104 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v104) {
        unint64_t v105 = v104;
      }
      else {
        unint64_t v105 = v248;
      }
      int v106 = &v247[v105];
      unint64_t v107 = v248 - v105;
      if (v248 - v105 >= 0x12) {
        uint64_t v108 = 18;
      }
      else {
        uint64_t v108 = v248 - v105;
      }
      unint64_t v109 = v107 - v108;
      if (v109 >= v109 - 1) {
        uint64_t v110 = v109 - 1;
      }
      else {
        uint64_t v110 = v109;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultElementType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultElementType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      uint64_t v15 = (void *)&unk_267771000;
      uint64_t v14 = v171;
      uint64_t v12 = v178;
      uint64_t v10 = v186;
      uint64_t v8 = v195;
      uint64_t v6 = v205;
      uint64_t v4 = v216;
      uint64_t v2 = v228;
      a1 = v241;
    }
  }
  uint64_t v16 = v15[167];
  uint64_t v17 = &unk_267771000;
  {
    uint64_t v229 = v2;
    uint64_t v242 = a1;
    uint64_t v206 = v6;
    uint64_t v217 = v4;
    uint64_t v187 = v10;
    uint64_t v196 = v8;
    uint64_t v172 = v14;
    uint64_t v179 = v12;
    uint64_t v166 = v16;
    uint64_t v17 = (void *)&unk_267771000;
    uint64_t v16 = v166;
    uint64_t v14 = v172;
    uint64_t v12 = v179;
    uint64_t v10 = v187;
    uint64_t v8 = v196;
    uint64_t v6 = v206;
    uint64_t v4 = v217;
    int v112 = v111;
    uint64_t v2 = v229;
    a1 = v242;
    if (v112)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultType<Empty>]";
      unint64_t v248 = 97;
      unint64_t v113 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v113) {
        unint64_t v114 = v113;
      }
      else {
        unint64_t v114 = v248;
      }
      int v115 = &v247[v114];
      unint64_t v116 = v248 - v114;
      if (v248 - v114 >= 0x12) {
        uint64_t v117 = 18;
      }
      else {
        uint64_t v117 = v248 - v114;
      }
      unint64_t v118 = v116 - v117;
      if (v118 >= v118 - 1) {
        uint64_t v119 = v118 - 1;
      }
      else {
        uint64_t v119 = v118;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      uint64_t v17 = (void *)&unk_267771000;
      uint64_t v16 = v166;
      uint64_t v14 = v172;
      uint64_t v12 = v179;
      uint64_t v10 = v187;
      uint64_t v8 = v196;
      uint64_t v6 = v206;
      uint64_t v4 = v217;
      uint64_t v2 = v229;
      a1 = v242;
    }
  }
  uint64_t v18 = v17[328];
  unint64_t v19 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  {
    uint64_t v230 = v2;
    uint64_t v243 = a1;
    uint64_t v207 = v6;
    uint64_t v218 = v4;
    uint64_t v188 = v10;
    uint64_t v197 = v8;
    uint64_t v173 = v14;
    uint64_t v180 = v12;
    uint64_t v162 = v18;
    uint64_t v167 = v16;
    unint64_t v19 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    uint64_t v18 = v162;
    uint64_t v16 = v167;
    uint64_t v14 = v173;
    uint64_t v12 = v180;
    uint64_t v10 = v188;
    uint64_t v8 = v197;
    uint64_t v6 = v207;
    uint64_t v4 = v218;
    int v121 = v120;
    uint64_t v2 = v230;
    a1 = v243;
    if (v121)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Stitchable<Empty>]";
      unint64_t v248 = 82;
      unint64_t v122 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v122) {
        unint64_t v123 = v122;
      }
      else {
        unint64_t v123 = v248;
      }
      int v124 = &v247[v123];
      unint64_t v125 = v248 - v123;
      if (v248 - v123 >= 0x12) {
        uint64_t v126 = 18;
      }
      else {
        uint64_t v126 = v248 - v123;
      }
      unint64_t v127 = v125 - v126;
      if (v127 >= v127 - 1) {
        uint64_t v128 = v127 - 1;
      }
      else {
        uint64_t v128 = v127;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v124[v126], v128);
      unint64_t v19 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      uint64_t v18 = v162;
      uint64_t v16 = v167;
      uint64_t v14 = v173;
      uint64_t v12 = v180;
      uint64_t v10 = v188;
      uint64_t v8 = v197;
      uint64_t v6 = v207;
      uint64_t v4 = v218;
      uint64_t v2 = v230;
      a1 = v243;
    }
  }
  uint64_t v20 = v19[364];
  int v21 = &unk_267771000;
  {
    uint64_t v231 = v2;
    uint64_t v244 = a1;
    uint64_t v208 = v6;
    uint64_t v219 = v4;
    uint64_t v189 = v10;
    uint64_t v198 = v8;
    uint64_t v174 = v14;
    uint64_t v181 = v12;
    uint64_t v163 = v18;
    uint64_t v168 = v16;
    uint64_t v159 = v20;
    int v21 = (void *)&unk_267771000;
    uint64_t v20 = v159;
    uint64_t v18 = v163;
    uint64_t v16 = v168;
    uint64_t v14 = v174;
    uint64_t v12 = v181;
    uint64_t v10 = v189;
    uint64_t v8 = v198;
    uint64_t v6 = v208;
    uint64_t v4 = v219;
    int v130 = v129;
    uint64_t v2 = v231;
    a1 = v244;
    if (v130)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      unint64_t v248 = 100;
      unint64_t v131 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v131) {
        unint64_t v132 = v131;
      }
      else {
        unint64_t v132 = v248;
      }
      uint64_t v133 = &v247[v132];
      unint64_t v134 = v248 - v132;
      if (v248 - v132 >= 0x12) {
        uint64_t v135 = 18;
      }
      else {
        uint64_t v135 = v248 - v132;
      }
      unint64_t v136 = v134 - v135;
      if (v136 >= v136 - 1) {
        uint64_t v137 = v136 - 1;
      }
      else {
        uint64_t v137 = v136;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v133[v135], v137);
      int v21 = (void *)&unk_267771000;
      uint64_t v20 = v159;
      uint64_t v18 = v163;
      uint64_t v16 = v168;
      uint64_t v14 = v174;
      uint64_t v12 = v181;
      uint64_t v10 = v189;
      uint64_t v8 = v198;
      uint64_t v6 = v208;
      uint64_t v4 = v219;
      uint64_t v2 = v231;
      a1 = v244;
    }
  }
  uint64_t v22 = v21[41];
  uint64_t v23 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  {
    uint64_t v232 = v2;
    uint64_t v245 = a1;
    uint64_t v209 = v6;
    uint64_t v220 = v4;
    uint64_t v190 = v10;
    uint64_t v199 = v8;
    uint64_t v175 = v14;
    uint64_t v182 = v12;
    uint64_t v164 = v18;
    uint64_t v169 = v16;
    uint64_t v157 = v22;
    uint64_t v160 = v20;
    uint64_t v23 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    uint64_t v22 = v157;
    uint64_t v20 = v160;
    uint64_t v18 = v164;
    uint64_t v16 = v169;
    uint64_t v14 = v175;
    uint64_t v12 = v182;
    uint64_t v10 = v190;
    uint64_t v8 = v199;
    uint64_t v6 = v209;
    uint64_t v4 = v220;
    int v139 = v138;
    uint64_t v2 = v232;
    a1 = v245;
    if (v139)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DowngraderInterface::Trait<Empty>]";
      unint64_t v248 = 89;
      unint64_t v140 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v140) {
        unint64_t v141 = v140;
      }
      else {
        unint64_t v141 = v248;
      }
      uint64_t v142 = &v247[v141];
      unint64_t v143 = v248 - v141;
      if (v248 - v141 >= 0x12) {
        uint64_t v144 = 18;
      }
      else {
        uint64_t v144 = v248 - v141;
      }
      unint64_t v145 = v143 - v144;
      if (v145 >= v145 - 1) {
        uint64_t v146 = v145 - 1;
      }
      else {
        uint64_t v146 = v145;
      }
      mlir::detail::TypeIDResolver<mlir::DowngraderInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DowngraderInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v142[v144], v146);
      uint64_t v23 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      uint64_t v22 = v157;
      uint64_t v20 = v160;
      uint64_t v18 = v164;
      uint64_t v16 = v169;
      uint64_t v14 = v175;
      uint64_t v12 = v182;
      uint64_t v10 = v190;
      uint64_t v8 = v199;
      uint64_t v6 = v209;
      uint64_t v4 = v220;
      uint64_t v2 = v232;
      a1 = v245;
    }
  }
  uint64_t v24 = v23[422];
  uint64_t v25 = &unk_267771000;
  {
    uint64_t v233 = v2;
    uint64_t v246 = a1;
    uint64_t v210 = v6;
    uint64_t v221 = v4;
    uint64_t v191 = v10;
    uint64_t v200 = v8;
    uint64_t v176 = v14;
    uint64_t v183 = v12;
    uint64_t v165 = v18;
    uint64_t v170 = v16;
    uint64_t v158 = v22;
    uint64_t v161 = v20;
    uint64_t v156 = v24;
    uint64_t v25 = (void *)&unk_267771000;
    uint64_t v24 = v156;
    uint64_t v22 = v158;
    uint64_t v20 = v161;
    uint64_t v18 = v165;
    uint64_t v16 = v170;
    uint64_t v14 = v176;
    uint64_t v12 = v183;
    uint64_t v10 = v191;
    uint64_t v8 = v200;
    uint64_t v6 = v210;
    uint64_t v4 = v221;
    int v148 = v147;
    uint64_t v2 = v233;
    a1 = v246;
    if (v148)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v248 = 90;
      unint64_t v149 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v149) {
        unint64_t v150 = v149;
      }
      else {
        unint64_t v150 = v248;
      }
      uint64_t v151 = &v247[v150];
      unint64_t v152 = v248 - v150;
      if (v248 - v150 >= 0x12) {
        uint64_t v153 = 18;
      }
      else {
        uint64_t v153 = v248 - v150;
      }
      unint64_t v154 = v152 - v153;
      if (v154 >= v154 - 1) {
        uint64_t v155 = v154 - 1;
      }
      else {
        uint64_t v155 = v154;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v151[v153], v155);
      uint64_t v25 = (void *)&unk_267771000;
      uint64_t v24 = v156;
      uint64_t v22 = v158;
      uint64_t v20 = v161;
      uint64_t v18 = v165;
      uint64_t v16 = v170;
      uint64_t v14 = v176;
      uint64_t v12 = v183;
      uint64_t v10 = v191;
      uint64_t v8 = v200;
      uint64_t v6 = v210;
      uint64_t v4 = v221;
      uint64_t v2 = v233;
      a1 = v246;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v22 == a1
      || v24 == a1
      || v25[37] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ACosOp>,mlir::OpTrait::OneResult<mlir::mps::ACosOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ACosOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ACosOp>,mlir::OpTrait::OneOperand<mlir::mps::ACosOp>,mlir::OpTrait::OpInvariants<mlir::mps::ACosOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ACosOp>,mlir::OpTrait::Stitchable<mlir::mps::ACosOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ACosOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ACosOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::ReciprocalSquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.reduction_and", 17, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReductionAndOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C367668;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 9 && (*(void *)a3 == 0x6D69645F7065656BLL ? (BOOL v7 = *(unsigned char *)(a3 + 8) == 115) : (BOOL v7 = 0), v7)) {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 9 && *(void *)result == 0x6D69645F7065656BLL && *(unsigned char *)(result + 8) == 115)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      *uint64_t v5 = v9;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"keep_dims", 9, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (void **)"keep_dims", (const char *)9, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ReductionAndOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::ReductionAndOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionAndOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ReductionAndOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ReductionAndOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionAndOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionAndOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::ReductionAndOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.reduction_and";
    v25[1] = 17;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionAndOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionAndOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionAndOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  unint64_t v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  uint64_t v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.reduction_and", 17, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)1)) {
    return 0;
  }
  uint64_t v6 = a1;
  if (!mlir::mps::ReductionAndOp::verifyInvariantsImpl((mlir::mps::ReductionAndOp *)&v6)) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 46) & 0x80) != 0 && *(_DWORD *)(a1 + 68) >= 2u) {
  return 1;
  }
}

BOOL mlir::Op<mlir::mps::ReductionAndOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.reduction_argmax", 20, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReductionArgMaxOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C369418;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 9 && (*(void *)a3 == 0x6D69645F7065656BLL ? (BOOL v7 = *(unsigned char *)(a3 + 8) == 115) : (BOOL v7 = 0), v7)) {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 9 && *(void *)result == 0x6D69645F7065656BLL && *(unsigned char *)(result + 8) == 115)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      *uint64_t v5 = v9;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"keep_dims", 9, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (void **)"keep_dims", (const char *)9, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ReductionAndOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::ReductionAndOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMaxOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ReductionArgMaxOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ReductionArgMaxOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionArgMaxOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionArgMaxOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::ReductionArgMaxOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.reduction_argmax";
    v25[1] = 20;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMaxOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionArgMaxOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionArgMaxOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  unint64_t v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  uint64_t v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.reduction_argmax", 20, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)1)) {
    return 0;
  }
  uint64_t v6 = a1;
  if (!mlir::mps::ReductionArgMaxOp::verifyInvariantsImpl((mlir::mps::ReductionArgMaxOp *)&v6)) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 46) & 0x80) != 0 && *(_DWORD *)(a1 + 68) >= 2u) {
  return 1;
  }
}

BOOL mlir::Op<mlir::mps::ReductionArgMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.reduction_argmin", 20, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReductionArgMinOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C3694E0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 9 && (*(void *)a3 == 0x6D69645F7065656BLL ? (BOOL v7 = *(unsigned char *)(a3 + 8) == 115) : (BOOL v7 = 0), v7)) {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 9 && *(void *)result == 0x6D69645F7065656BLL && *(unsigned char *)(result + 8) == 115)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      *uint64_t v5 = v9;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"keep_dims", 9, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (void **)"keep_dims", (const char *)9, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ReductionAndOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::ReductionAndOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionArgMinOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ReductionArgMinOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ReductionArgMinOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionArgMinOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionArgMinOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::ReductionArgMinOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.reduction_argmin";
    v25[1] = 20;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionArgMinOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionArgMinOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionArgMinOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  unint64_t v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  uint64_t v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.reduction_argmin", 20, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)1)) {
    return 0;
  }
  uint64_t v6 = a1;
  if (!mlir::mps::ReductionArgMaxOp::verifyInvariantsImpl((mlir::mps::ReductionArgMaxOp *)&v6)) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 46) & 0x80) != 0 && *(_DWORD *)(a1 + 68) >= 2u) {
  return 1;
  }
}

BOOL mlir::Op<mlir::mps::ReductionArgMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.reduction_logsumexp", 23, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReductionLogSumExpOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36A3B8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 9 && (*(void *)a3 == 0x6D69645F7065656BLL ? (BOOL v7 = *(unsigned char *)(a3 + 8) == 115) : (BOOL v7 = 0), v7)) {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 9 && *(void *)result == 0x6D69645F7065656BLL && *(unsigned char *)(result + 8) == 115)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      *uint64_t v5 = v9;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"keep_dims", 9, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (void **)"keep_dims", (const char *)9, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ReductionAndOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::ReductionAndOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionLogSumExpOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ReductionLogSumExpOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ReductionLogSumExpOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionLogSumExpOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionLogSumExpOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::ReductionLogSumExpOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.reduction_logsumexp";
    v25[1] = 23;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionLogSumExpOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionLogSumExpOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionLogSumExpOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  unint64_t v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  uint64_t v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.reduction_logsumexp", 23, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)1)) {
    return 0;
  }
  uint64_t v6 = a1;
  if (!mlir::mps::ReductionAndOp::verifyInvariantsImpl((mlir::mps::ReductionAndOp *)&v6)) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 46) & 0x80) != 0 && *(_DWORD *)(a1 + 68) >= 2u) {
  return 1;
  }
}

BOOL mlir::Op<mlir::mps::ReductionLogSumExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.reduction_max", 17, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReductionMaxOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C367730;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v7 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v7 = 0;
  }
  if (a4 == 14)
  {
    if (*(void *)a3 != 0x74616761706F7270 || *(void *)(a3 + 6) != 0x736E616E5F657461) {
      return 0;
    }
    return v7[1];
  }
  else
  {
    if (a4 != 9) {
      return 0;
    }
    if (*(void *)a3 != 0x6D69645F7065656BLL || *(unsigned char *)(a3 + 8) != 115) {
      return 0;
    }
    return *v7;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v12);
  if (v7 == 14)
  {
    if (*(void *)result == 0x74616761706F7270 && *(void *)(result + 6) == 0x736E616E5F657461)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
          uint64_t v10 = a4;
        }
        else {
          uint64_t v10 = 0;
        }
        v5[1] = v10;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else if (v7 == 9 && *(void *)result == 0x6D69645F7065656BLL && *(unsigned char *)(result + 8) == 115)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
        uint64_t v11 = a4;
      }
      else {
        uint64_t v11 = 0;
      }
      *uint64_t v5 = v11;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  if (*v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"keep_dims", 9, *v5);
  }
  uint64_t v6 = v5[1];
  if (v6)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"propagate_nans", 14, v6);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  BOOL result = 0;
  if (!v9
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v9, (void **)"keep_dims", (const char *)9, a4, a5))
  {
    uint64_t v10 = mlir::NamedAttrList::get(a3, *(void *)(*(void *)(a2 + 96) + 8));
    if (!v10
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v10, (void **)"propagate_nans", (const char *)0xE, a4, a5))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::getOpPropertyByteSize()
{
  return 16;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    *(_OWORD *)a3 = *a4;
  }
  else
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ReductionMaxOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::ReductionMaxOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2 && a3[1] == a2[1];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMaxOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::ModuleOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ReductionMaxOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 1) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *v4);
  uint64_t v5 = v4[1];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 24);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ReductionMaxOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionMaxOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionMaxOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::ReductionMaxOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.reduction_max";
    v25[1] = 17;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionMaxOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionMaxOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionMaxOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    unint64_t v10 = (long long *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  }
  else {
    unint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  long long v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.reduction_max", 17, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)1)) {
    return 0;
  }
  uint64_t v6 = a1;
  if (!mlir::mps::ReductionMaxOp::verifyInvariantsImpl((mlir::mps::ReductionMaxOp *)&v6)) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 46) & 0x80) != 0 && *(_DWORD *)(a1 + 68) >= 2u) {
  return 1;
  }
}

BOOL mlir::Op<mlir::mps::ReductionMaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.reduction_mean", 18, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReductionMeanOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C3682E8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 9 && (*(void *)a3 == 0x6D69645F7065656BLL ? (BOOL v7 = *(unsigned char *)(a3 + 8) == 115) : (BOOL v7 = 0), v7)) {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 9 && *(void *)result == 0x6D69645F7065656BLL && *(unsigned char *)(result + 8) == 115)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      *uint64_t v5 = v9;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"keep_dims", 9, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (void **)"keep_dims", (const char *)9, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ReductionAndOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::ReductionAndOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMeanOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ReductionMeanOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ReductionMeanOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionMeanOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionMeanOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::ReductionMeanOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.reduction_mean";
    v25[1] = 18;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionMeanOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionMeanOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionMeanOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  unint64_t v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  uint64_t v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.reduction_mean", 18, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)1)) {
    return 0;
  }
  uint64_t v6 = a1;
  if (!mlir::mps::ReductionMeanOp::verifyInvariantsImpl((mlir::mps::ReductionMeanOp *)&v6)) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 46) & 0x80) != 0 && *(_DWORD *)(a1 + 68) >= 2u) {
  return 1;
  }
}

BOOL mlir::Op<mlir::mps::ReductionMeanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.reduction_min", 17, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReductionMinOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C3677F8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v7 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v7 = 0;
  }
  if (a4 == 14)
  {
    if (*(void *)a3 != 0x74616761706F7270 || *(void *)(a3 + 6) != 0x736E616E5F657461) {
      return 0;
    }
    return v7[1];
  }
  else
  {
    if (a4 != 9) {
      return 0;
    }
    if (*(void *)a3 != 0x6D69645F7065656BLL || *(unsigned char *)(a3 + 8) != 115) {
      return 0;
    }
    return *v7;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v12);
  if (v7 == 14)
  {
    if (*(void *)result == 0x74616761706F7270 && *(void *)(result + 6) == 0x736E616E5F657461)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
          uint64_t v10 = a4;
        }
        else {
          uint64_t v10 = 0;
        }
        v5[1] = v10;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else if (v7 == 9 && *(void *)result == 0x6D69645F7065656BLL && *(unsigned char *)(result + 8) == 115)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
        uint64_t v11 = a4;
      }
      else {
        uint64_t v11 = 0;
      }
      *uint64_t v5 = v11;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  if (*v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"keep_dims", 9, *v5);
  }
  uint64_t v6 = v5[1];
  if (v6)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"propagate_nans", 14, v6);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  BOOL result = 0;
  if (!v9
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v9, (void **)"keep_dims", (const char *)9, a4, a5))
  {
    uint64_t v10 = mlir::NamedAttrList::get(a3, *(void *)(*(void *)(a2 + 96) + 8));
    if (!v10
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v10, (void **)"propagate_nans", (const char *)0xE, a4, a5))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::getOpPropertyByteSize()
{
  return 16;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    *(_OWORD *)a3 = *a4;
  }
  else
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ReductionMaxOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::ReductionMaxOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2 && a3[1] == a2[1];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionMinOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::ModuleOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ReductionMinOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 1) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *v4);
  uint64_t v5 = v4[1];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 24);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ReductionMinOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionMinOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionMinOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::ReductionMinOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.reduction_min";
    v25[1] = 17;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionMinOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionMinOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionMinOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    unint64_t v10 = (long long *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  }
  else {
    unint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  long long v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.reduction_min", 17, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)1)) {
    return 0;
  }
  uint64_t v6 = a1;
  if (!mlir::mps::ReductionMaxOp::verifyInvariantsImpl((mlir::mps::ReductionMaxOp *)&v6)) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 46) & 0x80) != 0 && *(_DWORD *)(a1 + 68) >= 2u) {
  return 1;
  }
}

BOOL mlir::Op<mlir::mps::ReductionMinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.reduction_or", 16, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReductionOrOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C366920;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  unint64_t v9 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  char v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0) {
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v6 & 2) == 0) {
      llvm::deallocate_buffer(v8[0], v8[1]);
    }
  }
  return v5;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                       + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 9 && (*(void *)a3 == 0x6D69645F7065656BLL ? (BOOL v7 = *(unsigned char *)(a3 + 8) == 115) : (BOOL v7 = 0), v7)) {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 9 && *(void *)result == 0x6D69645F7065656BLL && *(unsigned char *)(result + 8) == 115)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      *uint64_t v5 = v9;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"keep_dims", 9, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (void **)"keep_dims", (const char *)9, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ReductionAndOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::ReductionAndOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionOrOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ReductionOrOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ReductionOrOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionOrOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionOrOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::ReductionOrOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.reduction_or";
    v25[1] = 16;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionOrOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionOrOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionOrOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  unint64_t v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  uint64_t v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.reduction_or", 16, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)1)) {
    return 0;
  }
  uint64_t v6 = a1;
  if (!mlir::mps::ReductionAndOp::verifyInvariantsImpl((mlir::mps::ReductionAndOp *)&v6)) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 46) & 0x80) != 0 && *(_DWORD *)(a1 + 68) >= 2u) {
  return 1;
  }
}

BOOL mlir::Op<mlir::mps::ReductionOrOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.reduction_prod", 18, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReductionProdOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C3683B0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 9 && (*(void *)a3 == 0x6D69645F7065656BLL ? (BOOL v7 = *(unsigned char *)(a3 + 8) == 115) : (BOOL v7 = 0), v7)) {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 9 && *(void *)result == 0x6D69645F7065656BLL && *(unsigned char *)(result + 8) == 115)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      *uint64_t v5 = v9;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"keep_dims", 9, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (void **)"keep_dims", (const char *)9, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ReductionAndOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::ReductionAndOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionProdOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ReductionProdOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ReductionProdOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionProdOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionProdOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::ReductionProdOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.reduction_prod";
    v25[1] = 18;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionProdOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionProdOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionProdOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  unint64_t v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  uint64_t v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.reduction_prod", 18, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)1)) {
    return 0;
  }
  uint64_t v6 = a1;
  if (!mlir::mps::ReductionMeanOp::verifyInvariantsImpl((mlir::mps::ReductionMeanOp *)&v6)) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 46) & 0x80) != 0 && *(_DWORD *)(a1 + 68) >= 2u) {
  return 1;
  }
}

BOOL mlir::Op<mlir::mps::ReductionProdOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.reduction_sum", 17, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReductionSumOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C3678C0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 9 && (*(void *)a3 == 0x6D69645F7065656BLL ? (BOOL v7 = *(unsigned char *)(a3 + 8) == 115) : (BOOL v7 = 0), v7)) {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 9 && *(void *)result == 0x6D69645F7065656BLL && *(unsigned char *)(result + 8) == 115)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      *uint64_t v5 = v9;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"keep_dims", 9, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (void **)"keep_dims", (const char *)9, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ReductionAndOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::ReductionAndOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionSumOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ReductionSumOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ReductionSumOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionSumOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionSumOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::ReductionSumOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.reduction_sum";
    v25[1] = 17;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionSumOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionSumOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionSumOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  unint64_t v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  uint64_t v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.reduction_sum", 17, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)1)) {
    return 0;
  }
  uint64_t v6 = a1;
  if (!mlir::mps::ReductionMeanOp::verifyInvariantsImpl((mlir::mps::ReductionMeanOp *)&v6)) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 46) & 0x80) != 0 && *(_DWORD *)(a1 + 68) >= 2u) {
  return 1;
  }
}

BOOL mlir::Op<mlir::mps::ReductionSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.reduction_variance", 22, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReductionVarianceOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C369E40;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 9 && (*(void *)a3 == 0x6D69645F7065656BLL ? (BOOL v7 = *(unsigned char *)(a3 + 8) == 115) : (BOOL v7 = 0), v7)) {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 9 && *(void *)result == 0x6D69645F7065656BLL && *(unsigned char *)(result + 8) == 115)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      *uint64_t v5 = v9;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"keep_dims", 9, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (void **)"keep_dims", (const char *)9, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ReductionAndOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::ReductionAndOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReductionVarianceOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ReductionVarianceOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ReductionVarianceOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionVarianceOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReductionVarianceOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::ReductionVarianceOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.reduction_variance";
    v25[1] = 22;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReductionVarianceOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionVarianceOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReductionVarianceOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  unint64_t v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  uint64_t v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.reduction_variance", 22, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)1)) {
    return 0;
  }
  uint64_t v6 = a1;
  if (!mlir::mps::ReductionAndOp::verifyInvariantsImpl((mlir::mps::ReductionAndOp *)&v6)) {
    return 0;
  }
  if ((*(unsigned char *)(a1 + 46) & 0x80) != 0 && *(_DWORD *)(a1 + 68) >= 2u) {
  return 1;
  }
}

BOOL mlir::Op<mlir::mps::ReductionVarianceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.reinterpret_cast", 20, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReinterpretCastOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C3695A8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 19
    && (*a3 == 0x655F746C75736572 ? (BOOL v7 = a3[1] == 0x745F746E656D656CLL) : (BOOL v7 = 0),
        v7 ? (BOOL v8 = *(void *)((char *)a3 + 11) == 0x657079745F746E65) : (BOOL v8 = 0),
        v8))
  {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else
  {
    return 0;
  }
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v11);
  if (v7 == 19)
  {
    BOOL v8 = *result == 0x655F746C75736572 && result[1] == 0x745F746E656D656CLL;
    if (v8 && *(void *)((char *)result + 11) == 0x657079745F746E65)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id) {
          uint64_t v10 = a4;
        }
        else {
          uint64_t v10 = 0;
        }
        *uint64_t v5 = v10;
      }
      else
      {
        *uint64_t v5 = 0;
      }
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"result_element_type", 19, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v7, (void **)"result_element_type", (const char *)0x13, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::RandomUniformOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::RandomUniformOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReinterpretCastOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ReinterpretCastOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::TypeAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 16))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, void **a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ReinterpretCastOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, void **a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReinterpretCastOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReinterpretCastOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, void **a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::ReinterpretCastOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.reinterpret_cast";
    v25[1] = 20;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReinterpretCastOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReinterpretCastOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReinterpretCastOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  unint64_t v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  uint64_t v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.reinterpret_cast", 20, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v187 = a1;
    v1 = (void *)&unk_267771000;
    int v34 = v33;
    a1 = v187;
    if (v34)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v199 = 83;
      unint64_t v35 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v35) {
        unint64_t v36 = v35;
      }
      else {
        unint64_t v36 = v199;
      }
      int v37 = &v198[v36];
      unint64_t v38 = v199 - v36;
      if (v199 - v36 >= 0x12) {
        uint64_t v39 = 18;
      }
      else {
        uint64_t v39 = v199 - v36;
      }
      unint64_t v40 = v38 - v39;
      if (v40 >= v40 - 1) {
        uint64_t v41 = v40 - 1;
      }
      else {
        uint64_t v41 = v40;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v37[v39], v41);
      v1 = (void *)&unk_267771000;
      a1 = v187;
    }
  }
  uint64_t v2 = v1[23];
  char v3 = &unk_267771000;
  {
    uint64_t v177 = v2;
    uint64_t v188 = a1;
    char v3 = (void *)&unk_267771000;
    int v43 = v42;
    uint64_t v2 = v177;
    a1 = v188;
    if (v43)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v199 = 81;
      unint64_t v44 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v44) {
        unint64_t v45 = v44;
      }
      else {
        unint64_t v45 = v199;
      }
      unint64_t v46 = &v198[v45];
      unint64_t v47 = v199 - v45;
      if (v199 - v45 >= 0x12) {
        uint64_t v48 = 18;
      }
      else {
        uint64_t v48 = v199 - v45;
      }
      unint64_t v49 = v47 - v48;
      if (v49 >= v49 - 1) {
        uint64_t v50 = v49 - 1;
      }
      else {
        uint64_t v50 = v49;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v46[v48], v50);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v177;
      a1 = v188;
    }
  }
  uint64_t v4 = v3[25];
  unint64_t v5 = &unk_267771000;
  {
    uint64_t v178 = v2;
    uint64_t v189 = a1;
    uint64_t v168 = v4;
    unint64_t v5 = (void *)&unk_267771000;
    uint64_t v4 = v168;
    uint64_t v2 = v178;
    int v52 = v51;
    a1 = v189;
    if (v52)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      unint64_t v199 = 104;
      unint64_t v53 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v53) {
        unint64_t v54 = v53;
      }
      else {
        unint64_t v54 = v199;
      }
      unint64_t v55 = &v198[v54];
      unint64_t v56 = v199 - v54;
      if (v199 - v54 >= 0x12) {
        uint64_t v57 = 18;
      }
      else {
        uint64_t v57 = v199 - v54;
      }
      unint64_t v58 = v56 - v57;
      if (v58 >= v58 - 1) {
        uint64_t v59 = v58 - 1;
      }
      else {
        uint64_t v59 = v58;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v55[v57], v59);
      unint64_t v5 = (void *)&unk_267771000;
      uint64_t v4 = v168;
      uint64_t v2 = v178;
      a1 = v189;
    }
  }
  uint64_t v6 = v5[318];
  uint64_t v7 = &unk_267770000;
  {
    uint64_t v179 = v2;
    uint64_t v190 = a1;
    uint64_t v169 = v4;
    uint64_t v160 = v6;
    uint64_t v7 = (void *)&unk_267770000;
    uint64_t v6 = v160;
    uint64_t v4 = v169;
    uint64_t v2 = v179;
    int v61 = v60;
    a1 = v190;
    if (v61)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v199 = 86;
      unint64_t v62 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v62) {
        unint64_t v63 = v62;
      }
      else {
        unint64_t v63 = v199;
      }
      unint64_t v64 = &v198[v63];
      unint64_t v65 = v199 - v63;
      if (v199 - v63 >= 0x12) {
        uint64_t v66 = 18;
      }
      else {
        uint64_t v66 = v199 - v63;
      }
      unint64_t v67 = v65 - v66;
      if (v67 >= v67 - 1) {
        uint64_t v68 = v67 - 1;
      }
      else {
        uint64_t v68 = v67;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v64[v66], v68);
      uint64_t v7 = (void *)&unk_267770000;
      uint64_t v6 = v160;
      uint64_t v4 = v169;
      uint64_t v2 = v179;
      a1 = v190;
    }
  }
  uint64_t v8 = v7[431];
  unint64_t v9 = &unk_267771000;
  {
    uint64_t v180 = v2;
    uint64_t v191 = a1;
    uint64_t v170 = v4;
    uint64_t v153 = v8;
    uint64_t v161 = v6;
    unint64_t v9 = (void *)&unk_267771000;
    uint64_t v8 = v153;
    uint64_t v6 = v161;
    uint64_t v4 = v170;
    uint64_t v2 = v180;
    int v70 = v69;
    a1 = v191;
    if (v70)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      unint64_t v199 = 82;
      unint64_t v71 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v71) {
        unint64_t v72 = v71;
      }
      else {
        unint64_t v72 = v199;
      }
      unint64_t v73 = &v198[v72];
      unint64_t v74 = v199 - v72;
      if (v199 - v72 >= 0x12) {
        uint64_t v75 = 18;
      }
      else {
        uint64_t v75 = v199 - v72;
      }
      unint64_t v76 = v74 - v75;
      if (v76 >= v76 - 1) {
        uint64_t v77 = v76 - 1;
      }
      else {
        uint64_t v77 = v76;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v73[v75], v77);
      unint64_t v9 = (void *)&unk_267771000;
      uint64_t v8 = v153;
      uint64_t v6 = v161;
      uint64_t v4 = v170;
      uint64_t v2 = v180;
      a1 = v191;
    }
  }
  uint64_t v10 = v9[29];
  unint64_t v11 = &unk_267770000;
  {
    uint64_t v181 = v2;
    uint64_t v192 = a1;
    uint64_t v171 = v4;
    uint64_t v154 = v8;
    uint64_t v162 = v6;
    uint64_t v147 = v10;
    unint64_t v11 = (void *)&unk_267770000;
    uint64_t v10 = v147;
    uint64_t v8 = v154;
    uint64_t v6 = v162;
    uint64_t v4 = v171;
    uint64_t v2 = v181;
    int v79 = v78;
    a1 = v192;
    if (v79)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v199 = 84;
      unint64_t v80 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v80) {
        unint64_t v81 = v80;
      }
      else {
        unint64_t v81 = v199;
      }
      unint64_t v82 = &v198[v81];
      unint64_t v83 = v199 - v81;
      if (v199 - v81 >= 0x12) {
        uint64_t v84 = 18;
      }
      else {
        uint64_t v84 = v199 - v81;
      }
      unint64_t v85 = v83 - v84;
      if (v85 >= v85 - 1) {
        uint64_t v86 = v85 - 1;
      }
      else {
        uint64_t v86 = v85;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v82[v84], v86);
      unint64_t v11 = (void *)&unk_267770000;
      uint64_t v10 = v147;
      uint64_t v8 = v154;
      uint64_t v6 = v162;
      uint64_t v4 = v171;
      uint64_t v2 = v181;
      a1 = v192;
    }
  }
  uint64_t v12 = v11[435];
  char v13 = &unk_267771000;
  {
    uint64_t v182 = v2;
    uint64_t v193 = a1;
    uint64_t v172 = v4;
    uint64_t v155 = v8;
    uint64_t v163 = v6;
    uint64_t v142 = v12;
    uint64_t v148 = v10;
    char v13 = (void *)&unk_267771000;
    uint64_t v12 = v142;
    uint64_t v10 = v148;
    uint64_t v8 = v155;
    uint64_t v6 = v163;
    uint64_t v4 = v172;
    uint64_t v2 = v182;
    int v88 = v87;
    a1 = v193;
    if (v88)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v199 = 89;
      unint64_t v89 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v89) {
        unint64_t v90 = v89;
      }
      else {
        unint64_t v90 = v199;
      }
      unint64_t v91 = &v198[v90];
      unint64_t v92 = v199 - v90;
      if (v199 - v90 >= 0x12) {
        uint64_t v93 = 18;
      }
      else {
        uint64_t v93 = v199 - v90;
      }
      unint64_t v94 = v92 - v93;
      if (v94 >= v94 - 1) {
        uint64_t v95 = v94 - 1;
      }
      else {
        uint64_t v95 = v94;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v91[v93], v95);
      char v13 = (void *)&unk_267771000;
      uint64_t v12 = v142;
      uint64_t v10 = v148;
      uint64_t v8 = v155;
      uint64_t v6 = v163;
      uint64_t v4 = v172;
      uint64_t v2 = v182;
      a1 = v193;
    }
  }
  uint64_t v14 = v13[320];
  unint64_t v15 = &unk_267771000;
  {
    uint64_t v183 = v2;
    uint64_t v194 = a1;
    uint64_t v173 = v4;
    uint64_t v156 = v8;
    uint64_t v164 = v6;
    uint64_t v143 = v12;
    uint64_t v149 = v10;
    uint64_t v138 = v14;
    unint64_t v15 = (void *)&unk_267771000;
    uint64_t v14 = v138;
    uint64_t v12 = v143;
    uint64_t v10 = v149;
    uint64_t v8 = v156;
    uint64_t v6 = v164;
    uint64_t v4 = v173;
    uint64_t v2 = v183;
    int v97 = v96;
    a1 = v194;
    if (v97)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v199 = 93;
      unint64_t v98 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v98) {
        unint64_t v99 = v98;
      }
      else {
        unint64_t v99 = v199;
      }
      unint64_t v100 = &v198[v99];
      unint64_t v101 = v199 - v99;
      if (v199 - v99 >= 0x12) {
        uint64_t v102 = 18;
      }
      else {
        uint64_t v102 = v199 - v99;
      }
      unint64_t v103 = v101 - v102;
      if (v103 >= v103 - 1) {
        uint64_t v104 = v103 - 1;
      }
      else {
        uint64_t v104 = v103;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v100[v102], v104);
      unint64_t v15 = (void *)&unk_267771000;
      uint64_t v14 = v138;
      uint64_t v12 = v143;
      uint64_t v10 = v149;
      uint64_t v8 = v156;
      uint64_t v6 = v164;
      uint64_t v4 = v173;
      uint64_t v2 = v183;
      a1 = v194;
    }
  }
  uint64_t v16 = v15[31];
  unint64_t v17 = &unk_267771000;
  {
    uint64_t v184 = v2;
    uint64_t v195 = a1;
    uint64_t v174 = v4;
    uint64_t v157 = v8;
    uint64_t v165 = v6;
    uint64_t v144 = v12;
    uint64_t v150 = v10;
    uint64_t v135 = v16;
    uint64_t v139 = v14;
    unint64_t v17 = (void *)&unk_267771000;
    uint64_t v16 = v135;
    uint64_t v14 = v139;
    uint64_t v12 = v144;
    uint64_t v10 = v150;
    uint64_t v8 = v157;
    uint64_t v6 = v165;
    uint64_t v4 = v174;
    uint64_t v2 = v184;
    int v106 = v105;
    a1 = v195;
    if (v106)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::TypeChanger<Empty>]";
      unint64_t v199 = 83;
      unint64_t v107 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v107) {
        unint64_t v108 = v107;
      }
      else {
        unint64_t v108 = v199;
      }
      unint64_t v109 = &v198[v108];
      unint64_t v110 = v199 - v108;
      if (v199 - v108 >= 0x12) {
        uint64_t v111 = 18;
      }
      else {
        uint64_t v111 = v199 - v108;
      }
      unint64_t v112 = v110 - v111;
      if (v112 >= v112 - 1) {
        uint64_t v113 = v112 - 1;
      }
      else {
        uint64_t v113 = v112;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::TypeChanger<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::TypeChanger>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v109[v111], v113);
      unint64_t v17 = (void *)&unk_267771000;
      uint64_t v16 = v135;
      uint64_t v14 = v139;
      uint64_t v12 = v144;
      uint64_t v10 = v150;
      uint64_t v8 = v157;
      uint64_t v6 = v165;
      uint64_t v4 = v174;
      uint64_t v2 = v184;
      a1 = v195;
    }
  }
  uint64_t v18 = v17[63];
  uint64_t v19 = &unk_267771000;
  {
    uint64_t v185 = v2;
    uint64_t v196 = a1;
    uint64_t v175 = v4;
    uint64_t v158 = v8;
    uint64_t v166 = v6;
    uint64_t v145 = v12;
    uint64_t v151 = v10;
    uint64_t v136 = v16;
    uint64_t v140 = v14;
    uint64_t v133 = v18;
    uint64_t v19 = (void *)&unk_267771000;
    uint64_t v18 = v133;
    uint64_t v16 = v136;
    uint64_t v14 = v140;
    uint64_t v12 = v145;
    uint64_t v10 = v151;
    uint64_t v8 = v158;
    uint64_t v6 = v166;
    uint64_t v4 = v175;
    uint64_t v2 = v185;
    int v115 = v114;
    a1 = v196;
    if (v115)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v199 = 90;
      unint64_t v116 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v116) {
        unint64_t v117 = v116;
      }
      else {
        unint64_t v117 = v199;
      }
      unint64_t v118 = &v198[v117];
      unint64_t v119 = v199 - v117;
      if (v199 - v117 >= 0x12) {
        uint64_t v120 = 18;
      }
      else {
        uint64_t v120 = v199 - v117;
      }
      unint64_t v121 = v119 - v120;
      if (v121 >= v121 - 1) {
        uint64_t v122 = v121 - 1;
      }
      else {
        uint64_t v122 = v121;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v118[v120], v122);
      uint64_t v19 = (void *)&unk_267771000;
      uint64_t v18 = v133;
      uint64_t v16 = v136;
      uint64_t v14 = v140;
      uint64_t v12 = v145;
      uint64_t v10 = v151;
      uint64_t v8 = v158;
      uint64_t v6 = v166;
      uint64_t v4 = v175;
      uint64_t v2 = v185;
      a1 = v196;
    }
  }
  uint64_t v20 = v19[37];
  char v21 = &unk_267771000;
  {
    uint64_t v186 = v2;
    uint64_t v197 = a1;
    uint64_t v176 = v4;
    uint64_t v159 = v8;
    uint64_t v167 = v6;
    uint64_t v146 = v12;
    uint64_t v152 = v10;
    uint64_t v137 = v16;
    uint64_t v141 = v14;
    uint64_t v132 = v20;
    uint64_t v134 = v18;
    char v21 = (void *)&unk_267771000;
    uint64_t v20 = v132;
    uint64_t v18 = v134;
    uint64_t v16 = v137;
    uint64_t v14 = v141;
    uint64_t v12 = v146;
    uint64_t v10 = v152;
    uint64_t v8 = v159;
    uint64_t v6 = v167;
    uint64_t v4 = v176;
    uint64_t v2 = v186;
    int v124 = v123;
    a1 = v197;
    if (v124)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      unint64_t v199 = 100;
      unint64_t v125 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v125) {
        unint64_t v126 = v125;
      }
      else {
        unint64_t v126 = v199;
      }
      unint64_t v127 = &v198[v126];
      unint64_t v128 = v199 - v126;
      if (v199 - v126 >= 0x12) {
        uint64_t v129 = 18;
      }
      else {
        uint64_t v129 = v199 - v126;
      }
      unint64_t v130 = v128 - v129;
      if (v130 >= v130 - 1) {
        uint64_t v131 = v130 - 1;
      }
      else {
        uint64_t v131 = v130;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v127[v129], v131);
      char v21 = (void *)&unk_267771000;
      uint64_t v20 = v132;
      uint64_t v18 = v134;
      uint64_t v16 = v137;
      uint64_t v14 = v141;
      uint64_t v12 = v146;
      uint64_t v10 = v152;
      uint64_t v8 = v159;
      uint64_t v6 = v167;
      uint64_t v4 = v176;
      uint64_t v2 = v186;
      a1 = v197;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v21[41] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneOperand(a1, v5)) {
    return 0;
  }
  uint64_t v7 = a1;
  if (!mlir::mps::ReinterpretCastOp::verifyInvariantsImpl((mlir::mps::ReinterpretCastOp *)&v7)) {
    return 0;
  }
  uint64_t v7 = a1;
  return mlir::mps::ReinterpretCastOp::verify((mlir::mps::ReinterpretCastOp *)&v7) != 0;
}

BOOL mlir::Op<mlir::mps::ReinterpretCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::Relu6Op>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Relu6Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Relu6Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Relu6Op>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.relu6", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::Relu6Op,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36DB30;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Relu6Op>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::Relu6Op>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Relu6Op>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::Relu6Op>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::Relu6Op>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::Relu6Op>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Relu6Op>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Relu6Op>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Relu6Op>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Relu6Op>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::Relu6Op>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Relu6Op>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Relu6Op>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Relu6Op>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      unint64_t v11 = v32;
      uint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          unint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Relu6Op>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Relu6Op>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Relu6Op>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Relu6Op>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Relu6Op>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Relu6Op>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Relu6Op>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Relu6Op>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Relu6Op>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Relu6Op>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Relu6Op>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Relu6Op>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Relu6Op>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Relu6Op>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::Relu6Op>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Relu6Op>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::Relu6Op>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  uint64_t v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  uint64_t v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  uint64_t v24 = "mps.relu6";
  uint64_t v25 = 9;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::Relu6Op>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::Relu6Op>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::Relu6OpGenericAdaptorBase::Relu6OpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::DegammaOp>,mlir::OpTrait::OneResult<mlir::mps::DegammaOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::DegammaOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::DegammaOp>,mlir::OpTrait::OneOperand<mlir::mps::DegammaOp>,mlir::OpTrait::OpInvariants<mlir::mps::DegammaOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::DegammaOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::DegammaOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::DegammaOp>,mlir::OpTrait::Stitchable<mlir::mps::DegammaOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::DegammaOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::DegammaOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::Relu6Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReluGradOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReluGradOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReluGradOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReluGradOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.relu_grad", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReluGradOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C365020;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluGradOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReluGradOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluGradOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReluGradOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReluGradOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReluGradOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluGradOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluGradOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluGradOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluGradOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReluGradOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluGradOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluGradOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluGradOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluGradOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluGradOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluGradOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReluGradOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReluGradOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReluGradOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReluGradOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReluGradOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReluGradOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReluGradOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReluGradOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReluGradOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReluGradOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReluGradOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReluGradOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReluGradOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReluGradOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  uint64_t v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  uint64_t v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  uint64_t v24 = "mps.relu_grad";
  uint64_t v25 = 13;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::ReluGradOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::ReluGradOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::ReluGradOpGenericAdaptorBase::ReluGradOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v165 = a1;
    v1 = (void *)&unk_267771000;
    int v31 = v30;
    a1 = v165;
    if (v31)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v176 = 83;
      unint64_t v32 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v32) {
        unint64_t v33 = v32;
      }
      else {
        unint64_t v33 = v176;
      }
      uint64_t v34 = &v175[v33];
      unint64_t v35 = v176 - v33;
      if (v176 - v33 >= 0x12) {
        uint64_t v36 = 18;
      }
      else {
        uint64_t v36 = v176 - v33;
      }
      unint64_t v37 = v35 - v36;
      if (v37 >= v37 - 1) {
        uint64_t v38 = v37 - 1;
      }
      else {
        uint64_t v38 = v37;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v34[v36], v38);
      v1 = (void *)&unk_267771000;
      a1 = v165;
    }
  }
  uint64_t v2 = v1[23];
  char v3 = &unk_267771000;
  {
    uint64_t v156 = v2;
    uint64_t v166 = a1;
    char v3 = (void *)&unk_267771000;
    int v40 = v39;
    uint64_t v2 = v156;
    a1 = v166;
    if (v40)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v176 = 81;
      unint64_t v41 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v41) {
        unint64_t v42 = v41;
      }
      else {
        unint64_t v42 = v176;
      }
      int v43 = &v175[v42];
      unint64_t v44 = v176 - v42;
      if (v176 - v42 >= 0x12) {
        uint64_t v45 = 18;
      }
      else {
        uint64_t v45 = v176 - v42;
      }
      unint64_t v46 = v44 - v45;
      if (v46 >= v46 - 1) {
        uint64_t v47 = v46 - 1;
      }
      else {
        uint64_t v47 = v46;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v43[v45], v47);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v156;
      a1 = v166;
    }
  }
  uint64_t v4 = v3[25];
  unint64_t v5 = &unk_267771000;
  {
    uint64_t v157 = v2;
    uint64_t v167 = a1;
    uint64_t v148 = v4;
    unint64_t v5 = (void *)&unk_267771000;
    uint64_t v4 = v148;
    int v49 = v48;
    uint64_t v2 = v157;
    a1 = v167;
    if (v49)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      unint64_t v176 = 104;
      unint64_t v50 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v50) {
        unint64_t v51 = v50;
      }
      else {
        unint64_t v51 = v176;
      }
      int v52 = &v175[v51];
      unint64_t v53 = v176 - v51;
      if (v176 - v51 >= 0x12) {
        uint64_t v54 = 18;
      }
      else {
        uint64_t v54 = v176 - v51;
      }
      unint64_t v55 = v53 - v54;
      if (v55 >= v55 - 1) {
        uint64_t v56 = v55 - 1;
      }
      else {
        uint64_t v56 = v55;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      unint64_t v5 = (void *)&unk_267771000;
      uint64_t v4 = v148;
      uint64_t v2 = v157;
      a1 = v167;
    }
  }
  uint64_t v6 = v5[318];
  uint64_t v7 = &unk_267770000;
  {
    uint64_t v158 = v2;
    uint64_t v168 = a1;
    uint64_t v141 = v6;
    uint64_t v149 = v4;
    uint64_t v7 = (void *)&unk_267770000;
    uint64_t v6 = v141;
    uint64_t v4 = v149;
    int v58 = v57;
    uint64_t v2 = v158;
    a1 = v168;
    if (v58)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v176 = 86;
      unint64_t v59 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v59) {
        unint64_t v60 = v59;
      }
      else {
        unint64_t v60 = v176;
      }
      int v61 = &v175[v60];
      unint64_t v62 = v176 - v60;
      if (v176 - v60 >= 0x12) {
        uint64_t v63 = 18;
      }
      else {
        uint64_t v63 = v176 - v60;
      }
      unint64_t v64 = v62 - v63;
      if (v64 >= v64 - 1) {
        uint64_t v65 = v64 - 1;
      }
      else {
        uint64_t v65 = v64;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      uint64_t v7 = (void *)&unk_267770000;
      uint64_t v6 = v141;
      uint64_t v4 = v149;
      uint64_t v2 = v158;
      a1 = v168;
    }
  }
  uint64_t v8 = v7[431];
  uint64_t v9 = &unk_267771000;
  {
    uint64_t v159 = v2;
    uint64_t v169 = a1;
    uint64_t v142 = v6;
    uint64_t v150 = v4;
    uint64_t v135 = v8;
    uint64_t v9 = (void *)&unk_267771000;
    uint64_t v8 = v135;
    uint64_t v6 = v142;
    uint64_t v4 = v150;
    int v67 = v66;
    uint64_t v2 = v159;
    a1 = v169;
    if (v67)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      unint64_t v176 = 90;
      unint64_t v68 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v68) {
        unint64_t v69 = v68;
      }
      else {
        unint64_t v69 = v176;
      }
      int v70 = &v175[v69];
      unint64_t v71 = v176 - v69;
      if (v176 - v69 >= 0x12) {
        uint64_t v72 = 18;
      }
      else {
        uint64_t v72 = v176 - v69;
      }
      unint64_t v73 = v71 - v72;
      if (v73 >= v73 - 1) {
        uint64_t v74 = v73 - 1;
      }
      else {
        uint64_t v74 = v73;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      uint64_t v9 = (void *)&unk_267771000;
      uint64_t v8 = v135;
      uint64_t v6 = v142;
      uint64_t v4 = v150;
      uint64_t v2 = v159;
      a1 = v169;
    }
  }
  uint64_t v10 = v9[89];
  uint64_t v11 = &unk_267770000;
  {
    uint64_t v160 = v2;
    uint64_t v170 = a1;
    uint64_t v143 = v6;
    uint64_t v151 = v4;
    uint64_t v130 = v10;
    uint64_t v136 = v8;
    uint64_t v11 = (void *)&unk_267770000;
    uint64_t v10 = v130;
    uint64_t v8 = v136;
    uint64_t v6 = v143;
    uint64_t v4 = v151;
    int v76 = v75;
    uint64_t v2 = v160;
    a1 = v170;
    if (v76)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v176 = 84;
      unint64_t v77 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v77) {
        unint64_t v78 = v77;
      }
      else {
        unint64_t v78 = v176;
      }
      int v79 = &v175[v78];
      unint64_t v80 = v176 - v78;
      if (v176 - v78 >= 0x12) {
        uint64_t v81 = 18;
      }
      else {
        uint64_t v81 = v176 - v78;
      }
      unint64_t v82 = v80 - v81;
      if (v82 >= v82 - 1) {
        uint64_t v83 = v82 - 1;
      }
      else {
        uint64_t v83 = v82;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      uint64_t v11 = (void *)&unk_267770000;
      uint64_t v10 = v130;
      uint64_t v8 = v136;
      uint64_t v6 = v143;
      uint64_t v4 = v151;
      uint64_t v2 = v160;
      a1 = v170;
    }
  }
  uint64_t v12 = v11[435];
  char v13 = &unk_267771000;
  {
    uint64_t v161 = v2;
    uint64_t v171 = a1;
    uint64_t v144 = v6;
    uint64_t v152 = v4;
    uint64_t v131 = v10;
    uint64_t v137 = v8;
    uint64_t v126 = v12;
    char v13 = (void *)&unk_267771000;
    uint64_t v12 = v126;
    uint64_t v10 = v131;
    uint64_t v8 = v137;
    uint64_t v6 = v144;
    uint64_t v4 = v152;
    int v85 = v84;
    uint64_t v2 = v161;
    a1 = v171;
    if (v85)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v176 = 93;
      unint64_t v86 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v86) {
        unint64_t v87 = v86;
      }
      else {
        unint64_t v87 = v176;
      }
      int v88 = &v175[v87];
      unint64_t v89 = v176 - v87;
      if (v176 - v87 >= 0x12) {
        uint64_t v90 = 18;
      }
      else {
        uint64_t v90 = v176 - v87;
      }
      unint64_t v91 = v89 - v90;
      if (v91 >= v91 - 1) {
        uint64_t v92 = v91 - 1;
      }
      else {
        uint64_t v92 = v91;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      char v13 = (void *)&unk_267771000;
      uint64_t v12 = v126;
      uint64_t v10 = v131;
      uint64_t v8 = v137;
      uint64_t v6 = v144;
      uint64_t v4 = v152;
      uint64_t v2 = v161;
      a1 = v171;
    }
  }
  uint64_t v14 = v13[31];
  uint64_t v15 = &unk_267771000;
  {
    uint64_t v162 = v2;
    uint64_t v172 = a1;
    uint64_t v145 = v6;
    uint64_t v153 = v4;
    uint64_t v132 = v10;
    uint64_t v138 = v8;
    uint64_t v123 = v14;
    uint64_t v127 = v12;
    uint64_t v15 = (void *)&unk_267771000;
    uint64_t v14 = v123;
    uint64_t v12 = v127;
    uint64_t v10 = v132;
    uint64_t v8 = v138;
    uint64_t v6 = v145;
    uint64_t v4 = v153;
    int v94 = v93;
    uint64_t v2 = v162;
    a1 = v172;
    if (v94)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultType<Empty>]";
      unint64_t v176 = 97;
      unint64_t v95 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v95) {
        unint64_t v96 = v95;
      }
      else {
        unint64_t v96 = v176;
      }
      int v97 = &v175[v96];
      unint64_t v98 = v176 - v96;
      if (v176 - v96 >= 0x12) {
        uint64_t v99 = 18;
      }
      else {
        uint64_t v99 = v176 - v96;
      }
      unint64_t v100 = v98 - v99;
      if (v100 >= v100 - 1) {
        uint64_t v101 = v100 - 1;
      }
      else {
        uint64_t v101 = v100;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      uint64_t v15 = (void *)&unk_267771000;
      uint64_t v14 = v123;
      uint64_t v12 = v127;
      uint64_t v10 = v132;
      uint64_t v8 = v138;
      uint64_t v6 = v145;
      uint64_t v4 = v153;
      uint64_t v2 = v162;
      a1 = v172;
    }
  }
  uint64_t v16 = v15[328];
  uint64_t v17 = &unk_267771000;
  {
    uint64_t v163 = v2;
    uint64_t v173 = a1;
    uint64_t v146 = v6;
    uint64_t v154 = v4;
    uint64_t v133 = v10;
    uint64_t v139 = v8;
    uint64_t v124 = v14;
    uint64_t v128 = v12;
    uint64_t v121 = v16;
    uint64_t v17 = (void *)&unk_267771000;
    uint64_t v16 = v121;
    uint64_t v14 = v124;
    uint64_t v12 = v128;
    uint64_t v10 = v133;
    uint64_t v8 = v139;
    uint64_t v6 = v146;
    uint64_t v4 = v154;
    int v103 = v102;
    uint64_t v2 = v163;
    a1 = v173;
    if (v103)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      unint64_t v176 = 100;
      unint64_t v104 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v104) {
        unint64_t v105 = v104;
      }
      else {
        unint64_t v105 = v176;
      }
      int v106 = &v175[v105];
      unint64_t v107 = v176 - v105;
      if (v176 - v105 >= 0x12) {
        uint64_t v108 = 18;
      }
      else {
        uint64_t v108 = v176 - v105;
      }
      unint64_t v109 = v107 - v108;
      if (v109 >= v109 - 1) {
        uint64_t v110 = v109 - 1;
      }
      else {
        uint64_t v110 = v109;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      uint64_t v17 = (void *)&unk_267771000;
      uint64_t v16 = v121;
      uint64_t v14 = v124;
      uint64_t v12 = v128;
      uint64_t v10 = v133;
      uint64_t v8 = v139;
      uint64_t v6 = v146;
      uint64_t v4 = v154;
      uint64_t v2 = v163;
      a1 = v173;
    }
  }
  uint64_t v18 = v17[41];
  unint64_t v19 = &unk_267771000;
  {
    uint64_t v164 = v2;
    uint64_t v174 = a1;
    uint64_t v147 = v6;
    uint64_t v155 = v4;
    uint64_t v134 = v10;
    uint64_t v140 = v8;
    uint64_t v125 = v14;
    uint64_t v129 = v12;
    uint64_t v120 = v18;
    uint64_t v122 = v16;
    unint64_t v19 = (void *)&unk_267771000;
    uint64_t v18 = v120;
    uint64_t v16 = v122;
    uint64_t v14 = v125;
    uint64_t v12 = v129;
    uint64_t v10 = v134;
    uint64_t v8 = v140;
    uint64_t v6 = v147;
    uint64_t v4 = v155;
    int v112 = v111;
    uint64_t v2 = v164;
    a1 = v174;
    if (v112)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v176 = 90;
      unint64_t v113 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v113) {
        unint64_t v114 = v113;
      }
      else {
        unint64_t v114 = v176;
      }
      int v115 = &v175[v114];
      unint64_t v116 = v176 - v114;
      if (v176 - v114 >= 0x12) {
        uint64_t v117 = 18;
      }
      else {
        uint64_t v117 = v176 - v114;
      }
      unint64_t v118 = v116 - v117;
      if (v118 >= v118 - 1) {
        uint64_t v119 = v118 - 1;
      }
      else {
        uint64_t v119 = v118;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      unint64_t v19 = (void *)&unk_267771000;
      uint64_t v18 = v120;
      uint64_t v16 = v122;
      uint64_t v14 = v125;
      uint64_t v12 = v129;
      uint64_t v10 = v134;
      uint64_t v8 = v140;
      uint64_t v6 = v147;
      uint64_t v4 = v155;
      uint64_t v2 = v164;
      a1 = v174;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v19[37] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ReluGradOp>,mlir::OpTrait::OneResult<mlir::mps::ReluGradOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ReluGradOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ReluGradOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::ReluGradOp>,mlir::OpTrait::OpInvariants<mlir::mps::ReluGradOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ReluGradOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ReluGradOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ReluGradOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ReluGradOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ReluGradOp>,mlir::OpTrait::OneResult<mlir::mps::ReluGradOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ReluGradOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ReluGradOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::ReluGradOp>,mlir::OpTrait::OpInvariants<mlir::mps::ReluGradOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ReluGradOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ReluGradOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ReluGradOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ReluGradOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (uint64_t v7 = a1, mlir::mps::FloorDivideOp::verifyInvariantsImpl((mlir::mps::FloorDivideOp *)&v7)))
  {
    return mlir::OpTrait::impl::verifySameOperandsAndResultType(a1, v5) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::ReluGradOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReluOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReluOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReluOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReluOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.relu", 8, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReluOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36CAC8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReluOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReluOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReluOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReluOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReluOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      uint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      int v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReluOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReluOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReluOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReluOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReluOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReluOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReluOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReluOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReluOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReluOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReluOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReluOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReluOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReluOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReluOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  uint64_t v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  uint64_t v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  uint64_t v24 = "mps.relu";
  uint64_t v25 = 8;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::ReluOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::ReluOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  mlir::mps::detail::ReluOpGenericAdaptorBase::ReluOpGenericAdaptorBase((uint64_t)v18, this);
  uint64_t v19 = a2;
  uint64_t v20 = a3;
  v17[0] = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v17[1] = v8;
  if (v17[0] && (unint64_t v9 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v17, v19, v20), v9 >= 8))
  {
    unint64_t v10 = v9;
    if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
    {
      uint64_t v11 = *(unsigned int *)(a4 + 8);
      if (v11 >= *(_DWORD *)(a4 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
        LODWORD(v11) = *(_DWORD *)(a4 + 8);
      }
      *(void *)(*(void *)a4 + 8 * v11) = v10;
      goto LABEL_13;
    }
    uint64_t v12 = 1;
    if (*(_DWORD *)(a4 + 8)) {
      return v12;
    }
  }
  else
  {
    uint64_t v12 = 0;
    if (*(_DWORD *)(a4 + 8)) {
      return v12;
    }
  }
  unint64_t v13 = mlir::OpTrait::impl::foldIdempotent(this, v8);
  if (v13 >= 8)
  {
    if ((mlir::Operation *)((char *)this - 16) == (mlir::Operation *)(v13 & ((uint64_t)(v13 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8)) {
      return 1;
    }
    uint64_t v14 = *(unsigned int *)(a4 + 8);
    if (v14 >= *(_DWORD *)(a4 + 12))
    {
      unint64_t v16 = v13;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v14 + 1, 8);
      unint64_t v13 = v16;
      LODWORD(v14) = *(_DWORD *)(a4 + 8);
    }
    *(void *)(*(void *)a4 + 8 * v14) = v13;
LABEL_13:
    ++*(_DWORD *)(a4 + 8);
    return 1;
  }
  return v12;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v234 = a1;
    v1 = (void *)&unk_267771000;
    int v40 = v39;
    a1 = v234;
    if (v40)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v248 = 83;
      unint64_t v41 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v41) {
        unint64_t v42 = v41;
      }
      else {
        unint64_t v42 = v248;
      }
      int v43 = &v247[v42];
      unint64_t v44 = v248 - v42;
      if (v248 - v42 >= 0x12) {
        uint64_t v45 = 18;
      }
      else {
        uint64_t v45 = v248 - v42;
      }
      unint64_t v46 = v44 - v45;
      if (v46 >= v46 - 1) {
        uint64_t v47 = v46 - 1;
      }
      else {
        uint64_t v47 = v46;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v43[v45], v47);
      v1 = (void *)&unk_267771000;
      a1 = v234;
    }
  }
  uint64_t v2 = v1[23];
  char v3 = &unk_267771000;
  {
    uint64_t v222 = v2;
    uint64_t v235 = a1;
    char v3 = (void *)&unk_267771000;
    int v49 = v48;
    uint64_t v2 = v222;
    a1 = v235;
    if (v49)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v248 = 81;
      unint64_t v50 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v50) {
        unint64_t v51 = v50;
      }
      else {
        unint64_t v51 = v248;
      }
      int v52 = &v247[v51];
      unint64_t v53 = v248 - v51;
      if (v248 - v51 >= 0x12) {
        uint64_t v54 = 18;
      }
      else {
        uint64_t v54 = v248 - v51;
      }
      unint64_t v55 = v53 - v54;
      if (v55 >= v55 - 1) {
        uint64_t v56 = v55 - 1;
      }
      else {
        uint64_t v56 = v55;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v222;
      a1 = v235;
    }
  }
  uint64_t v4 = v3[25];
  unint64_t v5 = &unk_267771000;
  {
    uint64_t v223 = v2;
    uint64_t v236 = a1;
    uint64_t v211 = v4;
    unint64_t v5 = (void *)&unk_267771000;
    uint64_t v4 = v211;
    uint64_t v2 = v223;
    int v58 = v57;
    a1 = v236;
    if (v58)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      unint64_t v248 = 104;
      unint64_t v59 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v59) {
        unint64_t v60 = v59;
      }
      else {
        unint64_t v60 = v248;
      }
      int v61 = &v247[v60];
      unint64_t v62 = v248 - v60;
      if (v248 - v60 >= 0x12) {
        uint64_t v63 = 18;
      }
      else {
        uint64_t v63 = v248 - v60;
      }
      unint64_t v64 = v62 - v63;
      if (v64 >= v64 - 1) {
        uint64_t v65 = v64 - 1;
      }
      else {
        uint64_t v65 = v64;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      unint64_t v5 = (void *)&unk_267771000;
      uint64_t v4 = v211;
      uint64_t v2 = v223;
      a1 = v236;
    }
  }
  uint64_t v6 = v5[318];
  uint64_t v7 = &unk_267770000;
  {
    uint64_t v224 = v2;
    uint64_t v237 = a1;
    uint64_t v201 = v6;
    uint64_t v212 = v4;
    uint64_t v7 = (void *)&unk_267770000;
    uint64_t v6 = v201;
    uint64_t v4 = v212;
    int v67 = v66;
    uint64_t v2 = v224;
    a1 = v237;
    if (v67)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v248 = 86;
      unint64_t v68 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v68) {
        unint64_t v69 = v68;
      }
      else {
        unint64_t v69 = v248;
      }
      int v70 = &v247[v69];
      unint64_t v71 = v248 - v69;
      if (v248 - v69 >= 0x12) {
        uint64_t v72 = 18;
      }
      else {
        uint64_t v72 = v248 - v69;
      }
      unint64_t v73 = v71 - v72;
      if (v73 >= v73 - 1) {
        uint64_t v74 = v73 - 1;
      }
      else {
        uint64_t v74 = v73;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      uint64_t v7 = (void *)&unk_267770000;
      uint64_t v6 = v201;
      uint64_t v4 = v212;
      uint64_t v2 = v224;
      a1 = v237;
    }
  }
  uint64_t v8 = v7[431];
  unint64_t v9 = &unk_267771000;
  {
    uint64_t v225 = v2;
    uint64_t v238 = a1;
    uint64_t v202 = v6;
    uint64_t v213 = v4;
    uint64_t v192 = v8;
    unint64_t v9 = (void *)&unk_267771000;
    uint64_t v8 = v192;
    uint64_t v6 = v202;
    uint64_t v4 = v213;
    int v76 = v75;
    uint64_t v2 = v225;
    a1 = v238;
    if (v76)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      unint64_t v248 = 82;
      unint64_t v77 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v77) {
        unint64_t v78 = v77;
      }
      else {
        unint64_t v78 = v248;
      }
      int v79 = &v247[v78];
      unint64_t v80 = v248 - v78;
      if (v248 - v78 >= 0x12) {
        uint64_t v81 = 18;
      }
      else {
        uint64_t v81 = v248 - v78;
      }
      unint64_t v82 = v80 - v81;
      if (v82 >= v82 - 1) {
        uint64_t v83 = v82 - 1;
      }
      else {
        uint64_t v83 = v82;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      unint64_t v9 = (void *)&unk_267771000;
      uint64_t v8 = v192;
      uint64_t v6 = v202;
      uint64_t v4 = v213;
      uint64_t v2 = v225;
      a1 = v238;
    }
  }
  uint64_t v10 = v9[29];
  uint64_t v11 = &unk_267770000;
  {
    uint64_t v226 = v2;
    uint64_t v239 = a1;
    uint64_t v203 = v6;
    uint64_t v214 = v4;
    uint64_t v184 = v10;
    uint64_t v193 = v8;
    uint64_t v11 = (void *)&unk_267770000;
    uint64_t v10 = v184;
    uint64_t v8 = v193;
    uint64_t v6 = v203;
    uint64_t v4 = v214;
    int v85 = v84;
    uint64_t v2 = v226;
    a1 = v239;
    if (v85)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v248 = 84;
      unint64_t v86 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v86) {
        unint64_t v87 = v86;
      }
      else {
        unint64_t v87 = v248;
      }
      int v88 = &v247[v87];
      unint64_t v89 = v248 - v87;
      if (v248 - v87 >= 0x12) {
        uint64_t v90 = 18;
      }
      else {
        uint64_t v90 = v248 - v87;
      }
      unint64_t v91 = v89 - v90;
      if (v91 >= v91 - 1) {
        uint64_t v92 = v91 - 1;
      }
      else {
        uint64_t v92 = v91;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      uint64_t v11 = (void *)&unk_267770000;
      uint64_t v10 = v184;
      uint64_t v8 = v193;
      uint64_t v6 = v203;
      uint64_t v4 = v214;
      uint64_t v2 = v226;
      a1 = v239;
    }
  }
  uint64_t v12 = v11[435];
  unint64_t v13 = &unk_267771000;
  {
    uint64_t v227 = v2;
    uint64_t v240 = a1;
    uint64_t v204 = v6;
    uint64_t v215 = v4;
    uint64_t v185 = v10;
    uint64_t v194 = v8;
    uint64_t v177 = v12;
    unint64_t v13 = (void *)&unk_267771000;
    uint64_t v12 = v177;
    uint64_t v10 = v185;
    uint64_t v8 = v194;
    uint64_t v6 = v204;
    uint64_t v4 = v215;
    int v94 = v93;
    uint64_t v2 = v227;
    a1 = v240;
    if (v94)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v248 = 93;
      unint64_t v95 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v95) {
        unint64_t v96 = v95;
      }
      else {
        unint64_t v96 = v248;
      }
      int v97 = &v247[v96];
      unint64_t v98 = v248 - v96;
      if (v248 - v96 >= 0x12) {
        uint64_t v99 = 18;
      }
      else {
        uint64_t v99 = v248 - v96;
      }
      unint64_t v100 = v98 - v99;
      if (v100 >= v100 - 1) {
        uint64_t v101 = v100 - 1;
      }
      else {
        uint64_t v101 = v100;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      unint64_t v13 = (void *)&unk_267771000;
      uint64_t v12 = v177;
      uint64_t v10 = v185;
      uint64_t v8 = v194;
      uint64_t v6 = v204;
      uint64_t v4 = v215;
      uint64_t v2 = v227;
      a1 = v240;
    }
  }
  uint64_t v14 = v13[31];
  uint64_t v15 = &unk_267771000;
  {
    uint64_t v228 = v2;
    uint64_t v241 = a1;
    uint64_t v205 = v6;
    uint64_t v216 = v4;
    uint64_t v186 = v10;
    uint64_t v195 = v8;
    uint64_t v171 = v14;
    uint64_t v178 = v12;
    uint64_t v15 = (void *)&unk_267771000;
    uint64_t v14 = v171;
    uint64_t v12 = v178;
    uint64_t v10 = v186;
    uint64_t v8 = v195;
    uint64_t v6 = v205;
    uint64_t v4 = v216;
    int v103 = v102;
    uint64_t v2 = v228;
    a1 = v241;
    if (v103)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultElementType<Empty>]";
      unint64_t v248 = 104;
      unint64_t v104 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v104) {
        unint64_t v105 = v104;
      }
      else {
        unint64_t v105 = v248;
      }
      int v106 = &v247[v105];
      unint64_t v107 = v248 - v105;
      if (v248 - v105 >= 0x12) {
        uint64_t v108 = 18;
      }
      else {
        uint64_t v108 = v248 - v105;
      }
      unint64_t v109 = v107 - v108;
      if (v109 >= v109 - 1) {
        uint64_t v110 = v109 - 1;
      }
      else {
        uint64_t v110 = v109;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultElementType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultElementType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      uint64_t v15 = (void *)&unk_267771000;
      uint64_t v14 = v171;
      uint64_t v12 = v178;
      uint64_t v10 = v186;
      uint64_t v8 = v195;
      uint64_t v6 = v205;
      uint64_t v4 = v216;
      uint64_t v2 = v228;
      a1 = v241;
    }
  }
  uint64_t v16 = v15[167];
  uint64_t v17 = &unk_267771000;
  {
    uint64_t v229 = v2;
    uint64_t v242 = a1;
    uint64_t v206 = v6;
    uint64_t v217 = v4;
    uint64_t v187 = v10;
    uint64_t v196 = v8;
    uint64_t v172 = v14;
    uint64_t v179 = v12;
    uint64_t v166 = v16;
    uint64_t v17 = (void *)&unk_267771000;
    uint64_t v16 = v166;
    uint64_t v14 = v172;
    uint64_t v12 = v179;
    uint64_t v10 = v187;
    uint64_t v8 = v196;
    uint64_t v6 = v206;
    uint64_t v4 = v217;
    int v112 = v111;
    uint64_t v2 = v229;
    a1 = v242;
    if (v112)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultType<Empty>]";
      unint64_t v248 = 97;
      unint64_t v113 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v113) {
        unint64_t v114 = v113;
      }
      else {
        unint64_t v114 = v248;
      }
      int v115 = &v247[v114];
      unint64_t v116 = v248 - v114;
      if (v248 - v114 >= 0x12) {
        uint64_t v117 = 18;
      }
      else {
        uint64_t v117 = v248 - v114;
      }
      unint64_t v118 = v116 - v117;
      if (v118 >= v118 - 1) {
        uint64_t v119 = v118 - 1;
      }
      else {
        uint64_t v119 = v118;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      uint64_t v17 = (void *)&unk_267771000;
      uint64_t v16 = v166;
      uint64_t v14 = v172;
      uint64_t v12 = v179;
      uint64_t v10 = v187;
      uint64_t v8 = v196;
      uint64_t v6 = v206;
      uint64_t v4 = v217;
      uint64_t v2 = v229;
      a1 = v242;
    }
  }
  uint64_t v18 = v17[328];
  uint64_t v19 = &unk_267771000;
  {
    uint64_t v230 = v2;
    uint64_t v243 = a1;
    uint64_t v207 = v6;
    uint64_t v218 = v4;
    uint64_t v188 = v10;
    uint64_t v197 = v8;
    uint64_t v173 = v14;
    uint64_t v180 = v12;
    uint64_t v162 = v18;
    uint64_t v167 = v16;
    uint64_t v19 = (void *)&unk_267771000;
    uint64_t v18 = v162;
    uint64_t v16 = v167;
    uint64_t v14 = v173;
    uint64_t v12 = v180;
    uint64_t v10 = v188;
    uint64_t v8 = v197;
    uint64_t v6 = v207;
    uint64_t v4 = v218;
    int v121 = v120;
    uint64_t v2 = v230;
    a1 = v243;
    if (v121)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsIdempotent<Empty>]";
      unint64_t v248 = 84;
      unint64_t v122 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v122) {
        unint64_t v123 = v122;
      }
      else {
        unint64_t v123 = v248;
      }
      uint64_t v124 = &v247[v123];
      unint64_t v125 = v248 - v123;
      if (v248 - v123 >= 0x12) {
        uint64_t v126 = 18;
      }
      else {
        uint64_t v126 = v248 - v123;
      }
      unint64_t v127 = v125 - v126;
      if (v127 >= v127 - 1) {
        uint64_t v128 = v127 - 1;
      }
      else {
        uint64_t v128 = v127;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsIdempotent<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIdempotent>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v124[v126], v128);
      uint64_t v19 = (void *)&unk_267771000;
      uint64_t v18 = v162;
      uint64_t v16 = v167;
      uint64_t v14 = v173;
      uint64_t v12 = v180;
      uint64_t v10 = v188;
      uint64_t v8 = v197;
      uint64_t v6 = v207;
      uint64_t v4 = v218;
      uint64_t v2 = v230;
      a1 = v243;
    }
  }
  uint64_t v20 = v19[352];
  uint64_t v21 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  {
    uint64_t v231 = v2;
    uint64_t v244 = a1;
    uint64_t v208 = v6;
    uint64_t v219 = v4;
    uint64_t v189 = v10;
    uint64_t v198 = v8;
    uint64_t v174 = v14;
    uint64_t v181 = v12;
    uint64_t v163 = v18;
    uint64_t v168 = v16;
    uint64_t v159 = v20;
    uint64_t v21 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    uint64_t v20 = v159;
    uint64_t v18 = v163;
    uint64_t v16 = v168;
    uint64_t v14 = v174;
    uint64_t v12 = v181;
    uint64_t v10 = v189;
    uint64_t v8 = v198;
    uint64_t v6 = v208;
    uint64_t v4 = v219;
    int v130 = v129;
    uint64_t v2 = v231;
    a1 = v244;
    if (v130)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Stitchable<Empty>]";
      unint64_t v248 = 82;
      unint64_t v131 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v131) {
        unint64_t v132 = v131;
      }
      else {
        unint64_t v132 = v248;
      }
      uint64_t v133 = &v247[v132];
      unint64_t v134 = v248 - v132;
      if (v248 - v132 >= 0x12) {
        uint64_t v135 = 18;
      }
      else {
        uint64_t v135 = v248 - v132;
      }
      unint64_t v136 = v134 - v135;
      if (v136 >= v136 - 1) {
        uint64_t v137 = v136 - 1;
      }
      else {
        uint64_t v137 = v136;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v133[v135], v137);
      uint64_t v21 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      uint64_t v20 = v159;
      uint64_t v18 = v163;
      uint64_t v16 = v168;
      uint64_t v14 = v174;
      uint64_t v12 = v181;
      uint64_t v10 = v189;
      uint64_t v8 = v198;
      uint64_t v6 = v208;
      uint64_t v4 = v219;
      uint64_t v2 = v231;
      a1 = v244;
    }
  }
  uint64_t v22 = v21[364];
  uint64_t v23 = &unk_267771000;
  {
    uint64_t v232 = v2;
    uint64_t v245 = a1;
    uint64_t v209 = v6;
    uint64_t v220 = v4;
    uint64_t v190 = v10;
    uint64_t v199 = v8;
    uint64_t v175 = v14;
    uint64_t v182 = v12;
    uint64_t v164 = v18;
    uint64_t v169 = v16;
    uint64_t v157 = v22;
    uint64_t v160 = v20;
    uint64_t v23 = (void *)&unk_267771000;
    uint64_t v22 = v157;
    uint64_t v20 = v160;
    uint64_t v18 = v164;
    uint64_t v16 = v169;
    uint64_t v14 = v175;
    uint64_t v12 = v182;
    uint64_t v10 = v190;
    uint64_t v8 = v199;
    uint64_t v6 = v209;
    uint64_t v4 = v220;
    int v139 = v138;
    uint64_t v2 = v232;
    a1 = v245;
    if (v139)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      unint64_t v248 = 100;
      unint64_t v140 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v140) {
        unint64_t v141 = v140;
      }
      else {
        unint64_t v141 = v248;
      }
      uint64_t v142 = &v247[v141];
      unint64_t v143 = v248 - v141;
      if (v248 - v141 >= 0x12) {
        uint64_t v144 = 18;
      }
      else {
        uint64_t v144 = v248 - v141;
      }
      unint64_t v145 = v143 - v144;
      if (v145 >= v145 - 1) {
        uint64_t v146 = v145 - 1;
      }
      else {
        uint64_t v146 = v145;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v142[v144], v146);
      uint64_t v23 = (void *)&unk_267771000;
      uint64_t v22 = v157;
      uint64_t v20 = v160;
      uint64_t v18 = v164;
      uint64_t v16 = v169;
      uint64_t v14 = v175;
      uint64_t v12 = v182;
      uint64_t v10 = v190;
      uint64_t v8 = v199;
      uint64_t v6 = v209;
      uint64_t v4 = v220;
      uint64_t v2 = v232;
      a1 = v245;
    }
  }
  uint64_t v24 = v23[41];
  uint64_t v25 = &unk_267771000;
  {
    uint64_t v233 = v2;
    uint64_t v246 = a1;
    uint64_t v210 = v6;
    uint64_t v221 = v4;
    uint64_t v191 = v10;
    uint64_t v200 = v8;
    uint64_t v176 = v14;
    uint64_t v183 = v12;
    uint64_t v165 = v18;
    uint64_t v170 = v16;
    uint64_t v158 = v22;
    uint64_t v161 = v20;
    uint64_t v156 = v24;
    uint64_t v25 = (void *)&unk_267771000;
    uint64_t v24 = v156;
    uint64_t v22 = v158;
    uint64_t v20 = v161;
    uint64_t v18 = v165;
    uint64_t v16 = v170;
    uint64_t v14 = v176;
    uint64_t v12 = v183;
    uint64_t v10 = v191;
    uint64_t v8 = v200;
    uint64_t v6 = v210;
    uint64_t v4 = v221;
    int v148 = v147;
    uint64_t v2 = v233;
    a1 = v246;
    if (v148)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v248 = 90;
      unint64_t v149 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v149) {
        unint64_t v150 = v149;
      }
      else {
        unint64_t v150 = v248;
      }
      uint64_t v151 = &v247[v150];
      unint64_t v152 = v248 - v150;
      if (v248 - v150 >= 0x12) {
        uint64_t v153 = 18;
      }
      else {
        uint64_t v153 = v248 - v150;
      }
      unint64_t v154 = v152 - v153;
      if (v154 >= v154 - 1) {
        uint64_t v155 = v154 - 1;
      }
      else {
        uint64_t v155 = v154;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v151[v153], v155);
      uint64_t v25 = (void *)&unk_267771000;
      uint64_t v24 = v156;
      uint64_t v22 = v158;
      uint64_t v20 = v161;
      uint64_t v18 = v165;
      uint64_t v16 = v170;
      uint64_t v14 = v176;
      uint64_t v12 = v183;
      uint64_t v10 = v191;
      uint64_t v8 = v200;
      uint64_t v6 = v210;
      uint64_t v4 = v221;
      uint64_t v2 = v233;
      a1 = v246;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v22 == a1
      || v24 == a1
      || v25[37] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ReluOp>,mlir::OpTrait::OneResult<mlir::mps::ReluOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ReluOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ReluOp>,mlir::OpTrait::OneOperand<mlir::mps::ReluOp>,mlir::OpTrait::OpInvariants<mlir::mps::ReluOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ReluOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ReluOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ReluOp>,mlir::OpTrait::IsIdempotent<mlir::mps::ReluOp>,mlir::OpTrait::Stitchable<mlir::mps::ReluOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ReluOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ReluOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ReluOp>,mlir::OpTrait::OneResult<mlir::mps::ReluOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ReluOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ReluOp>,mlir::OpTrait::OneOperand<mlir::mps::ReluOp>,mlir::OpTrait::OpInvariants<mlir::mps::ReluOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ReluOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ReluOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ReluOp>,mlir::OpTrait::IsIdempotent<mlir::mps::ReluOp>,mlir::OpTrait::Stitchable<mlir::mps::ReluOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ReluOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ReluOp>>(uint64_t a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand((mlir::OpTrait::impl *)a1, v5)
    && mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(a1, (void **)(*(void *)(*(void *)(*(void *)(a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"operand", 7, 0)&& (*(_DWORD *)(a1 + 36) ? (uint64_t v6 = a1 - 16) : (uint64_t v6 = 0), (NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0), mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(a1, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0))&& mlir::OpTrait::impl::verifySameOperandsAndResultElementType((mlir::OpTrait::impl *)a1, v8)&& mlir::OpTrait::impl::verifySameOperandsAndResultType((mlir::OpTrait::impl *)a1, v9)))
  {
    return ZinIrConstData_specialization<half>::prepare() != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::ReluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::IsIdempotent,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.reshape", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36F2A0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 12 && (*(void *)a3 == 0x5F73695F6F72657ALL ? (BOOL v7 = *(_DWORD *)(a3 + 8) == 2037411683) : (BOOL v7 = 0), v7)) {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 12 && *(void *)result == 0x5F73695F6F72657ALL && *(_DWORD *)(result + 8) == 2037411683)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      *uint64_t v5 = v9;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"zero_is_copy", 12, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (void **)"zero_is_copy", (const char *)0xC, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ReshapeOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::ReshapeOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReshapeOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ReshapeOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ReshapeOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReshapeOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReshapeOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::ReshapeOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.reshape";
    v25[1] = 11;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReshapeOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReshapeOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReshapeOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  unint64_t v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  uint64_t v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.reshape", 11, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v187 = a1;
    v1 = (void *)&unk_267771000;
    int v34 = v33;
    a1 = v187;
    if (v34)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v199 = 83;
      unint64_t v35 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v35) {
        unint64_t v36 = v35;
      }
      else {
        unint64_t v36 = v199;
      }
      unint64_t v37 = &v198[v36];
      unint64_t v38 = v199 - v36;
      if (v199 - v36 >= 0x12) {
        uint64_t v39 = 18;
      }
      else {
        uint64_t v39 = v199 - v36;
      }
      unint64_t v40 = v38 - v39;
      if (v40 >= v40 - 1) {
        uint64_t v41 = v40 - 1;
      }
      else {
        uint64_t v41 = v40;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v37[v39], v41);
      v1 = (void *)&unk_267771000;
      a1 = v187;
    }
  }
  uint64_t v2 = v1[23];
  char v3 = &unk_267771000;
  {
    uint64_t v177 = v2;
    uint64_t v188 = a1;
    char v3 = (void *)&unk_267771000;
    int v43 = v42;
    uint64_t v2 = v177;
    a1 = v188;
    if (v43)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v199 = 81;
      unint64_t v44 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v44) {
        unint64_t v45 = v44;
      }
      else {
        unint64_t v45 = v199;
      }
      unint64_t v46 = &v198[v45];
      unint64_t v47 = v199 - v45;
      if (v199 - v45 >= 0x12) {
        uint64_t v48 = 18;
      }
      else {
        uint64_t v48 = v199 - v45;
      }
      unint64_t v49 = v47 - v48;
      if (v49 >= v49 - 1) {
        uint64_t v50 = v49 - 1;
      }
      else {
        uint64_t v50 = v49;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v46[v48], v50);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v177;
      a1 = v188;
    }
  }
  uint64_t v4 = v3[25];
  unint64_t v5 = &unk_267771000;
  {
    uint64_t v178 = v2;
    uint64_t v189 = a1;
    uint64_t v168 = v4;
    unint64_t v5 = (void *)&unk_267771000;
    uint64_t v4 = v168;
    uint64_t v2 = v178;
    int v52 = v51;
    a1 = v189;
    if (v52)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      unint64_t v199 = 104;
      unint64_t v53 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v53) {
        unint64_t v54 = v53;
      }
      else {
        unint64_t v54 = v199;
      }
      unint64_t v55 = &v198[v54];
      unint64_t v56 = v199 - v54;
      if (v199 - v54 >= 0x12) {
        uint64_t v57 = 18;
      }
      else {
        uint64_t v57 = v199 - v54;
      }
      unint64_t v58 = v56 - v57;
      if (v58 >= v58 - 1) {
        uint64_t v59 = v58 - 1;
      }
      else {
        uint64_t v59 = v58;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v55[v57], v59);
      unint64_t v5 = (void *)&unk_267771000;
      uint64_t v4 = v168;
      uint64_t v2 = v178;
      a1 = v189;
    }
  }
  uint64_t v6 = v5[318];
  uint64_t v7 = &unk_267770000;
  {
    uint64_t v179 = v2;
    uint64_t v190 = a1;
    uint64_t v169 = v4;
    uint64_t v160 = v6;
    uint64_t v7 = (void *)&unk_267770000;
    uint64_t v6 = v160;
    uint64_t v4 = v169;
    uint64_t v2 = v179;
    int v61 = v60;
    a1 = v190;
    if (v61)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v199 = 86;
      unint64_t v62 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v62) {
        unint64_t v63 = v62;
      }
      else {
        unint64_t v63 = v199;
      }
      unint64_t v64 = &v198[v63];
      unint64_t v65 = v199 - v63;
      if (v199 - v63 >= 0x12) {
        uint64_t v66 = 18;
      }
      else {
        uint64_t v66 = v199 - v63;
      }
      unint64_t v67 = v65 - v66;
      if (v67 >= v67 - 1) {
        uint64_t v68 = v67 - 1;
      }
      else {
        uint64_t v68 = v67;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v64[v66], v68);
      uint64_t v7 = (void *)&unk_267770000;
      uint64_t v6 = v160;
      uint64_t v4 = v169;
      uint64_t v2 = v179;
      a1 = v190;
    }
  }
  uint64_t v8 = v7[431];
  unint64_t v9 = &unk_267771000;
  {
    uint64_t v180 = v2;
    uint64_t v191 = a1;
    uint64_t v170 = v4;
    uint64_t v153 = v8;
    uint64_t v161 = v6;
    unint64_t v9 = (void *)&unk_267771000;
    uint64_t v8 = v153;
    uint64_t v6 = v161;
    uint64_t v4 = v170;
    uint64_t v2 = v180;
    int v70 = v69;
    a1 = v191;
    if (v70)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      unint64_t v199 = 90;
      unint64_t v71 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v71) {
        unint64_t v72 = v71;
      }
      else {
        unint64_t v72 = v199;
      }
      unint64_t v73 = &v198[v72];
      unint64_t v74 = v199 - v72;
      if (v199 - v72 >= 0x12) {
        uint64_t v75 = 18;
      }
      else {
        uint64_t v75 = v199 - v72;
      }
      unint64_t v76 = v74 - v75;
      if (v76 >= v76 - 1) {
        uint64_t v77 = v76 - 1;
      }
      else {
        uint64_t v77 = v76;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v73[v75], v77);
      unint64_t v9 = (void *)&unk_267771000;
      uint64_t v8 = v153;
      uint64_t v6 = v161;
      uint64_t v4 = v170;
      uint64_t v2 = v180;
      a1 = v191;
    }
  }
  uint64_t v10 = v9[89];
  unint64_t v11 = &unk_267770000;
  {
    uint64_t v181 = v2;
    uint64_t v192 = a1;
    uint64_t v171 = v4;
    uint64_t v154 = v8;
    uint64_t v162 = v6;
    uint64_t v147 = v10;
    unint64_t v11 = (void *)&unk_267770000;
    uint64_t v10 = v147;
    uint64_t v8 = v154;
    uint64_t v6 = v162;
    uint64_t v4 = v171;
    uint64_t v2 = v181;
    int v79 = v78;
    a1 = v192;
    if (v79)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v199 = 84;
      unint64_t v80 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v80) {
        unint64_t v81 = v80;
      }
      else {
        unint64_t v81 = v199;
      }
      unint64_t v82 = &v198[v81];
      unint64_t v83 = v199 - v81;
      if (v199 - v81 >= 0x12) {
        uint64_t v84 = 18;
      }
      else {
        uint64_t v84 = v199 - v81;
      }
      unint64_t v85 = v83 - v84;
      if (v85 >= v85 - 1) {
        uint64_t v86 = v85 - 1;
      }
      else {
        uint64_t v86 = v85;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v82[v84], v86);
      unint64_t v11 = (void *)&unk_267770000;
      uint64_t v10 = v147;
      uint64_t v8 = v154;
      uint64_t v6 = v162;
      uint64_t v4 = v171;
      uint64_t v2 = v181;
      a1 = v192;
    }
  }
  uint64_t v12 = v11[435];
  char v13 = &unk_267771000;
  {
    uint64_t v182 = v2;
    uint64_t v193 = a1;
    uint64_t v172 = v4;
    uint64_t v155 = v8;
    uint64_t v163 = v6;
    uint64_t v142 = v12;
    uint64_t v148 = v10;
    char v13 = (void *)&unk_267771000;
    uint64_t v12 = v142;
    uint64_t v10 = v148;
    uint64_t v8 = v155;
    uint64_t v6 = v163;
    uint64_t v4 = v172;
    uint64_t v2 = v182;
    int v88 = v87;
    a1 = v193;
    if (v88)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v199 = 89;
      unint64_t v89 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v89) {
        unint64_t v90 = v89;
      }
      else {
        unint64_t v90 = v199;
      }
      unint64_t v91 = &v198[v90];
      unint64_t v92 = v199 - v90;
      if (v199 - v90 >= 0x12) {
        uint64_t v93 = 18;
      }
      else {
        uint64_t v93 = v199 - v90;
      }
      unint64_t v94 = v92 - v93;
      if (v94 >= v94 - 1) {
        uint64_t v95 = v94 - 1;
      }
      else {
        uint64_t v95 = v94;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v91[v93], v95);
      char v13 = (void *)&unk_267771000;
      uint64_t v12 = v142;
      uint64_t v10 = v148;
      uint64_t v8 = v155;
      uint64_t v6 = v163;
      uint64_t v4 = v172;
      uint64_t v2 = v182;
      a1 = v193;
    }
  }
  uint64_t v14 = v13[320];
  unint64_t v15 = &unk_267771000;
  {
    uint64_t v183 = v2;
    uint64_t v194 = a1;
    uint64_t v173 = v4;
    uint64_t v156 = v8;
    uint64_t v164 = v6;
    uint64_t v143 = v12;
    uint64_t v149 = v10;
    uint64_t v138 = v14;
    unint64_t v15 = (void *)&unk_267771000;
    uint64_t v14 = v138;
    uint64_t v12 = v143;
    uint64_t v10 = v149;
    uint64_t v8 = v156;
    uint64_t v6 = v164;
    uint64_t v4 = v173;
    uint64_t v2 = v183;
    int v97 = v96;
    a1 = v194;
    if (v97)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v199 = 93;
      unint64_t v98 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v98) {
        unint64_t v99 = v98;
      }
      else {
        unint64_t v99 = v199;
      }
      unint64_t v100 = &v198[v99];
      unint64_t v101 = v199 - v99;
      if (v199 - v99 >= 0x12) {
        uint64_t v102 = 18;
      }
      else {
        uint64_t v102 = v199 - v99;
      }
      unint64_t v103 = v101 - v102;
      if (v103 >= v103 - 1) {
        uint64_t v104 = v103 - 1;
      }
      else {
        uint64_t v104 = v103;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v100[v102], v104);
      unint64_t v15 = (void *)&unk_267771000;
      uint64_t v14 = v138;
      uint64_t v12 = v143;
      uint64_t v10 = v149;
      uint64_t v8 = v156;
      uint64_t v6 = v164;
      uint64_t v4 = v173;
      uint64_t v2 = v183;
      a1 = v194;
    }
  }
  uint64_t v16 = v15[31];
  unint64_t v17 = &unk_267771000;
  {
    uint64_t v184 = v2;
    uint64_t v195 = a1;
    uint64_t v174 = v4;
    uint64_t v157 = v8;
    uint64_t v165 = v6;
    uint64_t v144 = v12;
    uint64_t v150 = v10;
    uint64_t v135 = v16;
    uint64_t v139 = v14;
    unint64_t v17 = (void *)&unk_267771000;
    uint64_t v16 = v135;
    uint64_t v14 = v139;
    uint64_t v12 = v144;
    uint64_t v10 = v150;
    uint64_t v8 = v157;
    uint64_t v6 = v165;
    uint64_t v4 = v174;
    uint64_t v2 = v184;
    int v106 = v105;
    a1 = v195;
    if (v106)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::TypeChanger<Empty>]";
      unint64_t v199 = 83;
      unint64_t v107 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v107) {
        unint64_t v108 = v107;
      }
      else {
        unint64_t v108 = v199;
      }
      unint64_t v109 = &v198[v108];
      unint64_t v110 = v199 - v108;
      if (v199 - v108 >= 0x12) {
        uint64_t v111 = 18;
      }
      else {
        uint64_t v111 = v199 - v108;
      }
      unint64_t v112 = v110 - v111;
      if (v112 >= v112 - 1) {
        uint64_t v113 = v112 - 1;
      }
      else {
        uint64_t v113 = v112;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::TypeChanger<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::TypeChanger>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v109[v111], v113);
      unint64_t v17 = (void *)&unk_267771000;
      uint64_t v16 = v135;
      uint64_t v14 = v139;
      uint64_t v12 = v144;
      uint64_t v10 = v150;
      uint64_t v8 = v157;
      uint64_t v6 = v165;
      uint64_t v4 = v174;
      uint64_t v2 = v184;
      a1 = v195;
    }
  }
  uint64_t v18 = v17[63];
  uint64_t v19 = &unk_267771000;
  {
    uint64_t v185 = v2;
    uint64_t v196 = a1;
    uint64_t v175 = v4;
    uint64_t v158 = v8;
    uint64_t v166 = v6;
    uint64_t v145 = v12;
    uint64_t v151 = v10;
    uint64_t v136 = v16;
    uint64_t v140 = v14;
    uint64_t v133 = v18;
    uint64_t v19 = (void *)&unk_267771000;
    uint64_t v18 = v133;
    uint64_t v16 = v136;
    uint64_t v14 = v140;
    uint64_t v12 = v145;
    uint64_t v10 = v151;
    uint64_t v8 = v158;
    uint64_t v6 = v166;
    uint64_t v4 = v175;
    uint64_t v2 = v185;
    int v115 = v114;
    a1 = v196;
    if (v115)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v199 = 90;
      unint64_t v116 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v116) {
        unint64_t v117 = v116;
      }
      else {
        unint64_t v117 = v199;
      }
      unint64_t v118 = &v198[v117];
      unint64_t v119 = v199 - v117;
      if (v199 - v117 >= 0x12) {
        uint64_t v120 = 18;
      }
      else {
        uint64_t v120 = v199 - v117;
      }
      unint64_t v121 = v119 - v120;
      if (v121 >= v121 - 1) {
        uint64_t v122 = v121 - 1;
      }
      else {
        uint64_t v122 = v121;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v118[v120], v122);
      uint64_t v19 = (void *)&unk_267771000;
      uint64_t v18 = v133;
      uint64_t v16 = v136;
      uint64_t v14 = v140;
      uint64_t v12 = v145;
      uint64_t v10 = v151;
      uint64_t v8 = v158;
      uint64_t v6 = v166;
      uint64_t v4 = v175;
      uint64_t v2 = v185;
      a1 = v196;
    }
  }
  uint64_t v20 = v19[37];
  char v21 = &unk_267771000;
  {
    uint64_t v186 = v2;
    uint64_t v197 = a1;
    uint64_t v176 = v4;
    uint64_t v159 = v8;
    uint64_t v167 = v6;
    uint64_t v146 = v12;
    uint64_t v152 = v10;
    uint64_t v137 = v16;
    uint64_t v141 = v14;
    uint64_t v132 = v20;
    uint64_t v134 = v18;
    char v21 = (void *)&unk_267771000;
    uint64_t v20 = v132;
    uint64_t v18 = v134;
    uint64_t v16 = v137;
    uint64_t v14 = v141;
    uint64_t v12 = v146;
    uint64_t v10 = v152;
    uint64_t v8 = v159;
    uint64_t v6 = v167;
    uint64_t v4 = v176;
    uint64_t v2 = v186;
    int v124 = v123;
    a1 = v197;
    if (v124)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      unint64_t v199 = 100;
      unint64_t v125 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v125) {
        unint64_t v126 = v125;
      }
      else {
        unint64_t v126 = v199;
      }
      unint64_t v127 = &v198[v126];
      unint64_t v128 = v199 - v126;
      if (v199 - v126 >= 0x12) {
        uint64_t v129 = 18;
      }
      else {
        uint64_t v129 = v199 - v126;
      }
      unint64_t v130 = v128 - v129;
      if (v130 >= v130 - 1) {
        uint64_t v131 = v130 - 1;
      }
      else {
        uint64_t v131 = v130;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v127[v129], v131);
      char v21 = (void *)&unk_267771000;
      uint64_t v20 = v132;
      uint64_t v18 = v134;
      uint64_t v16 = v137;
      uint64_t v14 = v141;
      uint64_t v12 = v146;
      uint64_t v10 = v152;
      uint64_t v8 = v159;
      uint64_t v6 = v167;
      uint64_t v4 = v176;
      uint64_t v2 = v186;
      a1 = v197;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v21[41] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)) {
    return 0;
  }
  uint64_t v6 = a1;
  if (!mlir::mps::ReshapeOp::verifyInvariantsImpl((mlir::mps::ReshapeOp *)&v6)) {
    return 0;
  }
  uint64_t v6 = a1;
  return mlir::mps::ReshapeOp::verify((mlir::mps::ReshapeOp *)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::ReshapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ResizeGradientOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.resize_gradient", 19, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ResizeGradientOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C3689F0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::mps::ResizeGradientOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::ResizeGradientOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::mps::ResizeGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::ResizeGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::getOpPropertyByteSize()
{
  return 48;
}

double mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::initProperties(uint64_t a1, uint64_t a2, _OWORD *a3, long long *a4)
{
  if (a4)
  {
    long long v4 = *a4;
    long long v5 = a4[2];
    a3[1] = a4[1];
    a3[2] = v5;
    *a3 = v4;
  }
  else
  {
    *(void *)&long long v4 = 0;
    a3[1] = 0u;
    a3[2] = 0u;
    *a3 = 0u;
  }
  return *(double *)&v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ResizeGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::mps::ResizeGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  long long v4 = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(a2 + 32) = v4;
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  if (*a3 != *a2) {
    return 0;
  }
  if (a3[1] != a2[1]) {
    return 0;
  }
  if (a3[2] != a2[2]) {
    return 0;
  }
  if (a3[3] != a2[3]) {
    return 0;
  }
  return a3[4] == a2[4] && a3[5] == a2[5];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ResizeGradientOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::scf::ForallOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeGradientOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeGradientOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeGradientOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::mps::ResizeGradientOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeGradientOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeGradientOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeGradientOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeGradientOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeGradientOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, void *a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ResizeGradientOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeGradientOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, void *a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ResizeGradientOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ResizeGradientOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, void *a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::ResizeGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.resize_gradient";
    v25[1] = 19;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ResizeGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ResizeGradientOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ResizeGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ResizeGradientOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ResizeGradientOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    unint64_t v10 = (long long *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  }
  else {
    unint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v29, v12, v11);
  uint64_t v20 = v8;
  v21[0] = 0;
  char v22 = 0;
  long long v13 = v10[1];
  long long v23 = *v10;
  long long v24 = v13;
  long long v25 = v10[2];
  long long v26 = *(_OWORD *)v29;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22) {
      char v22 = 0;
    }
    mlir::OperationName::OperationName(v21, "mps.resize_gradient", 19, Context);
    char v22 = 1;
  }
  uint64_t v27 = a2;
  uint64_t v28 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v29[0] = result;
  v29[1] = v16;
  if (result)
  {
    unint64_t v17 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v29, v27, v28);
    if (v17 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v18 = v17;
      if (a1 - 16 != (v17 & ((uint64_t)(v17 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v19 = *(unsigned int *)(a4 + 8);
        if (v19 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v19 + 1, 8);
          LODWORD(v19) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v19) = v18;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v187 = a1;
    v1 = (void *)&unk_267771000;
    int v34 = v33;
    a1 = v187;
    if (v34)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v199 = 83;
      unint64_t v35 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v35) {
        unint64_t v36 = v35;
      }
      else {
        unint64_t v36 = v199;
      }
      unint64_t v37 = &v198[v36];
      unint64_t v38 = v199 - v36;
      if (v199 - v36 >= 0x12) {
        uint64_t v39 = 18;
      }
      else {
        uint64_t v39 = v199 - v36;
      }
      unint64_t v40 = v38 - v39;
      if (v40 >= v40 - 1) {
        uint64_t v41 = v40 - 1;
      }
      else {
        uint64_t v41 = v40;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v37[v39], v41);
      v1 = (void *)&unk_267771000;
      a1 = v187;
    }
  }
  uint64_t v2 = v1[23];
  char v3 = &unk_267771000;
  {
    uint64_t v177 = v2;
    uint64_t v188 = a1;
    char v3 = (void *)&unk_267771000;
    int v43 = v42;
    uint64_t v2 = v177;
    a1 = v188;
    if (v43)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v199 = 81;
      unint64_t v44 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v44) {
        unint64_t v45 = v44;
      }
      else {
        unint64_t v45 = v199;
      }
      unint64_t v46 = &v198[v45];
      unint64_t v47 = v199 - v45;
      if (v199 - v45 >= 0x12) {
        uint64_t v48 = 18;
      }
      else {
        uint64_t v48 = v199 - v45;
      }
      unint64_t v49 = v47 - v48;
      if (v49 >= v49 - 1) {
        uint64_t v50 = v49 - 1;
      }
      else {
        uint64_t v50 = v49;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v46[v48], v50);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v177;
      a1 = v188;
    }
  }
  uint64_t v4 = v3[25];
  unint64_t v5 = &unk_267771000;
  {
    uint64_t v178 = v2;
    uint64_t v189 = a1;
    uint64_t v168 = v4;
    unint64_t v5 = (void *)&unk_267771000;
    uint64_t v4 = v168;
    uint64_t v2 = v178;
    int v52 = v51;
    a1 = v189;
    if (v52)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      unint64_t v199 = 104;
      unint64_t v53 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v53) {
        unint64_t v54 = v53;
      }
      else {
        unint64_t v54 = v199;
      }
      unint64_t v55 = &v198[v54];
      unint64_t v56 = v199 - v54;
      if (v199 - v54 >= 0x12) {
        uint64_t v57 = 18;
      }
      else {
        uint64_t v57 = v199 - v54;
      }
      unint64_t v58 = v56 - v57;
      if (v58 >= v58 - 1) {
        uint64_t v59 = v58 - 1;
      }
      else {
        uint64_t v59 = v58;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v55[v57], v59);
      unint64_t v5 = (void *)&unk_267771000;
      uint64_t v4 = v168;
      uint64_t v2 = v178;
      a1 = v189;
    }
  }
  uint64_t v6 = v5[318];
  size_t v7 = &unk_267770000;
  {
    uint64_t v179 = v2;
    uint64_t v190 = a1;
    uint64_t v169 = v4;
    uint64_t v160 = v6;
    size_t v7 = (void *)&unk_267770000;
    uint64_t v6 = v160;
    uint64_t v4 = v169;
    uint64_t v2 = v179;
    int v61 = v60;
    a1 = v190;
    if (v61)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v199 = 86;
      unint64_t v62 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v62) {
        unint64_t v63 = v62;
      }
      else {
        unint64_t v63 = v199;
      }
      unint64_t v64 = &v198[v63];
      unint64_t v65 = v199 - v63;
      if (v199 - v63 >= 0x12) {
        uint64_t v66 = 18;
      }
      else {
        uint64_t v66 = v199 - v63;
      }
      unint64_t v67 = v65 - v66;
      if (v67 >= v67 - 1) {
        uint64_t v68 = v67 - 1;
      }
      else {
        uint64_t v68 = v67;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v64[v66], v68);
      size_t v7 = (void *)&unk_267770000;
      uint64_t v6 = v160;
      uint64_t v4 = v169;
      uint64_t v2 = v179;
      a1 = v190;
    }
  }
  uint64_t v8 = v7[431];
  unint64_t v9 = &unk_267771000;
  {
    uint64_t v180 = v2;
    uint64_t v191 = a1;
    uint64_t v170 = v4;
    uint64_t v153 = v8;
    uint64_t v161 = v6;
    unint64_t v9 = (void *)&unk_267771000;
    uint64_t v8 = v153;
    uint64_t v6 = v161;
    uint64_t v4 = v170;
    uint64_t v2 = v180;
    int v70 = v69;
    a1 = v191;
    if (v70)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<2>::Impl<Empty>]";
      unint64_t v199 = 97;
      unint64_t v71 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v71) {
        unint64_t v72 = v71;
      }
      else {
        unint64_t v72 = v199;
      }
      unint64_t v73 = &v198[v72];
      unint64_t v74 = v199 - v72;
      if (v199 - v72 >= 0x12) {
        uint64_t v75 = 18;
      }
      else {
        uint64_t v75 = v199 - v72;
      }
      unint64_t v76 = v74 - v75;
      if (v76 >= v76 - 1) {
        uint64_t v77 = v76 - 1;
      }
      else {
        uint64_t v77 = v76;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v73[v75], v77);
      unint64_t v9 = (void *)&unk_267771000;
      uint64_t v8 = v153;
      uint64_t v6 = v161;
      uint64_t v4 = v170;
      uint64_t v2 = v180;
      a1 = v191;
    }
  }
  uint64_t v10 = v9[441];
  unint64_t v11 = &unk_267772000;
  {
    uint64_t v181 = v2;
    uint64_t v192 = a1;
    uint64_t v171 = v4;
    uint64_t v154 = v8;
    uint64_t v162 = v6;
    uint64_t v147 = v10;
    unint64_t v11 = (void *)&unk_267772000;
    uint64_t v10 = v147;
    uint64_t v8 = v154;
    uint64_t v6 = v162;
    uint64_t v4 = v171;
    uint64_t v2 = v181;
    int v79 = v78;
    a1 = v192;
    if (v79)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AttrSizedOperandSegments<Empty>]";
      unint64_t v199 = 96;
      unint64_t v80 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v80) {
        unint64_t v81 = v80;
      }
      else {
        unint64_t v81 = v199;
      }
      unint64_t v82 = &v198[v81];
      unint64_t v83 = v199 - v81;
      if (v199 - v81 >= 0x12) {
        uint64_t v84 = 18;
      }
      else {
        uint64_t v84 = v199 - v81;
      }
      unint64_t v85 = v83 - v84;
      if (v85 >= v85 - 1) {
        uint64_t v86 = v85 - 1;
      }
      else {
        uint64_t v86 = v85;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v82[v84], v86);
      unint64_t v11 = (void *)&unk_267772000;
      uint64_t v10 = v147;
      uint64_t v8 = v154;
      uint64_t v6 = v162;
      uint64_t v4 = v171;
      uint64_t v2 = v181;
      a1 = v192;
    }
  }
  uint64_t v12 = v11[47];
  long long v13 = &unk_267770000;
  {
    uint64_t v182 = v2;
    uint64_t v193 = a1;
    uint64_t v172 = v4;
    uint64_t v155 = v8;
    uint64_t v163 = v6;
    uint64_t v142 = v12;
    uint64_t v148 = v10;
    long long v13 = (void *)&unk_267770000;
    uint64_t v12 = v142;
    uint64_t v10 = v148;
    uint64_t v8 = v155;
    uint64_t v6 = v163;
    uint64_t v4 = v172;
    uint64_t v2 = v182;
    int v88 = v87;
    a1 = v193;
    if (v88)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v199 = 84;
      unint64_t v89 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v89) {
        unint64_t v90 = v89;
      }
      else {
        unint64_t v90 = v199;
      }
      unint64_t v91 = &v198[v90];
      unint64_t v92 = v199 - v90;
      if (v199 - v90 >= 0x12) {
        uint64_t v93 = 18;
      }
      else {
        uint64_t v93 = v199 - v90;
      }
      unint64_t v94 = v92 - v93;
      if (v94 >= v94 - 1) {
        uint64_t v95 = v94 - 1;
      }
      else {
        uint64_t v95 = v94;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v91[v93], v95);
      long long v13 = (void *)&unk_267770000;
      uint64_t v12 = v142;
      uint64_t v10 = v148;
      uint64_t v8 = v155;
      uint64_t v6 = v163;
      uint64_t v4 = v172;
      uint64_t v2 = v182;
      a1 = v193;
    }
  }
  uint64_t v14 = v13[435];
  uint64_t v15 = &unk_267771000;
  {
    uint64_t v183 = v2;
    uint64_t v194 = a1;
    uint64_t v173 = v4;
    uint64_t v156 = v8;
    uint64_t v164 = v6;
    uint64_t v143 = v12;
    uint64_t v149 = v10;
    uint64_t v138 = v14;
    uint64_t v15 = (void *)&unk_267771000;
    uint64_t v14 = v138;
    uint64_t v12 = v143;
    uint64_t v10 = v149;
    uint64_t v8 = v156;
    uint64_t v6 = v164;
    uint64_t v4 = v173;
    uint64_t v2 = v183;
    int v97 = v96;
    a1 = v194;
    if (v97)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v199 = 89;
      unint64_t v98 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v98) {
        unint64_t v99 = v98;
      }
      else {
        unint64_t v99 = v199;
      }
      unint64_t v100 = &v198[v99];
      unint64_t v101 = v199 - v99;
      if (v199 - v99 >= 0x12) {
        uint64_t v102 = 18;
      }
      else {
        uint64_t v102 = v199 - v99;
      }
      unint64_t v103 = v101 - v102;
      if (v103 >= v103 - 1) {
        uint64_t v104 = v103 - 1;
      }
      else {
        uint64_t v104 = v103;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v100[v102], v104);
      uint64_t v15 = (void *)&unk_267771000;
      uint64_t v14 = v138;
      uint64_t v12 = v143;
      uint64_t v10 = v149;
      uint64_t v8 = v156;
      uint64_t v6 = v164;
      uint64_t v4 = v173;
      uint64_t v2 = v183;
      a1 = v194;
    }
  }
  uint64_t v16 = v15[320];
  unint64_t v17 = &unk_267771000;
  {
    uint64_t v184 = v2;
    uint64_t v195 = a1;
    uint64_t v174 = v4;
    uint64_t v157 = v8;
    uint64_t v165 = v6;
    uint64_t v144 = v12;
    uint64_t v150 = v10;
    uint64_t v135 = v16;
    uint64_t v139 = v14;
    unint64_t v17 = (void *)&unk_267771000;
    uint64_t v16 = v135;
    uint64_t v14 = v139;
    uint64_t v12 = v144;
    uint64_t v10 = v150;
    uint64_t v8 = v157;
    uint64_t v6 = v165;
    uint64_t v4 = v174;
    uint64_t v2 = v184;
    int v106 = v105;
    a1 = v195;
    if (v106)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v199 = 93;
      unint64_t v107 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v107) {
        unint64_t v108 = v107;
      }
      else {
        unint64_t v108 = v199;
      }
      unint64_t v109 = &v198[v108];
      unint64_t v110 = v199 - v108;
      if (v199 - v108 >= 0x12) {
        uint64_t v111 = 18;
      }
      else {
        uint64_t v111 = v199 - v108;
      }
      unint64_t v112 = v110 - v111;
      if (v112 >= v112 - 1) {
        uint64_t v113 = v112 - 1;
      }
      else {
        uint64_t v113 = v112;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v109[v111], v113);
      unint64_t v17 = (void *)&unk_267771000;
      uint64_t v16 = v135;
      uint64_t v14 = v139;
      uint64_t v12 = v144;
      uint64_t v10 = v150;
      uint64_t v8 = v157;
      uint64_t v6 = v165;
      uint64_t v4 = v174;
      uint64_t v2 = v184;
      a1 = v195;
    }
  }
  uint64_t v18 = v17[31];
  uint64_t v19 = &unk_267771000;
  {
    uint64_t v185 = v2;
    uint64_t v196 = a1;
    uint64_t v175 = v4;
    uint64_t v158 = v8;
    uint64_t v166 = v6;
    uint64_t v145 = v12;
    uint64_t v151 = v10;
    uint64_t v136 = v16;
    uint64_t v140 = v14;
    uint64_t v133 = v18;
    uint64_t v19 = (void *)&unk_267771000;
    uint64_t v18 = v133;
    uint64_t v16 = v136;
    uint64_t v14 = v140;
    uint64_t v12 = v145;
    uint64_t v10 = v151;
    uint64_t v8 = v158;
    uint64_t v6 = v166;
    uint64_t v4 = v175;
    uint64_t v2 = v185;
    int v115 = v114;
    a1 = v196;
    if (v115)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v199 = 90;
      unint64_t v116 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v116) {
        unint64_t v117 = v116;
      }
      else {
        unint64_t v117 = v199;
      }
      unint64_t v118 = &v198[v117];
      unint64_t v119 = v199 - v117;
      if (v199 - v117 >= 0x12) {
        uint64_t v120 = 18;
      }
      else {
        uint64_t v120 = v199 - v117;
      }
      unint64_t v121 = v119 - v120;
      if (v121 >= v121 - 1) {
        uint64_t v122 = v121 - 1;
      }
      else {
        uint64_t v122 = v121;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v118[v120], v122);
      uint64_t v19 = (void *)&unk_267771000;
      uint64_t v18 = v133;
      uint64_t v16 = v136;
      uint64_t v14 = v140;
      uint64_t v12 = v145;
      uint64_t v10 = v151;
      uint64_t v8 = v158;
      uint64_t v6 = v166;
      uint64_t v4 = v175;
      uint64_t v2 = v185;
      a1 = v196;
    }
  }
  uint64_t v20 = v19[37];
  uint64_t v21 = &unk_267771000;
  {
    uint64_t v186 = v2;
    uint64_t v197 = a1;
    uint64_t v176 = v4;
    uint64_t v159 = v8;
    uint64_t v167 = v6;
    uint64_t v146 = v12;
    uint64_t v152 = v10;
    uint64_t v137 = v16;
    uint64_t v141 = v14;
    uint64_t v132 = v20;
    uint64_t v134 = v18;
    uint64_t v21 = (void *)&unk_267771000;
    uint64_t v20 = v132;
    uint64_t v18 = v134;
    uint64_t v16 = v137;
    uint64_t v14 = v141;
    uint64_t v12 = v146;
    uint64_t v10 = v152;
    uint64_t v8 = v159;
    uint64_t v6 = v167;
    uint64_t v4 = v176;
    uint64_t v2 = v186;
    int v124 = v123;
    a1 = v197;
    if (v124)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      unint64_t v199 = 100;
      unint64_t v125 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v125) {
        unint64_t v126 = v125;
      }
      else {
        unint64_t v126 = v199;
      }
      unint64_t v127 = &v198[v126];
      unint64_t v128 = v199 - v126;
      if (v199 - v126 >= 0x12) {
        uint64_t v129 = 18;
      }
      else {
        uint64_t v129 = v199 - v126;
      }
      unint64_t v130 = v128 - v129;
      if (v130 >= v130 - 1) {
        uint64_t v131 = v130 - 1;
      }
      else {
        uint64_t v131 = v130;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v127[v129], v131);
      uint64_t v21 = (void *)&unk_267771000;
      uint64_t v20 = v132;
      uint64_t v18 = v134;
      uint64_t v16 = v137;
      uint64_t v14 = v141;
      uint64_t v12 = v146;
      uint64_t v10 = v152;
      uint64_t v8 = v159;
      uint64_t v6 = v167;
      uint64_t v4 = v176;
      uint64_t v2 = v186;
      a1 = v197;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v21[41] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ResizeGradientOp>,mlir::OpTrait::OneResult<mlir::mps::ResizeGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ResizeGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ResizeGradientOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::mps::ResizeGradientOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::mps::ResizeGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::ResizeGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::ResizeGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ResizeGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ResizeGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ResizeGradientOp>>((mlir::OpTrait::impl *)a1, a2))return 0; {
  if (*(_DWORD *)(a1 + 36))
  }
    uint64_t v3 = a1 - 16;
  else {
    uint64_t v3 = 0;
  }
  mlir::detail::OpResultImpl::getNextResultAtOffset(v3, 0);
  uint64_t v5 = *(void *)(a1 + 72);
  if (*(unsigned char *)(a1 + 47)) {
    uint64_t v6 = (unsigned int *)(a1 + 80);
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = v6[8];
  uint64_t v8 = *(void *)(v5 + 32 * v7 + 24);
  uint64_t v9 = v6[9] + v7;
  unsigned int v10 = v6[10];
  if (!v10)
  {
    uint64_t v11 = 0;
    if (v6[11]) {
      goto LABEL_10;
    }
LABEL_13:
    uint64_t v12 = 0;
    return mlir::mps::verifyResize(a1, v4, 0, *(void *)(v5 + 24), v8, v11, v12) != 0;
  }
  uint64_t v11 = *(void *)(v5 + 32 * v9 + 24);
  if (!v6[11]) {
    goto LABEL_13;
  }
LABEL_10:
  uint64_t v12 = *(void *)(v5 + 32 * (v10 + v9) + 24);
  return mlir::mps::verifyResize(a1, v4, 0, *(void *)(v5 + 24), v8, v11, v12) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ResizeGradientOp>,mlir::OpTrait::OneResult<mlir::mps::ResizeGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ResizeGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ResizeGradientOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::mps::ResizeGradientOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::mps::ResizeGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::ResizeGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::ResizeGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ResizeGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ResizeGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ResizeGradientOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)2)
    || !mlir::OpTrait::impl::verifyOperandSizeAttr((uint64_t)a1, "operandSegmentSizes", 0x13uLL))
  {
    return 0;
  }
  uint64_t v6 = a1;
  return mlir::mps::ResizeGradientOp::verifyInvariantsImpl((mlir::mps::ResizeGradientOp *)&v6);
}

BOOL mlir::Op<mlir::mps::ResizeGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ResizeOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.resize", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ResizeOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36E6E8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::mps::ResizeOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::ResizeOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::mps::ResizeGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::ResizeGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::getOpPropertyByteSize()
{
  return 48;
}

double mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::initProperties(uint64_t a1, uint64_t a2, _OWORD *a3, long long *a4)
{
  if (a4)
  {
    long long v4 = *a4;
    long long v5 = a4[2];
    a3[1] = a4[1];
    a3[2] = v5;
    *a3 = v4;
  }
  else
  {
    *(void *)&long long v4 = 0;
    a3[1] = 0u;
    a3[2] = 0u;
    *a3 = 0u;
  }
  return *(double *)&v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ResizeGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::mps::ResizeGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  long long v4 = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(a2 + 32) = v4;
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  if (*a3 != *a2) {
    return 0;
  }
  if (a3[1] != a2[1]) {
    return 0;
  }
  if (a3[2] != a2[2]) {
    return 0;
  }
  if (a3[3] != a2[3]) {
    return 0;
  }
  return a3[4] == a2[4] && a3[5] == a2[5];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ResizeOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::scf::ForallOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::mps::ResizeGradientOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, void *a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ResizeOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, void *a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ResizeOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ResizeOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ResizeOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, void *a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::ResizeOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    long long v24 = v23;
    long long v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.resize";
    v25[1] = 10;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ResizeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ResizeOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ResizeOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ResizeOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ResizeOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    unint64_t v10 = (long long *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  }
  else {
    unint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v29, v12, v11);
  uint64_t v20 = v8;
  v21[0] = 0;
  char v22 = 0;
  long long v13 = v10[1];
  long long v23 = *v10;
  long long v24 = v13;
  long long v25 = v10[2];
  long long v26 = *(_OWORD *)v29;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22) {
      char v22 = 0;
    }
    mlir::OperationName::OperationName(v21, "mps.resize", 10, Context);
    char v22 = 1;
  }
  uint64_t v27 = a2;
  uint64_t v28 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v29[0] = result;
  v29[1] = v16;
  if (result)
  {
    unint64_t v17 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v29, v27, v28);
    if (v17 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v18 = v17;
      if (a1 - 16 != (v17 & ((uint64_t)(v17 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v19 = *(unsigned int *)(a4 + 8);
        if (v19 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v19 + 1, 8);
          LODWORD(v19) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v19) = v18;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ResizeGradientOp>,mlir::OpTrait::OneResult<mlir::mps::ResizeGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ResizeGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ResizeGradientOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::mps::ResizeGradientOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::mps::ResizeGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::ResizeGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::ResizeGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ResizeGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ResizeGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ResizeGradientOp>>((mlir::OpTrait::impl *)a1, a2))return 0; {
  if (*(_DWORD *)(a1 + 36))
  }
    uint64_t v3 = a1 - 16;
  else {
    uint64_t v3 = 0;
  }
  mlir::detail::OpResultImpl::getNextResultAtOffset(v3, 0);
  uint64_t v5 = *(void *)(a1 + 72);
  if (*(unsigned char *)(a1 + 47)) {
    unint64_t v6 = (unsigned int *)(a1 + 80);
  }
  else {
    unint64_t v6 = 0;
  }
  uint64_t v7 = v6[8];
  uint64_t v8 = *(void *)(v5 + 32 * v7 + 24);
  uint64_t v9 = v6[9] + v7;
  unsigned int v10 = v6[10];
  if (!v10)
  {
    uint64_t v11 = 0;
    if (v6[11]) {
      goto LABEL_10;
    }
LABEL_13:
    uint64_t v12 = 0;
    return mlir::mps::verifyResize(a1, v4, *(void *)(v5 + 24), 0, v8, v11, v12) != 0;
  }
  uint64_t v11 = *(void *)(v5 + 32 * v9 + 24);
  if (!v6[11]) {
    goto LABEL_13;
  }
LABEL_10:
  uint64_t v12 = *(void *)(v5 + 32 * (v10 + v9) + 24);
  return mlir::mps::verifyResize(a1, v4, *(void *)(v5 + 24), 0, v8, v11, v12) != 0;
}

BOOL mlir::Op<mlir::mps::ResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ReverseOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReverseOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReverseOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReverseOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.reverse", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReverseOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36F368;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReverseOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReverseOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReverseOp>::foldHook(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                      + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReverseOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ReverseOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReverseOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReverseOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReverseOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReverseOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReverseOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ReverseOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReverseOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReverseOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReverseOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    char v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      uint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      uint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReverseOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReverseOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ReverseOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReverseOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ReverseOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReverseOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReverseOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReverseOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReverseOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReverseOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  if (a5)
  {
    unint64_t v11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    uint64_t v12 = *(unsigned int *)(a11 + 8);
    if (v12 >= *(_DWORD *)(a11 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v12 + 1, 8);
      LODWORD(v12) = *(_DWORD *)(a11 + 8);
    }
    *(void *)(*(void *)a11 + 8 * v12) = v11;
    ++*(_DWORD *)(a11 + 8);
    return 1;
  }
  else
  {
    return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands");
  }
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReverseOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReverseOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ReverseOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ReverseOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  int v21 = v23;
  uint64_t v22 = 0x400000000;
  unsigned int v26 = a4;
  uint64_t v27 = a5;
  if (a5)
  {
    *((void *)v21 + v22) = *(void *)(mlir::ValueRange::dereference_iterator(&v26, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    unsigned int v13 = v22 + 1;
    LODWORD(v22) = v22 + 1;
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands"))
    {
      uint64_t v16 = 0;
      uint64_t v17 = v21;
      if (v21 == v23) {
        return v16;
      }
      goto LABEL_17;
    }
    unsigned int v13 = v22;
  }
  mlir::ValueRange::ValueRange(v20, (uint64_t)v21, v13);
  mlir::ValueRange::ValueRange(v19, *(void *)a11, *(unsigned int *)(a11 + 8));
  v24[0] = &unk_26C380E60;
  long long v25 = v24;
  uint64_t v28 = &v26;
  unsigned int v26 = (const char *)&unk_26C380E60;
  if (v28 == &v26)
  {
    (*((void (**)(const char **))v26 + 4))(&v26);
    uint64_t v15 = v25;
    if (v25 != v24) {
      goto LABEL_9;
    }
LABEL_15:
    (*(void (**)(void *))(v24[0] + 32))(v24);
    if (v14) {
      goto LABEL_12;
    }
    goto LABEL_16;
  }
  if (v28) {
    (*((void (**)(const char **))*v28 + 5))(v28);
  }
  uint64_t v15 = v25;
  if (v25 == v24) {
    goto LABEL_15;
  }
LABEL_9:
  if (v15) {
    (*(void (**)(void *))(*v15 + 40))(v15);
  }
  if (v14)
  {
LABEL_12:
    uint64_t v16 = 1;
    uint64_t v17 = v21;
    if (v21 == v23) {
      return v16;
    }
    goto LABEL_17;
  }
LABEL_16:
  unsigned int v26 = "mps.reverse";
  uint64_t v27 = 11;
  uint64_t v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v26, "' op inferred type(s) ", (uint64_t)&v21, " are incompatible with return type(s) of operation ", a11);
  uint64_t v17 = v21;
  if (v21 != v23) {
LABEL_17:
  }
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReverseOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReverseOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unsigned int v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ReverseOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReverseOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ReverseOp>(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::ReverseOpGenericAdaptorBase::ReverseOpGenericAdaptorBase((uint64_t)v14, a1);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)a1);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if (a1 - 4 != (unsigned int *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v144 = a1;
    v1 = (void *)&unk_267771000;
    int v28 = v27;
    a1 = v144;
    if (v28)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v154 = 83;
      unint64_t v29 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v29) {
        unint64_t v30 = v29;
      }
      else {
        unint64_t v30 = v154;
      }
      int v31 = &v153[v30];
      unint64_t v32 = v154 - v30;
      if (v154 - v30 >= 0x12) {
        uint64_t v33 = 18;
      }
      else {
        uint64_t v33 = v154 - v30;
      }
      unint64_t v34 = v32 - v33;
      if (v34 >= v34 - 1) {
        uint64_t v35 = v34 - 1;
      }
      else {
        uint64_t v35 = v34;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v31[v33], v35);
      v1 = (void *)&unk_267771000;
      a1 = v144;
    }
  }
  uint64_t v2 = v1[23];
  char v3 = &unk_267771000;
  {
    uint64_t v136 = v2;
    uint64_t v145 = a1;
    char v3 = (void *)&unk_267771000;
    int v37 = v36;
    uint64_t v2 = v136;
    a1 = v145;
    if (v37)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v154 = 81;
      unint64_t v38 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v38) {
        unint64_t v39 = v38;
      }
      else {
        unint64_t v39 = v154;
      }
      unint64_t v40 = &v153[v39];
      unint64_t v41 = v154 - v39;
      if (v154 - v39 >= 0x12) {
        uint64_t v42 = 18;
      }
      else {
        uint64_t v42 = v154 - v39;
      }
      unint64_t v43 = v41 - v42;
      if (v43 >= v43 - 1) {
        uint64_t v44 = v43 - 1;
      }
      else {
        uint64_t v44 = v43;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v136;
      a1 = v145;
    }
  }
  uint64_t v4 = v3[25];
  unint64_t v5 = &unk_267771000;
  {
    uint64_t v137 = v2;
    uint64_t v146 = a1;
    uint64_t v129 = v4;
    unint64_t v5 = (void *)&unk_267771000;
    uint64_t v4 = v129;
    int v46 = v45;
    uint64_t v2 = v137;
    a1 = v146;
    if (v46)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      unint64_t v154 = 104;
      unint64_t v47 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v47) {
        unint64_t v48 = v47;
      }
      else {
        unint64_t v48 = v154;
      }
      unint64_t v49 = &v153[v48];
      unint64_t v50 = v154 - v48;
      if (v154 - v48 >= 0x12) {
        uint64_t v51 = 18;
      }
      else {
        uint64_t v51 = v154 - v48;
      }
      unint64_t v52 = v50 - v51;
      if (v52 >= v52 - 1) {
        uint64_t v53 = v52 - 1;
      }
      else {
        uint64_t v53 = v52;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      unint64_t v5 = (void *)&unk_267771000;
      uint64_t v4 = v129;
      uint64_t v2 = v137;
      a1 = v146;
    }
  }
  uint64_t v6 = v5[318];
  uint64_t v7 = &unk_267770000;
  {
    uint64_t v138 = v2;
    uint64_t v147 = a1;
    uint64_t v123 = v6;
    uint64_t v130 = v4;
    uint64_t v7 = (void *)&unk_267770000;
    uint64_t v6 = v123;
    uint64_t v4 = v130;
    int v55 = v54;
    uint64_t v2 = v138;
    a1 = v147;
    if (v55)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v154 = 86;
      unint64_t v56 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v56) {
        unint64_t v57 = v56;
      }
      else {
        unint64_t v57 = v154;
      }
      unint64_t v58 = &v153[v57];
      unint64_t v59 = v154 - v57;
      if (v154 - v57 >= 0x12) {
        uint64_t v60 = 18;
      }
      else {
        uint64_t v60 = v154 - v57;
      }
      unint64_t v61 = v59 - v60;
      if (v61 >= v61 - 1) {
        uint64_t v62 = v61 - 1;
      }
      else {
        uint64_t v62 = v61;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      uint64_t v7 = (void *)&unk_267770000;
      uint64_t v6 = v123;
      uint64_t v4 = v130;
      uint64_t v2 = v138;
      a1 = v147;
    }
  }
  uint64_t v8 = v7[431];
  uint64_t v9 = &unk_267771000;
  {
    uint64_t v139 = v2;
    uint64_t v148 = a1;
    uint64_t v124 = v6;
    uint64_t v131 = v4;
    uint64_t v118 = v8;
    uint64_t v9 = (void *)&unk_267771000;
    uint64_t v8 = v118;
    uint64_t v6 = v124;
    uint64_t v4 = v131;
    int v64 = v63;
    uint64_t v2 = v139;
    a1 = v148;
    if (v64)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>]";
      unint64_t v154 = 97;
      unint64_t v65 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v65) {
        unint64_t v66 = v65;
      }
      else {
        unint64_t v66 = v154;
      }
      unint64_t v67 = &v153[v66];
      unint64_t v68 = v154 - v66;
      if (v154 - v66 >= 0x12) {
        uint64_t v69 = 18;
      }
      else {
        uint64_t v69 = v154 - v66;
      }
      unint64_t v70 = v68 - v69;
      if (v70 >= v70 - 1) {
        uint64_t v71 = v70 - 1;
      }
      else {
        uint64_t v71 = v70;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      uint64_t v9 = (void *)&unk_267771000;
      uint64_t v8 = v118;
      uint64_t v6 = v124;
      uint64_t v4 = v131;
      uint64_t v2 = v139;
      a1 = v148;
    }
  }
  uint64_t v10 = v9[433];
  uint64_t v11 = &unk_267770000;
  {
    uint64_t v140 = v2;
    uint64_t v149 = a1;
    uint64_t v125 = v6;
    uint64_t v132 = v4;
    uint64_t v114 = v10;
    uint64_t v119 = v8;
    uint64_t v11 = (void *)&unk_267770000;
    uint64_t v10 = v114;
    uint64_t v8 = v119;
    uint64_t v6 = v125;
    uint64_t v4 = v132;
    int v73 = v72;
    uint64_t v2 = v140;
    a1 = v149;
    if (v73)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v154 = 84;
      unint64_t v74 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v74) {
        unint64_t v75 = v74;
      }
      else {
        unint64_t v75 = v154;
      }
      unint64_t v76 = &v153[v75];
      unint64_t v77 = v154 - v75;
      if (v154 - v75 >= 0x12) {
        uint64_t v78 = 18;
      }
      else {
        uint64_t v78 = v154 - v75;
      }
      unint64_t v79 = v77 - v78;
      if (v79 >= v79 - 1) {
        uint64_t v80 = v79 - 1;
      }
      else {
        uint64_t v80 = v79;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      uint64_t v11 = (void *)&unk_267770000;
      uint64_t v10 = v114;
      uint64_t v8 = v119;
      uint64_t v6 = v125;
      uint64_t v4 = v132;
      uint64_t v2 = v140;
      a1 = v149;
    }
  }
  uint64_t v12 = v11[435];
  unsigned int v13 = &unk_267771000;
  {
    uint64_t v141 = v2;
    uint64_t v150 = a1;
    uint64_t v126 = v6;
    uint64_t v133 = v4;
    uint64_t v115 = v10;
    uint64_t v120 = v8;
    uint64_t v111 = v12;
    unsigned int v13 = (void *)&unk_267771000;
    uint64_t v12 = v111;
    uint64_t v10 = v115;
    uint64_t v8 = v120;
    uint64_t v6 = v126;
    uint64_t v4 = v133;
    int v82 = v81;
    uint64_t v2 = v141;
    a1 = v150;
    if (v82)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v154 = 93;
      unint64_t v83 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v83) {
        unint64_t v84 = v83;
      }
      else {
        unint64_t v84 = v154;
      }
      unint64_t v85 = &v153[v84];
      unint64_t v86 = v154 - v84;
      if (v154 - v84 >= 0x12) {
        uint64_t v87 = 18;
      }
      else {
        uint64_t v87 = v154 - v84;
      }
      unint64_t v88 = v86 - v87;
      if (v88 >= v88 - 1) {
        uint64_t v89 = v88 - 1;
      }
      else {
        uint64_t v89 = v88;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      unsigned int v13 = (void *)&unk_267771000;
      uint64_t v12 = v111;
      uint64_t v10 = v115;
      uint64_t v8 = v120;
      uint64_t v6 = v126;
      uint64_t v4 = v133;
      uint64_t v2 = v141;
      a1 = v150;
    }
  }
  uint64_t v14 = v13[31];
  uint64_t v15 = &unk_267771000;
  {
    uint64_t v142 = v2;
    uint64_t v151 = a1;
    uint64_t v127 = v6;
    uint64_t v134 = v4;
    uint64_t v116 = v10;
    uint64_t v121 = v8;
    uint64_t v109 = v14;
    uint64_t v112 = v12;
    uint64_t v15 = (void *)&unk_267771000;
    uint64_t v14 = v109;
    uint64_t v12 = v112;
    uint64_t v10 = v116;
    uint64_t v8 = v121;
    uint64_t v6 = v127;
    uint64_t v4 = v134;
    int v91 = v90;
    uint64_t v2 = v142;
    a1 = v151;
    if (v91)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v154 = 90;
      unint64_t v92 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v92) {
        unint64_t v93 = v92;
      }
      else {
        unint64_t v93 = v154;
      }
      unint64_t v94 = &v153[v93];
      unint64_t v95 = v154 - v93;
      if (v154 - v93 >= 0x12) {
        uint64_t v96 = 18;
      }
      else {
        uint64_t v96 = v154 - v93;
      }
      unint64_t v97 = v95 - v96;
      if (v97 >= v97 - 1) {
        uint64_t v98 = v97 - 1;
      }
      else {
        uint64_t v98 = v97;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      uint64_t v15 = (void *)&unk_267771000;
      uint64_t v14 = v109;
      uint64_t v12 = v112;
      uint64_t v10 = v116;
      uint64_t v8 = v121;
      uint64_t v6 = v127;
      uint64_t v4 = v134;
      uint64_t v2 = v142;
      a1 = v151;
    }
  }
  uint64_t v16 = v15[37];
  uint64_t v17 = &unk_267771000;
  {
    uint64_t v143 = v2;
    uint64_t v152 = a1;
    uint64_t v128 = v6;
    uint64_t v135 = v4;
    uint64_t v117 = v10;
    uint64_t v122 = v8;
    uint64_t v110 = v14;
    uint64_t v113 = v12;
    uint64_t v108 = v16;
    uint64_t v17 = (void *)&unk_267771000;
    uint64_t v16 = v108;
    uint64_t v14 = v110;
    uint64_t v12 = v113;
    uint64_t v10 = v117;
    uint64_t v8 = v122;
    uint64_t v6 = v128;
    uint64_t v4 = v135;
    int v100 = v99;
    uint64_t v2 = v143;
    a1 = v152;
    if (v100)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      unint64_t v154 = 100;
      unint64_t v101 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v101) {
        unint64_t v102 = v101;
      }
      else {
        unint64_t v102 = v154;
      }
      unint64_t v103 = &v153[v102];
      unint64_t v104 = v154 - v102;
      if (v154 - v102 >= 0x12) {
        uint64_t v105 = 18;
      }
      else {
        uint64_t v105 = v154 - v102;
      }
      unint64_t v106 = v104 - v105;
      if (v106 >= v106 - 1) {
        uint64_t v107 = v106 - 1;
      }
      else {
        uint64_t v107 = v106;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      uint64_t v17 = (void *)&unk_267771000;
      uint64_t v16 = v108;
      uint64_t v14 = v110;
      uint64_t v12 = v113;
      uint64_t v10 = v117;
      uint64_t v8 = v122;
      uint64_t v6 = v128;
      uint64_t v4 = v135;
      uint64_t v2 = v143;
      a1 = v152;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v17[41] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)1)) {
    return 0;
  }
  uint64_t v6 = a1;
  if (!mlir::mps::ReverseOp::verifyInvariantsImpl((mlir::mps::ReverseOp *)&v6)) {
    return 0;
  }
  uint64_t v6 = a1;
  return mlir::mps::ReverseOp::verify(&v6);
}

BOOL mlir::Op<mlir::mps::ReverseOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::RintOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RintOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RintOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RintOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.rint", 8, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RintOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36CB90;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RintOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RintOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RintOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RintOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::RintOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RintOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RintOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RintOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RintOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RintOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::RintOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RintOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RintOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RintOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      uint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RintOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RintOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RintOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RintOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RintOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RintOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RintOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RintOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RintOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RintOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RintOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RintOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RintOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RintOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::RintOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RintOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::RintOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  long long v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  long long v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  long long v24 = "mps.rint";
  uint64_t v25 = 8;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::RintOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::RintOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::RintOpGenericAdaptorBase::RintOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ACosOp>,mlir::OpTrait::OneResult<mlir::mps::ACosOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ACosOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ACosOp>,mlir::OpTrait::OneOperand<mlir::mps::ACosOp>,mlir::OpTrait::OpInvariants<mlir::mps::ACosOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ACosOp>,mlir::OpTrait::Stitchable<mlir::mps::ACosOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ACosOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ACosOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::RintOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::RoundOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RoundOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RoundOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RoundOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.round", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RoundOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36DBF8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RoundOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RoundOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RoundOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RoundOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::RoundOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::RoundOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RoundOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RoundOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RoundOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RoundOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::RoundOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RoundOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RoundOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RoundOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RoundOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RoundOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::RoundOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RoundOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::RoundOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RoundOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RoundOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::RoundOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RoundOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RoundOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RoundOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RoundOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RoundOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RoundOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::RoundOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::RoundOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::RoundOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  long long v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  long long v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  long long v24 = "mps.round";
  uint64_t v25 = 9;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::RoundOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::RoundOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::RoundOpGenericAdaptorBase::RoundOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ACosOp>,mlir::OpTrait::OneResult<mlir::mps::ACosOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ACosOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ACosOp>,mlir::OpTrait::OneOperand<mlir::mps::ACosOp>,mlir::OpTrait::OpInvariants<mlir::mps::ACosOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ACosOp>,mlir::OpTrait::Stitchable<mlir::mps::ACosOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ACosOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ACosOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::RoundOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.sample_grid_data_gradient", 29, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SampleGridDataGradientOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36B038;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::mps::SampleGridDataGradientOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::SampleGridDataGradientOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  if (*v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"normalize_coordinates", 21, *v5);
  }
  uint64_t v6 = v5[1];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"padding_mode", 12, v6);
  }
  uint64_t v7 = v5[2];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"relative_coordinates", 20, v7);
  }
  uint64_t v8 = v5[3];
  if (v8)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"sampling_mode", 13, v8);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::SampleGridDataGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::getOpPropertyByteSize()
{
  return 32;
}

double mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::initProperties(uint64_t a1, uint64_t a2, long long *a3, long long *a4)
{
  if (a4)
  {
    long long v4 = *a4;
    long long v5 = a4[1];
    *a3 = *a4;
    a3[1] = v5;
  }
  else
  {
    *(void *)&long long v4 = 0;
    *a3 = 0u;
    a3[1] = 0u;
  }
  return *(double *)&v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::SampleGridDataGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  int Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::mps::SampleGridDataGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::copyProperties(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  long long v4 = *(_OWORD *)(a3 + 16);
  *a2 = *(_OWORD *)a3;
  a2[1] = v4;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  if (*a3 != *a2) {
    return 0;
  }
  if (a3[1] != a2[1]) {
    return 0;
  }
  if (a3[2] == a2[2]) {
    return a3[3] == a2[3];
  }
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridDataGradientOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::pdl_interp::FuncOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::SampleGridDataGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingModeAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::SamplingModeAttr>(a1, v3 + 3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 16))(a3, v4[1]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[2]);
  uint64_t v5 = v4[3];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::SampleGridDataGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SampleGridDataGradientOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SampleGridDataGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v22 = v24;
  uint64_t v23 = 0x400000000;
  if (mlir::mps::SampleGridDataGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, v18, v19, (uint64_t)&v22))
  {
    mlir::ValueRange::ValueRange(v21, (uint64_t)v22, v23);
    mlir::ValueRange::ValueRange(v20, *(void *)a11, *(unsigned int *)(a11 + 8));
    v25[0] = &unk_26C380E60;
    unsigned int v26 = v25;
    int v28 = v27;
    v27[0] = &unk_26C380E60;
    if (v28 == v27)
    {
      (*(void (**)(void *))(v27[0] + 32))(v27);
      unint64_t v14 = v26;
      if (v26 != v25) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v28) {
        (*(void (**)(void *))(*v28 + 40))(v28);
      }
      unint64_t v14 = v26;
      if (v26 != v25)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v22;
          if (v22 == v24) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v25[0] + 32))(v25);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v27[0] = "mps.sample_grid_data_gradient";
    v27[1] = 29;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v27, "' op inferred type(s) ", (uint64_t)&v22, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v22;
    if (v22 == v24) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v22;
  if (v22 != v24) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SampleGridDataGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SampleGridDataGradientOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SampleGridDataGradientOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    unint64_t v10 = (long long *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  }
  else {
    unint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v28, v12, v11);
  uint64_t v20 = v8;
  v21[0] = 0;
  char v22 = 0;
  long long v13 = v10[1];
  long long v23 = *v10;
  long long v24 = v13;
  long long v25 = *(_OWORD *)v28;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22) {
      char v22 = 0;
    }
    mlir::OperationName::OperationName(v21, "mps.sample_grid_data_gradient", 29, Context);
    char v22 = 1;
  }
  uint64_t v26 = a2;
  uint64_t v27 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v28[0] = result;
  v28[1] = v16;
  if (result)
  {
    unint64_t v17 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v28, v26, v27);
    if (v17 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v18 = v17;
      if (a1 - 16 != (v17 & ((uint64_t)(v17 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v19 = *(unsigned int *)(a4 + 8);
        if (v19 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v19 + 1, 8);
          LODWORD(v19) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v19) = v18;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)3)) {
    return 0;
  }
  unint64_t v6 = a1;
  if (!mlir::mps::SampleGridDataGradientOp::verifyInvariantsImpl((mlir::mps::SampleGridDataGradientOp *)&v6)) {
    return 0;
  }
  unint64_t v6 = a1;
  return mlir::mps::SampleGridDataGradientOp::verify((mlir::mps::SampleGridDataGradientOp *)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::SampleGridDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SampleGridOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.sample_grid", 15, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SampleGridOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C366218;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::mps::SampleGridOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::SampleGridOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::mps::SampleGridOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::SampleGridOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::getOpPropertyByteSize()
{
  return 56;
}

double mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  if (a4)
  {
    long long v4 = *a4;
    long long v5 = a4[1];
    long long v6 = a4[2];
    *(void *)(a3 + 48) = *((void *)a4 + 6);
    *(_OWORD *)(a3 + 16) = v5;
    *(_OWORD *)(a3 + 32) = v6;
    *(_OWORD *)a3 = v4;
  }
  else
  {
    *(void *)(a3 + 48) = 0;
    *(void *)&long long v4 = 0;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return *(double *)&v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::SampleGridOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::mps::SampleGridOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  long long v4 = *(_OWORD *)(a3 + 16);
  long long v5 = *(_OWORD *)(a3 + 32);
  *(void *)(a2 + 48) = *(void *)(a3 + 48);
  *(_OWORD *)(a2 + 16) = v4;
  *(_OWORD *)(a2 + 32) = v5;
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  if (*a3 != *a2) {
    return 0;
  }
  if (a3[1] != a2[1]) {
    return 0;
  }
  if (a3[2] != a2[2]) {
    return 0;
  }
  if (a3[3] != a2[3]) {
    return 0;
  }
  if (a3[4] != a2[4]) {
    return 0;
  }
  if (a3[5] == a2[5]) {
    return a3[6] == a2[6];
  }
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::SampleGridOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::Conv2DDataGradientOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 16))(a3, v4[1]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[2]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[3]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 16))(a3, v4[4]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[5]);
  uint64_t v5 = v4[6];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::SampleGridOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SampleGridOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SampleGridOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SampleGridOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::SampleGridOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    long long v24 = v23;
    uint64_t v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.sample_grid";
    v25[1] = 15;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SampleGridOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SampleGridOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SampleGridOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SampleGridOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SampleGridOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    uint64_t v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  }
  else {
    uint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v30, v12, v11);
  uint64_t v20 = v8;
  v21[0] = 0;
  char v22 = 0;
  long long v13 = *(_OWORD *)(v10 + 16);
  long long v23 = *(_OWORD *)v10;
  long long v24 = v13;
  long long v25 = *(_OWORD *)(v10 + 32);
  uint64_t v26 = *(void *)(v10 + 48);
  long long v27 = *(_OWORD *)v30;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22) {
      char v22 = 0;
    }
    mlir::OperationName::OperationName(v21, "mps.sample_grid", 15, Context);
    char v22 = 1;
  }
  uint64_t v28 = a2;
  uint64_t v29 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v30[0] = result;
  v30[1] = v16;
  if (result)
  {
    unint64_t v17 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v30, v28, v29);
    if (v17 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v18 = v17;
      if (a1 - 16 != (v17 & ((uint64_t)(v17 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v19 = *(unsigned int *)(a4 + 8);
        if (v19 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v19 + 1, 8);
          LODWORD(v19) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v19) = v18;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)3)) {
    return 0;
  }
  unint64_t v6 = a1;
  if (!mlir::mps::SampleGridOp::verifyInvariantsImpl((mlir::mps::SampleGridOp *)&v6)) {
    return 0;
  }
  unint64_t v6 = a1;
  return mlir::mps::SampleGridOp::verify((mlir::mps::SampleGridOp *)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::SampleGridOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterAlongAxisOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterAlongAxisOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ScatterAlongAxisOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.scatter_along_axis", 22, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ScatterAlongAxisOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      size_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C369990;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::getInherentAttr(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (a4 == 4 && *a3 == 1701080941) {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    return 0;
  }
}

_DWORD *mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  if (v7 == 4 && *result == 1701080941)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::ScatterModeAttr,void>::id) {
        uint64_t v8 = a4;
      }
      else {
        uint64_t v8 = 0;
      }
      *uint64_t v5 = v8;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"mode", 4, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps40(v7, (void **)"mode", (const char *)4, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ScatterAlongAxisOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::ScatterAlongAxisOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterAlongAxisOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterAlongAxisOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterAlongAxisOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterAlongAxisOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterAlongAxisOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ScatterAlongAxisOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::ScatterModeAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterAlongAxisOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 16))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterAlongAxisOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterAlongAxisOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterAlongAxisOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterAlongAxisOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterAlongAxisOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ScatterAlongAxisOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterAlongAxisOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ScatterAlongAxisOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterAlongAxisOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ScatterAlongAxisOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  char v22 = v24;
  uint64_t v23 = 0x400000000;
  if (mlir::mps::ScatterAlongAxisOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, v18, v19, (uint64_t)&v22))
  {
    mlir::ValueRange::ValueRange(v21, (uint64_t)v22, v23);
    mlir::ValueRange::ValueRange(v20, *(void *)a11, *(unsigned int *)(a11 + 8));
    v25[0] = &unk_26C380E60;
    uint64_t v26 = v25;
    uint64_t v28 = v27;
    v27[0] = &unk_26C380E60;
    if (v28 == v27)
    {
      (*(void (**)(void *))(v27[0] + 32))(v27);
      unint64_t v14 = v26;
      if (v26 != v25) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v28) {
        (*(void (**)(void *))(*v28 + 40))(v28);
      }
      unint64_t v14 = v26;
      if (v26 != v25)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v22;
          if (v22 == v24) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v25[0] + 32))(v25);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v27[0] = "mps.scatter_along_axis";
    v27[1] = 22;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v27, "' op inferred type(s) ", (uint64_t)&v22, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v22;
    if (v22 == v24) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v22;
  if (v22 != v24) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ScatterAlongAxisOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ScatterAlongAxisOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ScatterAlongAxisOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ScatterAlongAxisOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ScatterAlongAxisOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  unint64_t v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  uint64_t v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.scatter_along_axis", 22, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v144 = a1;
    v1 = (void *)&unk_267771000;
    int v28 = v27;
    a1 = v144;
    if (v28)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v154 = 83;
      unint64_t v29 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v29) {
        unint64_t v30 = v29;
      }
      else {
        unint64_t v30 = v154;
      }
      uint64_t v31 = &v153[v30];
      unint64_t v32 = v154 - v30;
      if (v154 - v30 >= 0x12) {
        uint64_t v33 = 18;
      }
      else {
        uint64_t v33 = v154 - v30;
      }
      unint64_t v34 = v32 - v33;
      if (v34 >= v34 - 1) {
        uint64_t v35 = v34 - 1;
      }
      else {
        uint64_t v35 = v34;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v31[v33], v35);
      v1 = (void *)&unk_267771000;
      a1 = v144;
    }
  }
  uint64_t v2 = v1[23];
  char v3 = &unk_267771000;
  {
    uint64_t v136 = v2;
    uint64_t v145 = a1;
    char v3 = (void *)&unk_267771000;
    int v37 = v36;
    uint64_t v2 = v136;
    a1 = v145;
    if (v37)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v154 = 81;
      unint64_t v38 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v38) {
        unint64_t v39 = v38;
      }
      else {
        unint64_t v39 = v154;
      }
      unint64_t v40 = &v153[v39];
      unint64_t v41 = v154 - v39;
      if (v154 - v39 >= 0x12) {
        uint64_t v42 = 18;
      }
      else {
        uint64_t v42 = v154 - v39;
      }
      unint64_t v43 = v41 - v42;
      if (v43 >= v43 - 1) {
        uint64_t v44 = v43 - 1;
      }
      else {
        uint64_t v44 = v43;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v136;
      a1 = v145;
    }
  }
  uint64_t v4 = v3[25];
  unint64_t v5 = &unk_267771000;
  {
    uint64_t v137 = v2;
    uint64_t v146 = a1;
    uint64_t v129 = v4;
    unint64_t v5 = (void *)&unk_267771000;
    uint64_t v4 = v129;
    int v46 = v45;
    uint64_t v2 = v137;
    a1 = v146;
    if (v46)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      unint64_t v154 = 104;
      unint64_t v47 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v47) {
        unint64_t v48 = v47;
      }
      else {
        unint64_t v48 = v154;
      }
      unint64_t v49 = &v153[v48];
      unint64_t v50 = v154 - v48;
      if (v154 - v48 >= 0x12) {
        uint64_t v51 = 18;
      }
      else {
        uint64_t v51 = v154 - v48;
      }
      unint64_t v52 = v50 - v51;
      if (v52 >= v52 - 1) {
        uint64_t v53 = v52 - 1;
      }
      else {
        uint64_t v53 = v52;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      unint64_t v5 = (void *)&unk_267771000;
      uint64_t v4 = v129;
      uint64_t v2 = v137;
      a1 = v146;
    }
  }
  uint64_t v6 = v5[318];
  uint64_t v7 = &unk_267770000;
  {
    uint64_t v138 = v2;
    uint64_t v147 = a1;
    uint64_t v123 = v6;
    uint64_t v130 = v4;
    uint64_t v7 = (void *)&unk_267770000;
    uint64_t v6 = v123;
    uint64_t v4 = v130;
    int v55 = v54;
    uint64_t v2 = v138;
    a1 = v147;
    if (v55)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v154 = 86;
      unint64_t v56 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v56) {
        unint64_t v57 = v56;
      }
      else {
        unint64_t v57 = v154;
      }
      unint64_t v58 = &v153[v57];
      unint64_t v59 = v154 - v57;
      if (v154 - v57 >= 0x12) {
        uint64_t v60 = 18;
      }
      else {
        uint64_t v60 = v154 - v57;
      }
      unint64_t v61 = v59 - v60;
      if (v61 >= v61 - 1) {
        uint64_t v62 = v61 - 1;
      }
      else {
        uint64_t v62 = v61;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      uint64_t v7 = (void *)&unk_267770000;
      uint64_t v6 = v123;
      uint64_t v4 = v130;
      uint64_t v2 = v138;
      a1 = v147;
    }
  }
  uint64_t v8 = v7[431];
  unint64_t v9 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  {
    uint64_t v139 = v2;
    uint64_t v148 = a1;
    uint64_t v124 = v6;
    uint64_t v131 = v4;
    uint64_t v118 = v8;
    unint64_t v9 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    uint64_t v8 = v118;
    uint64_t v6 = v124;
    uint64_t v4 = v131;
    int v64 = v63;
    uint64_t v2 = v139;
    a1 = v148;
    if (v64)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<4>::Impl<Empty>]";
      unint64_t v154 = 90;
      unint64_t v65 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v65) {
        unint64_t v66 = v65;
      }
      else {
        unint64_t v66 = v154;
      }
      unint64_t v67 = &v153[v66];
      unint64_t v68 = v154 - v66;
      if (v154 - v66 >= 0x12) {
        uint64_t v69 = 18;
      }
      else {
        uint64_t v69 = v154 - v66;
      }
      unint64_t v70 = v68 - v69;
      if (v70 >= v70 - 1) {
        uint64_t v71 = v70 - 1;
      }
      else {
        uint64_t v71 = v70;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<4u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<4u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      unint64_t v9 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      uint64_t v8 = v118;
      uint64_t v6 = v124;
      uint64_t v4 = v131;
      uint64_t v2 = v139;
      a1 = v148;
    }
  }
  uint64_t v10 = v9[424];
  unint64_t v11 = &unk_267770000;
  {
    uint64_t v140 = v2;
    uint64_t v149 = a1;
    uint64_t v125 = v6;
    uint64_t v132 = v4;
    uint64_t v114 = v10;
    uint64_t v119 = v8;
    unint64_t v11 = (void *)&unk_267770000;
    uint64_t v10 = v114;
    uint64_t v8 = v119;
    uint64_t v6 = v125;
    uint64_t v4 = v132;
    int v73 = v72;
    uint64_t v2 = v140;
    a1 = v149;
    if (v73)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v154 = 84;
      unint64_t v74 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v74) {
        unint64_t v75 = v74;
      }
      else {
        unint64_t v75 = v154;
      }
      unint64_t v76 = &v153[v75];
      unint64_t v77 = v154 - v75;
      if (v154 - v75 >= 0x12) {
        uint64_t v78 = 18;
      }
      else {
        uint64_t v78 = v154 - v75;
      }
      unint64_t v79 = v77 - v78;
      if (v79 >= v79 - 1) {
        uint64_t v80 = v79 - 1;
      }
      else {
        uint64_t v80 = v79;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      unint64_t v11 = (void *)&unk_267770000;
      uint64_t v10 = v114;
      uint64_t v8 = v119;
      uint64_t v6 = v125;
      uint64_t v4 = v132;
      uint64_t v2 = v140;
      a1 = v149;
    }
  }
  uint64_t v12 = v11[435];
  char v13 = &unk_267771000;
  {
    uint64_t v141 = v2;
    uint64_t v150 = a1;
    uint64_t v126 = v6;
    uint64_t v133 = v4;
    uint64_t v115 = v10;
    uint64_t v120 = v8;
    uint64_t v111 = v12;
    char v13 = (void *)&unk_267771000;
    uint64_t v12 = v111;
    uint64_t v10 = v115;
    uint64_t v8 = v120;
    uint64_t v6 = v126;
    uint64_t v4 = v133;
    int v82 = v81;
    uint64_t v2 = v141;
    a1 = v150;
    if (v82)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v154 = 89;
      unint64_t v83 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v83) {
        unint64_t v84 = v83;
      }
      else {
        unint64_t v84 = v154;
      }
      unint64_t v85 = &v153[v84];
      unint64_t v86 = v154 - v84;
      if (v154 - v84 >= 0x12) {
        uint64_t v87 = 18;
      }
      else {
        uint64_t v87 = v154 - v84;
      }
      unint64_t v88 = v86 - v87;
      if (v88 >= v88 - 1) {
        uint64_t v89 = v88 - 1;
      }
      else {
        uint64_t v89 = v88;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      char v13 = (void *)&unk_267771000;
      uint64_t v12 = v111;
      uint64_t v10 = v115;
      uint64_t v8 = v120;
      uint64_t v6 = v126;
      uint64_t v4 = v133;
      uint64_t v2 = v141;
      a1 = v150;
    }
  }
  uint64_t v14 = v13[320];
  unint64_t v15 = &unk_267771000;
  {
    uint64_t v142 = v2;
    uint64_t v151 = a1;
    uint64_t v127 = v6;
    uint64_t v134 = v4;
    uint64_t v116 = v10;
    uint64_t v121 = v8;
    uint64_t v109 = v14;
    uint64_t v112 = v12;
    unint64_t v15 = (void *)&unk_267771000;
    uint64_t v14 = v109;
    uint64_t v12 = v112;
    uint64_t v10 = v116;
    uint64_t v8 = v121;
    uint64_t v6 = v127;
    uint64_t v4 = v134;
    int v91 = v90;
    uint64_t v2 = v142;
    a1 = v151;
    if (v91)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v154 = 90;
      unint64_t v92 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v92) {
        unint64_t v93 = v92;
      }
      else {
        unint64_t v93 = v154;
      }
      unint64_t v94 = &v153[v93];
      unint64_t v95 = v154 - v93;
      if (v154 - v93 >= 0x12) {
        uint64_t v96 = 18;
      }
      else {
        uint64_t v96 = v154 - v93;
      }
      unint64_t v97 = v95 - v96;
      if (v97 >= v97 - 1) {
        uint64_t v98 = v97 - 1;
      }
      else {
        uint64_t v98 = v97;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      unint64_t v15 = (void *)&unk_267771000;
      uint64_t v14 = v109;
      uint64_t v12 = v112;
      uint64_t v10 = v116;
      uint64_t v8 = v121;
      uint64_t v6 = v127;
      uint64_t v4 = v134;
      uint64_t v2 = v142;
      a1 = v151;
    }
  }
  uint64_t v16 = v15[37];
  unint64_t v17 = &unk_267771000;
  {
    uint64_t v143 = v2;
    uint64_t v152 = a1;
    uint64_t v128 = v6;
    uint64_t v135 = v4;
    uint64_t v117 = v10;
    uint64_t v122 = v8;
    uint64_t v110 = v14;
    uint64_t v113 = v12;
    uint64_t v108 = v16;
    unint64_t v17 = (void *)&unk_267771000;
    uint64_t v16 = v108;
    uint64_t v14 = v110;
    uint64_t v12 = v113;
    uint64_t v10 = v117;
    uint64_t v8 = v122;
    uint64_t v6 = v128;
    uint64_t v4 = v135;
    int v100 = v99;
    uint64_t v2 = v143;
    a1 = v152;
    if (v100)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      unint64_t v154 = 100;
      unint64_t v101 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v101) {
        unint64_t v102 = v101;
      }
      else {
        unint64_t v102 = v154;
      }
      unint64_t v103 = &v153[v102];
      unint64_t v104 = v154 - v102;
      if (v154 - v102 >= 0x12) {
        uint64_t v105 = 18;
      }
      else {
        uint64_t v105 = v154 - v102;
      }
      unint64_t v106 = v104 - v105;
      if (v106 >= v106 - 1) {
        uint64_t v107 = v106 - 1;
      }
      else {
        uint64_t v107 = v106;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      unint64_t v17 = (void *)&unk_267771000;
      uint64_t v16 = v108;
      uint64_t v14 = v110;
      uint64_t v12 = v113;
      uint64_t v10 = v117;
      uint64_t v8 = v122;
      uint64_t v6 = v128;
      uint64_t v4 = v135;
      uint64_t v2 = v143;
      a1 = v152;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v17[41] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)4)) {
    return 0;
  }
  uint64_t v6 = a1;
  if (!mlir::mps::ScatterAlongAxisOp::verifyInvariantsImpl((mlir::mps::ScatterAlongAxisOp *)&v6)) {
    return 0;
  }
  uint64_t v6 = a1;
  return mlir::mps::ScatterAlongAxisOp::verify((mlir::mps::ScatterAlongAxisOp *)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::ScatterAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterNDOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterNDOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ScatterNDOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.scatter_nd", 14, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ScatterNDOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C3657F0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v7 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v7 = 0;
  }
  if (a4 == 4)
  {
    if (*(_DWORD *)a3 != 1701080941) {
      return 0;
    }
    return v7[1];
  }
  else
  {
    if (a4 != 10) {
      return 0;
    }
    if (*(void *)a3 != 0x69645F6863746162 || *(_WORD *)(a3 + 8) != 29549) {
      return 0;
    }
    return *v7;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v11);
  if (v7 == 4)
  {
    if (*(_DWORD *)result == 1701080941)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::ScatterModeAttr,void>::id) {
          uint64_t v9 = a4;
        }
        else {
          uint64_t v9 = 0;
        }
        v5[1] = v9;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else if (v7 == 10 && *(void *)result == 0x69645F6863746162 && *(_WORD *)(result + 8) == 29549)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
        uint64_t v10 = a4;
      }
      else {
        uint64_t v10 = 0;
      }
      *uint64_t v5 = v10;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  if (*v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"batch_dims", 10, *v5);
  }
  uint64_t v6 = v5[1];
  if (v6)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"mode", 4, v6);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9 = (void **)mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  BOOL result = 0;
  if (!v9
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v9, (void **)"batch_dims", (const char *)0xA, a4, a5))
  {
    uint64_t v10 = mlir::NamedAttrList::get(a3, *(void *)(*(void *)(a2 + 96) + 8));
    if (!v10
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps40(v10, (void **)"mode", (const char *)4, a4, a5))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::getOpPropertyByteSize()
{
  return 16;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    *(_OWORD *)a3 = *a4;
  }
  else
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ScatterNDOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::ScatterNDOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2 && a3[1] == a2[1];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterNDOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::ModuleOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterNDOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterNDOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterNDOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterNDOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ScatterNDOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::ScatterModeAttr>(a1, v3 + 1) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterNDOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 16))(a3, *v4);
  uint64_t v5 = v4[1];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterNDOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterNDOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterNDOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterNDOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterNDOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, _DWORD *a11)
{
  return mlir::mps::ScatterNDOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterNDOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ScatterNDOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterNDOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ScatterNDOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::ScatterNDOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, &v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    uint64_t v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.scatter_nd";
    v25[1] = 14;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ScatterNDOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ScatterNDOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ScatterNDOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ScatterNDOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ScatterNDOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    unint64_t v10 = (long long *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  }
  else {
    unint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  long long v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.scatter_nd", 14, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)3)) {
    return 0;
  }
  unint64_t v6 = a1;
  if (!mlir::mps::ScatterNDOp::verifyInvariantsImpl((mlir::mps::ScatterNDOp *)&v6)) {
    return 0;
  }
  unint64_t v6 = a1;
  return mlir::mps::ScatterNDOp::verify((mlir::mps::ScatterNDOp *)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::ScatterNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ScatterOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.scatter", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ScatterOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36F430;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::getInherentAttr(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  if (a4 == 4 && *a3 == 1701080941) {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    return 0;
  }
}

_DWORD *mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  if (v7 == 4 && *result == 1701080941)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::ScatterModeAttr,void>::id) {
        uint64_t v8 = a4;
      }
      else {
        uint64_t v8 = 0;
      }
      *uint64_t v5 = v8;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"mode", 4, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps40(v7, (void **)"mode", (const char *)4, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ScatterAlongAxisOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::ScatterAlongAxisOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ScatterOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ScatterOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::ScatterModeAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 16))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ScatterOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ScatterOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ScatterOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ScatterOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  long long v22 = v24;
  uint64_t v23 = 0x400000000;
  if (mlir::mps::ScatterOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, v18, v19, (uint64_t)&v22))
  {
    mlir::ValueRange::ValueRange(v21, (uint64_t)v22, v23);
    mlir::ValueRange::ValueRange(v20, *(void *)a11, *(unsigned int *)(a11 + 8));
    v25[0] = &unk_26C380E60;
    uint64_t v26 = v25;
    int v28 = v27;
    v27[0] = &unk_26C380E60;
    if (v28 == v27)
    {
      (*(void (**)(void *))(v27[0] + 32))(v27);
      unint64_t v14 = v26;
      if (v26 != v25) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v28) {
        (*(void (**)(void *))(*v28 + 40))(v28);
      }
      unint64_t v14 = v26;
      if (v26 != v25)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v22;
          if (v22 == v24) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v25[0] + 32))(v25);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v27[0] = "mps.scatter";
    v27[1] = 11;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v27, "' op inferred type(s) ", (uint64_t)&v22, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v22;
    if (v22 == v24) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v22;
  if (v22 != v24) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ScatterOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ScatterOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ScatterOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ScatterOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ScatterOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  unint64_t v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  uint64_t v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.scatter", 11, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)4)) {
    return 0;
  }
  unint64_t v6 = a1;
  if (!mlir::mps::ScatterAlongAxisOp::verifyInvariantsImpl((mlir::mps::ScatterAlongAxisOp *)&v6)) {
    return 0;
  }
  unint64_t v6 = a1;
  return mlir::mps::ScatterOp::verify((mlir::mps::ScatterOp *)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::ScatterOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SelectOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SelectOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SelectOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SelectOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.select", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SelectOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36E7B0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SelectOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SelectOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SelectOp>::foldHook(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                      + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SelectOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SelectOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SelectOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SelectOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SelectOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SelectOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SelectOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SelectOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SelectOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SelectOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SelectOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      unint64_t v11 = v32;
      uint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          unint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SelectOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SelectOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SelectOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SelectOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SelectOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SelectOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SelectOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SelectOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SelectOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SelectOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::SelectOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SelectOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SelectOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SelectOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SelectOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v22 = v24;
  uint64_t v23 = 0x400000000;
  if (mlir::mps::SelectOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, v18, v19, (uint64_t)&v22))
  {
    mlir::ValueRange::ValueRange(v21, (uint64_t)v22, v23);
    mlir::ValueRange::ValueRange(v20, *(void *)a11, *(unsigned int *)(a11 + 8));
    v25[0] = &unk_26C380E60;
    unsigned int v26 = v25;
    int v28 = v27;
    v27[0] = &unk_26C380E60;
    if (v28 == v27)
    {
      (*(void (**)(void *))(v27[0] + 32))(v27);
      unint64_t v14 = v26;
      if (v26 != v25) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v28) {
        (*(void (**)(void *))(*v28 + 40))(v28);
      }
      unint64_t v14 = v26;
      if (v26 != v25)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v22;
          if (v22 == v24) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v25[0] + 32))(v25);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v27[0] = "mps.select";
    v27[1] = 10;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v27, "' op inferred type(s) ", (uint64_t)&v22, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v22;
    if (v22 == v24) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v22;
  if (v22 != v24) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SelectOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SelectOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SelectOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SelectOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SelectOp>(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::SelectOpGenericAdaptorBase::SelectOpGenericAdaptorBase((uint64_t)v14, a1);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)a1);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if (a1 - 4 != (unsigned int *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::SelectOp>,mlir::OpTrait::OneResult<mlir::mps::SelectOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::SelectOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::SelectOp>,mlir::OpTrait::NOperands<3u>::Impl<mlir::mps::SelectOp>,mlir::OpTrait::OpInvariants<mlir::mps::SelectOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::SelectOp>,mlir::OpTrait::ResultsBroadcastableShape<mlir::mps::SelectOp>,mlir::OpTrait::Stitchable<mlir::mps::SelectOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::SelectOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::SelectOp>>(a1, a2))return 0; {
  uint64_t v4 = a1;
  }
  return mlir::mps::SelectOp::verify((mlir::mps::SelectOp *)&v4) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::SelectOp>,mlir::OpTrait::OneResult<mlir::mps::SelectOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::SelectOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::SelectOp>,mlir::OpTrait::NOperands<3u>::Impl<mlir::mps::SelectOp>,mlir::OpTrait::OpInvariants<mlir::mps::SelectOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::SelectOp>,mlir::OpTrait::ResultsBroadcastableShape<mlir::mps::SelectOp>,mlir::OpTrait::Stitchable<mlir::mps::SelectOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::SelectOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::SelectOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)3)
    && (uint64_t v7 = a1, mlir::mps::SelectOp::verifyInvariantsImpl((mlir::mps::SelectOp *)&v7)))
  {
    return mlir::OpTrait::impl::verifyCompatibleOperandBroadcast(a1, v5) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::SelectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::ShapeOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ShapeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ShapeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ShapeOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.shape", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ShapeOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36DCC0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ShapeOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ShapeOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ShapeOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ShapeOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ShapeOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ShapeOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ShapeOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ShapeOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ShapeOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ShapeOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ShapeOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ShapeOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ShapeOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ShapeOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ShapeOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ShapeOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ShapeOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ShapeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ShapeOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ShapeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ShapeOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ShapeOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ShapeOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ShapeOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ShapeOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ShapeOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ShapeOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ShapeOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ShapeOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v22 = v24;
  uint64_t v23 = 0x400000000;
  if (mlir::mps::ShapeOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, v18, v19, (uint64_t)&v22))
  {
    mlir::ValueRange::ValueRange(v21, (uint64_t)v22, v23);
    mlir::ValueRange::ValueRange(v20, *(void *)a11, *(unsigned int *)(a11 + 8));
    v25[0] = &unk_26C380E60;
    unsigned int v26 = v25;
    int v28 = v27;
    v27[0] = &unk_26C380E60;
    if (v28 == v27)
    {
      (*(void (**)(void *))(v27[0] + 32))(v27);
      unint64_t v14 = v26;
      if (v26 != v25) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v28) {
        (*(void (**)(void *))(*v28 + 40))(v28);
      }
      unint64_t v14 = v26;
      if (v26 != v25)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v22;
          if (v22 == v24) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v25[0] + 32))(v25);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v27[0] = "mps.shape";
    v27[1] = 9;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v27, "' op inferred type(s) ", (uint64_t)&v22, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v22;
    if (v22 == v24) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v22;
  if (v22 != v24) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ShapeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ShapeOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ShapeOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ShapeOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ShapeOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::ShapeOpGenericAdaptorBase::ShapeOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::RankOp>,mlir::OpTrait::OneResult<mlir::mps::RankOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::RankOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::RankOp>,mlir::OpTrait::OneOperand<mlir::mps::RankOp>,mlir::OpTrait::OpInvariants<mlir::mps::RankOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::RankOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::RankOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::RankOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::ShapeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.sigmoid_gradient", 20, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SigmoidGradientOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C369670;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SigmoidGradientOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SigmoidGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  uint64_t v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  uint64_t v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  uint64_t v24 = "mps.sigmoid_gradient";
  uint64_t v25 = 20;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SigmoidGradientOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SigmoidGradientOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::SigmoidGradientOpGenericAdaptorBase::SigmoidGradientOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v210 = a1;
    v1 = (void *)&unk_267771000;
    int v37 = v36;
    a1 = v210;
    if (v37)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v223 = 83;
      unint64_t v38 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v38) {
        unint64_t v39 = v38;
      }
      else {
        unint64_t v39 = v223;
      }
      unint64_t v40 = &v222[v39];
      unint64_t v41 = v223 - v39;
      if (v223 - v39 >= 0x12) {
        uint64_t v42 = 18;
      }
      else {
        uint64_t v42 = v223 - v39;
      }
      unint64_t v43 = v41 - v42;
      if (v43 >= v43 - 1) {
        uint64_t v44 = v43 - 1;
      }
      else {
        uint64_t v44 = v43;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      v1 = (void *)&unk_267771000;
      a1 = v210;
    }
  }
  uint64_t v2 = v1[23];
  char v3 = &unk_267771000;
  {
    uint64_t v199 = v2;
    uint64_t v211 = a1;
    char v3 = (void *)&unk_267771000;
    int v46 = v45;
    uint64_t v2 = v199;
    a1 = v211;
    if (v46)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v223 = 81;
      unint64_t v47 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v47) {
        unint64_t v48 = v47;
      }
      else {
        unint64_t v48 = v223;
      }
      unint64_t v49 = &v222[v48];
      unint64_t v50 = v223 - v48;
      if (v223 - v48 >= 0x12) {
        uint64_t v51 = 18;
      }
      else {
        uint64_t v51 = v223 - v48;
      }
      unint64_t v52 = v50 - v51;
      if (v52 >= v52 - 1) {
        uint64_t v53 = v52 - 1;
      }
      else {
        uint64_t v53 = v52;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v199;
      a1 = v211;
    }
  }
  uint64_t v4 = v3[25];
  unint64_t v5 = &unk_267771000;
  {
    uint64_t v200 = v2;
    uint64_t v212 = a1;
    uint64_t v189 = v4;
    unint64_t v5 = (void *)&unk_267771000;
    uint64_t v4 = v189;
    uint64_t v2 = v200;
    int v55 = v54;
    a1 = v212;
    if (v55)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      unint64_t v223 = 104;
      unint64_t v56 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v56) {
        unint64_t v57 = v56;
      }
      else {
        unint64_t v57 = v223;
      }
      unint64_t v58 = &v222[v57];
      unint64_t v59 = v223 - v57;
      if (v223 - v57 >= 0x12) {
        uint64_t v60 = 18;
      }
      else {
        uint64_t v60 = v223 - v57;
      }
      unint64_t v61 = v59 - v60;
      if (v61 >= v61 - 1) {
        uint64_t v62 = v61 - 1;
      }
      else {
        uint64_t v62 = v61;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      unint64_t v5 = (void *)&unk_267771000;
      uint64_t v4 = v189;
      uint64_t v2 = v200;
      a1 = v212;
    }
  }
  uint64_t v6 = v5[318];
  uint64_t v7 = &unk_267770000;
  {
    uint64_t v201 = v2;
    uint64_t v213 = a1;
    uint64_t v190 = v4;
    uint64_t v180 = v6;
    uint64_t v7 = (void *)&unk_267770000;
    uint64_t v6 = v180;
    uint64_t v4 = v190;
    uint64_t v2 = v201;
    int v64 = v63;
    a1 = v213;
    if (v64)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v223 = 86;
      unint64_t v65 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v65) {
        unint64_t v66 = v65;
      }
      else {
        unint64_t v66 = v223;
      }
      unint64_t v67 = &v222[v66];
      unint64_t v68 = v223 - v66;
      if (v223 - v66 >= 0x12) {
        uint64_t v69 = 18;
      }
      else {
        uint64_t v69 = v223 - v66;
      }
      unint64_t v70 = v68 - v69;
      if (v70 >= v70 - 1) {
        uint64_t v71 = v70 - 1;
      }
      else {
        uint64_t v71 = v70;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      uint64_t v7 = (void *)&unk_267770000;
      uint64_t v6 = v180;
      uint64_t v4 = v190;
      uint64_t v2 = v201;
      a1 = v213;
    }
  }
  uint64_t v8 = v7[431];
  uint64_t v9 = &unk_267771000;
  {
    uint64_t v202 = v2;
    uint64_t v214 = a1;
    uint64_t v191 = v4;
    uint64_t v172 = v8;
    uint64_t v181 = v6;
    uint64_t v9 = (void *)&unk_267771000;
    uint64_t v8 = v172;
    uint64_t v6 = v181;
    uint64_t v4 = v191;
    uint64_t v2 = v202;
    int v73 = v72;
    a1 = v214;
    if (v73)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      unint64_t v223 = 90;
      unint64_t v74 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v74) {
        unint64_t v75 = v74;
      }
      else {
        unint64_t v75 = v223;
      }
      unint64_t v76 = &v222[v75];
      unint64_t v77 = v223 - v75;
      if (v223 - v75 >= 0x12) {
        uint64_t v78 = 18;
      }
      else {
        uint64_t v78 = v223 - v75;
      }
      unint64_t v79 = v77 - v78;
      if (v79 >= v79 - 1) {
        uint64_t v80 = v79 - 1;
      }
      else {
        uint64_t v80 = v79;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      uint64_t v9 = (void *)&unk_267771000;
      uint64_t v8 = v172;
      uint64_t v6 = v181;
      uint64_t v4 = v191;
      uint64_t v2 = v202;
      a1 = v214;
    }
  }
  uint64_t v10 = v9[89];
  uint64_t v11 = &unk_267770000;
  {
    uint64_t v203 = v2;
    uint64_t v215 = a1;
    uint64_t v192 = v4;
    uint64_t v173 = v8;
    uint64_t v182 = v6;
    uint64_t v165 = v10;
    uint64_t v11 = (void *)&unk_267770000;
    uint64_t v10 = v165;
    uint64_t v8 = v173;
    uint64_t v6 = v182;
    uint64_t v4 = v192;
    uint64_t v2 = v203;
    int v82 = v81;
    a1 = v215;
    if (v82)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v223 = 84;
      unint64_t v83 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v83) {
        unint64_t v84 = v83;
      }
      else {
        unint64_t v84 = v223;
      }
      unint64_t v85 = &v222[v84];
      unint64_t v86 = v223 - v84;
      if (v223 - v84 >= 0x12) {
        uint64_t v87 = 18;
      }
      else {
        uint64_t v87 = v223 - v84;
      }
      unint64_t v88 = v86 - v87;
      if (v88 >= v88 - 1) {
        uint64_t v89 = v88 - 1;
      }
      else {
        uint64_t v89 = v88;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      uint64_t v11 = (void *)&unk_267770000;
      uint64_t v10 = v165;
      uint64_t v8 = v173;
      uint64_t v6 = v182;
      uint64_t v4 = v192;
      uint64_t v2 = v203;
      a1 = v215;
    }
  }
  uint64_t v12 = v11[435];
  char v13 = &unk_267771000;
  {
    uint64_t v204 = v2;
    uint64_t v216 = a1;
    uint64_t v193 = v4;
    uint64_t v174 = v8;
    uint64_t v183 = v6;
    uint64_t v159 = v12;
    uint64_t v166 = v10;
    char v13 = (void *)&unk_267771000;
    uint64_t v12 = v159;
    uint64_t v10 = v166;
    uint64_t v8 = v174;
    uint64_t v6 = v183;
    uint64_t v4 = v193;
    uint64_t v2 = v204;
    int v91 = v90;
    a1 = v216;
    if (v91)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v223 = 93;
      unint64_t v92 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v92) {
        unint64_t v93 = v92;
      }
      else {
        unint64_t v93 = v223;
      }
      unint64_t v94 = &v222[v93];
      unint64_t v95 = v223 - v93;
      if (v223 - v93 >= 0x12) {
        uint64_t v96 = 18;
      }
      else {
        uint64_t v96 = v223 - v93;
      }
      unint64_t v97 = v95 - v96;
      if (v97 >= v97 - 1) {
        uint64_t v98 = v97 - 1;
      }
      else {
        uint64_t v98 = v97;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      char v13 = (void *)&unk_267771000;
      uint64_t v12 = v159;
      uint64_t v10 = v166;
      uint64_t v8 = v174;
      uint64_t v6 = v183;
      uint64_t v4 = v193;
      uint64_t v2 = v204;
      a1 = v216;
    }
  }
  uint64_t v14 = v13[31];
  uint64_t v15 = &unk_267771000;
  {
    uint64_t v205 = v2;
    uint64_t v217 = a1;
    uint64_t v194 = v4;
    uint64_t v175 = v8;
    uint64_t v184 = v6;
    uint64_t v160 = v12;
    uint64_t v167 = v10;
    uint64_t v154 = v14;
    uint64_t v15 = (void *)&unk_267771000;
    uint64_t v14 = v154;
    uint64_t v12 = v160;
    uint64_t v10 = v167;
    uint64_t v8 = v175;
    uint64_t v6 = v184;
    uint64_t v4 = v194;
    uint64_t v2 = v205;
    int v100 = v99;
    a1 = v217;
    if (v100)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultElementType<Empty>]";
      unint64_t v223 = 104;
      unint64_t v101 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v101) {
        unint64_t v102 = v101;
      }
      else {
        unint64_t v102 = v223;
      }
      unint64_t v103 = &v222[v102];
      unint64_t v104 = v223 - v102;
      if (v223 - v102 >= 0x12) {
        uint64_t v105 = 18;
      }
      else {
        uint64_t v105 = v223 - v102;
      }
      unint64_t v106 = v104 - v105;
      if (v106 >= v106 - 1) {
        uint64_t v107 = v106 - 1;
      }
      else {
        uint64_t v107 = v106;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultElementType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultElementType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      uint64_t v15 = (void *)&unk_267771000;
      uint64_t v14 = v154;
      uint64_t v12 = v160;
      uint64_t v10 = v167;
      uint64_t v8 = v175;
      uint64_t v6 = v184;
      uint64_t v4 = v194;
      uint64_t v2 = v205;
      a1 = v217;
    }
  }
  uint64_t v16 = v15[167];
  uint64_t v17 = &unk_267771000;
  {
    uint64_t v206 = v2;
    uint64_t v218 = a1;
    uint64_t v195 = v4;
    uint64_t v176 = v8;
    uint64_t v185 = v6;
    uint64_t v161 = v12;
    uint64_t v168 = v10;
    uint64_t v150 = v16;
    uint64_t v155 = v14;
    uint64_t v17 = (void *)&unk_267771000;
    uint64_t v16 = v150;
    uint64_t v14 = v155;
    uint64_t v12 = v161;
    uint64_t v10 = v168;
    uint64_t v8 = v176;
    uint64_t v6 = v185;
    uint64_t v4 = v195;
    uint64_t v2 = v206;
    int v109 = v108;
    a1 = v218;
    if (v109)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultType<Empty>]";
      unint64_t v223 = 97;
      unint64_t v110 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v110) {
        unint64_t v111 = v110;
      }
      else {
        unint64_t v111 = v223;
      }
      uint64_t v112 = &v222[v111];
      unint64_t v113 = v223 - v111;
      if (v223 - v111 >= 0x12) {
        uint64_t v114 = 18;
      }
      else {
        uint64_t v114 = v223 - v111;
      }
      unint64_t v115 = v113 - v114;
      if (v115 >= v115 - 1) {
        uint64_t v116 = v115 - 1;
      }
      else {
        uint64_t v116 = v115;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v112[v114], v116);
      uint64_t v17 = (void *)&unk_267771000;
      uint64_t v16 = v150;
      uint64_t v14 = v155;
      uint64_t v12 = v161;
      uint64_t v10 = v168;
      uint64_t v8 = v176;
      uint64_t v6 = v185;
      uint64_t v4 = v195;
      uint64_t v2 = v206;
      a1 = v218;
    }
  }
  uint64_t v18 = v17[328];
  unint64_t v19 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  {
    uint64_t v207 = v2;
    uint64_t v219 = a1;
    uint64_t v196 = v4;
    uint64_t v177 = v8;
    uint64_t v186 = v6;
    uint64_t v162 = v12;
    uint64_t v169 = v10;
    uint64_t v151 = v16;
    uint64_t v156 = v14;
    uint64_t v147 = v18;
    unint64_t v19 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    uint64_t v18 = v147;
    uint64_t v16 = v151;
    uint64_t v14 = v156;
    uint64_t v12 = v162;
    uint64_t v10 = v169;
    uint64_t v8 = v177;
    uint64_t v6 = v186;
    uint64_t v4 = v196;
    uint64_t v2 = v207;
    int v118 = v117;
    a1 = v219;
    if (v118)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Stitchable<Empty>]";
      unint64_t v223 = 82;
      unint64_t v119 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v119) {
        unint64_t v120 = v119;
      }
      else {
        unint64_t v120 = v223;
      }
      uint64_t v121 = &v222[v120];
      unint64_t v122 = v223 - v120;
      if (v223 - v120 >= 0x12) {
        uint64_t v123 = 18;
      }
      else {
        uint64_t v123 = v223 - v120;
      }
      unint64_t v124 = v122 - v123;
      if (v124 >= v124 - 1) {
        uint64_t v125 = v124 - 1;
      }
      else {
        uint64_t v125 = v124;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v121[v123], v125);
      unint64_t v19 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      uint64_t v18 = v147;
      uint64_t v16 = v151;
      uint64_t v14 = v156;
      uint64_t v12 = v162;
      uint64_t v10 = v169;
      uint64_t v8 = v177;
      uint64_t v6 = v186;
      uint64_t v4 = v196;
      uint64_t v2 = v207;
      a1 = v219;
    }
  }
  uint64_t v20 = v19[364];
  int v21 = &unk_267771000;
  {
    uint64_t v208 = v2;
    uint64_t v220 = a1;
    uint64_t v197 = v4;
    uint64_t v178 = v8;
    uint64_t v187 = v6;
    uint64_t v163 = v12;
    uint64_t v170 = v10;
    uint64_t v152 = v16;
    uint64_t v157 = v14;
    uint64_t v145 = v20;
    uint64_t v148 = v18;
    int v21 = (void *)&unk_267771000;
    uint64_t v20 = v145;
    uint64_t v18 = v148;
    uint64_t v16 = v152;
    uint64_t v14 = v157;
    uint64_t v12 = v163;
    uint64_t v10 = v170;
    uint64_t v8 = v178;
    uint64_t v6 = v187;
    uint64_t v4 = v197;
    uint64_t v2 = v208;
    int v127 = v126;
    a1 = v220;
    if (v127)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      unint64_t v223 = 100;
      unint64_t v128 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v128) {
        unint64_t v129 = v128;
      }
      else {
        unint64_t v129 = v223;
      }
      uint64_t v130 = &v222[v129];
      unint64_t v131 = v223 - v129;
      if (v223 - v129 >= 0x12) {
        uint64_t v132 = 18;
      }
      else {
        uint64_t v132 = v223 - v129;
      }
      unint64_t v133 = v131 - v132;
      if (v133 >= v133 - 1) {
        uint64_t v134 = v133 - 1;
      }
      else {
        uint64_t v134 = v133;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v130[v132], v134);
      int v21 = (void *)&unk_267771000;
      uint64_t v20 = v145;
      uint64_t v18 = v148;
      uint64_t v16 = v152;
      uint64_t v14 = v157;
      uint64_t v12 = v163;
      uint64_t v10 = v170;
      uint64_t v8 = v178;
      uint64_t v6 = v187;
      uint64_t v4 = v197;
      uint64_t v2 = v208;
      a1 = v220;
    }
  }
  uint64_t v22 = v21[41];
  uint64_t v23 = &unk_267771000;
  {
    uint64_t v209 = v2;
    uint64_t v221 = a1;
    uint64_t v198 = v4;
    uint64_t v179 = v8;
    uint64_t v188 = v6;
    uint64_t v164 = v12;
    uint64_t v171 = v10;
    uint64_t v153 = v16;
    uint64_t v158 = v14;
    uint64_t v146 = v20;
    uint64_t v149 = v18;
    uint64_t v144 = v22;
    uint64_t v23 = (void *)&unk_267771000;
    uint64_t v22 = v144;
    uint64_t v20 = v146;
    uint64_t v18 = v149;
    uint64_t v16 = v153;
    uint64_t v14 = v158;
    uint64_t v12 = v164;
    uint64_t v10 = v171;
    uint64_t v8 = v179;
    uint64_t v6 = v188;
    uint64_t v4 = v198;
    uint64_t v2 = v209;
    int v136 = v135;
    a1 = v221;
    if (v136)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v223 = 90;
      unint64_t v137 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v137) {
        unint64_t v138 = v137;
      }
      else {
        unint64_t v138 = v223;
      }
      uint64_t v139 = &v222[v138];
      unint64_t v140 = v223 - v138;
      if (v223 - v138 >= 0x12) {
        uint64_t v141 = 18;
      }
      else {
        uint64_t v141 = v223 - v138;
      }
      unint64_t v142 = v140 - v141;
      if (v142 >= v142 - 1) {
        uint64_t v143 = v142 - 1;
      }
      else {
        uint64_t v143 = v142;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v139[v141], v143);
      uint64_t v23 = (void *)&unk_267771000;
      uint64_t v22 = v144;
      uint64_t v20 = v146;
      uint64_t v18 = v149;
      uint64_t v16 = v153;
      uint64_t v14 = v158;
      uint64_t v12 = v164;
      uint64_t v10 = v171;
      uint64_t v8 = v179;
      uint64_t v6 = v188;
      uint64_t v4 = v198;
      uint64_t v2 = v209;
      a1 = v221;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v22 == a1
      || v23[37] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::OneResult<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::SigmoidGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::Stitchable<mlir::mps::SigmoidGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::SigmoidGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::SigmoidGradientOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::OneResult<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::SigmoidGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::Stitchable<mlir::mps::SigmoidGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::SigmoidGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::SigmoidGradientOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (uint64_t v8 = a1, mlir::mps::FloorDivideOp::verifyInvariantsImpl((mlir::mps::FloorDivideOp *)&v8))
    && mlir::OpTrait::impl::verifySameOperandsAndResultElementType(a1, v5))
  {
    return mlir::OpTrait::impl::verifySameOperandsAndResultType(a1, v6) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::SigmoidGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientWithSigmoidOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientWithSigmoidOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientWithSigmoidOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.sigmoid_gradient_with_sigmoid", 33, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SigmoidGradientWithSigmoidOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36B1C8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      uint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientWithSigmoidOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientWithSigmoidOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientWithSigmoidOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SigmoidGradientWithSigmoidOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidGradientWithSigmoidOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SigmoidGradientWithSigmoidOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  uint64_t v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  uint64_t v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  uint64_t v24 = "mps.sigmoid_gradient_with_sigmoid";
  uint64_t v25 = 33;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SigmoidGradientWithSigmoidOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SigmoidGradientWithSigmoidOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::SigmoidGradientWithSigmoidOpGenericAdaptorBase::SigmoidGradientWithSigmoidOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::OneResult<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::SigmoidGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::SigmoidGradientOp>,mlir::OpTrait::Stitchable<mlir::mps::SigmoidGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::SigmoidGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::SigmoidGradientOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::SigmoidGradientWithSigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SigmoidHardOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidHardOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidHardOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SigmoidHardOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.sigmoid_hard", 16, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SigmoidHardOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C3669E8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidHardOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SigmoidHardOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidHardOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  unint64_t v9 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  char v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0) {
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v6 & 2) == 0) {
      llvm::deallocate_buffer(v8[0], v8[1]);
    }
  }
  return v5;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SigmoidHardOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SigmoidHardOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SigmoidHardOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SigmoidHardOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                       + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidHardOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidHardOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidHardOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SigmoidHardOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidHardOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidHardOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidHardOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    uint64_t v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    uint64_t v13 = v29;
    if (v29)
    {
      unint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidHardOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidHardOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidHardOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidHardOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidHardOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidHardOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidHardOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidHardOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidHardOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidHardOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidHardOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SigmoidHardOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidHardOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SigmoidHardOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.sigmoid_hard";
    v25[1] = 16;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SigmoidHardOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SigmoidHardOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SigmoidHardOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SigmoidHardOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SigmoidHardOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::SigmoidHardOpGenericAdaptorBase::SigmoidHardOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::NReluOp>,mlir::OpTrait::OneResult<mlir::mps::NReluOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::NReluOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::NReluOp>,mlir::OpTrait::NOperands<3u>::Impl<mlir::mps::NReluOp>,mlir::OpTrait::OpInvariants<mlir::mps::NReluOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::NReluOp>,mlir::OpTrait::ResultsBroadcastableShape<mlir::mps::NReluOp>,mlir::OpTrait::Stitchable<mlir::mps::NReluOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::NReluOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::NReluOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::SigmoidHardOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SigmoidOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SigmoidOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.sigmoid", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SigmoidOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36F4F8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SigmoidOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SigmoidOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SigmoidOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SigmoidOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SigmoidOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SigmoidOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SigmoidOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SigmoidOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SigmoidOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SigmoidOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SigmoidOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SigmoidOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  uint64_t v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  uint64_t v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  uint64_t v24 = "mps.sigmoid";
  uint64_t v25 = 11;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SigmoidOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SigmoidOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::SigmoidOpGenericAdaptorBase::SigmoidOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ACosOp>,mlir::OpTrait::OneResult<mlir::mps::ACosOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ACosOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ACosOp>,mlir::OpTrait::OneOperand<mlir::mps::ACosOp>,mlir::OpTrait::OpInvariants<mlir::mps::ACosOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ACosOp>,mlir::OpTrait::Stitchable<mlir::mps::ACosOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ACosOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ACosOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::SigmoidOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SignOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SignOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SignOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SignOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.sign", 8, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SignOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36CC58;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SignOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SignOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SignOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SignOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SignOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SignOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SignOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SignOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SignOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SignOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SignOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SignOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SignOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SignOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SignOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SignOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SignOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SignOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SignOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  uint64_t v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  uint64_t v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  uint64_t v24 = "mps.sign";
  uint64_t v25 = 8;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SignOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SignOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::SignOpGenericAdaptorBase::SignOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ACosOp>,mlir::OpTrait::OneResult<mlir::mps::ACosOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ACosOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ACosOp>,mlir::OpTrait::OneOperand<mlir::mps::ACosOp>,mlir::OpTrait::OpInvariants<mlir::mps::ACosOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ACosOp>,mlir::OpTrait::Stitchable<mlir::mps::ACosOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ACosOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ACosOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SignbitOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SignbitOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SignbitOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SignbitOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.signbit", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SignbitOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36F5C0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignbitOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SignbitOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignbitOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SignbitOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SignbitOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SignbitOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignbitOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignbitOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignbitOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignbitOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SignbitOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignbitOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignbitOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignbitOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignbitOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignbitOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SignbitOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SignbitOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SignbitOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SignbitOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SignbitOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SignbitOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SignbitOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SignbitOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SignbitOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SignbitOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SignbitOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SignbitOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SignbitOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SignbitOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SignbitOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  uint64_t v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  uint64_t v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  uint64_t v24 = "mps.signbit";
  uint64_t v25 = 11;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SignbitOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SignbitOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::SignbitOpGenericAdaptorBase::SignbitOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ACosOp>,mlir::OpTrait::OneResult<mlir::mps::ACosOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ACosOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ACosOp>,mlir::OpTrait::OneOperand<mlir::mps::ACosOp>,mlir::OpTrait::OpInvariants<mlir::mps::ACosOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ACosOp>,mlir::OpTrait::Stitchable<mlir::mps::ACosOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ACosOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ACosOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::SignbitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SinOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SinOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SinOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SinOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.sin", 7, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SinOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36BF10;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SinOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SinOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SinOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SinOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SinOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SinOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SinOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SinOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SinOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SinOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SinOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SinOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SinOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SinOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SinOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SinOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SinOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SinOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SinOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  uint64_t v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  uint64_t v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  uint64_t v24 = "mps.sin";
  uint64_t v25 = 7;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SinOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SinOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::SinOpGenericAdaptorBase::SinOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ACosOp>,mlir::OpTrait::OneResult<mlir::mps::ACosOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ACosOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ACosOp>,mlir::OpTrait::OneOperand<mlir::mps::ACosOp>,mlir::OpTrait::OpInvariants<mlir::mps::ACosOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ACosOp>,mlir::OpTrait::Stitchable<mlir::mps::ACosOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ACosOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ACosOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.singlegate_rnn_gradient", 27, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SingleGateRNNGradientOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36AF70;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::getInherentAttr(uint64_t a1, uint64_t a2, _WORD *a3, size_t a4)
{
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::mps::SingleGateRNNGradientOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (_WORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::SingleGateRNNGradientOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }
  if (*v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"activation", 10, *v6);
  }
  uint64_t v7 = v6[1];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"gradient_for_input_state", 24, v7);
  }
  uint64_t v8 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, (uint64_t)(v6 + 2), 5);

  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  BOOL result = 0;
  if (!v9
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v9, (void **)"activation", (const char *)0xA, a4, a5))
  {
    uint64_t v10 = mlir::NamedAttrList::get(a3, *(void *)(*(void *)(a2 + 96) + 8));
    if (!v10
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v10, (void **)"gradient_for_input_state", (const char *)0x18, a4, a5))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::getOpPropertyByteSize()
{
  return 40;
}

double mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  if (a4)
  {
    long long v4 = *a4;
    long long v5 = a4[1];
    *(void *)(a3 + 32) = *((void *)a4 + 4);
    *(_OWORD *)a3 = v4;
    *(_OWORD *)(a3 + 16) = v5;
  }
  else
  {
    *(void *)(a3 + 32) = 0;
    *(void *)&long long v4 = 0;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
  }
  return *(double *)&v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::SingleGateRNNGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::mps::SingleGateRNNGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  long long v4 = *(_OWORD *)(a3 + 16);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a3 + 32);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::compareProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)a3 != *(void *)a2) {
    return 0;
  }
  if (*(void *)(a3 + 8) != *(void *)(a2 + 8)) {
    return 0;
  }
  return *(void *)(a3 + 16) == *(void *)(a2 + 16)
      && *(void *)(a3 + 24) == *(void *)(a2 + 24)
      && *(_DWORD *)(a3 + 32) == (unint64_t)*(unsigned int *)(a2 + 32);
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNGradientOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::SingleGateRNNGradientOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::mps::SingleGateRNNGradientOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::SingleGateRNNGradientOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SingleGateRNNGradientOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SingleGateRNNGradientOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::SingleGateRNNGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.singlegate_rnn_gradient";
    v25[1] = 27;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  void *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>::getDefaultDialect;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      unint64_t v14 = 72;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[346], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>::getAsmResultNames(uint64_t a1, uint64_t a2, void (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5 = a2;
  return mlir::mps::SingleGateRNNGradientOp::getAsmResultNames(&v5, a3, a4);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNGradientOp>::getDefaultDialect()
{
  return &byte_211F4AA5D;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::foldHook<mlir::mps::SingleGateRNNGradientOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::foldHook<mlir::mps::SingleGateRNNGradientOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    uint64_t v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  }
  else {
    uint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v17 = v8;
  v18[0] = 0;
  char v19 = 0;
  long long v13 = *(_OWORD *)(v10 + 16);
  long long v20 = *(_OWORD *)v10;
  long long v21 = v13;
  uint64_t v22 = *(void *)(v10 + 32);
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v17);
    if (v19) {
      char v19 = 0;
    }
    mlir::OperationName::OperationName(v18, "mps.singlegate_rnn_gradient", 27, Context);
    char v19 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v16;
  if (result) {
    return mlir::RegionBranchOpInterface::getEntrySuccessorRegions(v26, v24, v25, a4);
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v187 = a1;
    v1 = (void *)&unk_267771000;
    int v34 = v33;
    a1 = v187;
    if (v34)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v199 = 83;
      unint64_t v35 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v35) {
        unint64_t v36 = v35;
      }
      else {
        unint64_t v36 = v199;
      }
      int v37 = &v198[v36];
      unint64_t v38 = v199 - v36;
      if (v199 - v36 >= 0x12) {
        uint64_t v39 = 18;
      }
      else {
        uint64_t v39 = v199 - v36;
      }
      unint64_t v40 = v38 - v39;
      if (v40 >= v40 - 1) {
        uint64_t v41 = v40 - 1;
      }
      else {
        uint64_t v41 = v40;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v37[v39], v41);
      v1 = (void *)&unk_267771000;
      a1 = v187;
    }
  }
  uint64_t v2 = v1[23];
  char v3 = &unk_267771000;
  {
    uint64_t v177 = v2;
    uint64_t v188 = a1;
    char v3 = (void *)&unk_267771000;
    int v43 = v42;
    uint64_t v2 = v177;
    a1 = v188;
    if (v43)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNResults<2>::Impl<Empty>]";
      unint64_t v199 = 96;
      unint64_t v44 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v44) {
        unint64_t v45 = v44;
      }
      else {
        unint64_t v45 = v199;
      }
      int v46 = &v198[v45];
      unint64_t v47 = v199 - v45;
      if (v199 - v45 >= 0x12) {
        uint64_t v48 = 18;
      }
      else {
        uint64_t v48 = v199 - v45;
      }
      unint64_t v49 = v47 - v48;
      if (v49 >= v49 - 1) {
        uint64_t v50 = v49 - 1;
      }
      else {
        uint64_t v50 = v49;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNResults<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNResults<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v46[v48], v50);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v177;
      a1 = v188;
    }
  }
  uint64_t v4 = v3[439];
  uint64_t v5 = &unk_267770000;
  {
    uint64_t v178 = v2;
    uint64_t v189 = a1;
    uint64_t v168 = v4;
    uint64_t v5 = (void *)&unk_267770000;
    uint64_t v4 = v168;
    uint64_t v2 = v178;
    int v52 = v51;
    a1 = v189;
    if (v52)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v199 = 86;
      unint64_t v53 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v53) {
        unint64_t v54 = v53;
      }
      else {
        unint64_t v54 = v199;
      }
      int v55 = &v198[v54];
      unint64_t v56 = v199 - v54;
      if (v199 - v54 >= 0x12) {
        uint64_t v57 = 18;
      }
      else {
        uint64_t v57 = v199 - v54;
      }
      unint64_t v58 = v56 - v57;
      if (v58 >= v58 - 1) {
        uint64_t v59 = v58 - 1;
      }
      else {
        uint64_t v59 = v58;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v55[v57], v59);
      uint64_t v5 = (void *)&unk_267770000;
      uint64_t v4 = v168;
      uint64_t v2 = v178;
      a1 = v189;
    }
  }
  uint64_t v6 = v5[431];
  uint64_t v7 = &unk_267771000;
  {
    uint64_t v179 = v2;
    uint64_t v190 = a1;
    uint64_t v169 = v4;
    uint64_t v160 = v6;
    uint64_t v7 = (void *)&unk_267771000;
    uint64_t v6 = v160;
    uint64_t v4 = v169;
    uint64_t v2 = v179;
    int v61 = v60;
    a1 = v190;
    if (v61)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<3>::Impl<Empty>]";
      unint64_t v199 = 97;
      unint64_t v62 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v62) {
        unint64_t v63 = v62;
      }
      else {
        unint64_t v63 = v199;
      }
      int v64 = &v198[v63];
      unint64_t v65 = v199 - v63;
      if (v199 - v63 >= 0x12) {
        uint64_t v66 = 18;
      }
      else {
        uint64_t v66 = v199 - v63;
      }
      unint64_t v67 = v65 - v66;
      if (v67 >= v67 - 1) {
        uint64_t v68 = v67 - 1;
      }
      else {
        uint64_t v68 = v67;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<3u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v64[v66], v68);
      uint64_t v7 = (void *)&unk_267771000;
      uint64_t v6 = v160;
      uint64_t v4 = v169;
      uint64_t v2 = v179;
      a1 = v190;
    }
  }
  uint64_t v8 = v7[447];
  unint64_t v9 = &unk_267772000;
  {
    uint64_t v180 = v2;
    uint64_t v191 = a1;
    uint64_t v170 = v4;
    uint64_t v153 = v8;
    uint64_t v161 = v6;
    unint64_t v9 = (void *)&unk_267772000;
    uint64_t v8 = v153;
    uint64_t v6 = v161;
    uint64_t v4 = v170;
    uint64_t v2 = v180;
    int v70 = v69;
    a1 = v191;
    if (v70)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AttrSizedOperandSegments<Empty>]";
      unint64_t v199 = 96;
      unint64_t v71 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v71) {
        unint64_t v72 = v71;
      }
      else {
        unint64_t v72 = v199;
      }
      int v73 = &v198[v72];
      unint64_t v74 = v199 - v72;
      if (v199 - v72 >= 0x12) {
        uint64_t v75 = 18;
      }
      else {
        uint64_t v75 = v199 - v72;
      }
      unint64_t v76 = v74 - v75;
      if (v76 >= v76 - 1) {
        uint64_t v77 = v76 - 1;
      }
      else {
        uint64_t v77 = v76;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v73[v75], v77);
      unint64_t v9 = (void *)&unk_267772000;
      uint64_t v8 = v153;
      uint64_t v6 = v161;
      uint64_t v4 = v170;
      uint64_t v2 = v180;
      a1 = v191;
    }
  }
  uint64_t v10 = v9[47];
  unint64_t v11 = &unk_267770000;
  {
    uint64_t v181 = v2;
    uint64_t v192 = a1;
    uint64_t v171 = v4;
    uint64_t v154 = v8;
    uint64_t v162 = v6;
    uint64_t v147 = v10;
    unint64_t v11 = (void *)&unk_267770000;
    uint64_t v10 = v147;
    uint64_t v8 = v154;
    uint64_t v6 = v162;
    uint64_t v4 = v171;
    uint64_t v2 = v181;
    int v79 = v78;
    a1 = v192;
    if (v79)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v199 = 84;
      unint64_t v80 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v80) {
        unint64_t v81 = v80;
      }
      else {
        unint64_t v81 = v199;
      }
      int v82 = &v198[v81];
      unint64_t v83 = v199 - v81;
      if (v199 - v81 >= 0x12) {
        uint64_t v84 = 18;
      }
      else {
        uint64_t v84 = v199 - v81;
      }
      unint64_t v85 = v83 - v84;
      if (v85 >= v85 - 1) {
        uint64_t v86 = v85 - 1;
      }
      else {
        uint64_t v86 = v85;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v82[v84], v86);
      unint64_t v11 = (void *)&unk_267770000;
      uint64_t v10 = v147;
      uint64_t v8 = v154;
      uint64_t v6 = v162;
      uint64_t v4 = v171;
      uint64_t v2 = v181;
      a1 = v192;
    }
  }
  uint64_t v12 = v11[435];
  long long v13 = &unk_267771000;
  {
    uint64_t v182 = v2;
    uint64_t v193 = a1;
    uint64_t v172 = v4;
    uint64_t v155 = v8;
    uint64_t v163 = v6;
    uint64_t v142 = v12;
    uint64_t v148 = v10;
    long long v13 = (void *)&unk_267771000;
    uint64_t v12 = v142;
    uint64_t v10 = v148;
    uint64_t v8 = v155;
    uint64_t v6 = v163;
    uint64_t v4 = v172;
    uint64_t v2 = v182;
    int v88 = v87;
    a1 = v193;
    if (v88)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v199 = 89;
      unint64_t v89 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v89) {
        unint64_t v90 = v89;
      }
      else {
        unint64_t v90 = v199;
      }
      int v91 = &v198[v90];
      unint64_t v92 = v199 - v90;
      if (v199 - v90 >= 0x12) {
        uint64_t v93 = 18;
      }
      else {
        uint64_t v93 = v199 - v90;
      }
      unint64_t v94 = v92 - v93;
      if (v94 >= v94 - 1) {
        uint64_t v95 = v94 - 1;
      }
      else {
        uint64_t v95 = v94;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v91[v93], v95);
      long long v13 = (void *)&unk_267771000;
      uint64_t v12 = v142;
      uint64_t v10 = v148;
      uint64_t v8 = v155;
      uint64_t v6 = v163;
      uint64_t v4 = v172;
      uint64_t v2 = v182;
      a1 = v193;
    }
  }
  uint64_t v14 = v13[320];
  uint64_t v15 = &unk_267771000;
  {
    uint64_t v183 = v2;
    uint64_t v194 = a1;
    uint64_t v173 = v4;
    uint64_t v156 = v8;
    uint64_t v164 = v6;
    uint64_t v143 = v12;
    uint64_t v149 = v10;
    uint64_t v138 = v14;
    uint64_t v15 = (void *)&unk_267771000;
    uint64_t v14 = v138;
    uint64_t v12 = v143;
    uint64_t v10 = v149;
    uint64_t v8 = v156;
    uint64_t v6 = v164;
    uint64_t v4 = v173;
    uint64_t v2 = v183;
    int v97 = v96;
    a1 = v194;
    if (v97)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v199 = 93;
      unint64_t v98 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v98) {
        unint64_t v99 = v98;
      }
      else {
        unint64_t v99 = v199;
      }
      int v100 = &v198[v99];
      unint64_t v101 = v199 - v99;
      if (v199 - v99 >= 0x12) {
        uint64_t v102 = 18;
      }
      else {
        uint64_t v102 = v199 - v99;
      }
      unint64_t v103 = v101 - v102;
      if (v103 >= v103 - 1) {
        uint64_t v104 = v103 - 1;
      }
      else {
        uint64_t v104 = v103;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v100[v102], v104);
      uint64_t v15 = (void *)&unk_267771000;
      uint64_t v14 = v138;
      uint64_t v12 = v143;
      uint64_t v10 = v149;
      uint64_t v8 = v156;
      uint64_t v6 = v164;
      uint64_t v4 = v173;
      uint64_t v2 = v183;
      a1 = v194;
    }
  }
  uint64_t v16 = v15[31];
  uint64_t v17 = &unk_267771000;
  {
    uint64_t v184 = v2;
    uint64_t v195 = a1;
    uint64_t v174 = v4;
    uint64_t v157 = v8;
    uint64_t v165 = v6;
    uint64_t v144 = v12;
    uint64_t v150 = v10;
    uint64_t v135 = v16;
    uint64_t v139 = v14;
    uint64_t v17 = (void *)&unk_267771000;
    uint64_t v16 = v135;
    uint64_t v14 = v139;
    uint64_t v12 = v144;
    uint64_t v10 = v150;
    uint64_t v8 = v157;
    uint64_t v6 = v165;
    uint64_t v4 = v174;
    uint64_t v2 = v184;
    int v106 = v105;
    a1 = v195;
    if (v106)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v199 = 90;
      unint64_t v107 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v107) {
        unint64_t v108 = v107;
      }
      else {
        unint64_t v108 = v199;
      }
      int v109 = &v198[v108];
      unint64_t v110 = v199 - v108;
      if (v199 - v108 >= 0x12) {
        uint64_t v111 = 18;
      }
      else {
        uint64_t v111 = v199 - v108;
      }
      unint64_t v112 = v110 - v111;
      if (v112 >= v112 - 1) {
        uint64_t v113 = v112 - 1;
      }
      else {
        uint64_t v113 = v112;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v109[v111], v113);
      uint64_t v17 = (void *)&unk_267771000;
      uint64_t v16 = v135;
      uint64_t v14 = v139;
      uint64_t v12 = v144;
      uint64_t v10 = v150;
      uint64_t v8 = v157;
      uint64_t v6 = v165;
      uint64_t v4 = v174;
      uint64_t v2 = v184;
      a1 = v195;
    }
  }
  uint64_t v18 = v17[37];
  char v19 = &unk_267771000;
  {
    uint64_t v185 = v2;
    uint64_t v196 = a1;
    uint64_t v175 = v4;
    uint64_t v158 = v8;
    uint64_t v166 = v6;
    uint64_t v145 = v12;
    uint64_t v151 = v10;
    uint64_t v136 = v16;
    uint64_t v140 = v14;
    uint64_t v133 = v18;
    char v19 = (void *)&unk_267771000;
    uint64_t v18 = v133;
    uint64_t v16 = v136;
    uint64_t v14 = v140;
    uint64_t v12 = v145;
    uint64_t v10 = v151;
    uint64_t v8 = v158;
    uint64_t v6 = v166;
    uint64_t v4 = v175;
    uint64_t v2 = v185;
    int v115 = v114;
    a1 = v196;
    if (v115)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      unint64_t v199 = 100;
      unint64_t v116 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v116) {
        unint64_t v117 = v116;
      }
      else {
        unint64_t v117 = v199;
      }
      int v118 = &v198[v117];
      unint64_t v119 = v199 - v117;
      if (v199 - v117 >= 0x12) {
        uint64_t v120 = 18;
      }
      else {
        uint64_t v120 = v199 - v117;
      }
      unint64_t v121 = v119 - v120;
      if (v121 >= v121 - 1) {
        uint64_t v122 = v121 - 1;
      }
      else {
        uint64_t v122 = v121;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v118[v120], v122);
      char v19 = (void *)&unk_267771000;
      uint64_t v18 = v133;
      uint64_t v16 = v136;
      uint64_t v14 = v140;
      uint64_t v12 = v145;
      uint64_t v10 = v151;
      uint64_t v8 = v158;
      uint64_t v6 = v166;
      uint64_t v4 = v175;
      uint64_t v2 = v185;
      a1 = v196;
    }
  }
  uint64_t v20 = v19[41];
  long long v21 = &unk_267771000;
  {
    uint64_t v186 = v2;
    uint64_t v197 = a1;
    uint64_t v176 = v4;
    uint64_t v159 = v8;
    uint64_t v167 = v6;
    uint64_t v146 = v12;
    uint64_t v152 = v10;
    uint64_t v137 = v16;
    uint64_t v141 = v14;
    uint64_t v132 = v20;
    uint64_t v134 = v18;
    long long v21 = (void *)&unk_267771000;
    uint64_t v20 = v132;
    uint64_t v18 = v134;
    uint64_t v16 = v137;
    uint64_t v14 = v141;
    uint64_t v12 = v146;
    uint64_t v10 = v152;
    uint64_t v8 = v159;
    uint64_t v6 = v167;
    uint64_t v4 = v176;
    uint64_t v2 = v186;
    int v124 = v123;
    a1 = v197;
    if (v124)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      unint64_t v199 = 86;
      unint64_t v125 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v125) {
        unint64_t v126 = v125;
      }
      else {
        unint64_t v126 = v199;
      }
      int v127 = &v198[v126];
      unint64_t v128 = v199 - v126;
      if (v199 - v126 >= 0x12) {
        uint64_t v129 = 18;
      }
      else {
        uint64_t v129 = v199 - v126;
      }
      unint64_t v130 = v128 - v129;
      if (v130 >= v130 - 1) {
        uint64_t v131 = v130 - 1;
      }
      else {
        uint64_t v131 = v130;
      }
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v127[v129], v131);
      long long v21 = (void *)&unk_267771000;
      uint64_t v20 = v132;
      uint64_t v18 = v134;
      uint64_t v16 = v137;
      uint64_t v14 = v141;
      uint64_t v12 = v146;
      uint64_t v10 = v152;
      uint64_t v8 = v159;
      uint64_t v6 = v167;
      uint64_t v4 = v176;
      uint64_t v2 = v186;
      a1 = v197;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v21[350] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::SingleGateRNNGradientOp>,mlir::OpTrait::AtLeastNResults<2u>::Impl<mlir::mps::SingleGateRNNGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::SingleGateRNNGradientOp>,mlir::OpTrait::AtLeastNOperands<3u>::Impl<mlir::mps::SingleGateRNNGradientOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::mps::SingleGateRNNGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::SingleGateRNNGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::SingleGateRNNGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::SingleGateRNNGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::SingleGateRNNGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::SingleGateRNNGradientOp>,mlir::OpAsmOpInterface::Trait<mlir::mps::SingleGateRNNGradientOp>>(a1, a2))return 0; {
  uint64_t v4 = a1;
  }
  return mlir::mps::SingleGateRNNGradientOp::verify((mlir::mps::SingleGateRNNGradientOp *)&v4) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::SingleGateRNNGradientOp>,mlir::OpTrait::AtLeastNResults<2u>::Impl<mlir::mps::SingleGateRNNGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::SingleGateRNNGradientOp>,mlir::OpTrait::AtLeastNOperands<3u>::Impl<mlir::mps::SingleGateRNNGradientOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::mps::SingleGateRNNGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::SingleGateRNNGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::SingleGateRNNGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::SingleGateRNNGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::SingleGateRNNGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::SingleGateRNNGradientOp>,mlir::OpAsmOpInterface::Trait<mlir::mps::SingleGateRNNGradientOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyAtLeastNResults(a1, (mlir::Operation *)2)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v3)
    || !mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)3)
    || !mlir::OpTrait::impl::verifyOperandSizeAttr((uint64_t)a1, "operandSegmentSizes", 0x13uLL))
  {
    return 0;
  }
  uint64_t v5 = a1;
  return mlir::mps::SingleGateRNNGradientOp::verifyInvariantsImpl((mlir::mps::SingleGateRNNGradientOp *)&v5) != 0;
}

BOOL mlir::Op<mlir::mps::SingleGateRNNGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<3u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.singlegate_rnn", 18, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SingleGateRNNOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C368478;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, size_t a4)
{
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::mps::SingleGateRNNOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::SingleGateRNNOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }
  if (*v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"activation", 10, *v6);
  }
  uint64_t v7 = v6[1];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"training", 8, v7);
  }
  uint64_t v8 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, (uint64_t)(v6 + 2), 4);

  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  BOOL result = 0;
  if (!v9
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v9, (void **)"activation", (const char *)0xA, a4, a5))
  {
    uint64_t v10 = mlir::NamedAttrList::get(a3, *(void *)(*(void *)(a2 + 96) + 8));
    if (!v10
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v10, (void **)"training", (const char *)8, a4, a5))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::getOpPropertyByteSize()
{
  return 32;
}

double mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::initProperties(uint64_t a1, uint64_t a2, long long *a3, long long *a4)
{
  if (a4)
  {
    long long v4 = *a4;
    long long v5 = a4[1];
    *a3 = *a4;
    a3[1] = v5;
  }
  else
  {
    *(void *)&long long v4 = 0;
    *a3 = 0u;
    a3[1] = 0u;
  }
  return *(double *)&v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::SingleGateRNNOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::mps::SingleGateRNNOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::copyProperties(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  long long v4 = *(_OWORD *)(a3 + 16);
  *a2 = *(_OWORD *)a3;
  a2[1] = v4;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  if (*a3 != *a2) {
    return 0;
  }
  if (a3[1] != a2[1]) {
    return 0;
  }
  return a3[2] == a2[2] && a3[3] == a2[3];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::SingleGateRNNOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::SingleGateRNNOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::mps::SingleGateRNNOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::SingleGateRNNOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SingleGateRNNOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SingleGateRNNOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::SingleGateRNNOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.singlegate_rnn";
    v25[1] = 18;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  void *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>::getDefaultDialect;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      unint64_t v14 = 72;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[346], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>::getAsmResultNames(uint64_t a1, uint64_t a2, void (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v6 = a2 - 16;
  if (*(_DWORD *)(a2 + 36)) {
    uint64_t v7 = a2 - 16;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0);
  a3(a4, NextResultAtOffset, "result", 6);
  int v9 = *(_DWORD *)(a2 + 36);
  if (v9) {
    uint64_t v10 = v6;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t result = mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 1);
  if (v9 != 1)
  {
    uint64_t v12 = mlir::detail::OpResultImpl::getNextResultAtOffset(result, 0);
    return ((uint64_t (*)(uint64_t, uint64_t, const char *, uint64_t))a3)(a4, v12, "training_state", 14);
  }
  return result;
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SingleGateRNNOp>::getDefaultDialect()
{
  return &byte_211F4AA5D;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::foldHook<mlir::mps::SingleGateRNNOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::foldHook<mlir::mps::SingleGateRNNOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    uint64_t v10 = (long long *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  }
  else {
    uint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v25, v12, v11);
  uint64_t v17 = v8;
  v18[0] = 0;
  char v19 = 0;
  long long v13 = v10[1];
  long long v20 = *v10;
  long long v21 = v13;
  long long v22 = *(_OWORD *)v25;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v17);
    if (v19) {
      char v19 = 0;
    }
    mlir::OperationName::OperationName(v18, "mps.singlegate_rnn", 18, Context);
    char v19 = 1;
  }
  uint64_t v23 = a2;
  uint64_t v24 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v25[0] = result;
  v25[1] = v16;
  if (result) {
    return mlir::RegionBranchOpInterface::getEntrySuccessorRegions(v25, v23, v24, a4);
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::SingleGateRNNOp>,mlir::OpTrait::AtLeastNResults<1u>::Impl<mlir::mps::SingleGateRNNOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::SingleGateRNNOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::mps::SingleGateRNNOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::mps::SingleGateRNNOp>,mlir::OpTrait::OpInvariants<mlir::mps::SingleGateRNNOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::SingleGateRNNOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::SingleGateRNNOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::SingleGateRNNOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::SingleGateRNNOp>,mlir::OpAsmOpInterface::Trait<mlir::mps::SingleGateRNNOp>>(a1, a2))return 0; {
  unint64_t v11 = a1;
  }
  return mlir::mps::SingleGateRNNOp::verify((mlir::mps::SingleGateRNNOp *)&v11, v3, v4, v5, v6, v7, v8, v9) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::SingleGateRNNOp>,mlir::OpTrait::AtLeastNResults<1u>::Impl<mlir::mps::SingleGateRNNOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::SingleGateRNNOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::mps::SingleGateRNNOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::mps::SingleGateRNNOp>,mlir::OpTrait::OpInvariants<mlir::mps::SingleGateRNNOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::SingleGateRNNOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::SingleGateRNNOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::SingleGateRNNOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::SingleGateRNNOp>,mlir::OpAsmOpInterface::Trait<mlir::mps::SingleGateRNNOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyAtLeastNResults(a1, (mlir::Operation *)1)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v3)
    || !mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)2)
    || !mlir::OpTrait::impl::verifyOperandSizeAttr((uint64_t)a1, "operandSegmentSizes", 0x13uLL))
  {
    return 0;
  }
  uint64_t v5 = a1;
  return mlir::mps::SingleGateRNNOp::verifyInvariantsImpl((mlir::mps::SingleGateRNNOp *)&v5) != 0;
}

BOOL mlir::Op<mlir::mps::SingleGateRNNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SinhOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SinhOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SinhOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SinhOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.sinh", 8, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SinhOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36CD20;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinhOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SinhOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinhOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SinhOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SinhOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SinhOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinhOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinhOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinhOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinhOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SinhOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinhOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinhOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinhOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    long long v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      unint64_t v11 = v32;
      uint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          unint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinhOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinhOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SinhOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SinhOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SinhOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SinhOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SinhOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SinhOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SinhOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SinhOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SinhOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SinhOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SinhOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SinhOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SinhOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SinhOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SinhOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  uint64_t v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  uint64_t v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  uint64_t v24 = "mps.sinh";
  uint64_t v25 = 8;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SinhOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SinhOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::SinhOpGenericAdaptorBase::SinhOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ACosOp>,mlir::OpTrait::OneResult<mlir::mps::ACosOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ACosOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ACosOp>,mlir::OpTrait::OneOperand<mlir::mps::ACosOp>,mlir::OpTrait::OpInvariants<mlir::mps::ACosOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ACosOp>,mlir::OpTrait::Stitchable<mlir::mps::ACosOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ACosOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ACosOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::SinhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SizeOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SizeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SizeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SizeOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.size", 8, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SizeOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36CDE8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SizeOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SizeOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SizeOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SizeOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SizeOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SizeOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SizeOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SizeOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SizeOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SizeOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SizeOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SizeOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SizeOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SizeOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    long long v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SizeOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SizeOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SizeOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SizeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SizeOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SizeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SizeOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SizeOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SizeOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SizeOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::RankOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SizeOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SizeOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SizeOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SizeOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  long long v22 = v24;
  uint64_t v23 = 0x400000000;
  if (mlir::mps::RankOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, v18, v19, (uint64_t)&v22))
  {
    mlir::ValueRange::ValueRange(v21, (uint64_t)v22, v23);
    mlir::ValueRange::ValueRange(v20, *(void *)a11, *(unsigned int *)(a11 + 8));
    v25[0] = &unk_26C380E60;
    unsigned int v26 = v25;
    int v28 = v27;
    v27[0] = &unk_26C380E60;
    if (v28 == v27)
    {
      (*(void (**)(void *))(v27[0] + 32))(v27);
      unint64_t v14 = v26;
      if (v26 != v25) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v28) {
        (*(void (**)(void *))(*v28 + 40))(v28);
      }
      unint64_t v14 = v26;
      if (v26 != v25)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v22;
          if (v22 == v24) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v25[0] + 32))(v25);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v27[0] = "mps.size";
    v27[1] = 8;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v27, "' op inferred type(s) ", (uint64_t)&v22, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v22;
    if (v22 == v24) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v22;
  if (v22 != v24) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SizeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SizeOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SizeOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SizeOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SizeOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::SizeOpGenericAdaptorBase::SizeOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::SizeOp>,mlir::OpTrait::OneResult<mlir::mps::SizeOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::SizeOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::SizeOp>,mlir::OpTrait::OneOperand<mlir::mps::SizeOp>,mlir::OpTrait::OpInvariants<mlir::mps::SizeOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::SizeOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::SizeOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::SizeOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::SizeOp>,mlir::OpTrait::OneResult<mlir::mps::SizeOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::SizeOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::SizeOp>,mlir::OpTrait::OneOperand<mlir::mps::SizeOp>,mlir::OpTrait::OpInvariants<mlir::mps::SizeOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::SizeOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::SizeOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::SizeOp>>(uint64_t a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    || !mlir::OpTrait::impl::verifyOneOperand((mlir::OpTrait::impl *)a1, v5)
    || !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(a1, *(void *)(*(void *)(*(void *)(a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (void **)"operand", (void **)7, 0))
  {
    return 0;
  }
  if (*(_DWORD *)(a1 + 36)) {
    uint64_t v6 = a1 - 16;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(a1, (void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (void **)"result", 6, 0) != 0;
}

BOOL mlir::Op<mlir::mps::SizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SliceOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SliceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SliceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SliceOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.slice", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SliceOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36DD88;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SliceOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SliceOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SliceOp>::foldHook(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                      + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SliceOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SliceOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SliceOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SliceOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SliceOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SliceOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SliceOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SliceOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SliceOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SliceOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SliceOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    long long v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SliceOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SliceOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SliceOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SliceOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SliceOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SliceOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SliceOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SliceOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SliceOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SliceOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, void *a4, unint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::SliceOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SliceOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, void *a4, unint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SliceOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SliceOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SliceOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, void *a4, unint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  uint64_t v27 = *MEMORY[0x263EF8340];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::SliceOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.slice";
    v25[1] = 9;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SliceOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SliceOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SliceOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SliceOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SliceOp>(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::SliceOpGenericAdaptorBase::SliceOpGenericAdaptorBase((uint64_t)v14, a1);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)a1);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if (a1 - 4 != (unsigned int *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)4)) {
    return 0;
  }
  unint64_t v6 = a1;
  if (!mlir::mps::SliceOp::verifyInvariantsImpl((mlir::mps::SliceOp *)&v6)) {
    return 0;
  }
  unint64_t v6 = a1;
  return mlir::mps::SliceOp::verify((mlir::mps::SliceOp *)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::SliceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SoftmaxOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SoftmaxOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftmaxOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SoftmaxOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.softmax", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SoftmaxOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36F688;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftmaxOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SoftmaxOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftmaxOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SoftmaxOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SoftmaxOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SoftmaxOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftmaxOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftmaxOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftmaxOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftmaxOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SoftmaxOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftmaxOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftmaxOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftmaxOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    long long v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftmaxOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftmaxOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftmaxOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SoftmaxOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SoftmaxOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftmaxOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftmaxOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftmaxOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftmaxOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftmaxOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  if (a5)
  {
    unint64_t v11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    uint64_t v12 = *(unsigned int *)(a11 + 8);
    if (v12 >= *(_DWORD *)(a11 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v12 + 1, 8);
      LODWORD(v12) = *(_DWORD *)(a11 + 8);
    }
    *(void *)(*(void *)a11 + 8 * v12) = v11;
    ++*(_DWORD *)(a11 + 8);
    return 1;
  }
  else
  {
    return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands");
  }
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftmaxOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SoftmaxOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftmaxOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SoftmaxOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  int v21 = v23;
  uint64_t v22 = 0x400000000;
  unsigned int v26 = a4;
  uint64_t v27 = a5;
  if (a5)
  {
    *((void *)v21 + v22) = *(void *)(mlir::ValueRange::dereference_iterator(&v26, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    unsigned int v13 = v22 + 1;
    LODWORD(v22) = v22 + 1;
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands"))
    {
      uint64_t v16 = 0;
      uint64_t v17 = v21;
      if (v21 == v23) {
        return v16;
      }
      goto LABEL_17;
    }
    unsigned int v13 = v22;
  }
  mlir::ValueRange::ValueRange(v20, (uint64_t)v21, v13);
  mlir::ValueRange::ValueRange(v19, *(void *)a11, *(unsigned int *)(a11 + 8));
  v24[0] = &unk_26C380E60;
  uint64_t v25 = v24;
  int v28 = &v26;
  unsigned int v26 = (const char *)&unk_26C380E60;
  if (v28 == &v26)
  {
    (*((void (**)(const char **))v26 + 4))(&v26);
    uint64_t v15 = v25;
    if (v25 != v24) {
      goto LABEL_9;
    }
LABEL_15:
    (*(void (**)(void *))(v24[0] + 32))(v24);
    if (v14) {
      goto LABEL_12;
    }
    goto LABEL_16;
  }
  if (v28) {
    (*((void (**)(const char **))*v28 + 5))(v28);
  }
  uint64_t v15 = v25;
  if (v25 == v24) {
    goto LABEL_15;
  }
LABEL_9:
  if (v15) {
    (*(void (**)(void *))(*v15 + 40))(v15);
  }
  if (v14)
  {
LABEL_12:
    uint64_t v16 = 1;
    uint64_t v17 = v21;
    if (v21 == v23) {
      return v16;
    }
    goto LABEL_17;
  }
LABEL_16:
  unsigned int v26 = "mps.softmax";
  uint64_t v27 = 11;
  uint64_t v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v26, "' op inferred type(s) ", (uint64_t)&v21, " are incompatible with return type(s) of operation ", a11);
  uint64_t v17 = v21;
  if (v21 != v23) {
LABEL_17:
  }
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SoftmaxOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SoftmaxOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unsigned int v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SoftmaxOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SoftmaxOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SoftmaxOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::SoftmaxOpGenericAdaptorBase::SoftmaxOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2))
  {
    return 0;
  }
  unint64_t v6 = a1;
  return mlir::mps::SoftmaxOp::verifyInvariantsImpl((mlir::mps::SoftmaxOp *)&v6);
}

BOOL mlir::Op<mlir::mps::SoftmaxOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SoftplusOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SoftplusOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.softplus", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SoftplusOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C3650E8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SoftplusOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SoftplusOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SoftplusOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SoftplusOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SoftplusOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SoftplusOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SoftplusOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SoftplusOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SoftplusOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SoftplusOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  uint64_t v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  uint64_t v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  uint64_t v24 = "mps.softplus";
  uint64_t v25 = 12;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SoftplusOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SoftplusOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::SoftplusOpGenericAdaptorBase::SoftplusOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::DegammaOp>,mlir::OpTrait::OneResult<mlir::mps::DegammaOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::DegammaOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::DegammaOp>,mlir::OpTrait::OneOperand<mlir::mps::DegammaOp>,mlir::OpTrait::OpInvariants<mlir::mps::DegammaOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::DegammaOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::DegammaOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::DegammaOp>,mlir::OpTrait::Stitchable<mlir::mps::DegammaOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::DegammaOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::DegammaOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::SoftplusOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SoftplusParametricOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::UpgraderInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.softplus_parametric", 23, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SoftplusParametricOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36A480;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusParametricOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SoftplusParametricOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusParametricOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SoftplusParametricOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SoftplusParametricOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  unint64_t v7 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v2 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v6, a2);
  char v3 = v7;
  if (v7 >= 8)
  {
    if ((v7 & 4) != 0)
    {
      if ((v7 & 2) != 0) {
        uint64_t v4 = v6;
      }
      else {
        uint64_t v4 = (llvm **)v6[0];
      }
      (*(void (**)(llvm **))((v7 & 0xFFFFFFFFFFFFFFF8) + 16))(v4);
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer(v6[0], v6[1]);
    }
  }
  return v2;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SoftplusParametricOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusParametricOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  unint64_t v9 = (unint64_t)&llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
     + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  char v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
    {
      if ((v9 & 2) != 0) {
        unint64_t v7 = v8;
      }
      else {
        unint64_t v7 = (llvm **)v8[0];
      }
      uint64_t result = (*(uint64_t (**)(llvm **))((v9 & 0xFFFFFFFFFFFFFFF8) + 16))(v7);
    }
    if ((v6 & 2) == 0) {
      llvm::deallocate_buffer(v8[0], v8[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusParametricOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusParametricOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusParametricOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SoftplusParametricOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusParametricOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusParametricOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusParametricOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    uint64_t v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    char v13 = v29;
    if (v29)
    {
      unint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusParametricOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusParametricOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftplusParametricOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>::downgradeToVersion;
  char v3 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  {
    unint64_t v12 = v2;
    char v3 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DowngraderInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::DowngraderInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[420], v2);
}

void mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>::downgradeToVersion(uint64_t a1@<X1>, void *a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v4 = a1;
  mlir::mps::SoftplusParametricOp::downgradeToVersion(&v4, a2, a3, a4);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::UpgraderInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::UpgraderInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>::upgradeFromVersion;
  char v3 = &unk_267775000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267775000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::UpgraderInterface]";
      unint64_t v14 = 73;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::UpgraderInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267775000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[16], v2);
}

void mlir::detail::UpgraderInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>::upgradeFromVersion(uint64_t a1@<X1>, mlir::OpBuilder *a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v4 = a1;
  mlir::mps::SoftplusParametricOp::upgradeFromVersion(&v4, a2, a3, a4);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  if (a5)
  {
    unint64_t v11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    uint64_t v12 = *(unsigned int *)(a11 + 8);
    if (v12 >= *(_DWORD *)(a11 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v12 + 1, 8);
      LODWORD(v12) = *(_DWORD *)(a11 + 8);
    }
    *(void *)(*(void *)a11 + 8 * v12) = v11;
    ++*(_DWORD *)(a11 + 8);
    return 1;
  }
  else
  {
    return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands");
  }
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SoftplusParametricOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SoftplusParametricOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  int v21 = v23;
  uint64_t v22 = 0x400000000;
  unsigned int v26 = a4;
  uint64_t v27 = a5;
  if (a5)
  {
    *((void *)v21 + v22) = *(void *)(mlir::ValueRange::dereference_iterator(&v26, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    unsigned int v13 = v22 + 1;
    LODWORD(v22) = v22 + 1;
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands"))
    {
      uint64_t v16 = 0;
      uint64_t v17 = v21;
      if (v21 == v23) {
        return v16;
      }
      goto LABEL_17;
    }
    unsigned int v13 = v22;
  }
  mlir::ValueRange::ValueRange(v20, (uint64_t)v21, v13);
  mlir::ValueRange::ValueRange(v19, *(void *)a11, *(unsigned int *)(a11 + 8));
  v24[0] = &unk_26C380E60;
  uint64_t v25 = v24;
  int v28 = &v26;
  unsigned int v26 = (const char *)&unk_26C380E60;
  if (v28 == &v26)
  {
    (*((void (**)(const char **))v26 + 4))(&v26);
    uint64_t v15 = v25;
    if (v25 != v24) {
      goto LABEL_9;
    }
LABEL_15:
    (*(void (**)(void *))(v24[0] + 32))(v24);
    if (v14) {
      goto LABEL_12;
    }
    goto LABEL_16;
  }
  if (v28) {
    (*((void (**)(const char **))*v28 + 5))(v28);
  }
  uint64_t v15 = v25;
  if (v25 == v24) {
    goto LABEL_15;
  }
LABEL_9:
  if (v15) {
    (*(void (**)(void *))(*v15 + 40))(v15);
  }
  if (v14)
  {
LABEL_12:
    uint64_t v16 = 1;
    uint64_t v17 = v21;
    if (v21 == v23) {
      return v16;
    }
    goto LABEL_17;
  }
LABEL_16:
  unsigned int v26 = "mps.softplus_parametric";
  uint64_t v27 = 23;
  uint64_t v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v26, "' op inferred type(s) ", (uint64_t)&v21, " are incompatible with return type(s) of operation ", a11);
  uint64_t v17 = v21;
  if (v21 != v23) {
LABEL_17:
  }
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unsigned int v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SoftplusParametricOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SoftplusParametricOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SoftplusParametricOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::SoftplusParametricOpGenericAdaptorBase::SoftplusParametricOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v210 = a1;
    v1 = (void *)&unk_267771000;
    int v37 = v36;
    a1 = v210;
    if (v37)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v223 = 83;
      unint64_t v38 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v38) {
        unint64_t v39 = v38;
      }
      else {
        unint64_t v39 = v223;
      }
      unint64_t v40 = &v222[v39];
      unint64_t v41 = v223 - v39;
      if (v223 - v39 >= 0x12) {
        uint64_t v42 = 18;
      }
      else {
        uint64_t v42 = v223 - v39;
      }
      unint64_t v43 = v41 - v42;
      if (v43 >= v43 - 1) {
        uint64_t v44 = v43 - 1;
      }
      else {
        uint64_t v44 = v43;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      v1 = (void *)&unk_267771000;
      a1 = v210;
    }
  }
  uint64_t v2 = v1[23];
  char v3 = &unk_267771000;
  {
    uint64_t v199 = v2;
    uint64_t v211 = a1;
    char v3 = (void *)&unk_267771000;
    int v46 = v45;
    uint64_t v2 = v199;
    a1 = v211;
    if (v46)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v223 = 81;
      unint64_t v47 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v47) {
        unint64_t v48 = v47;
      }
      else {
        unint64_t v48 = v223;
      }
      unint64_t v49 = &v222[v48];
      unint64_t v50 = v223 - v48;
      if (v223 - v48 >= 0x12) {
        uint64_t v51 = 18;
      }
      else {
        uint64_t v51 = v223 - v48;
      }
      unint64_t v52 = v50 - v51;
      if (v52 >= v52 - 1) {
        uint64_t v53 = v52 - 1;
      }
      else {
        uint64_t v53 = v52;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v199;
      a1 = v211;
    }
  }
  uint64_t v4 = v3[25];
  unint64_t v5 = &unk_267771000;
  {
    uint64_t v200 = v2;
    uint64_t v212 = a1;
    uint64_t v189 = v4;
    unint64_t v5 = (void *)&unk_267771000;
    uint64_t v4 = v189;
    uint64_t v2 = v200;
    int v55 = v54;
    a1 = v212;
    if (v55)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      unint64_t v223 = 104;
      unint64_t v56 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v56) {
        unint64_t v57 = v56;
      }
      else {
        unint64_t v57 = v223;
      }
      unint64_t v58 = &v222[v57];
      unint64_t v59 = v223 - v57;
      if (v223 - v57 >= 0x12) {
        uint64_t v60 = 18;
      }
      else {
        uint64_t v60 = v223 - v57;
      }
      unint64_t v61 = v59 - v60;
      if (v61 >= v61 - 1) {
        uint64_t v62 = v61 - 1;
      }
      else {
        uint64_t v62 = v61;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      unint64_t v5 = (void *)&unk_267771000;
      uint64_t v4 = v189;
      uint64_t v2 = v200;
      a1 = v212;
    }
  }
  uint64_t v6 = v5[318];
  uint64_t v7 = &unk_267770000;
  {
    uint64_t v201 = v2;
    uint64_t v213 = a1;
    uint64_t v190 = v4;
    uint64_t v180 = v6;
    uint64_t v7 = (void *)&unk_267770000;
    uint64_t v6 = v180;
    uint64_t v4 = v190;
    uint64_t v2 = v201;
    int v64 = v63;
    a1 = v213;
    if (v64)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v223 = 86;
      unint64_t v65 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v65) {
        unint64_t v66 = v65;
      }
      else {
        unint64_t v66 = v223;
      }
      unint64_t v67 = &v222[v66];
      unint64_t v68 = v223 - v66;
      if (v223 - v66 >= 0x12) {
        uint64_t v69 = 18;
      }
      else {
        uint64_t v69 = v223 - v66;
      }
      unint64_t v70 = v68 - v69;
      if (v70 >= v70 - 1) {
        uint64_t v71 = v70 - 1;
      }
      else {
        uint64_t v71 = v70;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      uint64_t v7 = (void *)&unk_267770000;
      uint64_t v6 = v180;
      uint64_t v4 = v190;
      uint64_t v2 = v201;
      a1 = v213;
    }
  }
  uint64_t v8 = v7[431];
  uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  {
    uint64_t v202 = v2;
    uint64_t v214 = a1;
    uint64_t v191 = v4;
    uint64_t v172 = v8;
    uint64_t v181 = v6;
    uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    uint64_t v8 = v172;
    uint64_t v6 = v181;
    uint64_t v4 = v191;
    uint64_t v2 = v202;
    int v73 = v72;
    a1 = v214;
    if (v73)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<4>::Impl<Empty>]";
      unint64_t v223 = 90;
      unint64_t v74 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v74) {
        unint64_t v75 = v74;
      }
      else {
        unint64_t v75 = v223;
      }
      unint64_t v76 = &v222[v75];
      unint64_t v77 = v223 - v75;
      if (v223 - v75 >= 0x12) {
        uint64_t v78 = 18;
      }
      else {
        uint64_t v78 = v223 - v75;
      }
      unint64_t v79 = v77 - v78;
      if (v79 >= v79 - 1) {
        uint64_t v80 = v79 - 1;
      }
      else {
        uint64_t v80 = v79;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<4u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<4u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      uint64_t v8 = v172;
      uint64_t v6 = v181;
      uint64_t v4 = v191;
      uint64_t v2 = v202;
      a1 = v214;
    }
  }
  uint64_t v10 = v9[424];
  uint64_t v11 = &unk_267770000;
  {
    uint64_t v203 = v2;
    uint64_t v215 = a1;
    uint64_t v192 = v4;
    uint64_t v173 = v8;
    uint64_t v182 = v6;
    uint64_t v165 = v10;
    uint64_t v11 = (void *)&unk_267770000;
    uint64_t v10 = v165;
    uint64_t v8 = v173;
    uint64_t v6 = v182;
    uint64_t v4 = v192;
    uint64_t v2 = v203;
    int v82 = v81;
    a1 = v215;
    if (v82)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v223 = 84;
      unint64_t v83 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v83) {
        unint64_t v84 = v83;
      }
      else {
        unint64_t v84 = v223;
      }
      unint64_t v85 = &v222[v84];
      unint64_t v86 = v223 - v84;
      if (v223 - v84 >= 0x12) {
        uint64_t v87 = 18;
      }
      else {
        uint64_t v87 = v223 - v84;
      }
      unint64_t v88 = v86 - v87;
      if (v88 >= v88 - 1) {
        uint64_t v89 = v88 - 1;
      }
      else {
        uint64_t v89 = v88;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      uint64_t v11 = (void *)&unk_267770000;
      uint64_t v10 = v165;
      uint64_t v8 = v173;
      uint64_t v6 = v182;
      uint64_t v4 = v192;
      uint64_t v2 = v203;
      a1 = v215;
    }
  }
  uint64_t v12 = v11[435];
  unsigned int v13 = &unk_267771000;
  {
    uint64_t v204 = v2;
    uint64_t v216 = a1;
    uint64_t v193 = v4;
    uint64_t v174 = v8;
    uint64_t v183 = v6;
    uint64_t v159 = v12;
    uint64_t v166 = v10;
    unsigned int v13 = (void *)&unk_267771000;
    uint64_t v12 = v159;
    uint64_t v10 = v166;
    uint64_t v8 = v174;
    uint64_t v6 = v183;
    uint64_t v4 = v193;
    uint64_t v2 = v204;
    int v91 = v90;
    a1 = v216;
    if (v91)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v223 = 93;
      unint64_t v92 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v92) {
        unint64_t v93 = v92;
      }
      else {
        unint64_t v93 = v223;
      }
      unint64_t v94 = &v222[v93];
      unint64_t v95 = v223 - v93;
      if (v223 - v93 >= 0x12) {
        uint64_t v96 = 18;
      }
      else {
        uint64_t v96 = v223 - v93;
      }
      unint64_t v97 = v95 - v96;
      if (v97 >= v97 - 1) {
        uint64_t v98 = v97 - 1;
      }
      else {
        uint64_t v98 = v97;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      unsigned int v13 = (void *)&unk_267771000;
      uint64_t v12 = v159;
      uint64_t v10 = v166;
      uint64_t v8 = v174;
      uint64_t v6 = v183;
      uint64_t v4 = v193;
      uint64_t v2 = v204;
      a1 = v216;
    }
  }
  uint64_t v14 = v13[31];
  uint64_t v15 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  {
    uint64_t v205 = v2;
    uint64_t v217 = a1;
    uint64_t v194 = v4;
    uint64_t v175 = v8;
    uint64_t v184 = v6;
    uint64_t v160 = v12;
    uint64_t v167 = v10;
    uint64_t v154 = v14;
    uint64_t v15 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    uint64_t v14 = v154;
    uint64_t v12 = v160;
    uint64_t v10 = v167;
    uint64_t v8 = v175;
    uint64_t v6 = v184;
    uint64_t v4 = v194;
    uint64_t v2 = v205;
    int v100 = v99;
    a1 = v217;
    if (v100)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Stitchable<Empty>]";
      unint64_t v223 = 82;
      unint64_t v101 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v101) {
        unint64_t v102 = v101;
      }
      else {
        unint64_t v102 = v223;
      }
      unint64_t v103 = &v222[v102];
      unint64_t v104 = v223 - v102;
      if (v223 - v102 >= 0x12) {
        uint64_t v105 = 18;
      }
      else {
        uint64_t v105 = v223 - v102;
      }
      unint64_t v106 = v104 - v105;
      if (v106 >= v106 - 1) {
        uint64_t v107 = v106 - 1;
      }
      else {
        uint64_t v107 = v106;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      uint64_t v15 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      uint64_t v14 = v154;
      uint64_t v12 = v160;
      uint64_t v10 = v167;
      uint64_t v8 = v175;
      uint64_t v6 = v184;
      uint64_t v4 = v194;
      uint64_t v2 = v205;
      a1 = v217;
    }
  }
  uint64_t v16 = v15[364];
  uint64_t v17 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
  {
    uint64_t v206 = v2;
    uint64_t v218 = a1;
    uint64_t v195 = v4;
    uint64_t v176 = v8;
    uint64_t v185 = v6;
    uint64_t v161 = v12;
    uint64_t v168 = v10;
    uint64_t v150 = v16;
    uint64_t v155 = v14;
    uint64_t v17 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
    uint64_t v16 = v150;
    uint64_t v14 = v155;
    uint64_t v12 = v161;
    uint64_t v10 = v168;
    uint64_t v8 = v176;
    uint64_t v6 = v185;
    uint64_t v4 = v195;
    uint64_t v2 = v206;
    int v109 = v108;
    a1 = v218;
    if (v109)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DowngraderInterface::Trait<Empty>]";
      unint64_t v223 = 89;
      unint64_t v110 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v110) {
        unint64_t v111 = v110;
      }
      else {
        unint64_t v111 = v223;
      }
      unint64_t v112 = &v222[v111];
      unint64_t v113 = v223 - v111;
      if (v223 - v111 >= 0x12) {
        uint64_t v114 = 18;
      }
      else {
        uint64_t v114 = v223 - v111;
      }
      unint64_t v115 = v113 - v114;
      if (v115 >= v115 - 1) {
        uint64_t v116 = v115 - 1;
      }
      else {
        uint64_t v116 = v115;
      }
      mlir::detail::TypeIDResolver<mlir::DowngraderInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DowngraderInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v112[v114], v116);
      uint64_t v17 = &mlir::detail::TypeIDResolver<mlir::pdl_interp::detail::ExtractOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id;
      uint64_t v16 = v150;
      uint64_t v14 = v155;
      uint64_t v12 = v161;
      uint64_t v10 = v168;
      uint64_t v8 = v176;
      uint64_t v6 = v185;
      uint64_t v4 = v195;
      uint64_t v2 = v206;
      a1 = v218;
    }
  }
  uint64_t v18 = v17[422];
  unint64_t v19 = &unk_267775000;
  {
    uint64_t v207 = v2;
    uint64_t v219 = a1;
    uint64_t v196 = v4;
    uint64_t v177 = v8;
    uint64_t v186 = v6;
    uint64_t v162 = v12;
    uint64_t v169 = v10;
    uint64_t v151 = v16;
    uint64_t v156 = v14;
    uint64_t v147 = v18;
    unint64_t v19 = (void *)&unk_267775000;
    uint64_t v18 = v147;
    uint64_t v16 = v151;
    uint64_t v14 = v156;
    uint64_t v12 = v162;
    uint64_t v10 = v169;
    uint64_t v8 = v177;
    uint64_t v6 = v186;
    uint64_t v4 = v196;
    uint64_t v2 = v207;
    int v118 = v117;
    a1 = v219;
    if (v118)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::UpgraderInterface::Trait<Empty>]";
      unint64_t v223 = 87;
      unint64_t v119 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v119) {
        unint64_t v120 = v119;
      }
      else {
        unint64_t v120 = v223;
      }
      unint64_t v121 = &v222[v120];
      unint64_t v122 = v223 - v120;
      if (v223 - v120 >= 0x12) {
        uint64_t v123 = 18;
      }
      else {
        uint64_t v123 = v223 - v120;
      }
      unint64_t v124 = v122 - v123;
      if (v124 >= v124 - 1) {
        uint64_t v125 = v124 - 1;
      }
      else {
        uint64_t v125 = v124;
      }
      mlir::detail::TypeIDResolver<mlir::UpgraderInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::UpgraderInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v121[v123], v125);
      unint64_t v19 = (void *)&unk_267775000;
      uint64_t v18 = v147;
      uint64_t v16 = v151;
      uint64_t v14 = v156;
      uint64_t v12 = v162;
      uint64_t v10 = v169;
      uint64_t v8 = v177;
      uint64_t v6 = v186;
      uint64_t v4 = v196;
      uint64_t v2 = v207;
      a1 = v219;
    }
  }
  uint64_t v20 = v19[18];
  int v21 = &unk_267771000;
  {
    uint64_t v208 = v2;
    uint64_t v220 = a1;
    uint64_t v197 = v4;
    uint64_t v178 = v8;
    uint64_t v187 = v6;
    uint64_t v163 = v12;
    uint64_t v170 = v10;
    uint64_t v152 = v16;
    uint64_t v157 = v14;
    uint64_t v145 = v20;
    uint64_t v148 = v18;
    int v21 = (void *)&unk_267771000;
    uint64_t v20 = v145;
    uint64_t v18 = v148;
    uint64_t v16 = v152;
    uint64_t v14 = v157;
    uint64_t v12 = v163;
    uint64_t v10 = v170;
    uint64_t v8 = v178;
    uint64_t v6 = v187;
    uint64_t v4 = v197;
    uint64_t v2 = v208;
    int v127 = v126;
    a1 = v220;
    if (v127)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v223 = 90;
      unint64_t v128 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v128) {
        unint64_t v129 = v128;
      }
      else {
        unint64_t v129 = v223;
      }
      unint64_t v130 = &v222[v129];
      unint64_t v131 = v223 - v129;
      if (v223 - v129 >= 0x12) {
        uint64_t v132 = 18;
      }
      else {
        uint64_t v132 = v223 - v129;
      }
      unint64_t v133 = v131 - v132;
      if (v133 >= v133 - 1) {
        uint64_t v134 = v133 - 1;
      }
      else {
        uint64_t v134 = v133;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v130[v132], v134);
      int v21 = (void *)&unk_267771000;
      uint64_t v20 = v145;
      uint64_t v18 = v148;
      uint64_t v16 = v152;
      uint64_t v14 = v157;
      uint64_t v12 = v163;
      uint64_t v10 = v170;
      uint64_t v8 = v178;
      uint64_t v6 = v187;
      uint64_t v4 = v197;
      uint64_t v2 = v208;
      a1 = v220;
    }
  }
  uint64_t v22 = v21[37];
  uint64_t v23 = &unk_267771000;
  {
    uint64_t v209 = v2;
    uint64_t v221 = a1;
    uint64_t v198 = v4;
    uint64_t v179 = v8;
    uint64_t v188 = v6;
    uint64_t v164 = v12;
    uint64_t v171 = v10;
    uint64_t v153 = v16;
    uint64_t v158 = v14;
    uint64_t v146 = v20;
    uint64_t v149 = v18;
    uint64_t v144 = v22;
    uint64_t v23 = (void *)&unk_267771000;
    uint64_t v22 = v144;
    uint64_t v20 = v146;
    uint64_t v18 = v149;
    uint64_t v16 = v153;
    uint64_t v14 = v158;
    uint64_t v12 = v164;
    uint64_t v10 = v171;
    uint64_t v8 = v179;
    uint64_t v6 = v188;
    uint64_t v4 = v198;
    uint64_t v2 = v209;
    int v136 = v135;
    a1 = v221;
    if (v136)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      unint64_t v223 = 100;
      unint64_t v137 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v137) {
        unint64_t v138 = v137;
      }
      else {
        unint64_t v138 = v223;
      }
      uint64_t v139 = &v222[v138];
      unint64_t v140 = v223 - v138;
      if (v223 - v138 >= 0x12) {
        uint64_t v141 = 18;
      }
      else {
        uint64_t v141 = v223 - v138;
      }
      unint64_t v142 = v140 - v141;
      if (v142 >= v142 - 1) {
        uint64_t v143 = v142 - 1;
      }
      else {
        uint64_t v143 = v142;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v139[v141], v143);
      uint64_t v23 = (void *)&unk_267771000;
      uint64_t v22 = v144;
      uint64_t v20 = v146;
      uint64_t v18 = v149;
      uint64_t v16 = v153;
      uint64_t v14 = v158;
      uint64_t v12 = v164;
      uint64_t v10 = v171;
      uint64_t v8 = v179;
      uint64_t v6 = v188;
      uint64_t v4 = v198;
      uint64_t v2 = v209;
      a1 = v221;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v22 == a1
      || v23[41] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::mps::_anonymous_namespace_ *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)4)
    && (uint64_t v6 = a1, mlir::mps::SoftplusParametricOp::verifyInvariantsImpl((mlir::mps::SoftplusParametricOp *)&v6)))
  {
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::SoftplusParametricOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::UpgraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SoftsignOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SoftsignOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SoftsignOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftsignOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.softsign", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SoftsignOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C3651B0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftsignOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SoftsignOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftsignOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SoftsignOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SoftsignOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SoftsignOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftsignOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftsignOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftsignOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftsignOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SoftsignOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftsignOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftsignOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftsignOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      uint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftsignOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftsignOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SoftsignOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SoftsignOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SoftsignOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SoftsignOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SoftsignOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SoftsignOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftsignOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftsignOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftsignOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftsignOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftsignOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftsignOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SoftsignOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SoftsignOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SoftsignOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  uint64_t v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  uint64_t v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  uint64_t v24 = "mps.softsign";
  uint64_t v25 = 12;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SoftsignOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SoftsignOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::SoftsignOpGenericAdaptorBase::SoftsignOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::DegammaOp>,mlir::OpTrait::OneResult<mlir::mps::DegammaOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::DegammaOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::DegammaOp>,mlir::OpTrait::OneOperand<mlir::mps::DegammaOp>,mlir::OpTrait::OpInvariants<mlir::mps::DegammaOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::DegammaOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::DegammaOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::DegammaOp>,mlir::OpTrait::Stitchable<mlir::mps::DegammaOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::DegammaOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::DegammaOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::SoftsignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SortOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.sort", 8, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SortOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36CEB0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 10
    && (*(void *)a3 == 0x69646E6563736564 ? (BOOL v7 = *(unsigned __int16 *)(a3 + 8) == 26478) : (BOOL v7 = 0), v7))
  {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 10 && *(void *)result == 0x69646E6563736564 && *(_WORD *)(result + 8) == 26478)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      *uint64_t v5 = v9;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"descending", 10, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (void **)"descending", (const char *)0xA, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::SortOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::SortOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::SortOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::SortOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>::inferReturnTypes(mlir::Float32Type *this, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::SortOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>::refineReturnTypes(mlir::Float32Type *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SortOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SortOp>::refineReturnTypes(mlir::Float32Type *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v22 = v24;
  uint64_t v23 = 0x400000000;
  if (mlir::mps::SortOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, v18, v19, (uint64_t)&v22))
  {
    mlir::ValueRange::ValueRange(v21, (uint64_t)v22, v23);
    mlir::ValueRange::ValueRange(v20, *(void *)a11, *(unsigned int *)(a11 + 8));
    v25[0] = &unk_26C380E60;
    unsigned int v26 = v25;
    int v28 = v27;
    v27[0] = &unk_26C380E60;
    if (v28 == v27)
    {
      (*(void (**)(void *))(v27[0] + 32))(v27);
      unint64_t v14 = v26;
      if (v26 != v25) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v28) {
        (*(void (**)(void *))(*v28 + 40))(v28);
      }
      unint64_t v14 = v26;
      if (v26 != v25)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v22;
          if (v22 == v24) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v25[0] + 32))(v25);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v27[0] = "mps.sort";
    v27[1] = 8;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v27, "' op inferred type(s) ", (uint64_t)&v22, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v22;
    if (v22 == v24) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v22;
  if (v22 != v24) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SortOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SortOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SortOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x20uLL, 0x8004018A671A6uLL);
  void *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>::getDefaultDialect;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      unint64_t v14 = 72;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[346], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>::getAsmResultNames(uint64_t a1, uint64_t a2, void (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v6 = a2 - 16;
  if (*(_DWORD *)(a2 + 36)) {
    uint64_t v7 = a2 - 16;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0);
  a3(a4, NextResultAtOffset, "result", 6);
  if (*(_DWORD *)(a2 + 36)) {
    uint64_t v9 = v6;
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = mlir::detail::OpResultImpl::getNextResultAtOffset(v9, 1);
  uint64_t v11 = mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0);

  return ((uint64_t (*)(uint64_t, uint64_t, const char *, uint64_t))a3)(a4, v11, "indices", 7);
}

char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::SortOp>::getDefaultDialect()
{
  return &byte_211F4AA5D;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::foldHook<mlir::mps::SortOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::foldHook<mlir::mps::SortOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  uint64_t v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v23, v12, v11);
  uint64_t v16 = v8;
  v17[0] = 0;
  char v18 = 0;
  uint64_t v19 = *v10;
  long long v20 = *(_OWORD *)v23;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v16);
    if (v18) {
      char v18 = 0;
    }
    mlir::OperationName::OperationName(v17, "mps.sort", 8, Context);
    char v18 = 1;
  }
  uint64_t v21 = a2;
  uint64_t v22 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v23[0] = result;
  v23[1] = v15;
  if (result) {
    return mlir::RegionBranchOpInterface::getEntrySuccessorRegions(v23, v21, v22, a4);
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v165 = a1;
    v1 = (void *)&unk_267771000;
    int v31 = v30;
    a1 = v165;
    if (v31)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v176 = 83;
      unint64_t v32 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v32) {
        unint64_t v33 = v32;
      }
      else {
        unint64_t v33 = v176;
      }
      uint64_t v34 = &v175[v33];
      unint64_t v35 = v176 - v33;
      if (v176 - v33 >= 0x12) {
        uint64_t v36 = 18;
      }
      else {
        uint64_t v36 = v176 - v33;
      }
      unint64_t v37 = v35 - v36;
      if (v37 >= v37 - 1) {
        uint64_t v38 = v37 - 1;
      }
      else {
        uint64_t v38 = v37;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v34[v36], v38);
      v1 = (void *)&unk_267771000;
      a1 = v165;
    }
  }
  uint64_t v2 = v1[23];
  char v3 = &unk_267771000;
  {
    uint64_t v156 = v2;
    uint64_t v166 = a1;
    char v3 = (void *)&unk_267771000;
    int v40 = v39;
    uint64_t v2 = v156;
    a1 = v166;
    if (v40)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NResults<2>::Impl<Empty>]";
      unint64_t v176 = 89;
      unint64_t v41 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v41) {
        unint64_t v42 = v41;
      }
      else {
        unint64_t v42 = v176;
      }
      unint64_t v43 = &v175[v42];
      unint64_t v44 = v176 - v42;
      if (v176 - v42 >= 0x12) {
        uint64_t v45 = 18;
      }
      else {
        uint64_t v45 = v176 - v42;
      }
      unint64_t v46 = v44 - v45;
      if (v46 >= v46 - 1) {
        uint64_t v47 = v46 - 1;
      }
      else {
        uint64_t v47 = v46;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::NResults<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NResults<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v43[v45], v47);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v156;
      a1 = v166;
    }
  }
  uint64_t v4 = v3[348];
  unint64_t v5 = &unk_267770000;
  {
    uint64_t v157 = v2;
    uint64_t v167 = a1;
    uint64_t v148 = v4;
    unint64_t v5 = (void *)&unk_267770000;
    uint64_t v4 = v148;
    int v49 = v48;
    uint64_t v2 = v157;
    a1 = v167;
    if (v49)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v176 = 86;
      unint64_t v50 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v50) {
        unint64_t v51 = v50;
      }
      else {
        unint64_t v51 = v176;
      }
      unint64_t v52 = &v175[v51];
      unint64_t v53 = v176 - v51;
      if (v176 - v51 >= 0x12) {
        uint64_t v54 = 18;
      }
      else {
        uint64_t v54 = v176 - v51;
      }
      unint64_t v55 = v53 - v54;
      if (v55 >= v55 - 1) {
        uint64_t v56 = v55 - 1;
      }
      else {
        uint64_t v56 = v55;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      unint64_t v5 = (void *)&unk_267770000;
      uint64_t v4 = v148;
      uint64_t v2 = v157;
      a1 = v167;
    }
  }
  uint64_t v6 = v5[431];
  uint64_t v7 = &unk_267771000;
  {
    uint64_t v158 = v2;
    uint64_t v168 = a1;
    uint64_t v141 = v6;
    uint64_t v149 = v4;
    uint64_t v7 = (void *)&unk_267771000;
    uint64_t v6 = v141;
    uint64_t v4 = v149;
    int v58 = v57;
    uint64_t v2 = v158;
    a1 = v168;
    if (v58)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      unint64_t v176 = 90;
      unint64_t v59 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v59) {
        unint64_t v60 = v59;
      }
      else {
        unint64_t v60 = v176;
      }
      unint64_t v61 = &v175[v60];
      unint64_t v62 = v176 - v60;
      if (v176 - v60 >= 0x12) {
        uint64_t v63 = 18;
      }
      else {
        uint64_t v63 = v176 - v60;
      }
      unint64_t v64 = v62 - v63;
      if (v64 >= v64 - 1) {
        uint64_t v65 = v64 - 1;
      }
      else {
        uint64_t v65 = v64;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      uint64_t v7 = (void *)&unk_267771000;
      uint64_t v6 = v141;
      uint64_t v4 = v149;
      uint64_t v2 = v158;
      a1 = v168;
    }
  }
  uint64_t v8 = v7[89];
  unint64_t v9 = &unk_267770000;
  {
    uint64_t v159 = v2;
    uint64_t v169 = a1;
    uint64_t v142 = v6;
    uint64_t v150 = v4;
    uint64_t v135 = v8;
    unint64_t v9 = (void *)&unk_267770000;
    uint64_t v8 = v135;
    uint64_t v6 = v142;
    uint64_t v4 = v150;
    int v67 = v66;
    uint64_t v2 = v159;
    a1 = v169;
    if (v67)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v176 = 84;
      unint64_t v68 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v68) {
        unint64_t v69 = v68;
      }
      else {
        unint64_t v69 = v176;
      }
      unint64_t v70 = &v175[v69];
      unint64_t v71 = v176 - v69;
      if (v176 - v69 >= 0x12) {
        uint64_t v72 = 18;
      }
      else {
        uint64_t v72 = v176 - v69;
      }
      unint64_t v73 = v71 - v72;
      if (v73 >= v73 - 1) {
        uint64_t v74 = v73 - 1;
      }
      else {
        uint64_t v74 = v73;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      unint64_t v9 = (void *)&unk_267770000;
      uint64_t v8 = v135;
      uint64_t v6 = v142;
      uint64_t v4 = v150;
      uint64_t v2 = v159;
      a1 = v169;
    }
  }
  uint64_t v10 = v9[435];
  unint64_t v11 = &unk_267771000;
  {
    uint64_t v160 = v2;
    uint64_t v170 = a1;
    uint64_t v143 = v6;
    uint64_t v151 = v4;
    uint64_t v130 = v10;
    uint64_t v136 = v8;
    unint64_t v11 = (void *)&unk_267771000;
    uint64_t v10 = v130;
    uint64_t v8 = v136;
    uint64_t v6 = v143;
    uint64_t v4 = v151;
    int v76 = v75;
    uint64_t v2 = v160;
    a1 = v170;
    if (v76)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v176 = 89;
      unint64_t v77 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v77) {
        unint64_t v78 = v77;
      }
      else {
        unint64_t v78 = v176;
      }
      unint64_t v79 = &v175[v78];
      unint64_t v80 = v176 - v78;
      if (v176 - v78 >= 0x12) {
        uint64_t v81 = 18;
      }
      else {
        uint64_t v81 = v176 - v78;
      }
      unint64_t v82 = v80 - v81;
      if (v82 >= v82 - 1) {
        uint64_t v83 = v82 - 1;
      }
      else {
        uint64_t v83 = v82;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      unint64_t v11 = (void *)&unk_267771000;
      uint64_t v10 = v130;
      uint64_t v8 = v136;
      uint64_t v6 = v143;
      uint64_t v4 = v151;
      uint64_t v2 = v160;
      a1 = v170;
    }
  }
  uint64_t v12 = v11[320];
  char v13 = &unk_267771000;
  {
    uint64_t v161 = v2;
    uint64_t v171 = a1;
    uint64_t v144 = v6;
    uint64_t v152 = v4;
    uint64_t v131 = v10;
    uint64_t v137 = v8;
    uint64_t v126 = v12;
    char v13 = (void *)&unk_267771000;
    uint64_t v12 = v126;
    uint64_t v10 = v131;
    uint64_t v8 = v137;
    uint64_t v6 = v144;
    uint64_t v4 = v152;
    int v85 = v84;
    uint64_t v2 = v161;
    a1 = v171;
    if (v85)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v176 = 93;
      unint64_t v86 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v86) {
        unint64_t v87 = v86;
      }
      else {
        unint64_t v87 = v176;
      }
      unint64_t v88 = &v175[v87];
      unint64_t v89 = v176 - v87;
      if (v176 - v87 >= 0x12) {
        uint64_t v90 = 18;
      }
      else {
        uint64_t v90 = v176 - v87;
      }
      unint64_t v91 = v89 - v90;
      if (v91 >= v91 - 1) {
        uint64_t v92 = v91 - 1;
      }
      else {
        uint64_t v92 = v91;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      char v13 = (void *)&unk_267771000;
      uint64_t v12 = v126;
      uint64_t v10 = v131;
      uint64_t v8 = v137;
      uint64_t v6 = v144;
      uint64_t v4 = v152;
      uint64_t v2 = v161;
      a1 = v171;
    }
  }
  uint64_t v14 = v13[31];
  unint64_t v15 = &unk_267771000;
  {
    uint64_t v162 = v2;
    uint64_t v172 = a1;
    uint64_t v145 = v6;
    uint64_t v153 = v4;
    uint64_t v132 = v10;
    uint64_t v138 = v8;
    uint64_t v123 = v14;
    uint64_t v127 = v12;
    unint64_t v15 = (void *)&unk_267771000;
    uint64_t v14 = v123;
    uint64_t v12 = v127;
    uint64_t v10 = v132;
    uint64_t v8 = v138;
    uint64_t v6 = v145;
    uint64_t v4 = v153;
    int v94 = v93;
    uint64_t v2 = v162;
    a1 = v172;
    if (v94)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v176 = 90;
      unint64_t v95 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v95) {
        unint64_t v96 = v95;
      }
      else {
        unint64_t v96 = v176;
      }
      unint64_t v97 = &v175[v96];
      unint64_t v98 = v176 - v96;
      if (v176 - v96 >= 0x12) {
        uint64_t v99 = 18;
      }
      else {
        uint64_t v99 = v176 - v96;
      }
      unint64_t v100 = v98 - v99;
      if (v100 >= v100 - 1) {
        uint64_t v101 = v100 - 1;
      }
      else {
        uint64_t v101 = v100;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      unint64_t v15 = (void *)&unk_267771000;
      uint64_t v14 = v123;
      uint64_t v12 = v127;
      uint64_t v10 = v132;
      uint64_t v8 = v138;
      uint64_t v6 = v145;
      uint64_t v4 = v153;
      uint64_t v2 = v162;
      a1 = v172;
    }
  }
  uint64_t v16 = v15[37];
  uint64_t v17 = &unk_267771000;
  {
    uint64_t v163 = v2;
    uint64_t v173 = a1;
    uint64_t v146 = v6;
    uint64_t v154 = v4;
    uint64_t v133 = v10;
    uint64_t v139 = v8;
    uint64_t v124 = v14;
    uint64_t v128 = v12;
    uint64_t v121 = v16;
    uint64_t v17 = (void *)&unk_267771000;
    uint64_t v16 = v121;
    uint64_t v14 = v124;
    uint64_t v12 = v128;
    uint64_t v10 = v133;
    uint64_t v8 = v139;
    uint64_t v6 = v146;
    uint64_t v4 = v154;
    int v103 = v102;
    uint64_t v2 = v163;
    a1 = v173;
    if (v103)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      unint64_t v176 = 100;
      unint64_t v104 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v104) {
        unint64_t v105 = v104;
      }
      else {
        unint64_t v105 = v176;
      }
      unint64_t v106 = &v175[v105];
      unint64_t v107 = v176 - v105;
      if (v176 - v105 >= 0x12) {
        uint64_t v108 = 18;
      }
      else {
        uint64_t v108 = v176 - v105;
      }
      unint64_t v109 = v107 - v108;
      if (v109 >= v109 - 1) {
        uint64_t v110 = v109 - 1;
      }
      else {
        uint64_t v110 = v109;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      uint64_t v17 = (void *)&unk_267771000;
      uint64_t v16 = v121;
      uint64_t v14 = v124;
      uint64_t v12 = v128;
      uint64_t v10 = v133;
      uint64_t v8 = v139;
      uint64_t v6 = v146;
      uint64_t v4 = v154;
      uint64_t v2 = v163;
      a1 = v173;
    }
  }
  uint64_t v18 = v17[41];
  uint64_t v19 = &unk_267771000;
  {
    uint64_t v164 = v2;
    uint64_t v174 = a1;
    uint64_t v147 = v6;
    uint64_t v155 = v4;
    uint64_t v134 = v10;
    uint64_t v140 = v8;
    uint64_t v125 = v14;
    uint64_t v129 = v12;
    uint64_t v120 = v18;
    uint64_t v122 = v16;
    uint64_t v19 = (void *)&unk_267771000;
    uint64_t v18 = v120;
    uint64_t v16 = v122;
    uint64_t v14 = v125;
    uint64_t v12 = v129;
    uint64_t v10 = v134;
    uint64_t v8 = v140;
    uint64_t v6 = v147;
    uint64_t v4 = v155;
    int v112 = v111;
    uint64_t v2 = v164;
    a1 = v174;
    if (v112)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      unint64_t v176 = 86;
      unint64_t v113 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v113) {
        unint64_t v114 = v113;
      }
      else {
        unint64_t v114 = v176;
      }
      unint64_t v115 = &v175[v114];
      unint64_t v116 = v176 - v114;
      if (v176 - v114 >= 0x12) {
        uint64_t v117 = 18;
      }
      else {
        uint64_t v117 = v176 - v114;
      }
      unint64_t v118 = v116 - v117;
      if (v118 >= v118 - 1) {
        uint64_t v119 = v118 - 1;
      }
      else {
        uint64_t v119 = v118;
      }
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      uint64_t v19 = (void *)&unk_267771000;
      uint64_t v18 = v120;
      uint64_t v16 = v122;
      uint64_t v14 = v125;
      uint64_t v12 = v129;
      uint64_t v10 = v134;
      uint64_t v8 = v140;
      uint64_t v6 = v147;
      uint64_t v4 = v155;
      uint64_t v2 = v164;
      a1 = v174;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v19[350] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants(mlir::mps::_anonymous_namespace_ *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyNResults(a1, (mlir::Operation *)2)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v3)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (unint64_t v5 = a1, mlir::mps::SortOp::verifyInvariantsImpl((mlir::mps::SortOp *)&v5)))
  {
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::SortOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::NResults<2u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.space_to_batch", 18, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SpaceToBatchOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C367988;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 13
    && (*a3 == 0x68735F6C65786970 ? (BOOL v7 = *(void *)((char *)a3 + 5) == 0x656C66667568735FLL) : (BOOL v7 = 0), v7))
  {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else
  {
    return 0;
  }
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 13 && *result == 0x68735F6C65786970 && *(void *)((char *)result + 5) == 0x656C66667568735FLL)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      *uint64_t v5 = v9;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"pixel_shuffle", 13, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (void **)"pixel_shuffle", (const char *)0xD, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::BatchToSpaceOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::BatchToSpaceOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToBatchOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::SpaceToBatchOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::SpaceToBatchOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SpaceToBatchOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SpaceToBatchOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v22 = v24;
  uint64_t v23 = 0x400000000;
  if (mlir::mps::SpaceToBatchOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, v18, v19, (uint64_t)&v22))
  {
    mlir::ValueRange::ValueRange(v21, (uint64_t)v22, v23);
    mlir::ValueRange::ValueRange(v20, *(void *)a11, *(unsigned int *)(a11 + 8));
    v25[0] = &unk_26C380E60;
    unsigned int v26 = v25;
    int v28 = v27;
    v27[0] = &unk_26C380E60;
    if (v28 == v27)
    {
      (*(void (**)(void *))(v27[0] + 32))(v27);
      unint64_t v14 = v26;
      if (v26 != v25) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v28) {
        (*(void (**)(void *))(*v28 + 40))(v28);
      }
      unint64_t v14 = v26;
      if (v26 != v25)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v22;
          if (v22 == v24) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v25[0] + 32))(v25);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v27[0] = "mps.space_to_batch";
    v27[1] = 18;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v27, "' op inferred type(s) ", (uint64_t)&v22, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v22;
    if (v22 == v24) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v22;
  if (v22 != v24) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SpaceToBatchOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SpaceToBatchOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SpaceToBatchOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  unint64_t v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  uint64_t v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.space_to_batch", 18, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)4)) {
    return 0;
  }
  unint64_t v6 = a1;
  if (!mlir::mps::BatchToSpaceOp::verifyInvariantsImpl((mlir::mps::BatchToSpaceOp *)&v6)) {
    return 0;
  }
  unint64_t v6 = a1;
  return mlir::mps::SpaceToBatchOp::verify(&v6) != 0;
}

BOOL mlir::Op<mlir::mps::SpaceToBatchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.space_to_depth_2d", 21, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SpaceToDepth2DOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C368AB8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v7 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v7 = 0;
  }
  if (a4 == 13)
  {
    if (*(void *)a3 != 0x68735F6C65786970 || *(void *)(a3 + 5) != 0x656C66667568735FLL) {
      return 0;
    }
    return v7[1];
  }
  else
  {
    if (a4 != 10) {
      return 0;
    }
    if (*(void *)a3 != 0x69735F6B636F6C62 || *(_WORD *)(a3 + 8) != 25978) {
      return 0;
    }
    return *v7;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v12 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v12);
  if (v7 == 13)
  {
    if (*(void *)result == 0x68735F6C65786970 && *(void *)(result + 5) == 0x656C66667568735FLL)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
          uint64_t v10 = a4;
        }
        else {
          uint64_t v10 = 0;
        }
        v5[1] = v10;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else if (v7 == 10 && *(void *)result == 0x69735F6B636F6C62 && *(_WORD *)(result + 8) == 25978)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
        uint64_t v11 = a4;
      }
      else {
        uint64_t v11 = 0;
      }
      *uint64_t v5 = v11;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  if (*v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"block_size", 10, *v5);
  }
  uint64_t v6 = v5[1];
  if (v6)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"pixel_shuffle", 13, v6);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9 = (void **)mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  BOOL result = 0;
  if (!v9
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v9, (void **)"block_size", (const char *)0xA, a4, a5))
  {
    uint64_t v10 = mlir::NamedAttrList::get(a3, *(void *)(*(void *)(a2 + 96) + 8));
    if (!v10
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v10, (void **)"pixel_shuffle", (const char *)0xD, a4, a5))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::getOpPropertyByteSize()
{
  return 16;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    *(_OWORD *)a3 = *a4;
  }
  else
  {
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::DepthToSpace2DOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::DepthToSpace2DOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2 && a3[1] == a2[1];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::SpaceToDepth2DOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::ModuleOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::SpaceToDepth2DOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 1) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 16))(a3, *v4);
  uint64_t v5 = v4[1];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 24);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::SpaceToDepth2DOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SpaceToDepth2DOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SpaceToDepth2DOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  long long v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::SpaceToDepth2DOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.space_to_depth_2d";
    v25[1] = 21;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SpaceToDepth2DOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SpaceToDepth2DOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SpaceToDepth2DOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    unint64_t v10 = (long long *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  }
  else {
    unint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  uint64_t v19 = v8;
  v20[0] = 0;
  char v21 = 0;
  long long v22 = *v10;
  long long v23 = *(_OWORD *)v26;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21) {
      char v21 = 0;
    }
    mlir::OperationName::OperationName(v20, "mps.space_to_depth_2d", 21, Context);
    char v21 = 1;
  }
  uint64_t v24 = a2;
  uint64_t v25 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v26[0] = result;
  v26[1] = v15;
  if (result)
  {
    unint64_t v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
    if (v16 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v17 = v16;
      if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v18 = *(unsigned int *)(a4 + 8);
        if (v18 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
          LODWORD(v18) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v18) = v17;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)4)) {
    return 0;
  }
  unint64_t v6 = a1;
  if (!mlir::mps::DepthToSpace2DOp::verifyInvariantsImpl((mlir::mps::DepthToSpace2DOp *)&v6)) {
    return 0;
  }
  unint64_t v6 = a1;
  return mlir::mps::SpaceToDepth2DOp::verify((mlir::mps::SpaceToDepth2DOp *)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::SpaceToDepth2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.split", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SplitOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36DE50;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 10
    && (*(void *)a3 == 0x696C70735F6D756ELL ? (BOOL v7 = *(unsigned __int16 *)(a3 + 8) == 29556) : (BOOL v7 = 0), v7))
  {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 10 && *(void *)result == 0x696C70735F6D756ELL && *(_WORD *)(result + 8) == 29556)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      *uint64_t v5 = v9;
    }
    else
    {
      *uint64_t v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"num_splits", 10, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = (void **)mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v7, (void **)"num_splits", (const char *)0xA, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::SplitOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::mps::SplitOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::SplitOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::SplitOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::SplitOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SplitOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SplitOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  long long v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::SplitOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          unint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.split";
    v25[1] = 9;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    unint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  unint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SplitOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldHook<mlir::mps::SplitOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldHook<mlir::mps::SplitOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  unint64_t v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v23, v12, v11);
  uint64_t v16 = v8;
  v17[0] = 0;
  char v18 = 0;
  uint64_t v19 = *v10;
  long long v20 = *(_OWORD *)v23;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v16);
    if (v18) {
      char v18 = 0;
    }
    mlir::OperationName::OperationName(v17, "mps.split", 9, Context);
    char v18 = 1;
  }
  uint64_t v21 = a2;
  uint64_t v22 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v23[0] = result;
  v23[1] = v15;
  if (result) {
    return mlir::RegionBranchOpInterface::getEntrySuccessorRegions(v23, v21, v22, a4);
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v144 = a1;
    v1 = (void *)&unk_267771000;
    int v28 = v27;
    a1 = v144;
    if (v28)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v154 = 83;
      unint64_t v29 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v29) {
        unint64_t v30 = v29;
      }
      else {
        unint64_t v30 = v154;
      }
      int v31 = &v153[v30];
      unint64_t v32 = v154 - v30;
      if (v154 - v30 >= 0x12) {
        uint64_t v33 = 18;
      }
      else {
        uint64_t v33 = v154 - v30;
      }
      unint64_t v34 = v32 - v33;
      if (v34 >= v34 - 1) {
        uint64_t v35 = v34 - 1;
      }
      else {
        uint64_t v35 = v34;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v31[v33], v35);
      v1 = (void *)&unk_267771000;
      a1 = v144;
    }
  }
  uint64_t v2 = v1[23];
  char v3 = &unk_267771000;
  {
    uint64_t v136 = v2;
    uint64_t v145 = a1;
    char v3 = (void *)&unk_267771000;
    int v37 = v36;
    uint64_t v2 = v136;
    a1 = v145;
    if (v37)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicResults<Empty>]";
      unint64_t v154 = 87;
      unint64_t v38 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v38) {
        unint64_t v39 = v38;
      }
      else {
        unint64_t v39 = v154;
      }
      int v40 = &v153[v39];
      unint64_t v41 = v154 - v39;
      if (v154 - v39 >= 0x12) {
        uint64_t v42 = 18;
      }
      else {
        uint64_t v42 = v154 - v39;
      }
      unint64_t v43 = v41 - v42;
      if (v43 >= v43 - 1) {
        uint64_t v44 = v43 - 1;
      }
      else {
        uint64_t v44 = v43;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v136;
      a1 = v145;
    }
  }
  uint64_t v4 = v3[437];
  unint64_t v5 = &unk_267770000;
  {
    uint64_t v137 = v2;
    uint64_t v146 = a1;
    uint64_t v129 = v4;
    unint64_t v5 = (void *)&unk_267770000;
    uint64_t v4 = v129;
    int v46 = v45;
    uint64_t v2 = v137;
    a1 = v146;
    if (v46)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v154 = 86;
      unint64_t v47 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v47) {
        unint64_t v48 = v47;
      }
      else {
        unint64_t v48 = v154;
      }
      int v49 = &v153[v48];
      unint64_t v50 = v154 - v48;
      if (v154 - v48 >= 0x12) {
        uint64_t v51 = 18;
      }
      else {
        uint64_t v51 = v154 - v48;
      }
      unint64_t v52 = v50 - v51;
      if (v52 >= v52 - 1) {
        uint64_t v53 = v52 - 1;
      }
      else {
        uint64_t v53 = v52;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      unint64_t v5 = (void *)&unk_267770000;
      uint64_t v4 = v129;
      uint64_t v2 = v137;
      a1 = v146;
    }
  }
  uint64_t v6 = v5[431];
  uint64_t v7 = &unk_267771000;
  {
    uint64_t v138 = v2;
    uint64_t v147 = a1;
    uint64_t v123 = v6;
    uint64_t v130 = v4;
    uint64_t v7 = (void *)&unk_267771000;
    uint64_t v6 = v123;
    uint64_t v4 = v130;
    int v55 = v54;
    uint64_t v2 = v138;
    a1 = v147;
    if (v55)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<2>::Impl<Empty>]";
      unint64_t v154 = 97;
      unint64_t v56 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v56) {
        unint64_t v57 = v56;
      }
      else {
        unint64_t v57 = v154;
      }
      int v58 = &v153[v57];
      unint64_t v59 = v154 - v57;
      if (v154 - v57 >= 0x12) {
        uint64_t v60 = 18;
      }
      else {
        uint64_t v60 = v154 - v57;
      }
      unint64_t v61 = v59 - v60;
      if (v61 >= v61 - 1) {
        uint64_t v62 = v61 - 1;
      }
      else {
        uint64_t v62 = v61;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      uint64_t v7 = (void *)&unk_267771000;
      uint64_t v6 = v123;
      uint64_t v4 = v130;
      uint64_t v2 = v138;
      a1 = v147;
    }
  }
  uint64_t v8 = v7[441];
  unint64_t v9 = &unk_267770000;
  {
    uint64_t v139 = v2;
    uint64_t v148 = a1;
    uint64_t v124 = v6;
    uint64_t v131 = v4;
    uint64_t v118 = v8;
    unint64_t v9 = (void *)&unk_267770000;
    uint64_t v8 = v118;
    uint64_t v6 = v124;
    uint64_t v4 = v131;
    int v64 = v63;
    uint64_t v2 = v139;
    a1 = v148;
    if (v64)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v154 = 84;
      unint64_t v65 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v65) {
        unint64_t v66 = v65;
      }
      else {
        unint64_t v66 = v154;
      }
      int v67 = &v153[v66];
      unint64_t v68 = v154 - v66;
      if (v154 - v66 >= 0x12) {
        uint64_t v69 = 18;
      }
      else {
        uint64_t v69 = v154 - v66;
      }
      unint64_t v70 = v68 - v69;
      if (v70 >= v70 - 1) {
        uint64_t v71 = v70 - 1;
      }
      else {
        uint64_t v71 = v70;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      unint64_t v9 = (void *)&unk_267770000;
      uint64_t v8 = v118;
      uint64_t v6 = v124;
      uint64_t v4 = v131;
      uint64_t v2 = v139;
      a1 = v148;
    }
  }
  uint64_t v10 = v9[435];
  unint64_t v11 = &unk_267771000;
  {
    uint64_t v140 = v2;
    uint64_t v149 = a1;
    uint64_t v125 = v6;
    uint64_t v132 = v4;
    uint64_t v114 = v10;
    uint64_t v119 = v8;
    unint64_t v11 = (void *)&unk_267771000;
    uint64_t v10 = v114;
    uint64_t v8 = v119;
    uint64_t v6 = v125;
    uint64_t v4 = v132;
    int v73 = v72;
    uint64_t v2 = v140;
    a1 = v149;
    if (v73)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v154 = 89;
      unint64_t v74 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v74) {
        unint64_t v75 = v74;
      }
      else {
        unint64_t v75 = v154;
      }
      int v76 = &v153[v75];
      unint64_t v77 = v154 - v75;
      if (v154 - v75 >= 0x12) {
        uint64_t v78 = 18;
      }
      else {
        uint64_t v78 = v154 - v75;
      }
      unint64_t v79 = v77 - v78;
      if (v79 >= v79 - 1) {
        uint64_t v80 = v79 - 1;
      }
      else {
        uint64_t v80 = v79;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      unint64_t v11 = (void *)&unk_267771000;
      uint64_t v10 = v114;
      uint64_t v8 = v119;
      uint64_t v6 = v125;
      uint64_t v4 = v132;
      uint64_t v2 = v140;
      a1 = v149;
    }
  }
  uint64_t v12 = v11[320];
  char v13 = &unk_267771000;
  {
    uint64_t v141 = v2;
    uint64_t v150 = a1;
    uint64_t v126 = v6;
    uint64_t v133 = v4;
    uint64_t v115 = v10;
    uint64_t v120 = v8;
    uint64_t v111 = v12;
    char v13 = (void *)&unk_267771000;
    uint64_t v12 = v111;
    uint64_t v10 = v115;
    uint64_t v8 = v120;
    uint64_t v6 = v126;
    uint64_t v4 = v133;
    int v82 = v81;
    uint64_t v2 = v141;
    a1 = v150;
    if (v82)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v154 = 93;
      unint64_t v83 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v83) {
        unint64_t v84 = v83;
      }
      else {
        unint64_t v84 = v154;
      }
      int v85 = &v153[v84];
      unint64_t v86 = v154 - v84;
      if (v154 - v84 >= 0x12) {
        uint64_t v87 = 18;
      }
      else {
        uint64_t v87 = v154 - v84;
      }
      unint64_t v88 = v86 - v87;
      if (v88 >= v88 - 1) {
        uint64_t v89 = v88 - 1;
      }
      else {
        uint64_t v89 = v88;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      char v13 = (void *)&unk_267771000;
      uint64_t v12 = v111;
      uint64_t v10 = v115;
      uint64_t v8 = v120;
      uint64_t v6 = v126;
      uint64_t v4 = v133;
      uint64_t v2 = v141;
      a1 = v150;
    }
  }
  uint64_t v14 = v13[31];
  unint64_t v15 = &unk_267771000;
  {
    uint64_t v142 = v2;
    uint64_t v151 = a1;
    uint64_t v127 = v6;
    uint64_t v134 = v4;
    uint64_t v116 = v10;
    uint64_t v121 = v8;
    uint64_t v109 = v14;
    uint64_t v112 = v12;
    unint64_t v15 = (void *)&unk_267771000;
    uint64_t v14 = v109;
    uint64_t v12 = v112;
    uint64_t v10 = v116;
    uint64_t v8 = v121;
    uint64_t v6 = v127;
    uint64_t v4 = v134;
    int v91 = v90;
    uint64_t v2 = v142;
    a1 = v151;
    if (v91)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v154 = 90;
      unint64_t v92 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v92) {
        unint64_t v93 = v92;
      }
      else {
        unint64_t v93 = v154;
      }
      int v94 = &v153[v93];
      unint64_t v95 = v154 - v93;
      if (v154 - v93 >= 0x12) {
        uint64_t v96 = 18;
      }
      else {
        uint64_t v96 = v154 - v93;
      }
      unint64_t v97 = v95 - v96;
      if (v97 >= v97 - 1) {
        uint64_t v98 = v97 - 1;
      }
      else {
        uint64_t v98 = v97;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      unint64_t v15 = (void *)&unk_267771000;
      uint64_t v14 = v109;
      uint64_t v12 = v112;
      uint64_t v10 = v116;
      uint64_t v8 = v121;
      uint64_t v6 = v127;
      uint64_t v4 = v134;
      uint64_t v2 = v142;
      a1 = v151;
    }
  }
  uint64_t v16 = v15[37];
  unint64_t v17 = &unk_267771000;
  {
    uint64_t v143 = v2;
    uint64_t v152 = a1;
    uint64_t v128 = v6;
    uint64_t v135 = v4;
    uint64_t v117 = v10;
    uint64_t v122 = v8;
    uint64_t v110 = v14;
    uint64_t v113 = v12;
    uint64_t v108 = v16;
    unint64_t v17 = (void *)&unk_267771000;
    uint64_t v16 = v108;
    uint64_t v14 = v110;
    uint64_t v12 = v113;
    uint64_t v10 = v117;
    uint64_t v8 = v122;
    uint64_t v6 = v128;
    uint64_t v4 = v135;
    int v100 = v99;
    uint64_t v2 = v143;
    a1 = v152;
    if (v100)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      unint64_t v154 = 100;
      unint64_t v101 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v101) {
        unint64_t v102 = v101;
      }
      else {
        unint64_t v102 = v154;
      }
      int v103 = &v153[v102];
      unint64_t v104 = v154 - v102;
      if (v154 - v102 >= 0x12) {
        uint64_t v105 = 18;
      }
      else {
        uint64_t v105 = v154 - v102;
      }
      unint64_t v106 = v104 - v105;
      if (v106 >= v106 - 1) {
        uint64_t v107 = v106 - 1;
      }
      else {
        uint64_t v107 = v106;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      unint64_t v17 = (void *)&unk_267771000;
      uint64_t v16 = v108;
      uint64_t v14 = v110;
      uint64_t v12 = v113;
      uint64_t v10 = v117;
      uint64_t v8 = v122;
      uint64_t v6 = v128;
      uint64_t v4 = v135;
      uint64_t v2 = v143;
      a1 = v152;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v17[41] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)2)) {
    return 0;
  }
  unint64_t v5 = a1;
  if (!mlir::mps::SplitOp::verifyInvariantsImpl((mlir::mps::SplitOp *)&v5)) {
    return 0;
  }
  unint64_t v5 = a1;
  return mlir::mps::SplitOp::verify((mlir::mps::SplitOp *)&v5) != 0;
}

BOOL mlir::Op<mlir::mps::SplitOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SquareOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SquareOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SquareOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SquareOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.square", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SquareOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36E878;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SquareOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SquareOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SquareOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SquareOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SquareOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      unint64_t v11 = v32;
      uint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          unint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SquareOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SquareOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SquareOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SquareOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SquareOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SquareOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SquareOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SquareOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SquareOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SquareOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SquareOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SquareOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SquareOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SquareOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  uint64_t v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  uint64_t v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  uint64_t v24 = "mps.square";
  uint64_t v25 = 10;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SquareOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SquareOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::SquareOpGenericAdaptorBase::SquareOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ACosOp>,mlir::OpTrait::OneResult<mlir::mps::ACosOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ACosOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ACosOp>,mlir::OpTrait::OneOperand<mlir::mps::ACosOp>,mlir::OpTrait::OpInvariants<mlir::mps::ACosOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ACosOp>,mlir::OpTrait::Stitchable<mlir::mps::ACosOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ACosOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ACosOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::SquareOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SquareRootOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SquareRootOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SquareRootOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SquareRootOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.square_root", 15, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SquareRootOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C3662E0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareRootOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SquareRootOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareRootOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SquareRootOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SquareRootOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SquareRootOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareRootOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        uint64_t v11 = v12;
      }
      else {
        uint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareRootOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareRootOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareRootOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SquareRootOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareRootOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareRootOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareRootOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    char v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    unint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareRootOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareRootOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SquareRootOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SquareRootOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SquareRootOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SquareRootOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SquareRootOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SquareRootOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SquareRootOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SquareRootOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SquareRootOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SquareRootOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SquareRootOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v14[2] = *MEMORY[0x263EF8340];
  v14[0] = a4;
  v14[1] = a5;
  int v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v12 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(void **)a11 = *(void *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SquareRootOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SquareRootOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SquareRootOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SquareRootOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v20[0] = v21;
  uint64_t v24 = a4;
  uint64_t v25 = a5;
  v21[0] = 0;
  v20[1] = (void *)0x400000001;
  v21[0] = *(void *)(mlir::ValueRange::dereference_iterator(&v24, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v19, (uint64_t)v21, 1uLL);
  mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
  v22[0] = &unk_26C380E60;
  uint64_t v23 = v22;
  unsigned int v26 = &v24;
  uint64_t v24 = (const char *)&unk_26C380E60;
  if (v26 == &v24)
  {
    (*((void (**)(const char **))v24 + 4))(&v24);
    unint64_t v14 = v23;
    if (v23 != v22) {
      goto LABEL_5;
    }
LABEL_11:
    (*(void (**)(void *))(v22[0] + 32))(v22);
    if (v13) {
      goto LABEL_8;
    }
    goto LABEL_12;
  }
  if (v26) {
    (*((void (**)(const char **))*v26 + 5))(v26);
  }
  unint64_t v14 = v23;
  if (v23 == v22) {
    goto LABEL_11;
  }
LABEL_5:
  if (v14) {
    (*(void (**)(void *))(*v14 + 40))(v14);
  }
  if (v13)
  {
LABEL_8:
    uint64_t v15 = 1;
    uint64_t v16 = v20[0];
    if (v20[0] == v21) {
      return v15;
    }
    goto LABEL_13;
  }
LABEL_12:
  uint64_t v24 = "mps.square_root";
  uint64_t v25 = 15;
  uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v24, "' op inferred type(s) ", (uint64_t)v20, " are incompatible with return type(s) of operation ", a11);
  uint64_t v16 = v20[0];
  if (v20[0] != v21) {
LABEL_13:
  }
    free(v16);
  return v15;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SquareRootOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::SquareRootOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::SquareRootOpGenericAdaptorBase::SquareRootOpGenericAdaptorBase((uint64_t)v14, this);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)this);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ACosOp>,mlir::OpTrait::OneResult<mlir::mps::ACosOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ACosOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ACosOp>,mlir::OpTrait::OneOperand<mlir::mps::ACosOp>,mlir::OpTrait::OpInvariants<mlir::mps::ACosOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ACosOp>,mlir::OpTrait::Stitchable<mlir::mps::ACosOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ACosOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ACosOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::SquareRootOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::SqueezeOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SqueezeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SqueezeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SqueezeOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.squeeze", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SqueezeOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36F750;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SqueezeOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SqueezeOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SqueezeOp>::foldHook(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  unint64_t v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                      + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  char v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0) {
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v6 & 2) == 0) {
      llvm::deallocate_buffer(v8[0], v8[1]);
    }
  }
  return v5;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SqueezeOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::SqueezeOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::SqueezeOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SqueezeOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                       + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                       + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SqueezeOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SqueezeOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SqueezeOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::SqueezeOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x263EF8340];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SqueezeOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SqueezeOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SqueezeOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    uint64_t v10 = __p;
    if (__p)
    {
      uint64_t v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    uint64_t v13 = v29;
    if (v29)
    {
      unint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = *--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            MEMORY[0x21667D390](v16, 0x1000C8077774924);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SqueezeOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SqueezeOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::SqueezeOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SqueezeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::SqueezeOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SqueezeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SqueezeOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SqueezeOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SqueezeOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SqueezeOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::SqueezeOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SqueezeOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SqueezeOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::SqueezeOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::SqueezeOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v22 = v24;
  uint64_t v23 = 0x400000000;
  if (mlir::mps::SqueezeOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, v18, v19, (uint64_t)&v22))
  {
    mlir::ValueRange::ValueRange(v21, (uint64_t)v22, v23);
    mlir::ValueRange::ValueRange(v20, *(void *)a11, *(unsigned int *)(a11 + 8));
    v25[0] = &unk_26C380E60;
    unsigned int v26 = v25;
    int v28 = v27;
    v27[0] = &unk_26C380E60;
    if (v28 == v27)
    {
      (*(void (**)(void *))(v27[0] + 32))(v27);
      unint64_t v14 = v26;
      if (v26 != v25) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v28) {
        (*(void (**)(void *))(*v28 + 40))(v28);
      }
      unint64_t v14 = v26;
      if (v26 != v25)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v22;
          if (v22 == v24) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v25[0] + 32))(v25);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v27[0] = "mps.squeeze";
    v27[1] = 11;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v27, "' op inferred type(s) ", (uint64_t)&v22, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v22;
    if (v22 == v24) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v22;
  if (v22 != v24) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SqueezeOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SqueezeOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::SqueezeOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SqueezeOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::SqueezeOp>(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  mlir::mps::detail::SqueezeOpGenericAdaptorBase::SqueezeOpGenericAdaptorBase((uint64_t)v14, a1);
  uint64_t v15 = a2;
  uint64_t v16 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)a1);
  v13[0] = result;
  v13[1] = v9;
  if (result)
  {
    unint64_t v10 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v13, v15, v16);
    if (v10 < 8)
    {
      return 0;
    }
    else
    {
      if (a1 - 4 != (unsigned int *)(v10 & ((uint64_t)(v10 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v11 = *(unsigned int *)(a4 + 8);
        if (v11 >= *(_DWORD *)(a4 + 12))
        {
          unint64_t v12 = v10;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v11 + 1, 8);
          unint64_t v10 = v12;
          LODWORD(v11) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v11) = v10;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  v1 = &unk_267771000;
  {
    uint64_t v165 = a1;
    v1 = (void *)&unk_267771000;
    int v31 = v30;
    a1 = v165;
    if (v31)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v176 = 83;
      unint64_t v32 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v32) {
        unint64_t v33 = v32;
      }
      else {
        unint64_t v33 = v176;
      }
      uint64_t v34 = &v175[v33];
      unint64_t v35 = v176 - v33;
      if (v176 - v33 >= 0x12) {
        uint64_t v36 = 18;
      }
      else {
        uint64_t v36 = v176 - v33;
      }
      unint64_t v37 = v35 - v36;
      if (v37 >= v37 - 1) {
        uint64_t v38 = v37 - 1;
      }
      else {
        uint64_t v38 = v37;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v34[v36], v38);
      v1 = (void *)&unk_267771000;
      a1 = v165;
    }
  }
  uint64_t v2 = v1[23];
  char v3 = &unk_267771000;
  {
    uint64_t v156 = v2;
    uint64_t v166 = a1;
    char v3 = (void *)&unk_267771000;
    int v40 = v39;
    uint64_t v2 = v156;
    a1 = v166;
    if (v40)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v176 = 81;
      unint64_t v41 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v41) {
        unint64_t v42 = v41;
      }
      else {
        unint64_t v42 = v176;
      }
      unint64_t v43 = &v175[v42];
      unint64_t v44 = v176 - v42;
      if (v176 - v42 >= 0x12) {
        uint64_t v45 = 18;
      }
      else {
        uint64_t v45 = v176 - v42;
      }
      unint64_t v46 = v44 - v45;
      if (v46 >= v46 - 1) {
        uint64_t v47 = v46 - 1;
      }
      else {
        uint64_t v47 = v46;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v43[v45], v47);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v156;
      a1 = v166;
    }
  }
  uint64_t v4 = v3[25];
  unint64_t v5 = &unk_267771000;
  {
    uint64_t v157 = v2;
    uint64_t v167 = a1;
    uint64_t v148 = v4;
    unint64_t v5 = (void *)&unk_267771000;
    uint64_t v4 = v148;
    int v49 = v48;
    uint64_t v2 = v157;
    a1 = v167;
    if (v49)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      unint64_t v176 = 104;
      unint64_t v50 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v50) {
        unint64_t v51 = v50;
      }
      else {
        unint64_t v51 = v176;
      }
      unint64_t v52 = &v175[v51];
      unint64_t v53 = v176 - v51;
      if (v176 - v51 >= 0x12) {
        uint64_t v54 = 18;
      }
      else {
        uint64_t v54 = v176 - v51;
      }
      unint64_t v55 = v53 - v54;
      if (v55 >= v55 - 1) {
        uint64_t v56 = v55 - 1;
      }
      else {
        uint64_t v56 = v55;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      unint64_t v5 = (void *)&unk_267771000;
      uint64_t v4 = v148;
      uint64_t v2 = v157;
      a1 = v167;
    }
  }
  uint64_t v6 = v5[318];
  uint64_t v7 = &unk_267770000;
  {
    uint64_t v158 = v2;
    uint64_t v168 = a1;
    uint64_t v141 = v6;
    uint64_t v149 = v4;
    uint64_t v7 = (void *)&unk_267770000;
    uint64_t v6 = v141;
    uint64_t v4 = v149;
    int v58 = v57;
    uint64_t v2 = v158;
    a1 = v168;
    if (v58)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v176 = 86;
      unint64_t v59 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v59) {
        unint64_t v60 = v59;
      }
      else {
        unint64_t v60 = v176;
      }
      unint64_t v61 = &v175[v60];
      unint64_t v62 = v176 - v60;
      if (v176 - v60 >= 0x12) {
        uint64_t v63 = 18;
      }
      else {
        uint64_t v63 = v176 - v60;
      }
      unint64_t v64 = v62 - v63;
      if (v64 >= v64 - 1) {
        uint64_t v65 = v64 - 1;
      }
      else {
        uint64_t v65 = v64;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      uint64_t v7 = (void *)&unk_267770000;
      uint64_t v6 = v141;
      uint64_t v4 = v149;
      uint64_t v2 = v158;
      a1 = v168;
    }
  }
  uint64_t v8 = v7[431];
  uint64_t v9 = &unk_267771000;
  {
    uint64_t v159 = v2;
    uint64_t v169 = a1;
    uint64_t v142 = v6;
    uint64_t v150 = v4;
    uint64_t v135 = v8;
    uint64_t v9 = (void *)&unk_267771000;
    uint64_t v8 = v135;
    uint64_t v6 = v142;
    uint64_t v4 = v150;
    int v67 = v66;
    uint64_t v2 = v159;
    a1 = v169;
    if (v67)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>]";
      unint64_t v176 = 97;
      unint64_t v68 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v68) {
        unint64_t v69 = v68;
      }
      else {
        unint64_t v69 = v176;
      }
      unint64_t v70 = &v175[v69];
      unint64_t v71 = v176 - v69;
      if (v176 - v69 >= 0x12) {
        uint64_t v72 = 18;
      }
      else {
        uint64_t v72 = v176 - v69;
      }
      unint64_t v73 = v71 - v72;
      if (v73 >= v73 - 1) {
        uint64_t v74 = v73 - 1;
      }
      else {
        uint64_t v74 = v73;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      uint64_t v9 = (void *)&unk_267771000;
      uint64_t v8 = v135;
      uint64_t v6 = v142;
      uint64_t v4 = v150;
      uint64_t v2 = v159;
      a1 = v169;
    }
  }
  uint64_t v10 = v9[433];
  uint64_t v11 = &unk_267770000;
  {
    uint64_t v160 = v2;
    uint64_t v170 = a1;
    uint64_t v143 = v6;
    uint64_t v151 = v4;
    uint64_t v130 = v10;
    uint64_t v136 = v8;
    uint64_t v11 = (void *)&unk_267770000;
    uint64_t v10 = v130;
    uint64_t v8 = v136;
    uint64_t v6 = v143;
    uint64_t v4 = v151;
    int v76 = v75;
    uint64_t v2 = v160;
    a1 = v170;
    if (v76)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v176 = 84;
      unint64_t v77 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v77) {
        unint64_t v78 = v77;
      }
      else {
        unint64_t v78 = v176;
      }
      unint64_t v79 = &v175[v78];
      unint64_t v80 = v176 - v78;
      if (v176 - v78 >= 0x12) {
        uint64_t v81 = 18;
      }
      else {
        uint64_t v81 = v176 - v78;
      }
      unint64_t v82 = v80 - v81;
      if (v82 >= v82 - 1) {
        uint64_t v83 = v82 - 1;
      }
      else {
        uint64_t v83 = v82;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      uint64_t v11 = (void *)&unk_267770000;
      uint64_t v10 = v130;
      uint64_t v8 = v136;
      uint64_t v6 = v143;
      uint64_t v4 = v151;
      uint64_t v2 = v160;
      a1 = v170;
    }
  }
  uint64_t v12 = v11[435];
  char v13 = &unk_267771000;
  {
    uint64_t v161 = v2;
    uint64_t v171 = a1;
    uint64_t v144 = v6;
    uint64_t v152 = v4;
    uint64_t v131 = v10;
    uint64_t v137 = v8;
    uint64_t v126 = v12;
    char v13 = (void *)&unk_267771000;
    uint64_t v12 = v126;
    uint64_t v10 = v131;
    uint64_t v8 = v137;
    uint64_t v6 = v144;
    uint64_t v4 = v152;
    int v85 = v84;
    uint64_t v2 = v161;
    a1 = v171;
    if (v85)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v176 = 93;
      unint64_t v86 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v86) {
        unint64_t v87 = v86;
      }
      else {
        unint64_t v87 = v176;
      }
      unint64_t v88 = &v175[v87];
      unint64_t v89 = v176 - v87;
      if (v176 - v87 >= 0x12) {
        uint64_t v90 = 18;
      }
      else {
        uint64_t v90 = v176 - v87;
      }
      unint64_t v91 = v89 - v90;
      if (v91 >= v91 - 1) {
        uint64_t v92 = v91 - 1;
      }
      else {
        uint64_t v92 = v91;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      char v13 = (void *)&unk_267771000;
      uint64_t v12 = v126;
      uint64_t v10 = v131;
      uint64_t v8 = v137;
      uint64_t v6 = v144;
      uint64_t v4 = v152;
      uint64_t v2 = v161;
      a1 = v171;
    }
  }
  uint64_t v14 = v13[31];
  uint64_t v15 = &unk_267771000;
  {
    uint64_t v162 = v2;
    uint64_t v172 = a1;
    uint64_t v145 = v6;
    uint64_t v153 = v4;
    uint64_t v132 = v10;
    uint64_t v138 = v8;
    uint64_t v123 = v14;
    uint64_t v127 = v12;
    uint64_t v15 = (void *)&unk_267771000;
    uint64_t v14 = v123;
    uint64_t v12 = v127;
    uint64_t v10 = v132;
    uint64_t v8 = v138;
    uint64_t v6 = v145;
    uint64_t v4 = v153;
    int v94 = v93;
    uint64_t v2 = v162;
    a1 = v172;
    if (v94)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::TypeChanger<Empty>]";
      unint64_t v176 = 83;
      unint64_t v95 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v95) {
        unint64_t v96 = v95;
      }
      else {
        unint64_t v96 = v176;
      }
      unint64_t v97 = &v175[v96];
      unint64_t v98 = v176 - v96;
      if (v176 - v96 >= 0x12) {
        uint64_t v99 = 18;
      }
      else {
        uint64_t v99 = v176 - v96;
      }
      unint64_t v100 = v98 - v99;
      if (v100 >= v100 - 1) {
        uint64_t v101 = v100 - 1;
      }
      else {
        uint64_t v101 = v100;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::TypeChanger<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::TypeChanger>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      uint64_t v15 = (void *)&unk_267771000;
      uint64_t v14 = v123;
      uint64_t v12 = v127;
      uint64_t v10 = v132;
      uint64_t v8 = v138;
      uint64_t v6 = v145;
      uint64_t v4 = v153;
      uint64_t v2 = v162;
      a1 = v172;
    }
  }
  uint64_t v16 = v15[63];
  uint64_t v17 = &unk_267771000;
  {
    uint64_t v163 = v2;
    uint64_t v173 = a1;
    uint64_t v146 = v6;
    uint64_t v154 = v4;
    uint64_t v133 = v10;
    uint64_t v139 = v8;
    uint64_t v124 = v14;
    uint64_t v128 = v12;
    uint64_t v121 = v16;
    uint64_t v17 = (void *)&unk_267771000;
    uint64_t v16 = v121;
    uint64_t v14 = v124;
    uint64_t v12 = v128;
    uint64_t v10 = v133;
    uint64_t v8 = v139;
    uint64_t v6 = v146;
    uint64_t v4 = v154;
    int v103 = v102;
    uint64_t v2 = v163;
    a1 = v173;
    if (v103)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v176 = 90;
      unint64_t v104 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v104) {
        unint64_t v105 = v104;
      }
      else {
        unint64_t v105 = v176;
      }
      unint64_t v106 = &v175[v105];
      unint64_t v107 = v176 - v105;
      if (v176 - v105 >= 0x12) {
        uint64_t v108 = 18;
      }
      else {
        uint64_t v108 = v176 - v105;
      }
      unint64_t v109 = v107 - v108;
      if (v109 >= v109 - 1) {
        uint64_t v110 = v109 - 1;
      }
      else {
        uint64_t v110 = v109;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      uint64_t v17 = (void *)&unk_267771000;
      uint64_t v16 = v121;
      uint64_t v14 = v124;
      uint64_t v12 = v128;
      uint64_t v10 = v133;
      uint64_t v8 = v139;
      uint64_t v6 = v146;
      uint64_t v4 = v154;
      uint64_t v2 = v163;
      a1 = v173;
    }
  }
  uint64_t v18 = v17[37];
  uint64_t v19 = &unk_267771000;
  {
    uint64_t v164 = v2;
    uint64_t v174 = a1;
    uint64_t v147 = v6;
    uint64_t v155 = v4;
    uint64_t v134 = v10;
    uint64_t v140 = v8;
    uint64_t v125 = v14;
    uint64_t v129 = v12;
    uint64_t v120 = v18;
    uint64_t v122 = v16;
    uint64_t v19 = (void *)&unk_267771000;
    uint64_t v18 = v120;
    uint64_t v16 = v122;
    uint64_t v14 = v125;
    uint64_t v12 = v129;
    uint64_t v10 = v134;
    uint64_t v8 = v140;
    uint64_t v6 = v147;
    uint64_t v4 = v155;
    int v112 = v111;
    uint64_t v2 = v164;
    a1 = v174;
    if (v112)
    {
      uint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      unint64_t v176 = 100;
      unint64_t v113 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v113) {
        unint64_t v114 = v113;
      }
      else {
        unint64_t v114 = v176;
      }
      uint64_t v115 = &v175[v114];
      unint64_t v116 = v176 - v114;
      if (v176 - v114 >= 0x12) {
        uint64_t v117 = 18;
      }
      else {
        uint64_t v117 = v176 - v114;
      }
      unint64_t v118 = v116 - v117;
      if (v118 >= v118 - 1) {
        uint64_t v119 = v118 - 1;
      }
      else {
        uint64_t v119 = v118;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      uint64_t v19 = (void *)&unk_267771000;
      uint64_t v18 = v120;
      uint64_t v16 = v122;
      uint64_t v14 = v125;
      uint64_t v12 = v129;
      uint64_t v10 = v134;
      uint64_t v8 = v140;
      uint64_t v6 = v147;
      uint64_t v4 = v155;
      uint64_t v2 = v164;
      a1 = v174;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v19[41] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)1)) {
    return 0;
  }
  uint64_t v6 = a1;
  if (!mlir::mps::ReverseOp::verifyInvariantsImpl((mlir::mps::ReverseOp *)&v6)) {
    return 0;
  }
  uint64_t v6 = a1;
  return mlir::mps::SqueezeOp::verify((mlir::mps::SqueezeOp *)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::SqueezeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::StencilOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::StencilOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::StencilOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::StencilOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.stencil", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::StencilOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36F818;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  unint64_t v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  char v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0) {
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v6 & 2) == 0) {
      llvm::deallocate_buffer(v8[0], v8[1]);
    }
  }
  return v5;
}

void mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                       + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                       + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::mps::StencilOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::StencilOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::mps::StencilOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::StencilOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::getOpPropertyByteSize()
{
  return 64;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  if (a4)
  {
    long long v4 = *a4;
    long long v5 = a4[1];
    long long v6 = a4[3];
    *(_OWORD *)(a3 + 32) = a4[2];
    *(_OWORD *)(a3 + 48) = v6;
    *(_OWORD *)a3 = v4;
    *(_OWORD *)(a3 + 16) = v5;
  }
  else
  {
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
  }
  return mlir::mps::StencilOp::populateDefaultProperties(a2, (mlir::MLIRContext **)a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::mps::StencilOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::StencilOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::mps::StencilOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  long long v4 = *(_OWORD *)(a3 + 16);
  long long v5 = *(_OWORD *)(a3 + 48);
  *(_OWORD *)(a2 + 32) = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(a2 + 48) = v5;
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  if (*a3 != *a2) {
    return 0;
  }
  if (a3[1] != a2[1]) {
    return 0;
  }
  if (a3[2] != a2[2]) {
    return 0;
  }
  if (a3[3] != a2[3]) {
    return 0;
  }
  if (a3[4] != a2[4]) {
    return 0;
  }
  if (a3[5] != a2[5]) {
    return 0;
  }
  if (a3[6] == a2[6]) {
    return a3[7] == a2[7];
  }
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::StencilOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::StencilOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::StencilOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::StencilOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::StencilOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::StencilOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[1]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[2]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[3]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[4]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[5]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[6]);
  uint64_t v5 = v4[7];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 24);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::StencilOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::StencilOp>::getEffects;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::StencilOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::StencilOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::StencilOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::StencilOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::StencilOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::StencilOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::StencilOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::StencilOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::StencilOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::StencilOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, long long *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (mlir::mps::StencilOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    mlir::ValueRange::ValueRange(v19, (uint64_t)v20, v21);
    mlir::ValueRange::ValueRange(v18, *(void *)a11, *(unsigned int *)(a11 + 8));
    v23[0] = &unk_26C380E60;
    uint64_t v24 = v23;
    unsigned int v26 = v25;
    v25[0] = &unk_26C380E60;
    if (v26 == v25)
    {
      (*(void (**)(void *))(v25[0] + 32))(v25);
      unint64_t v14 = v24;
      if (v24 != v23) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v26) {
        (*(void (**)(void *))(*v26 + 40))(v26);
      }
      unint64_t v14 = v24;
      if (v24 != v23)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v20;
          if (v20 == v22) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v23[0] + 32))(v23);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v25[0] = "mps.stencil";
    v25[1] = 11;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v25, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v20;
    if (v20 == v22) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v20;
  if (v20 != v22) {
LABEL_12:
  }
    free(v16);
  return v15;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::StencilOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::StencilOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    unint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      char v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      unint64_t v14 = 86;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[21], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::StencilOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::StencilOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::StencilOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    unint64_t v10 = (long long *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  }
  else {
    unint64_t v10 = 0;
  }
  unint64_t v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v12 = 0;
    unint64_t v11 = 0;
  }
  mlir::ValueRange::ValueRange(v31, v12, v11);
  uint64_t v21 = v8;
  v22[0] = 0;
  char v23 = 0;
  long long v13 = v10[1];
  long long v24 = *v10;
  long long v25 = v13;
  long long v14 = v10[3];
  long long v26 = v10[2];
  long long v27 = v14;
  long long v28 = *(_OWORD *)v31;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v21);
    if (v23) {
      char v23 = 0;
    }
    mlir::OperationName::OperationName(v22, "mps.stencil", 11, Context);
    char v23 = 1;
  }
  uint64_t v29 = a2;
  uint64_t v30 = a3;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ExternalFoldInterface,mlir::Operation *,llvm::CastInfo<mlir::ExternalFoldInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  v31[0] = result;
  v31[1] = v17;
  if (result)
  {
    unint64_t v18 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v31, v29, v30);
    if (v18 < 8)
    {
      return 0;
    }
    else
    {
      unint64_t v19 = v18;
      if (a1 - 16 != (v18 & ((uint64_t)(v18 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
      {
        uint64_t v20 = *(unsigned int *)(a4 + 8);
        if (v20 >= *(_DWORD *)(a4 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v20 + 1, 8);
          LODWORD(v20) = *(_DWORD *)(a4 + 8);
        }
        *(void *)(*(void *)a4 + 8 * v20) = v19;
        ++*(_DWORD *)(a4 + 8);
      }
      return 1;
    }
  }
  return result;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)) {
    return 0;
  }
  unint64_t v6 = a1;
  if (!mlir::mps::StencilOp::verifyInvariantsImpl((mlir::mps::StencilOp *)&v6)) {
    return 0;
  }
  unint64_t v6 = a1;
  return mlir::mps::StencilOp::verify((mlir::mps::StencilOp *)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::StencilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x263EF8340];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::StridedSliceGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::StridedSliceGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::StridedSliceGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::StridedSliceGradientOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.strided_slice_gradient", 26, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::StridedSliceGradientOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      size_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_26C36A930;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_26C361F50;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }

  JUMPOUT(0x21667D3C0);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  unint64_t v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::StridedSliceGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<5u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::StridedSliceGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<5u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::StridedSliceGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<5u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::StridedSliceGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<5u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        unint64_t v11 = v13;
      }
      else {
        unint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::getCanonicalizationPatterns()
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::StridedSliceGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<5u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::StridedSliceGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<5u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::StridedSliceGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<5u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::StridedSliceGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<5u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  unint64_t v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::StridedSliceGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<5u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::StridedSliceGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<5u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::StridedSliceGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<5u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::StridedSliceGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<5u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  char v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0) {
        unint64_t v11 = v12;
      }
      else {
        unint64_t v11 = (llvm **)v12[0];
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v12[0], v12[1]);
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::StridedSliceGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<5u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::StridedSliceGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<5u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, size_t a4)
{
  int Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::mps::StridedSliceGradientOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::StridedSliceGradientOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  if (*v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"begin_mask", 10, *v5);
  }
  uint64_t v6 = v5[1];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"end_is_size", 11, v6);
  }
  uint64_t v7 = v5[2];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"end_mask", 8, v7);
  }
  uint64_t v8 = v5[3];
  if (v8)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"shrink_axis_mask", 16, v8);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::StridedSliceGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::getOpPropertyByteSize()
{
  return 32;
}

double mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::initProperties(uint64_t a1, uint64_t a2, long long *a3, long long *a4)
{
  if (a4)
  {
    long long v4 = *a4;
    long long v5 = a4[1];
    *a3 = *a4;
    a3[1] = v5;
  }
  else
  {
    *(void *)&long long v4 = 0;
    *a3 = 0u;
    a3[1] = 0u;
  }
  return *(double *)&v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::StridedSliceGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  int Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::mps::StridedSliceGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::copyProperties(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  long long v4 = *(_OWORD *)(a3 + 16);
  *a2 = *(_OWORD *)a3;
  a2[1] = v4;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  if (*a3 != *a2) {
    return 0;
  }
  if (a3[1] != a2[1]) {
    return 0;
  }
  if (a3[2] == a2[2]) {
    return a3[3] == a2[3];
  }
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::StridedSliceGradientOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::pdl_interp::FuncOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::StridedSliceGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x10uLL, 0x80040803F642BuLL);
  void *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::StridedSliceGradientOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::StridedSliceGradientOp>::writeProperties;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[312], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::StridedSliceGradientOp>::readProperties(uint64_t a1, uint64_t a2)
{
  char v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::StridedSliceGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::StridedSliceGradientOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 16))(a3, *v4);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[1]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 16))(a3, v4[2]);
  uint64_t v5 = v4[3];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::StridedSliceGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
  void *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::StridedSliceGradientOp>::getEffects;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[11], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::StridedSliceGradientOp>>(uint64_t a1)
{
  uint64_t v2 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  void *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::StridedSliceGradientOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::StridedSliceGradientOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::StridedSliceGradientOp>::isCompatibleReturnTypes;
  char v3 = &unk_267771000;
  {
    uint64_t v12 = v2;
    char v3 = (void *)&unk_267771000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      char v3 = (void *)&unk_267771000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[17], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::StridedSliceGradientOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::StridedSliceGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::StridedSliceGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::StridedSliceGradientOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::StridedSliceGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  v7[0] = &unk_26C380E60;
  unint64_t v10 = v9;
  unint64_t v8 = v7;
  v9[0] = &unk_26C380E60;
  if (v10 != v9)
  {
    if (v10) {
      (*(void (**)(void))(*v10 + 40))();
    }
    unint64_t v5 = v8;
    if (v8 != v7) {
      goto LABEL_5;
    }
LABEL_8:
    (*(void (**)(void *))(v7[0] + 32))(v7);
    return v4;
  }
  (*(void (**)(void *))(v9[0] + 32))(v9);
  unint64_t v5 = v8;
  if (v8 == v7) {
    goto LABEL_8;
  }
LABEL_5:
  if (v5) {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::StridedSliceGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t v22 = v24;
  uint64_t v23 = 0x400000000;
  if (mlir::mps::StridedSliceGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, v18, v19, (uint64_t)&v22))
  {
    mlir::ValueRange::ValueRange(v21, (uint64_t)v22, v23);
    mlir::ValueRange::ValueRange(v20, *(void *)a11, *(unsigned int *)(a11 + 8));
    v25[0] = &unk_26C380E60;
    long long v26 = v25;
    long long v28 = v27;
    v27[0] = &unk_26C380E60;
    if (v28 == v27)
    {
      (*(void (**)(void *))(v27[0] + 32))(v27);
      unint64_t v14 = v26;
      if (v26 != v25) {
        goto LABEL_6;
      }
    }
    else
    {
      if (v28) {
        (*(void (**)(void *))(*v28 + 40))(v28);
      }
      unint64_t v14 = v26;
      if (v26 != v25)
      {
LABEL_6:
        if (v14) {
          (*(void (**)(void *))(*v14 + 40))(v14);
        }
        if (v13)
        {
LABEL_9:
          uint64_t v15 = 1;
          uint64_t v16 = v22;
          if (v22 == v24) {
            return v15;
          }
          goto LABEL_12;
        }
        goto LABEL_16;
      }
    }
    (*(void (**)(void *))(v25[0] + 32))(v25);
    if (v13) {
      goto LABEL_9;
    }
LABEL_16:
    v27[0] = "mps.strided_slice_gradient";
    v27[1] = 26;
    uint64_t v15 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v27, "' op inferred type(s) ", (uint64_t)&v22, " are incompatible with return type(s) of operation ", a11);
    uint64_t v16 = v22;
    if (v22 == v24) {
      return v15;
    }
    goto LABEL_12;
  }
  uint64_t v15 = 0;
  uint64_t v16 = v22;
  if (v22 != v24) {
LABEL_12:
  }
    free(v16);
  return v15;
}