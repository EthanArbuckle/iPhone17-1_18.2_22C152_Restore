uint64_t ttseg_loc_ProcessLoop(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Str;
  uint64_t v11;
  unint64_t v12;
  char **v13;
  unsigned int v14;
  unsigned int v15;
  BOOL v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char **v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t (*v44)(void, uint64_t, void, void, uint64_t);
  int v45;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  unint64_t v53;
  uint64_t *v54;
  size_t v55;
  uint64_t v56;
  char *v57;
  char *v58;
  uint64_t v59;
  const char *v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  unsigned int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  char *v78;
  char *v79;
  void *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t (*v86)(void, char *);
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  const char *v98;
  uint64_t v99;
  _WORD *v100;
  uint64_t inited;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  int v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  unint64_t v123;
  unint64_t v124;
  uint64_t v125;
  unsigned int v126;
  unint64_t v127;
  int v128;
  uint64_t v129;
  int v130;
  int v131;
  int *v135;
  void *v136;
  char v137;
  int v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  unint64_t v145;
  unsigned int v146;
  uint64_t v147;
  int *v148;
  int v149;
  uint64_t v150;
  uint64_t v153;
  uint64_t v154;
  int v155;
  unint64_t v156;
  unsigned int *v157;
  unsigned int v158;
  void *v159;
  uint64_t v160;
  _DWORD *v161;
  uint64_t v162;
  uint64_t v163;
  _DWORD *v164;
  char *v165;
  void *v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  void *v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  const char *v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  unsigned int v181;
  unsigned int v182;
  int v183;
  uint64_t *v184;
  int v185;
  char *v186;
  char *v187;
  const char *v188;
  int v189;
  char *v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  char *v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  int *v248;
  int v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  int v257;
  uint64_t v259;
  const char *v260;
  uint64_t v261;
  uint64_t v263;
  uint64_t v264;
  uint64_t *v265;
  BOOL v266;
  unsigned int v267;
  _DWORD *v268;
  uint64_t *v269;
  BOOL v270;
  char *__dst;
  char *__dsta;
  char *__s2;
  uint64_t v274;
  unsigned __int8 *v275;
  char *v276;
  char *__s;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  char *v281;
  char *v282[2];
  long long v283;
  long long v284;
  long long v285;
  long long v286;
  long long v287;
  long long v288;
  long long v289;
  long long v290;
  long long v291;
  long long v292;
  long long v293;
  long long v294;
  long long v295;
  long long v296;
  long long v297;
  void *__src[2];
  long long v299;
  long long v300;
  long long v301;
  long long v302;
  long long v303;
  long long v304;
  long long v305;
  long long v306;
  long long v307;
  long long v308;
  long long v309;
  long long v310;
  long long v311;
  long long v312;
  long long v313;
  long long v314;
  long long v315;
  long long v316;
  long long v317;
  long long v318;
  int v319;
  size_t __len[2];
  long long v321;
  long long v322;
  long long v323;
  long long v324;
  long long v325;
  long long v326;
  long long v327;
  long long v328;
  long long v329;
  long long v330;
  long long v331;
  long long v332;
  long long v333;
  long long v334;
  long long v335;
  void v336[3];

  Str = 0;
  __s2 = (char *)(a1 + 508);
  v336[1] = *MEMORY[0x263EF8340];
  v11 = *(void *)(a1 + 248);
  v269 = (uint64_t *)(a1 + 320);
  v12 = *(unsigned __int16 *)(a1 + 404);
  v268 = (_DWORD *)(a1 + 440);
  v13 = ttseg_loc_ProcessLoop_RESULTS_STR;
  v267 = 1;
  while (1)
  {
    if (*(_DWORD *)(a1 + 104) == 6)
    {
      log_OutText(*(void *)(v11 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Speaking is interrupted", a6, a7, a8, v263);
      Str = 2166368263;
      goto LABEL_351;
    }
    v14 = *(_DWORD *)(a1 + 400) + 1;
    *(_DWORD *)(a1 + 400) = v14;
    v15 = *(_DWORD *)(a1 + 112);
    if (v15) {
      v16 = v14 > v15;
    }
    else {
      v16 = 0;
    }
    if (v16)
    {
      log_OutPublic(*(void *)(v11 + 32), (uint64_t)"TTSEG", 16103, "%s%u", a5, a6, a7, a8, "loops");
      Str = 2166368269;
      goto LABEL_351;
    }
    v17 = *(unsigned __int16 *)(a1 + 404);
    v18 = *(uint64_t **)(*(void *)(*(void *)(a1 + 232) + 16) + 8 * v17);
    if (a2 != 1 || v17 != v12) {
      break;
    }
LABEL_38:
    log_OutText(*(void *)(v11 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Process for %s returned %s %x", a6, a7, a8, v18[1]);
    v50 = *(void *)(a1 + 408);
    v51 = *(unsigned __int16 *)(a1 + 404);
    v52 = *(_DWORD *)(v50 + 4 * v51);
    if (v52 != 3)
    {
      v53 = *(unsigned __int16 *)(a1 + 404);
      if (v52) {
        goto LABEL_62;
      }
      goto LABEL_69;
    }
    if (*(_DWORD *)(a1 + 240) == 2)
    {
      v52 = 3;
      v53 = *(unsigned __int16 *)(a1 + 404);
      goto LABEL_63;
    }
    v54 = *(uint64_t **)(a1 + 248);
    v276 = 0;
    __s = 0;
    v274 = 0;
    v275 = 0;
    v296 = 0u;
    v297 = 0u;
    v294 = 0u;
    v295 = 0u;
    v292 = 0u;
    v293 = 0u;
    v290 = 0u;
    v291 = 0u;
    v288 = 0u;
    v289 = 0u;
    v286 = 0u;
    v287 = 0u;
    v284 = 0u;
    v285 = 0u;
    *(_OWORD *)v282 = 0u;
    v283 = 0u;
    Str = 0;
    if ((paramc_ParamGetStr(v54[5], (uint64_t)"pipelineswitchvoice", &__s) & 0x80000000) != 0 || !__s) {
      goto LABEL_60;
    }
    if (!*__s) {
      goto LABEL_59;
    }
    v270 = 0;
    if ((paramc_ParamGetStr(v54[5], (uint64_t)"vsvoicetagwithlangunknow", &v275) & 0x80000000) == 0 && v275) {
      v270 = *v275 != 0;
    }
    if ((paramc_ParamGetStr(v54[5], (uint64_t)"voice", &v276) & 0x80000000) != 0)
    {
LABEL_59:
      Str = 0;
      goto LABEL_60;
    }
    Str = 2166366218;
    v55 = strlen(__s);
    v56 = v55 >= 0x200 ? v55 + 1 : 512;
    v57 = (char *)heap_Calloc((void *)v54[1], v56, 1);
    if (!v57)
    {
LABEL_60:
      *(_DWORD *)(*(void *)(a1 + 408) + 4 * *(unsigned __int16 *)(a1 + 404)) = 1;
      goto LABEL_61;
    }
    v58 = strcpy(v57, __s);
    v59 = *(void *)(a1 + 576);
    v60 = v58;
    v61 = v276;
    __src[0] = 0;
    __dst = v58;
    if (!strcmp(v58, "(pop)"))
    {
      Str = tinystack_Pop(v59, __src);
      if ((Str & 0x80000000) != 0 || !__src[0])
      {
        log_OutText(v54[4], (uint64_t)"TTSEG", 3, 0, (uint64_t)"Bad voice stack status", v68, v69, v70, v263);
        v65 = (uint64_t)__dst;
        if ((Str & 0x80000000) != 0)
        {
          v137 = 1;
          goto LABEL_247;
        }
      }
      else
      {
        v65 = (uint64_t)__dst;
        strcpy(__dst, (const char *)__src[0]);
        heap_Free((void *)v54[1], (uint64_t)__src[0]);
        log_OutText(v54[4], (uint64_t)"TTSEG", 3, 0, (uint64_t)"Pop voice from voice stack: %s", v71, v72, v73, (uint64_t)__dst);
      }
    }
    else
    {
      if (!strcmp(v60, "(push)"))
      {
        log_OutText(v54[4], (uint64_t)"TTSEG", 3, 0, (uint64_t)"Push current voice %s to voice stack", v62, v63, v64, (uint64_t)v61);
        v136 = strhelper_Strdup(v54[1], v61);
        if (v136) {
          Str = tinystack_Push(v59, (uint64_t)v136);
        }
LABEL_171:
        v137 = 1;
LABEL_246:
        v65 = (uint64_t)__dst;
        goto LABEL_247;
      }
      Str = 0;
      v65 = (uint64_t)__dst;
    }
    v74 = strhelper_SafeStrtok(v65, ",", &v274);
    if (!v74) {
      goto LABEL_171;
    }
    v78 = v74;
    v265 = v54;
    while (1)
    {
      log_OutText(v54[4], (uint64_t)"TTSEG", 3, 0, (uint64_t)"Consider switch to %s", v75, v76, v77, (uint64_t)v78);
      v79 = v276;
      v80 = *(void **)(a1 + 248);
      v335 = 0u;
      v334 = 0u;
      v333 = 0u;
      v332 = 0u;
      v331 = 0u;
      v330 = 0u;
      v329 = 0u;
      v328 = 0u;
      v326 = 0u;
      v327 = 0u;
      v324 = 0u;
      v325 = 0u;
      v322 = 0u;
      v323 = 0u;
      *(_OWORD *)__len = 0u;
      v321 = 0u;
      v319 = 0;
      v317 = 0u;
      v318 = 0u;
      v315 = 0u;
      v316 = 0u;
      v313 = 0u;
      v314 = 0u;
      v311 = 0u;
      v312 = 0u;
      v309 = 0u;
      v310 = 0u;
      v307 = 0u;
      v308 = 0u;
      v305 = 0u;
      v306 = 0u;
      v303 = 0u;
      v304 = 0u;
      v301 = 0u;
      v302 = 0u;
      v299 = 0u;
      v300 = 0u;
      *(_OWORD *)__src = 0u;
      if (!v276 || LH_stricmp(v78, v276) | v270)
      {
        if (strlen(v78) - 31 < 0xFFFFFFFFFFFFFFE0)
        {
          v85 = 16121;
LABEL_93:
          log_OutPublic(v80[4], (uint64_t)"TTSEG", v85, "%s%s", v84, v81, v82, v83, "voice");
          Str = 0;
LABEL_94:
          v65 = (uint64_t)__dst;
          goto LABEL_133;
        }
        if (!*(void *)(*(void *)(a1 + 32) + 32))
        {
          v85 = 16122;
          goto LABEL_93;
        }
      }
      log_OutText(v80[4], (uint64_t)"TTSEG", 3, 0, (uint64_t)"Calling the voice switch callback with argument %s", v81, v82, v83, (uint64_t)v78);
      v86 = *(uint64_t (**)(void, char *))(a1 + 80);
      if (v86)
      {
        v87 = v86(*(void *)(a1 + 88), v78);
        Str = v87;
        if ((v87 & 0x80000000) != 0)
        {
          v95 = v87 & 0x1FFF;
          v96 = v80[4];
          if (v95 != 7858)
          {
            log_OutPublic(v96, (uint64_t)"TTSEG", 16000, "%s%x", v88, v89, v90, v91, "lherror");
LABEL_245:
            v137 = 1;
            v13 = ttseg_loc_ProcessLoop_RESULTS_STR;
            goto LABEL_246;
          }
          log_OutText(v96, (uint64_t)"TTSEG", 0, 0, (uint64_t)"Voice switch to '%s' is not allowed by user callback", v89, v90, v91, (uint64_t)v78);
          goto LABEL_94;
        }
        if (v79)
        {
LABEL_86:
          v266 = LH_stricmp(v78, v79) == 0;
          goto LABEL_89;
        }
      }
      else
      {
        Str = 0;
        if (v79) {
          goto LABEL_86;
        }
      }
      v266 = 0;
LABEL_89:
      if (!strcmp(v78, "__NUAN_Normal"))
      {
        v65 = (uint64_t)__dst;
        if (*(void *)(a1 + 544))
        {
          __strcpy_chk();
          goto LABEL_236;
        }
        goto LABEL_132;
      }
      v278 = 0;
      v279 = 0;
      *(_OWORD *)__src = 0u;
      v299 = 0u;
      v300 = 0u;
      v301 = 0u;
      v302 = 0u;
      v303 = 0u;
      v304 = 0u;
      v305 = 0u;
      v306 = 0u;
      v307 = 0u;
      v308 = 0u;
      v309 = 0u;
      v310 = 0u;
      v311 = 0u;
      v312 = 0u;
      v313 = 0u;
      v314 = 0u;
      v315 = 0u;
      v316 = 0u;
      v317 = 0u;
      v318 = 0u;
      v319 = 0;
      paramc_ParamGetUInt(v80[5], (uint64_t)"frequencyhz", (unsigned int *)&v309 + 2);
      __strcpy_chk();
      paramc_ParamGetStr(v80[5], (uint64_t)"voicemodel", &v279);
      paramc_ParamGetStr(v80[5], (uint64_t)"voiceoperatingpoint", &v278);
      if (v278 || v279) {
        __strcpy_chk();
      }
      if (((*(uint64_t (**)(void, void, void, void, void **))(*(void *)(*(void *)(a1 + 32) + 32)
                                                                               + 112))(*(void *)(*(void *)(a1 + 32) + 40), *(void *)(*(void *)(a1 + 32) + 48), v80[3], v80[5], __src) & 0x80000000) != 0&& (BYTE12(v309) = 0, BYTE12(v311) = 0, ((*(uint64_t (**)(void, void, void, void, void **))(*(void *)(*(void *)(a1 + 32) + 32)+ 96))(*(void *)(*(void *)(a1 + 32) + 40), *(void *)(*(void *)(a1 + 32) + 48), v80[3], v80[5], __src) & 0x80000000) != 0)|| ((*(uint64_t (**)(void, void, void **, uint64_t, size_t *))(*(void *)(*(void *)(a1 + 32)+ 32)+ 104))(*(void *)(*(void *)(a1 + 32) + 40), *(void *)(*(void *)(a1 + 32) + 48),
              __src,
              256,
              __len) & 0x80000000) != 0)
      {
        if (!v270) {
          log_OutPublic(v80[4], (uint64_t)"TTSEG", 16123, "%s%s", v97, v92, v93, v94, "voice");
        }
        Str = 0;
        goto LABEL_131;
      }
      LH_stricmp((char *)__len, *(char **)(*(void *)(a1 + 232) + 8));
      v264 = *(unsigned __int16 *)(a1 + 404);
      v98 = *(const char **)(*(void *)(*(void *)(*(void *)(a1 + 232) + 16) + 8 * v264) + 8);
      v100 = *(_WORD **)a1;
      v99 = *(void *)(a1 + 8);
      v280 = 0;
      v281 = 0;
      v336[0] = 0;
      inited = InitRsrcFunction(v100, v99, &v281);
      if ((inited & 0x80000000) != 0)
      {
        LODWORD(v98) = 0;
        v54 = v265;
LABEL_126:
        if (!v270) {
          log_OutPublic(v80[4], (uint64_t)"TTSEG", 16123, "%s%s", v102, v103, v104, v105, "voice");
        }
        Str = 0;
        goto LABEL_129;
      }
      if (!v98)
      {
        Str = inited;
LABEL_118:
        v54 = v265;
        goto LABEL_123;
      }
      Str = pipeline_ListPipelineComponentNames(v100, v99, (char *)__len, &v280);
      if ((Str & 0x80000000) != 0)
      {
        log_OutText(*((void *)v281 + 4), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Unable to get pipeline components for '%s'", v106, v107, v108, (uint64_t)__len);
        LODWORD(v98) = 0;
        goto LABEL_118;
      }
      v54 = v265;
      if (v264 >= (unsigned __int16)vector_GetSize(v280))
      {
        log_OutText(*((void *)v281 + 4), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Candidate pipeline '%s' is not compatible: too few components", v109, v110, v111, (uint64_t)__len);
        goto LABEL_122;
      }
      if (!vector_GetElemAt(v280, v264, v336))
      {
        log_OutText(*((void *)v281 + 4), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Unable to get component at index %u in pipeline '%s'", v112, v113, v114, v264);
        goto LABEL_122;
      }
      if (!*(void *)v336[0])
      {
        log_OutText(*((void *)v281 + 4), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Pipeline component at index %u in pipeline '%s' is NULL", v112, v113, v114, v264);
        goto LABEL_122;
      }
      v118 = strcmp(v98, *(const char **)v336[0]);
      v119 = *((void *)v281 + 4);
      if (v118)
      {
        log_OutText(v119, (uint64_t)"TTSEG", 4, 0, (uint64_t)"Candidate pipeline '%s' is not compatible: different component at index %u", v115, v116, v117, (uint64_t)__len);
LABEL_122:
        LODWORD(v98) = 0;
        goto LABEL_123;
      }
      log_OutText(v119, (uint64_t)"TTSEG", 4, 0, (uint64_t)"Candidate pipeline '%s' is compatible", v115, v116, v117, (uint64_t)__len);
      LODWORD(v98) = 1;
LABEL_123:
      if (v280) {
        vector_ObjClose(v280);
      }
      if ((Str & 0x80000000) != 0) {
        goto LABEL_126;
      }
LABEL_129:
      if (v98) {
        break;
      }
      log_OutText(v80[4], (uint64_t)"TTSEG", 1, 0, (uint64_t)"Destination pipeline '%s' is not compatible with current pipeline '%s': voice switch should not take place", v103, v104, v105, (uint64_t)__len);
LABEL_131:
      v65 = (uint64_t)__dst;
LABEL_132:
      if (v266) {
        goto LABEL_237;
      }
LABEL_133:
      v78 = strhelper_SafeStrtok(v65, ",", &v274);
      if (!v78) {
        goto LABEL_245;
      }
    }
    v65 = (uint64_t)__dst;
LABEL_236:
    __strcpy_chk();
LABEL_237:
    log_OutText(v54[4], (uint64_t)"TTSEG", 3, 0, (uint64_t)"Preparing for a switch to %s", v92, v93, v94, (uint64_t)v282);
    v172 = paramc_ParamSetStr(v54[5], (uint64_t)"pipelineswitchcomponent", *(char **)(*(void *)(*(void *)(*(void *)(a1 + 232) + 16) + 8 * *(unsigned __int16 *)(a1 + 404))+ 8));
    v13 = ttseg_loc_ProcessLoop_RESULTS_STR;
    if ((v172 & 0x80000000) != 0
      || (!strcmp(*(const char **)(*(void *)(*(void *)(*(void *)(a1 + 232) + 16)+ 8 * *(unsigned __int16 *)(a1 + 404))+ 8), "voice_switch")? (v177 = "pipelineswitchvspipeline"): (v177 = "pipelineswitchpipeline"), v172 = paramc_ParamSetStr(v54[5], (uint64_t)v177, (char *)v282), (v172 & 0x80000000) != 0))
    {
      Str = v172;
      log_OutPublic(v54[4], (uint64_t)"TTSEG", 16000, "%s%x", v173, v174, v175, v176, "lherror");
      v137 = 0;
    }
    else
    {
      Str = ttseg_loc_ProcessEnd(a1, *(unsigned __int16 *)(a1 + 404), (unsigned __int16)(*(_WORD *)(a1 + 404) + 1), 0, v173, v174, v175, v176);
      v137 = 0;
    }
LABEL_247:
    heap_Free((void *)v54[1], v65);
    if ((v137 & 1) != 0 || (Str & 0x80000000) != 0) {
      goto LABEL_60;
    }
LABEL_61:
    v50 = *(void *)(a1 + 408);
    v53 = *(unsigned __int16 *)(a1 + 404);
    v52 = *(_DWORD *)(v50 + 4 * v53);
    LODWORD(v51) = *(unsigned __int16 *)(a1 + 404);
    if (!v52) {
      goto LABEL_69;
    }
LABEL_62:
    if (v52 == 4) {
      goto LABEL_265;
    }
LABEL_63:
    v66 = v51 + 1;
    v67 = *(unsigned __int16 *)(*(void *)(a1 + 232) + 24);
    if ((int)v51 + 1 < v67)
    {
      *(_WORD *)(a1 + 404) = v66;
      goto LABEL_265;
    }
    if (v66 == v67 && *(void *)(a1 + 360))
    {
      Str = ttseg_loc_PutOutput(a1, 0, v48, v49, a5, a6, a7, a8);
      if ((Str & 0x80000000) != 0) {
        goto LABEL_265;
      }
      v50 = *(void *)(a1 + 408);
      v53 = *(unsigned __int16 *)(a1 + 404);
      v52 = *(_DWORD *)(v50 + 4 * v53);
      LODWORD(v51) = *(unsigned __int16 *)(a1 + 404);
    }
LABEL_69:
    if (v51 && (v52 & 0xFFFFFFFE) != 2)
    {
      if (a2 != 1) {
        goto LABEL_268;
      }
LABEL_272:
      if (v53 <= v12)
      {
        if (v12 == (unsigned __int16)v53) {
          goto LABEL_346;
        }
        goto LABEL_278;
      }
LABEL_268:
      while (1)
      {
        *(_WORD *)(a1 + 404) = --v53;
        v52 = *(_DWORD *)(v50 + 4 * (unsigned __int16)v53);
        if (!(_WORD)v53 || (v52 & 0xFFFFFFFE) == 2) {
          break;
        }
        if (a2 == 1)
        {
          LOWORD(v51) = v53;
          goto LABEL_272;
        }
      }
      LOWORD(v51) = v53;
      v53 = (unsigned __int16)v53;
    }
    if (a2 == 1 && v12 == (unsigned __int16)v51)
    {
LABEL_346:
      log_OutText(*(void *)(v11 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Returning to Process for %s", a6, a7, a8, *(void *)(*(void *)(*(void *)(*(void *)(a1 + 232) + 16) + 8 * v53) + 8));
      goto LABEL_352;
    }
LABEL_278:
    if (v52 != 3 || *(_DWORD *)(a1 + 240) == 2) {
      goto LABEL_321;
    }
    v184 = *(uint64_t **)(a1 + 248);
    __len[0] = 0;
    v281 = 0;
    v282[0] = 0;
    LODWORD(v280) = 0;
    if ((paramc_ParamGetStr(v184[5], (uint64_t)"pipelineswitchpipeline", v282) & 0x80000000) != 0
      || !v282[0]
      || !*v282[0])
    {
      Str = paramc_ParamGetStr(v184[5], (uint64_t)"pipelineswitchvspipeline", __len);
      if ((Str & 0x80000000) != 0 || !__len[0] || !*(unsigned char *)__len[0]) {
        goto LABEL_320;
      }
      v189 = strlen((const char *)__len[0]);
      v190 = (char *)heap_Alloc(v184[1], (v189 + 1));
      if (v190)
      {
        v187 = v190;
        strcpy(v190, (const char *)__len[0]);
        v188 = "pipelineswitchvspipeline";
        goto LABEL_290;
      }
LABEL_303:
      Str = 2166366218;
      v13 = ttseg_loc_ProcessLoop_RESULTS_STR;
      goto LABEL_320;
    }
    v185 = strlen(v282[0]);
    v186 = (char *)heap_Alloc(v184[1], (v185 + 1));
    if (!v186) {
      goto LABEL_303;
    }
    v187 = v186;
    strcpy(v186, v282[0]);
    v188 = "pipelineswitchpipeline";
LABEL_290:
    paramc_ParamSetStr(v184[5], (uint64_t)v188, 0);
    paramc_ParamSetUInt(v184[5], (uint64_t)"pipelineswitchexecuting", 1u);
    log_OutText(v184[4], (uint64_t)"TTSEG", 3, 0, (uint64_t)"Execute switch to %s", v191, v192, v193, (uint64_t)v187);
    log_OutText(v184[4], (uint64_t)"TTSEG", 99, 0, (uint64_t)"PIPELINE SWITCH %s", v194, v195, v196, (uint64_t)v187);
    v201 = ttseg_loc_ProcessEnd(a1, (unsigned __int16)(*(_WORD *)(a1 + 404) + 1), *(unsigned __int16 *)(*(void *)(a1 + 232) + 24), 1, v197, v198, v199, v200);
    if ((v201 & 0x80000000) == 0)
    {
      v201 = ttseg_loc_CloseOutputStreams(a1, v202, v203, v204, v205, v206, v207, v208);
      if ((v201 & 0x80000000) == 0) {
        v201 = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 128) + 160))(*(void *)(a1 + 272), *(void *)(a1 + 280), (unsigned __int16)(*(_WORD *)(a1 + 404) + 1));
      }
    }
    Str = v201;
    paramc_ParamSetStr(v184[5], (uint64_t)"fedatapackaging", byte_20D6B212C);
    if (!*(void *)(a1 + 544)) {
      *(void *)(a1 + 544) = *(void *)(a1 + 232);
    }
    if ((Str & 0x80000000) != 0) {
      goto LABEL_319;
    }
    if (!LH_stricmp(v187, *(char **)(*(void *)(a1 + 232) + 8)))
    {
      v225 = *(char **)(a1 + 232);
      v281 = v225;
      goto LABEL_305;
    }
    v216 = *(void *)(a1 + 544);
    if (v216 && !LH_stricmp(v187, *(char **)(v216 + 8)))
    {
      v225 = *(char **)(a1 + 544);
      v281 = v225;
      v227 = pipeline_ObjReopen((uint64_t)v225, v217, v218, v219, v220, v221, v222, v223);
      if ((v227 & 0x80000000) == 0) {
        goto LABEL_305;
      }
      goto LABEL_318;
    }
    v224 = pipeline_ObjOpen(*(_WORD **)a1, *(void *)(a1 + 8), v187, *(void *)(a1 + 232), *(unsigned __int16 *)(a1 + 404), *(void *)(a1 + 120), (uint64_t **)&v281, &v280);
    if ((v224 & 0x80000000) != 0)
    {
      Str = v224;
      goto LABEL_319;
    }
    v225 = v281;
    if (*(_DWORD *)(a1 + 192) == 1)
    {
      if (ttseg_loc_LicensingModePipeline((uint64_t)v184, a1, (uint64_t)v281))
      {
        v225 = v281;
        goto LABEL_305;
      }
      log_OutPublic(v184[4], (uint64_t)"TTSEG", 16124, "%s%s", v212, v213, v214, v215, "pipeline");
      pipeline_ObjClose((uint64_t)v281, v250, v251, v252, v253, v254, v255, v256);
      v281 = 0;
      Str = 2166373638;
      goto LABEL_319;
    }
LABEL_305:
    v226 = *(void *)(a1 + 232);
    if ((char *)v226 == v225 || v226 == *(void *)(a1 + 544))
    {
      *(void *)(a1 + 232) = v225;
    }
    else
    {
      v227 = pipeline_ObjClose(v226, v209, v210, v211, v212, v213, v214, v215);
      v225 = v281;
      *(void *)(a1 + 232) = v281;
      if ((v227 & 0x80000000) != 0)
      {
LABEL_318:
        Str = v227;
        goto LABEL_319;
      }
    }
    v228 = *((unsigned __int16 *)v225 + 12);
    if (v228 > *(unsigned __int16 *)(a1 + 416))
    {
      v229 = heap_Realloc((uint64_t *)v184[1], *(void *)(a1 + 408), 4 * v228);
      if (!v229)
      {
        Str = 2166366218;
        log_OutPublic(v184[4], (uint64_t)"TTSEG", 16000, 0, v230, v231, v232, v233, v263);
        goto LABEL_319;
      }
      *(void *)(a1 + 408) = v229;
      *(_WORD *)(a1 + 416) = *((_WORD *)v281 + 12);
    }
    v234 = v184[5];
    __dsta = (char *)v184[4];
    __src[0] = 0;
    paramc_ParamGetStr(v234, (uint64_t)"language", __src);
    v235 = v184[5];
    __src[0] = 0;
    paramc_ParamGetStr(v235, (uint64_t)"voice", __src);
    v236 = v184[5];
    __src[0] = 0;
    paramc_ParamGetStr(v236, (uint64_t)"voicemodel", __src);
    v237 = v184[5];
    __src[0] = 0;
    paramc_ParamGetStr(v237, (uint64_t)"langversion", __src);
    v238 = v184[5];
    __src[0] = 0;
    paramc_ParamGetStr(v238, (uint64_t)"voiceversion", __src);
    v239 = v184[5];
    __src[0] = 0;
    paramc_ParamGetStr(v239, (uint64_t)"applicationname", __src);
    log_OutEvent((uint64_t **)__dsta, 16, "%s%s%s%s%s%s%s%u%s%s%s%s%s%s%s%s", v240, v241, v242, v243, v244, "LANG");
    v245 = ttseg_loc_ProcessStart(a1, 0, 0, *(unsigned __int16 *)(a1 + 404), *(unsigned __int16 *)(*(void *)(a1 + 232) + 24));
    if ((v245 & 0x80000000) == 0) {
      v245 = ttseg_loc_OpenOutputStreams((void *)a1);
    }
    Str = v245;
LABEL_319:
    paramc_ParamSetUInt(v184[5], (uint64_t)"pipelineswitchexecuting", 0);
    heap_Free((void *)v184[1], (uint64_t)v187);
    v13 = ttseg_loc_ProcessLoop_RESULTS_STR;
LABEL_320:
    LOWORD(v51) = *(_WORD *)(a1 + 404);
LABEL_321:
    if ((_WORD)v51 || **(_DWORD **)(a1 + 408) == 2) {
      goto LABEL_265;
    }
    v246 = *(void *)(a1 + 232);
    if (*(void *)(a1 + 320))
    {
      *(_DWORD *)(a1 + 400) = 0;
      Str = ttseg_loc_GetInputIntoStream(v11, *(uint64_t (**)(uint64_t, unsigned int *, unsigned char *))(a1 + 344), *(void *)(a1 + 352), *(void *)(a1 + 128), v269, *(void *)(v246 + 32), *(void *)(v246 + 40), v268);
      if ((Str & 0x1FFF) != 3) {
        goto LABEL_265;
      }
      Str = 0;
      v246 = *(void *)(a1 + 232);
    }
    v247 = *(unsigned __int16 *)(v246 + 24);
    if (!v247)
    {
LABEL_335:
      if (a2 != 2) {
        goto LABEL_351;
      }
      v257 = critsec_Enter(*(void **)(a1 + 96));
      if ((v257 & 0x80000000) == 0)
      {
        if (*(_DWORD *)(a1 + 104) == 4) {
          *(_DWORD *)(a1 + 104) = 5;
        }
        v257 = critsec_Leave(*(void **)(a1 + 96));
      }
      if ((int)Str > -1 && v257 < 0) {
        return v257;
      }
      else {
        return Str;
      }
    }
    v248 = *(int **)(a1 + 408);
    while (1)
    {
      v249 = *v248++;
      if (v249 != 1) {
        break;
      }
      if (!--v247) {
        goto LABEL_335;
      }
    }
LABEL_265:
    if (a2 == 2) {
      return Str;
    }
LABEL_266:
    if ((Str & 0x80000000) != 0) {
      goto LABEL_351;
    }
  }
  *(_DWORD *)(*(void *)(a1 + 408) + 4 * v17) = 0;
  log_OutText(*(void *)(v11 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Calling Process for %s", a6, a7, a8, v18[1]);
  v24 = *(void *)(a1 + 232);
  v25 = *(void *)(v24 + 32);
  if (v25) {
    compstats_Start(v25, *(void *)(v24 + 40), *(unsigned __int16 *)(a1 + 404) + 2, v19, v20, v21, v22, v23);
  }
  v26 = (const char *)v18[1];
  if (*(_DWORD *)(a1 + 240) != 2)
  {
LABEL_20:
    kaldi::nnet1::Component::IsUpdatable(*(kaldi::nnet1::Component **)(v11 + 40));
    Str = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t))(v18[2] + 104))(v18[3], v18[4], *(void *)(a1 + 296), *(void *)(a1 + 304), *(void *)(a1 + 408) + 4 * *(unsigned __int16 *)(a1 + 404));
    kaldi::nnet1::Component::IsUpdatable(*(kaldi::nnet1::Component **)(v11 + 40));
    if (*(_DWORD *)(a1 + 240) == 2
      && ttseg_loc_ComponentIsTextParser((const char *)v18[1])
      && !*(_DWORD *)(*(void *)(a1 + 408) + 4 * *(unsigned __int16 *)(a1 + 404)))
    {
      (*(void (**)(void, void))(*(void *)(a1 + 128) + 72))(*(void *)(a1 + 320), *(void *)(a1 + 328));
    }
    v42 = *(void *)(a1 + 232);
    v43 = *(void *)(v42 + 32);
    if (v43) {
      compstats_Stop(v43, *(void *)(v42 + 40), *(unsigned __int16 *)(a1 + 404) + 2, v41, a5, a6, a7, a8);
    }
    v44 = *(uint64_t (**)(void, uint64_t, void, void, uint64_t))(a1 + 64);
    if (v44)
    {
      v45 = v44(*(void *)(a1 + 88), v18[1], *(void *)(a1 + 296), *(void *)(a1 + 304), *(void *)(a1 + 408) + 4 * *(unsigned __int16 *)(a1 + 404));
      if ((int)Str > -1 && v45 < 0) {
        Str = v45;
      }
      else {
        Str = Str;
      }
    }
    v47 = *(void *)(a1 + 168);
    if (*(void *)(v47 + 200))
    {
      LODWORD(__src[0]) = 0;
      if (((*(uint64_t (**)(void, void, void **))(v47 + 216))(*(void *)(a1 + 296), *(void *)(a1 + 304), __src) & 0x80000000) == 0)
      {
        if (LODWORD(__src[0])) {
          (*(void (**)(void, void, void, uint64_t, uint64_t))(*(void *)(a1 + 168) + 200))(*(void *)(a1 + 296), *(void *)(a1 + 304), 0, v18[1], 1);
        }
      }
    }
    if ((Str & 0x80000000) != 0)
    {
      if ((Str & 0x1FFF) != 0x807) {
        log_OutPublic(*(void *)(v11 + 32), (uint64_t)"TTSEG", 16018, "%s%s%s%x", a5, a6, a7, a8, "component");
      }
      goto LABEL_265;
    }
    goto LABEL_38;
  }
  if (strcmp((const char *)v18[1], __s2))
  {
    if (ttseg_loc_ComponentIsTextParser(v26))
    {
      LODWORD(__len[0]) = 0;
      __src[0] = 0;
      v27 = *(void *)(a1 + 248);
      v28 = (*(uint64_t (**)(void, void, void **, size_t *))(*(void *)(a1 + 128) + 88))(*(void *)(a1 + 136), *(void *)(a1 + 144), __src, __len);
      if ((v28 & 0x80000000) != 0) {
        goto LABEL_347;
      }
      if (LODWORD(__len[0]))
      {
        v32 = v13;
        v33 = *(unsigned int *)(a1 + 504);
        v34 = v33 + LODWORD(__len[0]);
        *(_DWORD *)(a1 + 504) = v33 + LODWORD(__len[0]);
        v35 = heap_Realloc(*(uint64_t **)(*(void *)(a1 + 248) + 8), *(void *)(a1 + 496), (v34 + 1));
        if (!v35)
        {
          Str = 2166366218;
          v261 = *(void *)(v27 + 32);
LABEL_350:
          log_OutPublic(v261, (uint64_t)"TTSEG", 16000, 0, v36, v37, v38, v39, v263);
          goto LABEL_351;
        }
        *(void *)(a1 + 496) = v35;
        memmove((void *)(v35 + v33), __src[0], LODWORD(__len[0]));
        v40 = LODWORD(__len[0]);
        v13 = v32;
      }
      else
      {
        v40 = 0;
      }
      v28 = (*(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 128) + 96))(*(void *)(a1 + 136), *(void *)(a1 + 144), v40);
      if ((v28 & 0x80000000) != 0)
      {
LABEL_347:
        Str = v28;
        v259 = *(void *)(*(void *)(a1 + 248) + 32);
        v260 = "Getting translated text returned error %x";
LABEL_348:
        log_OutText(v259, (uint64_t)"TTSEG", 4, 0, (uint64_t)v260, v29, v30, v31, Str);
        goto LABEL_351;
      }
    }
    goto LABEL_20;
  }
  LODWORD(v279) = 0;
  v280 = 0;
  *(_OWORD *)v282 = *(_OWORD *)"unknown";
  v336[0] = 0x6E776F6E6B6E75;
  Str = (*(uint64_t (**)(void, void, uint64_t *, uint64_t *))(*(void *)(a1 + 128) + 88))(*(void *)(a1 + 152), *(void *)(a1 + 160), &v280, &v279);
  if ((Str & 0x80000000) != 0 || (v123 = v279, !v279))
  {
    log_OutText(*(void *)(*(void *)(a1 + 248) + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Getting markers returned error %x", v120, v121, v122, Str);
LABEL_180:
    if ((Str & 0x80000000) != 0) {
      goto LABEL_351;
    }
LABEL_258:
    v181 = *(unsigned __int16 *)(a1 + 540);
    v182 = *(unsigned __int16 *)(a1 + 542);
    if (v181 > v182) {
      return 0;
    }
    v183 = 1;
    do
    {
      if (*(_DWORD *)(*(void *)(a1 + 408) + 4 * (unsigned __int16)v181) != 1) {
        v183 = 0;
      }
      LOWORD(v181) = v181 + 1;
    }
    while (v182 >= (unsigned __int16)v181);
    if (v183 == 1) {
      return 0;
    }
    *(_WORD *)(a1 + 404) = *(_WORD *)(*(void *)(a1 + 232) + 24) - 2;
    goto LABEL_266;
  }
  v124 = (unint64_t)v279 >> 5;
  LODWORD(v279) = v279 >> 5;
  if (v123 < 0x20) {
    goto LABEL_164;
  }
  v125 = 0;
  v126 = 0;
  v127 = 1;
  v128 = 1;
  while (2)
  {
    v129 = v280;
    v130 = *(_DWORD *)(v280 + v125);
    if (v130 == 0x4000)
    {
      v131 = *(_DWORD *)(v280 + v125 + 8);
      if (*(_DWORD *)(v280 + v125 + 16) | v131)
      {
        ++v126;
        *(_DWORD *)(a1 + 480) = v131;
        goto LABEL_143;
      }
    }
    else
    {
LABEL_143:
      if (v130 == 29) {
        ++v126;
      }
      if (v130 == 36 && v128 == 1)
      {
        __strcpy_chk();
        if (v127 < v279
          && *(_DWORD *)(v129 + v125 + 32) == 36
          && strlen(*(const char **)(v129 + v125 + 56)) >= 4)
        {
          __strcpy_chk();
        }
        if (v282[0] == (char *)0x6E6B6E755F736E69 && LODWORD(v282[1]) == 7239535) {
          __strcpy_chk();
        }
        v128 = 0;
      }
    }
    v124 = v279;
    v125 += 32;
    if (v127++ < v279) {
      continue;
    }
    break;
  }
  v13 = ttseg_loc_ProcessLoop_RESULTS_STR;
  if (v126) {
    goto LABEL_178;
  }
LABEL_164:
  if (!v124)
  {
LABEL_168:
    Str = 20;
    log_OutText(*(void *)(*(void *)(a1 + 248) + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"No SYNC marker found for the input text given to vauto_ttsAnalyzeText() %x", v120, v121, v122, 20);
    goto LABEL_258;
  }
  v135 = (int *)(v280 + 8);
  while (*(v135 - 2) != 0x4000)
  {
    v135 += 8;
    if (!--v124) {
      goto LABEL_168;
    }
  }
  v138 = *v135;
  if (v267 == 1)
  {
    v138 += *(v135 - 1);
    *(v135 - 1) = 0;
    *v135 = v138;
  }
  *(_DWORD *)(a1 + 480) = v138;
  v126 = 1;
LABEL_178:
  *(_DWORD *)(a1 + 484) = v126;
  v139 = ttseg_loc_PutOutput_TAI((void *)a1, 0, v267);
  v143 = *(void *)(a1 + 248);
  if (v139)
  {
    Str = v139;
    log_OutText(*(void *)(v143 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Callback for TA Info Request returned error %x", v140, v141, v142, v139);
    goto LABEL_180;
  }
  v144 = heap_Calloc(*(void **)(v143 + 8), v126, 40);
  *(void *)(a1 + 488) = v144;
  if (!v144) {
    goto LABEL_355;
  }
  if (v279)
  {
    v145 = 0;
    v146 = 0;
    do
    {
      v147 = v280;
      v148 = (int *)(v280 + 32 * v145);
      v149 = *v148;
      if (*v148 == 36)
      {
        __strcpy_chk();
        if (v282[0] == (char *)0x6E6B6E755F736E69 && LODWORD(v282[1]) == 7239535) {
          __strcpy_chk();
        }
      }
      else
      {
        if (v149 != 0x4000) {
          goto LABEL_197;
        }
        v150 = v280 + 32 * v145;
        if (!*(_DWORD *)(v150 + 16) && !*(_DWORD *)(v150 + 8)) {
          goto LABEL_211;
        }
      }
      v149 = *v148;
LABEL_197:
      if (v149 == 0x4000 || v149 == 29)
      {
        v153 = *(void *)(a1 + 488);
        v154 = v153 + 40 * v146;
        if (v149 == 0x4000) {
          v155 = 1;
        }
        else {
          v155 = 2;
        }
        *(_DWORD *)v154 = v155;
        strcpy((char *)(v154 + 24), (const char *)v282);
        v156 = v147 + 32 * v145;
        v158 = *(_DWORD *)(v156 + 4);
        v157 = (unsigned int *)(v156 + 4);
        *(void *)(v154 + 8) = v158;
        if (*v148 == 0x4000)
        {
          v159 = (void *)heap_Calloc(*(void **)(*(void *)(a1 + 248) + 8), 1, (*(_DWORD *)(a1 + 480) + 1));
          *(void *)(a1 + 472) = v159;
          if (!v159)
          {
LABEL_355:
            Str = 2166366218;
            v261 = *(void *)(*(void *)(a1 + 248) + 32);
            goto LABEL_350;
          }
          memmove(v159, (const void *)(*(void *)(a1 + 496) + *v157), *(unsigned int *)(a1 + 480));
        }
        v160 = *(void *)(a1 + 552);
        do
        {
          v161 = (_DWORD *)v160;
          v160 = *(void *)(v160 + 168);
        }
        while (v160);
        ++*v161;
        *(void *)(v153 + 40 * v146++ + 16) = v161;
      }
      else
      {
        v162 = *(void *)(a1 + 248);
        v281 = 0;
        v163 = *(void *)(a1 + 552);
        do
        {
          v164 = (_DWORD *)v163;
          v163 = *(void *)(v163 + 168);
        }
        while (v163);
        switch(v149)
        {
          case 16:
            v164[3] = *(_DWORD *)(v147 + 32 * v145 + 24);
            break;
          case 17:
            v164[4] = *(_DWORD *)(v147 + 32 * v145 + 24);
            break;
          case 18:
            v164[2] = *(_DWORD *)(v147 + 32 * v145 + 24);
            break;
          case 19:
          case 21:
          case 22:
          case 23:
            break;
          case 20:
            v164[6] = *(_DWORD *)(v147 + 32 * v145 + 24);
            break;
          case 24:
            v164[1] = *(_DWORD *)(v147 + 32 * v145 + 24);
            break;
          case 25:
            v164[5] = *(_DWORD *)(v147 + 32 * v145 + 24);
            break;
          default:
            if (v149 == 36)
            {
              paramc_ParamGetStr(*(void *)(v162 + 40), (uint64_t)"hasuserunknowninserted", &v281);
              if (v281 && !strcmp(v281, "yes")) {
                __strcpy_chk();
              }
              else {
                *((unsigned char *)v164 + 64) = 0;
              }
            }
            else if (v149 == 42)
            {
              __strcpy_chk();
              v165 = strchr((char *)__src, 44);
              if (v165)
              {
                *(_OWORD *)__len = 0u;
                v321 = 0u;
                __strcpy_chk();
                __strncpy_chk();
                LODWORD(v165) = LH_atou((const char *)__len);
              }
              else
              {
                *((unsigned char *)v164 + 32) = 0;
              }
              v164[7] = v165;
            }
            break;
        }
        if (*v164)
        {
          v166 = (void *)heap_Alloc(*(void *)(*(void *)(a1 + 248) + 8), 176);
          *((void *)v164 + 21) = v166;
          if (v166)
          {
            v171 = v166;
            memmove(v166, v164, 0xA8uLL);
            *(_DWORD *)v171 = 0;
            v171[21] = 0;
          }
          else
          {
            log_OutPublic(*(void *)(v162 + 32), (uint64_t)"TTSEG", 16000, 0, v167, v168, v169, v170, v263);
          }
        }
      }
LABEL_211:
      ++v145;
    }
    while (v145 < v279);
  }
  v178 = ttseg_loc_PutOutput_TAI((void *)a1, 1, v267);
  if ((v178 & 0x80000000) != 0)
  {
    Str = v178;
    v259 = *(void *)(*(void *)(a1 + 248) + 32);
    v260 = "Callback for TA Info Data returned error %x";
    goto LABEL_348;
  }
  v179 = *(void *)(a1 + 472);
  v13 = ttseg_loc_ProcessLoop_RESULTS_STR;
  if (v179)
  {
    heap_Free(*(void **)(*(void *)(a1 + 248) + 8), v179);
    *(void *)(a1 + 472) = 0;
    *(_DWORD *)(a1 + 480) = 0;
  }
  v180 = *(void *)(a1 + 488);
  if (v180)
  {
    heap_Free(*(void **)(*(void *)(a1 + 248) + 8), v180);
    *(void *)(a1 + 488) = 0;
  }
  Str = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 128) + 96))(*(void *)(a1 + 152), *(void *)(a1 + 160), (32 * v279));
  if ((Str & 0x80000000) == 0)
  {
    v267 = 0;
    goto LABEL_258;
  }
  log_OutText(*(void *)(*(void *)(a1 + 248) + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Unreading markers returned error %x", a6, a7, a8, Str);
LABEL_351:
  if (a2 == 1) {
LABEL_352:
  }
    *(_WORD *)(a1 + 404) = v12;
  return Str;
}

uint64_t ttseg_loc_SynthesizeEnd(uint64_t a1, _DWORD *a2, unsigned int *a3)
{
  uint64_t v6 = *(void *)(a1 + 248);
  v16 = 0;
  *a2 = *(_DWORD *)(a1 + 440);
  unsigned int v7 = *(_DWORD *)(a1 + 444);
  *a3 = v7;
  uint64_t v8 = *(void *)(a1 + 360);
  if (v8)
  {
    int v15 = 0;
    (*(void (**)(uint64_t, void, int *))(*(void *)(a1 + 128) + 136))(v8, *(void *)(a1 + 368), &v15);
    unsigned int v7 = *a3 + (8 * v15) / *(_DWORD *)(a1 + 264);
    *a3 = v7;
  }
  if (v7 > 0x418936) {
    unsigned int v9 = 1000 * (v7 / *(_DWORD *)(a1 + 260));
  }
  else {
    unsigned int v9 = 1000 * v7 / *(_DWORD *)(a1 + 260);
  }
  *a3 = v9;
  paramc_ParamSetStr(*(void *)(v6 + 40), (uint64_t)"component_stop", "yes");
  paramc_ParamSetStr(*(void *)(v6 + 40), (uint64_t)"component_stop_not_reset", "yes");
  if ((objc_GetObject(*(void *)(v6 + 48), (uint64_t)"CHARCOUNT", &v16) & 0x80000000) == 0)
  {
    (*(void (**)(void, void))(v16[1] + 64))(v16[2], v16[3]);
    objc_ReleaseObject(*(void *)(v6 + 48), (uint64_t)"CHARCOUNT");
  }
  return ttseg_loc_SynthesizeCleanup(a1, 0, *a2, *a3, v10, v11, v12, v13);
}

uint64_t ttseg_Speak(uint64_t a1, int a2, char *a3, char *a4)
{
  uint64_t v73 = 0;
  uint64_t v74 = 0;
  uint64_t v72 = 0;
  int v71 = 0;
  uint64_t v69 = 0;
  uint64_t v70 = 0;
  unsigned int v68 = 0;
  uint64_t v6 = ttseg_loc_BeginFunction(a1, a2, &v72, &v73);
  if ((v6 & 0x80000000) != 0) {
    return v6;
  }
  if (a3) {
    uint64_t v10 = a3;
  }
  else {
    uint64_t v10 = byte_20D6B212C;
  }
  log_OutText(*(void *)(v72 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Speak : Begin (%s, %s)", v7, v8, v9, (uint64_t)v10);
  uint64_t v11 = v73;
  uint64_t v17 = ttseg_loc_LockFromIdle(v72, v73, (uint64_t)"ttseg_Speak", 3, &v71);
  if ((v17 & 0x80000000) == 0)
  {
    uint64_t v18 = *(void *)(v11 + 232);
    if (v18)
    {
      uint64_t v19 = *(void *)(v18 + 32);
      if (v19)
      {
        compstats_Reset(v19);
        compstats_Start(*(void *)(*(void *)(v11 + 232) + 32), *(void *)(*(void *)(v11 + 232) + 40), 0, v20, v21, v22, v23, v24);
      }
    }
    else
    {
      log_OutPublic(*(void *)(v72 + 32), (uint64_t)"TTSEG", 16043, 0, v13, v14, v15, v16, v63);
      uint64_t v17 = 2166366225;
    }
    if (*(_DWORD *)(*(void *)(v11 + 32) + 220) == 1 && !*(_DWORD *)(v11 + 196)) {
      uint64_t v17 = ttseg_loc_LicensingIncreaseInstanceCount(v72, v11);
    }
    if ((v17 & 0x80000000) == 0)
    {
      if (a3 && *a3)
      {
        uint64_t NullHandle = safeh_GetNullHandle();
        uint64_t v67 = v25;
        uint64_t v64 = safeh_GetNullHandle();
        uint64_t v65 = v26;
        brk_DataOpenEx(*(void *)(v72 + 24), (uint64_t)a3, 0, (uint64_t)&v70);
        if ((brk_DataMapEx(*(void *)(v72 + 24), v70, 0, (uint64_t)&v68, (uint64_t)&v69) & 0x80000000) != 0)
        {
          uint64_t v17 = 2166368256;
          log_OutPublic(*(void *)(v72 + 32), (uint64_t)"TTSEG", 16045, "%s%s%s%x", v27, v28, v29, v30, "uri");
        }
        else if (v68)
        {
          v31 = *(uint64_t (**)(uint64_t))(*(void *)(v11 + 128) + 32);
          uint64_t v32 = safeh_GetNullHandle();
          uint64_t v33 = v31(v32);
          if ((v33 & 0x80000000) != 0)
          {
            uint64_t v17 = v33;
            log_OutPublic(*(void *)(v72 + 32), (uint64_t)"TTSEG", 16014, "%s%x", v34, v35, v36, v37, "lherror");
          }
          else
          {
            uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, char *, void, uint64_t, uint64_t *))(*(void *)(v11 + 128) + 64))(NullHandle, v67, 18, a4, 0, 2, &v64);
            if ((v38 & 0x80000000) != 0)
            {
              uint64_t v17 = v38;
              log_OutPublic(*(void *)(v72 + 32), (uint64_t)"TTSEG", 16016, "%s%s%s%x", v39, v40, v41, v42, "contentType");
            }
            else
            {
              uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)(v11 + 128) + 104))(v64, v65, v69, v68);
              if ((v17 & 0x80000000) != 0) {
                log_OutPublic(*(void *)(v72 + 32), (uint64_t)"TTSEG", 16125, "%s%s%s%x", v13, v14, v15, v16, "contentType");
              }
            }
          }
        }
        else
        {
          uint64_t v17 = 2166368256;
          log_OutPublic(*(void *)(v72 + 32), (uint64_t)"TTSEG", 16047, "%s%s", v27, v28, v29, v30, "uri");
        }
        if (v64) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)(v11 + 128) + 72))(v64, v65);
        }
        if ((v17 & 0x80000000) == 0)
        {
          uint64_t v52 = v72;
          uint64_t v53 = safeh_GetNullHandle();
          uint64_t v17 = ttseg_loc_Synthesize(v52, v11, 0, 0, a4, 0, 0, v55, NullHandle, v67, v53, v54, (_DWORD *)&v74 + 1, (unsigned int *)&v74);
        }
        if (NullHandle) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)(v11 + 128) + 40))(NullHandle, v67);
        }
      }
      else
      {
        uint64_t v43 = v72;
        v44 = *(uint64_t (**)(uint64_t, unsigned int *, unsigned char *))(v11 + 40);
        uint64_t v45 = *(void *)(v11 + 88);
        uint64_t v46 = safeh_GetNullHandle();
        uint64_t v48 = v47;
        uint64_t v49 = safeh_GetNullHandle();
        uint64_t v17 = ttseg_loc_Synthesize(v43, v11, v44, v45, a4, 0, 0, v51, v46, v48, v49, v50, (_DWORD *)&v74 + 1, (unsigned int *)&v74);
      }
    }
    if (*(_DWORD *)(*(void *)(v11 + 32) + 220) == 1 && *(_DWORD *)(v11 + 196) == 1)
    {
      int v56 = ttseg_loc_LicensingDecreaseInstanceCount(v72, v11);
      if (v56 >= 0) {
        uint64_t v17 = v17;
      }
      else {
        uint64_t v17 = v56;
      }
    }
    if (v18)
    {
      uint64_t v57 = *(void *)(v11 + 232);
      uint64_t v58 = *(void *)(v57 + 32);
      if (v58)
      {
        compstats_Stop(v58, *(void *)(v57 + 40), 0, v12, v13, v14, v15, v16);
        compstats_Log(*(void *)(*(void *)(v11 + 232) + 32), *(void *)(*(void *)(v11 + 232) + 40), *(void *)(v72 + 32), "Synthesis", *(void *)(*(void *)(v11 + 232) + 48), SHIDWORD(v74), v74);
      }
    }
    ttseg_loc_Unlock(v72, v11, v71);
    log_OutText(*(void *)(v72 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Speak : End (%x)", v59, v60, v61, v17);
    if (v69)
    {
      brk_DataUnmap(*(void *)(v72 + 24), v70, v69);
      uint64_t v69 = 0;
    }
    if (v70) {
      brk_DataClose(*(void *)(v72 + 24), v70);
    }
  }
  return v17;
}

uint64_t ttseg_loc_LicensingDecreaseInstanceCount(uint64_t a1, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 196)) {
    return 2166366208;
  }
  unsigned int v4 = *(_DWORD *)(a2 + 192);
  uint64_t v9 = critsec_Enter(*(void **)(*(void *)(a2 + 32) + 208));
  if ((v9 & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16112, "%s%s%s%x", v5, v6, v7, v8, "function");
  }
  else
  {
    if (v4 <= 2)
    {
      if (*(_DWORD *)(a2 + 196) == 1)
      {
        uint64_t v10 = *(void *)(a2 + 32);
        uint64_t v11 = v10 + 24 * v4;
        int v14 = *(_DWORD *)(v11 + 124);
        uint64_t v12 = (_DWORD *)(v11 + 124);
        int v13 = v14;
        if (v14)
        {
          *uint64_t v12 = v13 - 1;
          log_OutText(*(void *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG License is released: total ports=%lu,  acquired ports=%lu", v6, v7, v8, *(unsigned int *)(v10 + 24 * v4 + 116));
        }
      }
      else if (SWIlicense_inhibited == 1)
      {
        if (num_used_SWI_licenses) {
          --num_used_SWI_licenses;
        }
      }
      else
      {
        SWIlicenseFreeCacheableLicense();
      }
      ttseg_loc_LicenseLog((uint64_t **)a1, *(void *)(a2 + 32), v4, 6, v5, v6, v7, v8);
      *(_DWORD *)(a2 + 196) = 0;
    }
    critsec_Leave(*(void **)(*(void *)(a2 + 32) + 208));
  }
  return v9;
}

uint64_t ttseg_Break(uint64_t a1, int a2)
{
  uint64_t v22 = 0;
  uint64_t v21 = 0;
  uint64_t v2 = ttseg_loc_BeginFunction(a1, a2, &v21, &v22);
  if ((v2 & 0x80000000) != 0) {
    return v2;
  }
  log_OutText(*(void *)(v21 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Break : Begin", v3, v4, v5, v19);
  uint64_t v6 = v22;
  uint64_t v11 = critsec_Enter(*(void **)(v22 + 96));
  if ((v11 & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(v21 + 32), (uint64_t)"TTSEG", 16004, "%s%s%s%x", v7, v8, v9, v10, "function");
  }
  else
  {
    if ((*(_DWORD *)(v6 + 104) - 3) > 1)
    {
      log_OutText(*(void *)(v21 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Break : not speaking", v8, v9, v10, v20);
      LODWORD(v11) = -2128601071;
    }
    else
    {
      *(_DWORD *)(v6 + 104) = 6;
      uint64_t v12 = *(kaldi::nnet1::Component **)(v6 + 216);
      if (v12) {
        kaldi::nnet1::Component::IsUpdatable(v12);
      }
    }
    int v16 = critsec_Leave(*(void **)(v6 + 96));
    if (v16 >= 0 || (int)v11 <= -1) {
      uint64_t v11 = v11;
    }
    else {
      uint64_t v11 = v16;
    }
  }
  log_OutText(*(void *)(v21 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG Break : End (%x)", v13, v14, v15, v11);
  return v11;
}

uint64_t ttseg_GetProductList(void *a1, int a2, uint64_t a3, char *a4, int *a5)
{
  uint64_t v20 = 0;
  uint64_t v7 = ttseg_loc_CheckClassHandle(a1, a2, &v20, &v21);
  if ((v7 & 0x80000000) != 0) {
    return 2166366216;
  }
  uint64_t v11 = v7;
  log_OutText(*(void *)(v20 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Get Product List : Begin", v8, v9, v10, v18);
  if (a5)
  {
    int v16 = *a5;
    *a5 = 1;
    if (a4 && v16)
    {
      __sprintf_chk(a4, 0, 0x40uLL, "Vocalizer v%d.%d", 7, 4);
      strcpy(a4 + 64, "eng/vocalizer");
      sprintf(a4 + 96, "%d.%d.%d", 7, 4, 0);
    }
    log_OutText(*(void *)(v20 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Get Product List : End (%x, %u)", v13, v14, v15, v11);
  }
  else
  {
    log_OutPublic(*(void *)(v20 + 32), (uint64_t)"TTSEG", 16054, 0, v12, v13, v14, v15, v19);
    return 2166366215;
  }
  return v11;
}

uint64_t ttseg_GetLanguageList(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v9 = 2166366209;
  if ((ttseg_loc_CheckClassHandle(a1, a2, &v19, &v20) & 0x80000000) != 0) {
    return 2166366216;
  }
  uint64_t v13 = a3 + 64;
  log_OutText(*(void *)(v19 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Get Language List : Begin (%s)", v10, v11, v12, v13);
  uint64_t v17 = v20[4];
  if (v17) {
    uint64_t v9 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t))(v17 + 64))(v20[5], v20[6], v13, a5, a6);
  }
  log_OutText(*(void *)(v19 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Get Language List : End (%x, %u)", v14, v15, v16, v9);
  return v9;
}

uint64_t ttseg_GetVoiceList(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v11 = 2166366209;
  if ((ttseg_loc_CheckClassHandle(a1, a2, &v21, &v22) & 0x80000000) != 0) {
    return 2166366216;
  }
  uint64_t v15 = a3 + 64;
  log_OutText(*(void *)(v21 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Get Voice List : Begin (%s, %s)", v12, v13, v14, v15);
  uint64_t v19 = v22[4];
  if (v19) {
    uint64_t v11 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t))(v19 + 72))(v22[5], v22[6], v15, a4, a6, a7);
  }
  log_OutText(*(void *)(v21 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Get Voice List : End (%x, %u)", v16, v17, v18, v11);
  return v11;
}

uint64_t ttseg_GetDocTypeList(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v11 = 2166366209;
  if ((ttseg_loc_CheckClassHandle(a1, a2, &v21, &v22) & 0x80000000) != 0) {
    return 2166366216;
  }
  uint64_t v15 = a3 + 64;
  log_OutText(*(void *)(v21 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Get Document List : Begin (%s, %s)", v12, v13, v14, v15);
  uint64_t v19 = v22[4];
  if (v19) {
    uint64_t v11 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t))(v19 + 80))(v22[5], v22[6], v15, a4, a6, a7);
  }
  log_OutText(*(void *)(v21 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Get Document List : End (%x, %u)", v16, v17, v18, v11);
  return v11;
}

uint64_t ttseg_GetSpeechDBList(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v13 = 2166366209;
  if ((ttseg_loc_CheckClassHandle(a1, a2, &v23, &v24) & 0x80000000) != 0) {
    return 2166366216;
  }
  uint64_t v17 = a3 + 64;
  log_OutText(*(void *)(v23 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Get Speech DB List : Begin (%s, %s, %s)", v14, v15, v16, v17);
  uint64_t v21 = v24[4];
  if (v21) {
    uint64_t v13 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v21 + 88))(v24[5], v24[6], v17, a4, a5, a7, a8);
  }
  log_OutText(*(void *)(v23 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Get Speech DB List : End (%x, %u)", v18, v19, v20, v13);
  return v13;
}

uint64_t ttseg_GetLicenseAppType(void *a1, int a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t result = ttseg_loc_CheckClassHandle(a1, a2, &v7, &v8);
  if ((result & 0x80000000) != 0) {
    return 2166366216;
  }
  if (a3) {
    *a3 = *(_DWORD *)(v8 + 224);
  }
  if (a4) {
    *a4 = *(_DWORD *)(v8 + 228);
  }
  return result;
}

uint64_t ttseg_SetTTSLicensePorts(void *a1, int a2, int a3)
{
  uint64_t v4 = 2166366215;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  if ((ttseg_loc_CheckClassHandle(a1, a2, &v41, &v42) & 0x80000000) != 0) {
    return 2166366216;
  }
  uint64_t v6 = v41;
  uint64_t v5 = v42;
  int v43 = 0;
  uint64_t v11 = critsec_Enter(*(void **)(v42 + 208));
  if ((v11 & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(v6 + 32), (uint64_t)"TTSEG", 16112, "%s%s%s%x", v7, v8, v9, v10, "function");
    return v11;
  }
  unsigned int v12 = *(_DWORD *)(v5 + 116);
  if (v12 == a3) {
    goto LABEL_18;
  }
  if (v12 > a3)
  {
    ttseg_loc_LicenseLog((uint64_t **)v6, v5, 0, 11, v7, v8, v9, v10);
    if ((SWIlicense_inhibited & 1) == 0 && kaldi::nnet1::Component::IsUpdatable(0))
    {
      log_OutText(*(void *)(v6 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TTSEG SWIlicenseUnlock failed", v8, v9, v10, v39);
      uint64_t v11 = 2166373642;
    }
    *(_DWORD *)(v5 + 116) = 0;
  }
  if (!a3 || (v11 & 0x80000000) != 0) {
    goto LABEL_18;
  }
  int v13 = *(_DWORD *)(v5 + 112);
  int v14 = *(_DWORD *)(v5 + 128);
  if (SWIlicense_inhibited == 1)
  {
    int v43 = a3;
    int v15 = v14;
    int v16 = a3;
    goto LABEL_13;
  }
  if ((SWIlicenseLockMulti(0, g_SWIlicenseFeatureTTSOpt[*(unsigned int *)(v5 + 224)], a3, &v43) & 0xFFFFFFFB) != 0)
  {
    uint64_t v4 = 2166373638;
    *(_DWORD *)(v5 + 116) = 0;
    goto LABEL_19;
  }
  int v16 = v43;
  if (v43 < a3)
  {
    log_OutPublic(*(void *)(v6 + 32), (uint64_t)"TTSEG", 16118, "%s%u%s%u", v7, v8, v9, v10, "requiredPorts");
    if (!*(_DWORD *)(v5 + 116)) {
      goto LABEL_19;
    }
    ttseg_loc_LicenseLog((uint64_t **)v6, v5, 0, 11, v20, v21, v22, v23);
    if (SWIlicense_inhibited == 1)
    {
      int v28 = *(_DWORD *)(v5 + 116);
LABEL_29:
      int v43 = v28;
LABEL_30:
      ttseg_loc_LicenseLog((uint64_t **)v6, v5, 0, 10, v24, v25, v26, v27);
      if (v43 < *(_DWORD *)(v5 + 116))
      {
        uint64_t v4 = 2166373638;
        log_OutPublic(*(void *)(v6 + 32), (uint64_t)"TTSEG", 16118, "%s%u%s%u", v29, v30, v31, v32, "requiredPorts");
        ttseg_loc_LicenseLog((uint64_t **)v6, v5, 0, 11, v33, v34, v35, v36);
        if ((SWIlicense_inhibited & 1) == 0) {
          kaldi::nnet1::Component::IsUpdatable(0);
        }
      }
      goto LABEL_19;
    }
    if (kaldi::nnet1::Component::IsUpdatable(0))
    {
      uint64_t v37 = *(void *)(v6 + 32);
      uint64_t v38 = "TTSEG SWIlicenseUnlock failed";
    }
    else
    {
      int v28 = *(_DWORD *)(v5 + 116);
      if (SWIlicense_inhibited == 1) {
        goto LABEL_29;
      }
      if ((SWIlicenseLockMulti(0, g_SWIlicenseFeatureTTSOpt[*(unsigned int *)(v5 + 224)], v28, &v43) & 0xFFFFFFFB) == 0) {
        goto LABEL_30;
      }
      uint64_t v37 = *(void *)(v6 + 32);
      uint64_t v38 = "TTSEG SWIlicenseLockMulti failed";
    }
    log_OutText(v37, (uint64_t)"TTSEG", 4, 0, (uint64_t)v38, v25, v26, v27, v40);
    uint64_t v4 = 2166373642;
    goto LABEL_19;
  }
  int v15 = *(_DWORD *)(v5 + 128);
LABEL_13:
  *(_DWORD *)(v5 + 112) = a3;
  *(_DWORD *)(v5 + 116) = v16;
  unsigned int v17 = v15 + a3;
  unsigned int v18 = *(_DWORD *)(v5 + 120);
  if (!v18 || v18 == v14 + v13 || v18 > v17) {
    *(_DWORD *)(v5 + 120) = v17;
  }
  ttseg_loc_LicenseLog((uint64_t **)v6, v5, 0, 10, v7, v8, v9, v10);
LABEL_18:
  uint64_t v4 = v11;
LABEL_19:
  critsec_Leave(*(void **)(v5 + 208));
  return v4;
}

uint64_t ttseg_GetTTSProductVersion(unsigned char *a1, unsigned char *a2, unsigned char *a3)
{
  *a1 = 23;
  *a2 = 3;
  *a3 = 2;
  return 0;
}

uint64_t ttseg_loc_CompileRegex(uint64_t a1, uint64_t a2, int a3, char *a4, uint64_t *a5)
{
  int v15 = 0;
  int v14 = 0;
  uint64_t v7 = nuance_pcre_compile(a2, a3, a4, 2048, &v15, &v14, 0);
  if (v7)
  {
    uint64_t v12 = v7;
    uint64_t result = 0;
    *a5 = v12;
  }
  else
  {
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16128, "%s%s%s%s%x", v8, v9, v10, v11, "function");
    return 2166366226;
  }
  return result;
}

uint64_t ttseg_ParseTRConfigFile(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5, unsigned __int16 *a6)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  *(void *)&__n[1] = a4;
  __n[0] = a5;
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  uint64_t v10 = ttseg_loc_BeginFunction(a1, a2, &v44, &v45);
  if ((v10 & 0x80000000) != 0) {
    return v10;
  }
  if (a3 || (uint64_t v11 = 2166366215, a4) && a5)
  {
    uint64_t v10 = nuance_pcre_ObjOpen(*(_WORD **)v45, *(void *)(v45 + 8), (uint64_t)&v41);
    if ((v10 & 0x80000000) == 0)
    {
      uint64_t v12 = nuance_pcre_Init(v41, v42, 0xAu, 10);
      if ((v12 & 0x80000000) != 0)
      {
        uint64_t v11 = v12;
LABEL_29:
        nuance_pcre_ObjClose((uint64_t)v41, v42);
        return v11;
      }
      uint64_t v13 = ttseg_loc_CompileRegex(v44, (uint64_t)v41, v42, "version=([0-9\\.]+)", &v40);
      if ((v13 & 0x80000000) == 0)
      {
        uint64_t v13 = ttseg_loc_CompileRegex(v44, (uint64_t)v41, v42, "mimetype=\"([a-z-\\+;=/]+)\"", &v39);
        if ((v13 & 0x80000000) == 0)
        {
          uint64_t v13 = ttseg_loc_CompileRegex(v44, (uint64_t)v41, v42, "file=\"([^\"]+)\"", &v38);
          if ((v13 & 0x80000000) == 0)
          {
            if (!a3) {
              goto LABEL_32;
            }
            if (!*(unsigned char *)a3)
            {
              a3 = 0;
              goto LABEL_32;
            }
            uint64_t v13 = brk_DataOpenEx(*(void *)(v44 + 24), a3, 0, (uint64_t)&v43);
            if ((v13 & 0x80000000) == 0)
            {
              a3 = brk_DataMapEx(*(void *)(v44 + 24), v43, 0, (uint64_t)__n, (uint64_t)&__n[1]);
              uint64_t v11 = a3;
              if ((a3 & 0x80000000) != 0) {
                goto LABEL_17;
              }
LABEL_32:
              uint64_t v11 = 2166366218;
              int v15 = (char *)heap_Calloc(*(void **)(v44 + 8), (__n[0] + 1), 1);
              if (v15)
              {
                int v16 = v15;
                memcpy(v15, *(const void **)&__n[1], __n[0]);
                if (*v16)
                {
                  size_t v21 = 0;
                  int v22 = 0;
                  uint64_t v23 = v40;
                  unsigned int v24 = 1;
                  uint64_t v36 = v38;
                  uint64_t v37 = v39;
                  while (a6[6] <= 0x7Fu)
                  {
                    int v25 = v22 + 1;
                    __s[v22] = v16[v21];
                    if (v22 == 1023) {
                      goto LABEL_51;
                    }
                    size_t v21 = v24;
                    if (v16[v24] == 10 || strlen(v16) == v24)
                    {
                      __s[v25] = 0;
                      int v26 = strlen(__s);
                      if (nuance_pcre_exec(v41, v42, v23, 0, __s, v26, 0, 0, &v47, 256) == 2)
                      {
                        uint64_t v27 = v49 - (uint64_t)v48;
                        if ((int)v27 > 10)
                        {
LABEL_51:
                          uint64_t v35 = 2166366223;
                          goto LABEL_54;
                        }
                        memcpy(a6, &__s[v48], v27);
                        int v25 = 0;
                        *((unsigned char *)a6 + v27 + 1) = 0;
                      }
                      else
                      {
                        int v28 = strlen(__s);
                        if (nuance_pcre_exec(v41, v42, v37, 0, __s, v28, 0, 0, &v47, 256) != 2) {
                          goto LABEL_52;
                        }
                        size_t v29 = (v49 - v48);
                        uint64_t v30 = (void *)heap_Calloc(*(void **)(v44 + 8), (v29 + 1), 1);
                        *(void *)&a6[4 * a6[6] + 8] = v30;
                        if (!v30) {
                          goto LABEL_53;
                        }
                        memcpy(v30, &__s[v48], v29);
                        int v31 = strlen(__s);
                        if (nuance_pcre_exec(v41, v42, v36, 0, __s, v31, 0, 0, &v47, 256) != 2)
                        {
LABEL_52:
                          uint64_t v35 = 2166366228;
                          goto LABEL_54;
                        }
                        size_t v32 = (v49 - v48);
                        uint64_t v33 = (void *)heap_Calloc(*(void **)(v44 + 8), (v32 + 1), 1);
                        *(void *)&a6[4 * a6[6] + 520] = v33;
                        if (!v33)
                        {
LABEL_53:
                          uint64_t v35 = 2166366218;
                          goto LABEL_54;
                        }
                        memcpy(v33, &__s[v48], v32);
                        int v25 = 0;
                        ++a6[6];
                      }
                    }
                    size_t v34 = strlen(v16);
                    ++v24;
                    int v22 = v25;
                    if (v34 <= v21) {
                      break;
                    }
                  }
                }
                if (a6[6] == 128)
                {
                  uint64_t v35 = a3;
                  log_OutPublic(*(void *)(v44 + 32), (uint64_t)"TTSEG", 16129, "%s%s%s%x", v17, v18, v19, v20, "function");
                }
                else
                {
                  uint64_t v35 = a3;
                }
LABEL_54:
                heap_Free(*(void **)(v44 + 8), (uint64_t)v16);
                uint64_t v11 = v35;
              }
              goto LABEL_17;
            }
          }
        }
      }
      uint64_t v11 = v13;
LABEL_17:
      if (v40) {
        heap_Free(*(void **)(v44 + 8), v40);
      }
      if (v39) {
        heap_Free(*(void **)(v44 + 8), v39);
      }
      if (v38) {
        heap_Free(*(void **)(v44 + 8), v38);
      }
      if (*(void *)&__n[1])
      {
        brk_DataUnmap(*(void *)(v44 + 24), v43, *(uint64_t *)&__n[1]);
        *(void *)&__n[1] = 0;
      }
      if (v43)
      {
        brk_DataClose(*(void *)(v44 + 24), v43);
        uint64_t v43 = 0;
      }
      nuance_pcre_DeInit(v41, v42);
      goto LABEL_29;
    }
    return v10;
  }
  return v11;
}

uint64_t ttseg_ParseTRConfigFileDestroy(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v8 = 0;
  uint64_t v4 = ttseg_loc_BeginFunction(a1, a2, &v8, &v9);
  if ((v4 & 0x80000000) == 0 && *(_WORD *)(a3 + 12))
  {
    unint64_t v5 = 0;
    do
    {
      uint64_t v6 = a3 + 8 * v5;
      heap_Free(*(void **)(v8 + 8), *(void *)(v6 + 1040));
      heap_Free(*(void **)(v8 + 8), *(void *)(v6 + 16));
      ++v5;
    }
    while (v5 < *(unsigned __int16 *)(a3 + 12));
  }
  return v4;
}

BOOL ttseg_loc_check_vns(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v9 = 0;
  if ((paramc_ParamGetStr(a1, (uint64_t)"txm ypy hwb &53(1@+- _={[]?/>.<,", &v9) & 0x80000000) != 0)
    return 0;
  v1 = v9;
  if (!v9) {
    return 0;
  }
  int v11 = 0;
  memset(v10, 0, sizeof(v10));
  strcpy(__s, "key");
  int v2 = strlen(__s);
  uint64_t v3 = strlen(v9);
  if (v3)
  {
    unsigned int v4 = 0;
    unint64_t v5 = v10;
    do
    {
      char v6 = *v1++;
      *v5++ = __s[v4] ^ v6;
      if (v4 < v2 - 1) {
        ++v4;
      }
      else {
        unsigned int v4 = 0;
      }
      --v3;
    }
    while (v3);
  }
  return !LH_stricmp((char *)v10, "4:\x014CS5]@AJGW^CL\x1E\"\x168&9\x17\v\x18\x11\x0E\x1A\x04\x184");
}

uint64_t **ttseg_loc_LicenseLog(uint64_t **result, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = result;
  if (a3 <= 1)
  {
    if (!*(_DWORD *)(a2 + 216)) {
      __strcat_chk();
    }
    uint64_t v10 = (uint64_t **)v9[4];
    if ((SWIlicense_inhibited & 1) == 0) {
      SWIlicenseGetNumOfLicensesInUseInCache();
    }
    return log_OutEvent(v10, a4, "%s%u%s%u%s%u%s%s", a4, a5, a6, a7, a8, "LUSED");
  }
  return result;
}

void *DeinitLoadedCupList(void *result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    uint64_t v4 = *(void *)(a2 + 8);
    if (v4)
    {
      if (*(void *)(v4 + 8))
      {
        heap_Free(result, *(void *)(v4 + 8));
        uint64_t v4 = *(void *)(a2 + 8);
      }
      heap_Free(v3, v4);
    }
    return heap_Free(v3, a2);
  }
  return result;
}

void *ttseg_loc_RemoveTaInfo(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 248);
  uint64_t v3 = *(void *)(a1 + 552);
  uint64_t v4 = *(void *)(v3 + 168);
  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 552);
    do
    {
      do
      {
        uint64_t v6 = v5;
        uint64_t v5 = v4;
        uint64_t v4 = *(void *)(v4 + 168);
      }
      while (v4);
      *(void *)(v6 + 168) = 0;
      heap_Free(*(void **)(v2 + 8), v5);
      uint64_t v4 = *(void *)(v3 + 168);
      uint64_t v5 = v3;
    }
    while (v4);
    uint64_t v3 = *(void *)(a1 + 552);
  }
  uint64_t result = heap_Free(*(void **)(v2 + 8), v3);
  *(void *)(a1 + 552) = 0;
  return result;
}

uint64_t ObjcLoadCup(_WORD *a1, int a2, char *a3, uint64_t a4)
{
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v19);
  if ((inited & 0x80000000) != 0)
  {
    uint64_t v10 = inited;
  }
  else
  {
    uint64_t v9 = brk_RegisterCupAddon(*(uint64_t **)(v19 + 24), (uint64_t)a3, (uint64_t)&v18, (uint64_t)&v17);
    if ((v9 & 0x80000000) != 0)
    {
      uint64_t v10 = v9;
      if (v18)
      {
LABEL_12:
        if (v17) {
          brk_UnregisterCupAddon(*(uint64_t **)(v19 + 24), (uint64_t)a3);
        }
      }
    }
    else
    {
      uint64_t v10 = cupreader_open(a1, a2, v18, &v20);
      if ((v10 & 0x80000000) == 0)
      {
        v20[7] = v17;
        int v11 = (char *)strhelper_Strdup(*(void *)(v19 + 8), a3);
        uint64_t v12 = v20;
        v20[8] = (uint64_t)v11;
        if (v11)
        {
          uint64_t v13 = UriToBrokerString(*(void **)(v19 + 8), v11);
          uint64_t v12 = v20;
          v20[9] = (uint64_t)v13;
          if (v13) {
            uint64_t v10 = v10;
          }
          else {
            uint64_t v10 = 10;
          }
        }
        else
        {
          uint64_t v10 = 10;
        }
        *(void *)(a4 + 32) = v12;
        return v10;
      }
      if (v18) {
        goto LABEL_12;
      }
    }
  }
  int v14 = v20;
  if (v20)
  {
    uint64_t v15 = v20[8];
    if (v15)
    {
      heap_Free(*(void **)(v19 + 8), v15);
      int v14 = v20;
    }
    cupreader_close(a1, a2, (uint64_t)v14);
  }
  return v10;
}

uint64_t ObjcUnloadCup(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t v11 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v11);
  if ((inited & 0x80000000) == 0)
  {
    uint64_t v7 = *(void *)(a3 + 32);
    if (v7)
    {
      uint64_t inited = brk_UnregisterCupAddon(*(uint64_t **)(v11 + 24), *(void *)(v7 + 64));
      if ((inited & 0x80000000) == 0)
      {
        uint64_t v8 = *(void *)(v7 + 72);
        if (v8) {
          heap_Free(*(void **)(v11 + 8), v8);
        }
        uint64_t v9 = *(void *)(v7 + 64);
        if (v9) {
          heap_Free(*(void **)(v11 + 8), v9);
        }
        cupreader_close(a1, a2, v7);
      }
    }
  }
  return inited;
}

uint64_t ttseg_loc_ProcessStart(uint64_t a1, uint64_t (*a2)(uint64_t, void, void, void), uint64_t a3, int a4, unsigned int a5)
{
  LODWORD(v5) = a4;
  uint64_t v8 = *(uint64_t **)(a1 + 248);
  uint64_t v9 = (const char *)(a1 + 508);
  *(unsigned char *)(a1 + 508) = 0;
  *(_DWORD *)(a1 + 540) = 0;
  if (log_HasTraceTuningDataSubscriber(v8[4]))
  {
    uint64_t v10 = v8[4];
    uint64_t v11 = (*(uint64_t (**)(void))(*(void *)(a1 + 128) + 152))();
    log_OutTraceTuningDataBinary(v10, 400, 0, 0, v11, 0);
  }
  if (*(_DWORD *)(a1 + 240) == 2)
  {
    uint64_t v12 = *(void *)(a1 + 232);
    if (*(_WORD *)(v12 + 24))
    {
      unint64_t v13 = 0;
      do
      {
        uint64_t v14 = *(void *)(v12 + 16);
        if (ttseg_loc_ComponentIsTextParser(*(const char **)(*(void *)(v14 + 8 * v13) + 8)))
        {
          *(_WORD *)(a1 + 540) = v13;
          if (!strcmp(*(const char **)(*(void *)(v14 + 8 * v13 + 24) + 8), "fe/fe_lid")) {
            __int16 v15 = 3;
          }
          else {
            __int16 v15 = 2;
          }
          *(_WORD *)(a1 + 542) = v13 + v15;
          __strcpy_chk();
          uint64_t v12 = *(void *)(a1 + 232);
        }
        ++v13;
      }
      while (v13 < *(unsigned __int16 *)(v12 + 24));
    }
  }
  if (v5 < a5)
  {
    uint64_t v5 = v5;
    while (1)
    {
      unint64_t v16 = v5 + 1;
      (*(void (**)(void, void, void))(*(void *)(a1 + 128) + 56))(*(void *)(a1 + 272), *(void *)(a1 + 280), (unsigned __int16)(v5 + 1));
      log_OutText(v8[4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"Calling ProcessStart for %s", v17, v18, v19, *(void *)(*(void *)(*(void *)(*(void *)(a1 + 232) + 16) + 8 * v5) + 8));
      int v25 = *(void **)(a1 + 232);
      uint64_t v26 = v25[4];
      if (v26)
      {
        compstats_Start(v26, v25[5], (v5 + 2), v20, v21, v22, v23, v24);
        int v25 = *(void **)(a1 + 232);
      }
      if (*(_DWORD *)(a1 + 240) == 2)
      {
        uint64_t v27 = *(const char **)(*(void *)(v25[2] + 8 * v5) + 8);
        if (!strcmp(v27, v9))
        {
          uint64_t v28 = (*(uint64_t (**)(void, void, uint64_t, const char *, void, void, uint64_t))(*(void *)(a1 + 128) + 64))(*(void *)(a1 + 272), *(void *)(a1 + 280), 18, "application/x-realspeak-markers-pp;version=4.0",
                  0,
                  0,
                  a1 + 152);
          if ((v28 & 0x80000000) != 0) {
            return v28;
          }
          int v25 = *(void **)(a1 + 232);
          uint64_t v27 = *(const char **)(*(void *)(v25[2] + 8 * v5) + 8);
        }
        if (ttseg_loc_ComponentIsTextParser(v27))
        {
          uint64_t v28 = (*(uint64_t (**)(void, void, uint64_t, const char *, void, void, uint64_t))(*(void *)(a1 + 128) + 64))(*(void *)(a1 + 272), *(void *)(a1 + 280), 18, "text/plain;charset=utf-8",
                  0,
                  0,
                  a1 + 136);
          *(_DWORD *)(a1 + 464) = 0;
          if ((v28 & 0x80000000) != 0) {
            return v28;
          }
          int v25 = *(void **)(a1 + 232);
        }
      }
      size_t v29 = *(void **)(v25[2] + 8 * v5);
      uint64_t v35 = (*(uint64_t (**)(void, void, void, void))(v29[2] + 96))(v29[3], v29[4], *(void *)(a1 + 272), *(void *)(a1 + 280));
      uint64_t v36 = *(void *)(a1 + 232);
      uint64_t v37 = *(void *)(v36 + 32);
      if (v37) {
        compstats_Stop(v37, *(void *)(v36 + 40), (v5 + 2), v30, v31, v32, v33, v34);
      }
      if ((v35 & 0x80000000) != 0)
      {
        log_OutPublic(v8[4], (uint64_t)"TTSEG", 16017, "%s%s%s%x", v31, v32, v33, v34, "component");
        return v35;
      }
      *(_WORD *)(a1 + 396) = v16;
      if (a2) {
        uint64_t v35 = a2(a3, *(void *)(*(void *)(*(void *)(*(void *)(a1 + 232) + 16) + 8 * v5) + 8), *(void *)(a1 + 272), *(void *)(a1 + 280));
      }
      if ((v35 & 0x80000000) == 0)
      {
        ++v5;
        if (v16 < a5) {
          continue;
        }
      }
      goto LABEL_32;
    }
  }
  uint64_t v35 = 0;
LABEL_32:
  if (*(_DWORD *)(a1 + 240) == 2)
  {
    *(void *)(a1 + 496) = 0;
    *(_DWORD *)(a1 + 504) = 0;
    if (*(void *)(a1 + 552)) {
      ttseg_loc_RemoveTaInfo(a1);
    }
    uint64_t v38 = (_OWORD *)heap_Alloc(v8[1], 176);
    *(void *)(a1 + 552) = v38;
    if (v38)
    {
      v38[9] = 0u;
      v38[10] = 0u;
      v38[7] = 0u;
      v38[8] = 0u;
      v38[5] = 0u;
      v38[6] = 0u;
      v38[3] = 0u;
      v38[4] = 0u;
      v38[1] = 0u;
      v38[2] = 0u;
      *uint64_t v38 = 0u;
      uint64_t v43 = *(void *)(a1 + 552);
      *(int32x2_t *)(v43 + 20) = vdup_n_s32(0x270Fu);
      *(_DWORD *)(v43 + 28) = 0;
      *(_OWORD *)uint64_t v43 = xmmword_20D6B20B0;
      *(void *)(v43 + 168) = 0;
    }
    else
    {
      log_OutPublic(v8[4], (uint64_t)"TTSEG", 16000, 0, v39, v40, v41, v42, v45);
      uint64_t v35 = 2166366218;
    }
  }
  paramc_ParamSetUInt(v8[5], (uint64_t)"feedback-amount-of-output-msecs-for-this-speakrequest", 0);
  return v35;
}

uint64_t ttseg_loc_OpenOutputStreams(void *a1)
{
  uint64_t v1 = a1[31];
  uint64_t v7 = 0;
  if (!a1[6]) {
    return 0;
  }
  uint64_t v3 = (*(uint64_t (**)(void, void, void))(a1[16] + 56))(a1[34], a1[35], (unsigned __int16)(*(_WORD *)(a1[29] + 24) + 1));
  if ((v3 & 0x80000000) == 0)
  {
    int Str = paramc_ParamGetStr(*(void *)(v1 + 40), (uint64_t)"audiooutputmimetype", &v7);
    uint64_t v5 = v7;
    if ((Str & 0x80000000) == 0 && v7)
    {
      if (*v7
        && ((*(uint64_t (**)(void, void, uint64_t, unsigned char *, void, void, void *))(a1[16] + 64))(a1[34], a1[35], 18, v7, 0, 0, a1 + 45) & 0x80000000) == 0)
      {
        (*(void (**)(void, void, uint64_t, const char *, void, void, void *))(a1[16] + 64))(a1[34], a1[35], 18, "application/x-realspeak-markers-pp;version=4.0",
          0,
          0,
          a1 + 47);
      }
      uint64_t v5 = v7;
    }
    if (v5) {
      paramc_ParamRelease(*(void *)(v1 + 40));
    }
  }
  return v3;
}

uint64_t ttseg_loc_GetInputIntoStream(uint64_t a1, uint64_t (*a2)(uint64_t, unsigned int *, unsigned char *), uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, _DWORD *a8)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  uint64_t v14 = 2166366215;
  unsigned int v33 = 1024;
  if (a6)
  {
    compstats_Start(a6, a7, 1, a4, (uint64_t)a5, a6, a7, (uint64_t)a8);
    if (!a2) {
      return v14;
    }
    uint64_t v14 = a2(a3, &v33, v34);
    compstats_Stop(a6, a7, 1, v17, v18, v19, v20, v21);
  }
  else
  {
    if (!a2) {
      return v14;
    }
    uint64_t v14 = a2(a3, &v33, v34);
  }
  log_OutText(*(void *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"pfGetInput returned %lu bytes, %x", v22, v23, v24, v33);
  if ((v14 & 0x1FFF) == 5 || (v14 & 0x1FFF) == 3)
  {
LABEL_12:
    (*(void (**)(uint64_t, uint64_t))(a4 + 72))(*a5, a5[1]);
    *a5 = safeh_GetNullHandle();
    a5[1] = v29;
    return v14;
  }
  if ((v14 & 0x1FFF) != 0)
  {
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16011, "%s%x", v25, v26, v27, v28, "lherror");
    goto LABEL_12;
  }
  if (v33)
  {
    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned char *))(a4 + 104))(*a5, a5[1], v34);
    *a8 += v33;
  }
  else
  {
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"TTSEG", 16010, 0, v25, v26, v27, v28, v32);
    (*(void (**)(uint64_t, uint64_t))(a4 + 72))(*a5, a5[1]);
    *a5 = safeh_GetNullHandle();
    a5[1] = v31;
    return 18882563;
  }
  return v14;
}

uint64_t ttseg_loc_SynthesizeCleanup(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 248);
  LODWORD(v17) = ttseg_loc_ProcessEnd(a1, 0, *(unsigned __int16 *)(a1 + 396), 1, a5, a6, a7, a8);
  uint64_t v18 = *(void *)(a1 + 320);
  if (v18)
  {
    int v19 = (*(uint64_t (**)(uint64_t, void))(*(void *)(a1 + 128) + 72))(v18, *(void *)(a1 + 328));
    *(void *)(a1 + 320) = safeh_GetNullHandle();
    *(void *)(a1 + 328) = v10;
    if (v19 < 0 && (int)v17 > -1) {
      LODWORD(v17) = v19;
    }
  }
  int v21 = ttseg_loc_CloseOutputStreams(a1, v10, v11, v12, v13, v14, v15, v16);
  if (v21 >= 0 || (int)v17 <= -1) {
    uint64_t v17 = v17;
  }
  else {
    uint64_t v17 = v21;
  }
  if ((v17 & 0x80000000) == 0 || *(_DWORD *)(a1 + 268))
  {
    uint64_t v29 = *(void *)(a1 + 248);
    log_OutText(*(void *)(v29 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Send TTS_OUT_DONE message", v25, v26, v27, v75);
    *(void *)(a1 + 432) = 0;
    if (*(_DWORD *)(a1 + 208)) {
      kaldi::nnet1::Component::IsUpdatable(*(kaldi::nnet1::Component **)(a1 + 216));
    }
    uint64_t v30 = *(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, void, uint64_t))(a1 + 48);
    if (v30)
    {
      uint64_t v31 = *(void *)(a1 + 232);
      uint64_t v32 = *(void *)(v31 + 32);
      if (v32)
      {
        compstats_Start(v32, *(void *)(v31 + 40), *(unsigned __int16 *)(v31 + 24) + 2, v23, v24, v25, v26, v27);
        uint64_t v30 = *(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, void, uint64_t))(a1 + 48);
      }
      uint64_t v38 = v30(*(void *)(a1 + 88), 2, a1 + 424, a1 + 432, 0, a1 + 436);
      uint64_t v39 = *(void *)(a1 + 232);
      uint64_t v40 = *(void *)(v39 + 32);
      if (v40) {
        compstats_Stop(v40, *(void *)(v39 + 40), *(unsigned __int16 *)(v39 + 24) + 2, v33, v34, v35, v36, v37);
      }
      uint64_t v41 = *(void *)(v29 + 32);
      if ((v38 & 0x80000000) != 0) {
        log_OutText(v41, (uint64_t)"TTSEG", 4, 0, (uint64_t)"User PutOutput returned error %x", v35, v36, v37, v38);
      }
      else {
        log_OutText(v41, (uint64_t)"TTSEG", 4, 0, (uint64_t)"User PutOutput returned %p %u %u", v35, v36, v37, *(void *)(a1 + 424));
      }
    }
    else
    {
      LODWORD(v38) = 0;
    }
    if ((int)v38 >= 0 || (int)v17 <= -1) {
      uint64_t v17 = v17;
    }
    else {
      uint64_t v17 = v38;
    }
  }
  uint64_t v43 = *(void *)(a1 + 456);
  if (v43)
  {
    heap_Free(*(void **)(v9 + 8), v43);
    *(void *)(a1 + 456) = 0;
  }
  v76 = 0;
  uint64_t v44 = *(void *)(a1 + 544);
  if (v44)
  {
    uint64_t v45 = *(void *)(a1 + 232);
    if (v44 != v45)
    {
      int v46 = pipeline_ObjClose(v45, v43, v22, v23, v24, v25, v26, v27);
      if (v46 >= 0 || (int)v17 <= -1) {
        int v48 = v17;
      }
      else {
        int v48 = v46;
      }
      uint64_t v49 = *(void *)(a1 + 544);
      *(void *)(a1 + 232) = v49;
      paramc_ParamGetStr(*(void *)(*(void *)v49 + 40), (uint64_t)"fedatapackaging", &v76);
      paramc_ParamSetStr(*(void *)(**(void **)(a1 + 232) + 40), (uint64_t)"fedatapackaging", v76);
      int v57 = pipeline_ObjReopen(*(void *)(a1 + 232), v50, v51, v52, v53, v54, v55, v56);
      if (v57 >= 0 || v48 <= -1) {
        uint64_t v17 = v48;
      }
      else {
        uint64_t v17 = v57;
      }
    }
  }
  if (*(_DWORD *)(a1 + 288))
  {
    int v59 = (*(uint64_t (**)(void, void))(*(void *)(a1 + 128) + 40))(*(void *)(a1 + 272), *(void *)(a1 + 280));
    *(_DWORD *)(a1 + 288) = 0;
    if (v59 >= 0 || (int)v17 <= -1) {
      uint64_t v17 = v17;
    }
    else {
      uint64_t v17 = v59;
    }
  }
  if (*(_DWORD *)(a1 + 312))
  {
    int v61 = (*(uint64_t (**)(void, void))(*(void *)(a1 + 168) + 40))(*(void *)(a1 + 296), *(void *)(a1 + 304));
    *(_DWORD *)(a1 + 312) = 0;
    if (v61 >= 0 || (int)v17 <= -1) {
      uint64_t v17 = v17;
    }
    else {
      uint64_t v17 = v61;
    }
  }
  unsigned int v63 = *(uint64_t **)(a1 + 336);
  if (v63)
  {
    unsigned int v64 = paramc_ParamRestore(*(void *)(v9 + 40), v63);
    if ((v64 & 0x80000000) != 0)
    {
      unsigned int v69 = v64;
      log_OutPublic(*(void *)(v9 + 32), (uint64_t)"TTSEG", 16075, "%s%x", v65, v66, v67, v68, "lherror");
      if ((int)v17 >= 0) {
        uint64_t v17 = v69;
      }
      else {
        uint64_t v17 = v17;
      }
    }
    unsigned int v70 = paramc_ParamCloseRestorePoint(*(void *)(v9 + 40), *(char **)(a1 + 336));
    if ((v70 & 0x80000000) != 0)
    {
      unsigned int v71 = v70;
      log_OutPublic(*(void *)(v9 + 32), (uint64_t)"TTSEG", 16076, "%s%x", v24, v25, v26, v27, "lherror");
      if ((int)v17 >= 0) {
        uint64_t v17 = v71;
      }
      else {
        uint64_t v17 = v17;
      }
    }
    *(void *)(a1 + 336) = 0;
  }
  uint64_t v72 = *(void *)(a1 + 576);
  uint64_t v77 = 0;
  if (v72)
  {
    while ((tinystack_Pop(v72, &v77) & 0x80000000) == 0)
    {
      if (v77) {
        heap_Free(*(void **)(v9 + 8), v77);
      }
    }
  }
  uint64_t v73 = *(void *)(a1 + 408);
  if (v73)
  {
    heap_Free(*(void **)(v9 + 8), v73);
    *(void *)(a1 + 408) = 0;
  }
  log_OutEvent(*(uint64_t ***)(v9 + 32), 4, "%s%u%s%u%s%s", v23, v24, v25, v26, v27, "INPT");
  return v17;
}

BOOL ttseg_loc_ComponentIsTextParser(const char *a1)
{
  return !strcmp(a1, "pp/text_parser") || !strcmp(a1, "rby/pp") || strcmp(a1, "teng/pp") == 0;
}

uint64_t ttseg_loc_ProcessEnd(uint64_t a1, unsigned int a2, unsigned int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a1 + 248);
  if (a4) {
    *(_WORD *)(a1 + 396) = a2;
  }
  if (a2 >= a3)
  {
    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v12 = a2;
    do
    {
      log_OutText(*(void *)(v10 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Calling ProcessEnd for %s", a6, a7, a8, *(void *)(*(void *)(*(void *)(*(void *)(a1 + 232) + 16) + 8 * v12) + 8));
      uint64_t v18 = *(void **)(a1 + 232);
      uint64_t v19 = v18[4];
      if (v19)
      {
        compstats_Start(v19, v18[5], (v12 + 2), v13, v14, v15, v16, v17);
        uint64_t v18 = *(void **)(a1 + 232);
      }
      if (*(_DWORD *)(a1 + 240) == 2
        && !strcmp(*(const char **)(*(void *)(v18[2] + 8 * v12) + 8), (const char *)(a1 + 508)))
      {
        (*(void (**)(void, void))(*(void *)(a1 + 128) + 72))(*(void *)(a1 + 152), *(void *)(a1 + 160));
        uint64_t v18 = *(void **)(a1 + 232);
      }
      uint64_t v20 = *(void **)(v18[2] + 8 * v12);
      unsigned int v23 = (*(uint64_t (**)(void, void))(v20[2] + 112))(v20[3], v20[4]);
      uint64_t v24 = *(void *)(a1 + 232);
      uint64_t v25 = *(void *)(v24 + 32);
      if (v25) {
        compstats_Stop(v25, *(void *)(v24 + 40), (v12 + 2), v21, v22, a6, a7, a8);
      }
      if ((v23 & 0x80000000) != 0)
      {
        log_OutPublic(*(void *)(v10 + 32), (uint64_t)"TTSEG", 16019, "%s%s%s%x", v22, a6, a7, a8, "component");
        if ((int)v11 >= 0) {
          uint64_t v11 = v23;
        }
        else {
          uint64_t v11 = v11;
        }
      }
      ++v12;
    }
    while (a3 != (unsigned __int16)v12);
  }
  if (log_HasTraceTuningDataSubscriber(*(void *)(v10 + 32)))
  {
    uint64_t v26 = *(void *)(v10 + 32);
    uint64_t v27 = (*(uint64_t (**)(void))(*(void *)(a1 + 128) + 152))();
    log_OutTraceTuningDataBinary(v26, 401, 0, 0, v27, 0);
  }
  if (*(void *)(a1 + 496))
  {
    (*(void (**)(void, void))(*(void *)(a1 + 128) + 72))(*(void *)(a1 + 136), *(void *)(a1 + 144));
    heap_Free(*(void **)(v10 + 8), *(void *)(a1 + 496));
    *(void *)(a1 + 496) = 0;
  }
  return v11;
}

uint64_t ttseg_loc_CloseOutputStreams(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v20 = 0;
  if (*(void *)(a1 + 360))
  {
    int v9 = ttseg_loc_PutOutput(a1, 0, a3, a4, a5, a6, a7, a8);
    int v10 = v9 & (v9 >> 31);
    int v11 = (*(uint64_t (**)(void, void, int *))(*(void *)(a1 + 128) + 136))(*(void *)(a1 + 360), *(void *)(a1 + 368), &v20);
    if (v11 < 0)
    {
      if (v9 >= 0) {
        int v10 = v11;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 444) += (8 * v20) / *(_DWORD *)(a1 + 264);
    }
    LODWORD(v12) = (*(uint64_t (**)(void, void))(*(void *)(a1 + 128) + 72))(*(void *)(a1 + 360), *(void *)(a1 + 368));
    *(void *)(a1 + 360) = safeh_GetNullHandle();
    *(void *)(a1 + 368) = v13;
    if ((int)v12 >= 0 || v10 <= -1) {
      uint64_t v12 = v10;
    }
    else {
      uint64_t v12 = v12;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }
  uint64_t v15 = *(void *)(a1 + 376);
  if (v15)
  {
    int v16 = (*(uint64_t (**)(uint64_t, void))(*(void *)(a1 + 128) + 72))(v15, *(void *)(a1 + 384));
    *(void *)(a1 + 376) = safeh_GetNullHandle();
    *(void *)(a1 + 384) = v17;
    if (v16 >= 0 || (int)v12 <= -1) {
      return v12;
    }
    else {
      return v16;
    }
  }
  return v12;
}

_DWORD *ttseg_loc_NextMarkToDeliver(unsigned int a1, _DWORD *a2, unint64_t a3, _DWORD *a4)
{
  if (a4) {
    *a4 = 0;
  }
  if ((unint64_t)a2 >= a3) {
    return 0;
  }
  uint64_t result = 0;
  int v6 = (a1 >> 6) & 1;
  int v7 = (a1 >> 3) & 1;
  int v8 = a1 & 1;
  int v9 = (a1 >> 10) & 1;
  int v10 = (a1 >> 7) & 1;
  BOOL v11 = a1 != 0;
  int v12 = (a1 >> 4) & 1;
  int v13 = (a1 >> 8) & 1;
  int v14 = (a1 >> 5) & 1;
  int v15 = (a1 >> 9) & 1;
  int v16 = (a1 >> 1) & 1;
  int v17 = (a1 >> 2) & 1;
  while (2)
  {
    if (!result || a4 && a2[3] <= result[3])
    {
      int v18 = v11;
      switch(*a2)
      {
        case 0:
        case 2:
        case 5:
        case 6:
        case 7:
        case 9:
        case 0xA:
        case 0xB:
        case 0xC:
        case 0xD:
        case 0xE:
        case 0x15:
        case 0x16:
        case 0x1A:
        case 0x1F:
        case 0x20:
        case 0x22:
        case 0x25:
          goto LABEL_29;
        case 1:
          if (!v16) {
            goto LABEL_34;
          }
          goto LABEL_30;
        case 3:
        case 0xF:
        case 0x17:
        case 0x1B:
        case 0x1C:
        case 0x1E:
        case 0x23:
        case 0x27:
          goto LABEL_34;
        case 4:
          if (!v15) {
            goto LABEL_34;
          }
          goto LABEL_30;
        case 8:
          if (!v14) {
            goto LABEL_34;
          }
          goto LABEL_30;
        case 0x10:
        case 0x11:
        case 0x12:
        case 0x13:
        case 0x18:
          if (!v12) {
            goto LABEL_34;
          }
          goto LABEL_30;
        case 0x14:
          if (!v13) {
            goto LABEL_34;
          }
          goto LABEL_30;
        case 0x19:
          if (!v10) {
            goto LABEL_34;
          }
          goto LABEL_30;
        case 0x1D:
          if (!v7) {
            goto LABEL_34;
          }
          goto LABEL_30;
        case 0x21:
        case 0x26:
          if (!v17) {
            goto LABEL_34;
          }
          goto LABEL_30;
        case 0x24:
          int v18 = v6;
          goto LABEL_29;
        case 0x28:
          if (!v9) {
            goto LABEL_34;
          }
          goto LABEL_30;
        default:
          if (*a2 != 0x4000) {
            goto LABEL_34;
          }
          int v18 = v8;
          if (!a2[2]) {
            goto LABEL_34;
          }
LABEL_29:
          if (v18)
          {
LABEL_30:
            if (!result) {
              uint64_t result = a2;
            }
            if (a4) {
              ++*a4;
            }
          }
LABEL_34:
          a2 += 8;
          if ((unint64_t)a2 >= a3) {
            return result;
          }
          continue;
      }
    }
    return result;
  }
}

uint64_t ttseg_loc_PutOutput_TAI(void *a1, int a2, uint64_t a3)
{
  if (!a1[6]) {
    return 0;
  }
  uint64_t v3 = a1[31];
  uint64_t v4 = (uint64_t (*)(void, uint64_t, uint64_t, void *, void *, void, char *))a1[9];
  uint64_t v5 = a1 + 59;
  int v6 = a1 + 60;
  if (a2)
  {
    uint64_t v10 = v4(a1[11], 8, a3, v5, v6, a1[61], (char *)a1 + 484);
    if ((v10 & 0x80000000) != 0) {
      log_OutText(*(void *)(v3 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TA PutOutput (Data send) returned error %x", v7, v8, v9, v10);
    }
  }
  else
  {
    uint64_t v10 = v4(a1[11], 4, a3, v5, v6, 0, (char *)a1 + 484);
    if ((v10 & 0x80000000) != 0) {
      log_OutText(*(void *)(v3 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"TA PutOutput (Data req) returned error %x", v11, v12, v13, v10);
    }
  }
  return v10;
}

uint64_t ttseg_validateTaInfo(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  if ((ttseg_loc_BeginFunction(a1, a2, &v6, &v7) & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v4 = *(void *)(v7 + 552);
  while (v4 != a3)
  {
    uint64_t v4 = *(void *)(v4 + 168);
    if (!v4) {
      return 0;
    }
  }
  return 1;
}

uint64_t pipeline_ListPipelineComponentNames(_WORD *a1, int a2, char *a3, uint64_t *a4)
{
  unsigned int v47 = 0;
  uint64_t v5 = 2166366212;
  uint64_t v45 = 0;
  *(void *)int v46 = 0;
  uint64_t result = 2166366215;
  if (!a3) {
    return result;
  }
  if (!a4) {
    return result;
  }
  uint64_t result = InitRsrcFunction(a1, a2, v46);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  log_OutText(*(void *)(*(void *)v46 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"pipeline_ListPipelineComponentNames: Begin %s", v9, v10, v11, (uint64_t)a3);
  *a4 = 0;
  uint64_t v12 = pipeline_create_name_vector_for_query(*(void **)v46, a3, "COMPONENTS/*", &v45);
  uint64_t v16 = v45;
  if ((v12 & 0x80000000) != 0) {
    goto LABEL_58;
  }
  uint64_t v17 = *(void *)v46;
  int v48 = 0;
  uint64_t v50 = "lightssml";
  uint64_t v51 = 0;
  uint64_t v49 = "mparser/4sml";
  if (vector_GetElemAt(v45, 0, &v51))
  {
    if (!strcmp(*v51, "xcoder")) {
      vector_AddElemAt(v16, 0, &v50);
    }
    if ((paramc_ParamGetInt(*(void *)(v17 + 40), (uint64_t)"uselightssml", &v48) & 0x80000000) == 0)
    {
      uint64_t v22 = *v51;
      if (v48 == 1)
      {
        if (!strcmp(v22, "mparser/4sml"))
        {
          unsigned int v23 = &v50;
LABEL_16:
          vector_Remove(v16, 0);
          vector_AddElemAt(v16, 0, v23);
        }
      }
      else if (!strcmp(v22, "lightssml"))
      {
        unsigned int v23 = &v49;
        goto LABEL_16;
      }
    }
    uint64_t v12 = hlp_insert_after(*(uint64_t *)v46, v16, "xcoder", "voice_switch", is_not_sink_or_voice_switch);
    if ((v12 & 0x80000000) == 0)
    {
      pipeline_loc_DetermineEngine(*(uint64_t *)v46, v16, (int *)&v47);
      if (v47
        || (uint64_t v12 = hlp_insert_after(*(uint64_t *)v46, v16, "fe/be_adapt", "fe/fe_msp", is_not_sink_or_msp),
            (v12 & 0x80000000) == 0))
      {
        uint64_t v25 = *(void *)v46;
        uint64_t v51 = 0;
        int Size = vector_GetSize(v16);
        if (strstr(a3, "embedded-compact") || strstr(a3, "embedded-pro"))
        {
          uint64_t v27 = "synth/bet3fxd";
          uint64_t v28 = "select/bet3fxd";
        }
        else
        {
          uint64_t v27 = "synth/bet3fxd";
          uint64_t v28 = "select/bet3fxd";
          if (!strstr(a3, "embedded-high") && !strstr(a3, "22/bet3"))
          {
            uint64_t v28 = "select/bet3flt";
            uint64_t v27 = "synth/bet3flt";
          }
        }
        uint64_t v49 = v27;
        uint64_t v50 = v28;
        if (Size)
        {
          unsigned int v29 = 0;
          while (1)
          {
            if (!vector_GetElemAt(v16, v29, &v51))
            {
              uint64_t v24 = *(void *)(v25 + 32);
              goto LABEL_13;
            }
            uint64_t v30 = *v51;
            if (!strcmp(*v51, "select/bet3"))
            {
              vector_Remove(v16, v29);
              vector_AddElemAt(v16, v29, &v50);
              uint64_t v30 = *v51;
            }
            if (!strcmp(v30, "synth/bet3")) {
              break;
            }
            if (Size == ++v29) {
              goto LABEL_33;
            }
          }
          vector_Remove(v16, v29);
          vector_AddElemAt(v16, v29, &v49);
        }
LABEL_33:
        unsigned int v31 = v47;
        if (v47 <= 1)
        {
          uint64_t v44 = *(void *)v46;
          uint64_t v50 = "audioinserter";
          uint64_t v51 = 0;
          int v32 = vector_GetSize(v16);
          if (v32)
          {
            int v33 = v32;
            unsigned int v34 = 0;
            while (vector_GetElemAt(v16, v34, &v51))
            {
              uint64_t v35 = *v51;
              if (!strcmp(*v51, v50)) {
                goto LABEL_47;
              }
              if (!strcmp(v35, "audiocvt") || !strcmp(v35, "phonmap/mrk"))
              {
                vector_AddElemAt(v16, v34, &v50);
                goto LABEL_47;
              }
              if (v33 == ++v34) {
                goto LABEL_47;
              }
            }
            uint64_t v24 = *(void *)(v44 + 32);
            goto LABEL_13;
          }
LABEL_47:
          unsigned int v31 = v47;
        }
        if (v31 == 2) {
          uint64_t v36 = "teng/mrkaligner";
        }
        else {
          uint64_t v36 = "audioinserter";
        }
        uint64_t v12 = hlp_insert_after(*(uint64_t *)v46, v16, v36, "dspeffects", (uint64_t (*)(const char *))is_not_dspeffects);
        if ((v12 & 0x80000000) == 0)
        {
          uint64_t v37 = *(void *)v46;
          uint64_t v51 = 0;
          int v38 = vector_GetSize(v16);
          if (v38)
          {
            int v39 = v38;
            unsigned int v40 = 0;
            while (1)
            {
              if (!vector_GetElemAt(v16, v40, &v51))
              {
                log_OutText(*(void *)(v37 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Unable to remove component '%s'", v41, v42, v43, (uint64_t)"nlu/nluhtmlparser");
                goto LABEL_59;
              }
              if (!strcmp(*v51, "nlu/nluhtmlparser")) {
                break;
              }
              if (v39 == ++v40) {
                goto LABEL_66;
              }
            }
            vector_Remove(v16, v40);
          }
LABEL_66:
          uint64_t v5 = 0;
          *a4 = v16;
          goto LABEL_59;
        }
      }
    }
LABEL_58:
    uint64_t v5 = v12;
    goto LABEL_59;
  }
  uint64_t v24 = *(void *)(v17 + 32);
LABEL_13:
  log_OutPublic(v24, (uint64_t)"TTSEG", 16092, "%s%s", v18, v19, v20, v21, "pipeline");
LABEL_59:
  log_OutText(*(void *)(*(void *)v46 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"pipeline_ListPipelineComponentNames: End %s", v13, v14, v15, (uint64_t)a3);
  if ((v5 & 0x80000000) != 0)
  {
    if (v16) {
      vector_ObjClose(v16);
    }
  }
  return v5;
}

uint64_t pipeline_create_name_vector_for_query(void *a1, unsigned char *a2, char *__s1, void *a4)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  uint64_t v30 = &v32;
  uint64_t v31 = 0;
  uint64_t v28 = 0;
  unsigned int v29 = 0;
  uint64_t v27 = 0;
  BOOL v8 = strcmp(__s1, "OBJECTS/*") == 0;
  uint64_t v13 = brk_TagIteratorOpen(a1[3], a2, __s1, v8, &v31);
  if ((v13 & 0x80000000) != 0)
  {
    log_OutPublic(a1[4], (uint64_t)"TTSEG", 16072, "%s%s", v9, v10, v11, v12, "pipeline");
LABEL_17:
    if (v27) {
      vector_ObjClose(v27);
    }
    uint64_t v27 = 0;
  }
  else
  {
    uint64_t v14 = (void *)a1[1];
    long long v25 = xmmword_26C21F818;
    uint64_t v26 = off_26C21F828;
    if (vector_ObjOpen(v14, &v25, 64, &v27))
    {
      while ((brk_TagIteratorNext(v31, (uint64_t)&v29, (uint64_t)&v28) & 0x80000000) == 0)
      {
        unsigned int v23 = v29;
        if (!v29 || !strcmp(__s1, "COMPONENTS/*") && strcmp(v23, "COMPONENT"))
        {
          uint64_t v13 = 2166366212;
          log_OutPublic(a1[4], (uint64_t)"TTSEG", 16091, "%s%s%s%s", v19, v20, v21, v22, "pipeline");
          goto LABEL_17;
        }
        if (v28 && *v28)
        {
          if (!strcmp(__s1, "OBJECTS/*"))
          {
            __strcpy_chk();
            __strcat_chk();
            __strcat_chk();
          }
          else
          {
            __strcpy_chk();
          }
          if (vector_Add(v27, &v30)) {
            continue;
          }
        }
        uint64_t v13 = 2166366212;
        log_OutPublic(a1[4], (uint64_t)"TTSEG", 16092, "%s%s", v19, v20, v21, v22, "pipeline");
        goto LABEL_17;
      }
    }
    else
    {
      log_OutPublic(a1[4], (uint64_t)"TTSEG", 16072, "%s%s", v15, v16, v17, v18, "pipeline");
    }
  }
  *a4 = v27;
  if (v31) {
    brk_TagIteratorClose(v31);
  }
  return v13;
}

uint64_t pipeline_loc_DetermineEngine(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v15 = 0;
  uint64_t result = vector_GetSize(a2);
  if (!a3)
  {
    while (1)
LABEL_9:
      log_OutText(*(void *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Unable to determine the engine of the pipeline", v7, v8, v9, v14);
  }
  int v10 = result;
  *a3 = 0;
  if (result)
  {
    unsigned int v11 = 0;
    while (1)
    {
      if (!vector_GetElemAt(a2, v11, &v15)) {
        goto LABEL_9;
      }
      uint64_t v12 = *v15;
      uint64_t result = strcmp(*v15, "rby/ling");
      if (!result)
      {
        int v13 = 1;
        goto LABEL_12;
      }
      uint64_t result = strcmp(v12, "teng/synth");
      if (!result) {
        break;
      }
      if (v10 == ++v11) {
        return result;
      }
    }
    int v13 = 2;
LABEL_12:
    *a3 = v13;
  }
  return result;
}

uint64_t pipeline_ObjOpen(_WORD *a1, uint64_t a2, char *a3, uint64_t a4, int a5, uint64_t a6, uint64_t **a7, _DWORD *a8)
{
  uint64_t v106 = *MEMORY[0x263EF8340];
  int v104 = 0;
  uint64_t v102 = 0;
  __s2 = 0;
  *(void *)v100 = 0;
  v101 = 0;
  uint64_t v98 = 0;
  v99 = 0;
  uint64_t v96 = 0;
  uint64_t v97 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, v100);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  *a7 = 0;
  *a8 = 0;
  log_OutText(*(void *)(*(void *)v100 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"pipeline_ObjOpen : Begin %s", v17, v18, v19, (uint64_t)a3);
  *(void *)__s = 0;
  uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"mlset", &byte_20D5A22AE);
  if ((v27 & 0x1FFF) == 0xA) {
    goto LABEL_28;
  }
  uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"voiceml", &byte_20D5A22AE);
  if ((v27 & 0x1FFF) == 0xA) {
    goto LABEL_28;
  }
  uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"noclmset", &byte_20D5A22AE);
  if ((v27 & 0x1FFF) == 0xA) {
    goto LABEL_28;
  }
  uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"shortfragmentforceclm", &byte_20D5A22AE);
  if ((v27 & 0x1FFF) == 0xA) {
    goto LABEL_28;
  }
  uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"shortfragmentforceclm_value_pipeline", &byte_20D5A22AE);
  if ((v27 & 0x1FFF) == 0xA) {
    goto LABEL_28;
  }
  uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"extclccfg", &byte_20D5A22AE);
  if ((v27 & 0x1FFF) == 0xA) {
    goto LABEL_28;
  }
  uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"feextcfgdataprefix", &byte_20D5A22AE);
  if ((v27 & 0x1FFF) == 0xA) {
    goto LABEL_28;
  }
  uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"voicecomponentid", &byte_20D5A22AE);
  if ((v27 & 0x1FFF) == 0xA) {
    goto LABEL_28;
  }
  uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"engine_support_base_release", &byte_20D5A22AE);
  if ((v27 & 0x1FFF) == 0xA) {
    goto LABEL_28;
  }
  uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"engine_support_point_releases", &byte_20D5A22AE);
  if ((v27 & 0x1FFF) == 0xA) {
    goto LABEL_28;
  }
  paramc_ParamGetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"lidlanguages", __s);
  if (!*(void *)__s)
  {
    uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"lidlanguages", &byte_20D5A22AE);
    if ((v27 & 0x1FFF) == 0xA) {
      goto LABEL_28;
    }
  }
  uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"extraesclang", &byte_20D5A22AE);
  if ((v27 & 0x1FFF) == 0xA) {
    goto LABEL_28;
  }
  uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"extraesctn", &byte_20D5A22AE);
  if ((v27 & 0x1FFF) == 0xA) {
    goto LABEL_28;
  }
  uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"typeofsynthesis", &byte_20D5A22AE);
  if ((v27 & 0x1FFF) == 0xA) {
    goto LABEL_28;
  }
  uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"fedatapackaging", &byte_20D5A22AE);
  if ((v27 & 0x1FFF) == 0xA) {
    goto LABEL_28;
  }
  uint64_t v27 = paramc_ParamSetUInt(*(void *)(*(void *)v100 + 40), (uint64_t)"prmigexists", 0);
  if ((v27 & 0x1FFF) == 0xA) {
    goto LABEL_28;
  }
  paramc_ParamRemove(*(void *)(*(void *)v100 + 40), (uint64_t)"voiceoperatingpoint");
  paramc_ParamRemove(*(void *)(*(void *)v100 + 40), (uint64_t)"uselectrawdataversion");
  paramc_ParamRemove(*(void *)(*(void *)v100 + 40), (uint64_t)"uselectreductionversion");
  paramc_ParamRemove(*(void *)(*(void *)v100 + 40), (uint64_t)"nnpausingthresholdpercent");
  uint64_t v28 = paramc_ParamSetUInt(*(void *)(*(void *)v100 + 40), (uint64_t)"bet4nodeprunemax", 0);
  if ((v28 & 0x1FFF) != 0xA)
  {
    uint64_t v28 = paramc_ParamSetUInt(*(void *)(*(void *)v100 + 40), (uint64_t)"bet4beamwidth", 0);
    if ((v28 & 0x1FFF) != 0xA)
    {
      uint64_t v28 = paramc_ParamSetUInt(*(void *)(*(void *)v100 + 40), (uint64_t)"bet4nodelimit", 0);
      if ((v28 & 0x1FFF) != 0xA)
      {
        uint64_t v28 = paramc_ParamSetUInt(*(void *)(*(void *)v100 + 40), (uint64_t)"bet4nodeprunemaxunvoiced", 0);
        if ((v28 & 0x1FFF) != 0xA)
        {
          uint64_t v28 = paramc_ParamSetUInt(*(void *)(*(void *)v100 + 40), (uint64_t)"timbre_baseline", 0x64u);
          if ((v28 & 0x1FFF) != 0xA)
          {
            uint64_t v28 = paramc_ParamSetUInt(*(void *)(*(void *)v100 + 40), (uint64_t)"pitch_baseline", 0x64u);
            if ((v28 & 0x1FFF) != 0xA)
            {
              uint64_t v28 = paramc_ParamSetUInt(*(void *)(*(void *)v100 + 40), (uint64_t)"rate_baseline", 0x64u);
              if ((v28 & 0x1FFF) != 0xA)
              {
                uint64_t v28 = paramc_ParamSetUInt(*(void *)(*(void *)v100 + 40), (uint64_t)"volume_baseline", 0x50u);
                if ((v28 & 0x1FFF) != 0xA)
                {
                  paramc_ParamRemove(*(void *)(*(void *)v100 + 40), (uint64_t)"basicclcprosody");
                  paramc_ParamRemove(*(void *)(*(void *)v100 + 40), (uint64_t)"punctmarks");
                  paramc_ParamRemove(*(void *)(*(void *)v100 + 40), (uint64_t)"addondct_extended_lookup");
                  paramc_ParamRemove(*(void *)(*(void *)v100 + 40), (uint64_t)"nnpausingoverride");
                  uint64_t v95 = heap_Calloc(*(void **)(*(void *)v100 + 8), 1, 56);
                  if (!v95)
                  {
                    uint64_t v27 = 2166366218;
                    log_OutPublic(*(void *)(*(void *)v100 + 32), (uint64_t)"TTSEG", 16000, 0, v32, v33, v34, v35, v92);
                    goto LABEL_28;
                  }
                  *(void *)uint64_t v95 = *(void *)v100;
                  uint64_t v36 = heap_strdup(*(void *)(*(void *)v100 + 8), a3);
                  *(void *)(v95 + 8) = v36;
                  if (v36)
                  {
                    uint64_t v41 = pipeline_ListPipelineComponentNames(a1, a2, a3, &v97);
                    if ((v41 & 0x80000000) != 0)
                    {
                      uint64_t v27 = v41;
LABEL_59:
                      uint64_t v29 = 0;
                      uint64_t v30 = (uint64_t *)v95;
                      goto LABEL_29;
                    }
                    pipeline_loc_DetermineEngine(*(uint64_t *)v100, v97, &v104);
                    unsigned __int16 Size = vector_GetSize(v97);
                    *(_WORD *)(v95 + 24) = Size;
                    uint64_t v43 = heap_Calloc(*(void **)(*(void *)v100 + 8), Size, 8);
                    *(void *)(v95 + 16) = v43;
                    uint64_t v44 = *(void *)v100;
                    if (v43)
                    {
                      uint64_t v45 = heap_Calloc(*(void **)(*(void *)v100 + 8), *(unsigned __int16 *)(v95 + 24), 16);
                      uint64_t v46 = *(void *)(*(void *)v100 + 32);
                      uint64_t v94 = v45;
                      if (v45)
                      {
                        unsigned int LogLevel = log_GetLogLevel(v46);
                        LODWORD(v48) = *(unsigned __int16 *)(v95 + 24);
                        if (LogLevel >= 2)
                        {
                          compstats_ObjOpen(a1, a2, v48 + 3, v95 + 32);
                          compstats_Start(*(void *)(v95 + 32), *(void *)(v95 + 40), 0, v49, v50, v51, v52, v53);
                          uint64_t v48 = *(unsigned __int16 *)(v95 + 24);
                          if (*(void *)(v95 + 32))
                          {
                            uint64_t v54 = heap_Calloc(*(void **)(*(void *)v100 + 8), v48 + 3, 8);
                            *(void *)(v95 + 48) = v54;
                            if (v54)
                            {
                              **(void **)(v95 + 48) = heap_strdup(*(void *)(*(void *)v100 + 8), "Total");
                              *(void *)(*(void *)(v95 + 48) + 8) = heap_strdup(*(void *)(*(void *)v100 + 8), "TTSEG input CB");
                              uint64_t v55 = heap_strdup(*(void *)(*(void *)v100 + 8), "TTSEG output CB");
                              LODWORD(v48) = *(unsigned __int16 *)(v95 + 24);
                              *(void *)(*(void *)(v95 + 48) + 8 * *(unsigned __int16 *)(v95 + 24) + 16) = v55;
                            }
                            else
                            {
                              compstats_ObjClose(*(void *)(v95 + 32), *(void *)(v95 + 40));
                              *(void *)(v95 + 32) = safeh_GetNullHandle();
                              *(void *)(v95 + 40) = v56;
                              LODWORD(v48) = *(unsigned __int16 *)(v95 + 24);
                            }
                          }
                        }
                        if (v48)
                        {
                          unint64_t v57 = 0;
                          do
                          {
                            *(void *)__s = 0;
                            if (!vector_GetElemAt(v97, v57, __s))
                            {
                              log_OutPublic(*(void *)(*(void *)v100 + 32), (uint64_t)"TTSEG", 16000, 0, v58, v59, v60, v61, v92);
                              uint64_t v27 = 2166366212;
                              goto LABEL_76;
                            }
                            v62 = **(char ***)__s;
                            v101 = **(char ***)__s;
                            if (!a4 || (pipeline_Find(a4, v62, &v99) & 0x80000000) != 0)
                            {
                              uint64_t Object = pipeline_PrepareForOpeningComponent(*(uint64_t **)v100, (unsigned __int16)v57, v62, (void *)v95);
                              if ((Object & 0x80000000) != 0) {
                                goto LABEL_73;
                              }
                            }
                            else
                            {
                              unsigned int v63 = v99;
                              *(void *)(*(void *)(v95 + 16) + 8 * v57) = v99;
                              ++*v63;
                              if (*(void *)(v95 + 32)) {
                                *(void *)(*(void *)(v95 + 48) + 8 * v57 + 16) = heap_strdup(*(void *)(*(void *)v100 + 8), v101);
                              }
                            }
                            ++v57;
                          }
                          while (v57 < *(unsigned __int16 *)(v95 + 24));
                        }
                        uint64_t Object = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"pipeline", a3);
                        if ((Object & 0x1FFF) == 0xA
                          || (uint64_t Object = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"fedatapackaging", &byte_20D5A22AE), (Object & 0x1FFF) == 0xA))
                        {
LABEL_73:
                          uint64_t v27 = Object;
                          goto LABEL_76;
                        }
                        uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"datapackagename", &byte_20D5A22AE);
                        if ((v27 & 0x1FFF) == 0xA) {
                          goto LABEL_76;
                        }
                        if ((brk_TagIteratorOpen(*(void *)(*(void *)v100 + 24), a3, "PARAMETERS/*", 1, &v98) & 0x80000000) == 0)
                        {
                          if ((brk_TagIteratorNext(v98, (uint64_t)&__s2, (uint64_t)&v101) & 0x80000000) == 0)
                          {
                            int v93 = 0;
                            int v65 = 0;
                            while (1)
                            {
                              uint64_t v66 = __s2;
                              if (__s2 && *__s2)
                              {
                                if (!strcmp("vopversion", __s2)) {
                                  int v65 = 1;
                                }
                                if (strcmp("waitfactor", v66)) {
                                  goto LABEL_185;
                                }
                                __s[0] = 1;
                                if ((paramc_ParamGetUInt(*(void *)(*(void *)v100 + 40), (uint64_t)"waitfactor", __s) & 0x80000000) == 0)uint64_t v27 = paramc_ParamSetUInt(*(void *)(*(void *)v100 + 40), (uint64_t)"waitfactorpipelinebackup", __s[0]); {
                                if ((v27 & 0x1FFF) == 0xA)
                                }
                                  goto LABEL_76;
                                uint64_t v66 = __s2;
                                int v93 = 1;
                                if (__s2)
                                {
LABEL_185:
                                  if (*v66 && (a5 == 0xFFFF || strncmp("audiooutput", v66, 0xBuLL)))
                                  {
                                    if (strcmp("extraesclang", v66) && strcmp("extraesctn", v66)) {
                                      goto LABEL_99;
                                    }
                                    *(void *)__s = 0;
                                    if ((paramc_ParamGetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"clcpreventhlpactivate", __s) & 0x80000000) == 0)
                                    {
                                      uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"clcpreventhlpactivate", "yes");
                                      if ((v27 & 0x1FFF) == 0xA) {
                                        goto LABEL_76;
                                      }
                                    }
                                    uint64_t v66 = __s2;
                                    if (__s2)
                                    {
LABEL_99:
                                      if (*v66 && !strcmp("waitfactor", v66))
                                      {
                                        __s[0] = 0;
                                        if ((paramc_ParamGetUInt(*(void *)(*(void *)v100 + 40), (uint64_t)"waitfactorsetbyapi", __s) & 0x80000000) != 0|| __s[0] != 1)
                                        {
                                          if (v101) {
                                            unsigned int v70 = v101;
                                          }
                                          else {
                                            unsigned int v70 = &byte_20D5A22AE;
                                          }
                                          uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)__s2, v70);
                                        }
                                        int v69 = v27 & 0x1FFF;
LABEL_116:
                                        if (v69 == 10) {
                                          goto LABEL_76;
                                        }
                                        goto LABEL_117;
                                      }
                                    }
                                    if (v101) {
                                      uint64_t v67 = v101;
                                    }
                                    else {
                                      uint64_t v67 = &byte_20D5A22AE;
                                    }
                                    uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)v66, v67);
                                    if ((v27 & 0x1FFF) == 0xA) {
                                      goto LABEL_76;
                                    }
                                    if (!strcmp("shortfragmentforceclm", __s2))
                                    {
                                      if (v101) {
                                        uint64_t v68 = v101;
                                      }
                                      else {
                                        uint64_t v68 = &byte_20D5A22AE;
                                      }
                                      uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"shortfragmentforceclm_value_pipeline", v68);
                                      int v69 = v27 & 0x1FFF;
                                      goto LABEL_116;
                                    }
                                  }
                                }
                              }
LABEL_117:
                              if ((brk_TagIteratorNext(v98, (uint64_t)&__s2, (uint64_t)&v101) & 0x80000000) != 0) {
                                goto LABEL_120;
                              }
                            }
                          }
                          int v65 = 0;
                          int v93 = 0;
LABEL_120:
                          uint64_t v27 = vopCheckEngineCompatibility(*(uint64_t *)v100);
                          if ((v27 & 0x80000000) != 0) {
                            goto LABEL_76;
                          }
                          if (!v65) {
                            uint64_t v27 = paramc_ParamSetStr(*(void *)(*(void *)v100 + 40), (uint64_t)"vopversion", "0.0.0");
                          }
                          if ((v27 & 0x1FFF) == 0xA) {
                            goto LABEL_76;
                          }
                          if (!v93)
                          {
                            __s[0] = 1;
                            if ((paramc_ParamGetUInt(*(void *)(*(void *)v100 + 40), (uint64_t)"waitfactorpipelinebackup", __s) & 0x80000000) == 0)
                            {
                              uint64_t v27 = paramc_ParamSetUInt(*(void *)(*(void *)v100 + 40), (uint64_t)"waitfactor", __s[0]);
                              if ((v27 & 0x1FFF) == 0xA) {
                                goto LABEL_76;
                              }
                              uint64_t v27 = paramc_ParamSetUInt(*(void *)(*(void *)v100 + 40), (uint64_t)"waitfactorpipelinebackup", __s[0]);
                              if ((v27 & 0x1FFF) == 0xA) {
                                goto LABEL_76;
                              }
                            }
                          }
                          brk_TagIteratorClose(v98);
                          uint64_t v98 = 0;
                        }
                        if ((pipeline_create_name_vector_for_query(*(void **)v100, a3, "OBJECTS/*", &v96) & 0x80000000) == 0)
                        {
                          uint64_t v71 = v96;
                          if (!v104)
                          {
                            uint64_t Object = hlp_insert_after(*(uint64_t *)v100, v96, "FE_DCTLKP|fe/fe_dctlkp", "FE_NN|fe/fe_nn", 0);
                            if ((Object & 0x80000000) != 0) {
                              goto LABEL_73;
                            }
                          }
                          uint64_t Object = hlp_insert_after(*(uint64_t *)v100, v71, "INET|inetspi", "CHARCOUNT|charcount", 0);
                          if ((Object & 0x80000000) != 0) {
                            goto LABEL_73;
                          }
                          uint64_t Object = hlp_append(*(uint64_t *)v100, v71);
                          if ((Object & 0x80000000) != 0) {
                            goto LABEL_73;
                          }
                          if (vector_GetSize(v71))
                          {
                            unsigned int v72 = 0;
                            int v73 = 0;
                            uint64_t v27 = 2166366208;
                            do
                            {
                              if (!vector_GetElemAt(v71, v72, &v102)) {
                                goto LABEL_76;
                              }
                              __strcpy_chk();
                              if (*(void *)__s != 0x656E697C54454E49
                                || *(void *)((char *)&__s[1] + 1) != 0x69707374656E69)
                              {
                                uint64_t v75 = strchr((char *)__s, 124);
                                v101 = v75;
                                if (!v75) {
                                  goto LABEL_76;
                                }
                                *uint64_t v75 = 0;
                                ++v101;
                                __s2 = (char *)__s;
                                uint64_t Object = pipeline_LoadObject(a1, a2, (uint64_t)__s, v101, a6, a8);
                                if ((Object & 0x80000000) != 0) {
                                  goto LABEL_73;
                                }
                              }
                              unsigned int v72 = (unsigned __int16)++v73;
                            }
                            while (vector_GetSize(v71) > (unsigned __int16)v73);
                          }
                        }
                        uint64_t Object = pipeline_disclose_location_of_fe_clm_component(*(uint64_t *)v100, v95);
                        if ((Object & 0x80000000) != 0) {
                          goto LABEL_73;
                        }
                        uint64_t v27 = pipeline_disclose_processing_tnplus(*(uint64_t *)v100, v95);
                        if ((v27 & 0x80000000) != 0) {
                          goto LABEL_76;
                        }
                        unsigned int v76 = *(unsigned __int16 *)(v95 + 24);
                        if (*(_WORD *)(v95 + 24))
                        {
                          unint64_t v77 = 0;
                          v78 = (void *)(v94 + 8);
                          while (1)
                          {
                            v79 = *(uint64_t **)(*(void *)(v95 + 16) + 8 * v77);
                            if (!v79) {
                              goto LABEL_157;
                            }
                            uint64_t v80 = *(void *)(v95 + 32);
                            if (v80) {
                              compstats_Start(v80, *(void *)(v95 + 40), (v77 + 2), v22, v23, v24, v25, v26);
                            }
                            uint64_t NullHandle = safeh_GetNullHandle();
                            if (safeh_HandlesEqual(v79[3], v79[4], NullHandle, v82)) {
                              break;
                            }
                            if (*(void *)(v79[2] + 48))
                            {
                              log_OutText(*(void *)(*(void *)v100 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Reopen component: %s", v24, v25, v26, v79[1]);
                              *a8 = 1;
                              kaldi::nnet1::Component::IsUpdatable(*(kaldi::nnet1::Component **)(*(void *)v100 + 40));
                              uint64_t v83 = (*(uint64_t (**)(uint64_t, uint64_t))(v79[2] + 48))(v79[3], v79[4]);
                              goto LABEL_152;
                            }
LABEL_153:
                            uint64_t v84 = *(void *)(v95 + 32);
                            if (v84) {
                              compstats_Stop(v84, *(void *)(v95 + 40), (v77 + 2), v22, v23, v24, v25, v26);
                            }
                            if ((v27 & 0x80000000) != 0)
                            {
                              log_OutPublic(*(void *)(*(void *)v100 + 32), (uint64_t)"TTSEG", 16001, "%s%s%s%x", v23, v24, v25, v26, "component");
                              goto LABEL_76;
                            }
                            unsigned int v76 = *(unsigned __int16 *)(v95 + 24);
LABEL_157:
                            ++v77;
                            v78 += 2;
                            if (v77 >= v76) {
                              goto LABEL_158;
                            }
                          }
                          log_OutText(*(void *)(*(void *)v100 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Open component: %s", v24, v25, v26, v79[1]);
                          kaldi::nnet1::Component::IsUpdatable(*(kaldi::nnet1::Component **)(*(void *)v100 + 40));
                          uint64_t v83 = (*(uint64_t (**)(void, void, _WORD *, uint64_t, uint64_t *))(v79[2] + 32))(*(v78 - 1), *v78, a1, a2, v79 + 3);
LABEL_152:
                          uint64_t v27 = v83;
                          kaldi::nnet1::Component::IsUpdatable(*(kaldi::nnet1::Component **)(*(void *)v100 + 40));
                          goto LABEL_153;
                        }
LABEL_158:
                        uint64_t v85 = brk_TagIteratorOpen(*(void *)(*(void *)v100 + 24), a3, "RESOURCES/*", 1, &v98);
                        uint64_t v27 = v85;
                        if ((v85 & 0x80000000) != 0)
                        {
                          if ((v85 & 0x1FFF) != 0xD && (v85 & 0x1FFF) != 20) {
                            goto LABEL_76;
                          }
                          uint64_t v27 = 0;
                        }
                        while ((brk_TagIteratorNext(v98, (uint64_t)&__s2, (uint64_t)&v101) & 0x80000000) == 0)
                        {
                          if (__s2 && !strcmp(__s2, "RESOURCE"))
                          {
                            if (v101 && *v101)
                            {
                              log_OutPublic(*(void *)(*(void *)v100 + 32), (uint64_t)"TTSEG", 16095, "%s%s", v87, v88, v89, v90, "pipeline");
                              uint64_t v27 = 2166366212;
                            }
                            else
                            {
                              log_OutPublic(*(void *)(*(void *)v100 + 32), (uint64_t)"TTSEG", 16094, "%s%s", v87, v88, v89, v90, "pipeline");
                            }
                          }
                          else
                          {
                            log_OutPublic(*(void *)(*(void *)v100 + 32), (uint64_t)"TTSEG", 16093, "%s%s%s%s", v87, v88, v89, v90, "pipeline");
                          }
                        }
                        brk_TagIteratorClose(v98);
                        uint64_t v98 = 0;
                        uint64_t v91 = *(void *)(v95 + 32);
                        if (v91 && *(void *)(v95 + 48))
                        {
                          uint64_t v30 = (uint64_t *)v95;
                          compstats_Stop(v91, *(void *)(v95 + 40), 0, v22, v23, v24, v25, v26);
                          compstats_Log(v30[4], v30[5], *(void *)(*(void *)v100 + 32), "Pipeline Open", v30[6], 0, 0);
                          goto LABEL_77;
                        }
LABEL_76:
                        uint64_t v30 = (uint64_t *)v95;
LABEL_77:
                        uint64_t v29 = v94;
                        goto LABEL_29;
                      }
                      uint64_t v27 = 2166366218;
                      goto LABEL_58;
                    }
                    uint64_t v27 = 2166366218;
                  }
                  else
                  {
                    uint64_t v27 = 2166366218;
                    uint64_t v44 = *(void *)v100;
                  }
                  uint64_t v46 = *(void *)(v44 + 32);
LABEL_58:
                  log_OutPublic(v46, (uint64_t)"TTSEG", 16000, 0, v37, v38, v39, v40, v92);
                  goto LABEL_59;
                }
              }
            }
          }
        }
      }
    }
  }
  uint64_t v27 = v28;
LABEL_28:
  uint64_t v29 = 0;
  uint64_t v30 = 0;
LABEL_29:
  if (v97) {
    vector_ObjClose(v97);
  }
  if (v96) {
    vector_ObjClose(v96);
  }
  if (v98) {
    brk_TagIteratorClose(v98);
  }
  if (v29) {
    heap_Free(*(void **)(*(void *)v100 + 8), v29);
  }
  if ((v27 & 0x80000000) != 0)
  {
    if (v30) {
      pipeline_ObjClose((uint64_t)v30, v20, v21, v22, v23, v24, v25, v26);
    }
  }
  else
  {
    *a7 = v30;
  }
  log_OutText(*(void *)(*(void *)v100 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"pipeline_ObjOpen : End (%x)", v24, v25, v26, v27);
  return v27;
}

uint64_t pipeline_Find(uint64_t a1, char *__s2, void *a3)
{
  uint64_t v3 = 2166366215;
  if (a1 && __s2 && *__s2)
  {
    *a3 = 0;
    uint64_t v6 = *(unsigned __int16 *)(a1 + 24);
    if (*(_WORD *)(a1 + 24))
    {
      for (i = *(uint64_t **)(a1 + 16); ; ++i)
      {
        uint64_t v8 = *i;
        if (!strcmp(*(const char **)(*i + 8), __s2)) {
          break;
        }
        if (!--v6) {
          return 2166366228;
        }
      }
      uint64_t v3 = 0;
      *a3 = v8;
    }
    else
    {
      return 2166366228;
    }
  }
  return v3;
}

uint64_t pipeline_PrepareForOpeningComponent(uint64_t *a1, unsigned int a2, char *__s, void *a4)
{
  if (a4[4])
  {
    uint64_t v8 = heap_strdup(a1[1], __s);
    uint64_t v9 = a2 + 2;
    *(void *)(a4[6] + 8 * v9) = v8;
    compstats_Start(a4[4], a4[5], v9, v10, v11, v12, v13, v14);
  }
  uint64_t v15 = (_WORD *)heap_Calloc((void *)a1[1], 1, 40);
  if (!v15)
  {
    uint64_t v32 = 2166366218;
    log_OutPublic(a1[4], (uint64_t)"TTSEG", 16000, 0, v16, v17, v18, v19, v36);
    return v32;
  }
  uint64_t v20 = v15;
  *(void *)(a4[2] + 8 * a2) = v15;
  *uint64_t v15 = 1;
  uint64_t v21 = heap_strdup(a1[1], __s);
  v20[1] = v21;
  if (v21)
  {
    v20[3] = safeh_GetNullHandle();
    v20[4] = v26;
    uint64_t v32 = brk_InterfaceQuery(a1[3]);
    if ((v32 & 0x80000000) == 0)
    {
      uint64_t v33 = a4[4];
      if (v33) {
        compstats_Stop(v33, a4[5], a2 + 2, v27, v28, v29, v30, v31);
      }
      return v32;
    }
  }
  else
  {
    uint64_t v32 = 2166366218;
    log_OutPublic(a1[4], (uint64_t)"TTSEG", 16000, 0, v22, v23, v24, v25, v36);
  }
  uint64_t v34 = v20[1];
  if (v34) {
    heap_Free((void *)a1[1], v34);
  }
  heap_Free((void *)a1[1], (uint64_t)v20);
  *(void *)(a4[2] + 8 * a2) = 0;
  return v32;
}

uint64_t vopCheckEngineCompatibility(uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  __sprintf_chk(v30, 0, 0x20uLL, "%.2d.%.2d.%d", 23, 3, 2);
  uint64_t v2 = 0;
  if ((paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"engine_support_base_release", &v26) & 0x80000000) == 0 && v26)
  {
    if (*v26)
    {
      LOBYTE(v27) = 0;
      __int16 v29 = 0;
      uint64_t MajorMinorMaintAndSearchNext = versionGetMajorMinorMaintAndSearchNext(v26, &v27, (unsigned char *)&v29 + 1, &v29, 0);
      if ((MajorMinorMaintAndSearchNext & 0x80000000) != 0)
      {
        uint64_t v2 = MajorMinorMaintAndSearchNext;
        if ((MajorMinorMaintAndSearchNext & 0x1FFF) != 0x19)
        {
          uint64_t v9 = *(void *)(a1 + 32);
          uint64_t v10 = "VOP level compatibility check current engine '%s' against main '%s': failed (format error)";
LABEL_43:
          log_OutText(v9, (uint64_t)"TTSEG", 4, 0, (uint64_t)v10, v4, v5, v6, (uint64_t)v30);
          goto LABEL_44;
        }
      }
      else
      {
        if (v27 < 0x17u
          || v27 == 23 && (HIBYTE(v29) < 3u || HIBYTE(v29) == 3 && v29 <= 2u))
        {
          uint64_t v7 = *(void *)(a1 + 32);
          uint64_t v8 = "VOP level compatibility check current engine '%s' against main '%s': passed";
LABEL_50:
          log_OutText(v7, (uint64_t)"TTSEG", 4, 0, (uint64_t)v8, v4, v5, v6, (uint64_t)v30);
          goto LABEL_51;
        }
        uint64_t v2 = 2166366233;
      }
      log_OutText(*(void *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"VOP level compatibility check current engine '%s' against main '%s': did not pass", v4, v5, v6, (uint64_t)v30);
    }
    else
    {
      uint64_t v2 = 0;
    }
  }
  if ((paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"engine_support_point_releases", &v25) & 0x80000000) == 0)
  {
    uint64_t v15 = v25;
    if (v25)
    {
      if (*v25)
      {
        uint64_t v2 = 2166366233;
        __int16 v29 = 0;
        unsigned __int8 v28 = 0;
        uint64_t v27 = 0;
        while (1)
        {
          uint64_t v16 = versionGetMajorMinorMaintAndSearchNext(v15, (unsigned char *)&v29 + 1, &v29, &v28, &v27);
          if ((v16 & 0x80000000) != 0)
          {
            uint64_t v2 = v16;
            goto LABEL_40;
          }
          BOOL v17 = HIBYTE(v29) == 23 && v29 == 3;
          BOOL v18 = !v17 || v28 > 2u;
          BOOL v19 = v18;
          uint64_t v15 = v27;
          if (!v19 || v27 == 0) {
            break;
          }
          if (!*v27) {
            goto LABEL_40;
          }
        }
        if (!v19)
        {
          uint64_t v7 = *(void *)(a1 + 32);
          uint64_t v8 = "VOP level compatibility check current engine '%s' against point releases '%s': passed";
          goto LABEL_50;
        }
LABEL_40:
        uint64_t v9 = *(void *)(a1 + 32);
        if ((v2 & 0x1FFF) == 0x19) {
          uint64_t v10 = "VOP level compatibility check current engine '%s' against point releases '%s': did not pass";
        }
        else {
          uint64_t v10 = "VOP level compatibility check current engine '%s' against point releases '%s': failed (format error)";
        }
        goto LABEL_43;
      }
    }
  }
  if ((v2 & 0x80000000) != 0)
  {
LABEL_44:
    if ((v2 & 0x1FFF) == 7)
    {
      uint64_t v21 = *(void *)(a1 + 32);
      uint64_t v22 = 82001;
    }
    else
    {
      if ((v2 & 0x1FFF) != 0x19) {
        return v2;
      }
      uint64_t v21 = *(void *)(a1 + 32);
      uint64_t v22 = 82000;
    }
    log_OutPublic(v21, (uint64_t)"TTSEG", v22, 0, v11, v12, v13, v14, v24);
    return v2;
  }
LABEL_51:
  if ((!v26 || !*v26) && (!v25 || !*v25)) {
    log_OutText(*(void *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"VOP level compatibility check against current engine : not enabled", v12, v13, v14, v24);
  }
  return 0;
}

uint64_t hlp_insert_after(uint64_t a1, uint64_t a2, const char *a3, char *a4, uint64_t (*a5)(const char *))
{
  uint64_t v16 = 0;
  BOOL v17 = a4;
  uint64_t result = vector_GetSize(a2);
  if (result)
  {
    unsigned int v10 = result;
    unsigned int v11 = 1;
    while (1)
    {
      if (!vector_GetElemAt(a2, v11 - 1, &v16)) {
        goto LABEL_13;
      }
      if (!strcmp(*v16, a3)) {
        break;
      }
      if (v11++ >= v10) {
        return 0;
      }
    }
    if (!vector_GetElemAt(a2, v11, &v16))
    {
LABEL_13:
      log_OutText(*(void *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Unable to insert component '%s'", v12, v13, v14, *v17);
      return 2166366212;
    }
    if (!a5 || (uint64_t result = a5(*v16), result))
    {
      vector_AddElemAt(a2, v11, &v17);
      return 0;
    }
  }
  return result;
}

uint64_t hlp_append(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = "CLMOBJECT|clmobjectinterface";
  if (vector_Add(a2, &v7)) {
    return 0;
  }
  log_OutText(*(void *)(a1 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Unable to append '%s'", v3, v4, v5, *v7);
  return 2166366212;
}

uint64_t pipeline_LoadObject(_WORD *a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v48 = 0;
  uint64_t v49 = a3;
  uint64_t NullHandle = safeh_GetNullHandle();
  uint64_t v47 = v12;
  uint64_t v45 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v48);
  if ((inited & 0x80000000) == 0)
  {
    if ((objc_GetObject(v48[6], a3, &v45) & 0x80000000) != 0)
    {
      uint64_t v44 = 0;
      long long v42 = 0u;
      long long v43 = 0u;
      if (LH_stricmp(a4, "phonmap")) {
        char v23 = 1;
      }
      else {
        char v23 = 2;
      }
      LOBYTE(v42) = v23;
      uint64_t v24 = brk_InterfaceQuery(v48[3]);
      if ((v24 & 0x80000000) != 0) {
        return v24;
      }
      log_OutText(v48[4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"Open component: %s", v25, v26, v27, (uint64_t)a4);
      uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t, _WORD *, uint64_t, long long *))(*((void *)&v42 + 1) + 32))(NullHandle, v47, a1, a2, &v43);
      if ((v28 & 0x80000000) != 0)
      {
        uint64_t inited = v28;
        log_OutPublic(v48[4], (uint64_t)"TTSEG", 16001, "%s%s%s%x", v29, v30, v31, v32, "component");
        brk_InterfaceRelease(v48[3], *((uint64_t *)&v42 + 1));
        return inited;
      }
      uint64_t inited = objc_RegisterObject(v48[6], a3, &v42);
      if ((inited & 0x80000000) != 0)
      {
        log_OutPublic(v48[4], (uint64_t)"TTSEG", 16001, "%s%s%s%x", v33, v34, v35, v36, "component");
      }
      else
      {
        if (!a5 || vector_Add(a5, &v49)) {
          return inited;
        }
        log_OutPublic(v48[4], (uint64_t)"TTSEG", 16000, 0, v37, v38, v39, v40, v41);
        uint64_t inited = 2166366218;
      }
      (*(void (**)(void, void))(*((void *)&v42 + 1) + 40))(v43, *((void *)&v43 + 1));
      brk_InterfaceRelease(v48[3], *((uint64_t *)&v42 + 1));
      return inited;
    }
    uint64_t v17 = v45[1];
    if (*(void *)(v17 + 48))
    {
      log_OutText(v48[4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"Reopen object: %s", v14, v15, v16, a3);
      if (a6) {
        *a6 = 1;
      }
      uint64_t inited = (*(uint64_t (**)(void, void))(v17 + 48))(v45[2], v45[3]);
      if ((inited & 0x80000000) != 0) {
        log_OutPublic(v48[4], (uint64_t)"TTSEG", 16001, "%s%s%s%x", v18, v19, v20, v21, "component");
      }
    }
    objc_ReleaseObject(v48[6], a3);
  }
  return inited;
}

uint64_t pipeline_disclose_location_of_fe_clm_component(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = *(unsigned __int16 *)(a2 + 24);
  if (*(_WORD *)(a2 + 24))
  {
    uint64_t v4 = 0;
    int v5 = 0xFFFF;
    uint64_t v6 = *(void *)(a2 + 16);
    unsigned int v7 = 0xFFFF;
    unsigned int v8 = 0xFFFF;
    do
    {
      uint64_t v9 = *(void *)(v6 + 8 * v4);
      if (v9)
      {
        unsigned int v10 = *(const char **)(v9 + 8);
        if (!strcmp(v10, "fe/fe_clm"))
        {
          unsigned int v8 = (unsigned __int16)v4;
        }
        else if (!strcmp(v10, "fe/fe_global"))
        {
          unsigned int v7 = (unsigned __int16)v4;
        }
        else if (!strcmp(v10, "sink") || !strcmp(v10, "feeder"))
        {
          int v5 = (unsigned __int16)v4;
        }
      }
      ++v4;
    }
    while (v3 != v4);
    uint64_t v2 = a1;
    if (v5 != 0xFFFF) {
      return 0;
    }
  }
  else
  {
    unsigned int v7 = 0xFFFF;
    unsigned int v8 = 0xFFFF;
  }
  uint64_t result = paramc_ParamSetUInt(*(void *)(v2 + 40), (uint64_t)"fe_clm_component", 0);
  if ((result & 0x80000000) == 0 && v8 != 0xFFFF && v7 != 0xFFFF)
  {
    uint64_t v12 = *(void *)(v2 + 40);
    if (v7 >= v8) {
      unsigned int v13 = 1;
    }
    else {
      unsigned int v13 = 2;
    }
    return paramc_ParamSetUInt(v12, (uint64_t)"fe_clm_component", v13);
  }
  return result;
}

uint64_t pipeline_disclose_processing_tnplus(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned __int16 *)(a2 + 24);
  if (!*(_WORD *)(a2 + 24))
  {
    uint64_t v10 = *(void *)(a1 + 40);
LABEL_14:
    unsigned int v11 = "no";
    goto LABEL_15;
  }
  uint64_t v4 = 0;
  int v5 = 0;
  uint64_t v6 = *(void *)(a2 + 16);
  int v7 = 0xFFFF;
  do
  {
    uint64_t v8 = *(void *)(v6 + 8 * v4);
    if (v8)
    {
      uint64_t v9 = *(const char **)(v8 + 8);
      if (!strcmp(v9, "fe/geene_adapt"))
      {
        int v5 = 1;
      }
      else if (!strcmp(v9, "sink") || !strcmp(v9, "feeder"))
      {
        int v7 = (unsigned __int16)v4;
      }
    }
    ++v4;
  }
  while (v3 != v4);
  if (v7 != 0xFFFF) {
    return 0;
  }
  uint64_t v10 = *(void *)(a1 + 40);
  if (!v5) {
    goto LABEL_14;
  }
  unsigned int v11 = "yes";
LABEL_15:
  return paramc_ParamSetStr(v10, (uint64_t)"processingtnplus", v11);
}

uint64_t pipeline_ResourceLoad(uint64_t *a1, int a2, const char *a3, char *a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v35 = 0;
  uint64_t v14 = 2166366215;
  *(void *)&long long v34 = safeh_GetNullHandle();
  *((void *)&v34 + 1) = v15;
  if (a1 && a3)
  {
    if (!a4) {
      a4 = &byte_20D5A22AE;
    }
    uint64_t v16 = *a1;
    if (a7)
    {
      *a7 = safeh_GetNullHandle();
      a7[1] = v17;
    }
    uint64_t ResourceOwner = pipeline_FindResourceOwner((uint64_t)a1, a3, (uint64_t *)&v35);
    if ((ResourceOwner & 0x80000000) != 0)
    {
      uint64_t v30 = ResourceOwner;
      log_OutPublic(*(void *)(v16 + 32), (uint64_t)"TTSEG", 16077, "%s%s%s%s", v19, v20, v21, v22, "uri");
      return v30;
    }
    else
    {
      char v23 = *(uint64_t (**)(void, void, const char *, char *, uint64_t, uint64_t, long long *))(v35[2] + 64);
      if (v23)
      {
        uint64_t v24 = v23(v35[3], v35[4], a3, a4, a5, a6, &v34);
        uint64_t v29 = v24;
        if ((v24 & 0x80000000) == 0)
        {
          if (a7) {
            *(_OWORD *)a7 = v34;
          }
          return v29;
        }
        if (!a2 || ((uint64_t v14 = 0, v31 = v24 & 0x1FFF, v31 != 19) ? (v32 = v31 == 24) : (v32 = 1), !v32 && v31 != 1036))
        {
          log_OutPublic(*(void *)(v16 + 32), (uint64_t)"TTSEG", 16038, "%s%s%s%s%s%s%s%x", v25, v26, v27, v28, "component");
          return v29;
        }
      }
      else
      {
        log_OutPublic(*(void *)(v16 + 32), (uint64_t)"TTSEG", 16039, "%s%s%s%s%s%s", v19, v20, v21, v22, "component");
      }
    }
  }
  return v14;
}

uint64_t pipeline_ObjClose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 2166366214;
  }
  uint64_t v9 = *(void *)a1;
  if (*(void *)(a1 + 16))
  {
    uint64_t v10 = *(void *)(a1 + 32);
    if (v10)
    {
      compstats_Reset(v10);
      compstats_Start(*(void *)(a1 + 32), *(void *)(a1 + 40), 0, v11, v12, v13, v14, v15);
    }
    __int16 v16 = *(_WORD *)(a1 + 24);
    if (v16)
    {
      uint64_t v17 = 0;
      uint64_t v18 = (unsigned __int16)(v16 - 1) + 2;
      unsigned __int16 v19 = v16 - 1;
      do
      {
        uint64_t v20 = v19;
        uint64_t v21 = *(unsigned __int16 **)(*(void *)(a1 + 16) + 8 * v19);
        if (v21)
        {
          int v22 = *v21;
          BOOL v23 = v22 != 0;
          int v24 = v22 - 1;
          if (v24 != 0 && v23)
          {
            *uint64_t v21 = v24;
          }
          else
          {
            uint64_t NullHandle = safeh_GetNullHandle();
            if (!safeh_HandlesEqual(*((void *)v21 + 3), *((void *)v21 + 4), NullHandle, v26))
            {
              log_OutText(*(void *)(v9 + 32), (uint64_t)"TTSEG", 4, 0, (uint64_t)"Close component: %s", v27, v28, v29, *(void *)(*(void *)(*(void *)(a1 + 16) + 8 * v19) + 8));
              uint64_t v35 = *(void *)(a1 + 32);
              if (v35) {
                compstats_Start(v35, *(void *)(a1 + 40), v18, v30, v31, v32, v33, v34);
              }
              uint64_t v36 = *(void **)(*(void *)(a1 + 16) + 8 * v19);
              unsigned int v42 = (*(uint64_t (**)(void, void))(v36[2] + 40))(v36[3], v36[4]);
              uint64_t v43 = *(void *)(a1 + 32);
              if (v43) {
                compstats_Stop(v43, *(void *)(a1 + 40), v18, v37, v38, v39, v40, v41);
              }
              if ((v42 & 0x80000000) != 0)
              {
                log_OutPublic(*(void *)(v9 + 32), (uint64_t)"TTSEG", 16002, "%s%s%s%x", v38, v39, v40, v41, "component");
                if ((int)v17 >= 0) {
                  uint64_t v17 = v42;
                }
                else {
                  uint64_t v17 = v17;
                }
              }
            }
            uint64_t v44 = *(void *)(*(void *)(a1 + 16) + 8 * v19);
            uint64_t v45 = *(void *)(v44 + 16);
            if (v45)
            {
              int v46 = brk_InterfaceRelease(*(void *)(v9 + 24), v45);
              if (v46 >= 0 || (int)v17 <= -1) {
                uint64_t v17 = v17;
              }
              else {
                uint64_t v17 = v46;
              }
              uint64_t v44 = *(void *)(*(void *)(a1 + 16) + 8 * v19);
            }
            heap_Free(*(void **)(v9 + 8), *(void *)(v44 + 8));
            heap_Free(*(void **)(v9 + 8), *(void *)(*(void *)(a1 + 16) + 8 * v19));
          }
        }
        uint64_t v18 = (v18 - 1);
        --v19;
      }
      while (v20);
    }
    else
    {
      uint64_t v17 = 0;
    }
    uint64_t v48 = *(void *)(a1 + 32);
    if (v48)
    {
      compstats_Stop(v48, *(void *)(a1 + 40), 0, a4, a5, a6, a7, a8);
      compstats_Log(*(void *)(a1 + 32), *(void *)(a1 + 40), *(void *)(v9 + 32), "Pipeline Close", *(void *)(a1 + 48), 0, 0);
    }
    heap_Free(*(void **)(v9 + 8), *(void *)(a1 + 16));
  }
  else
  {
    uint64_t v17 = 0;
  }
  uint64_t v49 = *(void *)(a1 + 32);
  if (v49) {
    compstats_ObjClose(v49, *(void *)(a1 + 40));
  }
  if (*(void *)(a1 + 48))
  {
    unsigned __int16 v50 = 0;
    do
    {
      uint64_t v51 = *(void *)(*(void *)(a1 + 48) + 8 * v50);
      if (v51) {
        heap_Free(*(void **)(v9 + 8), v51);
      }
      ++v50;
    }
    while (*(unsigned __int16 *)(a1 + 24) + 3 > v50);
    heap_Free(*(void **)(v9 + 8), *(void *)(a1 + 48));
  }
  uint64_t v52 = *(void *)(a1 + 8);
  if (v52) {
    heap_Free(*(void **)(v9 + 8), v52);
  }
  heap_Free(*(void **)(v9 + 8), a1);
  return v17;
}

uint64_t pipeline_ObjReopen(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void **)a1;
  uint64_t v10 = *(char **)(a1 + 8);
  __s2 = 0;
  uint64_t v30 = 0;
  uint64_t v28 = 0;
  log_OutText(v9[4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"pipeline_ObjReopen : Begin %s", a6, a7, a8, (uint64_t)v10);
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"pipeline", v10);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"mlset", &byte_20D5A22AE);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"voiceml", &byte_20D5A22AE);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"noclmset", &byte_20D5A22AE);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"shortfragmentforceclm", &byte_20D5A22AE);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"shortfragmentforceclm_value_pipeline", &byte_20D5A22AE);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"extclccfg", &byte_20D5A22AE);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"lidlanguages", &byte_20D5A22AE);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"extraesclang", &byte_20D5A22AE);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"extraesctn", &byte_20D5A22AE);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"typeofsynthesis", &byte_20D5A22AE);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"uselearlyemission", &byte_20D5A22AE);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"pmksync", &byte_20D5A22AE);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"feextcfgdataprefix", &byte_20D5A22AE);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"engine_support_base_release", &byte_20D5A22AE);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"engine_support_point_releases", &byte_20D5A22AE);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"fedatapackaging", &byte_20D5A22AE);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"datapackagename", &byte_20D5A22AE);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  paramc_ParamRemove(v9[5], (uint64_t)"voiceoperatingpoint");
  paramc_ParamRemove(v9[5], (uint64_t)"uselectrawdataversion");
  paramc_ParamRemove(v9[5], (uint64_t)"uselectreductionversion");
  paramc_ParamRemove(v9[5], (uint64_t)"nnpausingthresholdpercent");
  uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"bet4nodeprunemax", 0);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"bet4beamwidth", 0);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"bet4nodelimit", 0);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"bet4nodeprunemaxunvoiced", 0);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"timbre_baseline", 0x64u);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"pitch_baseline", 0x64u);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"rate_baseline", 0x64u);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"volume_baseline", 0x50u);
  if ((v14 & 0x1FFF) == 0xA) {
    goto LABEL_85;
  }
  paramc_ParamRemove(v9[5], (uint64_t)"basicclcprosody");
  paramc_ParamRemove(v9[5], (uint64_t)"punctmarks");
  paramc_ParamRemove(v9[5], (uint64_t)"addondct_extended_lookup");
  paramc_ParamRemove(v9[5], (uint64_t)"nnpausingoverride");
  if ((brk_TagIteratorOpen(v9[3], v10, "PARAMETERS/*", 1, &v30) & 0x80000000) != 0) {
    goto LABEL_74;
  }
  if ((brk_TagIteratorNext(v30, (uint64_t)&__s2, (uint64_t)&v28) & 0x80000000) == 0)
  {
    int v15 = 0;
    while (1)
    {
      __int16 v16 = __s2;
      if (!__s2 || !*__s2) {
        goto LABEL_65;
      }
      if (!strcmp("waitfactor", __s2))
      {
        LODWORD(v27) = 1;
        if ((paramc_ParamGetUInt(v9[5], (uint64_t)"waitfactor", (unsigned int *)&v27) & 0x80000000) == 0) {
          uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"waitfactorpipelinebackup", v27);
        }
        if ((v14 & 0x1FFF) == 0xA) {
          goto LABEL_85;
        }
        __int16 v16 = __s2;
        if (!__s2)
        {
          int v15 = 1;
          goto LABEL_65;
        }
        int v15 = 1;
        if (!*__s2) {
          goto LABEL_65;
        }
      }
      if (strncmp("audiooutput", v16, 0xBuLL))
      {
        if (!strcmp("extraesclang", v16) || !strcmp("extraesctn", v16))
        {
          uint64_t v27 = 0;
          if ((paramc_ParamGetStr(v9[5], (uint64_t)"clcpreventhlpactivate", &v27) & 0x80000000) == 0)
          {
            uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"clcpreventhlpactivate", "yes");
            if ((v14 & 0x1FFF) == 0xA) {
              goto LABEL_85;
            }
          }
          __int16 v16 = __s2;
          if (!__s2) {
            goto LABEL_41;
          }
        }
        if (*v16 && !strcmp("waitfactor", v16))
        {
          LODWORD(v27) = 0;
          if ((paramc_ParamGetUInt(v9[5], (uint64_t)"waitfactorsetbyapi", (unsigned int *)&v27) & 0x80000000) != 0
            || v27 != 1)
          {
            if (v28) {
              uint64_t v20 = v28;
            }
            else {
              uint64_t v20 = &byte_20D5A22AE;
            }
            uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)__s2, v20);
          }
          int v19 = v14 & 0x1FFF;
        }
        else
        {
LABEL_41:
          if (v28) {
            uint64_t v17 = v28;
          }
          else {
            uint64_t v17 = &byte_20D5A22AE;
          }
          uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)v16, v17);
          if ((v14 & 0x1FFF) == 0xA) {
            goto LABEL_85;
          }
          if (strcmp("shortfragmentforceclm", __s2)) {
            goto LABEL_65;
          }
          if (v28) {
            uint64_t v18 = v28;
          }
          else {
            uint64_t v18 = &byte_20D5A22AE;
          }
          uint64_t v14 = paramc_ParamSetStr(v9[5], (uint64_t)"shortfragmentforceclm_value_pipeline", v18);
          int v19 = v14 & 0x1FFF;
        }
        if (v19 == 10) {
          goto LABEL_85;
        }
      }
LABEL_65:
      if ((brk_TagIteratorNext(v30, (uint64_t)&__s2, (uint64_t)&v28) & 0x80000000) != 0)
      {
        uint64_t v21 = vopCheckEngineCompatibility((uint64_t)v9);
        if ((v21 & 0x80000000) == 0)
        {
          if (!v15) {
            goto LABEL_70;
          }
LABEL_73:
          brk_TagIteratorClose(v30);
          uint64_t v30 = 0;
LABEL_74:
          uint64_t v21 = hlp_pipeline_objects_reopen(v9, v10);
          if ((v21 & 0x80000000) == 0)
          {
            uint64_t v21 = pipeline_disclose_location_of_fe_clm_component((uint64_t)v9, a1);
            if ((v21 & 0x80000000) == 0)
            {
              uint64_t v14 = pipeline_disclose_processing_tnplus((uint64_t)v9, a1);
              if ((v14 & 0x80000000) == 0)
              {
                unsigned int v22 = *(unsigned __int16 *)(a1 + 24);
                if (*(_WORD *)(a1 + 24))
                {
                  uint64_t v23 = 0;
                  while (1)
                  {
                    int v24 = *(uint64_t **)(*(void *)(a1 + 16) + 8 * v23);
                    if (*(void *)(v24[2] + 48))
                    {
                      log_OutText(v9[4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"Reopen component: %s", v11, v12, v13, v24[1]);
                      uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(v24[2] + 48))(v24[3], v24[4]);
                      if ((v14 & 0x80000000) != 0)
                      {
                        log_OutPublic(v9[4], (uint64_t)"TTSEG", 16001, "%s%s%s%x", v25, v11, v12, v13, "component");
                        goto LABEL_85;
                      }
                      unsigned int v22 = *(unsigned __int16 *)(a1 + 24);
                    }
                    if (++v23 >= (unint64_t)v22) {
                      goto LABEL_85;
                    }
                  }
                }
              }
              goto LABEL_85;
            }
          }
        }
LABEL_84:
        uint64_t v14 = v21;
        goto LABEL_85;
      }
    }
  }
  uint64_t v21 = vopCheckEngineCompatibility((uint64_t)v9);
  if ((v21 & 0x80000000) != 0) {
    goto LABEL_84;
  }
LABEL_70:
  LODWORD(v27) = 1;
  if ((paramc_ParamGetUInt(v9[5], (uint64_t)"waitfactorpipelinebackup", (unsigned int *)&v27) & 0x80000000) != 0) {
    goto LABEL_73;
  }
  uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"waitfactor", v27);
  if ((v14 & 0x1FFF) != 0xA)
  {
    uint64_t v14 = paramc_ParamSetUInt(v9[5], (uint64_t)"waitfactorpipelinebackup", v27);
    if ((v14 & 0x1FFF) != 0xA) {
      goto LABEL_73;
    }
  }
LABEL_85:
  log_OutText(v9[4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"pipeline_ObjReopen : End (%x)", v11, v12, v13, v14);
  return v14;
}

uint64_t hlp_pipeline_objects_reopen(void *a1, unsigned char *a2)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  int v25 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v4 = pipeline_create_name_vector_for_query(a1, a2, "COMPONENTS/*", &v22);
  uint64_t v5 = v22;
  if ((v4 & 0x80000000) != 0
    || (pipeline_loc_DetermineEngine((uint64_t)a1, v22, &v25),
        uint64_t v4 = pipeline_create_name_vector_for_query(a1, a2, "OBJECTS/*", &v23),
        (v4 & 0x80000000) != 0)
    || (uint64_t v6 = v23, !v25)
    && (uint64_t v4 = hlp_insert_after((uint64_t)a1, v23, "FE_DCTLKP|fe/fe_dctlkp", "FE_NN|fe/fe_nn", 0), (v4 & 0x80000000) != 0)
    || (uint64_t v4 = hlp_insert_after((uint64_t)a1, v6, "INET|inetspi", "CHARCOUNT|charcount", 0), (v4 & 0x80000000) != 0)
    || (uint64_t v4 = hlp_append((uint64_t)a1, v6), (v4 & 0x80000000) != 0))
  {
    uint64_t v9 = v4;
    goto LABEL_22;
  }
  if (!vector_GetSize(v6))
  {
    uint64_t v9 = 0;
    goto LABEL_22;
  }
  unsigned int v7 = 0;
  int v8 = 0;
  uint64_t v9 = 0;
  while (1)
  {
    if (!vector_GetElemAt(v6, v7, &v24))
    {
LABEL_28:
      uint64_t v9 = 2166366208;
      goto LABEL_22;
    }
    __strcpy_chk();
    if (*(void *)__s != 0x656E697C54454E49 || *(void *)&__s[5] != 0x69707374656E69)
    {
      uint64_t v11 = strchr(__s, 124);
      if (!v11) {
        goto LABEL_28;
      }
      *uint64_t v11 = 0;
      if ((objc_GetObject(a1[6], (uint64_t)__s, &v21) & 0x80000000) == 0) {
        break;
      }
    }
LABEL_19:
    unsigned int v7 = (unsigned __int16)++v8;
    if (vector_GetSize(v6) <= (unsigned __int16)v8) {
      goto LABEL_22;
    }
  }
  uint64_t v15 = v21[1];
  if (!*(void *)(v15 + 48)
    || (log_OutText(a1[4], (uint64_t)"TTSEG", 4, 0, (uint64_t)"Reopen object: %s", v12, v13, v14, (uint64_t)__s),
        uint64_t v9 = (*(uint64_t (**)(void, void))(v15 + 48))(v21[2], v21[3]),
        (v9 & 0x80000000) == 0))
  {
    objc_ReleaseObject(a1[6], (uint64_t)__s);
    goto LABEL_19;
  }
  log_OutPublic(a1[4], (uint64_t)"TTSEG", 16001, "%s%s%s%x", v16, v17, v18, v19, "component");
  objc_ReleaseObject(a1[6], (uint64_t)__s);
LABEL_22:
  if (v5) {
    vector_ObjClose(v5);
  }
  if (v23) {
    vector_ObjClose(v23);
  }
  return v9;
}

uint64_t pipeline_FindResourceOwner(uint64_t a1, const char *a2, uint64_t *a3)
{
  uint64_t v3 = 2166366215;
  if (a1 && a2 && *a2)
  {
    unint64_t v7 = 0;
    *a3 = 0;
    while (v7 < *(unsigned __int16 *)(a1 + 24))
    {
      uint64_t v20 = 0;
      int v8 = *(void **)(*(void *)(a1 + 16) + 8 * v7);
      uint64_t v9 = *(uint64_t (**)(void, void, uint64_t *))(v8[2] + 56);
      if (v9)
      {
        int v10 = v9(v8[3], v8[4], &v20);
        uint64_t v11 = *a3;
        if ((v10 & 0x80000000) == 0)
        {
          uint64_t v12 = v20;
          if (v20)
          {
            if (v11) {
              return 0;
            }
            unsigned __int16 v13 = 0;
            do
            {
              uint64_t v14 = *(const char **)(v12 + 8 * v13);
              if (!v14) {
                break;
              }
              size_t v15 = strlen(*(const char **)(v12 + 8 * v13));
              if (!strncmp(a2, v14, v15)
                && ((int v17 = a2[v15], v17 != 59) ? (v18 = v17 == 0) : (v18 = 1), v18))
              {
                uint64_t v11 = *(void *)(*(void *)(a1 + 16) + 8 * v7);
                *a3 = v11;
                uint64_t v16 = v11;
              }
              else
              {
                uint64_t v16 = 0;
              }
              ++v13;
            }
            while (!v16);
          }
        }
      }
      else
      {
        uint64_t v11 = 0;
      }
      ++v7;
      if (v11) {
        return 0;
      }
    }
    return 2166366228;
  }
  return v3;
}

uint64_t pipeline_ResourceUnload(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 2166366215;
  if (a1)
  {
    unint64_t v12 = 0;
    uint64_t v13 = *a1;
    uint64_t v8 = 2166366216;
    do
    {
      if (v12 >= *((unsigned __int16 *)a1 + 12)) {
        break;
      }
      uint64_t v14 = *(void **)(a1[2] + 8 * v12);
      size_t v15 = *(uint64_t (**)(void, void, uint64_t, uint64_t))(v14[2] + 72);
      if (v15)
      {
        uint64_t v8 = v15(v14[3], v14[4], a2, a3);
        if ((v8 & 0x80000000) == 0) {
          return v8;
        }
      }
      ++v12;
    }
    while ((v8 & 0x1FFF) == 8);
    if ((v8 & 0x80000000) != 0) {
      log_OutPublic(*(void *)(v13 + 32), (uint64_t)"TTSEG", 16041, "%s%p%s%x", a5, a6, a7, a8, "handle");
    }
  }
  return v8;
}

uint64_t pipeline_UnloadObjects(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v19 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v21);
  if ((inited & 0x80000000) == 0)
  {
    for (int i = 1; i != 3; ++i)
    {
      int Size = vector_GetSize(a3);
      if (Size)
      {
        unsigned int v7 = Size - 1;
        do
        {
          if (!vector_GetElemAt(a3, v7, &v20)) {
            break;
          }
          if ((objc_GetObject(v21[6], *v20, &v19) & 0x80000000) == 0)
          {
            objc_ReleaseObject(v21[6], *v20);
            if (i == 1)
            {
              int v8 = (*(uint64_t (**)(uint64_t, uint64_t))(v19[1] + 40))(v19[2], v19[3]);
              if (v8 < 0)
              {
                int v13 = v8;
                log_OutPublic(v21[4], (uint64_t)"TTSEG", 16100, "%s%x%s%s", v9, v10, v11, v12, "lherror");
              }
              else
              {
                int v13 = brk_InterfaceRelease(v21[3], v19[1]);
              }
            }
            else
            {
              int v13 = objc_UnregisterObject(v21[6], *v20);
              if (v13 < 0) {
                log_OutPublic(v21[4], (uint64_t)"TTSEG", 16101, "%s%x%s%s", v14, v15, v16, v17, "lherror");
              }
            }
            if (v13 >= 0) {
              uint64_t inited = inited;
            }
            else {
              uint64_t inited = v13;
            }
          }
          --v7;
        }
        while (v7 != -1);
      }
    }
  }
  return inited;
}

uint64_t pipeline_fill_CopyPartsString(const char **a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = *a1;
  if (*a1) {
    uint64_t v6 = strlen(*a1) + 1;
  }
  else {
    uint64_t v6 = 1;
  }
  uint64_t result = heap_Alloc(a2, v6);
  *a3 = result;
  if (result)
  {
    if (v5) {
      int v8 = v5;
    }
    else {
      int v8 = &byte_20D5A22AE;
    }
    strcpy((char *)result, v8);
    return 1;
  }
  return result;
}

uint64_t *pipeline_fill_ElemFreePartsString(uint64_t *result, void *a2)
{
  if (*result) {
    return heap_Free(a2, *result);
  }
  return result;
}

uint64_t is_not_sink_or_voice_switch(const char *a1)
{
  uint64_t result = strcmp(a1, "sink");
  if (result) {
    return strcmp(a1, "voice_switch") != 0;
  }
  return result;
}

uint64_t is_not_sink_or_msp(const char *a1)
{
  uint64_t result = strcmp(a1, "sink");
  if (result) {
    return strcmp(a1, "fe/fe_msp") != 0;
  }
  return result;
}

BOOL is_not_dspeffects(const char *a1)
{
  return strcmp(a1, "dspeffects") != 0;
}

uint64_t versionGetMajorMinorMaintAndSearchNext(char *a1, unsigned char *a2, unsigned char *a3, unsigned char *a4, char **a5)
{
  int v8 = 0;
  __int16 v9 = 0;
  int v10 = 0;
  *a4 = 0;
  uint64_t result = 2166366215;
  *a3 = 0;
  *a2 = 0;
  for (int i = a1; ; ++i)
  {
    unsigned int v13 = *i;
    BOOL v14 = v13 > 0x2C || ((1 << v13) & 0x100100000001) == 0;
    if (!v14 || v8 < 0) {
      break;
    }
    if (v13 - 48 >= 0xA) {
      int v8 = -2128601081;
    }
    else {
      int v8 = 0;
    }
    if (v13 - 48 >= 0xA) {
      int v15 = v10;
    }
    else {
      int v15 = v10 + 1;
    }
    if ((unsigned __int16)(v9 + 1) <= 2u) {
      int v16 = 0;
    }
    else {
      int v16 = -2128601081;
    }
    if (v13 == 46)
    {
      int v8 = v16;
      ++v9;
    }
    else
    {
      int v10 = v15;
    }
  }
  BOOL v17 = v9 == 2 && (unsigned __int16)v10 >= 3u;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0));
  if (!v17) {
    unsigned int v20 = -2128601081;
  }
  else {
    unsigned int v20 = 0;
  }
  if (v8 >= 0) {
    uint64_t v21 = v20;
  }
  else {
    uint64_t v21 = v8;
  }
  _WriteStatusReg(ARM64_SYSREG(3, 3, 4, 2, 0), StatusReg);
  if (v8 < 0) {
    return v21;
  }
  while (v13 == 44 || v13 == 32)
  {
    unsigned int v22 = *++i;
    unsigned int v13 = v22;
  }
  if (a5)
  {
    *a5 = i;
    goto LABEL_39;
  }
  if (!*i)
  {
LABEL_39:
    *a2 = atoi(a1);
    uint64_t v23 = strchr(a1, 46);
    if (v23)
    {
      uint64_t v24 = v23 + 1;
      *a3 = atoi(v23 + 1);
      int v25 = strchr(v24, 46);
      if (v25) {
        *a4 = atoi(v25 + 1);
      }
    }
    return v21;
  }
  return result;
}

uint64_t voice_switch_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2600476673;
  }
  uint64_t result = 0;
  *a2 = &IVScmp;
  return result;
}

uint64_t vscmp_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v5 = 2600476679;
  int v43 = 0;
  if (a5)
  {
    uint64_t inited = InitRsrcFunction(a3, a4, &v45);
    if ((inited & 0x80000000) != 0)
    {
      return inited;
    }
    else
    {
      *(void *)a5 = 0;
      *(_DWORD *)(a5 + 8) = 0;
      log_OutText(*(void *)(v45 + 32), (uint64_t)"VOICESWITCHCMP", 4, 0, (uint64_t)"Entering vscmp_ObjOpen", v10, v11, v12, v41);
      unsigned int v13 = (void *)heap_Calloc(*(void **)(v45 + 8), 1, 928);
      uint64_t v18 = v45;
      if (v13)
      {
        uint64_t v19 = v13;
        v13[1] = a4;
        v13[2] = v18;
        *unsigned int v13 = a3;
        uint64_t Object = objc_GetObject(*(void *)(v45 + 48), (uint64_t)"SYNTHSTREAM", &v44);
        if ((Object & 0x80000000) != 0)
        {
          uint64_t v26 = Object;
          log_OutPublic(*(void *)(v45 + 32), (uint64_t)"VOICESWITCHCMP", 6002, 0, v21, v22, v23, v24, v42);
        }
        else
        {
          v19[8] = *(void *)(v44 + 8);
          if ((objc_GetObject(*(void *)(v45 + 48), (uint64_t)"COMPQUERY", &v44) & 0x80000000) != 0)
          {
            v19[7] = 0;
            v19[5] = safeh_GetNullHandle();
            v19[6] = v31;
          }
          else
          {
            uint64_t v25 = v44;
            v19[7] = *(void *)(v44 + 8);
            *(_OWORD *)(v19 + 5) = *(_OWORD *)(v25 + 16);
          }
          int UInt = paramc_ParamGetUInt(*(void *)(v45 + 40), (uint64_t)"ppmaxpcreframeblocks", (unsigned int *)&v43);
          unsigned __int16 v33 = v43;
          int v34 = paramc_ParamGetUInt(*(void *)(v45 + 40), (uint64_t)"ppnumframesinblock", (unsigned int *)&v43);
          __int16 v35 = v43;
          v19[3] = 0;
          *((_DWORD *)v19 + 8) = 0;
          uint64_t v36 = nuance_pcre_ObjOpen(a3, a4, (uint64_t)(v19 + 3));
          if ((v36 & 0x80000000) != 0)
          {
            uint64_t v26 = v36;
          }
          else
          {
            if (v34 < 0) {
              __int16 v37 = 50;
            }
            else {
              __int16 v37 = v35;
            }
            if (UInt < 0) {
              unsigned __int16 v38 = 50;
            }
            else {
              unsigned __int16 v38 = v33;
            }
            uint64_t v26 = nuance_pcre_Init((void *)v19[3], v19[4], v38, v37);
            if ((v26 & 0x80000000) == 0)
            {
              int v39 = 865;
LABEL_22:
              *(void *)a5 = v19;
              *(_DWORD *)(a5 + 8) = v39;
              log_OutText(*(void *)(v45 + 32), (uint64_t)"VOICESWITCHCMP", 4, 0, (uint64_t)"Leaving ngwcmp_ObjOpen: %x", v28, v29, v30, v26);
              return 0;
            }
          }
        }
        log_OutPublic(*(void *)(v45 + 32), (uint64_t)"VOICESWITCHCMP", 6001, "%s%x", v27, v28, v29, v30, "lhError");
        *(void *)a5 = v19;
        *(_DWORD *)(a5 + 8) = 865;
        vscmp_ObjClose(v19, *(void *)(a5 + 8));
        uint64_t v19 = 0;
        int v39 = 0;
        goto LABEL_22;
      }
      log_OutPublic(*(void *)(v45 + 32), (uint64_t)"VOICESWITCHCMP", 6000, 0, v14, v15, v16, v17, v42);
      return 2600476682;
    }
  }
  return v5;
}

uint64_t vscmp_ObjClose(void *a1, int a2)
{
  int v3 = safeh_HandleCheck((uint64_t)a1, a2, 865, 928);
  if (v3 < 0) {
    return 2600476680;
  }
  LODWORD(v7) = v3;
  uint64_t v8 = a1[2];
  log_OutText(*(void *)(v8 + 32), (uint64_t)"VOICESWITCHCMP", 4, 0, (uint64_t)"Entering vscmp_ObjClose", v4, v5, v6, v18);
  uint64_t NullHandle = safeh_GetNullHandle();
  if (!safeh_HandlesEqual(a1[3], a1[4], NullHandle, v10))
  {
    int v11 = nuance_pcre_DeInit((void *)a1[3], a1[4]);
    if ((v11 & 0x80000000) == 0) {
      int v11 = nuance_pcre_ObjClose(a1[3], a1[4]);
    }
    LODWORD(v7) = v11;
  }
  if (a1[7]) {
    objc_ReleaseObject(*(void *)(v8 + 48), (uint64_t)"COMPQUERY");
  }
  int v12 = objc_ReleaseObject(*(void *)(v8 + 48), (uint64_t)"SYNTHSTREAM");
  if (v12 >= 0 || (int)v7 <= -1) {
    uint64_t v7 = v7;
  }
  else {
    uint64_t v7 = v12;
  }
  heap_Free(*(void **)(v8 + 8), (uint64_t)a1);
  log_OutText(*(void *)(v8 + 32), (uint64_t)"VOICESWITCHCMP", 4, 0, (uint64_t)"Leaving vscmp_ObjClose: %x", v14, v15, v16, v7);
  return v7;
}

uint64_t vscmp_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if ((safeh_HandleCheck(a1, a2, 865, 928) & 0x80000000) != 0) {
    return 2600476680;
  }
  synstrmaux_InitStreamOpener(a1 + 72, *(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"VOICESWITCHCMP");
  synstrmaux_RegisterInStream((_WORD *)(a1 + 72), (uint64_t)"text/plain;charset=utf-8", 0, a1 + 896);
  synstrmaux_RegisterOutStream((_WORD *)(a1 + 72), (uint64_t)"text/plain;charset=utf-8", a1 + 912);
  uint64_t v8 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 72), *(void *)(a1 + 64), a3, a4);
  if ((v8 & 0x80000000) != 0) {
    vscmp_ProcessEnd(a1, a2);
  }
  return v8;
}

uint64_t vscmp_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  __s2[1] = *MEMORY[0x263EF8340];
  uint64_t v60 = 0;
  size_t __n = 0;
  uint64_t v7 = 2600476682;
  strcpy(__src, "\x1B");
  __s2[0] = 0x5C313D736F655CLL;
  unint64_t v57 = 0;
  __dst = 0;
  *a5 = 1;
  if ((safeh_HandleCheck(a1, a2, 865, 928) & 0x80000000) != 0) {
    return 2600476680;
  }
  if (!*(void *)(a1 + 896) || !*(void *)(a1 + 912))
  {
    uint64_t v7 = 0;
    *a5 = 1;
    return v7;
  }
  uint64_t v8 = *(uint64_t **)(a1 + 16);
  __int16 v9 = (char *)heap_Alloc(v8[1], 2);
  if (v9)
  {
    int v10 = v9;
    int v11 = strcpy(v9, __src);
    int v12 = strlen(v11);
    unsigned int v13 = (char *)heap_Alloc(v8[1], (v12 + 8));
    if (!v13)
    {
      heap_Free((void *)v8[1], (uint64_t)v10);
      return v7;
    }
    uint64_t v14 = (uint64_t)v13;
    uint64_t v15 = strcpy(v13, v10);
    strcat(v15, (const char *)__s2);
    uint64_t v16 = (*(uint64_t (**)(void, void, char *, size_t *))(*(void *)(a1 + 64) + 144))(*(void *)(a1 + 896), *(void *)(a1 + 904), (char *)&__n + 4, &__n);
    if ((v16 & 0x80000000) == 0)
    {
      if (HIDWORD(__n))
      {
        uint64_t v16 = (*(uint64_t (**)(void, void, char **, char *))(*(void *)(a1 + 64) + 88))(*(void *)(a1 + 896), *(void *)(a1 + 904), &v60, (char *)&__n + 4);
        if ((v16 & 0x80000000) == 0)
        {
          uint64_t v17 = (char *)heap_Calloc((void *)v8[1], 1, (HIDWORD(__n) + 1));
          uint64_t v18 = v17;
          if (!v17)
          {
            uint64_t v36 = 0;
            uint64_t v16 = 2600476682;
            goto LABEL_30;
          }
          strncpy(v17, v60, HIDWORD(__n));
          v18[HIDWORD(__n)] = 0;
          if (!HIDWORD(__n))
          {
            uint64_t v36 = 0;
            goto LABEL_73;
          }
          unsigned int v53 = HIDWORD(__n);
          int v56 = 0;
          uint64_t v55 = 0;
          uint64_t v16 = paramc_ParamGet(v8[5], (uint64_t)"fullescvoiceseqdata", &v55, &v56);
          if ((v16 & 0x80000000) == 0)
          {
            uint64_t v19 = *v55;
            *(void *)&long long v20 = -1;
            *((void *)&v20 + 1) = -1;
            long long v63 = v20;
            long long v64 = v20;
            long long v65 = v20;
            long long v66 = v20;
            long long v67 = v20;
            long long v68 = v20;
            long long v69 = v20;
            long long v70 = v20;
            long long v71 = v20;
            long long v72 = v20;
            long long v73 = v20;
            long long v74 = v20;
            long long v75 = v20;
            long long v76 = v20;
            long long v77 = v20;
            long long v78 = v20;
            long long v79 = v20;
            long long v80 = v20;
            long long v81 = v20;
            long long v82 = v20;
            long long v83 = v20;
            long long v84 = v20;
            long long v85 = v20;
            long long v86 = v20;
            long long v87 = v20;
            signed int v21 = nuance_pcre_exec(*(void **)(a1 + 24), *(void *)(a1 + 32), v19, 0, v18, SHIDWORD(__n), 0, 0xA000u, &v63, 100);
            signed int v22 = v21;
            uint64_t v23 = &v18[(int)v63];
            if (v21 < 0) {
              uint64_t v23 = 0;
            }
            if (v63) {
              BOOL v24 = 1;
            }
            else {
              BOOL v24 = v21 < 0;
            }
            if (v21 < 0)
            {
              signed int v25 = v21;
              uint64_t v26 = v23;
              BOOL v51 = v24;
              uint64_t v27 = nuance_pcre_ErrorToLhError(v21);
              BOOL v24 = v51;
              uint64_t v23 = v26;
              signed int v22 = v25;
              uint64_t v16 = v27;
              if (v27 >> 20 == 2213)
              {
                uint64_t v16 = 0;
                int v32 = v27 & 0x1FFF;
                if (v32 != 7778 && v32 != 20)
                {
                  if (v32 == 10)
                  {
                    uint64_t v33 = v8[4];
                    uint64_t v34 = 11002;
                    __int16 v35 = 0;
                  }
                  else
                  {
                    unsigned __int16 v50 = "lhError";
                    __int16 v35 = "%s%x";
                    uint64_t v33 = v8[4];
                    uint64_t v34 = 11027;
                  }
                  log_OutPublic(v33, (uint64_t)"VOICESWITCHCMP", v34, v35, v28, v29, v30, v31, v50);
                  uint64_t v16 = 0;
                  signed int v22 = v25;
                  uint64_t v23 = v26;
                  BOOL v24 = v51;
                }
              }
            }
            uint64_t v36 = 0;
            unsigned __int16 v38 = &v18[SDWORD2(v64)];
            if (v23)
            {
              int v39 = &v18[SHIDWORD(v64)];
            }
            else
            {
              unsigned __int16 v38 = 0;
              int v39 = 0;
            }
            if (!v23 || !v39 || !v38 || v39 == v38) {
              goto LABEL_63;
            }
            if (v24)
            {
              uint64_t v36 = 0;
              uint64_t v40 = (v23 - v18);
              HIDWORD(__n) = v23 - v18;
              goto LABEL_64;
            }
            uint64_t v41 = v38;
            signed int v52 = v22;
            int v54 = 0;
            HIDWORD(__n) = v39 - v18 + 1;
            unsigned int v42 = (char *)heap_Alloc(v8[1], HIDWORD(__n));
            uint64_t v36 = v42;
            if (v42)
            {
              int v43 = v41;
              size_t v44 = (v39 - v41);
              memcpy(v42, v43, v44);
              v36[v44] = 0;
              uint64_t v45 = vs_trim_voice(v36);
              if (!strcmp((const char *)v45, "(pop)") || !strcmp((const char *)v45, "(push)"))
              {
                __strcpy_chk();
                memset(v18, 32, HIDWORD(__n));
                goto LABEL_61;
              }
              uint64_t best_matching_voice = vs_find_best_matching_voice((void *)a1, (char *)v45, __s, &v54);
              if ((best_matching_voice & 0x80000000) == 0)
              {
                int v47 = v54;
                memset(v18, 32, HIDWORD(__n));
                if (v47)
                {
                  unint64_t v48 = strlen(__s);
                  if (v48 < HIDWORD(__n)) {
                    memcpy(v18, __s, v48);
                  }
                  uint64_t v16 = 0;
                  if ((paramc_ParamGetStr(v8[5], (uint64_t)"voice", &v57) & 0x80000000) == 0 && v57)
                  {
                    paramc_ParamSetStr(v8[5], (uint64_t)"pipelineswitchvoice", v57);
                    uint64_t v16 = paramc_ParamSetStr(v8[5], (uint64_t)"vsvoicetagwithlangunknow", __s);
                  }
                  goto LABEL_62;
                }
LABEL_61:
                paramc_ParamSetStr(v8[5], (uint64_t)"pipelineswitchvoice", __s);
                uint64_t v16 = paramc_ParamRemove(v8[5], (uint64_t)"vsvoicetagwithlangunknow");
                *a5 = 3;
LABEL_62:
                signed int v22 = v52;
LABEL_63:
                uint64_t v40 = HIDWORD(__n);
LABEL_64:
                if (v40)
                {
                  if (v22 != -12 || __n)
                  {
                    uint64_t v49 = (*(uint64_t (**)(void, void, void **, uint64_t))(*(void *)(a1 + 64) + 112))(*(void *)(a1 + 912), *(void *)(a1 + 920), &__dst, v40);
                    if ((v49 & 0x80000000) != 0
                      || (memcpy(__dst, v18, v40),
                          uint64_t v49 = (*(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 64) + 120))(*(void *)(a1 + 912), *(void *)(a1 + 920), v40), (v49 & 0x80000000) != 0))
                    {
                      uint64_t v16 = v49;
                    }
                    else
                    {
                      uint64_t v16 = (*(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 64) + 96))(*(void *)(a1 + 896), *(void *)(a1 + 904), v40);
                      if ((v16 & 0x80000000) == 0 && HIDWORD(__n) < v53 && *a5 != 3) {
                        *a5 = 2;
                      }
                    }
                    goto LABEL_30;
                  }
                  goto LABEL_74;
                }
LABEL_73:
                if (!__n) {
                  goto LABEL_74;
                }
LABEL_30:
                heap_Free((void *)v8[1], v14);
                heap_Free((void *)v8[1], (uint64_t)v10);
                if (v18) {
                  heap_Free((void *)v8[1], (uint64_t)v18);
                }
                if (v36) {
                  heap_Free((void *)v8[1], (uint64_t)v36);
                }
                return v16;
              }
              uint64_t v7 = best_matching_voice;
            }
            uint64_t v16 = v7;
            goto LABEL_30;
          }
LABEL_29:
          uint64_t v36 = 0;
          goto LABEL_30;
        }
      }
      else
      {
        if (!__n)
        {
          uint64_t v18 = 0;
          uint64_t v36 = 0;
LABEL_74:
          *a5 = 0;
          goto LABEL_30;
        }
        uint64_t v16 = synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 72), *(void *)(a1 + 64));
      }
    }
    uint64_t v18 = 0;
    goto LABEL_29;
  }
  return v7;
}

uint64_t vscmp_ProcessEnd(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 865, 928) & 0x80000000) != 0) {
    return 2600476680;
  }
  uint64_t v3 = *(void *)(a1 + 64);
  return synstrmaux_CloseStreams((_WORD *)(a1 + 72), v3);
}

unsigned __int8 *vs_trim_voice(const char *a1)
{
  uint64_t v1 = a1;
  unsigned int v2 = strlen(a1);
  uint64_t v3 = (unsigned __int8 *)&v1[v2];
  uint64_t v4 = v2;
  uint64_t v5 = MEMORY[0x263EF8318];
  while (1)
  {
    unsigned int v7 = *--v3;
    char v6 = v7;
    uint64_t v8 = (1 << v7) & 0x100002600;
    if (v7 > 0x20 || v8 == 0)
    {
      if (v6 < 0)
      {
        if (!__maskrune(v6, 0x200uLL)) {
          goto LABEL_12;
        }
        goto LABEL_6;
      }
      if ((*(_DWORD *)(v5 + 4 * v6 + 60) & 0x200) == 0) {
        break;
      }
    }
LABEL_6:
    *uint64_t v3 = 0;
    if (v4 == 1) {
      return v3;
    }
  }
  while (1)
  {
LABEL_12:
    unsigned int v10 = *(unsigned __int8 *)v1;
    if (v10 <= 0x20 && ((1 << v10) & 0x100002600) != 0) {
      goto LABEL_16;
    }
    if ((char)v10 < 0) {
      break;
    }
    if ((*(_DWORD *)(v5 + 4 * (char)v10 + 60) & 0x200) == 0) {
      return (unsigned __int8 *)v1;
    }
LABEL_16:
    ++v1;
  }
  if (__maskrune((char)v10, 0x200uLL)) {
    goto LABEL_16;
  }
  return (unsigned __int8 *)v1;
}

uint64_t vs_find_best_matching_voice(void *a1, char *__s, char *a3, _DWORD *a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v4 = 2600476681;
  uint64_t v11 = 0;
  if (!a3) {
    return 2600476679;
  }
  *a3 = 0;
  if (__s)
  {
    if (strchr(__s, 58))
    {
      uint64_t v4 = 0;
      if ((paramc_ParamGetStr(*(void *)(a1[2] + 40), (uint64_t)"voice", &v11) & 0x80000000) == 0 && v11)
      {
        int v16 = 0;
        long long v14 = 0u;
        long long v15 = 0u;
        memset(v13, 0, sizeof(v13));
        memset(v12, 0, sizeof(v12));
        VoiceParamExtract_0(__s, "lang", (char *)v13);
        VoiceParamExtract_0(__s, "gender", (char *)&v13[6] + 8);
        VoiceParamExtract_0(__s, "ietf", (char *)v13 + 8);
        VoiceParamExtract_0(__s, "age", (char *)&v14 + 4);
        VoiceParamExtract_0(__s, "model", (char *)&v13[7] + 12);
        if (*(void *)&v13[0] == 0x6E776F6E6B6E75)
        {
          if (a4) {
            *a4 = 1;
          }
          if (strlen(__s) + 5 <= 0x1FF)
          {
            *(void *)a3 = 0x3D676E616C5C1BLL;
            *(void *)&a3[strlen(a3)] = 0x6E6B6E75656376;
            if (BYTE8(v13[6]))
            {
              strcat(a3, ",gender:");
              strcat(a3, (const char *)&v13[6] + 8);
            }
            if (BYTE4(v14))
            {
              strcat(a3, ",age:");
              strcat(a3, (const char *)&v14 + 4);
            }
            if (BYTE12(v13[7]))
            {
              *(void *)&a3[strlen(a3)] = 0x3A6C65646F6D2CLL;
              strcat(a3, (const char *)&v13[7] + 12);
            }
            *(_WORD *)&a3[strlen(a3)] = 92;
          }
        }
        else
        {
          for (uint64_t i = -1;
                (((*(uint64_t (**)(void, void, void, void, _OWORD *, char *, uint64_t))(a1[7] + 136))(a1[5], a1[6], *(void *)(a1[2] + 24), *(void *)(a1[2] + 40), v12, a3, 512) & 0x80000000) != 0|| !*a3)&& i;
                ++i)
          {
            if (strlen((const char *)v13) == 3)
            {
              __strcpy_chk();
              BYTE2(v15) = 120;
              LOBYTE(v13[0]) = 0;
            }
          }
        }
        return 0;
      }
    }
    else if (strlen(__s) <= 0x1FF)
    {
      strcpy(a3, __s);
      return 0;
    }
  }
  return v4;
}

size_t VoiceParamExtract_0(const char *a1, const char *a2, char *a3)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v12 = 0;
  size_t result = strlen(a1);
  if (result <= 0x1FF)
  {
    __strcpy_chk();
    size_t result = (size_t)strhelper_SafeStrtok((uint64_t)v13, "{}();,", &v12);
    if (result)
    {
      char v6 = (char *)result;
      while (1)
      {
        unsigned int v7 = strchr(v6, 58);
        if (v7)
        {
          uint64_t v8 = v7;
          size_t v9 = strlen(a2);
          size_t result = strncmp(v6, a2, v9);
          if (!result) {
            break;
          }
        }
        size_t result = (size_t)strhelper_SafeStrtok((uint64_t)v13, "{}();,", &v12);
        char v6 = (char *)result;
        if (!result) {
          return result;
        }
      }
      int v11 = v8[1];
      unsigned int v10 = v8 + 1;
      if (v11) {
        return (size_t)strcpy(a3, v10);
      }
    }
  }
  return result;
}

uint64_t UnloadTuningResources(void *a1)
{
  uint64_t v2 = a1[1797];
  if (v2)
  {
    uint64_t result = 0;
    uint64_t v4 = &a1[2 * v2 + 1668];
    while (1)
    {
      uint64_t v5 = *(v4 - 1);
      if (v5)
      {
        uint64_t result = (*(uint64_t (**)(void, void, uint64_t, void))(a1[1668] + 80))(a1[1666], a1[1667], v5, *v4);
        if ((result & 0x80000000) != 0) {
          break;
        }
      }
      v4 -= 2;
      if (!--v2) {
        goto LABEL_8;
      }
    }
  }
  else
  {
    uint64_t result = 0;
LABEL_8:
    a1[1797] = 0;
  }
  return result;
}

uint64_t ELQSSMLStartParsing(uint64_t a1, unsigned __int16 *a2, unint64_t a3, int a4, int a5)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni) {
    return 2375032834;
  }
  memset(v25, 0, sizeof(v25));
  ELQSSMLReset(a1);
  if (a5)
  {
    LOBYTE(v25[0]) = 0;
  }
  else
  {
    uint64_t result = ELQXMLGetEncodingFromHeader(*(void *)(a1 + 2624), v25, a2, a3, a4);
    if (result) {
      return result;
    }
    if (LOBYTE(v25[0])) {
      goto LABEL_11;
    }
  }
  Name = TxtEncodingGetName(a4);
  if (!Name || !*Name)
  {
    __sprintf_chk(v24, 0, 0x200uLL, "Invalid or unsupported TextEncoding in parsing XML file");
LABEL_13:
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v12, v13, v14, v15, "SSML parser error");
    return 2375032839;
  }
  __strcpy_chk();
LABEL_11:
  if (ELQXMLSetEncoding(*(void *)(a1 + 2624)))
  {
    __sprintf_chk(v24, 0, 0x200uLL, "Unknown XML encoding \"%s\"");
    goto LABEL_13;
  }
  uint64_t result = ELQXMLSetCallbacks(*(void *)(a1 + 2624));
  if (!result)
  {
    uint64_t result = ELQXMLSetNamespaceCallbacks(*(void *)(a1 + 2624));
    if (!result)
    {
      uint64_t result = SetInitialVoiceAndLanguage(a1);
      if (!result)
      {
        *(void *)a1 = 0;
        uint64_t v16 = *(void *)(a1 + 13264);
        uint64_t v19 = *(void *)(v16 + 8);
        uint64_t v18 = (void *)(v16 + 8);
        uint64_t v17 = v19;
        if (v19) {
          heap_Free(***(void ****)(a1 + 13264), v17);
        }
        *uint64_t v18 = 0;
        v18[1] = 0;
        uint64_t v20 = *(void *)(a1 + 13272);
        uint64_t v23 = *(void *)(v20 + 8);
        signed int v22 = (void *)(v20 + 8);
        uint64_t v21 = v23;
        if (v23) {
          heap_Free(***(void ****)(a1 + 13272), v21);
        }
        uint64_t result = 0;
        *signed int v22 = 0;
        v22[1] = 0;
        *(_DWORD *)(a1 + 2084) = 0;
        *(void *)(a1 + 2096) = 0;
        *(unsigned char *)(a1 + 2104) = 0;
      }
    }
  }
  return result;
}

uint64_t ELQSSMLIni(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v8 = ELQXMLGetControllerFromParser(a3);
  uint64_t v51 = 0;
  uint64_t v9 = heap_Alloc(*(void *)(a1 + 8), 14408);
  if (!v9)
  {
    uint64_t v21 = 2375032842;
LABEL_10:
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"LIGHTSSML", 1923, "%s%s", v10, v11, v12, v13, "SSML parser error");
    return v21;
  }
  uint64_t v14 = v9;
  *(void *)(v9 + 1552) = ELQSSMLDelete;
  *(void *)(v9 + 13320) = 0;
  *(void *)(v9 + 12992) = a1;
  uint64_t v15 = (unsigned char *)(v9 + 12968);
  *(_DWORD *)(v9 + 2084) = 0;
  *(void *)(v9 + 2096) = 0;
  *(unsigned char *)(v9 + 2104) = 0;
  *(_OWORD *)(v9 + 2640) = 0u;
  *(_OWORD *)(v9 + 2656) = 0u;
  *(void *)(v9 + 2624) = a3;
  *(_DWORD *)(v9 + 8) = 3;
  *(unsigned char *)(v9 + 13196) = 0;
  *(unsigned char *)(v9 + 13228) = 0;
  *(unsigned char *)(v9 + 13128) = 0;
  *(unsigned char *)(v9 + 13000) = 0;
  strcpy((char *)(v9 + 13164), "normal");
  *(_DWORD *)(v9 + 2616) = 0;
  *(unsigned char *)(v9 + 13280) = 0;
  *(_DWORD *)(v9 + 13312) = 0;
  *(_DWORD *)(v9 + 1568) = 100;
  *(void *)(v9 + 1560) = 0x6400000050;
  *(void *)(v9 + 1572) = 0x746C7561666564;
  *(_DWORD *)(v9 + 2088) = 100;
  uint64_t v16 = (void *)heap_Alloc(*(void *)(a1 + 8), 24);
  if (!v16)
  {
    uint64_t v21 = 2375032842;
    *(void *)(v14 + 13264) = 0;
LABEL_9:
    heap_Free(*(void **)(a1 + 8), v14);
    goto LABEL_10;
  }
  v16[1] = 0;
  v16[2] = 0;
  void *v16 = a1 + 8;
  *(void *)(v14 + 13264) = v16;
  uint64_t v17 = *(void *)(v14 + 12992);
  uint64_t v19 = *(void *)(v17 + 8);
  uint64_t v18 = v17 + 8;
  uint64_t v20 = (void *)heap_Alloc(v19, 24);
  if (!v20)
  {
    uint64_t v21 = 2375032842;
    *(void *)(v14 + 13272) = 0;
    DynStringDestroy(*(void ***)(v14 + 13264));
    goto LABEL_9;
  }
  v20[1] = 0;
  v20[2] = 0;
  *uint64_t v20 = v18;
  *(void *)(v14 + 13272) = v20;
  *(void *)(v14 + 2632) = a4;
  *(void *)(v14 + 2704) = 0;
  *(void *)(v14 + 12984) = 0;
  *(void *)(v14 + 2672) = 0;
  *(void *)(v14 + 2688) = 0;
  *(void *)(v14 + 2680) = 0;
  *(_DWORD *)(v14 + 2716) = 4;
  *(void *)(v14 + 2720) = 0;
  if (v8) {
    ELQXMLGetNamespaceSeparator(v8, v15);
  }
  else {
    *uint64_t v15 = 0;
  }
  *(void *)(v14 + 16) = 0;
  *(void *)(v14 + 24) = 0;
  signed int v22 = (unsigned char *)(v14 + 2728);
  uint64_t v23 = 10;
  do
  {
    *signed int v22 = 0;
    v22[512] = 0;
    v22 += 1024;
    --v23;
  }
  while (v23);
  uint64_t v24 = 0;
  *(void *)(v14 + 2720) = 0;
  *(void *)(v14 + 1552) = ELQSSMLIni;
  signed int v25 = "auxiliary";
  while (1)
  {
    if (*(void *)(v14 + 16))
    {
      uint64_t v26 = 0;
      unsigned int v27 = 1;
      while (LH_stricmp(*(char **)(v14 + 24 * v26 + 24), v25))
      {
        uint64_t v26 = v27;
        uint64_t v28 = v14 + 24 * v27;
        uint64_t v30 = *(void *)(v28 + 16);
        uint64_t v29 = (void *)(v28 + 16);
        ++v27;
        if (!v30) {
          goto LABEL_21;
        }
      }
      uint64_t v21 = 2375032839;
      goto LABEL_29;
    }
    LODWORD(v26) = 0;
    unsigned int v27 = 1;
    uint64_t v29 = (void *)(v14 + 16);
LABEL_21:
    size_t v31 = strlen(v25);
    int v32 = (char *)heap_Alloc(*(void *)(*(void *)(v14 + 12992) + 8), v31 + 1);
    *(void *)(v14 + 24 * v26 + 24) = v32;
    if (v32)
    {
      strcpy(v32, v25);
      uint64_t v21 = tinystack_Ini(*(void *)(v14 + 12992), 40, v29);
      uint64_t v33 = v14 + 24 * v27;
      *(void *)(v33 + 16) = 0;
      *(void *)(v33 + 24) = 0;
    }
    else
    {
      *(_DWORD *)(v14 + 2084) = -1919934454;
      strcpy((char *)(v14 + 2104), "Out of Memory");
      ELQXMLGetCurrentLineNumber(*(void *)(v14 + 2624));
      uint64_t v21 = *(unsigned int *)(v14 + 2084);
    }
    if (v21) {
      goto LABEL_29;
    }
    if (++v24 == 19) {
      break;
    }
    signed int v25 = ELQSSMLIni_StacksName[v24];
    if (*(uint64_t (**)())(v14 + 1552) != ELQSSMLIni)
    {
      uint64_t v21 = 2375032834;
LABEL_29:
      __sprintf_chk(v52, 0, 0x200uLL, "Unable to handle XML attribute \"%s\". Out of memory.\n", v25);
      log_OutPublic(*(void *)(*(void *)(v14 + 12992) + 32), (uint64_t)"LIGHTSSML", 1441, "%s%s", v34, v35, v36, v37, "SSML parser error");
      ELQSSMLDelete((void *)v14);
      return v21;
    }
  }
  if (ELQXMLSetUnknownEncodingHandler(*(void *)(v14 + 2624)))
  {
    __sprintf_chk(v52, 0, 0x200uLL, "Unable to set unknown encoding handler");
    log_OutPublic(*(void *)(*(void *)(v14 + 12992) + 32), (uint64_t)"LIGHTSSML", 1441, "%s%s", v39, v40, v41, v42, "SSML parser error");
    ELQSSMLDelete((void *)v14);
    return 2375032839;
  }
  else
  {
    *(void *)(v14 + 13344) = 0;
    *(void *)(v14 + 13328) = safeh_GetNullHandle();
    *(void *)(v14 + 13336) = v43;
    if ((objc_GetObject(*(void *)(*(void *)(v14 + 12992) + 48), (uint64_t)"TTSEG", &v51) & 0x80000000) != 0)
    {
      log_OutPublic(*(void *)(*(void *)(v14 + 12992) + 32), (uint64_t)"LIGHTSSML", 1441, 0, v44, v45, v46, v47, v50);
    }
    else
    {
      uint64_t v48 = v51;
      *(_OWORD *)(v14 + 13328) = *(_OWORD *)(v51 + 16);
      *(void *)(v14 + 13344) = *(void *)(v48 + 8);
    }
    *(void *)(v14 + 13352) = safeh_GetNullHandle();
    *(void *)(v14 + 13360) = v49;
    *(void *)(v14 + 14376) = 0;
    *(void *)(v14 + 1552) = ELQSSMLIni;
    uint64_t v21 = 0;
    if (a2) {
      *a2 = v14;
    }
  }
  return v21;
}

uint64_t ELQSSMLReset(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(result + 1552) == ELQSSMLIni)
    {
      uint64_t v2 = *(void *)(result + 13264);
      uint64_t v5 = *(void *)(v2 + 8);
      uint64_t v4 = (void *)(v2 + 8);
      uint64_t v3 = v5;
      if (v5) {
        heap_Free(***(void ****)(result + 13264), v3);
      }
      *uint64_t v4 = 0;
      v4[1] = 0;
      uint64_t v6 = *(void *)(v1 + 13272);
      uint64_t v9 = *(void *)(v6 + 8);
      uint64_t v8 = (void *)(v6 + 8);
      uint64_t v7 = v9;
      if (v9) {
        heap_Free(***(void ****)(v1 + 13272), v7);
      }
      *uint64_t v8 = 0;
      v8[1] = 0;
      ELQXMLReset(*(void *)(v1 + 2624));
      uint64_t v10 = *(void *)(v1 + 16);
      if (v10)
      {
        unsigned int v11 = 1;
        do
        {
          tinystack_Reset(v10);
          uint64_t v10 = *(void *)(v1 + 24 * v11++ + 16);
        }
        while (v10);
      }
      unint64_t v12 = *(void *)(v1 + 2720);
      if (v12)
      {
        uint64_t v13 = (unsigned char *)(v1 + 2728);
        unsigned int v14 = 1;
        do
        {
          *uint64_t v13 = 0;
          unsigned char v13[512] = 0;
          v13 += 1024;
        }
        while (v12 > v14++);
      }
      *(void *)(v1 + 2720) = 0;
      hashtable_ObjClose(*(void **)(v1 + 12984));
      *(void *)(v1 + 12984) = 0;
      *(_DWORD *)(v1 + 1568) = 100;
      *(void *)(v1 + 1560) = 0x6400000050;
      *(_DWORD *)(v1 + 2088) = 100;
      uint64_t v16 = *(void *)(v1 + 2672);
      return ELQMemorySlotReset(v16);
    }
  }
  return result;
}

uint64_t SSMLstartElement(uint64_t result, char *__s, uint64_t *a3)
{
  if (*(_DWORD *)(result + 2084)) {
    return result;
  }
  uint64_t v5 = result;
  if (!*(void *)result)
  {
    *(_DWORD *)(result + 8) = 3;
    if (SSMLstricmpElement(result, __s, "speak"))
    {
      uint64_t result = LH_stricmp(__s, "text");
      if (result)
      {
        *(_DWORD *)(v5 + 2084) = -1919926671;
        strcpy((char *)(v5 + 2104), "Fatal syntax error");
        uint64_t result = ELQXMLGetCurrentLineNumber(*(void *)(v5 + 2624));
        goto LABEL_17;
      }
      int v8 = 2;
    }
    else
    {
      uint64_t result = *a3;
      if (*a3)
      {
        unsigned int v6 = 1;
        do
        {
          if (!LH_stricmp((char *)result, "version"))
          {
            uint64_t v7 = (const char *)a3[v6];
            if (v7)
            {
              if (!strcmp(v7, "1.0")) {
                *(_DWORD *)(v5 + 8) = 0;
              }
            }
          }
          uint64_t result = a3[v6 + 1];
          v6 += 2;
        }
        while (result);
      }
      int v8 = 1;
    }
    *(_DWORD *)(v5 + 8) = v8;
  }
LABEL_17:
  if (*(_DWORD *)(v5 + 8) <= 1u)
  {
    uint64_t result = (uint64_t)SSML10StartConvert(v5, __s, (uint64_t)a3);
    *(_DWORD *)(v5 + 2084) = result;
  }
  ++*(void *)v5;
  return result;
}

uint64_t SSMLendElement(uint64_t result, char *a2)
{
  if (!*(_DWORD *)(result + 2084))
  {
    uint64_t v2 = result;
    if (*(_DWORD *)(result + 8) <= 1u)
    {
      uint64_t result = SSML10EndConvert(result, a2);
      *(_DWORD *)(v2 + 2084) = result;
    }
    --*(void *)v2;
  }
  return result;
}

char *SSMLCharacterDataHandlerStandard(char *result, char *a2, int a3)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  int v36 = *((_DWORD *)result + 679);
  if (!a3) {
    return result;
  }
  uint64_t v3 = (uint64_t)result;
  if (*((_DWORD *)result + 521)) {
    return result;
  }
  size_t v5 = a3;
  unsigned int v6 = (char *)ELQMemorySlotReserve(*((void *(***)(uint64_t, uint64_t, int))result + 334), a3 + 1);
  if (!v6)
  {
    *(_DWORD *)(v3 + 2084) = -1919934454;
    strcpy((char *)(v3 + 2104), "Out of Memory");
    uint64_t v15 = *(void *)(v3 + 2624);
    return (char *)ELQXMLGetCurrentLineNumber(v15);
  }
  uint64_t v7 = v6;
  uint64_t v35 = 0;
  uint64_t v8 = XMLGetStack(v3, "auxiliary");
  if (!v8)
  {
    log_OutPublic(*(void *)(*(void *)(v3 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v9, v10, v11, v12, "SSML parser error");
    *(_DWORD *)(v3 + 2084) = -1919934462;
    strcpy((char *)(v3 + 2104), "SSML Stack unavailable");
    return (char *)ELQXMLGetCurrentLineNumber(*(void *)(v3 + 2624));
  }
  uint64_t v13 = v8;
  uint64_t v37 = 0;
  SSMLViewOnLangFailureFromStack(v3, &v36);
  int v14 = v36;
  if (v36 == 4) {
    int v14 = *(_DWORD *)(v3 + 2716);
  }
  uint64_t result = (char *)tinystack_View(v13, &v35);
  if ((v35 & 8) != 0) {
    return SSMLFallbackStringHandler((char *)v3, a2, v5);
  }
  if ((v35 & 0x10) != 0) {
    return result;
  }
  if ((v35 & 0x4000) == 0)
  {
    if (v14 == 1) {
      return result;
    }
    goto LABEL_19;
  }
  uint64_t v16 = XMLGetStack(v3, "audio");
  tinystack_View(v16, &v37);
  if (v37 == 1) {
    return SSMLFallbackStringHandler((char *)v3, a2, v5);
  }
LABEL_19:
  strncpy(v7, a2, v5);
  v7[v5] = 0;
  if (*(_DWORD *)(v3 + 13312))
  {
    int v17 = *v7;
    if (*v7)
    {
      uint64_t v18 = 0;
      uint64_t v19 = v7;
      do
      {
        if (v17 == 44)
        {
          if (v18)
          {
            if (v7[v18 - 1] - 48 <= 9)
            {
              uint64_t v20 = 1;
              do
                unsigned int v21 = v19[v20++] - 48;
              while (v21 < 0xA);
              int v22 = v20 - 2;
              if (v22)
              {
                if (v22 != 3) {
                  *uint64_t v19 = 46;
                }
              }
            }
          }
        }
        ++v18;
        int v23 = *++v19;
        int v17 = v23;
      }
      while (v23);
    }
  }
  uint64_t v24 = (char *)(v3 + 13280);
  if (!*(unsigned char *)(v3 + 13280)) {
    return (char *)(*(uint64_t (**)(char *, void))(v3 + 2640))(v7, *(void *)(v3 + 2648));
  }
  uint64_t v38 = 0;
  BOOL v25 = *(unsigned char *)(v3 + 13128) != 101 || *(unsigned char *)(v3 + 13129) != 110 || *(unsigned __int8 *)(v3 + 13130) != 117;
  uint64_t result = strhelper_SafeStrtok((uint64_t)v7, " \t\n", &v38);
  if (result)
  {
    uint64_t v26 = result;
    do
    {
      char v42 = 0;
      v43[0] = 0;
      if (strlen(v26) > 0xC) {
        goto LABEL_56;
      }
      unint64_t v40 = 0;
      unint64_t v41 = 0;
      unint64_t v39 = 0;
      if (!ExtractDate(v24, v26, &v41, &v40, &v39, 0, &v42, 0)) {
        goto LABEL_56;
      }
      unint64_t v27 = v42 == 47 ? 0 : 80;
      if (!ExtractDate(v24, v26, &v41, &v40, &v39, 1, &v42, v27)) {
        goto LABEL_56;
      }
      int v28 = v41;
      if (v41 && v40)
      {
        if (v25) {
          int v29 = v41;
        }
        else {
          int v29 = v40;
        }
        if (v25) {
          int v28 = v40;
        }
        int v30 = __sprintf_chk(v43, 0, 0x20uLL, "%d/%d", v29, v28);
        if (v39) {
          sprintf(&v43[v30], "/%d", v39);
        }
      }
      if (v43[0])
      {
        size_t v31 = *(void (**)(char *, uint64_t))(v3 + 2640);
        if (v31)
        {
          uint64_t v32 = *(void *)(v3 + 2648);
          uint64_t v33 = v43;
          goto LABEL_58;
        }
      }
      else
      {
LABEL_56:
        size_t v31 = *(void (**)(char *, uint64_t))(v3 + 2640);
        if (v31)
        {
          uint64_t v32 = *(void *)(v3 + 2648);
          uint64_t v33 = v26;
LABEL_58:
          v31(v33, v32);
          uint64_t v34 = *(void (**)(const char *, void))(v3 + 2640);
          if (v34) {
            v34(" ", *(void *)(v3 + 2648));
          }
        }
      }
      uint64_t result = strhelper_SafeStrtok((uint64_t)v7, " \t\n", &v38);
      uint64_t v26 = result;
    }
    while (result);
  }
  return result;
}

uint64_t SSMLStartNamespace(uint64_t result, uint64_t a2, char *__src)
{
  if (a2 | (unint64_t)__src)
  {
    uint64_t v3 = result;
    unint64_t v4 = *(void *)(result + 2720);
    if (v4 <= 9)
    {
      if (a2)
      {
        uint64_t result = __strcpy_chk();
        unint64_t v4 = *(void *)(v3 + 2720);
      }
      if (__src)
      {
        uint64_t result = (uint64_t)strcpy((char *)(v3 + (v4 << 10) + 3240), __src);
        unint64_t v4 = *(void *)(v3 + 2720);
      }
      *(void *)(v3 + 2720) = v4 + 1;
    }
  }
  return result;
}

uint64_t SSMLEndNamespace(uint64_t result, char *__s2)
{
  if (__s2)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(result + 2720);
    if (v3)
    {
      uint64_t v5 = 0;
      uint64_t v6 = result + 2728;
      uint64_t v7 = *(void *)(result + 2720);
      do
      {
        uint64_t result = strcmp((const char *)v6, __s2);
        if (!result)
        {
          *(unsigned char *)uint64_t v6 = 0;
          *(unsigned char *)(v6 + 512) = 0;
          ++v5;
        }
        v6 += 1024;
        --v7;
      }
      while (v7);
    }
    else
    {
      uint64_t v5 = 0;
    }
    *(void *)(v2 + 2720) = v3 - v5;
  }
  return result;
}

uint64_t SetInitialVoiceAndLanguage(uint64_t a1)
{
  uint64_t v6 = 0;
  uint64_t Str = paramc_ParamGetStr(*(void *)(*(void *)(a1 + 12992) + 40), (uint64_t)"langcode", &v6);
  if ((Str & 0x80000000) != 0) {
    return Str;
  }
  __strcpy_chk();
  uint64_t v3 = paramc_ParamGetStr(*(void *)(*(void *)(a1 + 12992) + 40), (uint64_t)"voice", &v6);
  if ((v3 & 0x80000000) == 0)
  {
    __strcpy_chk();
    *(_DWORD *)(a1 + 13160) = 0;
    if (paramc_ParamGetStr(*(void *)(*(void *)(a1 + 12992) + 40), (uint64_t)"processingtnplus", &v6)) {
      BOOL v4 = 1;
    }
    else {
      BOOL v4 = v6 == 0;
    }
    if (!v4 && !LH_stricmp(v6, "yes")) {
      *(_DWORD *)(a1 + 13160) = 1;
    }
  }
  return v3;
}

uint64_t ELQSSMLParse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v5 = 2375032834;
  if (a1 && *(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) == ELQSSMLIni)
  {
    uint64_t v5 = ELQXMLParse(*(void *)(a1 + 2624));
    memset(v16, 0, sizeof(v16));
    int v15 = 0;
    if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) == ELQSSMLIni)
    {
      uint64_t v8 = *(void *)(a1 + 2096);
      int v15 = v8;
      uint64_t v9 = (const char *)(a1 + 2104);
    }
    else
    {
      LODWORD(v8) = 0;
      uint64_t v9 = 0;
    }
    if (*(_DWORD *)(a1 + 2084))
    {
      if (!a5)
      {
        __sprintf_chk(v17, 0, 0x200uLL, "%s at line %d\n", v9, v8);
LABEL_9:
        log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v10, v11, v12, v13, "SSML parser error");
      }
    }
    else if (!ELQXMLGetError(*(void *)(a1 + 2624)) {
           && !(ELQXMLGetErrorString(*(void *)(a1 + 2624), 0, (char *)v16) | a5))
    }
    {
      __sprintf_chk(v17, 0, 0x200uLL, "%s at line %d\n", (const char *)v16, v15);
      goto LABEL_9;
    }
  }
  return v5;
}

void *ELQSSMLDelete(void *result)
{
  if (result)
  {
    uint64_t v1 = (uint64_t)result;
    uint64_t v2 = (uint64_t (*)())result[194];
    if (v2 == ELQSSMLIni || v2 == ELQSSMLDelete)
    {
      DynStringDestroy((void **)result[1659]);
      DynStringDestroy(*(void ***)(v1 + 13264));
      if (*(uint64_t (**)())(v1 + 1552) == ELQSSMLIni)
      {
        unsigned int v3 = -1;
        do
          ++v3;
        while (*(void *)(v1 + 24 * v3 + 16));
        if (v3)
        {
          unsigned int v4 = v3 - 1;
          do
          {
            uint64_t v5 = v4;
            uint64_t v6 = v1 + 24 * v4;
            tinystack_Delete(*(void **)(v6 + 16));
            heap_Free(*(void **)(*(void *)(v1 + 12992) + 8), *(void *)(v6 + 24));
            --v4;
          }
          while (v5);
        }
        *(void *)(v1 + 16) = 0;
        *(void *)(v1 + 24) = 0;
      }
      hashtable_ObjClose(*(void **)(v1 + 12984));
      uint64_t v7 = *(void *)(v1 + 12992);
      uint64_t v8 = *(void *)(v7 + 48);
      if (v8 && *(void *)(v1 + 13344))
      {
        objc_ReleaseObject(v8, (uint64_t)"TTSEG");
        *(void *)(v1 + 13344) = 0;
        uint64_t v7 = *(void *)(v1 + 12992);
      }
      uint64_t v9 = *(void **)(v7 + 8);
      return heap_Free(v9, v1);
    }
  }
  return result;
}

void *DynStringDestroy(void **a1)
{
  unsigned int v3 = a1 + 1;
  uint64_t v2 = (uint64_t)a1[1];
  if (v2) {
    heap_Free((void *)**a1, v2);
  }
  *unsigned int v3 = 0;
  v3[1] = 0;
  unsigned int v4 = (void *)**a1;
  return heap_Free(v4, (uint64_t)a1);
}

uint64_t ELQSSMLSetOutputFunction(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni) {
    return 2375032834;
  }
  uint64_t result = 0;
  *(void *)(a1 + 2640) = a2;
  *(void *)(a1 + 2648) = a3;
  return result;
}

uint64_t ELQSSMLSetMemorySlot(uint64_t a1, uint64_t a2)
{
  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni) {
    return 2375032834;
  }
  uint64_t result = 0;
  *(void *)(a1 + 2672) = a2;
  return result;
}

uint64_t ELQSSMLSetVoiceInfo(uint64_t a1, uint64_t a2)
{
  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni) {
    return 2375032834;
  }
  uint64_t result = 0;
  *(void *)(a1 + 2680) = a2;
  return result;
}

uint64_t ELQSSMLSetLangCodeConverter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni) {
    return 2375032834;
  }
  uint64_t result = 0;
  *(void *)(a1 + 14384) = a2;
  *(void *)(a1 + 14392) = a3;
  *(void *)(a1 + 14400) = a4;
  return result;
}

uint64_t SSMLstricmpElement(uint64_t a1, char *__s, char *a3)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t result = 0xFFFFFFFFLL;
  if (__s && a3)
  {
    long long v51 = 0u;
    memset(v52, 0, sizeof(v52));
    long long v49 = 0u;
    long long v50 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v38 = 0u;
    long long v37 = 0u;
    long long v36 = 0u;
    long long v35 = 0u;
    long long v34 = 0u;
    long long v33 = 0u;
    long long v32 = 0u;
    long long v31 = 0u;
    long long v30 = 0u;
    long long v29 = 0u;
    long long v28 = 0u;
    long long v27 = 0u;
    long long v26 = 0u;
    long long v25 = 0u;
    long long v24 = 0u;
    long long v23 = 0u;
    long long v22 = 0u;
    uint64_t v20 = 0;
    char v21 = 0;
    char v7 = *(unsigned char *)(a1 + 12968);
    if (!v7 || strchr(__s, *(char *)(a1 + 12968)))
    {
      __sa[0] = v7;
      __sa[1] = 0;
      size_t v8 = strlen(__s);
      uint64_t v9 = ELQMemorySlotSave(*(void *(***)(uint64_t, uint64_t, int))(a1 + 2672), __s, v8 + 1);
      if (!v9) {
        goto LABEL_20;
      }
      uint64_t v10 = (uint64_t)v9;
      uint64_t v11 = strhelper_SafeStrtok((uint64_t)v9, __sa, &v20);
      if (!v11) {
        goto LABEL_20;
      }
      uint64_t v12 = *(void *)(a1 + 2720);
      if (v12)
      {
        uint64_t v13 = v11;
        int v14 = (char *)(a1 + 3240);
        while (strcmp(v13, v14)
             && strcmp(v13, "http://www.w3.org/2001/10/synthesis")
             && strcmp(v13, "http://www.w3.org/XML/1998/namespace"))
        {
          v14 += 1024;
          if (!--v12) {
            goto LABEL_22;
          }
        }
        int v15 = strhelper_SafeStrtok(v10, __sa, &v20);
        if (v15)
        {
          uint64_t v16 = v15;
          int v17 = "http://www.w3.org/XML/1998/namespace";
          if (LH_stricmp(v14, "http://www.w3.org/XML/1998/namespace"))
          {
            uint64_t v18 = 1u;
            int v17 = "http://www.w3.org/2001/10/synthesis";
            while (LH_stricmp("http://www.w3.org/2001/10/synthesis", v14)
                 || LH_stricmp(isValidElementForUri_tagsTable[v18], v16))
            {
              v18 += 2;
              if (v18 == 45) {
                goto LABEL_20;
              }
            }
          }
          *(void *)(a1 + 12976) = v17;
          goto LABEL_22;
        }
LABEL_20:
        char v21 = 0;
        return LH_stricmp(&v21, a3);
      }
    }
LABEL_22:
    __strcpy_chk();
    return LH_stricmp(&v21, a3);
  }
  return result;
}

uint64_t SetSSMLError(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 2084) = a2;
  __strcpy_chk();
  uint64_t v3 = *(void *)(a1 + 2624);
  return ELQXMLGetCurrentLineNumber(v3);
}

char *SSML10StartConvert(uint64_t a1, char *a2, uint64_t a3)
{
  uint64_t v146 = *MEMORY[0x263EF8340];
  v143[0] = 0;
  if (!SSMLstricmpElement(a1, a2, "speak"))
  {
    *(void *)(a1 + 2688) = 0;
    *(void *)(a1 + 2704) = 0;
    *(_DWORD *)(a1 + 2696) = 0;
    *(_DWORD *)(a1 + 2712) = 0;
    uint64_t v11 = *(char **)a3;
    if (*(void *)a3)
    {
      v140 = 0;
      unsigned int v12 = 1;
      uint64_t v13 = (char **)a3;
      int v14 = 1;
      int v15 = 1;
      do
      {
        if (!LH_stricmp(v11, "version") && *(void *)(a3 + 8 * v12)) {
          int v14 = 0;
        }
        if (*v13)
        {
          if ((!SSMLstricmp(a1, *v13, "lang") || !SSMLstricmp(a1, *v13, "xml:lang"))
            && *(void *)(a3 + 8 * v12))
          {
            int v15 = 0;
          }
          if (*v13)
          {
            if (!LH_stricmp(*v13, "autolid"))
            {
              uint64_t v16 = *(char **)(a3 + 8 * v12);
              if (v16)
              {
                int v17 = SSMLstricmp(a1, v16, "no");
                uint64_t v18 = "yes";
                if (!v17) {
                  uint64_t v18 = "no";
                }
                v140 = (char *)v18;
              }
            }
            if (*v13
              && (!SSMLstricmp(a1, *v13, "base") || !SSMLstricmp(a1, *v13, "xml:base")))
            {
              uint64_t v19 = *(char **)(a3 + 8 * v12);
              if (v19)
              {
                UrlSetBaseURI(a1, v19);
                uint64_t v20 = *(void (**)(char *, void))(a1 + 2640);
                if (v20) {
                  v20(v143, *(void *)(a1 + 2648));
                }
              }
            }
          }
        }
        uint64_t v13 = (char **)(a3 + 8 * (v12 + 1));
        uint64_t v11 = *v13;
        v12 += 2;
      }
      while (*v13);
      if (*(_DWORD *)(a1 + 2616))
      {
        if (!v14 || !v15)
        {
          if (v14)
          {
            log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1458, "%s%s", v6, v7, v8, v9, "SSML parser error");
            *(_DWORD *)(a1 + 2084) = -1919926671;
            strcpy((char *)(a1 + 2104), "The \"version\" attribute is required for \"speak\" element");
            goto LABEL_195;
          }
          goto LABEL_74;
        }
LABEL_54:
        log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1458, "%s%s", v6, v7, v8, v9, "SSML parser error");
        *(_DWORD *)(a1 + 2084) = -1919926671;
        strcpy((char *)(a1 + 2104), "The \"version\" attribute and the \"xml:lang\" attribute are required for \"speak\" element");
        uint64_t v26 = *(void *)(a1 + 2624);
LABEL_196:
        ELQXMLGetCurrentLineNumber(v26);
        return (char *)*(unsigned int *)(a1 + 2084);
      }
      if (!v14)
      {
LABEL_74:
        if (v15)
        {
          uint64_t v50 = *(void *)(*(void *)(a1 + 12992) + 32);
          if (*(_DWORD *)(a1 + 2616))
          {
            log_OutPublic(v50, (uint64_t)"LIGHTSSML", 1458, "%s%s", v6, v7, v8, v9, "SSML parser error");
            *(_DWORD *)(a1 + 2084) = -1919926671;
            strcpy((char *)(a1 + 2104), "The \"xml:lang\" attribute is required for \"speak\" element\n");
            goto LABEL_195;
          }
          log_OutText(v50, (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"SSML: Warning: the \"xml:lang\" attribute is required for \"speak\" element\n", v7, v8, v9, v139);
        }
        SSMLSaveOnLangFailureIntoStack(a1, *(_DWORD *)(a1 + 2716));
        long long v51 = *(char **)a3;
        BOOL v52 = *(void *)a3 != 0;
        if (!v15 && !v51)
        {
          uint64_t Str = 0;
LABEL_101:
          UnloadTuningResources((void *)a1);
          return (char *)Str;
        }
        uint64_t Str = 0;
        unsigned int v54 = 1;
        uint64_t v55 = (char **)a3;
        while (1)
        {
          if (v15)
          {
            *(void *)__s = 0;
            uint64_t Str = paramc_ParamGetStr(*(void *)(*(void *)(a1 + 12992) + 40), (uint64_t)"langcode", __s);
            if ((Str & 0x80000000) != 0) {
              goto LABEL_101;
            }
            uint64_t v56 = *(void *)__s;
          }
          else
          {
            if (!v52 || SSMLstricmp(a1, v51, "lang") && SSMLstricmp(a1, *v55, "xml:lang")) {
              goto LABEL_94;
            }
            uint64_t v56 = *(void *)(a3 + 8 * v54);
            if (!v56) {
              goto LABEL_94;
            }
            *(void *)__s = *(void *)(a3 + 8 * v54);
          }
          uint64_t v57 = NormalizeLangCode((void *)a1, v56);
          aux_SetActiveLanguage(a1, v57, v140);
          __sprintf_chk(v143, 0, 0x200uLL, "\x1B\\lang=%s\\"", (const char *)(a1 + 13128));
          uint64_t v58 = *(void (**)(char *, void))(a1 + 2640);
          if (v58) {
            v58(v143, *(void *)(a1 + 2648));
          }
          if (v15)
          {
LABEL_95:
            uint64_t v59 = *(char **)a3;
            if (*(void *)a3)
            {
              int v60 = 1;
              do
              {
                if (!LH_stricmp(v59, "ssft-domaintype"))
                {
                  __strcpy_chk();
                  __sprintf_chk(v143, 0, 0x200uLL, "\x1B\\domain=%s\\"", (const char *)(a1 + 13228));
                  uint64_t v61 = *(void (**)(char *, void))(a1 + 2640);
                  if (v61) {
                    v61(v143, *(void *)(a1 + 2648));
                  }
                }
                uint64_t v59 = *(char **)(a3 + 8 * (v60 + 1));
                v60 += 2;
              }
              while (v59);
            }
            goto LABEL_101;
          }
LABEL_94:
          uint64_t v55 = (char **)(a3 + 8 * (v54 + 1));
          long long v51 = *v55;
          BOOL v52 = *v55 != 0;
          v54 += 2;
          if (!*v55) {
            goto LABEL_95;
          }
        }
      }
    }
    else
    {
      if (*(_DWORD *)(a1 + 2616)) {
        goto LABEL_54;
      }
      v140 = 0;
      int v15 = 1;
    }
    log_OutText(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"SSML: Warning: the \"version\" attribute is required for \"speak\" element\n", v7, v8, v9, v139);
    goto LABEL_74;
  }
  if (!SSMLstricmpElement(a1, a2, "meta"))
  {
    v141 = 0;
    uint64_t v142 = 0;
    if (CheckTagBond(a1, &v141))
    {
      __sprintf_chk(__s, 0, 0x200uLL, "The \"%s\" element can only contain text", v141);
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v21, v22, v23, v24, "SSML parser error");
LABEL_58:
      *(_DWORD *)(a1 + 2084) = -1919926671;
      __strcpy_chk();
LABEL_59:
      ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
      ReleaseTagBond(a1);
      return (char *)*(unsigned int *)(a1 + 2084);
    }
    uint64_t v31 = XMLGetStack(a1, "tagOrder");
    if (!v31) {
      goto LABEL_194;
    }
    if ((tinystack_View(v31, &v142) & 0x80000000) == 0 && v142 == 13)
    {
      __sprintf_chk(__s, 0, 0x200uLL, "The \"%s\" element can only contain text", v141);
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v36, v37, v38, v39, "SSML parser error");
      unsigned __int16 v40 = 8194;
LABEL_163:
      *(_DWORD *)(a1 + 2084) = v40 | 0x8D900000;
      __strcpy_chk();
      goto LABEL_195;
    }
    uint64_t v72 = XMLGetStack(a1, "metadata");
    if (!v72) {
      goto LABEL_194;
    }
    uint64_t v73 = v72;
    if ((tinystack_View(v72, &v142) & 0x80000000) == 0) {
      uint64_t v142 = XMLGetCurrentValue(a1);
    }
    if ((tinystack_Push(v73, 17) & 0x80000000) == 0)
    {
      long long v78 = *(char **)a3;
      if (!*(void *)a3) {
        goto LABEL_207;
      }
      int v79 = 0;
      int v80 = 0;
      int v81 = 0;
      uint64_t v82 = 2;
      long long v83 = (char **)a3;
      do
      {
        if (LH_stricmp(v78, "name"))
        {
          if (*v83)
          {
            if (LH_stricmp(*v83, "http-equiv"))
            {
              if (*v83 && !LH_stricmp(*v83, "content")) {
                int v80 = 1;
              }
            }
            else
            {
              int v81 = 1;
            }
          }
        }
        else
        {
          int v79 = 1;
        }
        long long v83 = (char **)(a3 + 8 * (v82 & 0xFFFFFFFE));
        long long v78 = *v83;
        v82 += 2;
      }
      while (*v83);
      if (v79 && v81)
      {
        log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1462, "%s%s", v74, v75, v76, v77, "SSML parser error");
        *(_DWORD *)(a1 + 2084) = -1919926671;
        uint64_t v84 = a1 + 2104;
        *(void *)(a1 + 2104) = *(void *)"Out of Memory";
        uint64_t v85 = *(void *)" Memory";
LABEL_201:
        *(void *)(v84 + 6) = v85;
        goto LABEL_195;
      }
      if (v79 | v81)
      {
        if (v80) {
          return 0;
        }
        uint64_t v126 = *(void *)(*(void *)(a1 + 12992) + 32);
      }
      else
      {
LABEL_207:
        uint64_t v126 = *(void *)(*(void *)(a1 + 12992) + 32);
      }
      log_OutPublic(v126, (uint64_t)"LIGHTSSML", 1462, "%s%s", v74, v75, v76, v77, "SSML parser error");
      goto LABEL_209;
    }
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1923, "%s%s", v74, v75, v76, v77, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934454;
    uint64_t v84 = a1 + 2104;
    *(void *)(a1 + 2104) = *(void *)"Out of Memory";
    uint64_t v85 = *(void *)" Memory";
    goto LABEL_201;
  }
  if (!SSMLstricmpElement(a1, a2, "metadata"))
  {
    v141 = 0;
    uint64_t v142 = 0;
    if (CheckTagBond(a1, &v141))
    {
      long long v25 = v141;
LABEL_57:
      __sprintf_chk(__s, 0, 0x200uLL, "The \"%s\" element can only contain text", v25);
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1414, "%s%s", v27, v28, v29, v30, "SSML parser error");
      goto LABEL_58;
    }
    uint64_t v45 = XMLGetStack(a1, "tagOrder");
    if (!v45)
    {
LABEL_194:
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v32, v33, v34, v35, "SSML parser error");
      *(_DWORD *)(a1 + 2084) = -1919934462;
      strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
      goto LABEL_195;
    }
    if ((tinystack_View(v45, &v142) & 0x80000000) != 0 || v142 != 13)
    {
      uint64_t v101 = XMLGetStack(a1, "metadata");
      if (v101)
      {
        uint64_t v102 = v101;
        if ((tinystack_View(v101, &v142) & 0x80000000) == 0) {
          uint64_t v142 = XMLGetCurrentValue(a1);
        }
        if ((tinystack_Push(v102, 17) & 0x80000000) == 0) {
          return 0;
        }
        goto LABEL_199;
      }
      goto LABEL_194;
    }
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1414, "%s%s", v46, v47, v48, v49, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    strcpy((char *)(a1 + 2104), "\"metadata\" element must occur before all other element");
LABEL_195:
    uint64_t v26 = *(void *)(a1 + 2624);
    goto LABEL_196;
  }
  if (!SSMLstricmpElement(a1, a2, "mark"))
  {
    v141 = 0;
    uint64_t v142 = 0;
    if (CheckTagBond(a1, &v142))
    {
      long long v25 = (const char *)v142;
      goto LABEL_57;
    }
    uint64_t v66 = XMLGetStack(a1, "tagOrder");
    if (v66)
    {
      uint64_t v67 = v66;
      if ((tinystack_View(v66, &v141) & 0x80000000) != 0 && (tinystack_Push(v67, 13) & 0x80000000) != 0) {
        goto LABEL_199;
      }
      if (!*(void *)a3 || LH_stricmp(*(char **)a3, "name") || !*(void *)(a3 + 8)) {
        return 0;
      }
      __sprintf_chk(v143, 0, 0x200uLL, "\x1B\\mrk=%s\\"");
      goto LABEL_153;
    }
    goto LABEL_194;
  }
  if (!SSMLstricmpElement(a1, a2, "break"))
  {
    uint64_t v142 = 0;
    v143[0] = 0;
    *(void *)__s = 0;
    __int16 v145 = 0;
    if (CheckTagBond(a1, &v141))
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1446, "%s%s", v41, v42, v43, v44, "SSML parser error");
LABEL_105:
      *(_DWORD *)(a1 + 2084) = -1919926671;
      strcpy((char *)(a1 + 2104), "The \"%s\" element can only contain text");
      goto LABEL_59;
    }
    uint64_t v89 = XMLGetStack(a1, "tagOrder");
    if (!v89) {
      goto LABEL_194;
    }
    uint64_t v90 = v89;
    if ((tinystack_View(v89, &v142) & 0x80000000) != 0 && (tinystack_Push(v90, 13) & 0x80000000) != 0) {
      goto LABEL_199;
    }
    uint64_t v91 = *(char **)a3;
    if (*(void *)a3)
    {
      int v92 = 0;
      int v93 = (char **)(a3 + 16);
      unint64_t v94 = -1;
      do
      {
        if (!LH_stricmp(v91, "time"))
        {
          uint64_t v95 = (uint64_t)*(v93 - 1);
          if (v95)
          {
            size_t v96 = strlen(*(v93 - 1));
            if (*(unsigned char *)(v95 + v96 - 2) == 109)
            {
              __strncpy_chk();
              unint64_t v94 = (int)LH_atoi(__s);
            }
            else if ((*(unsigned __int8 *)(v95 + v96 - 1) | 0x20) == 0x73)
            {
              __strncpy_chk();
              uint64_t v97 = strrchr(__s, 44);
              if (v97) {
                *uint64_t v97 = 46;
              }
              unint64_t v94 = (unint64_t)(atof(__s) * 1000.0);
            }
          }
          if (v94 != -1)
          {
            __sprintf_chk(v143, 0, 0x200uLL, "\x1B\\pause=%d\\"", v94);
            uint64_t v98 = *(void (**)(char *, void))(a1 + 2640);
            if (v98) {
              v98(v143, *(void *)(a1 + 2648));
            }
          }
          int v92 = 1;
        }
        v99 = *v93;
        v93 += 2;
        uint64_t v91 = v99;
      }
      while (v99);
      if (!v92)
      {
        v127 = *(char **)a3;
        if (*(void *)a3)
        {
          v128 = (char **)(a3 + 8);
          do
          {
            if (!LH_stricmp(v127, "strength"))
            {
              if (!*v128 || !LH_stricmp(*v128, "medium") || !LH_stricmp(*v128, "weak")) {
                goto LABEL_221;
              }
              if (!LH_stricmp(*v128, "none"))
              {
                __sprintf_chk(v143, 0, 0x200uLL, "\x1B\\eos=0\\"");
                v130 = *(void (**)(char *, void))(a1 + 2640);
                if (v130) {
                  v130(v143, *(void *)(a1 + 2648));
                }
                __sprintf_chk(v143, 0, 0x200uLL, "\x1B\\pause=%d\\"");
                goto LABEL_222;
              }
              if (LH_stricmp(*v128, "x-weak"))
              {
                if (LH_stricmp(*v128, "strong") && LH_stricmp(*v128, "x-strong")) {
LABEL_221:
                }
                  __sprintf_chk(v143, 0, 0x200uLL, "\x1B\\pause\\"", v139);
                else {
                  __sprintf_chk(v143, 0, 0x200uLL, "\x1B\\eos=1\\"", v139);
                }
LABEL_222:
                v129 = *(void (**)(char *, void))(a1 + 2640);
                if (v129) {
                  v129(v143, *(void *)(a1 + 2648));
                }
                goto LABEL_224;
              }
              strcpy(v143, " ");
            }
LABEL_224:
            v127 = v128[1];
            v128 += 2;
          }
          while (v127);
        }
      }
    }
    if (v143[0]) {
      return 0;
    }
    __sprintf_chk(v143, 0, 0x200uLL, "\x1B\\pause\\"");
LABEL_153:
    v100 = *(void (**)(char *, void))(a1 + 2640);
    if (v100) {
      v100(v143, *(void *)(a1 + 2648));
    }
    return 0;
  }
  if (SSMLstricmpElement(a1, a2, "prosody"))
  {
    if (SSMLstricmpElement(a1, a2, "p"))
    {
      if (SSMLstricmpElement(a1, a2, "s"))
      {
        if (SSMLstricmpElement(a1, a2, "lang"))
        {
          if (!SSMLstricmpElement(a1, a2, "phoneme")) {
            return (char *)SSMLElement_PHONEME_Enter(a1, (char **)a3, (uint64_t)v143);
          }
          if (!SSMLstricmpElement(a1, a2, "voice")) {
            return (char *)SSMLElement_VOICE_Enter(a1, (char **)a3, v143);
          }
          if (!SSMLstricmpElement(a1, a2, "emphasis"))
          {
            return (char *)SSMLElement_EMPHASIS_Enter(a1, (void *)a3);
          }
          if (!SSMLstricmpElement(a1, a2, "sub"))
          {
            return (char *)SSMLElement_SUB_Enter(a1, a3);
          }
          if (!SSMLstricmpElement(a1, a2, "say-as")) {
            return (char *)SSMLElement_SAYAS_Enter(a1, (char **)a3, v143);
          }
          if (!SSMLstricmpElement(a1, a2, "audio")) {
            return (char *)SSMLElement_AUDIO_Enter(a1, (char **)a3, v143);
          }
          if (!SSMLstricmpElement(a1, a2, "style")) {
            return (char *)SSMLElement_STYLE_Enter(a1, (char **)a3, v143);
          }
          if (!SSMLstricmpElement(a1, a2, "prompt")) {
            return SSMLElement_PROMPT_Enter(a1, a3, v143);
          }
          if (!SSMLstricmpElement(a1, a2, "desc")) {
            return (char *)SSMLElement_DESC_Enter(a1, (char **)a3, v143);
          }
          if (!SSMLstricmpElement(a1, a2, "lexicon")) {
            return (char *)SSMLElement_LEXICON_Enter(a1, (char **)a3, (uint64_t)v143);
          }
          return 0;
        }
        uint64_t v86 = a1;
        long long v87 = (char **)a3;
        uint64_t v88 = 2;
      }
      else
      {
        uint64_t v86 = a1;
        long long v87 = (char **)a3;
        uint64_t v88 = 0;
      }
    }
    else
    {
      uint64_t v86 = a1;
      long long v87 = (char **)a3;
      uint64_t v88 = 1;
    }
    return (char *)SSMLElement_Block_Enter(v86, v87, v143, v88);
  }
  uint64_t v142 = 0;
  if (!*(void *)a3)
  {
    __sprintf_chk(__s, 0, 0x200uLL, "At least one attribute must be specified for \"prosody\" element");
LABEL_162:
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1305, "%s%s", v103, v104, v105, v106, "SSML parser error");
    unsigned __int16 v40 = 15985;
    goto LABEL_163;
  }
  if (CheckTagBond(a1, &v141))
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1305, "%s%s", v62, v63, v64, v65, "SSML parser error");
    goto LABEL_105;
  }
  uint64_t v107 = XMLGetStack(a1, "tagOrder");
  if (!v107) {
    goto LABEL_194;
  }
  uint64_t v108 = v107;
  if ((tinystack_View(v107, &v142) & 0x80000000) != 0 && (tinystack_Push(v108, 13) & 0x80000000) != 0)
  {
LABEL_199:
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v68, v69, v70, v71, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919933952;
    strcpy((char *)(a1 + 2104), "Too many nested attributes");
    goto LABEL_195;
  }
  SSMLPushProsodicParameters(a1);
  v109 = *(char **)a3;
  if (!*(void *)a3)
  {
LABEL_191:
    uint64_t v114 = XMLGetStack(a1, "auxiliary");
    if (!v114)
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v115, v116, v117, v118, "SSML parser error");
      uint64_t v124 = a1;
      int v123 = -1919934462;
      goto LABEL_210;
    }
    if ((tinystack_Push(v114, 0) & 0x80000000) != 0)
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v119, v120, v121, v122, "SSML parser error");
      int v123 = -1919933952;
      uint64_t v124 = a1;
      goto LABEL_210;
    }
    return 0;
  }
  v110 = (char **)(a3 + 8);
  while (1)
  {
    if (!LH_stricmp(v109, "rate") && *v110)
    {
      if (!ParseAttribute(a1, *v110, 2))
      {
        __sprintf_chk(__s, 0, 0x200uLL, "Error in prosody element - rate attribute");
        goto LABEL_243;
      }
      goto LABEL_190;
    }
    v111 = *(v110 - 1);
    if (!v111) {
      goto LABEL_234;
    }
    if (LH_stricmp(v111, "pitch") || !*v110) {
      break;
    }
    if (!ParseAttribute(a1, *v110, 3))
    {
      __sprintf_chk(__s, 0, 0x200uLL, "Error in prosody element - pitch attribute");
      goto LABEL_246;
    }
LABEL_190:
    v109 = v110[1];
    v110 += 2;
    if (!v109) {
      goto LABEL_191;
    }
  }
  v112 = *(v110 - 1);
  if (!v112) {
    goto LABEL_234;
  }
  if (LH_stricmp(v112, "timbre") || !*v110)
  {
    v113 = *(v110 - 1);
    if (!v113 || LH_stricmp(v113, "volume") || !*v110)
    {
LABEL_234:
      __sprintf_chk(__s, 0, 0x200uLL, "Error in prosody element - unknown or unimplemented attribute");
      goto LABEL_162;
    }
    if (!ParseAttribute(a1, *v110, 1))
    {
      __sprintf_chk(__s, 0, 0x200uLL, "Error in prosody element - volume attribute");
LABEL_243:
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1305, "%s%s", v131, v132, v133, v134, "SSML parser error");
      goto LABEL_209;
    }
    goto LABEL_190;
  }
  if (ParseAttribute(a1, *v110, 4)) {
    goto LABEL_190;
  }
  __sprintf_chk(__s, 0, 0x200uLL, "Error in prosody element - timbre attribute");
LABEL_246:
  log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1304, "%s%s", v135, v136, v137, v138, "SSML parser error");
LABEL_209:
  uint64_t v124 = a1;
  int v123 = -1919926671;
LABEL_210:
  SetSSMLError(v124, v123);
  return (char *)*(unsigned int *)(a1 + 2084);
}

uint64_t SSMLElement_Block_Enter(uint64_t a1, char **a2, char *a3, uint64_t a4)
{
  v60[64] = *(char **)MEMORY[0x263EF8340];
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  unsigned int v55 = *(_DWORD *)(a1 + 2716);
  if (CheckTagBond(a1, &v56))
  {
    __sprintf_chk((char *)v60, 0, 0x200uLL, "The \"%s\" element can only contain text", v56);
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v8, v9, v10, v11, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v12 = XMLGetStack(a1, "tagOrder");
  if (!v12)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v13, v14, v15, v16, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
LABEL_42:
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v17 = v12;
  if ((tinystack_View(v12, &v57) & 0x80000000) != 0 && (tinystack_Push(v17, 13) & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v18, v19, v20, v21, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919933952;
    strcpy((char *)(a1 + 2104), "Too many nested attributes");
    goto LABEL_42;
  }
  BOOL v52 = a3;
  uint64_t Str = SSMLViewOnLangFailureFromStack(a1, &v55);
  if (!Str)
  {
    unsigned int v23 = v55;
    if (v55 == 4) {
      unsigned int v23 = *(_DWORD *)(a1 + 2716);
    }
    unsigned int v51 = v23;
    *BOOL v52 = 0;
    uint64_t v24 = *a2;
    if (*a2)
    {
      uint64_t v25 = 0;
      uint64_t v53 = 0;
      __s2 = 0;
      uint64_t v26 = 0;
      int v27 = 0;
      uint64_t v50 = 0;
      uint64_t v28 = "lang";
      uint64_t v29 = a2;
      do
      {
        if (SSMLstricmp(a1, v24, v28) && SSMLstricmp(a1, *v29, "xml:lang")
          || (uint64_t v30 = *(uint64_t *)((char *)a2 + ((8 * v25) | 8))) == 0)
        {
          if (*v29)
          {
            if (SSMLstricmp(a1, *v29, "onlangfailure")
              || (uint64_t v39 = *(char **)((char *)a2 + ((8 * v25) | 8))) == 0)
            {
              if (*v29)
              {
                if (!LH_stricmp(*v29, "autolid"))
                {
                  uint64_t v36 = *(char **)((char *)a2 + ((8 * v25) | 8));
                  if (v36)
                  {
                    int v37 = SSMLstricmp(a1, v36, "no");
                    uint64_t v38 = "yes";
                    if (!v37) {
                      uint64_t v38 = "no";
                    }
                    uint64_t v50 = (char *)v38;
                  }
                }
              }
            }
            else
            {
              unsigned int v51 = SSMLGetLangFailureCode(v39);
            }
          }
        }
        else
        {
          uint64_t v31 = (char *)NormalizeLangCode((void *)a1, v30);
          size_t v32 = strlen(v31);
          __s2 = v31;
          uint64_t v53 = ELQMemorySlotSave(*(void *(***)(uint64_t, uint64_t, int))(a1 + 2672), v31, v32 + 1);
          uint64_t v59 = 0;
          v60[0] = 0;
          paramc_ParamGetStr(*(void *)(*(void *)(a1 + 12992) + 40), (uint64_t)"extraesclang", v60);
          uint64_t Str = paramc_ParamGetStr(*(void *)(*(void *)(a1 + 12992) + 40), (uint64_t)"langcode", &v59);
          if ((Str & 0x80000000) != 0) {
            return Str;
          }
          uint64_t v33 = a4;
          uint64_t v34 = v28;
          for (uint64_t i = 0; i != 3; ++i)
            __s1[i] = ssft_tolower(*(unsigned __int8 *)(v59 + i));
          __s1[3] = 0;
          uint64_t v28 = v34;
          a4 = v33;
          if (strstr(__s1, __s2) || v60[0] && strstr(v60[0], __s2))
          {
            int v27 = 1;
            if (Str) {
              return Str;
            }
          }
          else
          {
            int v27 = 0;
            if (Str) {
              return Str;
            }
          }
        }
        if (a4 <= 1)
        {
          if (*v29)
          {
            if (!LH_stricmp(*v29, "ssft-domaintype"))
            {
              if (*(char **)((char *)a2 + ((8 * v25) | 8)))
              {
                __strcpy_chk();
                sprintf(v52, "\x1B\\domain=%s\\"", (const char *)(a1 + 13196));
                unsigned __int16 v40 = *(void (**)(char *, void))(a1 + 2640);
                if (v40) {
                  v40(v52, *(void *)(a1 + 2648));
                }
              }
            }
          }
        }
        ++v26;
        uint64_t v25 = 2 * v26;
        uint64_t v29 = &a2[2 * v26];
        uint64_t v24 = *v29;
      }
      while (*v29);
    }
    else
    {
      int v27 = 0;
      uint64_t v53 = 0;
      __s2 = 0;
      uint64_t v50 = 0;
    }
    int v42 = v51;
    unsigned int v55 = v51;
    if (__s2) {
      BOOL v43 = 1;
    }
    else {
      BOOL v43 = a4 == 2;
    }
    unsigned int v44 = 4;
    if (v43)
    {
      uint64_t v45 = v52;
      uint64_t v46 = (uint64_t)v53;
      uint64_t v47 = v50;
      if (!v27)
      {
        if (v51 != 4)
        {
          SSMLSaveOnLangFailureIntoStack(a1, v51);
          if (!v51) {
            SSMLPushVoice(a1);
          }
LABEL_56:
          SSMLPushLanguage(a1);
          if (a4 == 1)
          {
            v45[8] = 0;
            uint64_t v48 = "\n\x1B\\para\\"";
          }
          else
          {
            if (a4)
            {
LABEL_62:
              SSMLOnLanguageChange(a1, v46, v47, v42, v45);
              return 0;
            }
            v45[8] = 0;
            uint64_t v48 = "\x1B\\eos=1\\"";
          }
          *(void *)uint64_t v45 = *(void *)v48;
          uint64_t v49 = *(void (**)(char *, void))(a1 + 2640);
          if (v49) {
            v49(v45, *(void *)(a1 + 2648));
          }
          goto LABEL_62;
        }
        unsigned int v44 = 3;
      }
    }
    else
    {
      uint64_t v45 = v52;
      uint64_t v46 = (uint64_t)v53;
      uint64_t v47 = v50;
    }
    unsigned int v55 = v44;
    SSMLSaveOnLangFailureIntoStack(a1, v44);
    int v42 = v44;
    goto LABEL_56;
  }
  return Str;
}

uint64_t SSMLElement_PHONEME_Enter(uint64_t a1, char **a2, uint64_t a3)
{
  uint64_t v62 = *MEMORY[0x263EF8340];
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  if (CheckTagBond(a1, &v59))
  {
    __sprintf_chk(v61, 0, 0x200uLL, "The \"%s\" element can only contain text", v59);
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1300, "%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t result = NewTagBond(a1, "phoneme");
  if (result) {
    return result;
  }
  uint64_t v11 = XMLGetStack(a1, "tagOrder");
  if (!v11)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v12, v13, v14, v15, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v16 = v11;
  if ((tinystack_View(v11, &v60) & 0x80000000) != 0 && (tinystack_Push(v16, 13) & 0x80000000) != 0)
  {
    uint64_t v52 = *(void *)(*(void *)(a1 + 12992) + 32);
LABEL_73:
    log_OutPublic(v52, (uint64_t)"LIGHTSSML", 1459, "%s%s", v17, v18, v19, v20, "SSML parser error");
    int v58 = -1919933952;
LABEL_74:
    uint64_t v57 = a1;
    goto LABEL_75;
  }
  uint64_t v21 = *a2;
  if (!*a2) {
    goto LABEL_70;
  }
  int v22 = 0;
  unsigned int v23 = 1;
  uint64_t v24 = 4;
  uint64_t v25 = a2;
  do
  {
    if (!LH_stricmp(v21, "orthmode"))
    {
      uint64_t v26 = a2[v23];
      if (v26)
      {
        if (!LH_stricmp(v26, "ignorepunct")) {
          int v22 = 1;
        }
      }
    }
    if (*v25)
    {
      if (!LH_stricmp(*v25, "alphabet"))
      {
        int v27 = a2[v23];
        if (v27)
        {
          if (LH_stricmp(v27, "nt-sampa")
            && LH_stricmp(a2[v23], "nts")
            && LH_stricmp(a2[v23], "x-sampa")
            && LH_stricmp(a2[v23], "x-navteq-sampa"))
          {
            if (LH_stricmp(a2[v23], "sxm-sampa"))
            {
              if (LH_stricmp(a2[v23], "lhp") && LH_stricmp(a2[v23], "x-l&h+"))
              {
                if (LH_stricmp(a2[v23], "pyt") && LH_stricmp(a2[v23], "pinyin"))
                {
                  if (LH_stricmp(a2[v23], "diacritized"))
                  {
                    if (LH_stricmp(a2[v23], "jeita"))
                    {
                      __sprintf_chk(v61, 0, 0x200uLL, "SSML: Unknown or unsupported alphabeth \"%s\"\n", a2[v23]);
                      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1300, "%s%s", v28, v29, v30, v31, "SSML parser error");
                      uint64_t v24 = 0;
                    }
                    else
                    {
                      uint64_t v24 = 128;
                    }
                  }
                  else
                  {
                    uint64_t v24 = 64;
                  }
                }
                else
                {
                  uint64_t v24 = 32;
                }
              }
              else
              {
                uint64_t v24 = 16;
              }
            }
            else
            {
              uint64_t v24 = 9;
            }
          }
          else
          {
            uint64_t v24 = 4;
          }
        }
      }
    }
    uint64_t v25 = &a2[v23 + 1];
    uint64_t v21 = *v25;
    v23 += 2;
  }
  while (*v25);
  size_t v32 = *a2;
  if (!*a2)
  {
LABEL_70:
    __sprintf_chk(v61, 0, 0x200uLL, "\"ph\" attribute is required in \"phoneme\" element");
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v53, v54, v55, v56, "SSML parser error");
    uint64_t v57 = a1;
    int v58 = -1919926671;
LABEL_75:
    SetSSMLError(v57, v58);
    return *(unsigned int *)(a1 + 2084);
  }
  int v33 = 0;
  uint64_t v34 = 0;
  BOOL v35 = v22 != 0;
  unsigned int v36 = 1;
  do
  {
    if (LH_stricmp(v32, "ph")) {
      goto LABEL_64;
    }
    uint64_t v37 = *(void *)(a1 + 13264);
    uint64_t v38 = strhelper_StringAppend(**(uint64_t ***)v37, *(char **)(v37 + 8), a2[v36], 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v37 + 16), 0x80uLL);
    *(void *)(v37 + 8) = v38;
    if (!v38)
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1923, "%s%s", v39, v40, v41, v42, "SSML parser error");
      int v58 = -1919934454;
      goto LABEL_74;
    }
    if (v24 > 15)
    {
      if (v24 > 63)
      {
        if (v24 == 64)
        {
          strcpy((char *)a3, "\x1B\\toi=diacritized");
LABEL_57:
          uint64_t v45 = *(void (**)(uint64_t, void))(a1 + 2640);
          if (v45) {
            v45(a3, *(void *)(a1 + 2648));
          }
          goto LABEL_59;
        }
        if (v24 != 128) {
          goto LABEL_59;
        }
        *(_DWORD *)(a3 + 8) = 6386793;
        BOOL v43 = "\x1B\\toi=jeita";
      }
      else if (v24 == 16)
      {
        *(_WORD *)(a3 + 8) = 112;
        BOOL v43 = "\x1B\\toi=lhp";
      }
      else
      {
        if (v24 != 32) {
          goto LABEL_59;
        }
        *(_WORD *)(a3 + 8) = 116;
        BOOL v43 = "\x1B\\toi=pyt";
      }
LABEL_56:
      *(void *)a3 = *(void *)v43;
      goto LABEL_57;
    }
    switch(v24)
    {
      case 0:
        uint64_t v44 = *(void *)(a1 + 13272);
        if (!*(void *)(v44 + 8)) {
          *(void *)(v44 + 8) = strhelper_StringAppend(**(uint64_t ***)v44, 0, &byte_20D5A22AE, 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v44 + 16), 0x80uLL);
        }
        break;
      case 4:
      case 8:
        *(_WORD *)(a3 + 8) = 115;
        BOOL v43 = "\x1B\\toi=nts";
        goto LABEL_56;
      case 9:
        *(_DWORD *)(a3 + 7) = 7564664;
        BOOL v43 = "\x1B\\toi=sxms";
        goto LABEL_56;
      default:
        break;
    }
LABEL_59:
    uint64_t v46 = XMLGetStack(a1, "phon");
    if (!v46) {
      goto LABEL_71;
    }
    v24 |= v35;
    if ((tinystack_Push(v46, v24) & 0x80000000) != 0) {
      goto LABEL_72;
    }
    uint64_t v51 = XMLGetStack(a1, "auxiliary");
    if (!v51)
    {
LABEL_71:
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v47, v48, v49, v50, "SSML parser error");
      uint64_t v57 = a1;
      int v58 = -1919934462;
      goto LABEL_75;
    }
    v34 |= 8uLL;
    if ((tinystack_Push(v51, v34) & 0x80000000) != 0)
    {
LABEL_72:
      uint64_t v52 = *(void *)(*(void *)(a1 + 12992) + 32);
      goto LABEL_73;
    }
    int v33 = 1;
LABEL_64:
    size_t v32 = a2[v36 + 1];
    v36 += 2;
  }
  while (v32);
  if (!v33) {
    goto LABEL_70;
  }
  return 0;
}

uint64_t SSMLElement_VOICE_Enter(uint64_t a1, char **a2, char *a3)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  uint64_t v43 = 0;
  if (!*a2)
  {
    __sprintf_chk(v44, 0, 0x200uLL, "At least one attribute must be specified for \"voice\" element");
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1433, "%s%s", v10, v11, v12, v13, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
LABEL_5:
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v42 = 0;
  if (CheckTagBond(a1, &v42))
  {
    __sprintf_chk(v44, 0, 0x200uLL, "The \"%s\" element can only contain text", v42);
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v15 = XMLGetStack(a1, "tagOrder");
  if (!v15)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v16, v17, v18, v19, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    goto LABEL_5;
  }
  uint64_t v20 = v15;
  if ((tinystack_View(v15, &v43) & 0x80000000) != 0 && (tinystack_Push(v20, 13) & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v21, v22, v23, v24, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919933952;
    strcpy((char *)(a1 + 2104), "Too many nested attributes");
    goto LABEL_5;
  }
  SSMLPushVoice(a1);
  SSMLPushLanguage(a1);
  SSMLPushProsodicParameters(a1);
  *a3 = 0;
  uint64_t v25 = *a2;
  if (!*a2)
  {
    uint64_t v26 = 0;
    int v27 = 0;
    unsigned int v36 = 0;
    goto LABEL_50;
  }
  uint64_t v26 = 0;
  uint64_t v41 = 0;
  int v27 = 0;
  uint64_t v28 = 0;
  unsigned int v29 = *(_DWORD *)(a1 + 8);
  uint64_t v30 = a2 + 1;
  do
  {
    if (!LH_stricmp(v25, "name") && *v30)
    {
      if (**v30) {
        uint64_t v28 = *v30;
      }
      goto LABEL_39;
    }
    if (v29 > 1) {
      goto LABEL_14;
    }
    uint64_t v34 = *(v30 - 1);
    if (!v34) {
      goto LABEL_39;
    }
    if (SSMLstricmp(a1, v34, "lang") && SSMLstricmp(a1, *(v30 - 1), "xml:lang") || !*v30)
    {
      BOOL v35 = *(v30 - 1);
      if (!v35) {
        goto LABEL_39;
      }
      if (!SSMLstricmp(a1, v35, "autolid") && *v30)
      {
        SSMLstricmp(a1, *v30, "no");
        goto LABEL_39;
      }
LABEL_14:
      uint64_t v31 = *(v30 - 1);
      if (v31)
      {
        if (LH_stricmp(v31, "gender") || !*v30)
        {
          size_t v32 = *(v30 - 1);
          if (v32)
          {
            if (LH_stricmp(v32, "age") || !*v30)
            {
              int v33 = *(v30 - 1);
              if (v33) {
                LH_stricmp(v33, "variant");
              }
            }
            else
            {
              uint64_t v26 = *v30;
            }
          }
        }
        else
        {
          uint64_t v41 = *v30;
        }
      }
      goto LABEL_39;
    }
    if (**v30) {
      int v27 = *v30;
    }
LABEL_39:
    uint64_t v25 = v30[1];
    v30 += 2;
  }
  while (v25);
  if (!v26)
  {
    unsigned int v36 = v41;
    if (!v28) {
      goto LABEL_50;
    }
    goto LABEL_57;
  }
  unsigned int v36 = v41;
  if (*v26)
  {
    int v37 = atoi(v26);
    uint64_t v38 = "Adult";
    if (v37 < 18) {
      uint64_t v38 = "Child";
    }
    if (v37 > 0) {
      uint64_t v26 = v38;
    }
  }
  if (v28)
  {
LABEL_57:
    __strcpy_chk();
    goto LABEL_65;
  }
LABEL_50:
  if (v36 || v26 || v27)
  {
    *(_WORD *)(a1 + 13000) = 40;
    if (v36)
    {
      __strcat_chk();
      __strcat_chk();
      if (v26)
      {
        __strcat_chk();
        goto LABEL_60;
      }
LABEL_61:
      if (v27)
      {
        NormalizeLangCode((void *)a1, (uint64_t)v27);
        __strcat_chk();
        goto LABEL_63;
      }
    }
    else
    {
      if (v26)
      {
LABEL_60:
        __strcat_chk();
        __strcat_chk();
        goto LABEL_61;
      }
      if (v27)
      {
        NormalizeLangCode((void *)a1, (uint64_t)v27);
LABEL_63:
        __strcat_chk();
        __strcat_chk();
      }
    }
    __strcat_chk();
  }
LABEL_65:
  if (*(unsigned char *)(a1 + 13000))
  {
    sprintf(a3, "\x1B\\voice=%s\\", "(push)"");
    uint64_t v39 = *(void (**)(char *, void))(a1 + 2640);
    if (v39) {
      v39(a3, *(void *)(a1 + 2648));
    }
    sprintf(a3, "\x1B\\voice=%s\\"", (const char *)(a1 + 13000));
    uint64_t v40 = *(void (**)(char *, void))(a1 + 2640);
    if (v40) {
      v40(a3, *(void *)(a1 + 2648));
    }
  }
  return 0;
}

uint64_t SSMLElement_EMPHASIS_Enter(uint64_t a1, void *a2)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  if (CheckTagBond(a1, &v20))
  {
    __sprintf_chk(v22, 0, 0x200uLL, "The \"%s\" element can only contain text", v20);
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v4, v5, v6, v7, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v8 = XMLGetStack(a1, "tagOrder");
  if (!v8)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v9, v10, v11, v12, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
LABEL_10:
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v13 = v8;
  if ((tinystack_View(v8, &v21) & 0x80000000) != 0 && (tinystack_Push(v13, 13) & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v14, v15, v16, v17, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919933952;
    strcpy((char *)(a1 + 2104), "Too many nested attributes");
    goto LABEL_10;
  }
  if (*a2 && *(unsigned char *)*a2) {
    uint64_t v18 = (char *)a2[1];
  }
  else {
    uint64_t v18 = "moderate";
  }
  Emphasis2Prosody(a1, v18);
  return 0;
}

uint64_t SSMLElement_SUB_Enter(uint64_t a1, uint64_t a2)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  uint64_t v35 = 0;
  unsigned int v36 = 0;
  if (CheckTagBond(a1, &v36))
  {
    __sprintf_chk(v37, 0, 0x200uLL, "The \"%s\" element can only contain text", v36);
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v4, v5, v6, v7, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v8 = XMLGetStack(a1, "tagOrder");
  if (!v8)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v9, v10, v11, v12, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    goto LABEL_10;
  }
  uint64_t v13 = v8;
  if ((tinystack_View(v8, &v35) & 0x80000000) != 0 && (tinystack_Push(v13, 13) & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v14, v15, v16, v17, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919933952;
    strcpy((char *)(a1 + 2104), "Too many nested attributes");
    goto LABEL_10;
  }
  if (!*(void *)a2 || LH_stricmp(*(char **)a2, "alias"))
  {
    __sprintf_chk(v37, 0, 0x200uLL, "\"alias\" attribute is required in \"sub\" element");
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v18, v19, v20, v21, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
LABEL_10:
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v23 = *(void (**)(void, void))(a1 + 2640);
  if (v23) {
    v23(*(void *)(a2 + 8), *(void *)(a1 + 2648));
  }
  uint64_t v24 = XMLGetStack(a1, "auxiliary");
  if (v24)
  {
    if ((tinystack_Push(v24, 16) & 0x80000000) == 0) {
      return NewTagBond(a1, "sub");
    }
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v29, v30, v31, v32, "SSML parser error");
    int v34 = -1919933952;
    uint64_t v33 = a1;
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v25, v26, v27, v28, "SSML parser error");
    uint64_t v33 = a1;
    int v34 = -1919934462;
  }
  SetSSMLError(v33, v34);
  return *(unsigned int *)(a1 + 2084);
}

uint64_t SSMLElement_SAYAS_Enter(uint64_t a1, char **a2, char *a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v26 = 0;
  if (CheckTagBond(a1, &v26))
  {
    __sprintf_chk(v27, 0, 0x200uLL, "The \"%s\" element can only contain text", v26);
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v10 = XMLGetStack(a1, "say-as");
  if (!v10)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v11, v12, v13, v14, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
LABEL_21:
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v15 = v10;
  uint64_t v16 = ELQMemorySlotSave(*(void *(***)(uint64_t, uint64_t, int))(a1 + 2672), (char *)(a1 + 13164), 0);
  if (!v16)
  {
    *(_DWORD *)(a1 + 2084) = -1919934454;
    strcpy((char *)(a1 + 2104), "Out of Memory");
    goto LABEL_21;
  }
  tinystack_Push(v15, (uint64_t)v16);
  *a3 = 0;
  uint64_t v17 = *a2;
  if (!*a2) {
    goto LABEL_38;
  }
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = a2 + 1;
  do
  {
    if (LH_stricmp(v17, "format"))
    {
      if (!LH_stricmp(*(v20 - 1), "interpret-as")) {
        uint64_t v18 = *v20;
      }
    }
    else
    {
      uint64_t v19 = *v20;
    }
    uint64_t v17 = v20[1];
    v20 += 2;
  }
  while (v17);
  if (!v18)
  {
    if (!v19 || LH_stricmp(v19, "slot")) {
      goto LABEL_38;
    }
    strcpy(a3, "\x1B\\slotbegin\\"");
    goto LABEL_37;
  }
  if (LH_stricmp(v18, "rational")
    && LH_stricmp(v18, "real")
    && LH_stricmp(v18, "decimal"))
  {
    if (!LH_stricmp(v18, "date") && v19)
    {
      strncpy((char *)(a1 + 13280), v19, 0x1FuLL);
      *(unsigned char *)(a1 + 13311) = 0;
      goto LABEL_27;
    }
  }
  else if (*(unsigned char *)(a1 + 13128) == 101 && *(unsigned char *)(a1 + 13129) == 110)
  {
    *(_DWORD *)(a1 + 13312) = 1;
  }
  if (!v19) {
    goto LABEL_28;
  }
LABEL_27:
  if (!LH_stricmp(v19, "slot"))
  {
    sprintf(a3, "\x1B\\slotbegin=%s\\"", v18);
LABEL_37:
    size_t v24 = strlen((const char *)(a1 + 13164));
    memmove((void *)(a1 + 13165), (const void *)(a1 + 13164), v24 + 1);
    *(unsigned char *)(a1 + 13164) = 95;
    goto LABEL_38;
  }
LABEL_28:
  uint64_t v22 = 0;
  uint64_t v23 = &qword_264111F88;
  do
  {
    if (!LH_stricmp(v18, (char *)*(v23 - 1))) {
      break;
    }
    ++v22;
    v23 += 2;
  }
  while (v22 != 27);
  __strcpy_chk();
  sprintf(a3, "\x1B\\tn=%s\\"", (const char *)(a1 + 13164));
LABEL_38:
  uint64_t v25 = *(void (**)(char *, void))(a1 + 2640);
  if (v25)
  {
    if (*a3) {
      v25(a3, *(void *)(a1 + 2648));
    }
  }
  return 0;
}

uint64_t SSMLElement_AUDIO_Enter(uint64_t a1, char **a2, char *a3)
{
  uint64_t v76 = *MEMORY[0x263EF8340];
  uint64_t v42 = 0;
  long long v75 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  *(_OWORD *)__dst = 0u;
  uint64_t v41 = 0;
  if (CheckTagBond(a1, &v41))
  {
    __sprintf_chk(v43, 0, 0x200uLL, "The \"%s\" element can only contain text", v41);
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t result = NewTagBond(a1, "audio");
  if (!result)
  {
    uint64_t v11 = XMLGetStack(a1, "tagOrder");
    if (v11)
    {
      uint64_t v16 = v11;
      if ((tinystack_View(v11, &v42) & 0x80000000) != 0 && (tinystack_Push(v16, 13) & 0x80000000) != 0) {
        goto LABEL_29;
      }
      uint64_t v21 = *a2;
      if (*a2)
      {
        uint64_t v22 = 0;
        uint64_t v23 = 2;
        do
        {
          if (!LH_stricmp(v21, "src")) {
            uint64_t v22 = v23 - 1;
          }
          uint64_t v21 = a2[v23];
          v23 += 2;
        }
        while (v21);
      }
      else
      {
        uint64_t v22 = 0;
      }
      uint64_t v24 = XMLGetStack(a1, "auxiliary");
      if (v24)
      {
        if ((tinystack_Push(v24, 0x4000) & 0x80000000) == 0)
        {
          uint64_t v25 = XMLGetStack(a1, "audio");
          if (!v25)
          {
            log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v26, v27, v28, v29, "SSML parser error");
            uint64_t v39 = a1;
            int v38 = -1919934462;
LABEL_31:
            SetSSMLError(v39, v38);
            return *(unsigned int *)(a1 + 2084);
          }
          uint64_t v30 = v25;
          if (v22)
          {
            uint64_t v31 = *(char **)(a1 + 13320);
            if (v31)
            {
              size_t v32 = strlen(*(const char **)(a1 + 13320));
              uint64_t v33 = a2[v22];
              if (strlen(v33) + v32 > 0x1FE)
              {
                log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v34, v35, v36, v37, "SSML parser error");
                int v38 = -1919934460;
LABEL_30:
                uint64_t v39 = a1;
                goto LABEL_31;
              }
            }
            else
            {
              uint64_t v33 = a2[v22];
            }
            UriCompleteUrl(v31, v33, __dst);
            ELQSubstituteEntitiesUTF8(__dst, 1);
            sprintf(a3, "\x1B\\audio=\"%s\"", __dst);
            uint64_t v40 = *(void (**)(char *, void))(a1 + 2640);
            if (v40) {
              v40(a3, *(void *)(a1 + 2648));
            }
          }
          if ((tinystack_Push(v30, 1) & 0x80000000) == 0) {
            return 0;
          }
        }
LABEL_29:
        log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v17, v18, v19, v20, "SSML parser error");
        int v38 = -1919933952;
        goto LABEL_30;
      }
    }
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v12, v13, v14, v15, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  return result;
}

uint64_t SSMLElement_STYLE_Enter(uint64_t a1, char **a2, char *a3)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  if (!*a2)
  {
    __sprintf_chk(v37, 0, 0x200uLL, "At least one attribute must be specified for \"style\" element");
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1305, "%s%s", v10, v11, v12, v13, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
LABEL_26:
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  if (CheckTagBond(a1, &v35))
  {
    __sprintf_chk(v37, 0, 0x200uLL, "The \"%s\" element can only contain text", v35);
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v14 = XMLGetStack(a1, "tagOrder");
  if (!v14) {
    goto LABEL_23;
  }
  uint64_t v19 = v14;
  if ((tinystack_View(v14, &v36) & 0x80000000) != 0 && (tinystack_Push(v19, 13) & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v20, v21, v22, v23, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919933952;
    strcpy((char *)(a1 + 2104), "Too many nested attributes");
    goto LABEL_26;
  }
  uint64_t v24 = XMLGetStack(a1, "style");
  if (!v24)
  {
LABEL_23:
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v15, v16, v17, v18, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    goto LABEL_26;
  }
  uint64_t v34 = v24;
  uint64_t v25 = *a2;
  if (!*a2) {
    goto LABEL_24;
  }
  unsigned int v26 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  int v29 = 0;
  uint64_t v30 = a2;
  do
  {
    if (LH_stricmp(v25, "name"))
    {
      if (*(_DWORD *)(a1 + 13160) == 1 && !LH_stricmp(*v30, "intensity")) {
        uint64_t v27 = a2[v26 | 1];
      }
    }
    else
    {
      uint64_t v28 = a2[v26 | 1];
    }
    unsigned int v26 = 2 * (unsigned __int16)++v29;
    uint64_t v30 = &a2[v26];
    uint64_t v25 = *v30;
  }
  while (*v30);
  if (!v28)
  {
LABEL_24:
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v15, v16, v17, v18, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    strcpy((char *)(a1 + 2104), "\"style\" element must have a name attribute\n");
    goto LABEL_26;
  }
  size_t v31 = strlen(v28);
  if (*(_DWORD *)(a1 + 13160) && v27) {
    v31 += strlen(v27) + 1;
  }
  if (v31 - 512 <= 0xFFFFFFFFFFFFFDFELL)
  {
    *(_DWORD *)(a1 + 2084) = -1919934455;
    strcpy((char *)(a1 + 2104), "Out of Memory");
    goto LABEL_26;
  }
  uint64_t v33 = ELQMemorySlotSave(*(void *(***)(uint64_t, uint64_t, int))(a1 + 2672), (char *)(a1 + 1572), 0);
  if (!v33)
  {
    SetSSMLError(a1, -1919934454);
    return *(unsigned int *)(a1 + 2084);
  }
  tinystack_Push(v34, (uint64_t)v33);
  *(unsigned char *)(a1 + 1572) = 0;
  __strcat_chk();
  if (*(_DWORD *)(a1 + 13160))
  {
    if (v27)
    {
      __strcat_chk();
      __strcat_chk();
    }
  }
  return ApplyCurrentStyle(a1, a3);
}

char *SSMLElement_PROMPT_Enter(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  if (CheckTagBond(a1, &v23))
  {
    __sprintf_chk(v24, 0, 0x200uLL, "The \"%s\" element can only contain text", v23);
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    ReleaseTagBond(a1);
    return (char *)*(unsigned int *)(a1 + 2084);
  }
  uint64_t v10 = XMLGetStack(a1, "tagOrder");
  if (!v10)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v11, v12, v13, v14, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
LABEL_10:
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return (char *)*(unsigned int *)(a1 + 2084);
  }
  uint64_t v15 = v10;
  if ((tinystack_View(v10, &v22) & 0x80000000) != 0 && (tinystack_Push(v15, 13) & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v16, v17, v18, v19, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919933952;
    strcpy((char *)(a1 + 2104), "Too many nested attributes");
    goto LABEL_10;
  }
  uint64_t result = *(char **)a2;
  if (*(void *)a2)
  {
    if (!LH_stricmp(result, "id") && *(void *)(a2 + 8))
    {
      sprintf(a3, "\x1B\\prompt=%s\\"", *(const char **)(a2 + 8));
      uint64_t v21 = *(void (**)(char *, void))(a1 + 2640);
      if (v21) {
        v21(a3, *(void *)(a1 + 2648));
      }
    }
    return 0;
  }
  return result;
}

uint64_t SSMLElement_DESC_Enter(uint64_t a1, char **a2, char *a3)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  size_t v32 = 0;
  uint64_t v33 = 0;
  int v6 = *(_DWORD *)(a1 + 2716);
  if (CheckTagBond(a1, &v32))
  {
    __sprintf_chk(v34, 0, 0x200uLL, "The \"%s\" element can only contain text", v32);
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1536, "%s%s", v7, v8, v9, v10, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919926671;
    __strcpy_chk();
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v11 = XMLGetStack(a1, "tagOrder");
  if (!v11)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v12, v13, v14, v15, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
LABEL_28:
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v16 = v11;
  if ((tinystack_View(v11, &v33) & 0x80000000) != 0 && (tinystack_Push(v16, 13) & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v17, v18, v19, v20, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919933952;
    strcpy((char *)(a1 + 2104), "Too many nested attributes");
    goto LABEL_28;
  }
  uint64_t v21 = *a2;
  if (*a2)
  {
    size_t v31 = 0;
    uint64_t v22 = 0;
    unsigned int v23 = 1;
    uint64_t v24 = a2;
    do
    {
      if (LH_stricmp(v21, "onlangfailure") || (uint64_t v25 = a2[v23]) == 0)
      {
        if (*v24)
        {
          if (SSMLstricmp(a1, *v24, "lang") && SSMLstricmp(a1, *v24, "xml:lang")
            || !a2[v23])
          {
            if (*v24)
            {
              if (!LH_stricmp(*v24, "autolid"))
              {
                unsigned int v26 = a2[v23];
                if (v26)
                {
                  int v27 = SSMLstricmp(a1, v26, "no");
                  uint64_t v28 = "yes";
                  if (!v27) {
                    uint64_t v28 = "no";
                  }
                  size_t v31 = (char *)v28;
                }
              }
            }
          }
          else
          {
            uint64_t v22 = (uint64_t)a2[v23];
          }
        }
      }
      else
      {
        int v6 = SSMLGetLangFailureCode(v25);
      }
      uint64_t v24 = &a2[v23 + 1];
      uint64_t v21 = *v24;
      v23 += 2;
    }
    while (*v24);
    if (v6) {
      goto LABEL_24;
    }
    goto LABEL_32;
  }
  uint64_t v22 = 0;
  size_t v31 = 0;
  if (!v6) {
LABEL_32:
  }
    SSMLPushVoice(a1);
LABEL_24:
  SSMLOnLanguageChange(a1, v22, v31, v6, a3);
  int v29 = *(void (**)(char *, void))(a1 + 2640);
  if (v29) {
    v29(a3, *(void *)(a1 + 2648));
  }
  return 0;
}

uint64_t SSMLElement_LEXICON_Enter(uint64_t a1, char **a2, uint64_t a3)
{
  uint64_t v65 = *MEMORY[0x263EF8340];
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  *(_OWORD *)__s = 0u;
  long long v34 = 0u;
  if (CheckTagBond(a1, &v32))
  {
    *(_DWORD *)(a1 + 2084) = -1919926670;
    ReleaseTagBond(a1);
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v7 = XMLGetStack(a1, "tagOrder");
  if (!v7)
  {
    uint64_t result = 2375032834;
LABEL_11:
    *(_DWORD *)(a1 + 2084) = result;
    return result;
  }
  if ((tinystack_View(v7, &v31) & 0x80000000) == 0 && v31 == 13)
  {
    unsigned __int16 v8 = 15986;
LABEL_10:
    uint64_t result = v8 | 0x8D900000;
    goto LABEL_11;
  }
  if (*(void *)(a1 + 14376) == 63)
  {
LABEL_9:
    unsigned __int16 v8 = 8201;
    goto LABEL_10;
  }
  uint64_t v9 = *a2;
  if (!*a2) {
    goto LABEL_34;
  }
  uint64_t v10 = 0;
  uint64_t v30 = 0;
  uint64_t v11 = 0;
  do
  {
    if (!LH_stricmp(v9, "uri")) {
      uint64_t v11 = v10 + 1;
    }
    uint64_t v12 = a2[v10];
    if (v12)
    {
      if (!SSMLstricmp(a1, v12, "base") || !SSMLstricmp(a1, a2[v10], "xml:base"))
      {
        uint64_t v13 = a2[v10 + 1];
        if (v13)
        {
          UrlSetBaseURI(a1, v13);
          uint64_t v14 = *(void (**)(uint64_t, void))(a1 + 2640);
          if (v14) {
            v14(a3, *(void *)(a1 + 2648));
          }
        }
      }
      uint64_t v15 = a2[v10];
      if (v15)
      {
        if (!SSMLstricmp(a1, v15, "type"))
        {
          uint64_t v16 = a2[v10 + 1];
          if (v16)
          {
            uint64_t v17 = *(void (**)(uint64_t, void))(a1 + 2640);
            if (v17) {
              v17(a3, *(void *)(a1 + 2648));
            }
            uint64_t v30 = v16;
          }
        }
      }
    }
    uint64_t v9 = a2[v10 + 2];
    v10 += 2;
  }
  while (v9);
  if (!v11)
  {
LABEL_34:
    uint64_t result = 2375040625;
    goto LABEL_11;
  }
  uint64_t v18 = *(char **)(a1 + 13320);
  if (v18)
  {
    size_t v19 = strlen(*(const char **)(a1 + 13320));
    uint64_t v20 = a2[v11];
    if (strlen(v20) + v19 >= 0x1FF) {
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v20 = a2[v11];
  }
  UriCompleteUrl(v18, v20, __s);
  ELQSubstituteEntitiesUTF8(__s, 1);
  uint64_t v25 = *(void *)(a1 + 13344);
  if (v25)
  {
    if (!v30 || !*v30) {
      determineMediaType(__s);
    }
    if (((*(uint64_t (**)(void, void))(v25 + 72))(*(void *)(a1 + 13328), *(void *)(a1 + 13336)) & 0x80000000) != 0)
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1448, "%s%s", v26, v27, v28, v29, "lexicon");
      return 0;
    }
    else
    {
      uint64_t result = 0;
      ++*(void *)(a1 + 14376);
    }
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1448, "%s%s", v21, v22, v23, v24, "lexicon");
    return 2375032857;
  }
  return result;
}

uint64_t SSMLstricmp(uint64_t a1, char *__s, char *a3)
{
  if (!__s || !a3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = __s;
  uint64_t v5 = strchr(__s, *(char *)(a1 + 12968));
  if (v5)
  {
    int v7 = *v5;
    int v6 = v5 + 1;
    if (v7) {
      uint64_t v4 = v6;
    }
  }
  return LH_stricmp(v4, a3);
}

uint64_t UrlSetBaseURI(uint64_t result, char *__s1)
{
  uint64_t v3 = result;
  uint64_t v4 = *(const char **)(result + 13320);
  if (v4)
  {
    if (__s1)
    {
      uint64_t result = strcmp(__s1, v4);
      if (!result) {
        return result;
      }
    }
  }
  else if (!__s1 || !*__s1)
  {
    return result;
  }
  uint64_t result = (uint64_t)heap_Free(*(void **)(*(void *)(v3 + 12992) + 8), (uint64_t)v4);
  if (__s1 && *__s1)
  {
    size_t v5 = strlen(__s1);
    uint64_t result = heap_Alloc(*(void *)(*(void *)(v3 + 12992) + 8), v5 + 1);
    *(void *)(v3 + 13320) = result;
    if (result)
    {
      return (uint64_t)strcpy((char *)result, __s1);
    }
  }
  else
  {
    *(void *)(v3 + 13320) = 0;
  }
  return result;
}

uint64_t SSMLSaveOnLangFailureIntoStack(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = XMLGetStack(a1, "onlangfailure");
  if (v4)
  {
    uint64_t result = tinystack_Push(v4, a2);
    if ((result & 0x80000000) == 0) {
      return result;
    }
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1459, "%s%s", v10, v11, v12, v13, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919933952;
    strcpy((char *)(a1 + 2104), "Too many nested attributes");
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v5, v6, v7, v8, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
  }
  uint64_t v14 = *(void *)(a1 + 2624);
  return ELQXMLGetCurrentLineNumber(v14);
}

uint64_t NormalizeLangCode(void *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  int v9 = 1;
  uint64_t v8 = 0;
  uint64_t v3 = a1[1798];
  if (v3
    && ((*(uint64_t (**)(void, void, uint64_t, void, uint64_t *, int *, void))(v3 + 32))(a1[1799], a1[1800], a2, 0, &v8, &v9, 0) & 0x80000000) == 0)
  {
    int v5 = v9;
    if (v9)
    {
      BOOL v6 = 1;
    }
    else
    {
      BOOL v6 = (*(int (**)(void, void, uint64_t, uint64_t *, int *))(a1[1798] + 40))(a1[1799], a1[1800], v2, &v8, &v9) >= 0;
      int v5 = v9;
    }
    if (v6 && v5 != 0) {
      return v8;
    }
  }
  return v2;
}

uint64_t aux_SetActiveLanguage(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v6 = a1 + 13128;
  uint64_t v7 = strchr((char *)(a1 + 13128), 58);
  uint64_t v8 = v7;
  if (a2)
  {
    __strcpy_chk();
    if (!a3)
    {
LABEL_6:
      if (!v8) {
        return __strcpy_chk();
      }
      goto LABEL_10;
    }
  }
  else if (v7)
  {
    __strncpy_chk();
    v10[(void)&v8[-v6]] = 0;
    if (!a3) {
      goto LABEL_6;
    }
  }
  else
  {
    __strcpy_chk();
    if (!a3) {
      return __strcpy_chk();
    }
  }
  if (!SSMLstricmp(a1, a3, "no")) {
LABEL_10:
  }
    __strcat_chk();
  return __strcpy_chk();
}

uint64_t XMLGetStack(uint64_t a1, char *a2)
{
  uint64_t result = 0;
  if (a1 && a2)
  {
    if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) == ELQSSMLIni)
    {
      uint64_t v5 = a1 + 16;
      if (*(void *)(a1 + 16))
      {
        if (!LH_stricmp(*(char **)(a1 + 24), a2)) {
          return *(void *)v5;
        }
        unsigned int v6 = 1;
        while (1)
        {
          uint64_t v7 = a1 + 24 * v6;
          uint64_t v8 = *(void *)(v7 + 16);
          uint64_t v5 = v7 + 16;
          if (!v8) {
            break;
          }
          unsigned int v9 = v6;
          int v10 = LH_stricmp(*(char **)(a1 + 24 * v6 + 24), a2);
          unsigned int v6 = v9 + 1;
          if (!v10) {
            return *(void *)v5;
          }
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t CheckTagBond(uint64_t a1, void *a2)
{
  uint64_t result = XMLGetStack(a1, "TagBond");
  if (result)
  {
    uint64_t v4 = 0;
    if ((tinystack_View(result, &v4) & 0x80000000) != 0)
    {
      return 0;
    }
    else
    {
      *a2 = v4;
      return 1;
    }
  }
  return result;
}

void *ReleaseTagBond(uint64_t a1)
{
  uint64_t v3 = 0;
  uint64_t result = (void *)XMLGetStack(a1, "TagBond");
  if (result)
  {
    uint64_t result = (void *)tinystack_Pop((uint64_t)result, &v3);
    if (v3) {
      return heap_Free(*(void **)(*(void *)(a1 + 12992) + 8), v3);
    }
  }
  return result;
}

uint64_t XMLGetCurrentValue(uint64_t a1)
{
  if (!a1) {
    return -1;
  }
  if (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t, uint64_t))(a1 + 1552) != ELQSSMLIni
    || !*(void *)(a1 + 16))
  {
    return -1;
  }
  uint64_t v3 = 0;
  unsigned int v4 = 1;
  while (LH_stricmp(*(char **)(a1 + 24 * v3 + 24), "metadata"))
  {
    uint64_t v3 = v4;
    if (!*(void *)(a1 + 24 * v4++ + 16)) {
      return -1;
    }
  }
  return *(void *)(a1 + 24 * v3 + 32);
}

uint64_t SSMLPushProsodicParameters(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v2 = XMLGetStack(a1, "volume");
  if (v2)
  {
    uint64_t v3 = v2;
    __sprintf_chk(__src, 0, 0x14uLL, "%d", *(_DWORD *)(a1 + 1560));
    uint64_t result = (uint64_t)ELQMemorySlotSave(*(void *(***)(uint64_t, uint64_t, int))(a1 + 2672), __src, 0);
    if (!result) {
      return result;
    }
    tinystack_Push(v3, result);
  }
  uint64_t v5 = XMLGetStack(a1, "pitch");
  if (v5)
  {
    uint64_t v6 = v5;
    __sprintf_chk(__src, 0, 0x14uLL, "%d", *(_DWORD *)(a1 + 1564));
    uint64_t result = (uint64_t)ELQMemorySlotSave(*(void *(***)(uint64_t, uint64_t, int))(a1 + 2672), __src, 0);
    if (!result) {
      return result;
    }
    tinystack_Push(v6, result);
  }
  uint64_t v7 = XMLGetStack(a1, "timbre");
  if (v7)
  {
    uint64_t v8 = v7;
    __sprintf_chk(__src, 0, 0x14uLL, "%d", *(_DWORD *)(a1 + 2088));
    uint64_t result = (uint64_t)ELQMemorySlotSave(*(void *(***)(uint64_t, uint64_t, int))(a1 + 2672), __src, 0);
    if (!result) {
      return result;
    }
    tinystack_Push(v8, result);
  }
  uint64_t result = XMLGetStack(a1, "speed");
  if (result)
  {
    uint64_t v9 = result;
    __sprintf_chk(__src, 0, 0x14uLL, "%d", *(_DWORD *)(a1 + 1568));
    uint64_t result = (uint64_t)ELQMemorySlotSave(*(void *(***)(uint64_t, uint64_t, int))(a1 + 2672), __src, 0);
    if (result) {
      return tinystack_Push(v9, result);
    }
  }
  return result;
}

uint64_t ParseAttribute(uint64_t a1, char *a2, int a3)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  v26[0] = 0;
  if (!*a2) {
    return 0;
  }
  uint64_t v25 = 0;
  switch(a3)
  {
    case 1:
      if (LH_stricmp(a2, "silent"))
      {
        if (LH_stricmp(a2, "x-soft"))
        {
          if (LH_stricmp(a2, "soft"))
          {
            if (!LH_stricmp(a2, "medium"))
            {
LABEL_10:
              int v5 = 80;
              goto LABEL_83;
            }
            if (LH_stricmp(a2, "loud"))
            {
              if (LH_stricmp(a2, "x-loud"))
              {
                if (LH_stricmp(a2, "default")) {
                  goto LABEL_84;
                }
                goto LABEL_10;
              }
              int v5 = 100;
            }
            else
            {
              int v5 = 90;
            }
          }
          else
          {
            int v5 = 53;
          }
        }
        else
        {
          int v5 = 26;
        }
      }
      else
      {
        int v5 = 0;
      }
LABEL_83:
      *(_DWORD *)(a1 + 1560) = v5;
      __sprintf_chk(v26, 0, 0x200uLL, "\x1B\\vol=%d\\"", v5);
LABEL_84:
      if (!v26[0])
      {
        float v20 = strtod(a2, &v25);
        if (*v25 == 37)
        {
          double v21 = (float)(v20 * (float)*(int *)(a1 + 1560)) / 100.0 + (double)*(int *)(a1 + 1560);
          unsigned int v22 = (int)v21 & ~((int)v21 >> 31);
          if (v22 >= 0x64) {
            unsigned int v22 = 100;
          }
        }
        else
        {
          int v23 = (int)v20;
          if ((int)v20 >= 100) {
            int v23 = 100;
          }
          unsigned int v22 = v23 & ~(v23 >> 31);
        }
        *(_DWORD *)(a1 + 1560) = v22;
        __sprintf_chk(v26, 0, 0x200uLL, "\x1B\\vol=%d\\"");
      }
      goto LABEL_92;
    case 2:
      if (LH_stricmp(a2, "x-fast"))
      {
        if (LH_stricmp(a2, "fast"))
        {
          if (!LH_stricmp(a2, "medium"))
          {
LABEL_17:
            int v6 = 100;
            goto LABEL_46;
          }
          if (LH_stricmp(a2, "slow"))
          {
            if (LH_stricmp(a2, "x-slow"))
            {
              if (LH_stricmp(a2, "default")) {
                goto LABEL_47;
              }
              goto LABEL_17;
            }
            int v6 = 50;
          }
          else
          {
            int v6 = 75;
          }
        }
        else
        {
          int v6 = 150;
        }
      }
      else
      {
        int v6 = 200;
      }
LABEL_46:
      *(_DWORD *)(a1 + 1568) = v6;
      __sprintf_chk(v26, 0, 0x200uLL, "\x1B\\rate=%d\\"", v6);
LABEL_47:
      if (v26[0]) {
        goto LABEL_92;
      }
      float v9 = strtod(a2, &v25);
      if (*v25 == 37)
      {
        double v10 = (float)(v9 * (float)*(int *)(a1 + 1568)) / 100.0 + (double)*(int *)(a1 + 1568);
        int v11 = (int)v10 & ~((int)v10 >> 31);
        if (v11 >= 0xC8) {
          int v11 = 200;
        }
        if (v11 <= 0x32) {
          int v11 = 50;
        }
      }
      else
      {
        if (v9 < 0.0) {
          return 0;
        }
        int v11 = (int)(float)(v9 * (float)*(int *)(a1 + 1568));
        if (v11 >= 200) {
          int v11 = 200;
        }
        if (v11 <= 50) {
          int v11 = 50;
        }
      }
      *(_DWORD *)(a1 + 1568) = v11;
      __sprintf_chk(v26, 0, 0x200uLL, "\x1B\\rate=%d\\"");
      goto LABEL_92;
    case 3:
      if (LH_stricmp(a2, "x-high"))
      {
        if (LH_stricmp(a2, "high"))
        {
          if (!LH_stricmp(a2, "medium"))
          {
LABEL_24:
            int v7 = 100;
            goto LABEL_60;
          }
          if (LH_stricmp(a2, "low"))
          {
            if (LH_stricmp(a2, "x-low"))
            {
              if (LH_stricmp(a2, "default")) {
                goto LABEL_61;
              }
              goto LABEL_24;
            }
            int v7 = 70;
          }
          else
          {
            int v7 = 85;
          }
        }
        else
        {
          int v7 = 135;
        }
      }
      else
      {
        int v7 = 160;
      }
LABEL_60:
      *(_DWORD *)(a1 + 1564) = v7;
      __sprintf_chk(v26, 0, 0x200uLL, "\x1B\\pitch=%d\\"", v7);
LABEL_61:
      if (v26[0]) {
        goto LABEL_92;
      }
      double v12 = strtod(a2, &v25);
      if (*v25 != 37) {
        return 0;
      }
      float v13 = v12;
      double v14 = (float)(v13 * (float)*(int *)(a1 + 1564)) / 100.0 + (double)*(int *)(a1 + 1564);
      unsigned int v15 = (int)v14 & ~((int)v14 >> 31);
      if (v15 >= 0xC8) {
        unsigned int v15 = 200;
      }
      if (v15 <= 0x32) {
        unsigned int v15 = 50;
      }
      *(_DWORD *)(a1 + 1564) = v15;
      __sprintf_chk(v26, 0, 0x200uLL, "\x1B\\pitch=%d\\"");
      goto LABEL_92;
    case 4:
      if (LH_stricmp(a2, "x-young"))
      {
        if (LH_stricmp(a2, "young"))
        {
          if (!LH_stricmp(a2, "medium"))
          {
LABEL_31:
            int v8 = 100;
            goto LABEL_70;
          }
          if (LH_stricmp(a2, "old"))
          {
            if (LH_stricmp(a2, "x-old"))
            {
              if (LH_stricmp(a2, "default")) {
                goto LABEL_71;
              }
              goto LABEL_31;
            }
            int v8 = 65;
          }
          else
          {
            int v8 = 80;
          }
        }
        else
        {
          int v8 = 120;
        }
      }
      else
      {
        int v8 = 135;
      }
LABEL_70:
      *(_DWORD *)(a1 + 2088) = v8;
      __sprintf_chk(v26, 0, 0x200uLL, "\x1B\\timbre=%d\\"", v8);
LABEL_71:
      if (!v26[0])
      {
        float v17 = strtod(a2, &v25);
        if (*v25 == 37)
        {
          double v18 = (float)(v17 * (float)*(int *)(a1 + 2088)) / 100.0 + (double)*(int *)(a1 + 2088);
          int v19 = (int)v18 & ~((int)v18 >> 31);
          if (v19 >= 0xC8) {
            int v19 = 200;
          }
          if (v19 <= 0x32) {
            int v19 = 50;
          }
        }
        else
        {
          int v19 = (int)v17;
          if ((int)v17 >= 200) {
            int v19 = 200;
          }
          if (v19 <= 50) {
            int v19 = 50;
          }
        }
        *(_DWORD *)(a1 + 2088) = v19;
        __sprintf_chk(v26, 0, 0x200uLL, "\x1B\\timbre=%d\\"");
      }
LABEL_92:
      uint64_t v24 = *(void (**)(char *, void))(a1 + 2640);
      if (v24) {
        v24(v26, *(void *)(a1 + 2648));
      }
      uint64_t result = 1;
      break;
    default:
      return 0;
  }
  return result;
}

uint64_t SSMLViewOnLangFailureFromStack(uint64_t a1, _DWORD *a2)
{
  uint64_t v10 = 0;
  uint64_t v4 = XMLGetStack(a1, "onlangfailure");
  if (v4)
  {
    tinystack_View(v4, &v10);
    uint64_t result = 0;
    *a2 = v10;
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v5, v6, v7, v8, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  return result;
}

uint64_t SSMLGetLangFailureCode(char *a1)
{
  uint64_t result = LH_stricmp(a1, "changevoice");
  if (result)
  {
    if (LH_stricmp(a1, "ignoretext"))
    {
      if (LH_stricmp(a1, "ignorelang")) {
        return 3;
      }
      else {
        return 2;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t SSMLPushVoice(uint64_t a1)
{
  uint64_t result = XMLGetStack(a1, "voice");
  if (result)
  {
    uint64_t v3 = result;
    uint64_t result = (uint64_t)ELQMemorySlotSave(*(void *(***)(uint64_t, uint64_t, int))(a1 + 2672), (char *)(a1 + 13000), 0);
    if (result)
    {
      return tinystack_Push(v3, result);
    }
  }
  return result;
}

uint64_t SSMLPushLanguage(uint64_t a1)
{
  uint64_t result = XMLGetStack(a1, "language");
  if (result)
  {
    uint64_t v3 = result;
    uint64_t result = (uint64_t)ELQMemorySlotSave(*(void *(***)(uint64_t, uint64_t, int))(a1 + 2672), (char *)(a1 + 13128), 0);
    if (result)
    {
      return tinystack_Push(v3, result);
    }
  }
  return result;
}

uint64_t SSMLOnLanguageChange(uint64_t result, uint64_t a2, char *a3, int a4, char *a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (a2 | (unint64_t)a3 && a4 != 1)
  {
    uint64_t v8 = result;
    if (a4)
    {
      if (a2) {
        uint64_t v10 = NormalizeLangCode((void *)result, a2);
      }
      else {
        uint64_t v10 = 0;
      }
      aux_SetActiveLanguage(v8, v10, a3);
      uint64_t result = sprintf(a5, "\x1B\\lang=%s\\"", (const char *)(v8 + 13128));
      int v11 = *(uint64_t (**)(char *, uint64_t))(v8 + 2640);
      if (v11)
      {
        uint64_t v12 = *(void *)(v8 + 2648);
        return v11(a5, v12);
      }
    }
    else
    {
      if (a2)
      {
        v13[0] = 40;
        __strcat_chk();
        __strcat_chk();
        __strcat_chk();
        sprintf(a5, "\x1B\\voice=%s\\"", (const char *)v13);
        uint64_t result = aux_SetActiveLanguage(v8, a2, a3);
      }
      float v9 = *(uint64_t (**)(char *, void))(v8 + 2640);
      if (v9) {
        return v9(a5, *(void *)(v8 + 2648));
      }
    }
  }
  return result;
}

uint64_t NewTagBond(uint64_t a1, const char *a2)
{
  uint64_t v4 = *(void *)(a1 + 12992);
  uint64_t v5 = XMLGetStack(a1, "TagBond");
  if (v5)
  {
    uint64_t v10 = v5;
    int v11 = (char *)heap_Alloc(*(void *)(v4 + 8), 32);
    if (v11)
    {
      uint64_t v16 = (uint64_t)v11;
      strcpy(v11, a2);
      if ((tinystack_Push(v10, v16) & 0x80000000) == 0) {
        return 0;
      }
    }
    log_OutPublic(*(void *)(v4 + 32), (uint64_t)"LIGHTSSML", 1923, "%s%s", v12, v13, v14, v15, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934454;
    strcpy((char *)(a1 + 2104), "Out of Memory");
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
  }
  ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
  return *(unsigned int *)(a1 + 2084);
}

uint64_t Emphasis2Prosody(uint64_t a1, char *a2)
{
  SSMLPushProsodicParameters(a1);
  if (a2 && *a2 && LH_stricmp(a2, "moderate"))
  {
    if (LH_stricmp(a2, "strong"))
    {
      if (LH_stricmp(a2, "reduced"))
      {
        LH_stricmp(a2, "none");
        goto LABEL_11;
      }
      float64x2_t v4 = (float64x2_t)vdupq_n_s64(0x4059000000000000uLL);
      int v5 = (int)((float)((float)*(int *)(a1 + 1560) * -10.0) / 100.0 + (double)*(int *)(a1 + 1560));
      uint64_t v6 = (uint32x2_t *)(a1 + 1564);
      int32x2_t v7 = *(int32x2_t *)(a1 + 1564);
      float32x2_t v8 = vcvt_f32_s32(v7);
      float32x2_t v9 = (float32x2_t)0x41200000C1200000;
    }
    else
    {
      float64x2_t v4 = (float64x2_t)vdupq_n_s64(0x4059000000000000uLL);
      int v5 = (int)((float)((float)*(int *)(a1 + 1560) * 20.0) / 100.0 + (double)*(int *)(a1 + 1560));
      uint64_t v6 = (uint32x2_t *)(a1 + 1564);
      int32x2_t v7 = *(int32x2_t *)(a1 + 1564);
      float32x2_t v8 = vcvt_f32_s32(v7);
      float32x2_t v9 = (float32x2_t)0xC1F0000041A00000;
    }
  }
  else
  {
    float64x2_t v4 = (float64x2_t)vdupq_n_s64(0x4059000000000000uLL);
    int v5 = (int)((float)((float)*(int *)(a1 + 1560) * 15.0) / 100.0 + (double)*(int *)(a1 + 1560));
    uint64_t v6 = (uint32x2_t *)(a1 + 1564);
    int32x2_t v7 = *(int32x2_t *)(a1 + 1564);
    float32x2_t v8 = vcvt_f32_s32(v7);
    float32x2_t v9 = (float32x2_t)0xC1A0000041700000;
  }
  float32x2_t v10 = vmul_f32(v8, v9);
  unsigned int v11 = v5 & ~(v5 >> 31);
  if (v11 >= 0x64) {
    unsigned int v11 = 100;
  }
  *(_DWORD *)(a1 + 1560) = v11;
  v12.i64[0] = v7.i32[0];
  v12.i64[1] = v7.i32[1];
  *uint64_t v6 = vmax_u32(vmin_u32((uint32x2_t)vmax_s32(vmovn_s64(vcvtq_s64_f64(vaddq_f64(vdivq_f64(vcvtq_f64_f32(v10), v4), vcvtq_f64_s64(v12)))), 0), (uint32x2_t)0xC8000000C8), (uint32x2_t)0x3200000032);
LABEL_11:
  return OutProsodyTags(a1);
}

uint64_t OutProsodyTags(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  __sprintf_chk(v7, 0, 0x40uLL, "\x1B\\rate=%d\\"", *(_DWORD *)(a1 + 1568));
  uint64_t v2 = *(void (**)(char *, void))(a1 + 2640);
  if (v2) {
    v2(v7, *(void *)(a1 + 2648));
  }
  __sprintf_chk(v7, 0, 0x40uLL, "\x1B\\pitch=%d\\"", *(_DWORD *)(a1 + 1564));
  uint64_t v3 = *(void (**)(char *, void))(a1 + 2640);
  if (v3) {
    v3(v7, *(void *)(a1 + 2648));
  }
  __sprintf_chk(v7, 0, 0x40uLL, "\x1B\\timbre=%d\\"", *(_DWORD *)(a1 + 2088));
  float64x2_t v4 = *(void (**)(char *, void))(a1 + 2640);
  if (v4) {
    v4(v7, *(void *)(a1 + 2648));
  }
  uint64_t result = __sprintf_chk(v7, 0, 0x40uLL, "\x1B\\vol=%d\\"", *(_DWORD *)(a1 + 1560));
  uint64_t v6 = *(uint64_t (**)(char *, void))(a1 + 2640);
  if (v6) {
    return v6(v7, *(void *)(a1 + 2648));
  }
  return result;
}

uint64_t ApplyCurrentStyle(uint64_t a1, char *a2)
{
  sprintf(a2, "\x1B\\style=%s\\"", (const char *)(a1 + 1572));
  float64x2_t v4 = *(void (**)(char *, void))(a1 + 2640);
  if (v4 && *a2)
  {
    v4(a2, *(void *)(a1 + 2648));
    return 0;
  }
  else
  {
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
}

char *determineMediaType(char *__s)
{
  if (__s)
  {
    uint64_t v1 = __s;
    uint64_t v2 = 0;
    while (1)
    {
      uint64_t v3 = ExtensionMimeTypeMap[2 * v2];
      if (v3)
      {
        size_t v4 = strlen(v1);
        size_t v5 = strlen(v3);
        uint64_t v6 = &v1[v4 - v5];
        if (v5 <= v4 && v6 >= v1) {
          break;
        }
      }
LABEL_12:
      if (++v2 == 8) {
        return 0;
      }
    }
    size_t v8 = v5;
    while (strncmp(v6, v3, v8))
    {
      if (--v6 < v1) {
        goto LABEL_12;
      }
    }
    return ExtensionMimeTypeMap[2 * v2 + 1];
  }
  return __s;
}

uint64_t SSML10EndConvert(uint64_t a1, char *a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  if (!SSMLstricmpElement(a1, a2, "prosody")) {
    goto LABEL_18;
  }
  if (!SSMLstricmpElement(a1, a2, "p"))
  {
    uint64_t v5 = a1;
    int v6 = 1;
    return SSMLElement_Block_Exit(v5, v18, v6);
  }
  if (!SSMLstricmpElement(a1, a2, "s"))
  {
    uint64_t v5 = a1;
    int v6 = 0;
    return SSMLElement_Block_Exit(v5, v18, v6);
  }
  if (!SSMLstricmpElement(a1, a2, "lang"))
  {
    uint64_t v5 = a1;
    int v6 = 2;
    return SSMLElement_Block_Exit(v5, v18, v6);
  }
  if (!SSMLstricmpElement(a1, a2, "emphasis"))
  {
LABEL_18:
    SSMLPopProsodicParameters((_DWORD *)a1);
    return 0;
  }
  if (!SSMLstricmpElement(a1, a2, "break")) {
    return 0;
  }
  if (!SSMLstricmpElement(a1, a2, "phoneme"))
  {
    uint64_t v4 = 2375032842;
    uint64_t v9 = *(void *)(a1 + 12992);
    uint64_t v11 = *(void *)(v9 + 8);
    float32x2_t v10 = (uint64_t **)(v9 + 8);
    int64x2_t v12 = (void *)heap_Alloc(v11, 24);
    if (v12)
    {
      uint64_t v13 = v12;
      *int64x2_t v12 = v10;
      v12[1] = 0;
      v12[2] = 0;
      uint64_t v14 = strhelper_StringAppend(*v10, 0, *(char **)(*(void *)(a1 + 13264) + 8), 0xFFFFFFFFFFFFFFFFLL, v12 + 2, 0x80uLL);
      v13[1] = v14;
      if (v14)
      {
        uint64_t v15 = SSMLElement_PHONEME_Exit(a1, v14);
        DynStringDestroy((void **)v13);
        return v15;
      }
    }
    return v4;
  }
  if (SSMLstricmpElement(a1, a2, "sub"))
  {
    if (!SSMLstricmpElement(a1, a2, "say-as")) {
      return SSMLElement_SAYAS_Exit(a1, v18);
    }
    if (!SSMLstricmpElement(a1, a2, "voice"))
    {
      SSMLElement_VOICE_Exit(a1, v18);
      return 0;
    }
    if (!SSMLstricmpElement(a1, a2, "speak")) {
      return SSMLElement_SPEAK_Exit(a1, v18);
    }
    if (SSMLstricmpElement(a1, a2, "audio"))
    {
      if (SSMLstricmpElement(a1, a2, "style"))
      {
        if (!SSMLstricmpElement(a1, a2, "desc"))
        {
          uint64_t v16 = *(void (**)(char *, void))(a1 + 2640);
          if (v16) {
            v16(v18, *(void *)(a1 + 2648));
          }
          return 0;
        }
        if (SSMLstricmpElement(a1, a2, "meta"))
        {
          if (SSMLstricmpElement(a1, a2, "metadata"))
          {
            SSMLstricmpElement(a1, a2, "lexicon");
            return 0;
          }
          uint64_t v17 = a1;
        }
        else
        {
          uint64_t v17 = a1;
        }
        return SSMLElement_META_Exit(v17);
      }
      return SSMLElement_STYLE_Exit(a1, v18);
    }
    return SSMLElement_AUDIO_Exit(a1);
  }
  else
  {
    return SSMLElement_SUB_Exit(a1);
  }
}

uint64_t SSMLElement_Block_Exit(uint64_t a1, char *a2, int a3)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  int v17 = *(_DWORD *)(a1 + 2716);
  int v6 = (unsigned char *)(a1 + 13196);
  if (*(unsigned char *)(a1 + 13196))
  {
    strcpy(a2, "\x1B\\domain\\"");
    int32x2_t v7 = *(void (**)(char *, void))(a1 + 2640);
    if (v7) {
      v7(a2, *(void *)(a1 + 2648));
    }
    *int v6 = 0;
  }
  uint64_t v8 = SSMLViewOnLangFailureFromStack(a1, &v17);
  if (!v8)
  {
    int v9 = v17;
    if (v17 == 4) {
      int v9 = *(_DWORD *)(a1 + 2716);
    }
    if (a3 == 1)
    {
      a2[8] = 0;
      float32x2_t v10 = "\n\x1B\\para\\"";
    }
    else
    {
      if (a3)
      {
LABEL_14:
        if (!v9)
        {
          uint64_t v15 = XMLGetStack(a1, "voice");
          if (v15)
          {
            double v18 = 0;
            tinystack_Pop(v15, &v18);
            if (v18)
            {
              __strcpy_chk();
              __sprintf_chk(v19, 0, 0x50uLL, "\x1B\\voice=%s\\"", v18);
              uint64_t v16 = *(void (**)(char *, void))(a1 + 2640);
              if (v16) {
                v16(v19, *(void *)(a1 + 2648));
              }
            }
          }
        }
        uint64_t v12 = XMLGetStack(a1, "language");
        if (v12)
        {
          double v18 = 0;
          tinystack_Pop(v12, &v18);
          if (v18)
          {
            __strcpy_chk();
            __sprintf_chk(v19, 0, 0x50uLL, "\x1B\\lang=%s\\"", v18);
            uint64_t v13 = *(void (**)(char *, void))(a1 + 2640);
            if (v13) {
              v13(v19, *(void *)(a1 + 2648));
            }
          }
        }
        uint64_t v8 = SSMLRemoveOnLangFailureFromStack(a1);
        ReleaseTagBond(a1);
        return v8;
      }
      a2[8] = 0;
      float32x2_t v10 = "\x1B\\eos=1\\"";
    }
    *(void *)a2 = *(void *)v10;
    uint64_t v11 = *(void (**)(char *, void))(a1 + 2640);
    if (v11) {
      v11(a2, *(void *)(a1 + 2648));
    }
    goto LABEL_14;
  }
  return v8;
}

uint64_t SSMLElement_PHONEME_Exit(uint64_t a1, char *a2)
{
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v4 = XMLGetStack(a1, "auxiliary");
  if (!v4) {
    goto LABEL_31;
  }
  tinystack_Pop(v4, &v31);
  if ((v31 & 8) != 0)
  {
    uint64_t v11 = XMLGetStack(a1, "phon");
    if (v11)
    {
      tinystack_Pop(v11, &v30);
      BOOL v10 = (v30 & 0xE0) == 0;
      int v9 = v30 & 1;
      goto LABEL_6;
    }
LABEL_31:
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v5, v6, v7, v8, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  int v9 = 0;
  BOOL v10 = 1;
LABEL_6:
  uint64_t v12 = *(void *)(a1 + 13272);
  uint64_t v13 = *(char **)(v12 + 8);
  if (!v13) {
    goto LABEL_20;
  }
  int v14 = strncmp(*(const char **)(v12 + 8), ":\"", 2uLL);
  if (!v14)
  {
    uint64_t v13 = strhelper_StringAppend(**(uint64_t ***)v12, v13, "\"", 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v12 + 16), 0x80uLL);
    *(void *)(v12 + 8) = v13;
    if (!v13) {
      goto LABEL_20;
    }
  }
  if (v10 && *v13)
  {
    if (v9)
    {
      if (!v14)
      {
        char v15 = v13[1];
        if (v15)
        {
          uint64_t v16 = (unsigned __int8 *)(v13 + 2);
          do
          {
            if (memchr(".:,;?!()", v15, 9uLL)) {
              *(v16 - 1) = 32;
            }
            int v17 = *v16++;
            char v15 = v17;
          }
          while (v17);
        }
      }
    }
    (*(void (**)(char *, void))(a1 + 2640))(v13, *(void *)(a1 + 2648));
  }
  if (!v14)
  {
LABEL_20:
    *(_WORD *)a2 = 92;
    double v18 = *(const char **)(*(void *)(a1 + 13264) + 8);
    if (v18) {
      strcat(a2, v18);
    }
    uint64_t v19 = *(void (**)(char *, void))(a1 + 2640);
    if (v19) {
      v19(a2, *(void *)(a1 + 2648));
    }
    strcpy(a2, "\x1B\\toi=orth\\"");
    uint64_t v20 = *(void (**)(char *, void))(a1 + 2640);
    if (v20) {
      v20(a2, *(void *)(a1 + 2648));
    }
  }
  uint64_t v21 = *(void *)(a1 + 13264);
  uint64_t v24 = *(void *)(v21 + 8);
  int v23 = (void *)(v21 + 8);
  uint64_t v22 = v24;
  if (v24) {
    heap_Free(***(void ****)(a1 + 13264), v22);
  }
  *int v23 = 0;
  v23[1] = 0;
  uint64_t v25 = *(void *)(a1 + 13272);
  uint64_t v28 = *(void *)(v25 + 8);
  uint64_t v27 = (void *)(v25 + 8);
  uint64_t v26 = v28;
  if (v28) {
    heap_Free(***(void ****)(a1 + 13272), v26);
  }
  *uint64_t v27 = 0;
  v27[1] = 0;
  ReleaseTagBond(a1);
  return 0;
}

uint64_t SSMLElement_SUB_Exit(uint64_t a1)
{
  uint64_t v8 = 0;
  ReleaseTagBond(a1);
  uint64_t v2 = XMLGetStack(a1, "auxiliary");
  if (v2)
  {
    tinystack_Pop(v2, &v8);
    return 0;
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v3, v4, v5, v6, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
}

uint64_t SSMLElement_SAYAS_Exit(uint64_t a1, char *a2)
{
  uint64_t v4 = (unsigned char *)(a1 + 13164);
  *(unsigned char *)(a1 + 13280) = 0;
  *(_DWORD *)(a1 + 13312) = 0;
  uint64_t v5 = XMLGetStack(a1, "say-as");
  if (!v5)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v6, v7, v8, v9, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
  uint64_t v13 = 0;
  int v10 = *v4;
  tinystack_Pop(v5, &v13);
  if (v13)
  {
    __strcpy_chk();
    if (*v4 == 95) {
      ++v13;
    }
    if (v10 != 95)
    {
      sprintf(a2, "\x1B\\tn=%s\\"", v13);
      goto LABEL_10;
    }
LABEL_9:
    strcpy(a2, "\x1B\\slotend\\"");
LABEL_10:
    uint64_t v12 = *(void (**)(char *, void))(a1 + 2640);
    if (v12) {
      v12(a2, *(void *)(a1 + 2648));
    }
    goto LABEL_12;
  }
  if (v10 == 95) {
    goto LABEL_9;
  }
LABEL_12:
  ReleaseTagBond(a1);
  return 0;
}

uint64_t SSMLElement_VOICE_Exit(uint64_t a1, char *a2)
{
  uint64_t result = sprintf(a2, "\x1B\\voice=%s\\", "(pop)"");
  uint64_t v5 = *(uint64_t (**)(char *, uint64_t))(a1 + 2640);
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 2648);
    return v5(a2, v6);
  }
  return result;
}

uint64_t SSMLElement_SPEAK_Exit(uint64_t a1, char *a2)
{
  uint64_t v8 = SSMLRemoveOnLangFailureFromStack(a1);
  if (v8)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1297, "%s%s", v4, v5, v6, v7, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = v8;
    strcpy((char *)(a1 + 2104), "Error retrieving OnLangFailure attribute");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
  }
  else
  {
    if (*(unsigned char *)(a1 + 13228))
    {
      strcpy(a2, "\x1B\\domain\\"");
      uint64_t v9 = *(void (**)(char *, void))(a1 + 2640);
      if (v9) {
        v9(a2, *(void *)(a1 + 2648));
      }
      *(unsigned char *)(a1 + 13228) = 0;
    }
    uint64_t v10 = *(void *)(a1 + 13320);
    if (v10)
    {
      heap_Free(*(void **)(*(void *)(a1 + 12992) + 8), v10);
      *(void *)(a1 + 13320) = 0;
    }
  }
  return v8;
}

uint64_t SSMLElement_AUDIO_Exit(uint64_t a1)
{
  uint64_t v15 = 0;
  uint64_t v2 = XMLGetStack(a1, "audio");
  if (v2 && (tinystack_Pop(v2, &v15), (uint64_t v7 = XMLGetStack(a1, "auxiliary")) != 0))
  {
    tinystack_Pop(v7, &v15);
    uint64_t v8 = *(void *)(a1 + 13272);
    uint64_t v9 = *(char **)(v8 + 8);
    if (v9)
    {
      *(void *)(v8 + 8) = strhelper_StringAppend(**(uint64_t ***)v8, v9, "\"", 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v8 + 16), 0x80uLL);
      uint64_t v8 = *(void *)(a1 + 13272);
      uint64_t v9 = *(char **)(v8 + 8);
    }
    *(void *)(v8 + 8) = strhelper_StringAppend(**(uint64_t ***)v8, v9, "\\"", 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v8 + 16), 0x80uLL);
    (*(void (**)(void, void))(a1 + 2640))(*(void *)(*(void *)(a1 + 13272) + 8), *(void *)(a1 + 2648));
    uint64_t v10 = *(void *)(a1 + 13272);
    uint64_t v13 = *(void *)(v10 + 8);
    uint64_t v12 = (void *)(v10 + 8);
    uint64_t v11 = v13;
    if (v13) {
      heap_Free(***(void ****)(a1 + 13272), v11);
    }
    *uint64_t v12 = 0;
    v12[1] = 0;
    ReleaseTagBond(a1);
    return 0;
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v3, v4, v5, v6, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
}

uint64_t SSMLElement_STYLE_Exit(uint64_t a1, char *a2)
{
  __src = 0;
  uint64_t v4 = XMLGetStack(a1, "style");
  if (v4)
  {
    if ((tinystack_Pop(v4, &__src) & 0x80000000) == 0)
    {
      strncpy((char *)(a1 + 1572), __src, 0x200uLL);
      *(unsigned char *)(a1 + 2083) = 0;
      return ApplyCurrentStyle(a1, a2);
    }
    *(_DWORD *)(a1 + 2084) = -1919934460;
    strcpy((char *)(a1 + 2104), "Out of Memory");
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v5, v6, v7, v8, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
  }
  ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
  return *(unsigned int *)(a1 + 2084);
}

uint64_t SSMLElement_META_Exit(uint64_t a1)
{
  uint64_t v8 = 0;
  uint64_t v2 = XMLGetStack(a1, "metadata");
  if (v2)
  {
    tinystack_Pop(v2, &v8);
    return 0;
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v3, v4, v5, v6, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
}

uint64_t SSMLPopProsodicParameters(_DWORD *a1)
{
  uint64_t v7 = 0;
  uint64_t v2 = XMLGetStack((uint64_t)a1, "volume");
  if (v2)
  {
    tinystack_Pop(v2, &v7);
    if (v7) {
      a1[390] = atoi(v7);
    }
  }
  uint64_t v3 = XMLGetStack((uint64_t)a1, "speed");
  if (v3)
  {
    tinystack_Pop(v3, &v7);
    if (v7) {
      a1[392] = atoi(v7);
    }
  }
  uint64_t v4 = XMLGetStack((uint64_t)a1, "pitch");
  if (v4)
  {
    tinystack_Pop(v4, &v7);
    if (v7) {
      a1[391] = atoi(v7);
    }
  }
  uint64_t v5 = XMLGetStack((uint64_t)a1, "timbre");
  if (v5)
  {
    tinystack_Pop(v5, &v7);
    if (v7) {
      a1[522] = atoi(v7);
    }
  }
  return OutProsodyTags((uint64_t)a1);
}

uint64_t SSMLRemoveOnLangFailureFromStack(uint64_t a1)
{
  uint64_t v8 = 0;
  uint64_t v2 = XMLGetStack(a1, "onLangFailure");
  if (v2)
  {
    tinystack_Pop(v2, &v8);
    return 0;
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 12992) + 32), (uint64_t)"LIGHTSSML", 1412, "%s%s", v3, v4, v5, v6, "SSML parser error");
    *(_DWORD *)(a1 + 2084) = -1919934462;
    strcpy((char *)(a1 + 2104), "SSML Stack unavailable");
    ELQXMLGetCurrentLineNumber(*(void *)(a1 + 2624));
    return *(unsigned int *)(a1 + 2084);
  }
}

char *SSMLFallbackStringHandler(char *result, unsigned char *a2, uint64_t a3)
{
  uint64_t v3 = a3;
  uint64_t v5 = result;
  v10[1] = 0;
  uint64_t v6 = *((void *)result + 1659);
  if (*(void *)(v6 + 8))
  {
    if (!a3) {
      return result;
    }
  }
  else
  {
    uint64_t result = strhelper_StringAppend(**(uint64_t ***)v6, 0, ":\"", 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v6 + 16), 0x80uLL);
    *(void *)(v6 + 8) = result;
    if (!v3) {
      return result;
    }
  }
  do
  {
    int v7 = *a2;
    if (v7 == 92 || v7 == 34)
    {
      v10[0] = 92;
      uint64_t v8 = *((void *)v5 + 1659);
      *(void *)(v8 + 8) = strhelper_StringAppend(**(uint64_t ***)v8, *(char **)(v8 + 8), v10, 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v8 + 16), 0x80uLL);
      LOBYTE(v7) = *a2;
    }
    v10[0] = v7;
    uint64_t v9 = *((void *)v5 + 1659);
    uint64_t result = strhelper_StringAppend(**(uint64_t ***)v9, *(char **)(v9 + 8), v10, 0xFFFFFFFFFFFFFFFFLL, (uint64_t *)(v9 + 16), 0x80uLL);
    *(void *)(v9 + 8) = result;
    ++a2;
    --v3;
  }
  while (v3);
  return result;
}

uint64_t ExtractDate(char *__s, char *a2, unint64_t *a3, unint64_t *a4, unint64_t *a5, uint64_t a6, unsigned char *a7, unint64_t a8)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  uint64_t v32 = 0;
  if (!a6)
  {
    if (!a3) {
      return 0;
    }
    *a3 = 0;
    if (!a4) {
      return 0;
    }
    *a4 = 0;
    if (!a5) {
      return 0;
    }
    *a5 = 9999;
    if (strlen(a2) > 0xC) {
      return 0;
    }
    strncpy(__dst, a2, 0xBuLL);
    __dst[11] = 0;
    if (!LH_stricmp(__s, "mdy"))
    {
      double v18 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
      if (v18)
      {
        *a4 = (int)LH_atoi(v18);
        *a7 = a2[v32 - 1];
      }
      uint64_t v19 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
      if (v19 && a2[v32 - 1] == *a7) {
        *a3 = (int)LH_atoi(v19);
      }
      goto LABEL_43;
    }
    if (LH_stricmp(__s, "dmy"))
    {
      if (!LH_stricmp(__s, "ymd"))
      {
        uint64_t v24 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
        if (v24)
        {
          *a5 = (int)LH_atoi(v24);
          *a7 = a2[v32 - 1];
        }
        uint64_t v25 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
        if (!v25 || a2[v32 - 1] != *a7) {
          goto LABEL_63;
        }
        goto LABEL_49;
      }
      if (!LH_stricmp(__s, "ydm"))
      {
        uint64_t v26 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
        if (v26)
        {
          *a5 = (int)LH_atoi(v26);
          *a7 = a2[v32 - 1];
        }
        uint64_t v27 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
        if (v27) {
          *a3 = (int)LH_atoi(v27);
        }
        uint64_t v22 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
        if (!v22) {
          goto LABEL_65;
        }
        int v28 = *a7;
        int v23 = a4;
        if (a2[v32 - 1] != v28) {
          goto LABEL_65;
        }
        goto LABEL_64;
      }
      if (!LH_stricmp(__s, "ym"))
      {
        uint64_t v29 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
        if (v29) {
          *a5 = (int)LH_atoi(v29);
        }
        goto LABEL_59;
      }
      if (!LH_stricmp(__s, "yd"))
      {
        uint64_t v30 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
        if (v30) {
          *a5 = (int)LH_atoi(v30);
        }
        goto LABEL_63;
      }
      if (LH_stricmp(__s, "my"))
      {
        if (LH_stricmp(__s, "md"))
        {
          if (!LH_stricmp(__s, "dm"))
          {
            *a5 = 0;
            uint64_t v31 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
            if (v31) {
              *a3 = (int)LH_atoi(v31);
            }
            goto LABEL_59;
          }
          if (LH_stricmp(__s, "y"))
          {
            if (LH_stricmp(__s, "m"))
            {
              if (LH_stricmp(__s, "d")) {
                return 0;
              }
              *a5 = 0;
LABEL_63:
              uint64_t v22 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
              int v23 = a3;
              if (!v22)
              {
LABEL_65:
                if (*a4 - 13 <= 0xFFFFFFFFFFFFFFF3 && strchr(__s, 109)
                  || *a3 - 32 <= 0xFFFFFFFFFFFFFFE0 && strchr(__s, 100)
                  || *a5 > 0x834)
                {
                  return 0;
                }
                return a2[v32] == 0;
              }
LABEL_64:
              *int v23 = (int)LH_atoi(v22);
              goto LABEL_65;
            }
            *a5 = 0;
LABEL_59:
            uint64_t v22 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
            int v23 = a4;
            if (!v22) {
              goto LABEL_65;
            }
            goto LABEL_64;
          }
LABEL_43:
          uint64_t v22 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
          int v23 = a5;
          if (!v22) {
            goto LABEL_65;
          }
          goto LABEL_64;
        }
        *a5 = 0;
        uint64_t v25 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
        if (!v25) {
          goto LABEL_63;
        }
LABEL_49:
        *a4 = (int)LH_atoi(v25);
        goto LABEL_63;
      }
      uint64_t v21 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
      if (!v21) {
        goto LABEL_43;
      }
    }
    else
    {
      uint64_t v20 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
      if (v20)
      {
        *a3 = (int)LH_atoi(v20);
        *a7 = a2[v32 - 1];
      }
      uint64_t v21 = strhelper_SafeStrtok((uint64_t)__dst, "-/.", &v32);
      if (!v21 || a2[v32 - 1] != *a7) {
        goto LABEL_43;
      }
    }
    *a4 = (int)LH_atoi(v21);
    goto LABEL_43;
  }
  unint64_t v12 = *a5;
  if (*a5 < a8 || v12 > 0x63)
  {
    if (v12 <= 0x63F && strchr(__s, 121)) {
      return 0;
    }
  }
  else
  {
    uint64_t v13 = 1900;
    if (v12 < 0x14) {
      uint64_t v13 = 2000;
    }
    *a5 = v13 + v12;
  }
  if (*a3 < 0x1E) {
    return 1;
  }
  unint64_t v16 = *a4;
  if (*a4 == 2) {
    return 0;
  }
  if (*a3 == 31 && v16 - 4 <= 7) {
    return dword_20D6B220C[v16 - 4];
  }
  else {
    return 1;
  }
}

uint64_t lightssml_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2375032833;
  }
  uint64_t result = 0;
  *a2 = &IlightssmlCtrl;
  return result;
}

uint64_t lightssml_ClassOpen(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t v23 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v23);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t v5 = 2375032840;
  uint64_t v6 = (void *)heap_Calloc(*(void **)(v23 + 8), 1, 40);
  if (!v6) {
    return 2375032842;
  }
  uint64_t v7 = (uint64_t)v6;
  uint64_t v8 = *(void *)(v23 + 8);
  v6[4] = 0;
  v6[1] = 0;
  uint64_t v9 = v6 + 1;
  *uint64_t v6 = 0;
  uint64_t v10 = v23;
  v6[2] = v8;
  v6[3] = v10;
  int v11 = critsec_ObjOpen(*(void *)(v10 + 16), *(void **)(v10 + 8), v6 + 4);
  uint64_t v16 = v23;
  if (v11 < 0
    || (int v17 = ELQXMLIniController(v23, (uint64_t)"LTTS7XML", (uint64_t)"./", *(void *)(v7 + 32)),
        *(void *)uint64_t v7 = v17,
        uint64_t v16 = v23,
        !v17))
  {
    uint64_t v19 = 1664;
  }
  else
  {
    uint64_t v18 = VoiceInfoIni(v9, v23);
    if ((v18 & 0x80000000) == 0)
    {
      uint64_t v5 = v18;
      *(void *)a3 = v7;
      *(_DWORD *)(a3 + 8) = 47834;
      return v5;
    }
    uint64_t v5 = 2375040626;
    uint64_t v19 = 1455;
    uint64_t v16 = v23;
  }
  log_OutPublic(*(void *)(v16 + 32), (uint64_t)"LIGHTSSML", v19, 0, v12, v13, v14, v15, v22);
  VoiceInfoDelete(*(uint64_t (***)())(v7 + 8));
  ELQXMLDeleteController(*(void **)v7);
  uint64_t v20 = *(void *)(v7 + 32);
  if (v20) {
    critsec_ObjClose(v20);
  }
  heap_Free(*(void **)(v23 + 8), v7);
  return v5;
}

uint64_t lightssml_ClassClose(uint64_t a1, int a2)
{
  uint64_t v3 = safeh_HandleCheck(a1, a2, 47834, 40);
  if ((v3 & 0x80000000) == 0)
  {
    if (a1)
    {
      VoiceInfoDelete(*(uint64_t (***)())(a1 + 8));
      ELQXMLDeleteController(*(void **)a1);
      uint64_t v4 = *(void *)(a1 + 32);
      if (v4) {
        critsec_ObjClose(v4);
      }
      heap_Free(*(void **)(a1 + 16), a1);
    }
    else
    {
      return 2375032840;
    }
  }
  return v3;
}

uint64_t lightssml_ObjOpen(void *a1, int a2, _WORD *a3, int a4, uint64_t a5)
{
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  uint64_t v5 = 2375032840;
  if (!a5) {
    return 2375032839;
  }
  *(void *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  uint64_t inited = InitRsrcFunction(a3, a4, &v39);
  if ((inited & 0x80000000) == 0)
  {
    log_OutText(*(void *)(v39 + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Entering lightssml_ObjOpen", v10, v11, v12, v38);
    uint64_t v13 = safeh_HandleCheck((uint64_t)a1, a2, 47834, 40);
    if ((v13 & 0x80000000) != 0)
    {
      uint64_t v35 = v13;
      log_OutPublic(*(void *)(v39 + 32), (uint64_t)"LIGHTSSML", 1152, 0, v14, v15, v16, v17, v38);
      uint64_t v5 = v35;
    }
    else if (a1)
    {
      uint64_t v18 = heap_Calloc(*(void **)(v39 + 8), 1, 128);
      if (v18)
      {
        uint64_t v22 = v18;
        *(void *)a5 = v18;
        *(_DWORD *)(a5 + 8) = 435;
        if ((objc_GetObject(*(void *)(v39 + 48), (uint64_t)"LANGCODECONVERTER", &v38) & 0x80000000) == 0)
        {
          uint64_t v23 = v38;
          if (*(unsigned char *)v38 != 1 || (uint64_t v24 = *(void *)(v38 + 8)) == 0)
          {
            objc_ReleaseObject(*(void *)(v39 + 48), (uint64_t)"LANGCODECONVERTER");
            uint64_t v31 = v39;
            uint64_t v5 = 2375032845;
            uint64_t v34 = 2574;
LABEL_24:
            log_OutPublic(*(void *)(v31 + 32), (uint64_t)"LIGHTSSML", v34, 0, v26, v27, v28, v29, v38);
            lightssml_ObjClose(*(void *)a5, *(void *)(a5 + 8));
            *(void *)a5 = 0;
            *(_DWORD *)(a5 + 8) = 0;
            goto LABEL_25;
          }
          *(void *)(v22 + 32) = v24;
          *(_OWORD *)(v22 + 40) = *(_OWORD *)(v23 + 16);
        }
        uint64_t Object = objc_GetObject(*(void *)(v39 + 48), (uint64_t)"SYNTHSTREAM", &v38);
        if ((Object & 0x80000000) != 0)
        {
          uint64_t v36 = Object;
          uint64_t v34 = 1154;
          uint64_t v31 = v39;
          uint64_t v5 = v36;
        }
        else
        {
          *(void *)(v22 + 56) = 0;
          *(void *)(v22 + 64) = 0;
          *(void *)(v22 + 72) = 0;
          *(void *)(v22 + 16) = v39;
          *(_DWORD *)(v22 + 80) = 65001;
          *(void *)(v22 + 24) = *(void *)(v38 + 8);
          *(_DWORD *)uint64_t v22 = 0;
          *(void *)(v22 + 8) = a1;
          uint64_t v30 = ELQXMLIniParser(*a1, 0);
          *(void *)(v22 + 64) = v30;
          uint64_t v31 = v39;
          if (v30)
          {
            uint64_t v32 = ELQMemorySlotInit(v39, 1024, 0);
            *(void *)(v22 + 72) = v32;
            uint64_t v31 = v39;
            if (v32)
            {
              int v33 = ELQSSMLIni(v39, (uint64_t *)(v22 + 56), *(void *)(v22 + 64), 0);
              if (!v33)
              {
                ELQSSMLSetMemorySlot(*(void *)(v22 + 56), *(void *)(v22 + 72));
                ELQSSMLSetVoiceInfo(*(void *)(v22 + 56), *(void *)(*(void *)(v22 + 8) + 8));
                ELQSSMLSetLangCodeConverter(*(void *)(v22 + 56), *(void *)(v22 + 32), *(void *)(v22 + 40), *(void *)(v22 + 48));
                uint64_t v5 = 0;
                *(_DWORD *)uint64_t v22 = 1;
                goto LABEL_25;
              }
              uint64_t v5 = v33 | 0x8D902000;
              uint64_t v34 = 1664;
              uint64_t v31 = v39;
            }
            else
            {
              uint64_t v5 = 2375033096;
              uint64_t v34 = 1923;
            }
          }
          else
          {
            uint64_t v34 = 1459;
          }
        }
        goto LABEL_24;
      }
      uint64_t v5 = 2375032842;
    }
    else
    {
      log_OutPublic(*(void *)(v39 + 32), (uint64_t)"LIGHTSSML", 1153, 0, v14, v15, v16, v17, v38);
    }
LABEL_25:
    log_OutText(*(void *)(v39 + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Exiting lightssml_ObjOpen", v19, v20, v21, v38);
    return v5;
  }
  return inited;
}

uint64_t lightssml_ObjClose(uint64_t a1, int a2)
{
  uint64_t v3 = safeh_HandleCheck(a1, a2, 435, 128);
  uint64_t v7 = 2375032840;
  if ((v3 & 0x80000000) == 0 && a1)
  {
    uint64_t v8 = v3;
    log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Entering lightssml_ObjClose", v4, v5, v6, v15);
    ELQSSMLDelete(*(void **)(a1 + 56));
    ELQXMLDeleteParser(*(void **)(a1 + 64));
    ELQMemorySlotDelete(*(void **)(a1 + 72));
    if (*(void *)(a1 + 24)) {
      objc_ReleaseObject(*(void *)(*(void *)(a1 + 16) + 48), (uint64_t)"SYNTHSTREAM");
    }
    if (*(void *)(a1 + 32)) {
      uint64_t v7 = objc_ReleaseObject(*(void *)(*(void *)(a1 + 16) + 48), (uint64_t)"LANGCODECONVERTER");
    }
    else {
      uint64_t v7 = v8;
    }
    *(_DWORD *)a1 = 0;
    uint64_t v9 = *(void *)(a1 + 16);
    uint64_t v10 = *(void *)(v9 + 32);
    heap_Free(*(void **)(v9 + 8), a1);
    log_OutText(v10, (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Exiting lightssml_ObjClose", v11, v12, v13, v16);
  }
  return v7;
}

uint64_t lightssml_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = 2375032840;
  if ((safeh_HandleCheck(a1, a2, 435, 128) & 0x80000000) == 0)
  {
    log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Entering lightssml_ProcessStart", v8, v9, v10, v27);
    if (*(_DWORD *)a1 == 1)
    {
      uint64_t v15 = 0;
      *(_DWORD *)a1 = 3;
      *(_OWORD *)(a1 + 88) = 0u;
      *(_OWORD *)(a1 + 104) = 0u;
      *(void *)(a1 + 120) = 0;
      *(void *)(a1 + 88) = *(void *)(a1 + 24);
      do
      {
        int v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, char *, void, void, uint64_t))(*(void *)(a1 + 24) + 64))(a3, a4, 217, lightssml_ProcessStart_szSSML_INPUT_NAMES[v15], 0, 0, a1 + 96);
        if ((v16 & 0x80000000) == 0) {
          break;
        }
      }
      while (v15++ != 3);
      uint64_t v21 = *(void *)(a1 + 16);
      if (v16 < 0)
      {
        log_OutText(*(void *)(v21 + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Exiting lightssml_ProcessStart: no SSML to process", v17, v18, v19, v28);
        paramc_ParamSetStr(*(void *)(*(void *)(a1 + 16) + 40), (uint64_t)"rulesetsfrommarkup", "0");
        return 0;
      }
      else
      {
        paramc_ParamSetStr(*(void *)(v21 + 40), (uint64_t)"rulesetsfrommarkup", "1");
        uint64_t v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, const char *, void, uint64_t, uint64_t))(*(void *)(a1 + 24) + 64))(a3, a4, 217, "text/plain;charset=utf-8",
                0,
                1,
                a1 + 112);
        if ((v22 & 0x80000000) != 0)
        {
          return v22;
        }
        else
        {
          uint64_t v7 = ELQSSMLSetOutputFunction(*(void *)(a1 + 56), (uint64_t)StringBuffer_Output, a1);
          if ((v7 & 0x80000000) == 0) {
            log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Exiting lightssml_ProcessStart", v23, v24, v25, v28);
          }
        }
      }
    }
    else
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 1156, 0, v11, v12, v13, v14, v28);
      return 2375032849;
    }
  }
  return v7;
}

uint64_t lightssml_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  unsigned int v44 = 0;
  strcpy(__s, "<speak>");
  strcpy(v46, "</speak>");
  unsigned int v42 = 0;
  uint64_t v7 = safeh_HandleCheck(a1, a2, 435, 128);
  if ((v7 & 0x80000000) != 0) {
    return 2375032840;
  }
  uint64_t v11 = v7;
  uint64_t v45 = 0;
  long long v43 = 0;
  log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Entering lightssml_Process", v8, v9, v10, v39);
  if ((*(_DWORD *)a1 & 0xFFFFFFFE) != 2)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 1156, 0, v12, v13, v14, v15, v40);
    uint64_t v11 = 2375032849;
    goto LABEL_14;
  }
  *a5 = 2;
  if (!*(void *)(a1 + 96) || !*(void *)(a1 + 112))
  {
    *a5 = 1;
    goto LABEL_16;
  }
  uint64_t v16 = (*(uint64_t (**)(void))(*(void *)(a1 + 24) + 144))();
  if ((v16 & 0x80000000) != 0)
  {
    uint64_t v11 = v16;
    log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 1158, "%s%x", v17, v18, v19, v20, "lhError");
    return v11;
  }
  uint64_t v11 = (*(uint64_t (**)(void, void, unsigned __int8 **, unsigned int *))(*(void *)(a1 + 24) + 88))(*(void *)(a1 + 96), *(void *)(a1 + 104), &v43, &v44);
  if ((v11 & 0x80000000) == 0)
  {
    unint64_t v21 = v44;
    if (v44)
    {
      uint64_t v45 = 0;
      if (*(_DWORD *)a1 == 3
        && (*(_DWORD *)a1 = 2,
            *(_DWORD *)(a1 + 80) = TxtEncodingDetect(v43, v21, &v45),
            uint64_t v22 = ELQSSMLStartParsing(*(void *)(a1 + 56), 0, 0, 65001, 1),
            (v22 & 0x80000000) != 0))
      {
        uint64_t v11 = v22;
      }
      else
      {
        int v23 = *(_DWORD *)(a1 + 80);
        if (v23 == 65001)
        {
          uint64_t v24 = (char *)&v43[v45];
          size_t v25 = v44 - v45;
        }
        else
        {
          unint64_t v41 = 0;
          TxtEncodingGetOutputBytesRequired((char *)&v43[v45], v44 - v45, v23, v23, &v41);
          uint64_t v29 = TxtEncodingConvert(*(void *)(*(void *)(a1 + 8) + 16), *(_DWORD *)(a1 + 80), 65001, (char *)&v43[v45], v41, 0, 0, 0);
          uint64_t v24 = v29;
          if (v29) {
            size_t v25 = strlen(v29);
          }
          else {
            size_t v25 = 0;
          }
        }
        uint64_t v11 = 2375040625;
        if (v24 && v25)
        {
          if (strstr(v24, "<speak"))
          {
            uint64_t v30 = v42;
LABEL_32:
            uint64_t v32 = *(void *)(a1 + 56);
            int v33 = v24;
            size_t v34 = v25;
            uint64_t v35 = v30;
            goto LABEL_33;
          }
          uint64_t v31 = strstr(v24, "speak>");
          uint64_t v30 = v42;
          if (v31 || strstr(v24, "<?xml") || !v30) {
            goto LABEL_32;
          }
          size_t v38 = strlen(__s);
          if ((ELQSSMLParse(*(void *)(a1 + 56), (uint64_t)__s, v38, 0, 0) & 0x80000000) == 0
            && (ELQSSMLParse(*(void *)(a1 + 56), (uint64_t)v24, v25, 0, 0) & 0x80000000) == 0)
          {
            size_t v34 = strlen(v46);
            uint64_t v35 = v42;
            int v33 = v46;
            uint64_t v32 = *(void *)(a1 + 56);
LABEL_33:
            if ((ELQSSMLParse(v32, (uint64_t)v33, v34, v35, 0) & 0x80000000) == 0)
            {
              if (*(_DWORD *)(a1 + 80) != 65001) {
                heap_Free(*(void **)(*(void *)(a1 + 16) + 8), (uint64_t)v24);
              }
              uint64_t v11 = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 24) + 96))(*(void *)(a1 + 96), *(void *)(a1 + 104), v44);
              if ((v11 & 0x80000000) == 0 && v42)
              {
                *a5 = 1;
                uint64_t v36 = *(void *)(a1 + 112);
                if (!v36) {
                  goto LABEL_16;
                }
                uint64_t v11 = (*(uint64_t (**)(uint64_t, void))(*(void *)(a1 + 24) + 72))(v36, *(void *)(a1 + 120));
                *(void *)(a1 + 112) = safeh_GetNullHandle();
                *(void *)(a1 + 120) = v37;
              }
              if ((v11 & 0x80000000) == 0) {
                goto LABEL_16;
              }
            }
          }
        }
      }
LABEL_14:
      *(_DWORD *)a1 = 1;
LABEL_16:
      log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Exiting lightssml_Process", v13, v14, v15, v40);
      return v11;
    }
    if (v42)
    {
      *a5 = 1;
      uint64_t v27 = *(void *)(a1 + 112);
      if (v27)
      {
        uint64_t v11 = (*(uint64_t (**)(uint64_t, void))(*(void *)(a1 + 24) + 72))(v27, *(void *)(a1 + 120));
        *(void *)(a1 + 112) = safeh_GetNullHandle();
        *(void *)(a1 + 120) = v28;
      }
    }
    else
    {
      *a5 = 0;
    }
  }
  return v11;
}

uint64_t lightssml_ProcessEnd(uint64_t a1, int a2)
{
  uint64_t v3 = 2375032840;
  if ((safeh_HandleCheck(a1, a2, 435, 128) & 0x80000000) == 0)
  {
    log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Entering lightssml_ProcessEnd", v4, v5, v6, v19);
    if ((*(_DWORD *)a1 & 0xFFFFFFFE) == 2)
    {
      *(_DWORD *)a1 = 1;
      uint64_t v3 = UnloadTuningResources(*(void **)(a1 + 56));
      if ((v3 & 0x80000000) == 0)
      {
        uint64_t v14 = *(void *)(a1 + 96);
        if (!v14
          || (uint64_t v3 = (*(uint64_t (**)(uint64_t, void))(*(void *)(a1 + 24) + 72))(v14, *(void *)(a1 + 104)), *(void *)(a1 + 96) = safeh_GetNullHandle(), *(void *)(a1 + 104) = v15, (v3 & 0x80000000) == 0))
        {
          uint64_t v16 = *(void *)(a1 + 112);
          if (v16)
          {
            uint64_t v3 = (*(uint64_t (**)(uint64_t, void))(*(void *)(a1 + 24) + 72))(v16, *(void *)(a1 + 120));
            *(void *)(a1 + 112) = safeh_GetNullHandle();
            *(void *)(a1 + 120) = v17;
          }
        }
      }
    }
    else
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 1156, 0, v7, v8, v9, v10, v20);
      uint64_t v3 = 2375032849;
    }
    log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"LIGHTSSML", 4, 0, (uint64_t)"Exiting lightssml_ProcessEnd", v11, v12, v13, v20);
  }
  return v3;
}

uint64_t StringBuffer_Output(const char *a1, void *a2)
{
  if (!a1) {
    return 0;
  }
  size_t v4 = strlen(a1);
  if (!v4) {
    return 0;
  }
  __dst = 0;
  uint64_t v5 = (*(uint64_t (**)(void, void, void **, size_t))(a2[3] + 112))(a2[14], a2[15], &__dst, v4);
  if ((v5 & 0x80000000) != 0) {
    return v5;
  }
  memcpy(__dst, a1, v4);
  uint64_t v6 = (*(uint64_t (**)(void, void, size_t))(a2[3] + 120))(a2[14], a2[15], v4);
  if ((v6 & 0x80000000) == 0 && log_HasTraceTuningDataSubscriber(*(void *)(a2[2] + 32))) {
    log_OutTraceTuningDataBinary(*(void *)(a2[2] + 32), 500, (uint64_t)&byte_20D5A22AE, (uint64_t)"text/plain;charset=utf-8",
  }
      (uint64_t)__dst,
      v4);
  return v6;
}

uint64_t ELQEntityGetCode(uint64_t result, int a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  __int16 v6 = 0;
  size_t v5 = 15;
  if (result)
  {
    uint64_t v4 = 0;
    if ((a2 & 0xFFFFFFFE) == 0x4B0)
    {
      TxtEncodingConvert(0, a2, 65001, (char *)result, 0xFuLL, (uint64_t)&__dst, 0x50uLL, &v5);
    }
    else
    {
      strncpy(&__dst, (const char *)result, 0xEuLL);
      v10[12] = 0;
      size_t v5 = strlen(&__dst);
    }
    if (__dst != 38) {
      goto LABEL_15;
    }
    size_t v2 = v5 - 1;
    if (v5 == 1)
    {
      LOWORD(result) = 38;
      return (unsigned __int16)result;
    }
    if (*(&__dst + v2) != 59 || (*(&__dst + v2) = 0, !v8))
    {
LABEL_15:
      LOWORD(result) = 0;
      return (unsigned __int16)result;
    }
    if (v8 == 35)
    {
      if ((v9 & 0xDF) == 0x58)
      {
        if (ELQAsciiHex2num(v10, &v6)) {
          LOWORD(result) = v6;
        }
        else {
          LOWORD(result) = 0;
        }
      }
      else
      {
        LODWORD(result) = UTF8ContainsCharacterFamily((uint64_t)&v9);
        if (result) {
          LOWORD(result) = (unsigned __int16)LH_atoi(&v9);
        }
      }
    }
    else
    {
      uint64_t v3 = &v8;
      LOWORD(v4) = 0;
      uint64_t result = ELQbsearch((uint64_t)&v3, (uint64_t)&EntityList, 0xFDuLL, 16, (uint64_t (*)(uint64_t, uint64_t))EntityCompare);
      if (result) {
        LOWORD(result) = *(_WORD *)(result + 8);
      }
    }
  }
  return (unsigned __int16)result;
}

uint64_t UTF8ContainsCharacterFamily(uint64_t __s)
{
  if (__s)
  {
    uint64_t v1 = __s;
    if (!*(unsigned char *)__s) {
      return 1;
    }
    uint64_t v2 = 0;
    while (1)
    {
      size_t v4 = 0;
      unsigned int v3 = ELQGetWCharFromString((char *)__s, 65001, 0, &v4);
      if (v3)
      {
        if (ELQwisdigit(v3) != 1) {
          return 0;
        }
        v2 += v4;
      }
      else
      {
        ++v2;
      }
      __s = v1 + v2;
      if (!*(unsigned char *)(v1 + v2)) {
        return 1;
      }
    }
  }
  return __s;
}

uint64_t EntityCompare(const char **a1, const char **a2)
{
  return strcmp(*a1, *a2);
}

unsigned char *ELQSubstituteEntitiesUTF8(unsigned char *result, char a2)
{
  if (result)
  {
    uint64_t v2 = result;
    if (*result)
    {
      size_t v4 = result;
      do
      {
        uint64_t result = (unsigned char *)ELQUtf8GetByteNo(v4);
        if (result <= 1) {
          int v5 = 1;
        }
        else {
          int v5 = (int)result;
        }
        if (result <= 1)
        {
          int v6 = *v4;
          if ((a2 & 2) != 0 && v6 == 37)
          {
            int v7 = v4[1];
            if (!v4[1]) {
              goto LABEL_43;
            }
            int v8 = v4[2];
            if (!v4[2]) {
              goto LABEL_43;
            }
            unsigned int v9 = v7 - 48;
            if ((v7 - 97) >= 6) {
              int v10 = -1;
            }
            else {
              int v10 = v7 - 87;
            }
            if ((v7 - 65) <= 5) {
              int v11 = v7 - 55;
            }
            else {
              int v11 = v10;
            }
            int v12 = v7 - 48;
            if (v9 > 9) {
              int v12 = v11;
            }
            unsigned int v13 = v8 - 48;
            if ((v8 - 97) >= 6) {
              int v14 = -1;
            }
            else {
              int v14 = v8 - 87;
            }
            if ((v8 - 65) <= 5) {
              int v15 = v8 - 55;
            }
            else {
              int v15 = v14;
            }
            int v16 = v8 - 48;
            if (v13 > 9) {
              int v16 = v15;
            }
            if ((v12 & 0x80000000) == 0 && (v16 & 0x80000000) == 0 && (unsigned __int16 v17 = v16 + 16 * v12) != 0)
            {
              uint64_t result = (unsigned char *)TxtEncodingCharUTF16ToUTF8(v17, (uint64_t)&v31);
              char v18 = v31;
              if (v31)
              {
                uint64_t v19 = v32;
                do
                {
                  *v2++ = v18;
                  int v20 = *v19++;
                  char v18 = v20;
                }
                while (v20);
              }
              v4 += 3;
            }
            else
            {
LABEL_43:
              *v2++ = 37;
              ++v4;
            }
            continue;
          }
          if ((a2 & 1) != 0 && v6 == 38)
          {
            int v21 = 0;
            unsigned int v22 = 0;
            char v23 = 38;
            while (1)
            {
              if (!v23)
              {
                ++v4;
                *v2++ = 38;
                goto LABEL_53;
              }
              if (v23 == 59) {
                break;
              }
              char v23 = v4[++v22];
              --v21;
            }
            unsigned __int8 v25 = v4[v22 + 1];
            v4[v22 + 1] = 0;
            uint64_t result = (unsigned char *)ELQEntityGetCode((uint64_t)v4, 65001);
            v4[v22 + 1] = v25;
            if (result)
            {
              uint64_t result = (unsigned char *)TxtEncodingCharUTF16ToUTF8(result, (uint64_t)&v31);
              char v26 = v31;
              if (v31)
              {
                uint64_t v27 = v32;
                do
                {
                  *v2++ = v26;
                  int v28 = *v27++;
                  char v26 = v28;
                }
                while (v28);
              }
              v4 += v22 + 1;
            }
            else if (v22)
            {
              do
              {
                char v29 = *v4++;
                *v2++ = v29;
              }
              while (!__CFADD__(v21++, 1));
            }
            continue;
          }
        }
        do
        {
          char v24 = *v4++;
          *v2++ = v24;
          --v5;
        }
        while (v5);
LABEL_53:
        ;
      }
      while (*v4);
    }
    *uint64_t v2 = 0;
  }
  return result;
}

uint64_t ELQUtf8GetNext(char *a1, unsigned char *a2)
{
  if (!a1) {
    goto LABEL_13;
  }
  unsigned int v2 = *a1;
  if (!*a1)
  {
    int v3 = 0;
    if (!a2) {
      return 0;
    }
    goto LABEL_14;
  }
  if ((v2 & 0x80000000) != 0)
  {
    if (v2 + 62 < 0x1E)
    {
      unsigned int v2 = 2;
      goto LABEL_24;
    }
    if ((v2 & 0xFFFFFFF0) == 0xFFFFFFE0)
    {
      unsigned int v2 = 3;
      goto LABEL_24;
    }
    if ((v2 + 11) > 0xFAu)
    {
      unsigned int v2 = 4;
LABEL_24:
      int v3 = 1;
      if (!a2) {
        return 0;
      }
      goto LABEL_14;
    }
LABEL_13:
    int v3 = 0;
    unsigned int v2 = 0;
    if (!a2) {
      return 0;
    }
    goto LABEL_14;
  }
  int v3 = 1;
  unsigned int v2 = 1;
  if (!a2) {
    return 0;
  }
LABEL_14:
  if (v3)
  {
    if (v2 <= 1) {
      uint64_t v5 = 1;
    }
    else {
      uint64_t v5 = v2;
    }
    uint64_t v6 = v5;
    int v7 = a2;
    do
    {
      char v8 = *a1++;
      *v7++ = v8;
      --v6;
    }
    while (v6);
  }
  else
  {
    uint64_t v5 = 0;
  }
  a2[v5] = 0;
  return v2;
}

uint64_t ELQUtf8GetByteNo(unsigned char *a1)
{
  if (!a1) {
    return 0;
  }
  int v1 = (char)*a1;
  if (!*a1) {
    return 0;
  }
  if ((v1 & 0x80000000) == 0) {
    return 1;
  }
  if ((v1 + 62) < 0x1E) {
    return 2;
  }
  if ((v1 & 0xFFFFFFF0) == 0xFFFFFFE0) {
    return 3;
  }
  if ((v1 + 11) > 0xFAu) {
    return 4;
  }
  else {
    return 0;
  }
}

uint64_t ELQwcsncmp(_WORD *a1, unsigned __int16 *a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t v3 = a3 - 1;
  if (a3 != 1)
  {
    uint64_t v4 = 2 * a3 - 2;
    uint64_t v5 = (_WORD *)((char *)a1 + v4);
    uint64_t v6 = (unsigned __int16 *)((char *)a2 + v4);
    while (*a1 && (unsigned __int16)*a1 == *a2)
    {
      ++a1;
      ++a2;
      if (!--v3)
      {
        a1 = v5;
        a2 = v6;
        return (unsigned __int16)*a1 - *a2;
      }
    }
  }
  return (unsigned __int16)*a1 - *a2;
}

uint64_t ELQGetWCharFromString(char *__s, int a2, int a3, size_t *a4)
{
  LOWORD(v6) = (_WORD)__s;
  if (a4) {
    *a4 = 0;
  }
  if (!__s) {
    return (unsigned __int16)v6;
  }
  if (a3)
  {
    if ((a2 - 1200) < 2)
    {
      if (*(_WORD *)__s)
      {
        int v7 = __s + 2;
        do
        {
          int v8 = *(unsigned __int16 *)v7;
          v7 += 2;
        }
        while (v8);
        unsigned int v9 = *((unsigned __int16 *)v7 - 2);
        unsigned int v10 = bswap32(v9) >> 16;
        if (a2 == 1201) {
          LOWORD(v6) = v10;
        }
        else {
          LOWORD(v6) = v9;
        }
        if (!a4) {
          return (unsigned __int16)v6;
        }
        goto LABEL_31;
      }
LABEL_33:
      LOWORD(v6) = 0;
      return (unsigned __int16)v6;
    }
    if (a2 == 65001)
    {
      uint64_t v11 = 0;
      while (__s[v11++])
        ;
      uint64_t v13 = v11 - 1;
      if (!v13) {
        goto LABEL_33;
      }
      while (v13 >= 2)
      {
        if (__s[--v13] >= -64) {
          goto LABEL_39;
        }
      }
      LODWORD(v13) = 0;
LABEL_39:
      __s += (int)v13;
      goto LABEL_40;
    }
    if (!*__s) {
      goto LABEL_33;
    }
    uint64_t v6 = __s[strlen(__s) - 1];
    goto LABEL_35;
  }
  switch(a2)
  {
    case 1200:
      LOWORD(v6) = *(_WORD *)__s;
      if (!a4 || !*(_WORD *)__s) {
        return (unsigned __int16)v6;
      }
LABEL_31:
      size_t v14 = 2;
      goto LABEL_45;
    case 65001:
      if (!*__s) {
        goto LABEL_33;
      }
LABEL_40:
      ELQUtf8GetNext(__s, __sa);
      __int16 v17 = TxtEncodingCharUTF8ToUTF16((unsigned __int8 *)__sa);
      if (__sa[0])
      {
        LOWORD(v6) = v17;
        if (!a4) {
          return (unsigned __int16)v6;
        }
        size_t v14 = strlen(__sa);
      }
      else
      {
        LOWORD(v6) = 0;
        if (!a4) {
          return (unsigned __int16)v6;
        }
        size_t v14 = 1;
      }
LABEL_45:
      *a4 = v14;
      return (unsigned __int16)v6;
    case 1201:
      LOWORD(v6) = __rev16(*(unsigned __int16 *)__s);
      if (!a4 || !*(_WORD *)__s) {
        return (unsigned __int16)v6;
      }
      goto LABEL_31;
  }
  uint64_t v6 = *__s;
  if (!*__s) {
    return (unsigned __int16)v6;
  }
LABEL_35:
  size_t v14 = 1;
  Map = TxtEncodingGetMap(a2, 1);
  int v16 = TxtEncodingCharToWChar(v6, Map);
  LOWORD(v6) = v16;
  if (a4 && v16) {
    goto LABEL_45;
  }
  return (unsigned __int16)v6;
}

uint64_t ELQwisdigit(unsigned int a1)
{
  if (a1 - 48 < 0xA) {
    return 1;
  }
  if (a1 < 0xA0) {
    return 0;
  }
  int v2 = 0;
  int v3 = 232;
  do
  {
    int v4 = (v2 + v3) / 2;
    unsigned int v5 = ELQwisdigit_wisdigitList[v4];
    if (v5 <= a1)
    {
      if (v5 >= a1) {
        return v4 != -1;
      }
      int v2 = v4 + 1;
    }
    else
    {
      int v3 = v4 - 1;
    }
  }
  while (v2 <= v3);
  int v4 = -1;
  return v4 != -1;
}

uint64_t ELQAsciiHex2num(const char *a1, _WORD *a2)
{
  int v3 = a1;
  size_t v4 = strlen(a1);
  if (v4)
  {
    size_t v5 = v4;
    __int16 v6 = 0;
    while (1)
    {
      int v8 = *v3++;
      int v7 = v8;
      if (memchr("ABCDEF", v8, 7uLL)) {
        break;
      }
      if (memchr("abcdef", v7, 7uLL))
      {
        __int16 v9 = 16 * v6 - 97;
        goto LABEL_7;
      }
      uint64_t result = (uint64_t)memchr("0987654321", v7, 0xBuLL);
      if (!result) {
        return result;
      }
      __int16 v9 = 16 * v6;
      __int16 v10 = -48;
LABEL_8:
      __int16 v6 = v10 + v9 + v7;
      if (!--v5) {
        goto LABEL_13;
      }
    }
    __int16 v9 = 16 * v6 - 65;
LABEL_7:
    __int16 v10 = 10;
    goto LABEL_8;
  }
  __int16 v6 = 0;
LABEL_13:
  *a2 = v6;
  return 1;
}

void *ELQMemorySlotInit(uint64_t a1, uint64_t a2, int a3)
{
  __int16 v6 = (void *)heap_Alloc(*(void *)(a1 + 8), 72);
  int v7 = v6;
  if (v6)
  {
    v6[1] = a1;
    v6[4] = 0;
    v6[5] = a2;
    v6[3] = 0;
    uint64_t v8 = ReallocBuffers(v6);
    v7[2] = v8;
    *((_DWORD *)v7 + 12) = a3;
    v7[7] = 0;
    v7[8] = 0;
    if (v8) {
      *int v7 = ELQMemorySlotInit;
    }
    else {
      return 0;
    }
  }
  return v7;
}

uint64_t ReallocBuffers(void *a1)
{
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t v3 = v2 + 100;
    a1[4] = v3;
    uint64_t v4 = heap_Realloc(*(uint64_t **)(a1[1] + 8), a1[2], 24 * v3);
  }
  else
  {
    a1[4] = 100;
    uint64_t v4 = heap_Alloc(*(void *)(a1[1] + 8), 2400);
  }
  uint64_t v5 = v4;
  a1[2] = v4;
  if (v4)
  {
    unint64_t v6 = a1[4];
    if (v6 >= 0x64)
    {
      int v7 = (void *)(v4 + 24 * v6 - 2400);
      BOOL v8 = v6 - 99 >= v6;
      uint64_t v9 = -99;
      if (!v8) {
        uint64_t v9 = 0;
      }
      bzero(v7, 24 * v9 + 2400);
    }
  }
  return v5;
}

void *ELQMemorySlotDelete(void *result)
{
  if (result)
  {
    int v1 = result;
    if ((void *(*)(uint64_t, uint64_t, int))*result == ELQMemorySlotInit)
    {
      uint64_t v2 = result[4];
      if (v2)
      {
        uint64_t v3 = 24 * v2 - 24;
        do
        {
          --v2;
          heap_Free(*(void **)(v1[1] + 8), *(void *)(v1[2] + v3));
          v3 -= 24;
        }
        while (v2);
      }
      heap_Free(*(void **)(v1[1] + 8), v1[2]);
      void *v1 = 0;
      uint64_t v4 = *(void **)(v1[1] + 8);
      return heap_Free(v4, (uint64_t)v1);
    }
  }
  return result;
}

void *(**ELQMemorySlotSave(void *(**result)(uint64_t a1, uint64_t a2, int a3), char *__src, size_t __n))(uint64_t a1, uint64_t a2, int a3)
{
  if (!result) {
    return result;
  }
  uint64_t v3 = (uint64_t)result;
  if (*result != ELQMemorySlotInit) {
    return 0;
  }
  size_t v4 = __n;
  if (__src && !__n) {
    size_t v4 = strlen(__src) + 1;
  }
  *(void *)(v3 + 64) += v4;
  if (v4 > *(void *)(v3 + 40))
  {
    unint64_t v6 = *(void *)(v3 + 24);
    goto LABEL_14;
  }
  unint64_t v7 = *(void *)(v3 + 56);
  unint64_t v6 = *(void *)(v3 + 24);
  if (v7 >= v6)
  {
LABEL_14:
    if (v6 >= *(void *)(v3 + 32))
    {
      uint64_t result = (void *(**)(uint64_t, uint64_t, int))ReallocBuffers((void *)v3);
      *(void *)(v3 + 16) = result;
      if (!result) {
        return result;
      }
      size_t v9 = *(void *)(v3 + 40);
      if (v4 > v9) {
        size_t v9 = v4;
      }
      *(void *)(v3 + 40) = v9;
    }
    else
    {
      uint64_t result = *(void *(***)(uint64_t, uint64_t, int))(v3 + 16);
      size_t v9 = *(void *)(v3 + 40);
      if (v4 > v9) {
        size_t v9 = v4;
      }
      *(void *)(v3 + 40) = v9;
      if (!result) {
        return result;
      }
    }
    __int16 v10 = &result[3 * *(void *)(v3 + 24)];
    unint64_t v11 = (v9 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    v10[1] = v11;
    char v10[2] = 0;
    uint64_t result = (void *(**)(uint64_t, uint64_t, int))heap_Alloc(*(void *)(*(void *)(v3 + 8) + 8), v11);
    *__int16 v10 = result;
    if (result)
    {
      uint64_t result = (void *(**)(uint64_t, uint64_t, int))SaveInBuffer(__src, v4, (void *)(*(void *)(v3 + 16)+ 24 * *(void *)(v3 + 24)));
      if (result)
      {
        uint64_t v12 = *(void *)(v3 + 24);
        if (*(_DWORD *)(v3 + 48)) {
          *(void *)(v3 + 56) = v12;
        }
        *(void *)(v3 + 24) = v12 + 1;
      }
    }
    return result;
  }
  uint64_t v8 = 24 * v7;
  while (1)
  {
    uint64_t result = (void *(**)(uint64_t, uint64_t, int))SaveInBuffer(__src, v4, (void *)(*(void *)(v3 + 16) + v8));
    if (result) {
      break;
    }
    ++v7;
    unint64_t v6 = *(void *)(v3 + 24);
    v8 += 24;
    if (v7 >= v6) {
      goto LABEL_14;
    }
  }
  if (*(_DWORD *)(v3 + 48)) {
    *(void *)(v3 + 56) = v7;
  }
  return result;
}

void *SaveInBuffer(void *__src, size_t __n, void *a3)
{
  size_t v4 = (__n + 3) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v5 = a3[2];
  if (v5 + v4 > a3[1]) {
    return 0;
  }
  unint64_t v6 = (void *)(*a3 + v5);
  if (__src) {
    memcpy(v6, __src, __n);
  }
  else {
    bzero(v6, __n);
  }
  a3[2] += v4;
  return v6;
}

void *(**ELQMemorySlotReserve(void *(**a1)(uint64_t a1, uint64_t a2, int a3), size_t __n))(uint64_t a1, uint64_t a2, int a3)
{
  return ELQMemorySlotSave(a1, 0, __n);
}

uint64_t ELQMemorySlotReset(uint64_t result)
{
  if (result && *(void *(**)(uint64_t, uint64_t, int))result == ELQMemorySlotInit)
  {
    uint64_t v1 = *(void *)(result + 32);
    if (v1)
    {
      uint64_t v2 = (void *)(*(void *)(result + 16) + 16);
      do
      {
        *uint64_t v2 = 0;
        v2 += 3;
        --v1;
      }
      while (v1);
    }
    *(void *)(result + 56) = 0;
    *(void *)(result + 64) = 0;
  }
  return result;
}

uint64_t ELQbsearch(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t (*a5)(uint64_t, uint64_t))
{
  if (!a3) {
    return 0;
  }
  unint64_t v7 = a3;
  while (1)
  {
    uint64_t v10 = a2 + (v7 >> 1) * a4;
    int v11 = a5(a1, v10);
    if (!v11) {
      break;
    }
    if (v11 > 0) {
      a2 = v10 + a4;
    }
    unint64_t v12 = v7 - (v11 > 0);
    unint64_t v7 = v12 >> 1;
    if (v12 <= 1) {
      return 0;
    }
  }
  return v10;
}

uint64_t ELQPluginGetProc(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result = 2375032834;
  if (a1)
  {
    uint64_t v5 = *(uint64_t (**)(uint64_t, void))(a1 + 88);
    if (v5)
    {
      if (*(uint64_t (**)(uint64_t, uint64_t (***)(), uint64_t, char *, char *, const char *, uint64_t, uint64_t (*)()))a1 == ELQPluginIni)
      {
        uint64_t v7 = v5(a2, *(void *)(a1 + 104));
        uint64_t result = 0;
        *a3 = v7;
      }
    }
  }
  return result;
}

uint64_t ELQPluginIni(uint64_t a1, uint64_t (***a2)(), uint64_t a3, char *a4, char *a5, const char *a6, uint64_t a7, uint64_t (*a8)())
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v14 = 2375032834;
  int v15 = (uint64_t (**)())heap_Alloc(*(void *)(a1 + 8), 120);
  if (!v15) {
    return 2375032842;
  }
  int v16 = v15;
  *int v15 = 0;
  if (a5) {
    FileFullPath(v18, a5, a4);
  }
  else {
    __strcpy_chk();
  }
  __strcat_chk();
  v16[14] = (uint64_t (*)())a1;
  v16[11] = 0;
  v16[12] = 0;
  if (!strcmp(a6, "LTTS7XML"))
  {
    v16[11] = (uint64_t (*)())LTTS7XML;
    v16[13] = a8;
    unsigned __int8 *v16 = ELQPluginIni;
    __strcpy_chk();
    uint64_t v14 = 0;
    *a2 = v16;
  }
  else
  {
    if (*v16 == ELQPluginIni)
    {
      unsigned __int8 *v16 = 0;
      v16[12] = 0;
      heap_Free(*(void **)(a1 + 8), (uint64_t)v16);
    }
    heap_Free(*(void **)(a1 + 8), (uint64_t)v16);
  }
  return v14;
}

uint64_t ELQPluginLoadUtilSymbols(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = *(uint64_t (**)(const char *, void))(a1 + 88);
  if (!v2) {
    return 0;
  }
  if (*(uint64_t (**)(uint64_t, uint64_t (***)(), uint64_t, char *, char *, const char *, uint64_t, uint64_t (*)()))a1 != ELQPluginIni) {
    return 0;
  }
  uint64_t v5 = (uint64_t (*)(uint64_t))v2("LoadUtilSymbols", *(void *)(a1 + 104));
  if (!a2 || !v5) {
    return 0;
  }
  return v5(a2);
}

uint64_t (**ELQPluginDelete(uint64_t (**result)(uint64_t a1, uint64_t (***a2)(), uint64_t a3, char *a4, char *a5, const char *a6, uint64_t a7, uint64_t (*a8)())))(uint64_t a1, uint64_t (***a2)(), uint64_t a3, char *a4, char *a5, const char *a6, uint64_t a7, uint64_t (*a8)())
{
  if (result)
  {
    if (*result == ELQPluginIni)
    {
      *uint64_t result = 0;
      result[12] = 0;
      return (uint64_t (**)(uint64_t, uint64_t (***)(), uint64_t, char *, char *, const char *, uint64_t, uint64_t (*)()))heap_Free(*((void **)result[14] + 1), (uint64_t)result);
    }
  }
  return result;
}

uint64_t VoiceInfoIni(void *a1, uint64_t a2)
{
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  uint64_t v47 = 0;
  size_t v4 = (void *)heap_Alloc(*(void *)(a2 + 8), 24);
  if (!v4) {
    return 2375032842;
  }
  uint64_t v5 = (uint64_t (**)())v4;
  *size_t v4 = 0;
  v4[1] = 0;
  unint64_t v6 = v4 + 1;
  v4[2] = 0;
  *a1 = v4;
  v4[2] = a2;
  *size_t v4 = VoiceInfoIni;
  uint64_t v7 = hashtable_ObjOpen(v4 + 1, a2, 32, 0);
  if ((v7 & 0x80000000) != 0)
  {
    uint64_t v39 = v7;
LABEL_84:
    VoiceInfoDelete(v5);
    return v39;
  }
  hashtable_ElementSetDestructor(*v6, (uint64_t)FreeVoiceElement);
  uint64_t v8 = brk_ComponentTableIteratorOpen(*(void *)(a2 + 24), (uint64_t)"pipeline/*", (uint64_t)&v49);
  uint64_t v9 = v8;
  if ((v8 & 0x80000000) != 0)
  {
    uint64_t v39 = v8;
    goto LABEL_84;
  }
  if ((brk_ComponentTableIteratorNext(v49) & 0x80000000) == 0)
  {
    long long v43 = (BOOL *)v6;
    do
    {
      uint64_t v9 = brk_TagIteratorOpen(*(void *)(a2 + 24), v48, "PARAMETERS/*", 1, &v47);
      if ((v9 & 0x80000000) == 0)
      {
        uint64_t v45 = 0;
        long long v46 = 0;
        if ((brk_TagIteratorNext(v47, (uint64_t)&v46, (uint64_t)&v45) & 0x80000000) == 0)
        {
          uint64_t v10 = 0;
          unsigned int v44 = 0;
          int v11 = 0;
          unint64_t v12 = 0;
          do
          {
            uint64_t v13 = v45;
            uint64_t v14 = v46;
            if (v46) {
              BOOL v15 = v45 == 0;
            }
            else {
              BOOL v15 = 1;
            }
            if (!v15 && *v45)
            {
              if (!strcmp(v46, "voice"))
              {
                unint64_t v12 = (char *)v13;
              }
              else if (!strcmp(v14, "langcode"))
              {
                int v11 = (char *)v13;
              }
              else if (!strcmp(v14, "gender"))
              {
                uint64_t v10 = v13;
              }
              else if (!strcmp(v14, "age"))
              {
                unsigned int v16 = LH_atoi(v13);
                __int16 v17 = v45;
                char v18 = "adult";
                if (v16 <= 0x11) {
                  char v18 = "child";
                }
                if (v16) {
                  __int16 v17 = v18;
                }
                unsigned int v44 = v17;
              }
            }
          }
          while ((brk_TagIteratorNext(v47, (uint64_t)&v46, (uint64_t)&v45) & 0x80000000) == 0);
          if (v12 && *v12)
          {
            uint64_t v19 = strhelper_Strdup(*(void *)(a2 + 8), v12);
            if (!v19)
            {
              uint64_t v40 = *(void **)(a2 + 8);
              uint64_t v41 = 0;
              goto LABEL_83;
            }
            uint64_t v20 = (uint64_t)v19;
            int v21 = *v12;
            if (*v12)
            {
              uint64_t v22 = 0;
              unsigned int v23 = 1;
              do
              {
                if ((v21 - 65) < 0x1A) {
                  LOBYTE(v21) = v21 + 32;
                }
                v19[v22] = v21;
                uint64_t v22 = v23;
                int v21 = v12[v23++];
              }
              while (v21);
            }
            if (!hashtable_Get(*v43))
            {
              char v24 = *(void **)(a2 + 8);
              unsigned __int8 v25 = (uint64_t *)heap_Alloc((uint64_t)v24, 24);
              if (!v25) {
                goto LABEL_82;
              }
              char v26 = v25;
              *unsigned __int8 v25 = 0;
              v25[1] = 0;
              v25[2] = 0;
              if (v11)
              {
                if (*v11) {
                  uint64_t v27 = v11;
                }
                else {
                  uint64_t v27 = "unknown";
                }
              }
              else
              {
                uint64_t v27 = "unknown";
              }
              int v28 = strhelper_Strdup((uint64_t)v24, v27);
              *char v26 = (uint64_t)v28;
              if (!v28) {
                goto LABEL_81;
              }
              int v29 = *v28;
              if (*v28)
              {
                unsigned int v30 = 1;
                do
                {
                  if ((v29 - 65) < 0x1A) {
                    LOBYTE(v29) = v29 + 32;
                  }
                  *int v28 = v29;
                  int v28 = (unsigned char *)(*v26 + v30);
                  int v29 = *v28;
                  ++v30;
                }
                while (*v28);
              }
              if (v10) {
                char v31 = *v10 ? (char *)v10 : "neutral";
              }
              else {
                char v31 = "neutral";
              }
              uint64_t v32 = strhelper_Strdup((uint64_t)v24, v31);
              v26[1] = (uint64_t)v32;
              if (!v32) {
                goto LABEL_81;
              }
              int v33 = *v32;
              if (*v32)
              {
                unsigned int v34 = 1;
                do
                {
                  if ((v33 - 65) < 0x1A) {
                    LOBYTE(v33) = v33 + 32;
                  }
                  *uint64_t v32 = v33;
                  uint64_t v32 = (unsigned char *)(v26[1] + v34);
                  int v33 = *v32;
                  ++v34;
                }
                while (*v32);
              }
              if (v44) {
                uint64_t v35 = *v44 ? (char *)v44 : "adult";
              }
              else {
                uint64_t v35 = "adult";
              }
              uint64_t v36 = strhelper_Strdup((uint64_t)v24, v35);
              v26[2] = (uint64_t)v36;
              if (!v36)
              {
LABEL_81:
                FreeVoiceElement(v24, v26);
LABEL_82:
                uint64_t v40 = *(void **)(a2 + 8);
                uint64_t v41 = v20;
LABEL_83:
                heap_Free(v40, v41);
                uint64_t v39 = 2375032842;
                goto LABEL_84;
              }
              int v37 = *v36;
              if (*v36)
              {
                unsigned int v38 = 1;
                do
                {
                  if ((v37 - 65) < 0x1A) {
                    LOBYTE(v37) = v37 + 32;
                  }
                  *uint64_t v36 = v37;
                  uint64_t v36 = (unsigned char *)(v26[2] + v38);
                  int v37 = *v36;
                  ++v38;
                }
                while (*v36);
              }
              hashtable_Set(*v43);
            }
            heap_Free(*(void **)(a2 + 8), v20);
          }
        }
        brk_TagIteratorClose(v47);
        uint64_t v47 = 0;
      }
    }
    while ((brk_ComponentTableIteratorNext(v49) & 0x80000000) == 0);
    brk_ComponentTableIteratorClose(v49);
    uint64_t v39 = v9;
    if ((v9 & 0x80000000) == 0) {
      return v9;
    }
    goto LABEL_84;
  }
  brk_ComponentTableIteratorClose(v49);
  return v9;
}

void *FreeVoiceElement(void *a1, uint64_t *a2)
{
  uint64_t v4 = a2[2];
  if (v4) {
    heap_Free(a1, v4);
  }
  uint64_t v5 = a2[1];
  if (v5) {
    heap_Free(a1, v5);
  }
  if (*a2) {
    heap_Free(a1, *a2);
  }
  return heap_Free(a1, (uint64_t)a2);
}

uint64_t (**VoiceInfoDelete(uint64_t (**result)()))()
{
  if (result)
  {
    uint64_t v1 = (uint64_t)result;
    if (*result == VoiceInfoIni)
    {
      uint64_t v2 = result[1];
      if (v2) {
        hashtable_ObjClose(v2);
      }
      *(void *)(v1 + 8) = 0;
      uint64_t v3 = *(void **)(*(void *)(v1 + 16) + 8);
      return (uint64_t (**)())heap_Free(v3, v1);
    }
  }
  return result;
}

char *LTTS7XML(char *__s1)
{
  if (__s1)
  {
    uint64_t v1 = __s1;
    uint64_t v2 = 0;
    while (strcmp(v1, (&LTTS7XML_FuncTable)[v2]))
    {
      v2 += 2;
      if (v2 == 38) {
        return 0;
      }
    }
    return (&LTTS7XML_FuncTable)[v2 + 1];
  }
  return __s1;
}

uint64_t LoqXMLGetVersion(char *a1)
{
  return 0;
}

uint64_t LoqXMLIniParser(void *a1, uint64_t a2)
{
  uint64_t v2 = 2375032842;
  if (!a1) {
    return 2375032839;
  }
  uint64_t v5 = heap_Alloc(*(void *)(a2 + 8), 536);
  if (v5)
  {
    unint64_t v6 = (void *)v5;
    *(void *)(v5 + 528) = a2;
    v10.realloc_fcn = (void *(__cdecl *)(void *, size_t))builtin_Alloc_0;
    v10.free_fcn = (void (__cdecl *)(void *))builtin_Realloc_0;
    uint64_t v7 = *(void *(__cdecl **)(size_t))(a2 + 8);
    int v11 = builtin_Free_0;
    v10.malloc_fcn = v7;
    XML_Parser v8 = XML_ParserCreate_MM(0, &v10, 0);
    v6[1] = v8;
    if (v8)
    {
      uint64_t v2 = 0;
      *unint64_t v6 = LoqXMLIniParser;
      *a1 = v6;
    }
    else
    {
      heap_Free(*(void **)(a2 + 8), (uint64_t)v6);
    }
  }
  return v2;
}

uint64_t LoqXMLIniParserNS(void *a1, uint64_t a2, XML_Char a3)
{
  uint64_t v3 = 2375032842;
  XML_Char namespaceSeparator = a3;
  if (!a1) {
    return 2375032839;
  }
  uint64_t v6 = heap_Alloc(*(void *)(a2 + 8), 536);
  if (v6)
  {
    uint64_t v7 = (void *)v6;
    memsuite.realloc_fcn = (void *(__cdecl *)(void *, size_t))builtin_Alloc_0;
    memsuite.free_fcn = (void (__cdecl *)(void *))builtin_Realloc_0;
    XML_Parser v8 = *(void *(__cdecl **)(size_t))(a2 + 8);
    unint64_t v12 = builtin_Free_0;
    memsuite.malloc_fcn = v8;
    XML_Parser v9 = XML_ParserCreate_MM("uft-8", &memsuite, &namespaceSeparator);
    v7[1] = v9;
    if (v9)
    {
      uint64_t v3 = 0;
      *uint64_t v7 = LoqXMLIniParser;
      *a1 = v7;
    }
    else
    {
      heap_Free(*(void **)(a2 + 8), (uint64_t)v7);
    }
  }
  return v3;
}

uint64_t LoqXMLDeleteParser(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    XML_ParserFree(*(XML_Parser *)(a1 + 8));
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    heap_Free(*(void **)(*(void *)(a1 + 528) + 8), a1);
    return 0;
  }
  return result;
}

uint64_t LoqXMLSetEncoding(uint64_t a1, const XML_Char *a2)
{
  uint64_t v2 = 2375032839;
  if (a1)
  {
    if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
    {
      __strcpy_chk();
      if (XML_SetEncoding(*(XML_Parser *)(a1 + 8), a2)) {
        return 0;
      }
      else {
        return 2375032839;
      }
    }
    else
    {
      return 2375032834;
    }
  }
  return v2;
}

uint64_t LoqXMLGetEncoding(uint64_t a1, char *__dst)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    strcpy(__dst, (const char *)(a1 + 16));
    return 0;
  }
  return result;
}

uint64_t LoqXMLSetCallbacks(uint64_t a1, void (__cdecl *a2)(void *, const XML_Char *, const XML_Char **), void (__cdecl *a3)(void *, const XML_Char *), void (__cdecl *a4)(void *, const XML_Char *, int), void *userData)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    XML_SetUserData(*(XML_Parser *)(a1 + 8), userData);
    XML_SetElementHandler(*(XML_Parser *)(a1 + 8), a2, a3);
    XML_SetCharacterDataHandler(*(XML_Parser *)(a1 + 8), a4);
    return 0;
  }
  return result;
}

uint64_t LoqXMLSetUnknownEncodingHandler(uint64_t a1, int (__cdecl *a2)(void *, const XML_Char *, XML_Encoding *), void *a3)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    XML_SetUnknownEncodingHandler(*(XML_Parser *)(a1 + 8), a2, a3);
    return 0;
  }
  return result;
}

double LoqXMLGetEncodingMap(uint64_t (**a1)(void *a1, uint64_t a2), uint64_t a2, void *a3)
{
  if (a1 && *a1 == LoqXMLIniParser)
  {
    if (a3) {
      *a3 = a2;
    }
    *(void *)(a2 + 1040) = 0;
    double result = 0.0;
    *(_OWORD *)(a2 + 1024) = 0u;
  }
  return result;
}

uint64_t LoqXMLParse(uint64_t a1, const char *a2, int a3, int a4, _DWORD *a5)
{
  if (a5) {
    *a5 = 0;
  }
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    XML_Status v8 = XML_Parse(*(XML_Parser *)(a1 + 8), a2, a3, a4);
    if (v8) {
      uint64_t result = 0;
    }
    else {
      uint64_t result = 2375040625;
    }
    if (a5)
    {
      if (v8)
      {
        uint64_t result = 0;
        *a5 = 1;
      }
    }
  }
  return result;
}

uint64_t LoqXMLGetError(uint64_t a1, XML_Error *a2, _DWORD *a3)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    if (a2) {
      *a2 = XML_GetErrorCode(*(XML_Parser *)(a1 + 8));
    }
    if (a3)
    {
      int CurrentLineNumber = XML_GetCurrentLineNumber(*(XML_Parser *)(a1 + 8));
      uint64_t result = 0;
      *a3 = CurrentLineNumber;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t LoqXMLGetCurrentLineNumber(uint64_t a1, _DWORD *a2)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    if (a2)
    {
      int CurrentLineNumber = XML_GetCurrentLineNumber(*(XML_Parser *)(a1 + 8));
      uint64_t result = 0;
      *a2 = CurrentLineNumber;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t LoqXMLSetUserData(uint64_t a1, void *a2)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    XML_SetUserData(*(XML_Parser *)(a1 + 8), a2);
    return 0;
  }
  return result;
}

uint64_t LoqXMLGetUserData(uint64_t a1, void *a2)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    uint64_t result = 0;
    if (a2) {
      *a2 = **(void **)(a1 + 8);
    }
  }
  return result;
}

uint64_t LoqXMLReset(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    if (XML_ParserReset(*(XML_Parser *)(a1 + 8), 0)) {
      return 0;
    }
    else {
      return 2375040625;
    }
  }
  return result;
}

uint64_t LoqXMLGetByteOffset(uint64_t a1, _DWORD *a2)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    int CurrentByteIndex = XML_GetCurrentByteIndex(*(XML_Parser *)(a1 + 8));
    if (a2)
    {
      int v6 = CurrentByteIndex;
      uint64_t result = 0;
      *a2 = v6;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t LoqXMLSetXmlDeclHandler(uint64_t a1, void (__cdecl *a2)(void *, const XML_Char *, const XML_Char *, int))
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    XML_SetXmlDeclHandler(*(XML_Parser *)(a1 + 8), a2);
    return 0;
  }
  return result;
}

uint64_t LoqXMLSetNamespaceCallbacks(uint64_t a1, void (__cdecl *a2)(void *, const XML_Char *, const XML_Char *), void (__cdecl *a3)(void *, const XML_Char *))
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void *, uint64_t))a1 == LoqXMLIniParser)
  {
    XML_SetNamespaceDeclHandler(*(XML_Parser *)(a1 + 8), a2, a3);
    return 0;
  }
  return result;
}

uint64_t builtin_Alloc_0(uint64_t a1, unsigned int a2)
{
  return heap_Alloc(a1, a2);
}

uint64_t builtin_Realloc_0(uint64_t *a1, uint64_t a2, unsigned int a3)
{
  return heap_Realloc(a1, a2, a3);
}

void *ELQXMLIniController(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = heap_Alloc(*(void *)(a1 + 8), 1216);
  uint64_t v7 = (void *)v6;
  if (v6)
  {
    *(void *)(v6 + 1200) = a1;
    *(void *)(v6 + 1208) = a4;
    *(_DWORD *)(v6 + 1196) = 0;
    *(void *)(v6 + 8) = 0;
    *(_OWORD *)(v6 + 1040) = 0u;
    *(_OWORD *)(v6 + 1056) = 0u;
    *(_OWORD *)(v6 + 1072) = 0u;
    *(_OWORD *)(v6 + 1088) = 0u;
    *(void *)(v6 + 1104) = 0;
    *(void *)(v6 + 1120) = 0;
    *(void *)(v6 + 1136) = 0;
    *(void *)(v6 + 1128) = 0;
    *(_OWORD *)(v6 + 1152) = 0u;
    *(_OWORD *)(v6 + 1168) = 0u;
    *(_OWORD *)(v6 + 1177) = 0u;
    __strcpy_chk();
    __strcpy_chk();
    *uint64_t v7 = ELQXMLIniController;
  }
  return v7;
}

void *ELQXMLDeleteController(void *result)
{
  if (result)
  {
    uint64_t v1 = (uint64_t)result;
    if ((void *(*)(uint64_t, uint64_t, uint64_t, uint64_t))*result == ELQXMLIniController)
    {
      critsec_Enter((void *)result[151]);
      uint64_t v2 = *(uint64_t (***)(uint64_t, uint64_t (***)(), uint64_t, char *, char *, const char *, uint64_t, uint64_t (*)()))(v1 + 8);
      if (v2) {
        ELQPluginDelete(v2);
      }
      critsec_Leave(*(void **)(v1 + 1208));
      *(void *)uint64_t v1 = 0;
      uint64_t v3 = *(void **)(*(void *)(v1 + 1200) + 8);
      return heap_Free(v3, v1);
    }
  }
  return result;
}

uint64_t ELQXMLGetNamespaceSeparator(uint64_t a1, unsigned char *a2)
{
  uint64_t result = 2375032834;
  if (a1)
  {
    if (*(void *(**)(uint64_t, uint64_t, uint64_t, uint64_t))a1 == ELQXMLIniController)
    {
      uint64_t result = 0;
      *a2 = *(unsigned char *)(a1 + 1192);
    }
  }
  return result;
}

void *XMLIniParser(uint64_t a1, uint64_t a2)
{
  if (!a1 || *(void *(**)(uint64_t, uint64_t, uint64_t, uint64_t))a1 != ELQXMLIniController) {
    return 0;
  }
  uint64_t v6 = (void *)heap_Alloc(*(void *)(*(void *)(a1 + 1200) + 8), 32);
  uint64_t v3 = v6;
  if (!v6) {
    return v3;
  }
  *uint64_t v6 = 0;
  critsec_Enter(*(void **)(a1 + 1208));
  uint64_t v7 = (uint64_t (***)(uint64_t, uint64_t (***)(), uint64_t, char *, char *, const char *, uint64_t, uint64_t (*)()))(a1 + 8);
  if (!*(void *)(a1 + 8))
  {
    if (*(void *(**)(uint64_t, uint64_t, uint64_t, uint64_t))a1 != ELQXMLIniController
      || ELQPluginIni(*(void *)(a1 + 1200), (uint64_t (***)())(a1 + 8), 0, (char *)(a1 + 16), (char *)(a1 + 528), (const char *)(a1 + 16), 0, 0))
    {
      goto LABEL_14;
    }
    ELQPluginLoadUtilSymbols(*(void *)(a1 + 8), *(void *)(a1 + 1184));
    if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLIniParser", (uint64_t *)(a1 + 1040)))
    {
LABEL_13:
      ELQPluginDelete(*v7);
LABEL_14:
      heap_Free(*(void **)(*(void *)(a1 + 1200) + 8), (uint64_t)v3);
      critsec_Leave(*(void **)(a1 + 1208));
      return 0;
    }
    if (*(void *)(a1 + 1040))
    {
      if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLIniParserNS", (uint64_t *)(a1 + 1048))) {
        goto LABEL_13;
      }
      if (*(void *)(a1 + 1048))
      {
        if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLDeleteParser", (uint64_t *)(a1 + 1056))) {
          goto LABEL_13;
        }
        if (*(void *)(a1 + 1056))
        {
          if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLSetEncoding", (uint64_t *)(a1 + 1064))) {
            goto LABEL_13;
          }
          if (*(void *)(a1 + 1064))
          {
            if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLGetEncoding", (uint64_t *)(a1 + 1072)))goto LABEL_13; {
            if (*(void *)(a1 + 1072))
            }
            {
              if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLSetCallbacks", (uint64_t *)(a1 + 1080)))goto LABEL_13; {
              if (*(void *)(a1 + 1080))
              }
              {
                if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLSetNamespaceCallbacks", (uint64_t *)(a1 + 1088)))goto LABEL_13; {
                if (*(void *)(a1 + 1088))
                }
                {
                  if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLGetErrorString", (uint64_t *)(a1 + 1120)))goto LABEL_13; {
                  if (*(void *)(a1 + 1120))
                  }
                  {
                    if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLGetError", (uint64_t *)(a1 + 1104)))goto LABEL_13; {
                    if (*(void *)(a1 + 1104))
                    }
                    {
                      if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLGetCurrentLineNumber", (uint64_t *)(a1 + 1112)))goto LABEL_13; {
                      if (*(void *)(a1 + 1112))
                      }
                      {
                        if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLParse", (uint64_t *)(a1 + 1096)))goto LABEL_13; {
                        if (*(void *)(a1 + 1096))
                        }
                        {
                          if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLSetUEHandler", (uint64_t *)(a1 + 1128)))goto LABEL_13; {
                          if (*(void *)(a1 + 1128))
                          }
                          {
                            if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLGetEncodingMap", (uint64_t *)(a1 + 1136)))goto LABEL_13; {
                            if (*(void *)(a1 + 1136))
                            }
                            {
                              if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLSetUserData", (uint64_t *)(a1 + 1144)))goto LABEL_13; {
                              if (*(void *)(a1 + 1144))
                              }
                              {
                                if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLGetUserData", (uint64_t *)(a1 + 1152)))goto LABEL_13; {
                                if (*(void *)(a1 + 1152))
                                }
                                {
                                  if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLReset", (uint64_t *)(a1 + 1160)))goto LABEL_13; {
                                  if (*(void *)(a1 + 1160))
                                  }
                                  {
                                    if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLGetByteOffset", (uint64_t *)(a1 + 1168)))goto LABEL_13; {
                                    if (*(void *)(a1 + 1168))
                                    }
                                    {
                                      if (ELQPluginGetProc(*(void *)(a1 + 8), (uint64_t)"ELQXMLSetXmlDeclHandler", (uint64_t *)(a1 + 1176)))goto LABEL_13; {
                                      if (*(void *)(a1 + 1176))
                                      }
                                        goto LABEL_7;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    ELQPluginDelete(*v7);
  }
LABEL_7:
  v3[2] = a1;
  critsec_Leave(*(void **)(a1 + 1208));
  XML_Status v8 = v3 + 1;
  uint64_t v9 = *(void *)(a1 + 1200);
  if (!*(_DWORD *)(a1 + 1196))
  {
    if ((*(unsigned int (**)(void *, uint64_t))(a1 + 1040))(v8, v9)) {
      goto LABEL_9;
    }
LABEL_16:
    v3[3] = a2;
    *uint64_t v3 = ELQXMLIniParser;
    return v3;
  }
  if (!(*(unsigned int (**)(void *, uint64_t, void))(a1 + 1048))(v8, v9, *(char *)(a1 + 1192)))goto LABEL_16; {
LABEL_9:
  }
  heap_Free(*(void **)(*(void *)(a1 + 1200) + 8), (uint64_t)v3);
  return 0;
}

void *ELQXMLDeleteParser(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    if ((uint64_t (*)())*result == ELQXMLIniParser)
    {
      uint64_t v2 = result[2];
      if (*(void *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v2 == ELQXMLIniController)
      {
        (*(void (**)(void))(v2 + 1056))(result[1]);
        uint64_t v2 = v1[2];
      }
      void *v1 = 0;
      uint64_t v3 = *(void **)(*(void *)(v2 + 1200) + 8);
      return heap_Free(v3, (uint64_t)v1);
    }
  }
  return result;
}

uint64_t ELQXMLSetEncoding(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void, void))a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(void *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1064))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLSetCallbacks(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void, void))a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(void *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1080))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLSetNamespaceCallbacks(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void, void))a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(void *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1088))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLParse(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void, void))a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(void *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1096))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLGetCurrentLineNumber(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)())a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(void *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1112))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLGetError(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void, void))a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(void *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1104))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLGetErrorString(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v3 = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void, void))a1 == ELQXMLIniParser)
  {
    uint64_t v4 = *(void *)(a1 + 16);
    if (v4)
    {
      if (*(void *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v4 == ELQXMLIniController)
      {
        uint64_t v6 = (const char *)(*(uint64_t (**)(uint64_t))(v4 + 1120))(a2);
        *a3 = 0;
        if (v6)
        {
          strcpy(a3, v6);
          return 0;
        }
        else
        {
          return 2375032839;
        }
      }
    }
  }
  return v3;
}

uint64_t ELQXMLGetEncodingFromHeader(uint64_t a1, unsigned char *a2, unsigned __int16 *a3, unint64_t a4, int a5)
{
  uint64_t v6 = a3;
  uint64_t v7 = a2;
  uint64_t v38 = *MEMORY[0x263EF8340];
  uint64_t result = 2375032839;
  if ((!a1 || *(uint64_t (**)(void, void))a1 == ELQXMLIniParser) && a2 && a3)
  {
    BOOL v10 = 0;
    *a2 = 0;
    if (a4 >= 0xA)
    {
      int v35 = a5;
      uint64_t v11 = 0;
      unint64_t v12 = 0;
      unsigned int v13 = 0;
      while (1)
      {
        uint64_t v14 = (char *)v6 + v11;
        unsigned int v15 = *((unsigned __int8 *)v6 + v11);
        if (v15 <= 0xD && ((1 << v15) & 0x2401) != 0)
        {
LABEL_17:
          BOOL v10 = 0;
          uint64_t v7 = a2;
          a5 = v35;
          goto LABEL_18;
        }
        if (!strncmp(v14, "encoding", 8uLL)) {
          unint64_t v12 = v14;
        }
        uint64_t v11 = v13 + 1;
        if (v15 == 63 && *((unsigned char *)v6 + v11) == 62) {
          break;
        }
        ++v13;
        if (v11 + 9 >= a4) {
          goto LABEL_17;
        }
      }
      BOOL v10 = 0;
      uint64_t v7 = a2;
      a5 = v35;
      if (v12)
      {
        if (v12 < v14)
        {
          while (1)
          {
            int v26 = *(unsigned __int8 *)v12;
            if (v26 == 34 || v26 == 39) {
              break;
            }
            BOOL v10 = 0;
            if (++v12 == (char *)v6 + v13) {
              goto LABEL_18;
            }
          }
          int v28 = (unsigned __int8 *)(v12 + 1);
          if (v12 + 1 >= v14)
          {
            int v34 = 0;
          }
          else
          {
            uint64_t v29 = 1;
            while (1)
            {
              int v30 = v12[v29];
              if (v30 == 34 || v30 == 39) {
                break;
              }
              a2[(v29++ - 1)] = v30;
              int v28 = (unsigned __int8 *)&v12[v29];
              if (&v12[v29] >= v14) {
                goto LABEL_68;
              }
            }
            int v28 = (unsigned __int8 *)&v12[v29];
LABEL_68:
            int v34 = v29 - 1;
          }
          if (v28 == (unsigned __int8 *)v14) {
            return 2375040625;
          }
          a2[v34] = 0;
          BOOL v10 = *a2 != 0;
        }
      }
    }
LABEL_18:
    uint64_t result = 0;
    if (a5 != 65001 && !v10)
    {
      if (a1) {
        uint64_t v17 = *(void *)(*(void *)(*(void *)(a1 + 16) + 1200) + 8);
      }
      else {
        uint64_t v17 = 0;
      }
      TxtEncodingConvert(v17, 65001, 1200, "encoding", 0xFFFFFFFFFFFFFFFFLL, (uint64_t)v37, 0x50uLL, 0);
      char v18 = 0;
      unint64_t v19 = a4 >> 1;
      BOOL v20 = a4 >> 1 > 9;
      uint64_t v21 = 9;
      if (v20) {
        uint64_t v22 = v19;
      }
      else {
        uint64_t v22 = 9;
      }
      while (1)
      {
        if (v22 == v21) {
          return 0;
        }
        unsigned int v23 = *v6;
        BOOL v20 = v23 > 0xD;
        int v24 = (1 << v23) & 0x2401;
        if (!v20 && v24 != 0) {
          return 0;
        }
        if (!ELQwcsncmp(v6, v37, 8)) {
          char v18 = v6;
        }
        if (*v6 == 63 && v6[1] == 62) {
          break;
        }
        uint64_t result = 0;
        ++v21;
        ++v6;
        if (v21 == 265) {
          return result;
        }
      }
      uint64_t result = 0;
      if (v18)
      {
        while (v18 < v6)
        {
          int v27 = *v18;
          if (v27 == 34 || v27 == 39)
          {
            char v31 = v18 + 1;
            if (v18 + 1 >= v6)
            {
              int v32 = 0;
            }
            else
            {
              int v32 = 0;
              do
              {
                int v33 = *v31;
                if (v33 == 34) {
                  break;
                }
                if (v33 == 39) {
                  break;
                }
                v7[v32++] = v33;
                ++v31;
              }
              while (v31 < v6);
            }
            if (v6 != v31)
            {
              uint64_t result = 0;
              v7[v32] = 0;
              return result;
            }
            return 2375040625;
          }
          uint64_t result = 0;
          ++v18;
        }
      }
    }
  }
  return result;
}

uint64_t ELQXMLSetUnknownEncodingHandler(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)())a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(void *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1128))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLUnknownEncodingHandler(uint64_t result, unsigned __int8 *a2, uint64_t a3)
{
  if (result)
  {
    if (*(uint64_t (**)())result == ELQXMLIniParser
      && (uint64_t v3 = *(void *)(result + 16)) != 0
      && (uint64_t v10 = 0, *(void *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v3 == ELQXMLIniController))
    {
      int v5 = (*(uint64_t (**)(void, uint64_t, uint64_t *))(v3 + 1136))(*(void *)(result + 8), a3, &v10);
      uint64_t result = 0;
      if (a2)
      {
        if (!v5)
        {
          int Id = TxtEncodingGetId(a2);
          uint64_t result = (uint64_t)TxtEncodingGetMap(Id, 1);
          if (result)
          {
            uint64_t v7 = (_DWORD *)result;
            for (uint64_t i = 0; i != 255; ++i)
            {
              int v9 = TxtEncodingCharToWChar(i, v7);
              *(_DWORD *)(v10 + 4 * i) = v9;
              uint64_t result = 1;
            }
          }
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t ELQXMLReset(uint64_t a1)
{
  uint64_t result = 2375032834;
  if (!a1) {
    return 2375032839;
  }
  if (*(uint64_t (**)(void, void))a1 == ELQXMLIniParser)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      if (*(void *(**)(uint64_t, uint64_t, uint64_t, uint64_t))v3 == ELQXMLIniController) {
        return (*(uint64_t (**)(void))(v3 + 1160))(*(void *)(a1 + 8));
      }
    }
  }
  return result;
}

uint64_t ELQXMLGetControllerFromParser(uint64_t result)
{
  if (result)
  {
    if (*(uint64_t (**)())result == ELQXMLIniParser) {
      return *(void *)(result + 16);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t Wav2PCM(_WORD *a1, uint64_t a2, const char *a3, uint64_t a4, int a5, char *a6, uint64_t *a7, unsigned int *a8)
{
  v63[199] = *MEMORY[0x263EF8340];
  long long v60 = 0;
  uint64_t v61 = 0;
  unsigned __int8 v59 = 0;
  unsigned int v57 = 0;
  int v58 = 0;
  long long v56 = 0;
  if (!a3) {
    return 2269126663;
  }
  uint64_t result = 2269126663;
  if (a8)
  {
    if (a7)
    {
      if (a6)
      {
        if (a5)
        {
          if (a4)
          {
            if (*a3)
            {
              *a6 = 0;
              *a7 = 0;
              *a8 = 0;
              uint64_t result = InitRsrcFunction(a1, a2, &v61);
              if ((result & 0x80000000) == 0)
              {
                uint64_t result = ssftriff_reader_ObjOpenEx(a1, a2, 4, a3, a4, a5, "WAVE", 0, (uint64_t *)&v60);
                if ((result & 0x80000000) == 0)
                {
                  unsigned int v54 = 0;
                  unsigned int v55 = 0;
                  while (1)
                  {
                    unsigned int v21 = ssftriff_reader_OpenChunk((uint64_t)v60, &v58, &v57, &v56, v17, v18, v19, v20);
                    if ((v21 & 0x80000000) != 0)
                    {
LABEL_34:
                      if ((v21 & 0x1FFF) == 0x14) {
                        uint64_t v42 = 0;
                      }
                      else {
                        uint64_t v42 = v21;
                      }
                      if (!*a6)
                      {
                        log_OutPublic(*(void *)(v61 + 32), (uint64_t)"AUDIOFETCH", 149, "%s%s", v17, v18, v19, v20, "url");
                        goto LABEL_55;
                      }
                      if (v54 != 1)
                      {
                        if (!v54)
                        {
                          log_OutPublic(*(void *)(v61 + 32), (uint64_t)"AUDIOFETCH", 150, "%s%s", v17, v18, v19, v20, "url");
                          goto LABEL_55;
                        }
                        log_OutText(*(void *)(v61 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"RIFF WAVE URL %s has %u audio chunks, will be concatenated", v18, v19, v20, (uint64_t)a3);
                      }
                      if (v55)
                      {
                        uint64_t v43 = heap_Alloc(*(void *)(v61 + 8), v55);
                        *a7 = v43;
                        if (!v43)
                        {
                          log_OutPublic(*(void *)(v61 + 32), (uint64_t)"AUDIOFETCH", 151, "%s%lu", v44, v45, v46, v47, "sizeBytes");
                          uint64_t v53 = 2269126666;
                          goto LABEL_56;
                        }
                        uint64_t v48 = (char *)v43;
                        uint64_t v49 = v54;
                        long long v50 = v63;
                        do
                        {
                          long long v51 = (const void *)*((void *)v50 - 1);
                          unsigned int v52 = *v50;
                          v50 += 4;
                          memcpy(v48, v51, v52);
                          v48 += v52;
                          --v49;
                        }
                        while (v49);
                      }
                      *a8 = v55;
                      uint64_t v53 = v42;
                      goto LABEL_56;
                    }
                    if (v58 ^ 0x20746D66 | v59)
                    {
                      if (v58 ^ 0x61746164 | v59)
                      {
                        log_OutText(*(void *)(v61 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Ignoring RIFF WAVE chunk %s in URL %s (%lu bytes)", v18, v19, v20, (uint64_t)&v58);
                      }
                      else
                      {
                        uint64_t v40 = &__s2[16 * v54 + 32];
                        *(void *)uint64_t v40 = v56;
                        unsigned int v41 = v57;
                        *((_DWORD *)v40 + 2) = v57;
                        ++v54;
                        v55 += v41;
                        log_OutText(*(void *)(v61 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"RIFF WAV %s: audio chunk %u, %lu bytes", v18, v19, v20, (uint64_t)a3);
                      }
                    }
                    else
                    {
                      if (v57 <= 0xF)
                      {
                        log_OutPublic(*(void *)(v61 + 32), (uint64_t)"AUDIOFETCH", 143, "%s%s", v17, v18, v19, v20, "url");
                        goto LABEL_55;
                      }
                      int v25 = *v56;
                      uint64_t v26 = v56[1];
                      unsigned int v28 = *((_DWORD *)v56 + 1);
                      int v27 = *((_DWORD *)v56 + 2);
                      int v29 = v56[6];
                      unsigned int v30 = v56[7];
                      log_OutText(*(void *)(v61 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"RIFF WAV %s: format %d, %d channels, %ld HZ, %ld bytes per sec, %d block align, %d bits per sample", v18, v19, v20, (uint64_t)a3);
                      if (v26 != 1)
                      {
                        log_OutPublic(*(void *)(v61 + 32), (uint64_t)"AUDIOFETCH", 144, "%s%s%s%d", v31, v32, v33, v34, "url");
                        goto LABEL_55;
                      }
                      switch(v25)
                      {
                        case 7:
                          if (v28 != 8000 || v27 != 8000 || v29 != 1 || v30 != 8)
                          {
                            log_OutPublic(*(void *)(v61 + 32), (uint64_t)"AUDIOFETCH", 147, "%s%s%s%s%s%ld%s%ld%s%d%s%d", v31, v32, v33, v34, "url");
                            goto LABEL_55;
                          }
                          strcpy(a6, "audio/basic");
                          break;
                        case 6:
                          if (v28 != 8000 || v27 != 8000 || v29 != 1 || v30 != 8)
                          {
                            log_OutPublic(*(void *)(v61 + 32), (uint64_t)"AUDIOFETCH", 146, "%s%s%s%s%s%ld%s%ld%s%d%s%d", v31, v32, v33, v34, "url");
LABEL_55:
                            uint64_t v53 = 2269126660;
LABEL_56:
                            if (v60) {
                              ssftriff_reader_ObjClose(v60, v22, v23, v24, v17, v18, v19, v20);
                            }
                            return v53;
                          }
                          strcpy(a6, "audio/x-alaw-basic");
                          break;
                        case 1:
                          *(void *)a6 = 0x4C2F6F69647561;
                          LH_itoa(v30, __s2, 0xAu);
                          int v35 = strcat(a6, __s2);
                          strcpy(&a6[strlen(v35)], ";endian=little;rate=");
                          LH_itoa(v28, __s2, 0xAu);
                          strcat(a6, __s2);
                          if (v30 != 16)
                          {
                            log_OutPublic(*(void *)(v61 + 32), (uint64_t)"AUDIOFETCH", 145, "%s%s%s%s%s%d", v36, v37, v38, v39, "url");
                            goto LABEL_55;
                          }
                          break;
                        default:
                          log_OutPublic(*(void *)(v61 + 32), (uint64_t)"AUDIOFETCH", 148, "%s%s%s%d", v31, v32, v33, v34, "url");
                          goto LABEL_55;
                      }
                    }
                    unsigned int v21 = ssftriff_reader_CloseChunk((uint64_t)v60);
                    if ((v21 & 0x80000000) != 0) {
                      goto LABEL_34;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t Au2PCM(_WORD *a1, int a2, unsigned char *a3, _DWORD *a4, unsigned int a5, char *a6, void *a7, unsigned int *a8, int a9)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  uint64_t v44 = 0;
  if (!a3) {
    return 2269126663;
  }
  uint64_t result = 2269126663;
  if (!a8) {
    return result;
  }
  if (!a7) {
    return result;
  }
  if (!a6) {
    return result;
  }
  if (!a5) {
    return result;
  }
  if (!a4) {
    return result;
  }
  if (!*a3) {
    return result;
  }
  *a6 = 0;
  *a7 = 0;
  *a8 = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v44);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  if (*a4 == 1684960046)
  {
    if (a5 <= 0xBF)
    {
      log_OutPublic(*(void *)(v44 + 32), (uint64_t)"AUDIOFETCH", 101, "%s%s", v17, v18, v19, v20, "url");
      return 2269126660;
    }
    unsigned int v21 = bswap32(a4[1]);
    unsigned int v25 = bswap32(a4[2]);
    unsigned int v22 = bswap32(a4[3]);
    unsigned int v24 = bswap32(a4[4]);
    unsigned int v23 = bswap32(a4[5]);
  }
  else
  {
    unsigned int v21 = 0;
    if (a9) {
      unsigned int v22 = 27;
    }
    else {
      unsigned int v22 = 1;
    }
    unsigned int v23 = 1;
    unsigned int v24 = 8000;
    unsigned int v25 = a5;
  }
  unsigned int v42 = v25;
  unsigned int v43 = v21;
  log_OutText(*(void *)(v44 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Sun Au %s: encoding %u, %u channels, %u HZ, %u data offset, %u data size", v18, v19, v20, (uint64_t)a3);
  uint64_t v30 = v44;
  if (v23 != 1)
  {
    log_OutPublic(*(void *)(v44 + 32), (uint64_t)"AUDIOFETCH", 102, "%s%s%s%u", v26, v27, v28, v29, "url");
    return 2269126660;
  }
  if (v22 == 1)
  {
    unsigned int v32 = v42;
    unsigned int v31 = v43;
    if (v24 != 8000)
    {
      log_OutPublic(*(void *)(v44 + 32), (uint64_t)"AUDIOFETCH", 104, "%s%s%s%s%s%u", v26, v27, v28, v29, "url");
      return 2269126660;
    }
    strcpy(a6, "audio/basic");
  }
  else
  {
    unsigned int v32 = v42;
    unsigned int v31 = v43;
    if (v22 == 27)
    {
      if (v24 != 8000)
      {
        log_OutPublic(*(void *)(v44 + 32), (uint64_t)"AUDIOFETCH", 103, "%s%s%s%s%s%u", v26, v27, v28, v29, "url");
        return 2269126660;
      }
      strcpy(a6, "audio/x-alaw-basic");
    }
    else
    {
      if (v22 != 3)
      {
        log_OutPublic(*(void *)(v44 + 32), (uint64_t)"AUDIOFETCH", 105, "%s%s%s%u", v26, v27, v28, v29, "url");
        return 2269126660;
      }
      strcpy(a6, "audio/L16;endian=big;rate=");
      unsigned int v33 = v24;
      uint64_t v34 = v30;
      LH_itoa(v33, __s2, 0xAu);
      strcat(a6, __s2);
      uint64_t v30 = v34;
      unsigned int v32 = v42;
      unsigned int v31 = v43;
    }
  }
  if (!v32)
  {
    log_OutPublic(*(void *)(v30 + 32), (uint64_t)"AUDIOFETCH", 106, "%s%s", v26, v27, v28, v29, "url");
    return 2269126660;
  }
  if (v32 + v31 > a5)
  {
    log_OutPublic(*(void *)(v30 + 32), (uint64_t)"AUDIOFETCH", 107, "%s%s", v26, v27, v28, v29, "url");
    return 2269126660;
  }
  size_t v35 = v32;
  unsigned int v36 = v32;
  uint64_t v37 = (void *)heap_Alloc(*(void *)(v44 + 8), v32);
  *a7 = v37;
  if (v37)
  {
    memcpy(v37, (char *)a4 + v43, v35);
    uint64_t result = 0;
    *a8 = v36;
  }
  else
  {
    log_OutPublic(*(void *)(v44 + 32), (uint64_t)"AUDIOFETCH", 108, "%s%lu", v38, v39, v40, v41, "sizeBytes");
    return 2269126666;
  }
  return result;
}

uint64_t audiofetch_LoadAPDB(uint64_t a1, int a2, const char *a3)
{
  uint64_t v21 = 0;
  uint64_t ReadOnly = 2269126663;
  if (a3)
  {
    if (*a3)
    {
      uint64_t ReadOnly = safeh_HandleCheck(a1, a2, 702, 64);
      if ((ReadOnly & 0x80000000) == 0 && !strncmp(a3, "x-vocalizer-speechbase://", 0x19uLL))
      {
        uint64_t v6 = a3 + 25;
        long long v24 = 0u;
        long long v25 = 0u;
        long long v22 = 0u;
        long long v23 = 0u;
        int v7 = strlen(a3 + 25);
        XML_Status v8 = (char *)heap_Alloc(*(void *)(*(void *)(a1 + 16) + 8), (v7 + 1));
        if (v8)
        {
          uint64_t v13 = (uint64_t)v8;
          strcpy(v8, v6);
          uint64_t ReadOnly = ssftmap_FindReadOnly(*(void *)(a1 + 48), v13, &v21);
          if ((ReadOnly & 0x80000000) != 0)
          {
            long long v24 = 0u;
            long long v25 = 0u;
            long long v22 = 0u;
            long long v23 = 0u;
            long long v23 = *(_OWORD *)a1;
            long long v24 = *(_OWORD *)(a1 + 16);
            LOWORD(v22) = GetEngineFreq(a1);
            *((void *)&v22 + 1) = v13;
            uint64_t v14 = ssftmap_Insert(*(void *)(a1 + 48), v13, (uint64_t)&v22);
            if ((v14 & 0x80000000) != 0)
            {
              uint64_t ReadOnly = v14;
              log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 155, "%s%s", v15, v16, v17, v18, "speechbase");
            }
            else
            {
              uint64_t ReadOnly = ssftmap_FindReadOnly(*(void *)(a1 + 48), v13, &v21);
            }
          }
          heap_Free(*(void **)(*(void *)(a1 + 16) + 8), v13);
        }
        else
        {
          log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 100, 0, v9, v10, v11, v12, v20);
          return 2269126666;
        }
      }
    }
  }
  return ReadOnly;
}

uint64_t GetEngineFreq(uint64_t a1)
{
  unsigned int v4 = 0;
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 40);
  if (!v1 || (paramc_ParamGetUInt(v1, (uint64_t)"frequencyhz", &v4) & 0x80000000) != 0) {
    return 0;
  }
  else {
    return (unsigned __int16)v4;
  }
}

uint64_t audiofetch_ReleaseAPDB(uint64_t a1, int a2, const char *a3)
{
  uint64_t v13 = 0;
  uint64_t v5 = safeh_HandleCheck(a1, a2, 702, 64);
  if ((v5 & 0x80000000) == 0 && !strncmp(a3, "x-vocalizer-speechbase://", 0x19uLL))
  {
    uint64_t v6 = ssftmap_IteratorOpen(*(void *)(a1 + 48), 0, 0, (uint64_t)&v13);
    if ((v6 & 0x80000000) != 0) {
      return v6;
    }
    uint64_t v11 = 0;
    __s2 = 0;
    int v7 = a3 + 25;
    while (1)
    {
      while (1)
      {
        int v8 = ssftmap_IteratorNext(v13, &__s2, &v11);
        if (v8 < 0)
        {
LABEL_12:
          int v9 = ssftmap_IteratorClose((uint64_t)v13);
          return v9 & (v9 >> 31);
        }
        if (!v8) {
          break;
        }
LABEL_9:
        if (v8 < 0) {
          goto LABEL_12;
        }
      }
      if (strcmp(v7, __s2))
      {
        int v8 = 0;
        goto LABEL_9;
      }
      if ((ssftmap_IteratorRemove(v13) & 0x80000000) != 0) {
        goto LABEL_12;
      }
    }
  }
  return v5;
}

uint64_t audiofetch_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2269126657;
  }
  uint64_t result = 0;
  *a2 = &ITFAudioUri;
  return result;
}

uint64_t audiofetch_ClassOpen(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t v5 = 0;
  if (!a3) {
    return 2269126663;
  }
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v5);
  if ((result & 0x80000000) == 0)
  {
    *(void *)a3 = v5;
    *(_DWORD *)(a3 + 8) = 701;
  }
  return result;
}

uint64_t audiofetch_ClassClose()
{
  return 0;
}

uint64_t audiofetch_ObjOpen(uint64_t a1, int a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v34 = 0;
  *(void *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  uint64_t inited = InitRsrcFunction(a3, a4, &v34);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t v11 = 2269126664;
  if ((safeh_HandleCheck(a1, a2, 701, 408) & 0x80000000) == 0)
  {
    log_OutText(*(void *)(v34 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Entering audiofetch_ObjOpen", v12, v13, v14, v31);
    uint64_t v15 = heap_Calloc(*(void **)(v34 + 8), 1, 64);
    if (v15)
    {
      unsigned int v20 = (void *)v15;
      *(void *)uint64_t v15 = a3;
      *(void *)(v15 + 8) = a4;
      uint64_t v21 = v34;
      *(void *)(v15 + 16) = v34;
      *(void *)(v15 + 24) = a1;
      *(_DWORD *)(v15 + 32) = 1;
      *(_DWORD *)(v15 + 56) = 1;
      long long v22 = *(void **)(v21 + 8);
      long long v31 = xmmword_26C21F830;
      long long v32 = *(_OWORD *)&off_26C21F840;
      unsigned int v33 = off_26C21F850;
      uint64_t v23 = ssftmap_ObjOpen(v22, 0, &v31, v20 + 5);
      uint64_t v28 = v20[2];
      if ((v23 & 0x80000000) != 0)
      {
        uint64_t v11 = v23;
      }
      else
      {
        uint64_t v29 = *(void **)(v28 + 8);
        long long v31 = xmmword_26C21F858;
        long long v32 = *(_OWORD *)off_26C21F868;
        unsigned int v33 = off_26C21F878;
        uint64_t v11 = ssftmap_ObjOpen(v29, 0, &v31, v20 + 6);
        if ((v11 & 0x80000000) == 0)
        {
          *(void *)a5 = v20;
          *(_DWORD *)(a5 + 8) = 702;
LABEL_12:
          log_OutText(*(void *)(v34 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Exiting audiofetch_ObjOpen", v25, v26, v27, v31);
          return v11;
        }
        uint64_t v28 = v20[2];
      }
      log_OutPublic(*(void *)(v28 + 32), (uint64_t)"AUDIOFETCH", 130, 0, v24, v25, v26, v27, v31);
      *(void *)a5 = v20;
      *(_DWORD *)(a5 + 8) = 702;
      audiofetch_ObjClose(v20, *(void *)(a5 + 8));
      *(void *)a5 = 0;
      *(_DWORD *)(a5 + 8) = 0;
      goto LABEL_12;
    }
    log_OutPublic(*(void *)(v34 + 32), (uint64_t)"AUDIOFETCH", 100, 0, v16, v17, v18, v19, v31);
    uint64_t v11 = 2269126666;
    goto LABEL_12;
  }
  return v11;
}

uint64_t audiofetch_ObjClose(void *a1, int a2)
{
  uint64_t v6 = safeh_HandleCheck((uint64_t)a1, a2, 702, 64);
  if ((v6 & 0x80000000) == 0)
  {
    log_OutText(*(void *)(a1[2] + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Entering audiofetch_ObjClose", v3, v4, v5, v13);
    uint64_t v10 = a1[6];
    if (v10) {
      uint64_t v6 = ssftmap_ObjClose(v10);
    }
    uint64_t v11 = a1[5];
    if (v11) {
      uint64_t v6 = ssftmap_ObjClose(v11);
    }
    log_OutText(*(void *)(a1[2] + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Exiting audiofetch_ObjClose", v7, v8, v9, v14);
    heap_Free(*(void **)(a1[2] + 8), (uint64_t)a1);
  }
  return v6;
}

uint64_t audiofetch_ObjReopen(uint64_t a1, int a2)
{
  unsigned __int16 v21 = 0;
  uint64_t v19 = 0;
  unsigned int v20 = 0;
  uint64_t v18 = 0;
  uint64_t v3 = safeh_HandleCheck(a1, a2, 702, 64);
  if ((v3 & 0x80000000) != 0) {
    return v3;
  }
  log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Entering audiofetch_ObjReopen", v4, v5, v6, v18);
  int EngineFreq = GetEngineFreq(a1);
  int v8 = ssftmap_IteratorOpen(*(void *)(a1 + 48), 0, 0, (uint64_t)&v20);
  if ((v8 & 0x80000000) == 0)
  {
    while (1)
    {
      int v12 = ssftmap_IteratorNext(v20, &v19, &v18);
      if (v12 < 0) {
        break;
      }
      int v13 = (*(uint64_t (**)(void, unsigned __int16 *))(*(void *)(v18 + 48) + 88))(*(void *)(v18 + 56), &v21);
      if (v13 < 0 || (int v14 = v13, v21 != EngineFreq))
      {
        int v14 = ssftmap_IteratorRemove(v20);
        if (v14 < 0) {
          goto LABEL_12;
        }
      }
      else if (v13 < 0)
      {
        goto LABEL_12;
      }
    }
    int v14 = v12;
LABEL_12:
    int v8 = ssftmap_IteratorClose((uint64_t)v20);
    if (v8 >= 0 || (v14 & 0x1FFF) != 23) {
      int v8 = v14;
    }
  }
  if ((v8 & 0x1FFF) == 0x17) {
    uint64_t v15 = 0;
  }
  else {
    uint64_t v15 = v8;
  }
  log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Exiting audiofetch_ObjReopen", v9, v10, v11, v18);
  return v15;
}

uint64_t audiofetch_Reset(uint64_t a1, int a2)
{
  unsigned int v5 = 0;
  uint64_t result = safeh_HandleCheck(a1, a2, 702, 64);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 16) + 40);
    if (v4)
    {
      uint64_t result = paramc_ParamGetUInt(v4, (uint64_t)"pipelineswitchexecuting", &v5);
      if ((result & 0x80000000) != 0)
      {
        unsigned int v5 = 0;
      }
      else if (v5 == 1)
      {
        return result;
      }
    }
    uint64_t result = ssftmap_Clear(*(void *)(a1 + 40));
    *(_DWORD *)(a1 + 32) = 1;
  }
  return result;
}

uint64_t audiofetch_Fetch(uint64_t a1, int a2, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, void *a7)
{
  return fetchAudio(a1, a2, a3, a4, a7, 0);
}

uint64_t audiofetch_Release(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t result = safeh_HandleCheck(a1, a2, 702, 64);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v6 = *(void *)(a1 + 40);
    return ssftmap_Remove(v6, a3);
  }
  return result;
}

uint64_t audiofetch_FetchStreamOpen(void *a1, int a2, uint64_t a3, void *a4, _DWORD *a5, _DWORD *a6, uint64_t a7)
{
  uint64_t v67 = 0;
  *a4 = 0;
  *a5 = 0;
  *(void *)a7 = 0;
  *(_DWORD *)(a7 + 8) = 0;
  uint64_t v13 = safeh_HandleCheck((uint64_t)a1, a2, 702, 64);
  if ((v13 & 0x80000000) != 0) {
    return v13;
  }
  uint64_t ReadOnly = ssftmap_FindReadOnly(a1[5], a3, &v67);
  if ((ReadOnly & 0x80000000) == 0)
  {
    uint64_t v15 = (void *)heap_Calloc(*(void **)(a1[2] + 8), 1, 96);
    uint64_t v20 = a1[2];
    if (!v15)
    {
      log_OutPublic(*(void *)(v20 + 32), (uint64_t)"AUDIOFETCH", 100, 0, v16, v17, v18, v19, v66);
      return 2269126666;
    }
    unsigned __int16 v21 = v15;
    *uint64_t v15 = v20;
    v15[1] = a1;
    uint64_t v22 = v67;
    v15[2] = v67;
    uint64_t v23 = *(void *)(v22 + 40);
    if (v23)
    {
      uint64_t ReadOnly = (*(uint64_t (**)(uint64_t, void, void))(*(void *)(v22 + 32) + 48))(v23, *(unsigned int *)(v22 + 48), *(unsigned int *)(v22 + 16));
      if ((ReadOnly & 0x80000000) != 0) {
        log_OutPublic(*(void *)(a1[2] + 32), (uint64_t)"AUDIOFETCH", 157, "%s%s%s%x", v24, v25, v26, v27, "uri");
      }
    }
    else
    {
      int v28 = *(_DWORD *)(v22 + 76);
      if (v28 != 3)
      {
        uint64_t v29 = 0;
        while (AudioFetchDecoderIndex[v29] != v28)
        {
          v29 += 6;
          if ((v29 * 4) == 96)
          {
            log_OutPublic(*(void *)(v20 + 32), (uint64_t)"AUDIOFETCH", 162, "%s%s%s%d", v16, v17, v18, v19, "uri");
            uint64_t ReadOnly = 2269126657;
            goto LABEL_19;
          }
        }
        uint64_t v30 = &AudioFetchDecoderIndex[v29];
        uint64_t v31 = brk_InterfaceQuery(*(void *)(v20 + 24));
        if ((v31 & 0x80000000) != 0)
        {
          uint64_t ReadOnly = v31;
          log_OutPublic(*(void *)(a1[2] + 32), (uint64_t)"AUDIOFETCH", 160, "%s%s%s%s%s%x", v32, v33, v34, v35, "decoder");
        }
        else
        {
          uint64_t ReadOnly = (*(uint64_t (**)(void, void, void, void, void, void, void, void *))(v21[3] + 32))(v30[4], 0, *a1, a1[1], 0, 0, 0, v21 + 4);
          if ((ReadOnly & 0x80000000) != 0) {
            log_OutPublic(*(void *)(a1[2] + 32), (uint64_t)"AUDIOFETCH", 161, "%s%s%s%s%s%x", v36, v37, v38, v39, "decoder");
          }
        }
      }
    }
LABEL_19:
    if (*(_DWORD *)(v67 + 80) != 1)
    {
LABEL_36:
      if ((ReadOnly & 0x80000000) == 0)
      {
        uint64_t v63 = v67;
        *a4 = *(void *)(v67 + 24);
        int v64 = *(_DWORD *)(v63 + 16);
        *a5 = v64;
        if (*(_DWORD *)(v63 + 80) == 1) {
          int v64 = *((_DWORD *)v21 + 22);
        }
        *a6 = v64;
        *(void *)a7 = v21;
        *(_DWORD *)(a7 + 8) = 703;
        return ReadOnly;
      }
LABEL_41:
      *(void *)a7 = v21;
      *(_DWORD *)(a7 + 8) = 703;
      audiofetch_FetchStreamClose(v21, *(void *)(a7 + 8), 0);
      *(void *)a7 = 0;
      *(_DWORD *)(a7 + 8) = 0;
      return ReadOnly;
    }
    unint64_t v40 = *(unsigned int *)(v67 + 16);
    int v68 = 0;
    uint64_t v41 = v21[2];
    unsigned int v42 = *(unsigned __int16 *)(v41 + 68);
    uint64_t v43 = *(unsigned __int16 *)(v41 + 70);
    unsigned int v44 = v42;
    if (*(_WORD *)(v41 + 70))
    {
      unsigned int v45 = *(unsigned __int16 *)(v41 + 70);
      unsigned int v46 = v42;
      do
      {
        unsigned int v44 = v45;
        unsigned int v45 = v46 % v45;
        unsigned int v46 = v44;
      }
      while (v45);
    }
    uint64_t v47 = (void *)v21[8];
    if (v47)
    {
      spxrsmp_resampler_destroy(v47);
      v21[8] = 0;
      uint64_t v48 = v21[2];
      unsigned int v42 = *(unsigned __int16 *)(v48 + 68);
      uint64_t v43 = *(unsigned __int16 *)(v48 + 70);
    }
    uint64_t v49 = spxrsmp_resampler_init(*v21, 1u, v42, v43, 7u, &v68);
    v21[8] = v49;
    if (!v68 && v49)
    {
      uint64_t v54 = v21[2];
      unsigned int v55 = *(unsigned __int16 *)(v54 + 70) / v44;
      *((_WORD *)v21 + 28) = v55;
      unint64_t v56 = *(unsigned __int16 *)(v54 + 68) / v44;
      *((_WORD *)v21 + 29) = v56;
      *((_DWORD *)v21 + 18) = 1;
      unint64_t v57 = v40 * (unint64_t)v55 / v56 + 16;
      if (v57 <= v40) {
        unint64_t v57 = v40;
      }
      unint64_t v58 = 2 * v57;
      uint64_t v59 = v21[10];
      if (v59)
      {
        long long v60 = v21 + 11;
        if (v21[11] >= v58) {
          goto LABEL_36;
        }
        uint64_t v61 = heap_Realloc(*(uint64_t **)(*(void *)(v21[1] + 16) + 8), v59, v58);
        if (v61)
        {
          v21[10] = v61;
LABEL_35:
          *long long v60 = v58;
          goto LABEL_36;
        }
      }
      else
      {
        uint64_t v62 = heap_Alloc(*(void *)(*(void *)(v21[1] + 16) + 8), v58);
        v21[10] = v62;
        if (v62)
        {
          long long v60 = v21 + 11;
          goto LABEL_35;
        }
      }
    }
    uint64_t ReadOnly = 2269126656;
    v21[8] = 0;
    log_OutPublic(*(void *)(a1[2] + 32), (uint64_t)"AUDIOFETCH", 137, "%s%s%s%hu%s%hu", v50, v51, v52, v53, "uri");
    goto LABEL_41;
  }
  return ReadOnly;
}

uint64_t audiofetch_FetchStreamRead(uint64_t a1, int a2, unsigned int a3, uint64_t a4, unsigned int *a5, unsigned int *a6)
{
  unsigned int v51 = a3;
  int v49 = 0;
  *a5 = 0;
  uint64_t v11 = safeh_HandleCheck(a1, a2, 703, 96);
  if ((v11 & 0x80000000) != 0) {
    return v11;
  }
  unsigned int v12 = a3;
  uint64_t v13 = a5;
  int v14 = (_WORD *)a4;
  if (*(_DWORD *)(a1 + 72) == 1)
  {
    int v14 = *(_WORD **)(a1 + 80);
    uint64_t v13 = (unsigned int *)&v49;
    unsigned int v12 = *(unsigned __int16 *)(a1 + 58) * a3 / *(unsigned __int16 *)(a1 + 56);
  }
  uint64_t v15 = 2269126663;
  unsigned int v50 = v12;
  if (!a4 || !a3) {
    return 2269126663;
  }
  uint64_t v16 = *(unsigned int *)(a1 + 48);
  uint64_t v17 = *(void *)(a1 + 16);
  unsigned int v18 = *(_DWORD *)(v17 + 16);
  if (v18 <= v16) {
    return 2269126659;
  }
  unsigned int v19 = v18 - v16;
  if (v19 < v12)
  {
    unsigned int v50 = v19;
    unsigned int v12 = v19;
  }
  if (!*(void *)(v17 + 40))
  {
    if (*(void *)(a1 + 24))
    {
      if (v12)
      {
        do
        {
          uint64_t v30 = *(void *)(a1 + 16);
          uint64_t v31 = *(void *)(a1 + 24);
          int v32 = *(unsigned __int16 *)(v30 + 72);
          __int16 v33 = v12 * v32;
          if (v12 * v32 >= 0xFFFF) {
            __int16 v33 = -1;
          }
          LOWORD(v48) = v33;
          if (v12 >> 15) {
            __int16 v34 = -1;
          }
          else {
            __int16 v34 = 2 * v12;
          }
          unsigned __int16 v47 = v34;
          __int16 v46 = 0;
          uint64_t v11 = (*(uint64_t (**)(void, void, void, void, unsigned int *, void, _WORD *, unsigned __int16 *, void, __int16 *, const char *, uint64_t))(v31 + 112))(*(void *)(a1 + 32), *(void *)(a1 + 40), 0, *(void *)(v30 + 56) + (*(_DWORD *)(a1 + 48) * v32), &v48, 0, &v14[*v13], &v47, 0, &v46, v44, v45);
          if ((v11 & 0x80000000) != 0 || !(_WORD)v48)
          {
            unsigned int v44 = "lhError";
            uint64_t v45 = v11;
            log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"AUDIOFETCH", 163, "%s%s%s%x", v35, v36, v37, v38, "uri");
            unsigned int v12 = v50;
          }
          else
          {
            unsigned int v39 = v47;
            *(_DWORD *)(a1 + 48) += v47 >> 1;
            *v13 += v39 >> 1;
            unsigned int v12 = v50 - (v39 >> 1);
            unsigned int v50 = v12;
          }
        }
        while ((v11 & 0x80000000) == 0 && v12);
        uint64_t v15 = 2269126663;
        if ((v11 & 0x80000000) != 0) {
          return v11;
        }
      }
      *a5 = *v13;
      if (*(_DWORD *)(*(void *)(a1 + 16) + 80) != 1)
      {
        *a6 = *v13;
        return v11;
      }
      uint64_t v40 = *(void *)(a1 + 64);
      uint64_t v41 = v14;
      unsigned int v42 = v13;
    }
    else
    {
      memcpy(v14, (const void *)(*(void *)(v17 + 56) + 2 * v16), 2 * v12);
      *(_DWORD *)(a1 + 48) += v12;
      *a5 = v12;
      if (*(_DWORD *)(*(void *)(a1 + 16) + 80) != 1)
      {
        *a6 = v12;
        return v11;
      }
      uint64_t v40 = *(void *)(a1 + 64);
      unsigned int v42 = &v50;
      uint64_t v41 = v14;
    }
    unsigned int v43 = spxrsmp_resampler_process_int(v40, 0, v41, v42, a4, &v51);
    if (v43 <= 2) {
      uint64_t v15 = dword_20D6B24A0[v43];
    }
    *a6 = v51;
    return v15;
  }
  unsigned int v48 = v12;
  if (v12)
  {
    while (1)
    {
      uint64_t v11 = (*(uint64_t (**)(void, unsigned int *, _WORD *))(*(void *)(*(void *)(a1 + 16) + 32) + 72))(*(void *)(*(void *)(a1 + 16) + 40), &v48, &v14[*v13]);
      if ((v11 & 0x80000000) != 0) {
        break;
      }
      unsigned int v24 = v48;
      unsigned int v25 = v50;
      *v13 += v48;
      unsigned int v50 = v25 - v24;
      if (v25 == v24) {
        goto LABEL_13;
      }
    }
    log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"AUDIOFETCH", 158, "%s%s%s%x", v20, v21, v22, v23, "uri");
  }
  else
  {
LABEL_13:
    *a5 = *v13;
    if (*(_DWORD *)(*(void *)(a1 + 16) + 80) == 1)
    {
      int v26 = spxrsmp_resampler_process_int(*(void *)(a1 + 64), 0, v14, v13, a4, &v51);
      unsigned int v27 = -2025840623;
      int v28 = -2025840630;
      if (v26 != 1) {
        int v28 = -2025840633;
      }
      if (v26 != 2) {
        unsigned int v27 = v28;
      }
      uint64_t v13 = &v51;
      if (v26) {
        uint64_t v11 = v27;
      }
      else {
        uint64_t v11 = 0;
      }
    }
    *a6 = *v13;
    *(_DWORD *)(a1 + 48) += *a5;
  }
  return v11;
}

uint64_t audiofetch_FetchStreamClose(void *a1, int a2, int a3)
{
  uint64_t v5 = safeh_HandleCheck((uint64_t)a1, a2, 703, 96);
  if ((v5 & 0x80000000) == 0)
  {
    uint64_t v6 = a1[2];
    if (*(void *)(v6 + 40))
    {
      uint64_t v5 = (*(uint64_t (**)(void))(*(void *)(v6 + 32) + 64))();
      if ((v5 & 0x80000000) != 0) {
        log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"AUDIOFETCH", 159, "%s%s%s%x", v7, v8, v9, v10, "uri");
      }
    }
    uint64_t v11 = a1[3];
    if (v11)
    {
      uint64_t v12 = a1[4];
      if (v12)
      {
        int v13 = (*(uint64_t (**)(uint64_t, void))(v11 + 40))(v12, a1[5]);
        if (v13 < 0)
        {
          int v18 = v13;
          log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"AUDIOFETCH", 164, "%s%x", v14, v15, v16, v17, "lhError");
          if ((int)v5 >= 0) {
            LODWORD(v5) = v18;
          }
        }
      }
      int v19 = brk_InterfaceRelease(*(void *)(*a1 + 24), a1[3]);
      if (v19 >= 0 || (int)v5 <= -1) {
        uint64_t v5 = v5;
      }
      else {
        uint64_t v5 = v19;
      }
    }
    if (*(_DWORD *)(a1[2] + 80) == 1)
    {
      spxrsmp_resampler_destroy((void *)a1[8]);
      uint64_t v21 = a1[10];
      if (v21) {
        heap_Free(*(void **)(*(void *)(a1[1] + 16) + 8), v21);
      }
      a1[10] = 0;
      a1[11] = 0;
      a1[8] = 0;
      *((_DWORD *)a1 + 18) = 0;
    }
    if (a3)
    {
      int v22 = ssftmap_Remove(*(void *)(a1[1] + 40), *(void *)(a1[2] + 8));
      if (v22 >= 0 || (int)v5 <= -1) {
        uint64_t v5 = v5;
      }
      else {
        uint64_t v5 = v22;
      }
    }
    heap_Free(*(void **)(*a1 + 8), (uint64_t)a1);
  }
  return v5;
}

uint64_t audiofetch_GetAudioURI(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  uint64_t v9 = 0;
  uint64_t result = 2269126663;
  if (a3)
  {
    if (a4)
    {
      uint64_t result = safeh_HandleCheck(a1, a2, 702, 64);
      if ((result & 0x80000000) == 0)
      {
        int ReadOnly = ssftmap_FindReadOnly(*(void *)(a1 + 40), a3, &v9);
        uint64_t result = 0;
        if ((ReadOnly & 0x80000000) == 0)
        {
          if (v9)
          {
            uint64_t result = 0;
            *a4 = *(void *)(v9 + 24);
          }
        }
      }
    }
  }
  return result;
}

uint64_t audiofetch_FetchSsml(uint64_t a1, int a2, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, void *a7)
{
  return fetchAudio(a1, a2, a3, a4, a7, 1);
}

uint64_t audiofetch_ElemCopyAudioVarLenBuf(_WORD *a1, uint64_t a2, void *a3)
{
  if (!a1) {
    return 2269126663;
  }
  uint64_t result = 0;
  ++*a1;
  *a3 = a1;
  return result;
}

void *audiofetch_ElemFreeAudioVarLenBuf(void *result, void *a2)
{
  if (result)
  {
    uint64_t v2 = (uint64_t)result;
    unsigned int v3 = *(unsigned __int16 *)result;
    if (v3 < 2)
    {
      uint64_t v5 = result[1];
      if (v5) {
        heap_Free(a2, v5);
      }
      uint64_t v6 = *(void *)(v2 + 24);
      if (v6) {
        heap_Free(a2, v6);
      }
      uint64_t v7 = *(void *)(v2 + 56);
      if (v7) {
        heap_Free(a2, v7);
      }
      return heap_Free(a2, v2);
    }
    else
    {
      *(_WORD *)uint64_t result = v3 - 1;
    }
  }
  return result;
}

uint64_t audiofetch_ElemCopySpeechBase(long long *a1, void *a2, uint64_t *a3)
{
  uint64_t v3 = 2269126663;
  if (a1)
  {
    uint64_t v7 = (_OWORD *)heap_Calloc(a2, 1, 64);
    if (v7)
    {
      uint64_t v8 = (uint64_t)v7;
      long long v9 = *a1;
      long long v10 = a1[1];
      long long v11 = a1[3];
      v7[2] = a1[2];
      v7[3] = v11;
      *uint64_t v7 = v9;
      v7[1] = v10;
      uint64_t v12 = v7 + 3;
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      uint64_t v13 = brk_InterfaceQuery(*(void *)(*((void *)v7 + 4) + 24));
      if ((v13 & 0x80000000) != 0)
      {
        uint64_t v3 = v13;
      }
      else
      {
        uint64_t v14 = (*(uint64_t (**)(void, void, void, void, uint64_t))(*(void *)(v8 + 48) + 32))(*(void *)(v8 + 16), *(void *)(v8 + 24), *(void *)(v8 + 40), *(void *)(v8 + 8), v8 + 56);
        if ((v14 & 0x80000000) != 0)
        {
          uint64_t v20 = v14;
          brk_InterfaceRelease(*(void *)(*(void *)(v8 + 32) + 24), *(void *)(v8 + 48));
          *(void *)(v8 + 48) = 0;
          uint64_t v3 = v20;
        }
        else
        {
          __int16 v22 = 0;
          uint64_t v15 = (*(uint64_t (**)(void, __int16 *))(*(void *)v12 + 88))(*(void *)(v8 + 56), &v22);
          if ((v15 & 0x80000000) == 0 && v22 == *(_WORD *)v8)
          {
            uint64_t v3 = v15;
LABEL_13:
            *a3 = v8;
            return v3;
          }
          log_OutPublic(*(void *)(*(void *)(v8 + 32) + 32), (uint64_t)"AUDIOFETCH", 134, "%s%s", v16, v17, v18, v19, "speechbase");
          (*(void (**)(uint64_t))(*(void *)(v8 + 48) + 40))(v8 + 56);
          *(void *)(v8 + 56) = 0;
          brk_InterfaceRelease(*(void *)(*(void *)(v8 + 32) + 24), *(void *)(v8 + 48));
          *(void *)(v8 + 48) = 0;
          uint64_t v3 = 2269126681;
        }
      }
      heap_Free(a2, v8);
      uint64_t v8 = 0;
      goto LABEL_13;
    }
    return 2269126666;
  }
  return v3;
}

void *audiofetch_ElemFreeSpeechBase(void *result, void *a2)
{
  if (result)
  {
    uint64_t v3 = result;
    uint64_t v4 = result[6];
    if (v4)
    {
      uint64_t v5 = result + 7;
      if (v3[7])
      {
        (*(void (**)(void *))(v4 + 40))(v5);
        uint64_t v4 = v3[6];
      }
      brk_InterfaceRelease(*(void *)(v3[4] + 24), v4);
    }
    return heap_Free(a2, (uint64_t)v3);
  }
  return result;
}

uint64_t fetchAudio(uint64_t a1, int a2, uint64_t a3, char *a4, void *a5, int a6)
{
  uint64_t v6 = 2269126666;
  uint64_t ReadOnly = 2269126663;
  if (a3 && a5 && *(unsigned char *)a3)
  {
    *a5 = 0;
    uint64_t v13 = safeh_HandleCheck(a1, a2, 702, 64);
    if ((v13 & 0x80000000) == 0)
    {
      log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Entering audiofetch_Fetch for URI \"%s\"", v14, v15, v16, a3);
      log_OutTraceTuningData(*(uint64_t ***)(*(void *)(a1 + 16) + 32), 311, (uint64_t)"%s%s %s%s %s%s", v17, v18, v19, v20, v21, "BEG");
      if (strncmp((const char *)a3, "x-vocalizer-speechbase://", 0x19uLL))
      {
        if (a4)
        {
          if (!strncmp(a4, "cup:", 4uLL))
          {
            *(void *)&long long v99 = 0;
            size_t v96 = 0;
            LODWORD(__endptr) = 0;
            MimeTypeFromURI = (char *)audiofetch_GetMimeTypeFromURI((char *)a3);
            size_t v75 = strlen((const char *)a3);
            size_t v76 = strlen(a4);
            uint64_t v77 = heap_Alloc(*(void *)(*(void *)(a1 + 16) + 8), v75 + v76 + 1);
            if (v77)
            {
              uint64_t v67 = (char *)v77;
              if (!strncmp(a4, "cup:", 4uLL))
              {
                sprintf(v67, "%s:%s", a4 + 4, (const char *)a3);
                uint64_t v89 = strrchr(v67, 46);
                if (v89) {
                  *uint64_t v89 = 0;
                }
                uint64_t v90 = brk_DataOpenEx(*(void *)(*(void *)(a1 + 16) + 24), (uint64_t)v67, 0, (uint64_t)&v99);
                uint64_t v91 = v99;
                if ((v90 & 0x80000000) != 0)
                {
                  uint64_t v6 = v90;
                }
                else
                {
                  uint64_t v92 = brk_DataMapEx(*(void *)(*(void *)(a1 + 16) + 24), v99, 0, (uint64_t)&__endptr, (uint64_t)&v96);
                  int v93 = v96;
                  if ((v92 & 0x80000000) != 0)
                  {
                    uint64_t v6 = v92;
                  }
                  else
                  {
                    uint64_t v6 = audiofetch_PrepareAudioTask((_WORD **)a1, (char *)a3, MimeTypeFromURI, v96, __endptr, a5);
                    int v93 = v96;
                  }
                  uint64_t v91 = v99;
                  if (v93)
                  {
                    brk_DataUnmap(*(void *)(*(void *)(a1 + 16) + 24), v99, (uint64_t)v93);
                    uint64_t v91 = v99;
                  }
                }
                if (v91) {
                  brk_DataClose(*(void *)(*(void *)(a1 + 16) + 24), v91);
                }
              }
              else
              {
                uint64_t v6 = 2269126674;
              }
LABEL_54:
              heap_Free(*(void **)(*(void *)(a1 + 16) + 8), (uint64_t)v67);
              goto LABEL_55;
            }
            goto LABEL_55;
          }
          *(void *)&long long v99 = 0;
          LODWORD(__endptr) = 0;
          size_t v96 = 0;
          size_t v22 = strlen(a4);
          BOOL v23 = a6 != 0;
          if (v22)
          {
            size_t v24 = v22;
            if (IsThisUrlOrRealPath(a4, 0))
            {
              while (1)
              {
                int v25 = a4[v24];
                if (v25 == 47) {
                  break;
                }
                if (v25 == 92 || &a4[v24] <= a4) {
                  break;
                }
                --v24;
              }
              long long v78 = (char *)heap_Alloc(*(void *)(*(void *)(a1 + 16) + 8), v24 + 2);
              if (!v78) {
                goto LABEL_55;
              }
              uint64_t v67 = v78;
              int v79 = strncpy(v78, a4, v24 + 1);
              v79[v24 + 1] = 0;
              size_t v80 = strlen(v79);
              size_t v81 = strlen((const char *)a3);
              uint64_t v82 = (char *)heap_Alloc(*(void *)(*(void *)(a1 + 16) + 8), v80 + v81 + 1);
              if (!v82) {
                goto LABEL_54;
              }
              unsigned int v66 = v82;
              UriCompleteUrl(v67, (char *)a3, v82);
              goto LABEL_33;
            }
          }
        }
        else
        {
          *(void *)&long long v99 = 0;
          LODWORD(__endptr) = 0;
          size_t v96 = 0;
          BOOL v23 = a6 != 0;
        }
        size_t v61 = strlen((const char *)a3);
        uint64_t v62 = (char *)heap_Alloc(*(void *)(*(void *)(a1 + 16) + 8), v61 + 1);
        if (v62)
        {
          unsigned int v66 = v62;
          uint64_t v67 = 0;
          strncpy(v62, (const char *)a3, v61)[v61] = 0;
LABEL_33:
          int v68 = (char *)audiofetch_GetMimeTypeFromURI(v66);
          long long v69 = strrchr(v66, 63);
          if (v69) {
            *long long v69 = 0;
          }
          uint64_t v70 = brk_DataOpenEx(*(void *)(*(void *)(a1 + 16) + 24), (uint64_t)v66, v23, (uint64_t)&v96);
          long long v71 = v96;
          if ((v70 & 0x80000000) != 0)
          {
            uint64_t v6 = v70;
          }
          else
          {
            uint64_t v72 = brk_DataMapEx(*(void *)(*(void *)(a1 + 16) + 24), (uint64_t)v96, 0, (uint64_t)&__endptr, (uint64_t)&v99);
            uint64_t v73 = v99;
            if ((v72 & 0x80000000) != 0)
            {
              uint64_t v6 = v72;
            }
            else
            {
              uint64_t v6 = audiofetch_PrepareAudioTask((_WORD **)a1, v66, v68, (char *)v99, __endptr, a5);
              uint64_t v73 = v99;
            }
            long long v71 = v96;
            if (v73)
            {
              brk_DataUnmap(*(void *)(*(void *)(a1 + 16) + 24), (uint64_t)v96, v73);
              long long v71 = v96;
            }
          }
          if (v71) {
            brk_DataClose(*(void *)(*(void *)(a1 + 16) + 24), (uint64_t)v71);
          }
          heap_Free(*(void **)(*(void *)(a1 + 16) + 8), (uint64_t)v66);
          if (!v67) {
            goto LABEL_55;
          }
          goto LABEL_54;
        }
LABEL_55:
        uint64_t ReadOnly = v6;
        goto LABEL_56;
      }
      __endptr = 0;
      long long v101 = 0u;
      long long v102 = 0u;
      long long v99 = 0u;
      long long v100 = 0u;
      uint64_t v98 = 0;
      int v27 = strlen((const char *)(a3 + 25));
      int v28 = (char *)heap_Alloc(*(void *)(*(void *)(a1 + 16) + 8), (v27 + 1));
      if (!v28)
      {
        log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 100, 0, v29, v30, v31, v32, v95);
        uint64_t ReadOnly = 2269126666;
LABEL_56:
        log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"Exiting audiofetch_Fetch for URI \"%s\", %x", v63, v64, v65, a3);
        log_OutTraceTuningData(*(uint64_t ***)(*(void *)(a1 + 16) + 32), 311, (uint64_t)"%s%s %s%u", v83, v84, v85, v86, v87, "END");
        return ReadOnly;
      }
      uint64_t v33 = (uint64_t)v28;
      __int16 v34 = strcpy(v28, (const char *)(a3 + 25));
      uint64_t v35 = strchr(v34, 35);
      if (v35)
      {
        uint64_t v40 = v35;
        strtoul(v35 + 1, &__endptr, 10);
        *uint64_t v40 = 0;
        uint64_t ReadOnly = ssftmap_FindReadOnly(*(void *)(a1 + 48), v33, &v98);
        if ((ReadOnly & 0x80000000) == 0)
        {
LABEL_23:
          if ((ReadOnly & 0x80000000) == 0 && v98 && *(void *)(v98 + 56))
          {
            uint64_t v46 = heap_Calloc(*(void **)(*(void *)(a1 + 16) + 8), 1, 88);
            if (v46)
            {
              uint64_t v51 = v46;
              size_t v96 = 0;
              uint64_t v97 = 0;
              *(_WORD *)uint64_t v46 = 1;
              uint64_t v52 = v98;
              uint64_t v53 = *(void *)(v98 + 48);
              *(void *)(v46 + 32) = v53;
              *(void *)(v46 + 40) = *(void *)(v52 + 56);
              *(void *)(v46 + 56) = 0;
              uint64_t v54 = (*(uint64_t (**)(void))(v53 + 80))();
              if ((v54 & 0x80000000) != 0)
              {
                uint64_t v94 = v54;
                log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 156, "%s%s%s%u%s%x", v55, v56, v57, v58, "speechbase");
                uint64_t v6 = v94;
              }
              else
              {
                int v59 = v97;
                *(_DWORD *)(v51 + 48) = HIDWORD(v96);
                *(_DWORD *)(v51 + 16) = v59;
                long long v60 = strhelper_Strdup(*(void *)(*(void *)(a1 + 16) + 8), (char *)a3);
                *(void *)(v51 + 24) = v60;
                if (v60) {
                  uint64_t v6 = AddAudioTask(a1, v51, a5);
                }
              }
              audiofetch_ElemFreeAudioVarLenBuf((void *)v51, *(void **)(*(void *)(a1 + 16) + 8));
              uint64_t ReadOnly = v6;
            }
            else
            {
              log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 100, 0, v47, v48, v49, v50, v95);
              uint64_t ReadOnly = 2269126666;
            }
          }
          goto LABEL_47;
        }
        long long v101 = 0u;
        long long v102 = 0u;
        long long v99 = 0u;
        long long v100 = 0u;
        long long v100 = *(_OWORD *)a1;
        long long v101 = *(_OWORD *)(a1 + 16);
        LOWORD(v99) = GetEngineFreq(a1);
        *((void *)&v99 + 1) = v33;
        uint64_t v41 = ssftmap_Insert(*(void *)(a1 + 48), v33, (uint64_t)&v99);
        if ((v41 & 0x80000000) == 0)
        {
          uint64_t ReadOnly = ssftmap_FindReadOnly(*(void *)(a1 + 48), v33, &v98);
          goto LABEL_23;
        }
        uint64_t ReadOnly = v41;
        log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 155, "%s%s", v42, v43, v44, v45, "speechbase");
      }
      else
      {
        log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 154, "%s%s", v36, v37, v38, v39, "uri");
      }
LABEL_47:
      heap_Free(*(void **)(*(void *)(a1 + 16) + 8), v33);
      goto LABEL_56;
    }
    return v13;
  }
  return ReadOnly;
}

uint64_t AddAudioTask(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  *a3 = 0;
  uint64_t v6 = *(const char **)(a2 + 24);
  if (v6)
  {
    unsigned int v7 = strlen(*(const char **)(a2 + 24));
    if (v7 >= 0x51)
    {
      v6 += v7 - 80;
      unsigned int v7 = strlen(v6);
    }
  }
  else
  {
    unsigned int v7 = 0;
    uint64_t v6 = &byte_20D5A22AE;
  }
  uint64_t v8 = heap_Alloc(*(void *)(*(void *)(a1 + 16) + 8), v7 + 16);
  *(void *)(a2 + 8) = v8;
  if (v8)
  {
    strcpy(__src, "__NUAN_");
    LH_utoa(*(_DWORD *)(a1 + 32), v25, 0xAu);
    __strcat_chk();
    __strcat_chk();
    strcpy(*(char **)(a2 + 8), __src);
    if (*v6)
    {
      size_t v13 = strlen(__src);
      strcpy((char *)(*(void *)(a2 + 8) + v13), v6);
    }
    uint64_t v18 = ssftmap_Insert(*(void *)(a1 + 40), *(void *)(a2 + 8), a2);
    if ((v18 & 0x80000000) != 0)
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 100, 0, v14, v15, v16, v17, v24);
    }
    else
    {
      int v19 = *(_DWORD *)(a1 + 32);
      BOOL v20 = __CFADD__(v19, 1);
      int v21 = v19 + 1;
      if (v20) {
        int v21 = 1;
      }
      *(_DWORD *)(a1 + 32) = v21;
      *a3 = *(void *)(a2 + 8);
      if (*(void *)(a2 + 40)) {
        size_t v22 = "Audio insertion %s: from %s, %u offset, %u duration";
      }
      else {
        size_t v22 = "Audio insertion %s: from %s, encoding %d, %u samples";
      }
      log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 3, 0, (uint64_t)v22, v15, v16, v17, (uint64_t)__src);
    }
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOFETCH", 100, 0, v9, v10, v11, v12, v24);
    return 2269126666;
  }
  return v18;
}

const char *audiofetch_GetMimeTypeFromURI(char *a1)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (!a1) {
    return "application/octet-stream";
  }
  size_t ExtensionFromURI = UriGetExtensionFromURI(a1, v7, 0x50uLL);
  if (ExtensionFromURI)
  {
    uint64_t v3 = (char *)ExtensionFromURI;
    uint64_t v4 = 0;
    while (LH_stricmp(v3, audiofetch_GetMimeTypeFromURI_EXT_TO_MIMETYPE_CONVERSION_MAP_T[v4]))
    {
      v4 += 2;
      if (v4 == 18) {
        goto LABEL_6;
      }
    }
    return audiofetch_GetMimeTypeFromURI_EXT_TO_MIMETYPE_CONVERSION_MAP_T[v4 + 1];
  }
  else
  {
LABEL_6:
    uint64_t v5 = "application/octet-stream";
    if (!strncmp(a1, "audio/", 6uLL) && strchr(a1, 58)) {
      return "audio/x-wav";
    }
  }
  return v5;
}

uint64_t audiofetch_PrepareAudioTask(_WORD **a1, char *a2, char *__s1, char *a4, uint64_t a5, void *a6)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  int v47 = 0;
  int v48 = 0;
  int v46 = 0;
  char v53 = 0;
  long long v51 = 0u;
  long long v52 = 0u;
  *(_OWORD *)__s1a = 0u;
  long long v50 = 0u;
  size_t __n_4 = 0;
  unsigned int __n = 0;
  if (ParseAudioMimeType(__s1, &v48, (_WORD *)&v47 + 1, &v47, &v46))
  {
    int EngineFreq = GetEngineFreq((uint64_t)a1);
    int v16 = EngineFreq;
    if (v46) {
      BOOL v17 = 1;
    }
    else {
      BOOL v17 = HIWORD(v47) == EngineFreq;
    }
    int v18 = !v17;
    if (a5 || (v48 - 5) >= 4)
    {
      switch(v48)
      {
        case 1:
          uint64_t v21 = Au2PCM(*a1, (int)a1[1], a2, a4, a5, __s1a, &__n_4, &__n, 1);
          goto LABEL_22;
        case 5:
          uint64_t v21 = Wav2PCM(*a1, (uint64_t)a1[1], a2, (uint64_t)a4, a5, __s1a, (uint64_t *)&__n_4, &__n);
          goto LABEL_22;
        case 6:
          uint64_t v21 = Au2PCM(*a1, (int)a1[1], a2, a4, a5, __s1a, &__n_4, &__n, 0);
          goto LABEL_22;
        case 7:
          uint64_t v21 = NistSphere2PCM(*a1, (int)a1[1], a2, a4, a5, __s1a, &__n_4, &__n);
          goto LABEL_22;
        case 8:
          uint64_t v21 = NuanceAudio2PCM(*a1, (uint64_t)a1[1], a2, (uint64_t)a4, a5, __s1a, 0x41uLL, (uint64_t *)&__n_4, &__n);
LABEL_22:
          uint64_t v19 = v21;
          if ((v21 & 0x80000000) == 0) {
            goto LABEL_23;
          }
          if (__n_4) {
            heap_Free(*((void **)a1[2] + 1), __n_4);
          }
          return v19;
        default:
          unsigned int __n = a5;
          size_t v22 = (void *)heap_Alloc(*((void *)a1[2] + 1), a5);
          size_t __n_4 = (size_t)v22;
          if (!v22) {
            goto LABEL_39;
          }
          memcpy(v22, a4, __n);
LABEL_23:
          if (!ParseAudioMimeType(__s1a, &v48, (_WORD *)&v47 + 1, &v47, 0))
          {
            log_OutPublic(*((void *)a1[2] + 4), (uint64_t)"AUDIOFETCH", 136, "%s%s%s%s", v23, v24, v25, v26, "uri");
            if (__n_4) {
              heap_Free(*((void **)a1[2] + 1), __n_4);
            }
            return 2269126660;
          }
          int v27 = HIWORD(v47);
          uint64_t v28 = heap_Calloc(*((void **)a1[2] + 1), 1, 88);
          if (v28)
          {
            uint64_t v33 = (void *)v28;
            if (v27 == v16) {
              int v34 = v18;
            }
            else {
              int v34 = 1;
            }
            *(_WORD *)uint64_t v28 = 1;
            *(_WORD *)(v28 + 68) = v27;
            *(_WORD *)(v28 + 70) = v16;
            int v35 = v48;
            unsigned int v36 = (unsigned __int16)v47;
            *(_WORD *)(v28 + 72) = v47;
            unsigned int v37 = __n;
            *(_DWORD *)(v28 + 64) = __n;
            *(_DWORD *)(v28 + 76) = v35;
            *(_DWORD *)(v28 + 80) = v34;
            if (v36)
            {
              if (v36 != 1)
              {
                if (v36 == 2) {
                  v37 >>= 1;
                }
                else {
                  v37 /= v36;
                }
              }
              *(_DWORD *)(v28 + 16) = v37;
            }
            uint64_t v38 = strhelper_Strdup(*((void *)a1[2] + 1), a2);
            v33[3] = v38;
            if (v38)
            {
              v33[7] = __n_4;
              uint64_t v19 = AddAudioTask((uint64_t)a1, (uint64_t)v33, a6);
            }
            else
            {
              if (__n_4) {
                heap_Free(*((void **)a1[2] + 1), __n_4);
              }
              log_OutPublic(*((void *)a1[2] + 4), (uint64_t)"AUDIOFETCH", 100, 0, v39, v40, v41, v42, v43);
              uint64_t v19 = 2269126666;
            }
            audiofetch_ElemFreeAudioVarLenBuf(v33, *((void **)a1[2] + 1));
          }
          else
          {
            if (__n_4) {
              heap_Free(*((void **)a1[2] + 1), __n_4);
            }
            log_OutPublic(*((void *)a1[2] + 4), (uint64_t)"AUDIOFETCH", 100, 0, v29, v30, v31, v32, v43);
LABEL_39:
            uint64_t v19 = 2269126666;
          }
          break;
      }
    }
    else
    {
      return 2269126660;
    }
  }
  else
  {
    uint64_t v19 = 2269126660;
    log_OutPublic(*((void *)a1[2] + 4), (uint64_t)"AUDIOFETCH", 133, "%s%s%s%s", v11, v12, v13, v14, "uri");
  }
  return v19;
}

BOOL ParseAudioMimeType(char *__s1, int *a2, _WORD *a3, _WORD *a4, _DWORD *a5)
{
  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  if (a5) {
    *a5 = 0;
  }
  if (!strcmp(__s1, "audio/wav") || !strcmp(__s1, "audio/x-wav"))
  {
    if (a5)
    {
      *a5 = 1;
      int v14 = 5;
      goto LABEL_26;
    }
    return *a2 != 0;
  }
  if (!strcmp(__s1, "audio/x-nist"))
  {
    if (!a5) {
      return *a2 != 0;
    }
    *a5 = 1;
    int v14 = 7;
    goto LABEL_26;
  }
  if (!strcmp(__s1, "audio/x-nuance-audio"))
  {
    if (!a5) {
      return *a2 != 0;
    }
    *a5 = 1;
    int v14 = 8;
    goto LABEL_26;
  }
  if (!strcmp(__s1, "audio/x-alaw-basic"))
  {
    *a2 = 1;
    *a3 = 8000;
    goto LABEL_33;
  }
  if (!strcmp(__s1, "audio/basic"))
  {
    if (a5)
    {
      *a5 = 1;
      int v14 = 6;
      goto LABEL_26;
    }
    *a2 = 2;
    *a3 = 8000;
LABEL_33:
    *a4 = 1;
    return *a2 != 0;
  }
  if (!strncmp(__s1, "audio/L16;", 0xAuLL))
  {
    *a4 = 2;
    uint64_t v10 = strchr(__s1, 59);
    if (!v10) {
      goto LABEL_37;
    }
    uint64_t v11 = v10;
    int v12 = 0;
    int v13 = 1;
    do
    {
      if (!strncmp(v11 + 1, "endian=little;", 0xEuLL))
      {
        int v12 = 0;
      }
      else if (!strncmp(v11 + 1, "endian=big;", 0xBuLL))
      {
        int v12 = 1;
      }
      else if (!strncmp(v11 + 1, "rate=", 5uLL))
      {
        *a3 = (unsigned __int16)LH_atou(v11 + 6);
      }
      else if (!strncmp(v11 + 1, "channels=", 9uLL))
      {
        int v13 = (unsigned __int16)LH_atou(v11 + 10);
      }
      uint64_t v11 = strchr(v11 + 1, 59);
    }
    while (v11);
    if (v13 == 1)
    {
      if (v12)
      {
        int v14 = 4;
LABEL_26:
        *a2 = v14;
        return *a2 != 0;
      }
LABEL_37:
      int v14 = 3;
      goto LABEL_26;
    }
  }
  return *a2 != 0;
}

uint64_t NistSphere2PCM(_WORD *a1, int a2, unsigned char *a3, char *a4, uint64_t a5, char *a6, void *a7, _DWORD *a8)
{
  uint64_t v99 = *MEMORY[0x263EF8340];
  uint64_t v90 = 0;
  uint64_t v91 = 0;
  uint64_t v89 = 0;
  int v88 = 0;
  memset(v98, 0, sizeof(v98));
  long long v97 = 0u;
  *(_OWORD *)&v96[1] = 0u;
  v96[0] = 78;
  memset(v95, 0, sizeof(v95));
  long long v94 = 0u;
  *(_OWORD *)&v93[3] = 0u;
  qmemcpy(v93, "pcm", 3);
  if (!a3) {
    return 2269126663;
  }
  uint64_t v8 = a8;
  uint64_t v9 = 2269126663;
  if (a8)
  {
    uint64_t v10 = a7;
    if (a7)
    {
      if (a6)
      {
        uint64_t v12 = a5;
        if (a5)
        {
          int v13 = a4;
          if (a4)
          {
            uint64_t v14 = (uint64_t)a3;
            if (*a3)
            {
              *a6 = 0;
              *a7 = 0;
              *a8 = 0;
              uint64_t inited = InitRsrcFunction(a1, a2, &v91);
              if ((inited & 0x80000000) != 0) {
                return inited;
              }
              int v20 = 0;
              uint64_t v21 = 0;
              size_t v22 = (unsigned __int8 *)&v13[v12];
              uint64_t v86 = a6;
              uint64_t v23 = -(uint64_t)v13;
              uint64_t v24 = -(uint64_t)v12;
              uint64_t v25 = v13;
              while (1)
              {
                if (v25 >= (char *)v22)
                {
LABEL_72:
                  log_OutPublic(*(void *)(v91 + 32), (uint64_t)"AUDIOFETCH", 109, "%s%s", v15, v16, v17, v18, "url");
                  return 2269126660;
                }
                unint64_t v26 = 0;
                while (1)
                {
                  int v27 = v25[v26];
                  if (v27 == 10 || v27 == 13) {
                    break;
                  }
                  ++v26;
                  if (!&v25[v23 + v24 + v26]) {
                    goto LABEL_72;
                  }
                }
                uint64_t v29 = (unsigned __int8 *)&v25[v26];
                if (!v20)
                {
                  if (v26 < 7) {
                    goto LABEL_91;
                  }
                  uint64_t v81 = v14;
                  uint64_t v83 = v13;
                  uint64_t v33 = v8;
                  uint64_t v34 = v12;
                  int v35 = v10;
                  unsigned int v36 = v21;
                  uint64_t v37 = v24;
                  uint64_t v38 = inited;
                  uint64_t v39 = v23;
                  int v40 = strncmp("NIST_1A", v25, 7uLL);
                  uint64_t inited = v38;
                  uint64_t v24 = v37;
                  uint64_t v21 = v36;
                  uint64_t v10 = v35;
                  uint64_t v12 = v34;
                  uint64_t v8 = v33;
                  uint64_t v14 = v81;
                  int v13 = v83;
                  if (v40 || (v23 = v39, v41 = v25[7], int v20 = 1, v41 != 10) && v41 != 13)
                  {
LABEL_91:
                    log_OutPublic(*(void *)(v91 + 32), (uint64_t)"AUDIOFETCH", 110, "%s%s", v15, v16, v17, v18, "url");
                    return 2269126660;
                  }
                  goto LABEL_58;
                }
                if (v20 != 2)
                {
                  uint64_t v85 = v10;
                  if (v25 >= (char *)v29)
                  {
                    uint64_t v48 = v23;
                    uint64_t v49 = inited;
                  }
                  else
                  {
                    uint64_t v30 = 0;
                    do
                    {
                      int v31 = v25[v30];
                      if (v31 != 32 && v31 != 9)
                      {
                        uint64_t v48 = v23;
                        uint64_t v49 = inited;
                        v25 += v30;
                        goto LABEL_48;
                      }
                      ++v30;
                    }
                    while (v26 != v30);
                    uint64_t v48 = v23;
                    uint64_t v49 = inited;
                    v25 += v26;
                  }
LABEL_48:
                  long long v50 = LH_atou(v25);
                  uint64_t v21 = v50;
                  if (!v50 || v50 >= v12)
                  {
                    log_OutPublic(*(void *)(v91 + 32), (uint64_t)"AUDIOFETCH", 111, "%s%s%s%u", v15, v16, v17, v18, "url");
                    return 2269126660;
                  }
                  int v20 = 2;
                  uint64_t inited = v49;
                  uint64_t v23 = v48;
                  uint64_t v10 = v85;
                  goto LABEL_58;
                }
                if ((unint64_t)&v25[v23 + v26] >= v21) {
                  goto LABEL_72;
                }
                uint64_t v82 = v23;
                uint64_t v84 = v21;
                uint64_t v42 = inited;
                if (buf_token_strcmp("end_head", v25, (uint64_t)&v25[v26]))
                {
                  if (!buf_token_strcmp("sample_rate", v25, (uint64_t)v29))
                  {
                    uint64_t v46 = v91;
                    int v47 = (int *)&v90 + 1;
LABEL_55:
                    uint64_t v51 = buf_parse_value_int(v46, v14, v25, (unint64_t)v29, v47, v43, v44, v45);
                    goto LABEL_56;
                  }
                  if (!buf_token_strcmp("sample_count", v25, (uint64_t)v29))
                  {
                    uint64_t v46 = v91;
                    int v47 = (int *)&v90;
                    goto LABEL_55;
                  }
                  if (!buf_token_strcmp("sample_sig_bits", v25, (uint64_t)v29))
                  {
                    uint64_t v46 = v91;
                    int v47 = (int *)&v89 + 1;
                    goto LABEL_55;
                  }
                  if (!buf_token_strcmp("sample_n_bytes", v25, (uint64_t)v29))
                  {
                    uint64_t v46 = v91;
                    int v47 = (int *)&v89;
                    goto LABEL_55;
                  }
                  if (!buf_token_strcmp("channel_count", v25, (uint64_t)v29))
                  {
                    uint64_t v46 = v91;
                    int v47 = &v88;
                    goto LABEL_55;
                  }
                  if (!buf_token_strcmp("sample_byte_format", v25, (uint64_t)v29))
                  {
                    uint64_t v56 = v91;
                    uint64_t v57 = v96;
                    goto LABEL_70;
                  }
                  if (!buf_token_strcmp("sample_coding", v25, (uint64_t)v29))
                  {
                    uint64_t v56 = v91;
                    uint64_t v57 = v93;
LABEL_70:
                    uint64_t v51 = buf_parse_value_str(v56, v14, (unsigned __int8 *)v25, (unint64_t)v29, v57, v16, v17, v18);
LABEL_56:
                    uint64_t inited = v51;
                    int v20 = 2;
                    uint64_t v21 = v84;
                    goto LABEL_57;
                  }
                  int v20 = 2;
                }
                else
                {
                  int v20 = 3;
                }
                uint64_t v21 = v84;
                uint64_t inited = v42;
LABEL_57:
                uint64_t v23 = v82;
LABEL_58:
                if ((inited & 0x80000000) != 0) {
                  return inited;
                }
                if (v29 < v22)
                {
                  while (1)
                  {
                    unsigned int v52 = *v29;
                    BOOL v53 = v52 > 0x20;
                    uint64_t v54 = (1 << v52) & 0x100002600;
                    if (v53 || v54 == 0) {
                      break;
                    }
                    if (++v29 >= v22)
                    {
                      uint64_t v29 = v22;
                      break;
                    }
                  }
                }
                uint64_t v25 = (char *)v29;
                if (v20 == 3)
                {
                  unsigned int v87 = inited;
                  int v60 = v88;
                  int v59 = v89;
                  int v61 = v90;
                  signed int v62 = HIDWORD(v90);
                  int v63 = (int)v21;
                  log_OutText(*(void *)(v91 + 32), (uint64_t)"AUDIOFETCH", 4, 0, (uint64_t)"NIST SPHERE %s: %s %s, %d channels, %d HZ, %d sample sig bits, %d bytes per sample, %u data offset, %d sample count", v16, v17, v18, v14);
                  if (v60 != 1)
                  {
                    log_OutPublic(*(void *)(v91 + 32), (uint64_t)"AUDIOFETCH", 112, "%s%s%s%d", v64, v65, v66, v67, "url");
                    return 2269126660;
                  }
                  if (v61 < 0)
                  {
                    log_OutPublic(*(void *)(v91 + 32), (uint64_t)"AUDIOFETCH", 119, "%s%s%s%d", v64, v65, v66, v67, "url");
                    return 2269126660;
                  }
                  if (v59 <= 0)
                  {
                    log_OutPublic(*(void *)(v91 + 32), (uint64_t)"AUDIOFETCH", 120, "%s%s%s%d", v64, v65, v66, v67, "url");
                    return 2269126660;
                  }
                  if (!(*(_DWORD *)v93 ^ 0x77616C75 | v93[4]))
                  {
                    BOOL v71 = v62 == 8000 || v62 == 0;
                    if (!v71 || v59 != 1) {
                      goto LABEL_125;
                    }
                    int v68 = v63;
LABEL_103:
                    strcpy(v86, "audio/basic");
                    goto LABEL_129;
                  }
                  int v68 = v63;
                  if (!(*(_DWORD *)v93 ^ 0x77616C61 | v93[4])) {
                    goto LABEL_104;
                  }
                  if (*(_DWORD *)v93 != 7168880)
                  {
                    if (*(_DWORD *)v96 != 1814918509 || *(_DWORD *)&v96[3] != 7823724)
                    {
                      if (*(_DWORD *)v96 != 1634479457 || *(unsigned __int16 *)&v96[4] != 119)
                      {
                        log_OutPublic(*(void *)(v91 + 32), (uint64_t)"AUDIOFETCH", 115, "%s%s%s%s%s%d%s%d%s%s", v64, v65, v66, v67, "url");
                        return 2269126660;
                      }
LABEL_104:
                      BOOL v72 = v62 == 8000 || v62 == 0;
                      if (!v72 || v59 != 1)
                      {
                        log_OutPublic(*(void *)(v91 + 32), (uint64_t)"AUDIOFETCH", 113, "%s%s%s%s%s%d%s%d", v64, v65, v66, v67, "url");
                        return 2269126660;
                      }
                      strcpy(v86, "audio/x-alaw-basic");
LABEL_129:
                      if (!v61)
                      {
                        log_OutPublic(*(void *)(v91 + 32), (uint64_t)"AUDIOFETCH", 116, "%s%s", v64, v65, v66, v67, "url");
                        return 2269126660;
                      }
                      size_t v75 = (v61 * v59);
                      if ((int)v75 + v68 > v12)
                      {
                        log_OutPublic(*(void *)(v91 + 32), (uint64_t)"AUDIOFETCH", 117, "%s%s", v64, v65, v66, v67, "url");
                        return 2269126660;
                      }
                      size_t v76 = (void *)heap_Alloc(*(void *)(v91 + 8), v75);
                      *uint64_t v10 = v76;
                      if (v76)
                      {
                        memcpy(v76, &v13[v63], v75);
                        *uint64_t v8 = v75;
                        return v87;
                      }
                      else
                      {
                        log_OutPublic(*(void *)(v91 + 32), (uint64_t)"AUDIOFETCH", 118, "%s%s%s%lu", v77, v78, v79, v80, "url");
                        return 2269126666;
                      }
                    }
                    BOOL v73 = v62 == 8000 || v62 == 0;
                    if (!v73 || v59 != 1)
                    {
LABEL_125:
                      log_OutPublic(*(void *)(v91 + 32), (uint64_t)"AUDIOFETCH", 114, "%s%s%s%s%s%d%s%d", v64, v65, v66, v67, "url");
                      return 2269126660;
                    }
                    goto LABEL_103;
                  }
                  if (v62 < 1 || v59 != 2)
                  {
LABEL_117:
                    uint64_t v9 = 2269126660;
                    log_OutPublic(*(void *)(v91 + 32), (uint64_t)"AUDIOFETCH", 115, "%s%s%s%s%s%d%s%d%s%s", v64, v65, v66, v67, "url");
                    return v9;
                  }
                  if (*(unsigned __int16 *)v96 ^ 0x3130 | v96[2])
                  {
                    if (*(unsigned __int16 *)v96 ^ 0x3031 | v96[2])
                    {
                      if (*(unsigned __int16 *)v96 != 78 && *(unsigned __int16 *)v96 != 49) {
                        goto LABEL_117;
                      }
                      goto LABEL_126;
                    }
                    long long v74 = v86;
                    strcpy(v86, "audio/L16;endian=big;rate=");
                  }
                  else
                  {
LABEL_126:
                    long long v74 = v86;
                    strcpy(v86, "audio/L16;endian=little;rate=");
                  }
                  LH_itoa(v62, __s2, 0xAu);
                  strcat(v74, __s2);
                  int v68 = v63;
                  goto LABEL_129;
                }
              }
            }
          }
        }
      }
    }
  }
  return v9;
}

uint64_t buf_token_strcmp(const char *a1, const char *a2, uint64_t a3)
{
  size_t v6 = strlen(a1);
  if (v6 > a3 - (uint64_t)a2) {
    return 0xFFFFFFFFLL;
  }
  size_t v8 = v6;
  uint64_t result = strncmp(a1, a2, v6);
  if (!result)
  {
    unsigned int v9 = a2[v8];
    BOOL v10 = v9 > 0x20;
    uint64_t v11 = (1 << v9) & 0x100002600;
    return v10 || v11 == 0;
  }
  return result;
}

uint64_t buf_parse_value_int(uint64_t a1, uint64_t a2, const char *a3, unint64_t a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v10 = a3;
  if ((unint64_t)a3 < a4)
  {
    unint64_t v12 = a4 - (void)a3;
    while (1)
    {
      int v13 = *(unsigned __int8 *)v10;
      if (v13 == 9 || v13 == 32) {
        break;
      }
      ++v10;
      if (!--v12)
      {
        BOOL v10 = (const char *)a4;
        break;
      }
    }
  }
  if ((unint64_t)v10 >= a4)
  {
LABEL_15:
    uint64_t v17 = 2269126660;
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"AUDIOFETCH", 121, "%s%s", (uint64_t)a5, a6, a7, a8, "url");
  }
  else
  {
    unint64_t v14 = a4 - (void)v10;
    while (1)
    {
      int v15 = *(unsigned __int8 *)v10;
      if (v15 != 32 && v15 != 9) {
        break;
      }
      ++v10;
      if (!--v14) {
        goto LABEL_15;
      }
    }
    if (buf_token_strcmp("-i", v10, a4))
    {
      uint64_t v17 = 2269126660;
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"AUDIOFETCH", 122, "%s%s", v20, v21, v22, v23, "url");
    }
    else
    {
      for (uint64_t i = v10 + 2; (unint64_t)i < a4; ++i)
      {
        int v25 = *(unsigned __int8 *)i;
        if (v25 != 32 && v25 != 9)
        {
          uint64_t v17 = 0;
          *a5 = atoi(i);
          return v17;
        }
      }
      uint64_t v17 = 2269126660;
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"AUDIOFETCH", 123, "%s%s", v20, v21, v22, v23, "url");
    }
  }
  return v17;
}

uint64_t buf_parse_value_str(uint64_t a1, uint64_t a2, unsigned __int8 *a3, unint64_t a4, char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((unint64_t)a3 < a4)
  {
    unint64_t v11 = a4 - (void)a3;
    while (1)
    {
      int v12 = *a3;
      if (v12 == 9 || v12 == 32) {
        break;
      }
      ++a3;
      if (!--v11)
      {
        a3 = (unsigned __int8 *)a4;
        break;
      }
    }
  }
  if ((unint64_t)a3 >= a4)
  {
LABEL_12:
    uint64_t v16 = 2269126660;
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"AUDIOFETCH", 124, "%s%s", (uint64_t)a5, a6, a7, a8, "url");
  }
  else
  {
    unint64_t v13 = a4 - (void)a3;
    unint64_t v14 = (const char *)(a3 + 2);
    while (1)
    {
      int v15 = *((unsigned __int8 *)v14 - 2);
      if (v15 != 9 && v15 != 32) {
        break;
      }
      ++v14;
      if (!--v13) {
        goto LABEL_12;
      }
    }
    if (v15 == 45 && *(v14 - 1) == 115 && *(unsigned __int8 *)v14 - 48 < 0xA)
    {
      int v17 = atoi(v14);
      if (v17 >= 63) {
        int v22 = 63;
      }
      else {
        int v22 = v17;
      }
      if ((unint64_t)v14 < a4)
      {
        while (*(unsigned __int8 *)v14 - 48 <= 9)
        {
          if ((unint64_t)++v14 >= a4)
          {
            unint64_t v14 = (const char *)a4;
            break;
          }
        }
      }
      if ((unint64_t)v14 < a4)
      {
        unint64_t v23 = a4 - (void)v14;
        while (1)
        {
          int v24 = *(unsigned __int8 *)v14;
          if (v24 != 32 && v24 != 9) {
            break;
          }
          ++v14;
          if (!--v23)
          {
            unint64_t v14 = (const char *)a4;
            break;
          }
        }
      }
      if ((unint64_t)&v14[v22] <= a4)
      {
        uint64_t v27 = v22;
        strncpy(a5, v14, v22);
        uint64_t v16 = 0;
        a5[v27] = 0;
      }
      else
      {
        uint64_t v16 = 2269126660;
        log_OutPublic(*(void *)(a1 + 32), (uint64_t)"AUDIOFETCH", 126, "%s%s", v18, v19, v20, v21, "url");
      }
    }
    else
    {
      uint64_t v16 = 2269126660;
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"AUDIOFETCH", 125, "%s%s", (uint64_t)a5, a6, a7, a8, "url");
    }
  }
  return v16;
}

uint64_t naudec_New(_WORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = 2269126663;
  if (a3)
  {
    uint64_t v12 = 0;
    uint64_t inited = InitRsrcFunction(a1, a2, &v12);
    if ((inited & 0x80000000) != 0)
    {
      return inited;
    }
    else
    {
      size_t v8 = (void *)heap_Alloc(*(void *)(v12 + 8), 64);
      *a3 = (uint64_t)v8;
      if (v8)
      {
        *size_t v8 = a1;
        v8[1] = a2;
        unsigned int v9 = (_WORD **)*a3;
        *((_OWORD *)v9 + 2) = 0u;
        *((_OWORD *)v9 + 3) = 0u;
        *((_OWORD *)v9 + 1) = 0u;
        uint64_t v10 = nauread_New(*v9, (uint64_t)v9[1], (uint64_t *)v9 + 2);
        if ((v10 & 0x80000000) != 0)
        {
          uint64_t v3 = v10;
LABEL_10:
          naudec_Destroy(a3);
          return v3;
        }
        uint64_t v3 = genidec_New(*v9, (uint64_t)v9[1], v9 + 3);
        if ((v3 & 0x80000000) != 0) {
          goto LABEL_10;
        }
      }
      else
      {
        return 2269126666;
      }
    }
  }
  return v3;
}

uint64_t naudec_Destroy(uint64_t *a1)
{
  uint64_t v1 = 2269126663;
  if (a1)
  {
    uint64_t v3 = *a1;
    if (*a1)
    {
      uint64_t v10 = 0;
      uint64_t inited = InitRsrcFunction(*(_WORD **)v3, *(void *)(v3 + 8), &v10);
      if ((inited & 0x80000000) != 0)
      {
        return inited;
      }
      else
      {
        uint64_t v5 = *a1;
        if (*(void *)(*a1 + 16)) {
          uint64_t v1 = nauread_Destroy((uint64_t *)(*a1 + 16));
        }
        else {
          uint64_t v1 = 0;
        }
        uint64_t v7 = *(void *)(v5 + 24);
        size_t v6 = (uint64_t *)(v5 + 24);
        if (v7)
        {
          unsigned int v8 = genidec_Destroy(v6);
          if ((int)v1 >= 0) {
            uint64_t v1 = v8;
          }
          else {
            uint64_t v1 = v1;
          }
        }
        heap_Free(*(void **)(v10 + 8), *a1);
        *a1 = 0;
      }
    }
  }
  return v1;
}

uint64_t naudec_OpenInputMemory(uint64_t a1, const char *a2, uint64_t a3, int a4)
{
  uint64_t result = 2269126663;
  if (a1)
  {
    if (*(void *)(a1 + 16))
    {
      uint64_t result = nauread_ExtOpen(*(void *)(a1 + 16), "memory", a2, a3, a4);
      if ((result & 0x80000000) == 0)
      {
        uint64_t v6 = *(void *)(a1 + 16);
        return nauread_ReadHeader(v6);
      }
    }
  }
  return result;
}

uint64_t naudec_Decode(_WORD **a1, uint64_t *a2, _DWORD *a3)
{
  unsigned __int16 v41 = 0;
  uint64_t v40 = 0;
  uint64_t Info = nauread_GetInfo((uint64_t)a1[2], 0, &v41, 0, &v40);
  if ((Info & 0x80000000) != 0) {
    return Info;
  }
  unint64_t v7 = (unint64_t)v41 >> 3;
  uint64_t v8 = (v40 * v7);
  *a3 = v8;
  size_t v42 = 0;
  *a2 = 0;
  uint64_t Info = InitRsrcFunction(*a1, (int)a1[1], &v42);
  if ((Info & 0x80000000) != 0) {
    return Info;
  }
  uint64_t v9 = 2269126666;
  uint64_t v10 = heap_Alloc(*(void *)(v42 + 8), v8);
  *a2 = v10;
  if (!v10) {
    return v9;
  }
  uint64_t v11 = v10;
  unint64_t v12 = *a3;
  uint64_t Info = nauread_BeginReadData((uint64_t)a1[2]);
  if ((Info & 0x80000000) != 0) {
    return Info;
  }
  int v39 = 0;
  size_t v37 = 0;
  unint64_t v38 = 0;
  int v13 = genidec_RequestSamples(a1[3], 0, 1000, &v39, (uint64_t *)&v38, &v37);
  LODWORD(v18) = v13;
  if (v13 < 0 || v13 == 6 || !v12)
  {
LABEL_27:
    unsigned int Data = nauread_EndReadData((uint64_t)a1[2]);
    if (v18 == 6) {
      return Data;
    }
    else {
      return v18;
    }
  }
  int v19 = 0;
  while (1)
  {
    size_t v20 = v37;
    unint64_t v21 = v38;
    if ((unint64_t)a1[5] >= v37) {
      goto LABEL_13;
    }
    size_t v42 = 0;
    uint64_t inited = InitRsrcFunction(*a1, (int)a1[1], &v42);
    if ((inited & 0x80000000) != 0) {
      break;
    }
    uint64_t v23 = heap_Realloc(*(uint64_t **)(v42 + 8), (uint64_t)a1[4], v20);
    a1[4] = (_WORD *)v23;
    if (!v23) {
      goto LABEL_34;
    }
    a1[5] = (_WORD *)v20;
LABEL_13:
    size_t v42 = 0;
    int v25 = a1[6];
    size_t v24 = (size_t)a1[7];
    unint64_t v26 = v21 - (void)v25;
    if ((_WORD *)v21 == v25)
    {
      size_t v27 = v20 - v24;
      if (v20 <= v24) {
        goto LABEL_23;
      }
    }
    else
    {
      size_t v28 = (size_t)v25 + v24;
      if ((unint64_t)v25 + v24 <= v21)
      {
        if ((_WORD *)((char *)v25 + v24) != (_WORD *)v21)
        {
          uint64_t v18 = 2269126660;
          goto LABEL_35;
        }
        uint64_t v18 = nauread_ReadData((uint64_t)a1[2], a1[4], v20, &v42, v14, v15, v16, v17);
        a1[6] = (_WORD *)v21;
        size_t v24 = v42;
        goto LABEL_22;
      }
      size_t v29 = v20 + v21;
      memmove(a1[4], (char *)a1[4] + v26, v24 - v26);
      size_t v24 = (size_t)a1[7] - v26;
      a1[6] = (_WORD *)v21;
      a1[7] = (_WORD *)v24;
      size_t v27 = v29 - v28;
      if (v29 == v28) {
        goto LABEL_23;
      }
    }
    uint64_t v18 = nauread_ReadData((uint64_t)a1[2], (char *)a1[4] + v24, v27, &v42, v14, v15, v16, v17);
    size_t v24 = (size_t)a1[7] + v42;
LABEL_22:
    a1[7] = (_WORD *)v24;
    if ((v18 & 0x80000000) != 0) {
      goto LABEL_35;
    }
LABEL_23:
    size_t v42 = v24;
    int v36 = v12 / v7;
    uint64_t v30 = genidec_Decode(a1[3], (uint64_t)a1[4], &v42, v11, (uint64_t)&v36);
    if ((v30 & 0x80000000) != 0)
    {
      uint64_t v18 = v30;
      goto LABEL_35;
    }
    int v31 = v36;
    v19 += v36;
    int v32 = genidec_RequestSamples(a1[3], v19, 1000, &v39, (uint64_t *)&v38, &v37);
    LODWORD(v18) = v32;
    if ((v32 & 0x80000000) == 0 && v32 != 6)
    {
      uint64_t v33 = (v31 * v7);
      v11 += v33;
      v12 -= v33;
      if (v12) {
        continue;
      }
    }
    goto LABEL_27;
  }
  uint64_t v9 = inited;
LABEL_34:
  uint64_t v18 = v9;
LABEL_35:
  nauread_EndReadData((uint64_t)a1[2]);
  return v18;
}

uint64_t NuanceAudio2PCM(_WORD *a1, uint64_t a2, const char *a3, uint64_t a4, int a5, char *a6, size_t a7, uint64_t *a8, _DWORD *a9)
{
  uint64_t v9 = 2269126663;
  if (a3)
  {
    BOOL v15 = !a9 || a8 == 0;
    BOOL v16 = v15 || a6 == 0;
    BOOL v17 = v16 || a5 == 0;
    BOOL v18 = v17 || a4 == 0;
    if (!v18 && *a3 != 0)
    {
      int v25 = 0;
      *a6 = 0;
      *a8 = 0;
      *a9 = 0;
      uint64_t v21 = naudec_New(a1, a2, (uint64_t *)&v25);
      if ((v21 & 0x80000000) == 0)
      {
        if ((naudec_OpenInputMemory((uint64_t)v25, a3, a4, a5) & 0x80000000) == 0)
        {
          if (v25)
          {
            if (v25[3])
            {
              if ((nauread_GetContentType((uint64_t)v25[2], a6, a7) & 0x80000000) == 0)
              {
                if (v25)
                {
                  int v22 = v25[3];
                  if (v22)
                  {
                    if ((nauread_OpenDecoder((uint64_t)v25[2], v22) & 0x80000000) == 0)
                    {
                      naudec_Decode(v25, a8, a9);
                      if (v25)
                      {
                        uint64_t v23 = v25[3];
                        if (v23) {
                          genidec_Close(v23);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return naudec_Destroy((uint64_t *)&v25);
      }
      return v21;
    }
  }
  return v9;
}

uint64_t genidec_New(_WORD *a1, uint64_t a2, void *a3)
{
  if (!a3) {
    return 2269126663;
  }
  uint64_t v11 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v11);
  if ((inited & 0x80000000) == 0)
  {
    unint64_t v7 = (void *)heap_Alloc(*(void *)(v11 + 8), 40);
    *a3 = v7;
    if (v7)
    {
      *unint64_t v7 = a1;
      v7[1] = a2;
      uint64_t v8 = (void *)*a3;
      v8[2] = 0;
      v8[3] = safeh_GetNullHandle();
      v8[4] = v9;
    }
    else
    {
      return 2269126666;
    }
  }
  return inited;
}

uint64_t genidec_Destroy(uint64_t *a1)
{
  uint64_t inited = 2269126663;
  if (a1)
  {
    uint64_t v3 = *a1;
    if (*a1)
    {
      uint64_t v5 = 0;
      uint64_t inited = InitRsrcFunction(*(_WORD **)v3, *(void *)(v3 + 8), &v5);
      if ((inited & 0x80000000) == 0)
      {
        heap_Free(*(void **)(v5 + 8), *a1);
        *a1 = 0;
      }
    }
  }
  return inited;
}

uint64_t genidec_Open(void *a1, char *__s1, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = 2269126676;
  if (!a1) {
    return 2269126663;
  }
  if (a1[2]) {
    return 2269126673;
  }
  if (!strcmp(__s1, "vssq5"))
  {
    if (a3 > 15999)
    {
      if (a3 == 16000) {
        goto LABEL_20;
      }
      int v11 = 22050;
    }
    else
    {
      if (a3 == 8000) {
        goto LABEL_20;
      }
      int v11 = 11025;
    }
    if (a3 != v11) {
      return v5;
    }
    goto LABEL_20;
  }
  if (strcmp(__s1, "rhelp")) {
    return v5;
  }
  if (a3 > 15999)
  {
    if (a3 != 22050 && a3 != 16000) {
      return v5;
    }
  }
  else if (a3 != 8000 && a3 != 11025)
  {
    return v5;
  }
LABEL_20:
  uint64_t v14 = 0;
  uint64_t inited = InitRsrcFunction((_WORD *)*a1, a1[1], &v14);
  if ((inited & 0x80000000) == 0)
  {
    uint64_t inited = brk_InterfaceQuery(*(void *)(v14 + 24));
    if ((inited & 0x80000000) == 0) {
      return (*(uint64_t (**)(void, void, uint64_t, uint64_t, void *))(a1[2] + 32))(*a1, a1[1], a4, a5, a1 + 3);
    }
  }
  return inited;
}

uint64_t genidec_Close(void *a1)
{
  uint64_t result = 2269126663;
  if (a1)
  {
    uint64_t v3 = a1[2];
    if (v3)
    {
      uint64_t v4 = (*(uint64_t (**)(void, void))(v3 + 40))(a1[3], a1[4]);
      a1[2] = 0;
      a1[3] = safeh_GetNullHandle();
      a1[4] = v5;
      return v4;
    }
    else
    {
      return 2269126673;
    }
  }
  return result;
}

uint64_t genidec_RequestSamples(void *a1, int a2, int a3, _DWORD *a4, uint64_t *a5, void *a6)
{
  uint64_t result = 2269126663;
  if (a1 && a4 && a5 && a6)
  {
    uint64_t v11 = a1[2];
    if (v11)
    {
      int v15 = a3;
      int v16 = a2;
      uint64_t v12 = *a5;
      unsigned int v13 = 0;
      unsigned int v14 = v12;
      uint64_t result = (*(uint64_t (**)(void, void, int *, int *, void, unsigned int *, unsigned int *))(v11 + 104))(a1[3], a1[4], &v16, &v15, 0, &v14, &v13);
      *a4 = v15;
      *a5 = v14;
      *a6 = v13;
    }
    else
    {
      return 2269126673;
    }
  }
  return result;
}

uint64_t genidec_Decode(void *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = 2269126663;
  if (a1 && a2 && a3 && a4 && a5)
  {
    uint64_t v8 = a1[2];
    if (v8)
    {
      unsigned int v9 = *a3;
      uint64_t result = (*(uint64_t (**)(void, void, uint64_t, unsigned int *, uint64_t))(v8 + 112))(a1[3], a1[4], a2, &v9, a4);
      *a3 = v9;
    }
    else
    {
      return 2269126673;
    }
  }
  return result;
}

uint64_t nauread_New(_WORD *a1, uint64_t a2, uint64_t *a3)
{
  if (!a3) {
    return 2269126663;
  }
  uint64_t v10 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v10);
  if ((inited & 0x80000000) == 0)
  {
    unint64_t v7 = (void *)heap_Alloc(*(void *)(v10 + 8), 96);
    *a3 = (uint64_t)v7;
    if (v7)
    {
      *unint64_t v7 = a1;
      v7[1] = a2;
      uint64_t v8 = *a3;
      *(void *)(v8 + 16) = 0;
      *(_DWORD *)(v8 + 24) = 0;
      *(_WORD *)(v8 + 28) = 0;
      *(_OWORD *)(v8 + 30) = 0u;
      *(_OWORD *)(v8 + 46) = 0u;
      *(_DWORD *)(v8 + 64) = 0;
      *(void *)(v8 + 80) = 0;
      *(void *)(v8 + 88) = 0;
      *(void *)(v8 + 72) = 0;
    }
    else
    {
      return 2269126666;
    }
  }
  return inited;
}

uint64_t nauread_Destroy(uint64_t *a1)
{
  uint64_t v1 = 2269126663;
  if (a1)
  {
    uint64_t v3 = *a1;
    if (*a1)
    {
      uint64_t v13 = 0;
      uint64_t inited = InitRsrcFunction(*(_WORD **)v3, *(void *)(v3 + 8), &v13);
      if ((inited & 0x80000000) != 0)
      {
        return inited;
      }
      else
      {
        uint64_t v1 = nauread_Close(*a1, v5, v6, v7, v8, v9, v10, v11);
        heap_Free(*(void **)(v13 + 8), *a1);
        *a1 = 0;
      }
    }
  }
  return v1;
}

uint64_t nauread_Close(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 2269126663;
  }
  uint64_t result = *(void *)(a1 + 16);
  if (result)
  {
    uint64_t result = ssftriff_reader_ObjClose((void *)result, a2, a3, a4, a5, a6, a7, a8);
    *(void *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 24) = 0;
    *(_WORD *)(a1 + 28) = 0;
    *(_OWORD *)(a1 + 30) = 0u;
    *(_OWORD *)(a1 + 46) = 0u;
    *(_DWORD *)(a1 + 64) = 0;
    *(void *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
    *(void *)(a1 + 72) = 0;
  }
  return result;
}

uint64_t nauread_ExtOpen(uint64_t a1, char *__s1, const char *a3, uint64_t a4, int a5)
{
  uint64_t result = 2269126663;
  if (a1)
  {
    if (*(void *)(a1 + 16))
    {
      return 2269126673;
    }
    else
    {
      if (!strcmp(__s1, "broker"))
      {
        uint64_t v11 = 0;
      }
      else if (!strcmp(__s1, "file"))
      {
        uint64_t v11 = 1;
      }
      else
      {
        uint64_t v11 = 4 * (strcmp(__s1, "memory") == 0);
      }
      return ssftriff_reader_ObjOpenEx(*(_WORD **)a1, *(void *)(a1 + 8), v11, a3, a4, a5, "NUAU", 0, (uint64_t *)(a1 + 16));
    }
  }
  return result;
}

uint64_t nauread_ReadHeader(uint64_t a1)
{
  int v1 = -2025840636;
  if (!a1) {
    return 2269126663;
  }
  uint64_t v3 = *(void *)(a1 + 16);
  if (!v3) {
    return 2269126673;
  }
  LODWORD(v30) = 0;
  uint64_t result = ssftriff_reader_FindChunk(v3, "NAUH", 0, (unsigned int *)&v30, 0);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  size_t v29 = 0;
  uint64_t v30 = 0;
  int v9 = nauread_OpenChunk(a1, "NAUF", &v30, &v29, v5, v6, v7, v8);
  if (v9 < 0) {
    goto LABEL_21;
  }
  if ((unint64_t)v29 > 5)
  {
    uint64_t v10 = v30;
    *(_DWORD *)(a1 + 24) = *v30;
    *(_WORD *)(a1 + 28) = *((_WORD *)v10 + 2);
    int v9 = ssftriff_reader_CloseChunk(*(void *)(a1 + 16));
    if (v9 < 0) {
      goto LABEL_21;
    }
    size_t v29 = 0;
    uint64_t v30 = 0;
    int v9 = nauread_OpenChunk(a1, "NAUX", &v30, &v29, v11, v12, v13, v14);
    if (v9 < 0) {
      goto LABEL_21;
    }
    if ((unint64_t)v29 > 3)
    {
      *(void *)(a1 + 80) = *v30;
      int v9 = ssftriff_reader_CloseChunk(*(void *)(a1 + 16));
      if (v9 < 0) {
        goto LABEL_21;
      }
      size_t v29 = 0;
      uint64_t v30 = 0;
      int v9 = nauread_OpenChunk(a1, "NAUC", &v30, &v29, v15, v16, v17, v18);
      if (v9 < 0) {
        goto LABEL_21;
      }
      if ((unint64_t)v29 < 0x20)
      {
        __strcpy_chk();
        int v9 = ssftriff_reader_CloseChunk(*(void *)(a1 + 16));
        if (v9 < 0) {
          goto LABEL_21;
        }
        unint64_t v28 = 0;
        size_t v29 = 0;
        int v9 = nauread_OpenChunk(a1, "NAUI", &v29, &v28, v19, v20, v21, v22);
        if (v9 < 0) {
          goto LABEL_21;
        }
        unint64_t v23 = v28;
        if (v28 >= 4)
        {
          uint64_t v24 = *v29;
          *(_DWORD *)(a1 + 64) = v24;
          if (v23 >= (v24 + 4))
          {
            uint64_t v30 = 0;
            int inited = InitRsrcFunction(*(_WORD **)a1, *(void *)(a1 + 8), &v30);
            if (inited < 0)
            {
              int v1 = inited;
            }
            else
            {
              uint64_t v26 = *(void *)(a1 + 72);
              if (v26)
              {
                heap_Free(*((void **)v30 + 1), v26);
                *(void *)(a1 + 72) = 0;
              }
              size_t v27 = (void *)heap_Alloc(*((void *)v30 + 1), v24);
              *(void *)(a1 + 72) = v27;
              if (v27)
              {
                memcpy(v27, v29 + 1, *(unsigned int *)(a1 + 64));
                int v9 = ssftriff_reader_CloseChunk(*(void *)(a1 + 16));
LABEL_21:
                int v1 = v9;
                goto LABEL_27;
              }
              int v1 = -2025840630;
            }
          }
        }
      }
    }
  }
  ssftriff_reader_CloseChunk(*(void *)(a1 + 16));
LABEL_27:
  LODWORD(result) = ssftriff_reader_CloseChunk(*(void *)(a1 + 16));
  if (v1 >= 0) {
    return result;
  }
  else {
    return v1;
  }
}

uint64_t nauread_GetContentType(uint64_t a1, char *a2, size_t a3)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v3 = 2269126665;
  size_t v7 = a3;
  if (!a1) {
    return 2269126663;
  }
  if (!*(void *)(a1 + 16)) {
    return 2269126673;
  }
  if (a3)
  {
    *a2 = 0;
    if (nauread_strapp(a2, &v7, "audio/L"))
    {
      LH_itoa(*(unsigned __int16 *)(a1 + 28), __s, 0xAu);
      if (nauread_strapp(a2, &v7, __s))
      {
        if (nauread_strapp(a2, &v7, ";endian=little;rate="))
        {
          LH_itoa(*(_DWORD *)(a1 + 24), __s, 0xAu);
          if (nauread_strapp(a2, &v7, __s)) {
            return 0;
          }
          else {
            return 2269126665;
          }
        }
      }
    }
  }
  return v3;
}

char *nauread_strapp(char *a1, size_t *a2, char *__s)
{
  size_t v6 = strlen(__s);
  if (*a2 <= v6) {
    return 0;
  }
  *a2 -= v6;
  strcat(a1, __s);
  return a1;
}

uint64_t nauread_GetInfo(uint64_t a1, _DWORD *a2, _WORD *a3, void *a4, void *a5)
{
  uint64_t v5 = 2269126663;
  if (a1)
  {
    if (*(void *)(a1 + 16))
    {
      if (a2) {
        *a2 = *(_DWORD *)(a1 + 24);
      }
      if (a3) {
        *a3 = *(_WORD *)(a1 + 28);
      }
      if (a4) {
        *a4 = a1 + 30;
      }
      uint64_t v5 = 0;
      if (a5) {
        *a5 = *(void *)(a1 + 80);
      }
    }
    else
    {
      return 2269126673;
    }
  }
  return v5;
}

uint64_t nauread_OpenDecoder(uint64_t a1, void *a2)
{
  uint64_t result = 2269126663;
  if (a1)
  {
    if (*(void *)(a1 + 16)) {
      return genidec_Open(a2, (char *)(a1 + 30), *(_DWORD *)(a1 + 24), *(void *)(a1 + 72), *(unsigned int *)(a1 + 64));
    }
    else {
      return 2269126673;
    }
  }
  return result;
}

uint64_t nauread_BeginReadData(uint64_t a1)
{
  uint64_t result = 2269126663;
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    if (v3)
    {
      unsigned int v4 = 0;
      uint64_t result = ssftriff_reader_FindChunk(v3, "NAUD", 0, &v4, 0);
      *(void *)(a1 + 88) = v4;
    }
    else
    {
      return 2269126673;
    }
  }
  return result;
}

uint64_t nauread_EndReadData(uint64_t a1)
{
  uint64_t result = 2269126663;
  if (a1)
  {
    if (*(void *)(a1 + 16))
    {
      uint64_t result = ssftriff_reader_CloseChunk(*(void *)(a1 + 16));
      *(void *)(a1 + 88) = 0;
    }
    else
    {
      return 2269126673;
    }
  }
  return result;
}

uint64_t nauread_ReadData(uint64_t a1, void *a2, size_t a3, size_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 2269126663;
  if (a4)
  {
    *a4 = 0;
    if (a1)
    {
      uint64_t v11 = *(void *)(a1 + 16);
      if (v11)
      {
        if (*(void *)(a1 + 88) >= a3) {
          size_t v12 = a3;
        }
        else {
          size_t v12 = *(void *)(a1 + 88);
        }
        if (v12)
        {
          __src = 0;
          Chunkunsigned int Data = ssftriff_reader_GetChunkData(v11, v12, &__src, (uint64_t)a4, a5, a6, a7, a8);
          if ((ChunkData & 0x80000000) != 0)
          {
            return ChunkData;
          }
          else
          {
            uint64_t v8 = ssftriff_reader_Seek(*(void *)(a1 + 16), v12, 1);
            if ((v8 & 0x80000000) == 0)
            {
              memcpy(a2, __src, v12);
              *a4 = v12;
              *(void *)(a1 + 88) -= v12;
            }
          }
        }
        else
        {
          return 6;
        }
      }
      else
      {
        return 2269126673;
      }
    }
  }
  return v8;
}

uint64_t nauread_OpenChunk(uint64_t a1, const char *a2, void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v14 = 0;
  char v13 = 0;
  *(_DWORD *)__s1 = 0;
  unsigned int v10 = ssftriff_reader_OpenChunk(*(void *)(a1 + 16), __s1, &v14, a3, a5, a6, a7, a8);
  *a4 = v14;
  if (!strcmp(__s1, a2)) {
    return v10;
  }
  else {
    return 2269126660;
  }
}

uint64_t spxrsmp_resampler_init(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, unsigned int a5, int *a6)
{
  return spxrsmp_resampler_init_frac(a1, a2, a3, a4, a3, a4, a5, a6);
}

uint64_t spxrsmp_resampler_init_frac(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, int a5, int a6, unsigned int a7, int *a8)
{
  if (a7 >= 0xB)
  {
    uint64_t v9 = 0;
    if (a8)
    {
      int v10 = 3;
LABEL_21:
      *a8 = v10;
      return v9;
    }
    return v9;
  }
  uint64_t v9 = heap_Calloc(*(void **)(a1 + 8), 136, 1);
  if (!v9)
  {
LABEL_19:
    if (a8)
    {
      int v10 = 1;
      goto LABEL_21;
    }
    return v9;
  }
  uint64_t v18 = *(void **)(a1 + 8);
  *(void *)(v9 + 60) = 0;
  *(void *)(v9 + 8) = 0;
  *(void *)(v9 + 16) = 0;
  *(void *)uint64_t v9 = v18;
  *(_DWORD *)(v9 + 112) = 0;
  *(void *)(v9 + 32) = 0;
  *(void *)(v9 + 96) = 0;
  *(void *)(v9 + 120) = 0;
  *(_DWORD *)(v9 + 52) = 1065353216;
  *(_DWORD *)(v9 + 24) = -1;
  *(_DWORD *)(v9 + 28) = a2;
  *(_DWORD *)(v9 + 40) = 160;
  uint64_t v19 = (int)(4 * a2);
  *(void *)(v9 + 128) = 0x100000001;
  uint64_t v20 = heap_Calloc(v18, v19, 1);
  *(void *)(v9 + 72) = v20;
  if (!v20)
  {
LABEL_18:
    heap_Free(*(void **)(a1 + 8), v9);
    uint64_t v9 = 0;
    goto LABEL_19;
  }
  uint64_t v21 = heap_Calloc(*(void **)v9, v19, 1);
  *(void *)(v9 + 88) = v21;
  uint64_t v22 = *(void **)v9;
  if (!v21)
  {
LABEL_17:
    heap_Free(v22, *(void *)(v9 + 72));
    goto LABEL_18;
  }
  unint64_t v23 = (_DWORD *)heap_Calloc(v22, v19, 1);
  *(void *)(v9 + 80) = v23;
  if (!v23)
  {
    heap_Free(*(void **)v9, *(void *)(v9 + 88));
    uint64_t v22 = *(void **)v9;
    goto LABEL_17;
  }
  if (a2)
  {
    uint64_t v24 = *(_DWORD **)(v9 + 72);
    int v25 = *(_DWORD **)(v9 + 88);
    uint64_t v26 = a2;
    do
    {
      *v24++ = 0;
      *v25++ = 0;
      *v23++ = 0;
      --v26;
    }
    while (v26);
  }
  if (*(_DWORD *)(v9 + 24) != a7)
  {
    *(_DWORD *)(v9 + 24) = a7;
    if (*(_DWORD *)(v9 + 60)) {
      update_filter((void **)v9);
    }
  }
  spxrsmp_resampler_set_rate_frac(v9, a3, a4, a5, a6);
  update_filter((void **)v9);
  *(_DWORD *)(v9 + 60) = 1;
  if (a8)
  {
    int v10 = 0;
    goto LABEL_21;
  }
  return v9;
}

uint64_t spxrsmp_resampler_set_rate_frac(uint64_t a1, unsigned int a2, uint64_t a3, int a4, int a5)
{
  if (*(_DWORD *)(a1 + 8) != a4
    || *(_DWORD *)(a1 + 12) != a5
    || *(_DWORD *)(a1 + 16) != a2
    || *(_DWORD *)(a1 + 20) != a3)
  {
    unsigned int v5 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 8) = a4;
    *(_DWORD *)(a1 + 12) = a5;
    *(_DWORD *)(a1 + 16) = a2;
    *(_DWORD *)(a1 + 20) = a3;
    if (a2 >= a3) {
      unsigned int v6 = a3;
    }
    else {
      unsigned int v6 = a2;
    }
    if (v6 >= 2)
    {
      unsigned int v12 = 2;
      do
      {
        if (!(a2 % v12))
        {
          while (1)
          {
            uint64_t v13 = a3 / v12;
            if (a3 % v12) {
              break;
            }
            a2 /= v12;
            *(_DWORD *)(a1 + 16) = a2;
            *(_DWORD *)(a1 + 20) = v13;
            a3 = a3 / v12;
            if (a2 % v12) {
              goto LABEL_21;
            }
          }
        }
        uint64_t v13 = a3;
LABEL_21:
        ++v12;
        if (a2 >= v13) {
          unsigned int v14 = v13;
        }
        else {
          unsigned int v14 = a2;
        }
        a3 = v13;
      }
      while (v12 <= v14);
    }
    if (v5 && *(_DWORD *)(a1 + 28))
    {
      unint64_t v7 = 0;
      uint64_t v8 = *(void *)(a1 + 80);
      do
      {
        unsigned int v9 = *(_DWORD *)(a1 + 20) * *(_DWORD *)(v8 + 4 * v7) / v5;
        *(_DWORD *)(v8 + 4 * v7) = v9;
        unsigned int v10 = *(_DWORD *)(a1 + 20);
        if (v9 >= v10) {
          *(_DWORD *)(v8 + 4 * v7) = v10 - 1;
        }
        ++v7;
      }
      while (v7 < *(unsigned int *)(a1 + 28));
    }
    if (*(_DWORD *)(a1 + 60)) {
      update_filter((void **)a1);
    }
  }
  return 0;
}

void update_filter(void **a1)
{
  unsigned int v2 = *((_DWORD *)a1 + 8);
  int v3 = *((_DWORD *)a1 + 6);
  unsigned int v4 = (unsigned int *)((char *)&quality_map + 24 * v3);
  unsigned int v6 = *v4;
  unsigned int v5 = v4[1];
  *((_DWORD *)a1 + 14) = v5;
  *((_DWORD *)a1 + 8) = v6;
  unsigned int v8 = *((_DWORD *)a1 + 4);
  unsigned int v7 = *((_DWORD *)a1 + 5);
  if (v8 <= v7)
  {
    *((_DWORD *)a1 + 13) = *((_DWORD *)&quality_map + 6 * v3 + 3);
  }
  else
  {
    unsigned int v9 = v8 * v6 / v7 - 1;
    unsigned int v10 = v5 >> (2 * v7 < v8) >> (4 * v7 < v8) >> (8 * v7 < v8) >> (16 * v7 < v8);
    uint64_t v11 = (float *)((char *)&quality_map + 24 * v3);
    if (v10 <= 1) {
      unsigned int v5 = 1;
    }
    else {
      unsigned int v5 = v5 >> (2 * v7 < v8) >> (4 * v7 < v8) >> (8 * v7 < v8) >> (16 * v7 < v8);
    }
    *((float *)a1 + 13) = (float)(v11[2] * (float)v7) / (float)v8;
    unsigned int v6 = (v9 & 0xFFFFFFF8) + 8;
    *((_DWORD *)a1 + 8) = v6;
    if (4 * v7 < v8
      || (v10 ? (BOOL v12 = 2 * v7 >= v8) : (BOOL v12 = 0),
          v12 ? (BOOL v13 = 8 * v7 >= v8) : (BOOL v13 = 0),
          v13 ? (BOOL v14 = 16 * v7 >= v8) : (BOOL v14 = 0),
          !v14))
    {
      *((_DWORD *)a1 + 14) = v5;
    }
  }
  uint64_t v15 = (uint64_t)a1[13];
  if (v7 > 16 * v5 + 128)
  {
    if (v15)
    {
      unsigned int v16 = v6 * v5 + 8;
      if (*((_DWORD *)a1 + 28) >= v16)
      {
LABEL_27:
        unsigned int v19 = *((_DWORD *)a1 + 14);
        unsigned int v20 = *((_DWORD *)a1 + 8);
        int v21 = v20 * v19 + 4;
        uint64_t v18 = resampler_basic_interpolate_single;
        if (v21 >= -3)
        {
          uint64_t v22 = 0;
          float v23 = *((float *)a1 + 13);
          float v24 = (float)v19;
          uint64_t v25 = *((void *)&quality_map + 3 * *((int *)a1 + 6) + 2);
          uint64_t v26 = v21 + 4;
          do
          {
            *(_WORD *)(v15 + 2 * v22) = sinc(v20, v25, v23, (float)((float)(v22 - 4) / v24) - (float)(v20 >> 1));
            ++v22;
            uint64_t v18 = resampler_basic_interpolate_single;
          }
          while (v26 != v22);
        }
        goto LABEL_43;
      }
      uint64_t v15 = heap_Realloc(*a1, (uint64_t)a1[13], (int)(2 * v16));
      a1[13] = (void *)v15;
      *((_DWORD *)a1 + 28) = *((_DWORD *)a1 + 14) * *((_DWORD *)a1 + 8) + 8;
    }
    else
    {
      uint64_t v15 = heap_Calloc(*a1, (int)(2 * v5 * v6 + 16), 1);
      a1[13] = (void *)v15;
    }
    uint64_t v18 = resampler_basic_interpolate_single;
    if (!v15) {
      goto LABEL_43;
    }
    goto LABEL_27;
  }
  if (!v15)
  {
    uint64_t v15 = heap_Calloc(*a1, (int)(2 * v7 * v6), 1);
    a1[13] = (void *)v15;
LABEL_32:
    uint64_t v18 = resampler_basic_direct_single;
    if (!v15) {
      goto LABEL_43;
    }
    goto LABEL_33;
  }
  unsigned int v17 = v6 * v7;
  if (*((_DWORD *)a1 + 28) < v17)
  {
    uint64_t v15 = heap_Realloc(*a1, (uint64_t)a1[13], (int)(2 * v17));
    a1[13] = (void *)v15;
    *((_DWORD *)a1 + 28) = *((_DWORD *)a1 + 5) * *((_DWORD *)a1 + 8);
    goto LABEL_32;
  }
LABEL_33:
  unsigned int v27 = *((_DWORD *)a1 + 5);
  uint64_t v18 = resampler_basic_direct_single;
  if (v27)
  {
    unsigned int v80 = v2;
    int v28 = 0;
    unsigned int v29 = 0;
    uint64_t v30 = *((unsigned int *)a1 + 8);
    if ((int)v30 >= 0) {
      int v31 = *((_DWORD *)a1 + 8);
    }
    else {
      int v31 = v30 + 1;
    }
    int v32 = 1 - (v31 >> 1);
    do
    {
      if (v30)
      {
        uint64_t v33 = 0;
        float v34 = *((float *)a1 + 13);
        uint64_t v35 = *((void *)&quality_map + 3 * *((int *)a1 + 6) + 2);
        do
        {
          *(_WORD *)(v15 + 2 * (v28 + v33)) = sinc(v30, v35, v34, (float)(v32 + v33) - (float)((float)v29 / (float)v27));
          ++v33;
        }
        while (v30 != v33);
      }
      ++v29;
      v28 += v30;
      uint64_t v18 = resampler_basic_direct_single;
    }
    while (v29 != v27);
    unsigned int v2 = v80;
  }
LABEL_43:
  a1[15] = v18;
  unsigned int v36 = *((_DWORD *)a1 + 4);
  unsigned int v37 = *((_DWORD *)a1 + 5);
  *((_DWORD *)a1 + 11) = v36 / v37;
  *((_DWORD *)a1 + 12) = v36 % v37;
  uint64_t v38 = (uint64_t)a1[12];
  if (!v38)
  {
    int v67 = *((_DWORD *)a1 + 7);
    int v68 = *((_DWORD *)a1 + 8) + *((_DWORD *)a1 + 10) - 1;
    *((_DWORD *)a1 + 9) = v68;
    long long v69 = (void *)heap_Calloc(*a1, 2 * v68 * v67, 1);
LABEL_78:
    a1[12] = v69;
    if (v69)
    {
      unsigned int v71 = *((_DWORD *)a1 + 9) * *((_DWORD *)a1 + 7);
      if (v71)
      {
        bzero(v69, 2 * v71);
      }
    }
    return;
  }
  unsigned int v39 = *((_DWORD *)a1 + 8);
  if (!*((_DWORD *)a1 + 16))
  {
    int v70 = v39 + *((_DWORD *)a1 + 10) - 1;
    *((_DWORD *)a1 + 9) = v70;
    long long v69 = (void *)heap_Realloc(*a1, v38, 2 * v70 * *((_DWORD *)a1 + 7));
    goto LABEL_78;
  }
  if (v39 <= v2)
  {
    if (v39 < v2 && *((_DWORD *)a1 + 7))
    {
      unint64_t v72 = 0;
      BOOL v73 = a1[11];
      do
      {
        int v74 = *((_DWORD *)v73 + v72);
        unsigned int v75 = (v2 - *((_DWORD *)a1 + 8)) >> 1;
        *((_DWORD *)v73 + v72) = v75;
        int v76 = *((_DWORD *)a1 + 8);
        int v77 = v74 + v75;
        uint64_t v78 = (v77 + v76 - 1);
        if (v77 + v76 != 1)
        {
          unsigned int v79 = *((_DWORD *)a1 + 9) * v72;
          do
          {
            *(_WORD *)(v38 + 2 * v79) = *(_WORD *)(v38 + 2 * (v75 + v79));
            ++v79;
            --v78;
          }
          while (v78);
        }
        *((_DWORD *)v73 + v72++) = v77;
      }
      while (v72 < *((unsigned int *)a1 + 7));
    }
  }
  else
  {
    uint64_t v40 = *((int *)a1 + 9);
    unsigned int v41 = v39 + *((_DWORD *)a1 + 10) - 1;
    if (v41 > v40)
    {
      *((_DWORD *)a1 + 9) = v41;
      uint64_t v38 = heap_Realloc(*a1, v38, (int)(2 * v41 * *((_DWORD *)a1 + 7)));
      a1[12] = (void *)v38;
    }
    uint64_t v42 = (*((_DWORD *)a1 + 7) - 1);
    if ((int)v42 >= 0)
    {
      uint64_t v43 = a1[11];
      unsigned int v44 = v2 - 2;
      uint64_t v45 = v38 + 2 * v40 * v42;
      while (1)
      {
        uint64_t v46 = *((unsigned int *)v43 + v42);
        unsigned int v47 = v2 + 2 * v46;
        if (v38) {
          break;
        }
        *((_DWORD *)v43 + v42) = 0;
        unsigned int v52 = *((_DWORD *)a1 + 8);
        if (v47 < v52) {
          goto LABEL_72;
        }
        *((_DWORD *)v43 + v42) = (v47 - v52) >> 1;
LABEL_73:
        v45 -= 2 * v40;
        if (v42-- <= 0) {
          return;
        }
      }
      if ((int)(v44 + v46) >= 0)
      {
        uint64_t v48 = 2 * (v44 + v46);
        unsigned int v49 = v44 + *((_DWORD *)a1 + 9) * v42 + 2 * v46;
        do
        {
          *(_WORD *)(v38 + 2 * v49) = *(_WORD *)(v45 + v48);
          v48 -= 2;
          --v49;
        }
        while (v48 != -2);
      }
      if (v46)
      {
        unsigned int v50 = *((_DWORD *)a1 + 9) * v42;
        uint64_t v51 = v46;
        do
        {
          *(_WORD *)(v38 + 2 * v50++) = 0;
          --v51;
        }
        while (v51);
      }
      *((_DWORD *)v43 + v42) = 0;
      unsigned int v52 = *((_DWORD *)a1 + 8);
      unsigned int v53 = v47 - v52;
      if (v47 >= v52)
      {
        *((_DWORD *)v43 + v42) = v53 >> 1;
        uint64_t v62 = *((_DWORD *)a1 + 8) + (v53 >> 1) - 1;
        if (*((_DWORD *)a1 + 8) + (v53 >> 1) != 1)
        {
          unsigned int v63 = *((_DWORD *)a1 + 9) * v42;
          do
          {
            *(_WORD *)(v38 + 2 * v63) = *(_WORD *)(v38 + 2 * ((v53 >> 1) + v63));
            ++v63;
            --v62;
          }
          while (v62);
        }
        goto LABEL_73;
      }
      int v54 = 2 * v46;
      unint64_t v55 = v47 - 1;
      if (v47 == 1)
      {
        unsigned int v61 = 0;
      }
      else
      {
        int v56 = *((_DWORD *)a1 + 9) * v42;
        int v57 = v52 + v56;
        unsigned int v58 = v44 + v54 + v56;
        unsigned int v59 = v57 - 2;
        uint64_t v60 = v47 - 1;
        do
        {
          *(_WORD *)(v38 + 2 * v59--) = *(_WORD *)(v38 + 2 * v58--);
          --v60;
        }
        while (v60);
        unsigned int v61 = v47 - 1;
      }
      unint64_t v64 = v52 - 1;
      if (v61 < v64)
      {
        unsigned int v65 = ~v2 + v52 + *((_DWORD *)a1 + 9) * v42 - v54;
        do
        {
          *(_WORD *)(v38 + 2 * v65) = 0;
          ++v55;
          --v65;
        }
        while (v55 < v64);
      }
LABEL_72:
      *((_DWORD *)a1[9] + v42) += (v52 - v47) >> 1;
      goto LABEL_73;
    }
  }
}

void *spxrsmp_resampler_destroy(void *result)
{
  if (result)
  {
    int v1 = (void **)result;
    unsigned int v2 = (void *)*result;
    uint64_t v3 = result[12];
    if (v3) {
      heap_Free((void *)*result, v3);
    }
    uint64_t v4 = (uint64_t)v1[13];
    if (v4) {
      heap_Free(*v1, v4);
    }
    uint64_t v5 = (uint64_t)v1[9];
    if (v5) {
      heap_Free(*v1, v5);
    }
    uint64_t v6 = (uint64_t)v1[11];
    if (v6) {
      heap_Free(*v1, v6);
    }
    uint64_t v7 = (uint64_t)v1[10];
    if (v7) {
      heap_Free(*v1, v7);
    }
    return heap_Free(v2, (uint64_t)v1);
  }
  return result;
}

uint64_t spxrsmp_resampler_process_int(uint64_t a1, unsigned int a2, _WORD *a3, unsigned int *a4, uint64_t a5, unsigned int *a6)
{
  uint64_t v28 = a5;
  uint64_t v6 = *(void *)(a1 + 96);
  if (!v6 || !*(void *)(a1 + 104)) {
    return 1;
  }
  unsigned int v10 = *a4;
  unsigned int v11 = *a6;
  int v13 = *(_DWORD *)(a1 + 32);
  int v12 = *(_DWORD *)(a1 + 36);
  uint64_t v14 = *(int *)(a1 + 128);
  if (!*(_DWORD *)(*(void *)(a1 + 88) + 4 * a2)
    || (v11 -= speex_resampler_magic(a1, a2, &v28, v11), !*(_DWORD *)(*(void *)(a1 + 88) + 4 * a2)))
  {
    if (v10 && v11)
    {
      int v15 = v13 - 1;
      unsigned int v16 = v12 - (v13 - 1);
      uint64_t v17 = v28;
      uint64_t v18 = (_WORD *)(v6 + 2 * v12 * a2 + 2 * v15);
      do
      {
        if (v10 >= v16) {
          uint64_t v19 = v16;
        }
        else {
          uint64_t v19 = v10;
        }
        unsigned int v26 = v11;
        unsigned int v27 = v19;
        if (a3)
        {
          if (v19)
          {
            unsigned int v20 = a3;
            int v21 = v18;
            do
            {
              *v21++ = *v20;
              v20 += v14;
              --v19;
            }
            while (v19);
          }
        }
        else if (v19)
        {
          uint64_t v22 = v18;
          do
          {
            *v22++ = 0;
            --v19;
          }
          while (v19);
        }
        speex_resampler_process_native(a1, a2, &v27, v17, &v26);
        v11 -= v26;
        if (a3) {
          a3 += v27 * v14;
        }
        else {
          a3 = 0;
        }
        v10 -= v27;
        if (!v10) {
          break;
        }
        v17 += 2 * *(_DWORD *)(a1 + 132) * v26;
      }
      while (v11);
    }
  }
  uint64_t result = 0;
  *a4 -= v10;
  *a6 -= v11;
  return result;
}

uint64_t speex_resampler_magic(uint64_t a1, unsigned int a2, uint64_t *a3, unsigned int a4)
{
  unsigned int v18 = a4;
  uint64_t v7 = *(void *)(a1 + 96);
  unsigned int v17 = *(_DWORD *)(*(void *)(a1 + 88) + 4 * a2);
  int v8 = *(_DWORD *)(a1 + 32);
  int v9 = *(_DWORD *)(a1 + 36);
  speex_resampler_process_native(a1, a2, &v17, *a3, &v18);
  uint64_t v10 = *(void *)(a1 + 88);
  int v11 = *(_DWORD *)(v10 + 4 * a2);
  uint64_t v13 = v11 - v17;
  BOOL v12 = v11 == v17;
  *(_DWORD *)(v10 + 4 * a2) = v13;
  if (!v12)
  {
    unsigned int v14 = v17;
    unsigned int v15 = v8 - 1;
    do
    {
      *(_WORD *)(v7 + 2 * v9 * a2 + 2 * v15) = *(_WORD *)(v7 + 2 * v9 * a2 + 2 * (v14 + v15));
      ++v15;
      --v13;
    }
    while (v13);
  }
  uint64_t result = v18;
  *a3 += 2 * *(_DWORD *)(a1 + 132) * v18;
  return result;
}

uint64_t speex_resampler_process_native(uint64_t a1, unsigned int a2, unsigned int *a3, uint64_t a4, _DWORD *a5)
{
  int v9 = *(_DWORD *)(a1 + 32);
  uint64_t v10 = *(void *)(a1 + 96) + 2 * *(_DWORD *)(a1 + 36) * a2;
  *(_DWORD *)(a1 + 64) = 1;
  uint64_t result = (*(uint64_t (**)(void))(a1 + 120))();
  uint64_t v12 = *(void *)(a1 + 72);
  int v13 = *(_DWORD *)(v12 + 4 * a2);
  if (v13 < (int)*a3) {
    *a3 = v13;
  }
  *a5 = result;
  *(_DWORD *)(v12 + 4 * a2) -= *a3;
  if (v9 >= 2)
  {
    unsigned int v14 = *a3;
    uint64_t v15 = (v9 - 1);
    unsigned int v16 = (_WORD *)v10;
    do
    {
      *v16++ = *(_WORD *)(v10 + 2 * v14++);
      --v15;
    }
    while (v15);
  }
  return result;
}

uint64_t sinc(int a1, uint64_t a2, float a3, float a4)
{
  double v4 = a4;
  double v5 = fabs(a4);
  if (v5 >= 0.000000999999997)
  {
    if (v5 <= (float)((float)a1 * 0.5))
    {
      long double v11 = a3 * 32768.0 * sin((float)(a3 * a4) * 3.14159265) / ((float)(a3 * a4) * 3.14159265);
      float v12 = (v4 + v4) / (double)a1;
      double v13 = v11 * compute_func(a2, fabsf(v12));
      if (v13 >= -32767.0)
      {
        if (v13 <= 32766.0) {
          int v8 = (int)v13;
        }
        else {
          LOWORD(v8) = 0x7FFF;
        }
      }
      else
      {
        LOWORD(v8) = 0x8000;
      }
    }
    else
    {
      LOWORD(v8) = 0;
    }
  }
  else
  {
    double v6 = a3 * 32768.0;
    double v7 = 32767.0;
    if (v6 <= 32766.0) {
      double v7 = v6;
    }
    int v8 = (int)v7;
    if (v6 < -32767.0) {
      LOWORD(v8) = 0x8000;
    }
  }
  return (__int16)v8;
}

uint64_t resampler_basic_direct_single(uint64_t a1, unsigned int a2, uint64_t a3, int *a4, uint64_t a5, int *a6)
{
  uint64_t v6 = a2;
  uint64_t v7 = *(void *)(a1 + 72);
  uint64_t v8 = *(void *)(a1 + 80);
  int v9 = *(_DWORD *)(v7 + 4 * a2);
  unsigned int v10 = *(_DWORD *)(v8 + 4 * a2);
  int v11 = *a4;
  if (v9 >= *a4)
  {
    uint64_t result = 0;
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v13 = *(int *)(a1 + 32);
    uint64_t v14 = *(void *)(a1 + 104);
    int v15 = *(_DWORD *)(a1 + 44);
    int v16 = *(_DWORD *)(a1 + 48);
    unsigned int v17 = *(_DWORD *)(a1 + 20);
    uint64_t v18 = *(int *)(a1 + 132);
    uint64_t result = *a6 & ~(*a6 >> 31);
    while (v12 != result)
    {
      if ((int)v13 < 1)
      {
        LOWORD(v28) = 0;
      }
      else
      {
        uint64_t v20 = 0;
        int v21 = (int16x4_t *)(v14 + 2 * v10 * v13);
        uint64_t v22 = (int16x4_t *)(a3 + 2 * v9);
        int32x4_t v23 = 0uLL;
        do
        {
          int16x4_t v24 = *v21++;
          int16x4_t v25 = v24;
          int16x4_t v26 = *v22++;
          int32x4_t v23 = vmlal_s16(v23, v26, v25);
          v20 += 4;
        }
        while (v20 < v13);
        int v27 = vaddq_s32(vaddq_s32(vdupq_lane_s32(*(int32x2_t *)v23.i8, 1), v23), vaddq_s32(vdupq_laneq_s32(v23, 2), vdupq_laneq_s32(v23, 3))).u32[0];
        int v28 = (v27 + 0x4000) >> 15;
        if (v28 <= -32767) {
          LOWORD(v28) = -32767;
        }
        if (v27 > 1073725439) {
          LOWORD(v28) = 0x7FFF;
        }
      }
      uint64_t v29 = v12 + 1;
      *(_WORD *)(a5 + 2 * v12 * v18) = v28;
      v9 += v15;
      unsigned int v30 = v10 + v16;
      if (v30 < v17)
      {
        unsigned int v31 = 0;
      }
      else
      {
        ++v9;
        unsigned int v31 = v17;
      }
      unsigned int v10 = v30 - v31;
      uint64_t v12 = v29;
      if (v9 >= v11)
      {
        uint64_t result = v29;
        break;
      }
    }
  }
  *(_DWORD *)(v7 + 4 * v6) = v9;
  *(_DWORD *)(v8 + 4 * v6) = v10;
  return result;
}

uint64_t resampler_basic_interpolate_single(uint64_t a1, unsigned int a2, uint64_t a3, int *a4, uint64_t a5, int *a6)
{
  uint64_t v6 = a2;
  uint64_t v7 = *(void *)(a1 + 72);
  uint64_t v8 = *(void *)(a1 + 80);
  int v9 = *(_DWORD *)(v7 + 4 * a2);
  unsigned int v10 = *(_DWORD *)(v8 + 4 * a2);
  int v11 = *a4;
  if (v9 >= *a4)
  {
    uint64_t v17 = 0;
  }
  else
  {
    uint64_t v46 = *(void *)(a1 + 80);
    uint64_t v47 = *(void *)(a1 + 72);
    uint64_t v48 = a2;
    uint64_t v12 = 0;
    int v13 = *(_DWORD *)(a1 + 44);
    int v14 = *(_DWORD *)(a1 + 48);
    unsigned int v15 = *(_DWORD *)(a1 + 20);
    uint64_t v16 = *(unsigned int *)(a1 + 32);
    uint64_t v17 = *a6 & ~(*a6 >> 31);
    uint64_t v18 = *(int *)(a1 + 132);
    while (v12 != v17)
    {
      int v19 = *(_DWORD *)(a1 + 56);
      if ((int)v16 < 1)
      {
        int v24 = 0;
        int v23 = 0;
        int v22 = 0;
        int v21 = 0;
      }
      else
      {
        uint64_t v20 = 0;
        int v21 = 0;
        int v22 = 0;
        int v23 = 0;
        int v24 = 0;
        uint64_t v25 = *(void *)(a1 + 104);
        uint64_t v26 = v16;
        int v27 = (__int16 *)(a3 + 2 * v9);
        do
        {
          int v28 = *v27++;
          int v29 = v19 * ++v20 - v19 * v10 / v15;
          v24 += *(__int16 *)(v25 + 2 * (v29 + 2)) * v28;
          v23 += *(__int16 *)(v25 + 2 * (v29 + 3)) * v28;
          v22 += *(__int16 *)(v25 + 2 * (v29 + 4)) * v28;
          v21 += *(__int16 *)(v25 + 2 * (v29 + 5)) * v28;
          --v26;
        }
        while (v26);
      }
      int v30 = (int)(((__int16)v15 >> 1) + ((v19 * v10 % v15) << 15)) / (int)v15;
      int v31 = (__int16)v30;
      int v32 = 2 * (__int16)v30;
      int v33 = (v32 * (__int16)v30 + 0x8000) >> 16;
      int v34 = v33 * v32 + 0x8000;
      int v35 = 5461 * (v34 >> 16);
      int v36 = v35 + 2147478188 * (__int16)v30 + 0x4000;
      unsigned int v37 = v30 + ((v33 - (v34 >> 16)) >> 1);
      int v38 = 2147472726 * v31 + (v33 << 14) - v35 + 0x4000;
      if ((_WORD)v37 + (unsigned __int16)(v38 >> 15) + (unsigned __int16)(v36 >> 15)) {
        __int16 v39 = 0x8000;
      }
      else {
        __int16 v39 = 0x7FFF;
      }
      int v40 = (v24 >> 16) * (__int16)(v36 >> 15)
          + (v23 >> 16) * (__int16)v37
          + ((((unsigned __int16)v24 >> 1) * (__int16)(v36 >> 15)) >> 15)
          + (v22 >> 16) * (__int16)(v39 - (v37 + (v38 >> 15) + (v36 >> 15)))
          + ((((unsigned __int16)v23 >> 1) * (__int16)v37) >> 15)
          + (v21 >> 16) * (__int16)(v38 >> 15)
          + ((((unsigned __int16)v22 >> 1)
            * (__int16)(v39 - (v37 + (v38 >> 15) + (v36 >> 15)))) >> 15)
          + ((((unsigned __int16)v21 >> 1) * (__int16)(v38 >> 15)) >> 15);
      int v41 = (v40 + 0x2000) >> 14;
      if (v41 <= -32767) {
        LOWORD(v41) = -32767;
      }
      if (v40 > 536862719) {
        LOWORD(v41) = 0x7FFF;
      }
      uint64_t v42 = v12 + 1;
      *(_WORD *)(a5 + 2 * v12 * v18) = v41;
      unsigned int v43 = v10 + v14;
      if (v10 + v14 < v15) {
        v9 += v13;
      }
      else {
        v9 += v13 + 1;
      }
      if (v43 < v15) {
        unsigned int v44 = 0;
      }
      else {
        unsigned int v44 = v15;
      }
      unsigned int v10 = v43 - v44;
      ++v12;
      if (v9 >= v11)
      {
        uint64_t v17 = v42;
        break;
      }
    }
    uint64_t v7 = v47;
    uint64_t v6 = v48;
    uint64_t v8 = v46;
  }
  *(_DWORD *)(v7 + 4 * v6) = v9;
  *(_DWORD *)(v8 + 4 * v6) = v10;
  return v17;
}

double compute_func(uint64_t a1, float a2)
{
  float v2 = (float)*(int *)(a1 + 8) * a2;
  signed int v3 = vcvtms_s32_f32(v2);
  float v4 = v2 - (float)(int)floorf(v2);
  double v5 = v4;
  float v6 = v4 * v4;
  double v7 = (float)(v4 * (float)(v4 * v4));
  double v8 = v7 * 0.166666667 + v5 * -0.166666667;
  double v9 = v6;
  double v10 = v5 + v9 * 0.5 + v7 * -0.5;
  double v11 = v9 * 0.5 + v5 * -0.333333333 + v7 * -0.166666667;
  uint64_t v12 = (double *)(*(void *)a1 + 8 * v3);
  return v12[1] * (1.0 - v8 - v10 - v11) + v11 * *v12 + v10 * v12[2] + v8 * v12[3];
}

uint64_t audioinserter_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2341478401;
  }
  uint64_t result = 0;
  *a2 = &IAudioInserter;
  return result;
}

uint64_t audioins_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = 2341478410;
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  if (!a5) {
    return 2341478407;
  }
  uint64_t inited = InitRsrcFunction(a3, a4, &v50);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  *(void *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  log_OutText(*(void *)(v50 + 32), (uint64_t)"AUDIOINSERTER", 4, 0, (uint64_t)"Entering audioins_ObjOpen", v10, v11, v12, v47);
  int v13 = (void *)heap_Calloc(*(void **)(v50 + 8), 1, 1056);
  uint64_t v18 = v50;
  if (v13)
  {
    uint64_t v19 = (uint64_t)v13;
    v13[1] = a4;
    v13[2] = v18;
    *int v13 = a3;
    uint64_t Object = objc_GetObject(*(void *)(v50 + 48), (uint64_t)"SYNTHSTREAM", &v49);
    if ((Object & 0x80000000) != 0)
    {
      uint64_t v31 = Object;
      log_OutPublic(*(void *)(v50 + 32), (uint64_t)"AUDIOINSERTER", 2574, 0, v21, v22, v23, v24, v48);
      uint64_t v5 = v31;
      goto LABEL_27;
    }
    *(void *)(v19 + 848) = *(void *)(v49 + 8);
    if ((objc_GetObject(*(void *)(v50 + 48), (uint64_t)"AUDIOFETCHER", &v49) & 0x80000000) == 0)
    {
      uint64_t v29 = v49;
      if (*(unsigned char *)v49 == 1)
      {
        uint64_t v30 = *(void *)(v49 + 8);
        if (v30)
        {
          *(void *)(v19 + 920) = v30;
          *(_OWORD *)(v19 + 928) = *(_OWORD *)(v29 + 16);
LABEL_15:
          uint64_t ParamU32 = audioins_GetParamU32(v19, (uint64_t)"frequencyhz", (unsigned int *)(v19 + 944), 0x1F40u);
          if ((ParamU32 & 0x80000000) != 0
            || (uint64_t ParamU32 = audioins_GetParamU32(v19, (uint64_t)"audiooutputbufsamples", (unsigned int *)(v19 + 948), 0x400u), (ParamU32 & 0x80000000) != 0)|| (uint64_t ParamU32 = audioins_SetDefaultAudioProsodyParameters(v19), (ParamU32 & 0x80000000) != 0))
          {
            uint64_t v5 = ParamU32;
          }
          else
          {
            uint64_t v37 = WSOLA__Create(*(void *)(v19 + 16), *(_WORD *)(v19 + 944));
            *(void *)(v19 + 1032) = v37;
            if (v37)
            {
              WSOLA__Initialise(v37);
              WSOLA__SetTimeScaleFactor(*(_WORD **)(v19 + 1032), 100);
              uint64_t v38 = heap_Alloc(*(void *)(*(void *)(v19 + 1032) + 328), 2048);
              *(void *)(v19 + 1040) = v38;
              if (v38)
              {
                uint64_t v39 = heap_Alloc(*(void *)(*(void *)(v19 + 1032) + 328), 2048);
                *(void *)(v19 + 1048) = v39;
                if (v39)
                {
                  unint64_t v40 = 0;
                  uint64_t v41 = v50;
                  do
                  {
                    uint64_t v42 = *(void *)(v41 + 40);
                    unsigned int v43 = off_2641133F8[v40];
                    v51[0] = v19;
                    v51[1] = audioinserter_loc_ParamCheckChange;
                    v51[2] = audioinserter_loc_ParamLearnChange;
                    uint64_t v44 = paramc_ListenerAdd(v42, v43, v51);
                    uint64_t v5 = v44;
                    if (v40 > 4) {
                      break;
                    }
                    ++v40;
                  }
                  while ((v44 & 0x80000000) == 0);
                  if ((v44 & 0x80000000) == 0)
                  {
                    int v45 = 13546;
LABEL_28:
                    *(void *)a5 = v19;
                    *(_DWORD *)(a5 + 8) = v45;
                    log_OutText(*(void *)(v50 + 32), (uint64_t)"AUDIOINSERTER", 4, 0, (uint64_t)"Leaving audioins_ObjOpen: %x", v33, v34, v35, v5);
                    return v5;
                  }
                }
              }
            }
          }
LABEL_27:
          log_OutPublic(*(void *)(v50 + 32), (uint64_t)"AUDIOINSERTER", 2580, "%s%x", v32, v33, v34, v35, "lhError");
          *(void *)a5 = v19;
          *(_DWORD *)(a5 + 8) = 13546;
          audioins_ObjClose((void *)v19, *(void *)(a5 + 8));
          uint64_t v19 = 0;
          int v45 = 0;
          goto LABEL_28;
        }
      }
      objc_ReleaseObject(*(void *)(v50 + 48), (uint64_t)"AUDIOFETCHER");
    }
    log_OutPublic(*(void *)(v50 + 32), (uint64_t)"AUDIOINSERTER", 2560, 0, v25, v26, v27, v28, v48);
    goto LABEL_15;
  }
  log_OutPublic(*(void *)(v50 + 32), (uint64_t)"AUDIOINSERTER", 2577, 0, v14, v15, v16, v17, v48);
  return v5;
}

uint64_t audioins_ObjClose(void *a1, int a2)
{
  if ((safeh_HandleCheck((uint64_t)a1, a2, 13546, 1056) & 0x80000000) != 0) {
    return 2341478408;
  }
  uint64_t v6 = a1[2];
  log_OutText(*(void *)(v6 + 32), (uint64_t)"AUDIOINSERTER", 4, 0, (uint64_t)"Entering audioins_ObjClose", v3, v4, v5, v21);
  unint64_t v7 = 0;
  do
  {
    uint64_t v8 = *(void *)(v6 + 40);
    double v9 = off_2641133F8[v7];
    *(void *)&long long v22 = a1;
    *((void *)&v22 + 1) = audioinserter_loc_ParamCheckChange;
    uint64_t v23 = audioinserter_loc_ParamLearnChange;
    uint64_t v10 = paramc_ListenerRemove(v8, v9, &v22);
    uint64_t v11 = v10;
    if (v7 > 4) {
      break;
    }
    ++v7;
  }
  while ((v10 & 0x80000000) == 0);
  if (a1[106])
  {
    int v12 = objc_ReleaseObject(*(void *)(v6 + 48), (uint64_t)"SYNTHSTREAM");
    if (v12 >= 0 || (int)v11 <= -1) {
      uint64_t v11 = v11;
    }
    else {
      uint64_t v11 = v12;
    }
  }
  if (a1[115])
  {
    int v14 = objc_ReleaseObject(*(void *)(v6 + 48), (uint64_t)"AUDIOFETCHER");
    if (v14 >= 0 || (int)v11 <= -1) {
      uint64_t v11 = v11;
    }
    else {
      uint64_t v11 = v14;
    }
  }
  uint64_t v16 = a1[129];
  if (v16)
  {
    heap_Free(*(void **)(v16 + 328), a1[130]);
    heap_Free(*(void **)(a1[129] + 328), a1[131]);
    WSOLA__Remove(a1 + 129);
    a1[129] = 0;
  }
  heap_Free(*(void **)(v6 + 8), (uint64_t)a1);
  log_OutText(*(void *)(v6 + 32), (uint64_t)"AUDIOINSERTER", 4, 0, (uint64_t)"Leaving audioins_ObjClose: %x", v17, v18, v19, v11);
  return v11;
}

uint64_t audioins_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if ((safeh_HandleCheck(a1, a2, 13546, 1056) & 0x80000000) != 0) {
    return 2341478408;
  }
  synstrmaux_InitStreamOpener(a1 + 24, *(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER");
  *(void *)(a1 + 952) = 0;
  *(_DWORD *)(a1 + 960) = 0;
  uint64_t v7 = audioins_SetDefaultAudioProsodyParameters(a1);
  if ((v7 & 0x80000000) == 0 && *(void *)(a1 + 920))
  {
    if (synstrmaux_BuildAudioContentType("audio/L16;rate=", *(_DWORD *)(a1 + 944), v9, 0x30uLL) <= 0x2F)
    {
      synstrmaux_RegisterInStream((_WORD *)(a1 + 24), (uint64_t)v9, 1, a1 + 856);
      synstrmaux_RegisterInStream((_WORD *)(a1 + 24), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
        0,
        a1 + 888);
      synstrmaux_RegisterOutStream((_WORD *)(a1 + 24), (uint64_t)v9, a1 + 872);
      synstrmaux_RegisterOutStream((_WORD *)(a1 + 24), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
        a1 + 904);
      uint64_t v7 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 24), *(void *)(a1 + 848), a3, a4);
      if ((v7 & 0x80000000) != 0) {
        synstrmaux_CloseStreams((_WORD *)(a1 + 24), *(void *)(a1 + 848));
      }
    }
    else
    {
      return 9;
    }
  }
  return v7;
}

uint64_t audioins_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v95 = 0;
  uint64_t v96 = 0;
  int v94 = 0;
  uint64_t v92 = 0;
  uint64_t v93 = 0;
  uint64_t v7 = safeh_HandleCheck(a1, a2, 13546, 1056);
  if ((v7 & 0x80000000) != 0) {
    return 2341478408;
  }
  *a5 = 1;
  if (!*(void *)(a1 + 920)) {
    return v7;
  }
  if (*(void *)(a1 + 968))
  {
    uint64_t inserted = audioins_InsertAudio(a1);
    if ((inserted & 0x80000000) == 0 && !*(_DWORD *)(a1 + 992)) {
      uint64_t inserted = audioins_InsertAudioEnd(a1);
    }
    *a5 = 2;
    return inserted;
  }
  uint64_t inserted = (*(uint64_t (**)(void, void, char *, uint64_t *))(*(void *)(a1 + 848) + 144))(*(void *)(a1 + 888), *(void *)(a1 + 896), (char *)&v96 + 4, &v95);
  if ((inserted & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2571, "%s%x", v9, v10, v11, v12, "lhError");
    return inserted;
  }
  if (!HIDWORD(v96))
  {
    uint64_t v34 = *(void *)(a1 + 856);
    if (v34)
    {
      uint64_t inserted = (*(uint64_t (**)(uint64_t, void, char *, int *))(*(void *)(a1 + 848) + 144))(v34, *(void *)(a1 + 864), (char *)&v95 + 4, &v94);
      if ((inserted & 0x80000000) != 0) {
        log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2569, "%s%x", v35, v36, v37, v38, "lhError");
      }
    }
    else
    {
      HIDWORD(v95) = 0;
      int v94 = 1;
    }
    if ((inserted & 0x80000000) == 0 && v95 && v94)
    {
      uint64_t inserted = synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 24), *(void *)(a1 + 848));
      int v24 = 0;
    }
    else if (HIDWORD(v95))
    {
      int v24 = 1;
    }
    else
    {
      int v24 = 0;
      *a5 = 0;
    }
    goto LABEL_58;
  }
  uint64_t v13 = (*(uint64_t (**)(void, void, uint64_t *, char *))(*(void *)(a1 + 848) + 88))(*(void *)(a1 + 888), *(void *)(a1 + 896), &v93, (char *)&v96 + 4);
  if ((v13 & 0x80000000) != 0)
  {
    uint64_t inserted = v13;
    log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2571, "%s%x", v14, v15, v16, v17, "lhError");
    return inserted;
  }
  uint64_t inserted = (*(uint64_t (**)(void, void, uint64_t *, void))(*(void *)(a1 + 848) + 112))(*(void *)(a1 + 904), *(void *)(a1 + 912), &v92, HIDWORD(v96));
  if ((inserted & 0x80000000) != 0)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2570, "%s%x", v18, v19, v20, v21, "lhError");
    (*(void (**)(void, void, void))(*(void *)(a1 + 848) + 96))(*(void *)(a1 + 888), *(void *)(a1 + 896), 0);
    return inserted;
  }
  unsigned int v22 = HIDWORD(v96);
  HIDWORD(v96) >>= 5;
  if (v22 <= 0x1F)
  {
    LODWORD(v23) = 0;
    int v24 = 1;
LABEL_16:
    uint64_t v25 = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 848) + 120))(*(void *)(a1 + 904), *(void *)(a1 + 912), (32 * v23));
    if ((v25 & 0x80000000) != 0)
    {
      uint64_t inserted = v25;
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2570, "%s%x", v26, v27, v28, v29, "lhError");
      (*(void (**)(void, void, void))(*(void *)(a1 + 848) + 96))(*(void *)(a1 + 888), *(void *)(a1 + 896), 0);
    }
    else
    {
      uint64_t inserted = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 848) + 96))(*(void *)(a1 + 888), *(void *)(a1 + 896), (32 * v23));
      if ((inserted & 0x80000000) != 0) {
        log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2571, "%s%x", v30, v31, v32, v33, "lhError");
      }
    }
    goto LABEL_54;
  }
  uint64_t v39 = 0;
  uint64_t v41 = v92;
  uint64_t v40 = v93;
  uint64_t v42 = 12;
  while (2)
  {
    uint64_t v23 = v39;
    if (*(_DWORD *)(v40 + v42) != *(_DWORD *)(a1 + 956)) {
      *(_DWORD *)(a1 + 960) = 0;
    }
    uint64_t v43 = v41 + v42;
    long long v44 = *(_OWORD *)(v40 + v42 - 12);
    *(_OWORD *)(v43 + 4) = *(_OWORD *)(v40 + v42 + 4);
    *(_OWORD *)(v43 - 12) = v44;
    int v45 = *(_DWORD *)(v41 + v42) + *(_DWORD *)(a1 + 952);
    *(_DWORD *)uint64_t v43 = v45;
    if (*(_DWORD *)(v41 + v42 - 12) != 33) {
      *(_DWORD *)(v41 + v42) = *(_DWORD *)(a1 + 960) + v45;
    }
    HIDWORD(v46) = *(_DWORD *)(v40 + v42 - 12);
    LODWORD(v46) = HIDWORD(v46) - 8;
    switch((v46 >> 1))
    {
      case 0u:
        *(_DWORD *)(a1 + 956) = *(_DWORD *)(v40 + v42);
        *(_DWORD *)(a1 + 960) += *(_DWORD *)(a1 + 944) * *(_DWORD *)(v40 + v42 + 12) / 0x3E8u;
        goto LABEL_41;
      case 5u:
        *(_DWORD *)(a1 + 1020) = *(_DWORD *)(v40 + v42 + 12);
        *(_DWORD *)(a1 + 1016) = 1;
        goto LABEL_41;
      case 8u:
        *(_DWORD *)(a1 + 1008) = *(_DWORD *)(v40 + v42 + 12);
        *(_DWORD *)(a1 + 1004) = 1;
        goto LABEL_41;
      case 9u:
        uint64_t v62 = *(void *)(a1 + 856);
        if (v62)
        {
          (*(void (**)(uint64_t, void, uint64_t *))(*(void *)(a1 + 848) + 136))(v62, *(void *)(a1 + 864), &v96);
          uint64_t inserted = (*(uint64_t (**)(void, void, char *, int *))(*(void *)(a1 + 848) + 144))(*(void *)(a1 + 856), *(void *)(a1 + 864), (char *)&v95 + 4, &v94);
          unsigned int v63 = v96 >> 1;
          int v64 = HIDWORD(v95) >> 1;
          uint64_t v40 = v93;
        }
        else
        {
          unsigned int v63 = 0;
          int v64 = 0;
          int v94 = 1;
        }
        HIDWORD(v95) = v64;
        LODWORD(v96) = v63;
        uint64_t v65 = (*(_DWORD *)(a1 + 960) + *(_DWORD *)(v40 + v42));
        if ((inserted & 0x80000000) != 0 || !v94 && v64 + v63 <= v65)
        {
          log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 3, 0, (uint64_t)"Insert audio skipped! u32AudioPos=%d, iAudioPos=%d, cAudio = %d, iAudioPos + cAudio = %d", v19, v20, v21, v65);
LABEL_43:
          int v24 = 1;
          if ((inserted & 0x80000000) != 0) {
            goto LABEL_54;
          }
LABEL_44:
          if (v23)
          {
            if (v23 == 1)
            {
              LODWORD(v23) = 1;
            }
            else
            {
              uint64_t v47 = 0;
              int v48 = 0;
              uint64_t v49 = v92;
              while (1)
              {
                do
                {
                  uint64_t v50 = (long long *)(v49 + 32 * v47++);
                  uint64_t v51 = (long long *)(v49 + 32 * v47);
                  int v52 = v48;
                  if (*((_DWORD *)v50 + 3) > *((_DWORD *)v51 + 3))
                  {
                    long long v90 = *v50;
                    long long v53 = v90;
                    long long v91 = v50[1];
                    long long v54 = v91;
                    long long v55 = v51[1];
                    *uint64_t v50 = *v51;
                    v50[1] = v55;
                    *uint64_t v51 = v53;
                    v51[1] = v54;
                    int v52 = 1;
                    int v48 = 1;
                  }
                }
                while (v47 != v23 - 1);
                if (!v52) {
                  break;
                }
                uint64_t v47 = 0;
                int v48 = 0;
              }
            }
          }
          goto LABEL_16;
        }
        log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 3, 0, (uint64_t)"Insert audio NOT skipped! u32AudioPos=%d, iAudioPos=%d, cAudio = %d, iAudioPos + cAudio = %d", v19, v20, v21, v65);
        log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 3, 0, (uint64_t)"Before insert audio, I will write audio: u32AudioPos=%d, iAudioPos=%d, u32AudioPos-iAudioPos=%d (%d Bytes))", v66, v67, v68, v65);
        if (*(void *)(a1 + 856))
        {
          if (v65 > v96)
          {
            uint64_t inserted = (*(uint64_t (**)(void, void))(*(void *)(a1 + 848) + 128))(*(void *)(a1 + 872), *(void *)(a1 + 880));
            if ((inserted & 0x80000000) != 0) {
              log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2578, "%s%x", v69, v70, v71, v72, "lhError");
            }
          }
        }
        if (v94)
        {
          (*(void (**)(void, void, uint64_t *))(*(void *)(a1 + 848) + 136))(*(void *)(a1 + 872), *(void *)(a1 + 880), &v96);
          unsigned int v76 = v96 >> 1;
          LODWORD(v96) = v96 >> 1;
          if ((inserted & 0x80000000) == 0 && v76 < *(_DWORD *)(v92 + v42))
          {
            *(void *)&long long v90 = 0;
            unsigned int v77 = *(_DWORD *)(v92 + v42) - v76;
            log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 3, 0, (uint64_t)"Insert %u silence samples at %u", v73, v74, v75, v77);
            uint64_t v78 = (*(uint64_t (**)(void, void, long long *, void))(*(void *)(a1 + 848) + 112))(*(void *)(a1 + 872), *(void *)(a1 + 880), &v90, 2 * v77);
            if ((v78 & 0x80000000) == 0) {
              uint64_t v78 = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 848) + 120))(*(void *)(a1 + 872), *(void *)(a1 + 880), 2 * v77);
            }
            uint64_t inserted = v78;
          }
        }
        if (log_HasTraceTuningDataSubscriber(*(void *)(*(void *)(a1 + 16) + 32))) {
          log_OutTraceTuningData(*(uint64_t ***)(*(void *)(a1 + 16) + 32), 312, (uint64_t)"%s%s %s%s", v79, v80, v81, v82, v83, "BEG");
        }
        if ((inserted & 0x80000000) != 0) {
          goto LABEL_89;
        }
        uint64_t v84 = audioins_InsertAudioStart((void *)a1, *(void *)(v93 + v42 + 12));
        if ((v84 & 0x80000000) != 0) {
          goto LABEL_88;
        }
        uint64_t inserted = audioins_InsertAudio(a1);
        if ((inserted & 0x80000000) == 0 && !*(_DWORD *)(a1 + 992))
        {
          uint64_t v84 = audioins_InsertAudioEnd(a1);
LABEL_88:
          uint64_t inserted = v84;
        }
LABEL_89:
        LODWORD(v23) = v23 + 1;
        if (log_HasTraceTuningDataSubscriber(*(void *)(*(void *)(a1 + 16) + 32))) {
          log_OutTraceTuningData(*(uint64_t ***)(*(void *)(a1 + 16) + 32), 312, (uint64_t)"%s%u %s%s %s%u", v85, v86, v87, v88, v89, "POSREF");
        }
        int v24 = 0;
        *a5 = 2;
        if ((inserted & 0x80000000) == 0) {
          goto LABEL_44;
        }
LABEL_54:
        if (v23 == HIDWORD(v96) && v95) {
          *a5 = 2;
        }
LABEL_58:
        if ((inserted & 0x80000000) == 0)
        {
          if (v24)
          {
            uint64_t v56 = *(void *)(a1 + 856);
            if (v56)
            {
              uint64_t inserted = (*(uint64_t (**)(void, void, uint64_t, void, uint64_t, char *))(*(void *)(a1 + 848) + 128))(*(void *)(a1 + 872), *(void *)(a1 + 880), v56, *(void *)(a1 + 864), 0xFFFFFFFFLL, (char *)&v95 + 4);
              if ((inserted & 0x80000000) != 0) {
                log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2578, "%s%x", v57, v58, v59, v60, "lhError");
              }
            }
          }
        }
        return inserted;
      default:
LABEL_41:
        ++v39;
        v42 += 32;
        if (v23 + 1 < (unint64_t)HIDWORD(v96)) {
          continue;
        }
        LODWORD(v23) = v23 + 1;
        goto LABEL_43;
    }
  }
}

uint64_t audioins_ProcessEnd(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 13546, 1056) & 0x80000000) != 0) {
    return 2341478408;
  }
  audioins_InsertAudioEnd(a1);
  WSOLA__Initialise(*(void *)(a1 + 1032));
  uint64_t v3 = synstrmaux_CloseStreams((_WORD *)(a1 + 24), *(void *)(a1 + 848));
  uint64_t v4 = *(void *)(a1 + 920);
  if (v4) {
    (*(void (**)(void, void))(v4 + 56))(*(void *)(a1 + 928), *(void *)(a1 + 936));
  }
  return v3;
}

uint64_t audioins_GetParamU32(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int a4)
{
  uint64_t UInt = paramc_ParamGetUInt(*(void *)(*(void *)(a1 + 16) + 40), a2, a3);
  if ((UInt & 0x80000000) != 0)
  {
    *a3 = a4;
    uint64_t UInt = paramc_ParamSetUInt(*(void *)(*(void *)(a1 + 16) + 40), a2, a4);
    if ((UInt & 0x80000000) != 0) {
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 2579, "%s%s%s%x", v9, v10, v11, v12, "parameter");
    }
  }
  return UInt;
}

uint64_t audioins_SetDefaultAudioProsodyParameters(uint64_t a1)
{
  *(void *)(a1 + 1004) = 0;
  *(void *)(a1 + 1016) = 0;
  float v2 = (unsigned int *)(a1 + 1000);
  uint64_t result = audioins_GetParamU32(a1, (uint64_t)"volume", (unsigned int *)(a1 + 1000), 0x50u);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = audioins_GetParamU32(a1, (uint64_t)"audioinsertervolume", v2, *(_DWORD *)(a1 + 1000));
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = audioins_GetParamU32(a1, (uint64_t)"rate", (unsigned int *)(a1 + 1012), 0x64u);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = audioins_GetParamU32(a1, (uint64_t)"audioinserterrate", (unsigned int *)(a1 + 1012), *(_DWORD *)(a1 + 1012));
        if ((result & 0x80000000) == 0)
        {
          unsigned int v4 = 0;
          uint64_t result = audioins_GetParamU32(a1, (uint64_t)"audioinsertervolumeadjust", &v4, 1u);
          *(_DWORD *)(a1 + 1024) = v4 != 0;
          if ((result & 0x80000000) == 0)
          {
            unsigned int v5 = 0;
            uint64_t result = audioins_GetParamU32(a1, (uint64_t)"audioinserterrateadjust", &v5, 1u);
            *(_DWORD *)(a1 + 1028) = v5 != 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t audioinserter_loc_ParamCheckChange(uint64_t a1, char *__s1, const char *a3, _DWORD *a4)
{
  *a4 = 1;
  if (!strcmp(__s1, "frequencyhz"))
  {
    uint64_t result = 2341478417;
    if (!*(void *)(a1 + 856) && !*(void *)(a1 + 872)) {
      return 0;
    }
LABEL_11:
    *a4 = 0;
    return result;
  }
  if (strcmp(__s1, "audioinsertervolume"))
  {
    if (strcmp(__s1, "audioinserterrate") || (atoi(a3) - 401) > 0xFFFFFEA0) {
      return 0;
    }
    goto LABEL_10;
  }
  if (atoi(a3) > 0x64)
  {
LABEL_10:
    uint64_t result = 2341478415;
    goto LABEL_11;
  }
  return 0;
}

uint64_t audioinserter_loc_ParamLearnChange(uint64_t a1, char *__s1, const char *a3)
{
  if (!strcmp(__s1, "frequencyhz"))
  {
    uint64_t result = 2341478417;
    if (!*(void *)(a1 + 856) && !*(void *)(a1 + 872))
    {
      unsigned int v7 = LH_atou(a3);
      uint64_t result = 0;
      *(_DWORD *)(a1 + 944) = v7;
    }
  }
  else if (!strcmp(__s1, "audiooutputbufsamples"))
  {
    unsigned int v8 = LH_atou(a3);
    uint64_t result = 0;
    if (!v8) {
      unsigned int v8 = 1024;
    }
    *(_DWORD *)(a1 + 948) = v8;
  }
  else if (!strcmp(__s1, "audioinsertervolume"))
  {
    int v9 = atoi(a3);
    uint64_t result = 0;
    *(_DWORD *)(a1 + 1000) = v9;
  }
  else if (!strcmp(__s1, "audioinserterrate"))
  {
    int v10 = atoi(a3);
    uint64_t result = 0;
    *(_DWORD *)(a1 + 1012) = v10;
  }
  else if (!strcmp(__s1, "audioinsertervolumeadjust"))
  {
    int v11 = atoi(a3);
    uint64_t result = 0;
    *(_DWORD *)(a1 + 1024) = v11 != 0;
  }
  else if (!strcmp(__s1, "audioinserterrateadjust"))
  {
    int v12 = atoi(a3);
    uint64_t result = 0;
    *(_DWORD *)(a1 + 1028) = v12 != 0;
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t audioins_InsertAudio(uint64_t a1)
{
  unsigned int v27 = 0;
  unsigned int v26 = 0;
  uint64_t v25 = 0;
  unsigned int v24 = 1024;
  unsigned int v2 = *(_DWORD *)(a1 + 948);
  unsigned int v3 = *(_DWORD *)(a1 + 996);
  if (v2 >= v3) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = v2;
  }
  if (*(_DWORD *)(a1 + 1028))
  {
    uint64_t v5 = 1020;
    if (!*(_DWORD *)(a1 + 1016)) {
      uint64_t v5 = 1012;
    }
    int v6 = *(_DWORD *)(a1 + v5);
    char v7 = v2 >= *(_DWORD *)(a1 + 992);
    if (v4 <= 0x400)
    {
      uint64_t v8 = *(void *)(a1 + 1048);
    }
    else
    {
      uint64_t v8 = heap_Realloc(*(uint64_t **)(*(void *)(a1 + 1032) + 328), *(void *)(a1 + 1048), 2 * v4);
      *(void *)(a1 + 1048) = v8;
    }
    uint64_t v19 = (*(uint64_t (**)(void, void, uint64_t, uint64_t, unsigned int *, unsigned int *))(*(void *)(a1 + 920) + 88))(*(void *)(a1 + 968), *(void *)(a1 + 976), v4, v8, &v27, &v26);
    if ((v19 & 0x80000000) == 0)
    {
      if (*(_DWORD *)(a1 + 1024))
      {
        uint64_t v21 = 1008;
        if (!*(_DWORD *)(a1 + 1004)) {
          uint64_t v21 = 1000;
        }
        vol_ScaleToLevel(*(__int16 **)(a1 + 1048), v26, *(unsigned __int16 *)(a1 + v21));
      }
      WSOLA__rateChange_bet4_approach(*(void *)(a1 + 1032), v7, v6, *(__int16 **)(a1 + 1048), v26, *(_WORD **)(a1 + 1040), (int *)&v24, *(void *)(a1 + 848), *(void *)(a1 + 872), *(void *)(a1 + 880));
      unsigned int v20 = v24;
      goto LABEL_24;
    }
LABEL_27:
    (*(void (**)(void, void, void))(*(void *)(a1 + 848) + 120))(*(void *)(a1 + 872), *(void *)(a1 + 880), 0);
    return v19;
  }
  uint64_t v9 = (*(uint64_t (**)(void, void, __int16 **, void))(*(void *)(a1 + 848) + 112))(*(void *)(a1 + 872), *(void *)(a1 + 880), &v25, (2 * v4));
  if ((v9 & 0x80000000) != 0)
  {
    uint64_t v19 = v9;
    uint64_t v22 = *(void *)(*(void *)(a1 + 16) + 32);
LABEL_29:
    log_OutPublic(v22, (uint64_t)"AUDIOINSERTER", 2578, "%s%s%s%x", v10, v11, v12, v13, "uri");
    return v19;
  }
  uint64_t v14 = (*(uint64_t (**)(void, void, uint64_t, __int16 *, unsigned int *, unsigned int *))(*(void *)(a1 + 920) + 88))(*(void *)(a1 + 968), *(void *)(a1 + 976), v4, v25, &v27, &v26);
  if ((v14 & 0x80000000) != 0)
  {
    uint64_t v19 = v14;
    goto LABEL_27;
  }
  if (*(_DWORD *)(a1 + 1024))
  {
    uint64_t v18 = 1008;
    if (!*(_DWORD *)(a1 + 1004)) {
      uint64_t v18 = 1000;
    }
    vol_ScaleToLevel(v25, v27, *(unsigned __int16 *)(a1 + v18));
  }
  log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"AUDIOINSERTER", 3, 0, (uint64_t)"Insert %u audio samples for %s", v15, v16, v17, 0);
  uint64_t v19 = (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 848) + 120))(*(void *)(a1 + 872), *(void *)(a1 + 880), 2 * v26);
  if ((v19 & 0x80000000) != 0)
  {
    uint64_t v22 = *(void *)(*(void *)(a1 + 16) + 32);
    goto LABEL_29;
  }
  unsigned int v20 = v26;
LABEL_24:
  *(_DWORD *)(a1 + 952) += v20;
  *(_DWORD *)(a1 + 992) -= v27;
  return v19;
}

uint64_t audioins_InsertAudioEnd(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 968);
  if (v2)
  {
    uint64_t v3 = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)(a1 + 920) + 96))(v2, *(void *)(a1 + 976), 1);
    *(void *)(a1 + 968) = safeh_GetNullHandle();
    *(void *)(a1 + 976) = v4;
  }
  else
  {
    uint64_t v3 = 0;
  }
  *(void *)(a1 + 984) = 0;
  *(_DWORD *)(a1 + 992) = 0;
  return v3;
}

uint64_t audioins_InsertAudioStart(void *a1, uint64_t a2)
{
  char v4 = 0;
  uint64_t v24 = 0;
  uint64_t v5 = a1 + 123;
  int v6 = a1 + 124;
  char v7 = (char *)a1 + 996;
  uint64_t v8 = a1 + 121;
  char v9 = 1;
  uint64_t v10 = a2;
  do
  {
    if (v4)
    {
      uint64_t v11 = *(uint64_t (**)(void, void, uint64_t, void, uint64_t, uint64_t, uint64_t *))(a1[115] + 64);
      uint64_t NullHandle = safeh_GetNullHandle();
      uint64_t v14 = v11(a1[116], a1[117], a2, 0, NullHandle, v13, &v24);
      if ((v14 & 0x80000000) != 0)
      {
        uint64_t v21 = v14;
        goto LABEL_9;
      }
      uint64_t v10 = v24;
    }
    uint64_t v19 = (*(uint64_t (**)(void, void, uint64_t, void *, void *, char *, void *))(a1[115] + 80))(a1[116], a1[117], v10, v5, v6, v7, v8);
    char v20 = ((v19 & 0x1FFF) == 20) & v9;
    char v4 = 1;
    char v9 = 0;
  }
  while ((v20 & 1) != 0);
  uint64_t v21 = v19;
  if ((v19 & 0x80000000) == 0) {
    return v21;
  }
LABEL_9:
  log_OutPublic(*(void *)(a1[2] + 32), (uint64_t)"AUDIOINSERTER", 2561, 0, v15, v16, v17, v18, v23);
  return v21;
}

uint64_t vol_ScaleToLevel(__int16 *a1, unsigned int a2, int a3)
{
  if (a3 != 80 && a2)
  {
    int v3 = aVolScaleFactor_0[a3];
    uint64_t v4 = a2;
    do
    {
      int v5 = *a1 * v3;
      unsigned int v6 = v5 >> 15;
      if (v5 < -1073709056) {
        LOWORD(v6) = -32767;
      }
      if (v5 <= 0x3FFFFFFF) {
        __int16 v7 = v6;
      }
      else {
        __int16 v7 = 0x7FFF;
      }
      *a1++ = v7;
      --v4;
    }
    while (v4);
  }
  return 0;
}

uint64_t dsp_interpolatate_init(uint64_t *a1, uint64_t a2, int a3)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  *a1 = 0;
  uint64_t v6 = dsp_malloc(a2, 0x20u);
  if (!v6) {
    return 4294967294;
  }
  uint64_t v7 = v6;
  uint64_t result = 0;
  *(void *)uint64_t v7 = a2;
  *(void *)(v7 + 24) = 0;
  *(_DWORD *)(v7 + 12) = a3;
  *(_DWORD *)(v7 + 16) = 0;
  *a1 = v7;
  return result;
}

uint64_t dsp_interpolatate_deinit(uint64_t *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = *a1;
  if (!*a1) {
    return 0;
  }
  *(_DWORD *)(v2 + 16) = 0;
  dsp_free(*(void *)v2);
  uint64_t result = 0;
  *a1 = 0;
  return result;
}

uint64_t dsp_interpolate_set_target_rate(uint64_t result, float a2)
{
  *(float *)(result + 8) = a2;
  return result;
}

uint64_t dsp_interpolate_execute(uint64_t a1)
{
  int v1 = *(uint64_t (**)(void))(a1 + 24);
  if (v1) {
    return v1();
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t dsp_interpolate_linear(uint64_t result, uint64_t a2, uint64_t a3, int a4, int a5, unsigned int *a6)
{
  uint64_t v6 = result;
  int v7 = 0;
  LODWORD(result) = 0;
  int v8 = 0;
  int v9 = *(_DWORD *)(v6 + 12);
  *a6 = 0;
  float v10 = *(float *)(v6 + 16);
  uint64_t v11 = *(unsigned int *)(v6 + 12);
  float v12 = *(float *)(v6 + 8);
  float v13 = v10;
  do
  {
    if (v11)
    {
      int v14 = 0;
      uint64_t v15 = v11;
      do
      {
        float v16 = v10 * (float)*(__int16 *)(a3 + 2 * (v9 + v14));
        float v17 = v16 + (float)((float)(1.0 - v10) * (float)*(__int16 *)(a3 + 2 * (v8 + v14)));
        if (v17 >= -32767.0) {
          float v18 = v16 + (float)((float)(1.0 - v10) * (float)*(__int16 *)(a3 + 2 * (v8 + v14)));
        }
        else {
          float v18 = -32767.0;
        }
        if (v17 <= 32767.0) {
          float v19 = v18;
        }
        else {
          float v19 = 32767.0;
        }
        *(_WORD *)(a2 + 2 * (v7 + v14++)) = (int)v19;
        --v15;
      }
      while (v15);
    }
    uint64_t result = (result + 1);
    float v13 = v13 + v12;
    unsigned int v20 = v13;
    float v10 = v13 - (float)v13;
    BOOL v21 = v13 >= (float)(a4 - 1) || result == a5;
    int v8 = v11 * v20;
    int v9 = v11 * v20 + v11;
    v7 += v11;
  }
  while (!v21 && a4 - 1 > v20);
  *(float *)(v6 + 16) = v10;
  *a6 = v20;
  return result;
}

uint64_t dsp_interpolate_reset(uint64_t a1)
{
  *(_DWORD *)(a1 + 16) = 0;
  return 0;
}

uint64_t dsp_tempo_changer_init(uint64_t *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v4 = 0xFFFFFFFFLL;
  if (a1 && (a3 - 3) >= 0xFFFFFFFE)
  {
    *a1 = 0;
    uint64_t v9 = dsp_malloc(a2, 0x60u);
    if (v9)
    {
      uint64_t v10 = v9;
      *(void *)uint64_t v9 = a2;
      *(void *)(v9 + 80) = 0;
      *(_DWORD *)(v9 + 72) = 1;
      *(_DWORD *)(v9 + 8) = a3;
      uint64_t v11 = (void *)(v9 + 16);
      *(_DWORD *)(v9 + 32) = a4;
      uint64_t v12 = signal_fifo_init((uint64_t *)(v9 + 16), a2, a3);
      if (v12)
      {
        uint64_t v4 = v12;
      }
      else
      {
        uint64_t v13 = signal_fifo_init((uint64_t *)(v10 + 24), a2, a3);
        if (v13)
        {
          uint64_t v4 = v13;
          int v14 = v11;
        }
        else
        {
          uint64_t v4 = dsp_tempo_changer_set_target_tempo(v10, 1.0);
          if (!v4)
          {
            *a1 = v10;
            return v4;
          }
          signal_fifo_deinit(v11);
          int v14 = (void *)(v10 + 24);
        }
        signal_fifo_deinit(v14);
      }
      dsp_free(a2);
    }
    else
    {
      return 4294967294;
    }
  }
  return v4;
}

uint64_t dsp_tempo_changer_set_target_tempo(uint64_t a1, float a2)
{
  *(float *)(a1 + 12) = a2;
  *(void *)(a1 + 36) = 0xF00000028;
  int v4 = *(_DWORD *)(a1 + 32);
  unsigned int v5 = 8 * v4 / 0x3E8u;
  *(_DWORD *)(a1 + 52) = 8;
  *(_DWORD *)(a1 + 56) = v5;
  unsigned int v6 = 40 * v4 / 0x3E8u;
  unsigned int v7 = 15 * v4 / 0x3E8u;
  *(_DWORD *)(a1 + 44) = v6;
  *(_DWORD *)(a1 + 48) = v7;
  int v8 = 2 * v5;
  if (v6 < 2 * v5)
  {
    *(_DWORD *)(a1 + 44) = v8;
    unsigned int v6 = 2 * v5;
  }
  if (!*(void *)(a1 + 80))
  {
    uint64_t v9 = (void *)dsp_malloc(*(void *)a1, v8 * *(_DWORD *)(a1 + 8));
    *(void *)(a1 + 80) = v9;
    if (!v9) {
      return 4294967294;
    }
    dsp_memset(v9, 0, (2 * *(_DWORD *)(a1 + 56) * *(_DWORD *)(a1 + 8)));
    *(_DWORD *)(a1 + 72) = 1;
    unsigned int v5 = *(_DWORD *)(a1 + 56);
    unsigned int v6 = *(_DWORD *)(a1 + 44);
    unsigned int v7 = *(_DWORD *)(a1 + 48);
  }
  uint64_t result = 0;
  float v11 = (float)(v6 - v5) * a2;
  *(float *)(a1 + 60) = v11;
  unsigned int v12 = (v11 + 0.5 + (double)v5);
  if (v6 > v12) {
    unsigned int v12 = v6;
  }
  *(_DWORD *)(a1 + 68) = v12 + v7;
  return result;
}

uint64_t dsp_tempo_changer_deinit(void *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = (void *)*a1;
  if (!*a1) {
    return 0;
  }
  signal_fifo_deinit(v2 + 2);
  signal_fifo_deinit(v2 + 3);
  if (v2[10])
  {
    dsp_free(*v2);
    v2[10] = 0;
  }
  dsp_free(*v2);
  uint64_t result = 0;
  *a1 = 0;
  return result;
}

uint64_t wsola_exec(uint64_t a1)
{
  unsigned int v2 = 0;
  do
  {
    if (*(_DWORD *)(a1 + 72))
    {
      *(_DWORD *)(a1 + 72) = 0;
      *(_DWORD *)(a1 + 64) = 0;
      goto LABEL_31;
    }
    uint64_t rd_ptr = signal_fifo_get_rd_ptr(*(void *)(a1 + 16));
    if ((*(_DWORD *)(a1 + 48) - 9) > 0xFFFFFFFA)
    {
      unsigned int v4 = 0;
      unsigned int v5 = 0;
      float v8 = -3.4028e38;
    }
    else
    {
      unsigned int v4 = 0;
      unsigned int v5 = 0;
      unsigned int v6 = 4;
      float v7 = -3.4028e38;
      float v8 = -3.4028e38;
      do
      {
        float v9 = cross_correlation(a1, (__int16 *)(rd_ptr + 2 * *(_DWORD *)(a1 + 8) * v6), *(__int16 **)(a1 + 80));
        if (v9 > v8)
        {
          float v8 = v9;
          unsigned int v5 = v6;
          float v7 = v9;
          unsigned int v4 = v6;
        }
        if (v9 > v7)
        {
          float v7 = v9;
          unsigned int v4 = v6;
        }
        v6 += 8;
      }
      while (v6 < *(_DWORD *)(a1 + 48) - 4);
      if (v5 > 0xFFFFFFFB) {
        goto LABEL_18;
      }
    }
    unsigned int v10 = v5;
    do
    {
      float v11 = cross_correlation(a1, (__int16 *)(rd_ptr + 2 * *(_DWORD *)(a1 + 8) * v10), *(__int16 **)(a1 + 80));
      if (v11 > v8)
      {
        float v8 = v11;
        unsigned int v5 = v10;
      }
      ++v10;
    }
    while (v10 < v5 + 4);
LABEL_18:
    unsigned int v12 = v4 + 4;
    if (v4 <= 0xFFFFFFFB)
    {
      do
      {
        float v13 = cross_correlation(a1, (__int16 *)(rd_ptr + 2 * *(_DWORD *)(a1 + 8) * v4), *(__int16 **)(a1 + 80));
        if (v13 > v8)
        {
          float v8 = v13;
          unsigned int v5 = v4;
        }
        ++v4;
      }
      while (v4 < v12);
    }
    unsigned int v14 = *(_DWORD *)(a1 + 56);
    uint64_t result = signal_fifo_ensure_free_space(*(void *)(a1 + 24), v14);
    if (result) {
      return result;
    }
    uint64_t wr_ptr = signal_fifo_get_wr_ptr(*(void *)(a1 + 24));
    uint64_t v17 = signal_fifo_get_rd_ptr(*(void *)(a1 + 16));
    unsigned int v18 = *(_DWORD *)(a1 + 56);
    if (v18)
    {
      int v19 = 0;
      int v20 = 0;
      float v21 = 1.0 / (float)v14;
      int v22 = *(_DWORD *)(a1 + 8);
      float v23 = 0.0;
      float v24 = 1.0;
      do
      {
        if (v22)
        {
          int v25 = 0;
          uint64_t v26 = *(void *)(a1 + 80);
          do
          {
            *(_WORD *)(wr_ptr + 2 * (v19 + v25)) = (int)(float)((float)(v24
                                                                                      * (float)*(__int16 *)(v26 + 2 * (v19 + v25)))
                                                                              + (float)(v23
                                                                                      * (float)*(__int16 *)(v17 + 2 * v22 * v5 + 2 * (v19 + v25))));
            ++v25;
          }
          while (v22 != v25);
        }
        float v23 = v21 + v23;
        float v24 = v24 - v21;
        ++v20;
        v19 += v22;
      }
      while (v20 != v18);
    }
    uint64_t result = signal_fifo_push_samples_nodata(*(void *)(a1 + 24), v18);
    if (result) {
      return result;
    }
    unsigned int v2 = *(_DWORD *)(a1 + 56) + v5;
LABEL_31:
    uint64_t v27 = signal_fifo_get_rd_ptr(*(void *)(a1 + 16));
    uint64_t result = signal_fifo_push_samples(*(void *)(a1 + 24), (const void *)(v27 + 2 * *(_DWORD *)(a1 + 8) * v2), *(_DWORD *)(a1 + 44) - 2 * *(_DWORD *)(a1 + 56));
    if (result) {
      return result;
    }
    dsp_memcpy(*(void **)(a1 + 80), (const void *)(v27 + 2 * (*(_DWORD *)(a1 + 44) + v2 - 2 * *(_DWORD *)(a1 + 56)) * *(_DWORD *)(a1 + 8)), (2 * *(_DWORD *)(a1 + 8) * *(_DWORD *)(a1 + 56)));
    float v28 = *(float *)(a1 + 60) + *(float *)(a1 + 64);
    *(float *)(a1 + 64) = v28;
    signal_fifo_pop_samples(*(_DWORD **)(a1 + 16), (int)v28);
    *(float *)(a1 + 64) = *(float *)(a1 + 64) - (float)(int)v28;
  }
  while (signal_fifo_get_num_unread_samples(*(_DWORD **)(a1 + 16)) >= *(_DWORD *)(a1 + 68));
  return 0;
}

uint64_t dsp_tempo_push_samples_from_fifo(uint64_t a1, uint64_t a2)
{
  uint64_t result = signal_fifo_move_samples(*(void *)(a1 + 16), a2);
  if ((result & 0x80000000) == 0)
  {
    if (signal_fifo_get_num_unread_samples(*(_DWORD **)(a1 + 16)) <= *(_DWORD *)(a1 + 68))
    {
      return 0;
    }
    else
    {
      return wsola_exec(a1);
    }
  }
  return result;
}

uint64_t dsp_tempo_reset(uint64_t a1)
{
  uint64_t result = dsp_tempo_changer_set_target_tempo(a1, 1.0);
  if (!result)
  {
    uint64_t result = signal_fifo_clear(*(void *)(a1 + 16));
    if (!result)
    {
      uint64_t result = signal_fifo_clear(*(void *)(a1 + 24));
      if (!result)
      {
        if (*(void *)(a1 + 80))
        {
          dsp_free(*(void *)a1);
          *(void *)(a1 + 80) = 0;
        }
        uint64_t result = 0;
        *(_DWORD *)(a1 + 72) = 1;
      }
    }
  }
  return result;
}

float cross_correlation(uint64_t a1, __int16 *a2, __int16 *a3)
{
  uint64_t v3 = (*(_DWORD *)(a1 + 56) * *(_DWORD *)(a1 + 8));
  if (!v3) {
    goto LABEL_5;
  }
  float v4 = 0.0;
  unsigned int v5 = a3;
  uint64_t v6 = (*(_DWORD *)(a1 + 56) * *(_DWORD *)(a1 + 8));
  do
  {
    int v7 = *v5++;
    float v4 = v4 + (float)((float)v7 * (float)v7);
    --v6;
  }
  while (v6);
  if (v4 <= 1.1755e-38) {
LABEL_5:
  }
    float v4 = 1.0;
  *(float *)(a1 + 88) = v4;
  float v8 = 0.0;
  if (v3)
  {
    do
    {
      int v9 = *a2++;
      float v10 = (float)v9;
      int v11 = *a3++;
      float v8 = v8 + (float)(v10 * (float)v11);
      --v3;
    }
    while (v3);
  }
  float result = v8 / v4;
  if (result < 0.0) {
    return -result;
  }
  return result;
}

uint64_t rateTrans_init(uint64_t **a1, uint64_t a2, int a3)
{
  uint64_t v3 = 0xFFFFFFFFLL;
  if (a1 && (a3 - 3) >= 0xFFFFFFFE)
  {
    *a1 = 0;
    uint64_t v7 = dsp_malloc(a2, 0x40u);
    if (v7)
    {
      float v8 = (uint64_t *)v7;
      *(void *)uint64_t v7 = a2;
      *(_DWORD *)(v7 + 48) = 1;
      int v9 = (void *)(v7 + 8);
      uint64_t v10 = signal_fifo_init((uint64_t *)(v7 + 8), a2, a3);
      if (v10)
      {
        uint64_t v3 = v10;
      }
      else
      {
        uint64_t v11 = signal_fifo_init(v8 + 2, a2, a3);
        if (v11)
        {
          uint64_t v3 = v11;
          unsigned int v12 = v9;
        }
        else
        {
          uint64_t v13 = signal_fifo_init(v8 + 3, a2, a3);
          if (v13)
          {
            uint64_t v3 = v13;
          }
          else
          {
            uint64_t v14 = dsp_biquad_init(v8 + 4, a2, a3, 1);
            if (v14)
            {
              uint64_t v3 = v14;
            }
            else
            {
              uint64_t v3 = dsp_interpolatate_init(v8 + 5, a2, a3);
              if (!v3)
              {
                set_DctBrk(v8[5], (uint64_t)dsp_interpolate_linear);
                *a1 = v8;
                return v3;
              }
              dsp_biquad_deinit(v8 + 4);
            }
            signal_fifo_deinit(v8 + 3);
          }
          signal_fifo_deinit(v9);
          unsigned int v12 = v8 + 2;
        }
        signal_fifo_deinit(v12);
      }
      dsp_free(a2);
    }
    else
    {
      return 4294967294;
    }
  }
  return v3;
}

uint64_t rateTrans_deinit(void *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v2 = (void *)*a1;
  if (!*a1) {
    return 0;
  }
  dsp_interpolatate_deinit(v2 + 5);
  dsp_biquad_deinit(v2 + 4);
  signal_fifo_deinit(v2 + 1);
  signal_fifo_deinit(v2 + 2);
  signal_fifo_deinit(v2 + 3);
  dsp_free(*v2);
  uint64_t result = 0;
  *a1 = 0;
  return result;
}

uint64_t rateTrans_set_rate(uint64_t a1, float a2)
{
  *(float *)(a1 + 52) = a2;
  if (a2 <= 1.0)
  {
    if (a2 < 1.1755e-38) {
      return 0xFFFFFFFFLL;
    }
    float v3 = a2 * 0.5;
  }
  else
  {
    float v3 = 1.0 / (float)(a2 + a2);
  }
  *(float *)(a1 + 56) = v3 * 0.9;
  dsp_interpolate_set_target_rate(*(void *)(a1 + 40), a2);
  uint64_t v5 = *(void *)(a1 + 32);
  float v6 = *(float *)(a1 + 56);
  return dsp_biquad_create_low_pass_filter(v5, v6);
}

uint64_t rateTrans_elaborate(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 48))
  {
    uint64_t v3 = *(void *)(a1 + 24);
    float v4 = *(_DWORD **)(a1 + 8);
    goto LABEL_6;
  }
  if (*(float *)(a1 + 52) > 1.0)
  {
    uint64_t result = dsp_biquad_process_fifos(*(void *)(a1 + 32), *(void *)(a1 + 16), *(_DWORD **)(a1 + 8));
    if (result) {
      return result;
    }
    float v4 = *(_DWORD **)(a1 + 16);
    uint64_t v3 = *(void *)(a1 + 24);
LABEL_6:
    uint64_t result = rateTrans_do_trans(a1, v3, v4);
    if (result) {
      return result;
    }
    return 0;
  }
  uint64_t result = rateTrans_do_trans(a1, *(void *)(a1 + 16), *(_DWORD **)(a1 + 8));
  if (!result)
  {
    uint64_t result = dsp_biquad_process_fifos(*(void *)(a1 + 32), *(void *)(a1 + 24), *(_DWORD **)(a1 + 16));
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t rateTrans_push_samples_from_fifo(uint64_t a1, uint64_t a2)
{
  uint64_t result = signal_fifo_move_samples(*(void *)(a1 + 8), a2);
  if ((result & 0x80000000) == 0)
  {
    return rateTrans_elaborate(a1);
  }
  return result;
}

uint64_t rateTrans_push_samples_to_fifo(uint64_t a1, uint64_t a2)
{
  return signal_fifo_move_samples(a2, *(void *)(a1 + 24));
}

uint64_t rateTrans_reset(uint64_t a1)
{
  *(_DWORD *)(a1 + 48) = 1;
  uint64_t result = dsp_interpolate_reset(*(void *)(a1 + 40));
  if (!result)
  {
    dsp_biquad_flush(*(void *)(a1 + 32));
    uint64_t result = signal_fifo_clear(*(void *)(a1 + 8));
    if (!result)
    {
      uint64_t result = signal_fifo_clear(*(void *)(a1 + 16));
      if (!result)
      {
        uint64_t v3 = *(void *)(a1 + 24);
        return signal_fifo_clear(v3);
      }
    }
  }
  return result;
}

uint64_t rateTrans_do_trans(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  unsigned int num_unread_samples = signal_fifo_get_num_unread_samples(a3);
  if (num_unread_samples < 2) {
    return 0;
  }
  uint64_t v8 = (int)((float)((float)num_unread_samples / *(float *)(a1 + 52)) + 1.0);
  uint64_t result = signal_fifo_ensure_free_space(a2, v8);
  if (!result)
  {
    signal_fifo_get_rd_ptr((uint64_t)a3);
    signal_fifo_get_wr_ptr(a2);
    int v9 = dsp_interpolate_execute(*(void *)(a1 + 40));
    if (v9 <= (int)v8)
    {
      unsigned int v10 = v9;
      signal_fifo_pop_samples(a3, 0);
      return signal_fifo_push_samples_nodata(a2, v10);
    }
    else
    {
      return 4294967293;
    }
  }
  return result;
}

uint64_t dsp_malloc(uint64_t a1, unsigned int a2)
{
  return heap_Alloc(a1, a2);
}

void *dsp_memcpy(void *a1, const void *a2, size_t __n)
{
  return memcpy(a1, a2, __n);
}

void *dsp_memset(void *a1, int a2, size_t __len)
{
  return memset(a1, a2, __len);
}

void *dsp_memmove_samples(void *a1, const void *a2, unsigned int a3)
{
  return memmove(a1, a2, 2 * a3);
}

uint64_t dsp_timbre_init(uint64_t *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v4 = 0xFFFFFFFFLL;
  if (a1 && (a3 - 3) >= 0xFFFFFFFE)
  {
    *a1 = 0;
    int v9 = (void *)dsp_malloc(a2, 0x50u);
    if (v9)
    {
      uint64_t v10 = (uint64_t)v9;
      *int v9 = a2;
      uint64_t v11 = v9 + 7;
      uint64_t v12 = signal_fifo_init(v9 + 7, a2, a3);
      if (v12)
      {
        uint64_t v4 = v12;
      }
      else
      {
        uint64_t v13 = signal_fifo_init((uint64_t *)(v10 + 48), a2, a3);
        if (v13)
        {
          uint64_t v4 = v13;
          uint64_t v14 = v11;
        }
        else
        {
          uint64_t v15 = dsp_tempo_changer_init((uint64_t *)(v10 + 64), a2, a3, a4);
          if (!v15)
          {
            uint64_t v4 = rateTrans_init((uint64_t **)(v10 + 72), a2, a3);
            if (!v4)
            {
              *(_DWORD *)(v10 + 40) = 0;
              dsp_timbre_reset(v10);
              *a1 = v10;
              return v4;
            }
            signal_fifo_deinit(v11);
            signal_fifo_deinit((void *)(v10 + 48));
            dsp_tempo_changer_deinit((void *)(v10 + 64));
            goto LABEL_12;
          }
          uint64_t v4 = v15;
          signal_fifo_deinit(v11);
          uint64_t v14 = (void *)(v10 + 48);
        }
        signal_fifo_deinit(v14);
      }
LABEL_12:
      dsp_free(a2);
      return v4;
    }
    return 4294967294;
  }
  return v4;
}

uint64_t dsp_timbre_reset(uint64_t a1)
{
  uint64_t result = dsp_tempo_reset(*(void *)(a1 + 64));
  if (!result)
  {
    uint64_t result = rateTrans_reset(*(void *)(a1 + 72));
    if (!result)
    {
      *(void *)(a1 + 8) = 0x3F80000000000000;
      *(_DWORD *)(a1 + 20) = 0;
      *(_DWORD *)(a1 + 24) = 0;
      *(_DWORD *)(a1 + 16) = 1065353216;
      *(void *)(a1 + 40) = 0;
      uint64_t result = signal_fifo_clear(*(void *)(a1 + 48));
      if (!result)
      {
        uint64_t result = signal_fifo_clear(*(void *)(a1 + 56));
        if (!result)
        {
          signal_fifo_set_backlog_size(*(void *)(a1 + 48), 0);
          return dsp_timbre_recalculate(a1);
        }
      }
    }
  }
  return result;
}

uint64_t dsp_timbre_deinit(void *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v2 = (void *)*a1;
  if (!*a1) {
    return 0;
  }
  signal_fifo_deinit(v2 + 7);
  signal_fifo_deinit(v2 + 6);
  dsp_tempo_changer_deinit(v2 + 8);
  rateTrans_deinit(v2 + 9);
  dsp_free(*v2);
  uint64_t result = 0;
  *a1 = 0;
  return result;
}

uint64_t dsp_timbre_set_target_timbre(uint64_t a1, float a2)
{
  *(float *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 20) = a2 != 0.0;
  *(_DWORD *)(a1 + 24) = 1;
  return 0;
}

uint64_t dsp_timbre_push_samples(uint64_t a1, __int16 *a2, int a3)
{
  LODWORD(v3) = a3;
  uint64_t v6 = LDOString_BorrowAllocator(*(void *)(a1 + 64));
  if (!v6) {
    return 4294967293;
  }
  uint64_t v7 = v6;
  if (v3)
  {
    uint64_t v8 = v3;
    float v9 = 0.0;
    uint64_t v10 = a2;
    do
    {
      int v11 = *v10++;
      float v9 = v9 + (float)v11;
      --v8;
    }
    while (v8);
  }
  else
  {
    float v9 = 0.0;
  }
  *(float *)(a1 + 40) = v9 / (float)v3;
  int v13 = *(_DWORD *)(a1 + 44);
  if (v13 == 3)
  {
    if (!*(_DWORD *)(a1 + 24))
    {
LABEL_20:
      uint64_t result = signal_fifo_push_samples(*(void *)(a1 + 48), a2, v3);
      if (!result)
      {
        uint64_t result = dsp_tempo_push_samples_from_fifo(*(void *)(a1 + 64), *(void *)(a1 + 48));
        if (!result)
        {
          uint64_t result = rateTrans_push_samples_from_fifo(*(void *)(a1 + 72), v7);
          if (!result)
          {
            uint64_t result = rateTrans_push_samples_to_fifo(*(void *)(a1 + 72), *(void *)(a1 + 56));
            if ((result & 0x80000000) == 0) {
              return 0;
            }
          }
        }
      }
      return result;
    }
    *(_DWORD *)(a1 + 24) = 0;
    int v13 = 4;
  }
  else
  {
    if (v13) {
      goto LABEL_16;
    }
    if (!*(_DWORD *)(a1 + 24) || (int v14 = *(_DWORD *)(a1 + 20), *(_DWORD *)(a1 + 24) = 0, !v14))
    {
LABEL_17:
      uint64_t v15 = *(void *)(a1 + 56);
      float v16 = a2;
      unsigned int v17 = v3;
      goto LABEL_18;
    }
    int v13 = 1;
  }
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 44) = v13;
LABEL_16:
  switch(v13)
  {
    case 0:
      goto LABEL_17;
    case 1:
      signal_fifo_set_backlog_size(*(void *)(a1 + 48), 0);
      uint64_t result = dsp_tempo_push_samples_from_fifo(*(void *)(a1 + 64), *(void *)(a1 + 48));
      if (result) {
        return result;
      }
      uint64_t result = rateTrans_push_samples_from_fifo(*(void *)(a1 + 72), v7);
      if (result) {
        return result;
      }
      uint64_t result = rateTrans_push_samples_to_fifo(*(void *)(a1 + 72), *(void *)(a1 + 56));
      if (result) {
        return result;
      }
      *(_DWORD *)(a1 + 44) = 2;
LABEL_29:
      if (!v3) {
        return 0;
      }
      uint64_t v3 = v3;
      while (2)
      {
        int v18 = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 28) = v18 + 1;
        if (*(float *)(a1 + 40) < 3.0 || v18 >= 2047) {
          goto LABEL_50;
        }
        uint64_t result = signal_fifo_push_samples(*(void *)(a1 + 48), a2, 1u);
        if (!result)
        {
          uint64_t result = dsp_tempo_push_samples_from_fifo(*(void *)(a1 + 64), *(void *)(a1 + 48));
          if (!result)
          {
            uint64_t result = rateTrans_push_samples_from_fifo(*(void *)(a1 + 72), v7);
            if (!result)
            {
              uint64_t result = rateTrans_push_samples_to_fifo(*(void *)(a1 + 72), *(void *)(a1 + 56));
              if ((result & 0x80000000) == 0)
              {
                ++a2;
                if (!--v3) {
                  return 0;
                }
                continue;
              }
            }
          }
        }
        return result;
      }
    case 2:
      goto LABEL_29;
    case 3:
      goto LABEL_20;
    case 4:
      if (!v3) {
        return 0;
      }
      uint64_t v3 = v3;
      break;
    default:
      return 0;
  }
  while (1)
  {
    int v19 = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 28) = v19 + 1;
    if (*(float *)(a1 + 40) < 3.0 || v19 >= 2047) {
      break;
    }
    uint64_t result = signal_fifo_push_samples(*(void *)(a1 + 48), a2, 1u);
    if (result) {
      return result;
    }
    uint64_t result = dsp_tempo_push_samples_from_fifo(*(void *)(a1 + 64), *(void *)(a1 + 48));
    if (result) {
      return result;
    }
    uint64_t result = rateTrans_push_samples_from_fifo(*(void *)(a1 + 72), v7);
    if (result) {
      return result;
    }
    uint64_t result = rateTrans_push_samples_to_fifo(*(void *)(a1 + 72), *(void *)(a1 + 56));
    if ((result & 0x80000000) != 0) {
      return result;
    }
    ++a2;
    if (!--v3) {
      return 0;
    }
  }
LABEL_50:
  uint64_t result = dsp_timbre_recalculate(a1);
  if (!result)
  {
    *(_DWORD *)(a1 + 44) = 3;
    uint64_t v15 = *(void *)(a1 + 48);
    float v16 = a2;
    unsigned int v17 = v3;
LABEL_18:
    uint64_t result = signal_fifo_push_samples(v15, v16, v17);
    if (result) {
      return result;
    }
    return 0;
  }
  return result;
}

uint64_t dsp_timbre_recalculate(uint64_t a1)
{
  float v2 = 1.1755e-38;
  if ((float)((float)(*(float *)(a1 + 8) / 100.0) + 1.0) >= 1.1755e-38) {
    float v2 = (float)(*(float *)(a1 + 8) / 100.0) + 1.0;
  }
  float v3 = (float)(*(float *)(a1 + 16) + -1.0) + v2;
  *(float *)(a1 + 32) = (float)(*(float *)(a1 + 12) + -1.0) + (float)(1.0 / v2);
  *(float *)(a1 + 36) = v3;
  uint64_t result = rateTrans_set_rate(*(void *)(a1 + 72), v3);
  if (!result)
  {
    uint64_t v5 = *(void *)(a1 + 64);
    float v6 = *(float *)(a1 + 32);
    return dsp_tempo_changer_set_target_tempo(v5, v6);
  }
  return result;
}

uint64_t dsp_timbre_get_samples(uint64_t a1, void *a2, unsigned int a3)
{
  return signal_fifo_get_samples(*(void *)(a1 + 56), a2, a3);
}

uint64_t dsp_timbre_flush(uint64_t a1)
{
  return 0;
}

uint64_t dspeffects_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2360352769;
  }
  uint64_t result = 0;
  *a2 = &IDspEffects;
  return result;
}

uint64_t dspeffects_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = 2360352778;
  uint64_t v50 = 0;
  uint64_t v51 = 0;
  if (!a5) {
    return 2360352775;
  }
  uint64_t inited = InitRsrcFunction(a3, a4, &v51);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  *(void *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  log_OutText(v51[4], (uint64_t)"DSPEFFECTS", 4, 0, (uint64_t)"Entering dspeffects_ObjOpen", v10, v11, v12, v48);
  uint64_t v13 = heap_Calloc((void *)v51[1], 1, 992);
  if (v13)
  {
    uint64_t v18 = v13;
    *(void *)(v13 + 960) = 0x6400000000;
    uint64_t v19 = heap_Alloc(v51[1], 256);
    *(void *)(v18 + 952) = v19;
    int v20 = v51;
    if (v19)
    {
      *(void *)(v18 + 8) = a4;
      *(void *)(v18 + 16) = v20;
      *(void *)uint64_t v18 = a3;
      uint64_t Object = objc_GetObject(v51[6], (uint64_t)"SYNTHSTREAM", &v50);
      if ((Object & 0x80000000) != 0)
      {
        uint64_t v32 = 2574;
        uint64_t v33 = v51;
        uint64_t v5 = Object;
        goto LABEL_22;
      }
      *(void *)(v18 + 848) = *(void *)(v50 + 8);
      if ((objc_GetObject(v51[6], (uint64_t)"AUDIOFETCHER", &v50) & 0x80000000) == 0)
      {
        uint64_t v30 = v50;
        if (*(unsigned char *)v50 == 1)
        {
          uint64_t v31 = *(void *)(v50 + 8);
          if (v31)
          {
            *(void *)(v18 + 920) = v31;
            *(_OWORD *)(v18 + 928) = *(_OWORD *)(v30 + 16);
            goto LABEL_17;
          }
        }
        objc_ReleaseObject(v51[6], (uint64_t)"AUDIOFETCHER");
      }
      log_OutPublic(v51[4], (uint64_t)"DSPEFFECTS", 2560, 0, v26, v27, v28, v29, v49);
LABEL_17:
      uint64_t ParamU32 = dspeffects_GetParamU32(v18, (uint64_t)"frequencyhz", (unsigned int *)(v18 + 980), 0x1F40u);
      if ((ParamU32 & 0x80000000) != 0
        || (uint64_t ParamU32 = dspeffects_GetParamS32(v18, (int *)(v18 + 976)), (ParamU32 & 0x80000000) != 0))
      {
        uint64_t v5 = ParamU32;
        goto LABEL_24;
      }
      uint64_t v39 = dspeffects_GetParamU32(v18, (uint64_t)"timbre", (unsigned int *)(v18 + 968), 0x64u);
      int v40 = MapProsodyValue_Scaling(50, 100, 200, *(_DWORD *)(v18 + 976), *(_DWORD *)(v18 + 968));
      *(_DWORD *)(v18 + 968) = v40;
      *(_DWORD *)(v18 + 972) = v40;
      if ((v39 & 0x80000000) != 0)
      {
        uint64_t v5 = v39;
        goto LABEL_24;
      }
      int v41 = dsp_timbre_init((uint64_t *)(v18 + 944), v51[1], 1, *(_DWORD *)(v18 + 980));
      uint64_t v33 = v51;
      if (!v41)
      {
        unint64_t v44 = 0;
        do
        {
          uint64_t v45 = v33[5];
          unint64_t v46 = off_264113428[v44];
          v52[0] = v18;
          v52[1] = dspeffects_loc_ParamCheckChange;
          v52[2] = dspeffects_loc_ParamLearnChange;
          uint64_t v47 = paramc_ListenerAdd(v45, v46, v52);
          uint64_t v5 = v47;
          if (v44 > 1) {
            break;
          }
          ++v44;
        }
        while ((v47 & 0x80000000) == 0);
        if ((v47 & 0x80000000) == 0)
        {
          int v42 = 55546;
          goto LABEL_25;
        }
LABEL_24:
        log_OutPublic(v51[4], (uint64_t)"DSPEFFECTS", 2580, "%s%x", v35, v36, v37, v38, "lhError");
        *(void *)a5 = v18;
        *(_DWORD *)(a5 + 8) = 55546;
        dspeffects_ObjClose((void *)v18, *(void *)(a5 + 8));
        uint64_t v18 = 0;
        int v42 = 0;
LABEL_25:
        *(void *)a5 = v18;
        *(_DWORD *)(a5 + 8) = v42;
        log_OutText(v51[4], (uint64_t)"DSPEFFECTS", 4, 0, (uint64_t)"Leaving dspeffects_ObjOpen: %x", v36, v37, v38, v5);
        return v5;
      }
      uint64_t v32 = 2577;
LABEL_22:
      log_OutPublic(v33[4], (uint64_t)"DSPEFFECTS", v32, 0, v22, v23, v24, v25, v49);
      goto LABEL_24;
    }
    heap_Free((void *)v51[1], v18);
  }
  log_OutPublic(v51[4], (uint64_t)"DSPEFFECTS", 2577, 0, v14, v15, v16, v17, v49);
  return v5;
}

uint64_t dspeffects_ObjClose(void *a1, int a2)
{
  if ((safeh_HandleCheck((uint64_t)a1, a2, 55546, 992) & 0x80000000) != 0) {
    return 2360352776;
  }
  uint64_t v6 = a1[2];
  log_OutText(*(void *)(v6 + 32), (uint64_t)"DSPEFFECTS", 4, 0, (uint64_t)"Entering dspeffects_ObjClose", v3, v4, v5, v20);
  dsp_timbre_deinit(a1 + 118);
  unint64_t v7 = 0;
  do
  {
    uint64_t v8 = *(void *)(v6 + 40);
    float v9 = off_264113428[v7];
    *(void *)&long long v21 = a1;
    *((void *)&v21 + 1) = dspeffects_loc_ParamCheckChange;
    uint64_t v22 = dspeffects_loc_ParamLearnChange;
    uint64_t v10 = paramc_ListenerRemove(v8, v9, &v21);
    uint64_t v11 = v10;
    if (v7 > 1) {
      break;
    }
    ++v7;
  }
  while ((v10 & 0x80000000) == 0);
  if (a1[106])
  {
    int v12 = objc_ReleaseObject(*(void *)(v6 + 48), (uint64_t)"SYNTHSTREAM");
    if (v12 >= 0 || (int)v11 <= -1) {
      uint64_t v11 = v11;
    }
    else {
      uint64_t v11 = v12;
    }
  }
  if (a1[115])
  {
    int v14 = objc_ReleaseObject(*(void *)(v6 + 48), (uint64_t)"AUDIOFETCHER");
    if (v14 >= 0 || (int)v11 <= -1) {
      uint64_t v11 = v11;
    }
    else {
      uint64_t v11 = v14;
    }
  }
  heap_Free(*(void **)(v6 + 8), a1[119]);
  heap_Free(*(void **)(v6 + 8), (uint64_t)a1);
  log_OutText(*(void *)(v6 + 32), (uint64_t)"DSPEFFECTS", 4, 0, (uint64_t)"Leaving dspEffects_ObjClose: %x", v16, v17, v18, v11);
  return v11;
}

uint64_t dspeffects_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v7 = 2360352776;
  uint64_t v8 = safeh_HandleCheck(a1, a2, 55546, 992);
  if ((v8 & 0x80000000) == 0)
  {
    uint64_t v9 = v8;
    synstrmaux_InitStreamOpener(a1 + 24, *(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS");
    if (*(void *)(a1 + 920))
    {
      *(_DWORD *)(a1 + 960) = 0;
      if (!dsp_timbre_reset(*(void *)(a1 + 944)))
      {
        uint64_t ParamU32 = dspeffects_GetParamU32(a1, (uint64_t)"frequencyhz", (unsigned int *)(a1 + 980), 0x1F40u);
        if ((ParamU32 & 0x80000000) != 0
          || (uint64_t ParamU32 = dspeffects_GetParamS32(a1, (int *)(a1 + 976)), (ParamU32 & 0x80000000) != 0))
        {
          uint64_t v7 = ParamU32;
        }
        else
        {
          dspeffects_GetParamU32(a1, (uint64_t)"timbre", (unsigned int *)(a1 + 968), 0x64u);
          int v11 = MapProsodyValue_Scaling(50, 100, 200, *(_DWORD *)(a1 + 976), *(_DWORD *)(a1 + 968));
          *(_DWORD *)(a1 + 968) = v11;
          *(_DWORD *)(a1 + 972) = v11;
          if (synstrmaux_BuildAudioContentType("audio/L16;rate=", *(_DWORD *)(a1 + 980), v13, 0x30uLL) > 0x2F) {
            return 9;
          }
          synstrmaux_RegisterInStream((_WORD *)(a1 + 24), (uint64_t)v13, 1, a1 + 856);
          synstrmaux_RegisterInStream((_WORD *)(a1 + 24), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
            0,
            a1 + 888);
          synstrmaux_RegisterOutStream((_WORD *)(a1 + 24), (uint64_t)v13, a1 + 872);
          synstrmaux_RegisterOutStream((_WORD *)(a1 + 24), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
            a1 + 904);
          uint64_t v7 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 24), *(void *)(a1 + 848), a3, a4);
          dsp_timbre_set_target_timbre(*(void *)(a1 + 944), (float)*(unsigned int *)(a1 + 968) + -100.0);
          *(_DWORD *)(a1 + 984) = 0;
          if ((v7 & 0x80000000) == 0) {
            return v7;
          }
        }
        synstrmaux_CloseStreams((_WORD *)(a1 + 24), *(void *)(a1 + 848));
        return v7;
      }
      return 2360352778;
    }
    else
    {
      return v9;
    }
  }
  return v7;
}

uint64_t dspeffects_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unsigned int v81 = 0;
  uint64_t v80 = 0;
  int v79 = 0;
  uint64_t v7 = safeh_HandleCheck(a1, a2, 55546, 992);
  if ((v7 & 0x80000000) != 0) {
    return 2360352776;
  }
  *(_DWORD *)(a1 + 988) = 1;
  *a5 = 1;
  int v8 = *(_DWORD *)(a1 + 960);
  if (v8 == 2)
  {
    uint64_t result = synstrmaux_CloseOutStreamsOnly((_WORD *)(a1 + 24), *(void *)(a1 + 848));
    *(_DWORD *)(a1 + 960) = 3;
    return result;
  }
  if (v8 == 1) {
    goto LABEL_6;
  }
  uint64_t v9 = v7;
  if (!v8)
  {
    *(_DWORD *)(a1 + 960) = 1;
LABEL_6:
    if (((*(uint64_t (**)(void, void, char *, uint64_t *))(*(void *)(a1 + 848) + 144))(*(void *)(a1 + 888), *(void *)(a1 + 896), (char *)&v80 + 4, &v80) & 0x80000000) != 0)
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2571, "%s%x", v10, v11, v12, v13, "lhError");
    }
    else if (((*(uint64_t (**)(void, void, unsigned int *, int *))(*(void *)(a1 + 848) + 144))(*(void *)(a1 + 856), *(void *)(a1 + 864), &v81, &v79) & 0x80000000) != 0)
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2569, "%s%x", v14, v15, v16, v17, "lhError");
    }
    uint64_t v84 = 0;
    uint64_t v85 = 0;
    uint64_t v83 = 0;
    int v82 = 0;
    uint64_t v9 = (*(uint64_t (**)(void, void, uint64_t *, char *))(*(void *)(a1 + 848) + 88))(*(void *)(a1 + 888), *(void *)(a1 + 896), &v85, (char *)&v83 + 4);
    if ((v9 & 0x80000000) != 0)
    {
      HIDWORD(v83) = 0;
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2571, "%s%x", v19, v20, v21, v22, "lhError");
    }
    else if (HIDWORD(v83))
    {
      uint64_t v27 = (*(uint64_t (**)(void, void, uint64_t *))(*(void *)(a1 + 848) + 112))(*(void *)(a1 + 904), *(void *)(a1 + 912), &v84);
      if ((v27 & 0x80000000) != 0)
      {
        HIDWORD(v83) = 0;
        log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2570, "%s%x", v23, v24, v25, v26, "lhError");
      }
      else
      {
        uint64_t v28 = HIDWORD(v83);
        if (HIDWORD(v83) >= 0x20)
        {
          uint64_t v29 = 0;
          unint64_t v30 = (unint64_t)HIDWORD(v83) >> 5;
          do
          {
            uint64_t v31 = (_OWORD *)(v84 + 32 * v29);
            uint64_t v32 = v85 + 32 * v29;
            long long v33 = *(_OWORD *)(v32 + 16);
            *uint64_t v31 = *(_OWORD *)v32;
            v31[1] = v33;
            if (*(_DWORD *)v32 == 17)
            {
              int v34 = MapProsodyValue_Scaling(50, 100, 200, *(_DWORD *)(a1 + 976), *(_DWORD *)(v32 + 24));
              *(_DWORD *)(a1 + 968) = v34;
              uint64_t v35 = v85 + 32 * v29;
              *(_DWORD *)(a1 + 964) = *(_DWORD *)(v35 + 24);
              if (*(_DWORD *)(a1 + 972) != v34)
              {
                unsigned int v36 = *(_DWORD *)(v35 + 12);
                uint64_t v86 = 0;
                uint64_t v87 = 0;
                if (v36)
                {
                  (*(void (**)(void, void, uint64_t *))(*(void *)(a1 + 848) + 136))(*(void *)(a1 + 856), *(void *)(a1 + 864), &v87);
                  uint64_t v37 = (*(uint64_t (**)(void, void, char *, char *))(*(void *)(a1 + 848) + 144))(*(void *)(a1 + 856), *(void *)(a1 + 864), (char *)&v87 + 4, (char *)&v86 + 4);
                  if (v36 > v87 >> 1)
                  {
                    unsigned int v38 = v36 - (v87 >> 1);
                    unsigned int v39 = v36 >= v87 >> 1 ? v36 - (v87 >> 1) : 0;
                    *(_DWORD *)(a1 + 984) -= v39;
                    if (v38)
                    {
                      while (1)
                      {
                        int v40 = v38 >= 0x80 ? 128 : v38;
                        uint64_t v37 = (*(uint64_t (**)(void, void, void, void, uint64_t *))(*(void *)(a1 + 848) + 80))(*(void *)(a1 + 856), *(void *)(a1 + 864), *(void *)(a1 + 952), (2 * v40), &v86);
                        if ((v37 & 0x80000000) != 0) {
                          break;
                        }
                        if (!v86) {
                          goto LABEL_40;
                        }
                        if (dsp_timbre_push_samples(*(void *)(a1 + 944), *(__int16 **)(a1 + 952), v86 >> 1))return 2360352778; {
                        unsigned int v45 = v86;
                        }
                        do
                        {
                          int samples = dsp_timbre_get_samples(*(void *)(a1 + 944), *(void **)(a1 + 952), 0x80u);
                          LODWORD(v86) = samples;
                          if (!samples) {
                            break;
                          }
                          uint64_t v37 = (*(uint64_t (**)(void, void, void, void))(*(void *)(a1 + 848) + 104))(*(void *)(a1 + 872), *(void *)(a1 + 880), *(void *)(a1 + 952), (2 * samples));
                          if ((v37 & 0x80000000) != 0)
                          {
                            log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2578, "%s%x", v47, v48, v49, v50, "lhError");
                            break;
                          }
                        }
                        while (v86);
                        v38 -= v45 >> 1;
                        if (!v38) {
                          goto LABEL_40;
                        }
                      }
                      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2578, "%s%x", v41, v42, v43, v44, "lhError");
                    }
                  }
                }
                else
                {
                  uint64_t v37 = 0;
                }
LABEL_40:
                unsigned int v51 = *(_DWORD *)(a1 + 968);
                *(_DWORD *)(a1 + 972) = v51;
                if (dsp_timbre_set_target_timbre(*(void *)(a1 + 944), (float)v51 + -100.0)) {
                  return 2360352778;
                }
                if ((v37 & 0x80000000) != 0) {
                  return v37;
                }
                *(_DWORD *)(a1 + 988) = 0;
                uint64_t v27 = (*(uint64_t (**)(void, void, uint64_t *, int *))(*(void *)(a1 + 848) + 144))(*(void *)(a1 + 856), *(void *)(a1 + 864), &v83, &v82);
                if ((v27 & 0x80000000) != 0) {
                  log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2571, "%s%x", v52, v53, v54, v55, "lhError");
                }
              }
            }
            ++v29;
          }
          while (v29 != v30);
          uint64_t v28 = HIDWORD(v83);
        }
        (*(void (**)(void, void, uint64_t))(*(void *)(a1 + 848) + 120))(*(void *)(a1 + 904), *(void *)(a1 + 912), v28);
      }
      (*(void (**)(void, void, void))(*(void *)(a1 + 848) + 96))(*(void *)(a1 + 888), *(void *)(a1 + 896), HIDWORD(v83));
      uint64_t v9 = v27;
    }
    unsigned int v56 = *(_DWORD *)(a1 + 968);
    if (*(_DWORD *)(a1 + 972) == v56
      || (*(_DWORD *)(a1 + 972) = v56,
          !dsp_timbre_set_target_timbre(*(void *)(a1 + 944), (float)v56 + -100.0)))
    {
      if ((v9 & 0x80000000) == 0)
      {
        if (((*(uint64_t (**)(void, void, unsigned int *, int *))(*(void *)(a1 + 848) + 144))(*(void *)(a1 + 856), *(void *)(a1 + 864), &v81, &v79) & 0x80000000) != 0)log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2569, "%s%x", v57, v58, v59, v60, "lhError"); {
        unsigned int v61 = v81;
        }
        if (v81)
        {
          do
          {
            LODWORD(v85) = 0;
            if (v61 >= 0x80) {
              uint64_t v62 = 128;
            }
            else {
              uint64_t v62 = v61;
            }
            uint64_t v9 = (*(uint64_t (**)(void, void, void, uint64_t, uint64_t *))(*(void *)(a1 + 848) + 80))(*(void *)(a1 + 856), *(void *)(a1 + 864), *(void *)(a1 + 952), v62, &v85);
            if ((v9 & 0x80000000) != 0)
            {
              log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2578, "%s%x", v63, v64, v65, v66, "lhError");
              goto LABEL_81;
            }
            if (dsp_timbre_push_samples(*(void *)(a1 + 944), *(__int16 **)(a1 + 952), v85 >> 1))
            {
              uint64_t v9 = 2360352778;
              goto LABEL_81;
            }
            int v71 = v85;
            if ((int)v85 >= 0) {
              int v72 = v85;
            }
            else {
              int v72 = v85 + 1;
            }
            *(_DWORD *)(a1 + 984) -= v72 >> 1;
            while (1)
            {
              int v73 = dsp_timbre_get_samples(*(void *)(a1 + 944), *(void **)(a1 + 952), 0x80u);
              LODWORD(v85) = v73;
              if (v73 < 1) {
                break;
              }
              *(_DWORD *)(a1 + 988) = 0;
              *(_DWORD *)(a1 + 984) += v73;
              uint64_t v9 = (*(uint64_t (**)(void, void, void, void))(*(void *)(a1 + 848) + 104))(*(void *)(a1 + 872), *(void *)(a1 + 880), *(void *)(a1 + 952), (2 * v73));
              if ((v9 & 0x80000000) != 0)
              {
                log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2578, "%s%x", v67, v68, v69, v70, "lhError");
                goto LABEL_75;
              }
              if ((int)v85 <= 0) {
                goto LABEL_75;
              }
            }
            if (*(_DWORD *)(a1 + 988)) {
              *a5 = 0;
            }
LABEL_75:
            v61 -= v71;
          }
          while (v61);
          if ((v9 & 0x80000000) == 0) {
            goto LABEL_82;
          }
LABEL_81:
          log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2569, "%s%x", v67, v68, v69, v70, "lhError");
        }
        else
        {
          uint64_t v9 = 0;
        }
LABEL_82:
        if ((v9 & 0x80000000) == 0 && v80 && v79 && *(_DWORD *)(a1 + 960) == 1)
        {
          uint64_t v9 = 2360352778;
          if (!dsp_timbre_flush(*(void *)(a1 + 944)))
          {
            int v74 = dsp_timbre_get_samples(*(void *)(a1 + 944), *(void **)(a1 + 952), 0x80u);
            if (v74)
            {
              while (1)
              {
                uint64_t v9 = (*(uint64_t (**)(void, void, void, void))(*(void *)(a1 + 848) + 104))(*(void *)(a1 + 872), *(void *)(a1 + 880), *(void *)(a1 + 952), (2 * v74));
                if ((v9 & 0x80000000) != 0) {
                  break;
                }
                int v74 = dsp_timbre_get_samples(*(void *)(a1 + 944), *(void **)(a1 + 952), 0x80u);
                if (!v74) {
                  goto LABEL_95;
                }
              }
              log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2578, "%s%x", v75, v76, v77, v78, "lhError");
            }
            else
            {
              uint64_t v9 = 0;
LABEL_95:
              *(_DWORD *)(a1 + 960) = 2;
              *a5 = 2;
            }
          }
        }
        else if (!v81)
        {
          *a5 = 0;
        }
      }
    }
    else
    {
      return 2360352778;
    }
  }
  return v9;
}

uint64_t dspeffects_ProcessEnd(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 55546, 992) & 0x80000000) != 0) {
    return 2360352776;
  }
  uint64_t v3 = synstrmaux_CloseStreams((_WORD *)(a1 + 24), *(void *)(a1 + 848));
  uint64_t v4 = *(void *)(a1 + 920);
  if (v4) {
    (*(void (**)(void, void))(v4 + 56))(*(void *)(a1 + 928), *(void *)(a1 + 936));
  }
  return v3;
}

uint64_t dspeffects_GetParamU32(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int a4)
{
  uint64_t UInt = paramc_ParamGetUInt(*(void *)(*(void *)(a1 + 16) + 40), a2, a3);
  if ((UInt & 0x80000000) != 0)
  {
    *a3 = a4;
    uint64_t UInt = paramc_ParamSetUInt(*(void *)(*(void *)(a1 + 16) + 40), a2, a4);
    if ((UInt & 0x80000000) != 0) {
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2579, "%s%s%s%x", v9, v10, v11, v12, "parameter");
    }
  }
  return UInt;
}

uint64_t dspeffects_GetParamS32(uint64_t a1, int *a2)
{
  uint64_t Int = paramc_ParamGetInt(*(void *)(*(void *)(a1 + 16) + 40), (uint64_t)"timbre_baseline", a2);
  if ((Int & 0x80000000) != 0)
  {
    *a2 = 100;
    uint64_t Int = paramc_ParamSetInt(*(void *)(*(void *)(a1 + 16) + 40), (uint64_t)"timbre_baseline", 0x64u);
    if ((Int & 0x80000000) != 0) {
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"DSPEFFECTS", 2579, "%s%s%s%x", v5, v6, v7, v8, "parameter");
    }
  }
  return Int;
}

uint64_t dspeffects_loc_ParamCheckChange(uint64_t a1, char *__s1, const char *a3, _DWORD *a4)
{
  *a4 = 1;
  if (!strcmp(__s1, "frequencyhz"))
  {
    uint64_t result = 2360352785;
    if (!*(void *)(a1 + 856) && !*(void *)(a1 + 872)) {
      return 0;
    }
LABEL_11:
    *a4 = 0;
    return result;
  }
  if (strcmp(__s1, "timbre"))
  {
    if (strcmp(__s1, "timbre_baseline") || (atoi(a3) - 201) > 0xFFFFFF68) {
      return 0;
    }
    goto LABEL_10;
  }
  if ((atoi(a3) - 201) < 0xFFFFFF69)
  {
LABEL_10:
    uint64_t result = 2360352783;
    goto LABEL_11;
  }
  return 0;
}

uint64_t dspeffects_loc_ParamLearnChange(uint64_t a1, char *__s1, const char *a3)
{
  if (!strcmp(__s1, "frequencyhz"))
  {
    uint64_t v6 = 2360352785;
    if (!*(void *)(a1 + 856) && !*(void *)(a1 + 872))
    {
      uint64_t v6 = 0;
      *(_DWORD *)(a1 + 980) = LH_atou(a3);
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  if (!strcmp(__s1, "timbre_baseline"))
  {
    int v7 = LH_atoi(a3);
    *(_DWORD *)(a1 + 976) = v7;
    *(_DWORD *)(a1 + 968) = MapProsodyValue_Scaling(50, 100, 200, v7, *(_DWORD *)(a1 + 964));
  }
  if (!strcmp(__s1, "timbre"))
  {
    *(_DWORD *)(a1 + 964) = atoi(a3);
    int v8 = *(_DWORD *)(a1 + 976);
    int v9 = atoi(a3);
    *(_DWORD *)(a1 + 968) = MapProsodyValue_Scaling(50, 100, 200, v8, v9);
  }
  return v6;
}

uint64_t signal_fifo_init(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v3 = 0xFFFFFFFFLL;
  if (a1 && (a3 - 3) >= 0xFFFFFFFE)
  {
    uint64_t v7 = dsp_malloc(a2, 0x28u);
    if (v7)
    {
      uint64_t v8 = v7;
      *(void *)uint64_t v7 = a2;
      *(_DWORD *)(v7 + 8) = a3;
      *(void *)(v7 + 24) = 0;
      *(void *)(v7 + 32) = 0;
      *(void *)(v7 + 16) = 0;
      uint64_t v3 = check_minimum_space((void *)v7, 0x800u / (unsigned __int16)a3);
      if (v3) {
        dsp_free(a2);
      }
      else {
        *a1 = v8;
      }
    }
    else
    {
      return 4294967294;
    }
  }
  return v3;
}

uint64_t check_minimum_space(void *a1, unsigned int a2)
{
  int v4 = *((_DWORD *)a1 + 7);
  int v3 = *((_DWORD *)a1 + 8);
  unsigned int v5 = *((_DWORD *)a1 + 6);
  int v6 = v4 - v3;
  unsigned int v7 = v4 - v3 + a2;
  if (v5 >= v7)
  {
    if (v5 - v4 >= a2)
    {
      return 0;
    }
    else
    {
      dsp_memmove_samples((void *)a1[2], (const void *)(a1[2] + 2 * (*((_DWORD *)a1 + 2) * v3)), *((_DWORD *)a1 + 2) * v6);
      uint64_t result = 0;
      *((_DWORD *)a1 + 7) = v6;
      *((_DWORD *)a1 + 8) = 0;
    }
  }
  else
  {
    if (v7 <= v5 + 2048) {
      unsigned int v8 = v5 + 2048;
    }
    else {
      unsigned int v8 = v4 - v3 + a2;
    }
    unsigned int v9 = v5 + 2048 + ((v8 + ~v5) & 0xFFFFF800);
    *((_DWORD *)a1 + 6) = v9;
    uint64_t v10 = (void *)dsp_malloc(*a1, 2 * v9 * *((_DWORD *)a1 + 2));
    if (v10)
    {
      uint64_t v11 = v10;
      uint64_t v12 = a1[2];
      if (v12)
      {
        if (*((_DWORD *)a1 + 6))
        {
          dsp_memcpy(v10, (const void *)(v12 + 2 * (*((_DWORD *)a1 + 2) * *((_DWORD *)a1 + 8))), (2 * v6 * *((_DWORD *)a1 + 2)));
          dsp_free(*a1);
        }
      }
      uint64_t result = 0;
      a1[2] = v11;
      *((_DWORD *)a1 + 7) = v6;
      *((_DWORD *)a1 + 8) = 0;
      *((_DWORD *)a1 + 6) = v9;
    }
    else
    {
      return 4294967294;
    }
  }
  return result;
}

uint64_t signal_fifo_deinit(void *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  float v2 = (void *)*a1;
  if (!*a1) {
    return 0;
  }
  if (v2[2])
  {
    dsp_free(*v2);
    v2[2] = 0;
    *((_DWORD *)v2 + 6) = 0;
  }
  dsp_free(*v2);
  uint64_t result = 0;
  *a1 = 0;
  return result;
}

uint64_t signal_fifo_set_backlog_size(uint64_t result, int a2)
{
  *(_DWORD *)(result + 36) = a2;
  return result;
}

uint64_t signal_fifo_get_rd_ptr(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16) + 2 * (*(_DWORD *)(result + 8) * *(_DWORD *)(result + 32));
  }
  return result;
}

uint64_t signal_fifo_get_num_unread_samples(_DWORD *a1)
{
  unsigned int v1 = a1[9];
  unsigned int v2 = a1[7] - a1[8];
  BOOL v3 = v2 >= v1;
  unsigned int v4 = v2 - v1;
  if (v3) {
    return v4;
  }
  else {
    return 0;
  }
}

uint64_t signal_fifo_get_wr_ptr(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16) + 2 * (*(_DWORD *)(result + 8) * *(_DWORD *)(result + 28));
  }
  return result;
}

uint64_t signal_fifo_push_samples(uint64_t a1, const void *a2, unsigned int a3)
{
  uint64_t v6 = check_minimum_space((void *)a1, a3);
  if (!v6)
  {
    if (a1)
    {
      int v7 = *(_DWORD *)(a1 + 8);
      unsigned int v8 = (void *)(*(void *)(a1 + 16) + 2 * (v7 * *(_DWORD *)(a1 + 28)));
    }
    else
    {
      unsigned int v8 = 0;
      int v7 = MEMORY[8];
    }
    dsp_memcpy(v8, a2, 2 * a3 * v7);
    *(_DWORD *)(a1 + 28) += a3;
  }
  return v6;
}

uint64_t signal_fifo_push_samples_nodata(uint64_t a1, unsigned int a2)
{
  uint64_t result = check_minimum_space((void *)a1, a2);
  if (!result) {
    *(_DWORD *)(a1 + 28) += a2;
  }
  return result;
}

uint64_t signal_fifo_get_samples(uint64_t a1, void *a2, unsigned int a3)
{
  int v3 = *(_DWORD *)(a1 + 32);
  unsigned int v4 = *(_DWORD *)(a1 + 36);
  unsigned int v5 = *(_DWORD *)(a1 + 28) - v3;
  BOOL v6 = v5 >= v4;
  unsigned int v7 = v5 - v4;
  if (!v6) {
    unsigned int v7 = 0;
  }
  if (v7 >= a3) {
    uint64_t v8 = a3;
  }
  else {
    uint64_t v8 = v7;
  }
  if (v8)
  {
    dsp_memcpy(a2, (const void *)(*(void *)(a1 + 16) + 2 * (*(_DWORD *)(a1 + 8) * v3)), (2 * v8 * *(_DWORD *)(a1 + 8)));
    *(_DWORD *)(a1 + 32) += v8;
  }
  return v8;
}

uint64_t signal_fifo_pop_samples(_DWORD *a1, unsigned int a2)
{
  int v3 = a1[8];
  unsigned int v2 = a1[9];
  unsigned int v4 = a1[7] - v3;
  BOOL v5 = v4 >= v2;
  LODWORD(v6) = v4 - v2;
  if (!v5) {
    LODWORD(v6) = 0;
  }
  if (v6 >= a2) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = v6;
  }
  a1[8] = v6 + v3;
  return v6;
}

uint64_t signal_fifo_move_samples(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = (_DWORD *)a2;
  if (a2)
  {
    int v3 = *(_DWORD *)(a2 + 32);
    a2 = *(void *)(a2 + 16) + 2 * (*(_DWORD *)(a2 + 8) * v3);
  }
  else
  {
    int v3 = MEMORY[0x20];
  }
  unsigned int v4 = v2[9];
  unsigned int v5 = v2[7] - v3;
  BOOL v6 = v5 >= v4;
  unsigned int v7 = v5 - v4;
  if (v6) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t result = signal_fifo_push_samples(a1, (const void *)a2, v8);
  if (!result)
  {
    int v11 = v2[8];
    unsigned int v10 = v2[9];
    unsigned int v12 = v2[7] - v11;
    BOOL v6 = v12 >= v10;
    unsigned int v13 = v12 - v10;
    if (!v6) {
      unsigned int v13 = 0;
    }
    if (v13 >= v8) {
      unsigned int v13 = v8;
    }
    v2[8] = v13 + v11;
    return v8;
  }
  return result;
}

uint64_t signal_fifo_clear(uint64_t a1)
{
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  check_minimum_space((void *)a1, 0x800u / *(_DWORD *)(a1 + 8));
  return 0;
}

uint64_t dsp_biquad_init(void *a1, uint64_t a2, int a3, int a4)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = (void *)dsp_malloc(a2, 0x38u);
  if (v8)
  {
    unsigned int v9 = v8;
    *a1 = 0;
    *uint64_t v8 = a2;
    uint64_t v10 = dsp_malloc(a2, 4 * a3 * a4);
    v9[5] = v10;
    if (v10)
    {
      uint64_t v11 = dsp_malloc(a2, 4 * a3 * a4);
      v9[6] = v11;
      if (v11)
      {
        uint64_t result = 0;
        *((_DWORD *)v9 + 2) = 0;
        *((_DWORD *)v9 + 3) = a3;
        *((_DWORD *)v9 + 4) = a4;
        *a1 = v9;
        return result;
      }
      dsp_free(a2);
    }
    dsp_free(a2);
  }
  return 4294967294;
}

void *dsp_biquad_deinit(void *result)
{
  if (result)
  {
    unsigned int v1 = (void *)*result;
    if (*result)
    {
      dsp_free(*v1);
      dsp_free(*v1);
      uint64_t v2 = *v1;
      return (void *)dsp_free(v2);
    }
  }
  return result;
}

uint64_t dsp_biquad_create_low_pass_filter(uint64_t a1, float a2)
{
  *(_DWORD *)(a1 + 8) = 1;
  long double v3 = tan((float)(a2 * 3.1416));
  *(float *)&long double v3 = v3;
  __asm { FMOV            V4.2S, #-1.0 }
  _D4.f32[0] = *(float *)&v3 + 1.0;
  float32x2_t v9 = vmla_n_f32(_D4, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v3, 0), *(float *)&v3);
  __asm { FMOV            V2.2S, #1.0 }
  float32x2_t v11 = vdiv_f32(_D2, v9);
  float32x2_t v12 = vadd_f32(v9, v9);
  float32x2_t v13 = (float32x2_t)vdup_lane_s32((int32x2_t)v11, 0);
  float v14 = (float)((float)(1.0 - *(float *)&v3) + (float)(*(float *)&v3 * *(float *)&v3)) * v11.f32[0];
  v11.i32[1] = v12.i32[1];
  v13.f32[0] = *(float *)&v3 * *(float *)&v3;
  float32x2_t v15 = vmul_f32(v11, v13);
  *(_DWORD *)(a1 + 20) = v15.i32[0];
  *(float *)(a1 + 24) = v15.f32[0] + v15.f32[0];
  *(float32x2_t *)(a1 + 28) = v15;
  *(float *)(a1 + 36) = v14;
  uint64_t v16 = (*(_DWORD *)(a1 + 16) * *(_DWORD *)(a1 + 12));
  if (v16)
  {
    uint64_t v17 = *(_DWORD **)(a1 + 40);
    uint64_t v18 = *(_DWORD **)(a1 + 48);
    do
    {
      *v17++ = 0;
      *v18++ = 0;
      --v16;
    }
    while (v16);
  }
  return 0;
}

float dsp_biquad_process(uint64_t a1, unsigned int a2, float a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if (!v3) {
    return 0.0;
  }
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  do
  {
    float v6 = *(float *)(v4 + 4 * a2) + (float)(a3 * *(float *)(a1 + 20));
    *(float *)(v4 + 4 * a2) = (float)(*(float *)(v5 + 4 * a2) + (float)(a3 * *(float *)(a1 + 24)))
                              - (float)(*(float *)(a1 + 32) * v6);
    *(float *)(v5 + 4 * a2++) = (float)(a3 * *(float *)(a1 + 28)) - (float)(*(float *)(a1 + 36) * v6);
    a3 = v6;
    --v3;
  }
  while (v3);
  return v6;
}

uint64_t dsp_biquad_process_fifos(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t num_unread_samples = signal_fifo_get_num_unread_samples(a3);
  uint64_t rd_ptr = signal_fifo_get_rd_ptr((uint64_t)a3);
  signal_fifo_ensure_free_space(a2, num_unread_samples);
  uint64_t wr_ptr = signal_fifo_get_wr_ptr(a2);
  if (num_unread_samples)
  {
    uint64_t v9 = wr_ptr;
    int v10 = 0;
    unint64_t v11 = *(unsigned int *)(a1 + 12);
    do
    {
      if (v11)
      {
        for (unint64_t i = 0; i < v11; ++i)
        {
          float v13 = dsp_biquad_process(a1, i, (float)*(__int16 *)(rd_ptr + 2 * i));
          if (v13 >= -32767.0) {
            float v14 = v13;
          }
          else {
            float v14 = -32767.0;
          }
          if (v13 <= 32767.0) {
            float v15 = v14;
          }
          else {
            float v15 = 32767.0;
          }
          *(_WORD *)(v9 + 2 * i) = (int)v15;
          unint64_t v11 = *(unsigned int *)(a1 + 12);
        }
      }
      rd_ptr += 2 * v11;
      v9 += 2 * v11;
      ++v10;
    }
    while (v10 != num_unread_samples);
  }
  signal_fifo_pop_samples(a3, num_unread_samples);
  return signal_fifo_push_samples_nodata(a2, num_unread_samples);
}

uint64_t dsp_biquad_flush(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 12);
  if (v1)
  {
    uint64_t v2 = *(_DWORD **)(result + 40);
    uint64_t v3 = *(_DWORD **)(result + 48);
    do
    {
      *v2++ = 0;
      *v3++ = 0;
      --v1;
    }
    while (v1);
  }
  return result;
}

uint64_t DICT_Init(uint64_t a1, uint64_t a2, int a3, int a4)
{
  char __src = 0;
  uint64_t v7 = BINTREE_Construct(a2, 0, a3);
  *(void *)a1 = v7;
  if (v7)
  {
    *(void *)(a1 + 8) = CompFunc1;
    *(void *)(a1 + 16) = CompFunc2;
    *(_DWORD *)(a1 + 64) = -1;
    *(void *)(a1 + 72) = a2;
    uint64_t v8 = (unsigned int *)(a1 + 24);
    ARRAY_Init((uint64_t)v8, a2, 1, a4);
    uint64_t v9 = (kaldi::nnet1::UpdatableComponent *)ARRAY_Add(v8, &__src);
    if (v9 == -1) {
      return kaldi::nnet1::UpdatableComponent::IsUpdatable(v9);
    }
    else {
      return 0;
    }
  }
  else
  {
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
  }
}

uint64_t CompFunc1(uint64_t a1, int a2, int a3)
{
  return strcmp((const char *)(*(void *)(a1 + 24) + (*(_DWORD *)(a1 + 40) * a2)), (const char *)(*(void *)(a1 + 24) + (*(_DWORD *)(a1 + 40) * a3)));
}

uint64_t CompFunc2(uint64_t a1, char *__s1, int a3)
{
  return strcmp(__s1, (const char *)(*(void *)(a1 + 24) + (*(_DWORD *)(a1 + 40) * a3)));
}

uint64_t DICT_Destruct(uint64_t *a1)
{
  uint64_t v1 = (uint64_t)(a1 + 3);
  BINTREE_Destruct(*a1);
  return ARRAY_Flush(v1);
}

uint64_t DICT_Add(uint64_t a1, char *__s, void *a3, int a4, _DWORD *a5)
{
  int __src = a4;
  int v9 = strlen(__s);
  int v10 = (kaldi::nnet1::UpdatableComponent *)ARRAY_AddBuf((unsigned int *)(a1 + 24), __s, v9 + 1, 1u);
  *a5 = 1;
  if (v10 == -1)
  {
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(v10);
  }
  else
  {
    unsigned int v11 = v10;
    float32x2_t v12 = (kaldi::nnet1::UpdatableComponent *)ARRAY_AddBuf((unsigned int *)(a1 + 24), &__src, 4, 4u);
    if (v12 == -1) {
      return kaldi::nnet1::UpdatableComponent::IsUpdatable(v12);
    }
    float32x2_t v12 = (kaldi::nnet1::UpdatableComponent *)ARRAY_AddBuf((unsigned int *)(a1 + 24), a3, __src, 1u);
    if (v12 == -1) {
      return kaldi::nnet1::UpdatableComponent::IsUpdatable(v12);
    }
    float32x2_t v12 = (kaldi::nnet1::UpdatableComponent *)BINTREE_Add((uint64_t *)a1, (uint64_t (**)(void, void, void))(a1 + 8), v11);
    if (v12 == -1) {
      return kaldi::nnet1::UpdatableComponent::IsUpdatable(v12);
    }
    int v13 = (int)v12;
    int v21 = 0;
    float32x2_t v12 = (kaldi::nnet1::UpdatableComponent *)ARRAY_AddBuf((unsigned int *)(a1 + 24), &v21, 4, 4u);
    if (v12 == -1)
    {
      return kaldi::nnet1::UpdatableComponent::IsUpdatable(v12);
    }
    else if (v13)
    {
      float v14 = (const char *)(*(void *)(a1 + 32) + (*(_DWORD *)(a1 + 48) * v13));
      size_t v15 = strlen(v14);
      uint64_t result = 0;
      uint64_t v17 = (uint64_t)&v14[v15 + 1];
      uint64_t v18 = 4 - (v17 & 3);
      if ((v17 & 3) == 0) {
        uint64_t v18 = 0;
      }
      uint64_t v19 = *(unsigned int *)(v17 + v18) + v17 + v18 + 4;
      uint64_t v20 = 4 - (v19 & 3);
      if ((v19 & 3) == 0) {
        uint64_t v20 = 0;
      }
      *(_DWORD *)(v19 + v20) = v11;
      *a5 = 0;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t DICT_Find(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  int v7 = *(_DWORD *)(a1 + 64);
  if (v7 == -1)
  {
    int v7 = BINTREE_Find(*(void *)a1, a1 + 8, a2);
    if (v7) {
      goto LABEL_3;
    }
LABEL_11:
    *a4 = 1;
    return 0;
  }
  if (!v7) {
    goto LABEL_11;
  }
LABEL_3:
  *a4 = 0;
  uint64_t v8 = (const char *)(*(void *)(a1 + 32) + (*(_DWORD *)(a1 + 48) * v7));
  *(void *)a3 = v8;
  size_t v9 = (size_t)&v8[strlen(v8) + 1];
  uint64_t v10 = 4 - (v9 & 3);
  if ((v9 & 3) == 0) {
    uint64_t v10 = 0;
  }
  unsigned int v11 = (unsigned int *)(v9 + v10);
  unsigned int v12 = *v11++;
  int v13 = (char *)v11 + v12;
  *(_DWORD *)(a3 + 16) = v12;
  *(void *)(a3 + 8) = v11;
  if ((v13 & 3) != 0) {
    uint64_t v14 = 4 - (v13 & 3);
  }
  else {
    uint64_t v14 = 0;
  }
  int v15 = *(_DWORD *)&v13[v14];
  *(_DWORD *)(a1 + 64) = v15;
  if (v15)
  {
    *(_DWORD *)(a3 + 20) = 1;
  }
  else
  {
    *(_DWORD *)(a3 + 20) = 0;
    *(_DWORD *)(a1 + 64) = -1;
  }
  return 0;
}

uint64_t DICT_Remove(uint64_t a1, uint64_t a2, _DWORD *a3, int *a4)
{
  *a3 = 0;
  uint64_t v8 = a1 + 8;
  uint64_t result = BINTREE_Find(*(void *)a1, a1 + 8, a2);
  if (result)
  {
    uint64_t v10 = *(void *)(a1 + 32);
    int v11 = *a3 + 1;
    do
    {
      size_t v12 = v10
          + (*(_DWORD *)(a1 + 48) * result)
          + strlen((const char *)(v10 + (*(_DWORD *)(a1 + 48) * result)))
          + 1;
      uint64_t v13 = 4 - (v12 & 3);
      if ((v12 & 3) == 0) {
        uint64_t v13 = 0;
      }
      uint64_t v14 = v12 + v13 + *(int *)(v12 + v13) + 4;
      uint64_t v15 = 4 - (v14 & 3);
      if ((v14 & 3) == 0) {
        uint64_t v15 = 0;
      }
      unsigned int v17 = *(_DWORD *)(v14 + v15);
      LODWORD(result) = v17;
      *a3 = v11++;
    }
    while (result);
    uint64_t result = BINTREE_Remove(*(void *)a1, v8, a2, &v17);
    if (result) {
      int v16 = -1;
    }
    else {
      int v16 = v17 == 0;
    }
  }
  else
  {
    int v16 = 1;
  }
  *a4 = v16;
  return result;
}

size_t DICTITT_Current@<X0>(unsigned int *a1@<X0>, uint64_t a2@<X8>)
{
  unsigned int v4 = a1[16];
  if (v4 == -1) {
    unsigned int v4 = *(_DWORD *)BINTREEITT_Current(a1 + 2);
  }
  uint64_t v5 = (const char *)(*(void *)(*(void *)a1 + 32) + *(_DWORD *)(*(void *)a1 + 48) * v4);
  *(void *)a2 = v5;
  size_t result = strlen(v5);
  uint64_t v7 = (uint64_t)&v5[result + 1];
  uint64_t v8 = 4 - (v7 & 3);
  if ((v7 & 3) == 0) {
    uint64_t v8 = 0;
  }
  size_t v9 = (unsigned int *)(v7 + v8);
  unsigned int v11 = *v9++;
  unsigned int v10 = v11;
  size_t v12 = (char *)v9 + v11;
  *(void *)(a2 + 8) = v9;
  if ((v12 & 3) != 0) {
    uint64_t v13 = 4 - (v12 & 3);
  }
  else {
    uint64_t v13 = 0;
  }
  int v14 = *(_DWORD *)&v12[v13];
  BOOL v15 = v14 == 0;
  if (!v14) {
    int v14 = -1;
  }
  a1[16] = v14;
  int v16 = !v15;
  *(_DWORD *)(a2 + 16) = v10;
  *(_DWORD *)(a2 + 20) = v16;
  return result;
}

uint64_t DICTITT_Init(uint64_t a1, uint64_t *a2)
{
  *(void *)a1 = a2;
  *(_DWORD *)(a1 + 64) = -1;
  return BINTREEITT_Init(a1 + 8, *a2);
}

double ARRAY_Init(uint64_t a1, uint64_t a2, int a3, int a4)
{
  double result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 16) = a4;
  *(_DWORD *)(a1 + 24) = a3;
  *(void *)(a1 + 32) = a2;
  return result;
}

uint64_t ARRAY_Add(unsigned int *a1, void *__src)
{
  int v9 = 0;
  unsigned int v4 = *a1;
  unsigned int v5 = a1[5];
  if (*a1 >= v5)
  {
    unsigned int v7 = a1[4] + v5;
    a1[5] = v7;
    uint64_t v6 = OOCAllocator_Realloc(*((void *)a1 + 4), *((void *)a1 + 1), a1[6] * v7, &v9);
    *((void *)a1 + 1) = v6;
    if (v9) {
      return 0xFFFFFFFFLL;
    }
    unsigned int v4 = *a1;
  }
  else
  {
    uint64_t v6 = *((void *)a1 + 1);
  }
  memcpy((void *)(v6 + a1[6] * v4), __src, a1[6]);
  uint64_t result = *a1;
  *a1 = result + 1;
  return result;
}

uint64_t ARRAY_AddBuf(unsigned int *a1, void *__src, int a3, unsigned int a4)
{
  unsigned int v7 = *a1;
  unsigned int v8 = a1[5];
  unsigned int v9 = a1[6];
  int v17 = 0;
  if (v7 % a4) {
    unsigned int v10 = a4 - v7 % a4;
  }
  else {
    unsigned int v10 = 0;
  }
  uint64_t v11 = v10 + v7;
  unsigned int v12 = v11 + a3;
  if ((int)v11 + a3 <= v8)
  {
    uint64_t v15 = *((void *)a1 + 1);
LABEL_12:
    memcpy((void *)(v15 + v11 * v9), __src, v9 * a3);
    *a1 = v12;
    return v11;
  }
  unsigned int v13 = a1[4] + v8;
  if (v12 <= v13) {
    unsigned int v14 = v13;
  }
  else {
    unsigned int v14 = v11 + a3;
  }
  uint64_t v15 = OOCAllocator_Realloc(*((void *)a1 + 4), *((void *)a1 + 1), v14 * v9, &v17);
  *((void *)a1 + 1) = v15;
  if (!v17)
  {
    a1[5] = v14;
    goto LABEL_12;
  }
  return 0xFFFFFFFFLL;
}

uint64_t ARRAY_Destroy(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)a1 <= a2)
  {
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pThis");
  }
  else
  {
    uint64_t v2 = *(int *)(a1 + 24);
    int v3 = *(_DWORD *)a1 - 1;
    *(_DWORD *)a1 = v3;
    unsigned int v4 = (char *)(*(void *)(a1 + 8) + (int)(v2 * a2));
    memcpy(v4, &v4[v2], v2 * (v3 - a2));
    return 0;
  }
}

uint64_t ARRAY_Flush(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    OOCAllocator_Free(v2, *(void *)(a1 + 8));
  }
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  return 0;
}

uint64_t BINTREE_Construct(uint64_t a1, unsigned int a2, int a3)
{
  int v9 = 0;
  uint64_t v6 = OOCAllocator_Calloc(a1, 1, 24, &v9);
  uint64_t v8 = v6;
  if (v9) {
    return 0;
  }
  *(_DWORD *)(v6 + 12) = a3;
  *(void *)(v6 + 16) = a1;
  if (BINTREE_IncreaseHeap(&v8, a2)) {
    return 0;
  }
  else {
    return v8;
  }
}

uint64_t BINTREE_IncreaseHeap(uint64_t *a1, unsigned int a2)
{
  uint64_t v4 = *a1;
  int v11 = 0;
  unsigned int v5 = *(_DWORD *)v4;
  if (!a2) {
    a2 = *(_DWORD *)(v4 + 12) + v5;
  }
  if (a2 < v5) {
    return 0;
  }
  unsigned int v7 = (unsigned int *)OOCAllocator_Realloc(*(void *)(v4 + 16), v4, 20 * a2 + 24, &v11);
  if (v11) {
    return 1;
  }
  *a1 = (uint64_t)v7;
  uint64_t v8 = v7 + 6;
  unsigned int v9 = *v7;
  unsigned int v10 = *v7 + 1;
  *unsigned int v7 = a2;
  v7[1] = v10;
  if (v10 < a2)
  {
    unsigned int v9 = v10 - 1;
    do
    {
      v8[5 * v9 + 2] = v9 + 2;
      ++v9;
    }
    while (a2 - 1 != v9);
  }
  uint64_t result = 0;
  v8[5 * v9 + 2] = 0;
  return result;
}

uint64_t BINTREE_NewNode(uint64_t *a1, unsigned int a2)
{
  uint64_t v3 = *a1;
  uint64_t v9 = v3;
  if (*(_DWORD *)(v3 + 4)) {
    goto LABEL_2;
  }
  if (!BINTREE_IncreaseHeap(&v9, 0))
  {
    uint64_t v3 = v9;
    *a1 = v9;
LABEL_2:
    unsigned int v6 = *(_DWORD *)(v3 + 4);
    unsigned int v5 = (_DWORD *)(v3 + 4);
    uint64_t result = v6;
    unsigned int v7 = (int32x2_t *)&v5[5 * v6];
    *unsigned int v5 = v7[1].i32[0];
    v7[2].i8[0] = 0;
    *unsigned int v7 = vdup_n_s32(a2);
    v7[1] = 0;
    return result;
  }
  return 0xFFFFFFFFLL;
}

uint64_t BINTREE_Add(uint64_t *a1, uint64_t (**a2)(void, void, void), unsigned int a3)
{
  uint64_t result = BINTREE_NewNode(a1, a3);
  if (result != -1)
  {
    int v7 = result;
    uint64_t v8 = *a1;
    int v9 = *(_DWORD *)(*a1 + 8);
    if (v9)
    {
      int v69 = result;
      unsigned int v70 = a3;
      int v10 = 0;
      int v11 = 0;
      uint64_t v68 = *a1;
      unsigned int v12 = (_DWORD *)(v8 + 4);
      int v13 = *(_DWORD *)(*a1 + 8);
      while (1)
      {
        int v14 = v13;
        int v15 = v13;
        int v16 = &v12[5 * v13];
        unsigned int v18 = v16[1];
        int v17 = v16 + 1;
        uint64_t v19 = v12;
        int v20 = *((unsigned __int8 *)v17 + 12);
        int v21 = (*a2)(a2, v70, v18);
        if (!v21) {
          break;
        }
        if (v20)
        {
          int v9 = v15;
          int v11 = v10;
        }
        uint64_t v22 = &v19[5 * v15];
        uint64_t v23 = v22 + 2;
        uint64_t v24 = v22 + 3;
        if (v21 >= 0) {
          uint64_t v23 = v24;
        }
        int v13 = *v23;
        int v10 = v14;
        unsigned int v12 = v19;
        if (!*v23)
        {
          *uint64_t v23 = v69;
          uint64_t v25 = &v19[5 * v9];
          int v26 = (*a2)(a2, v70, v25[1]);
          uint64_t v27 = (int *)(v25 + 2);
          int v67 = v26;
          if (v26 < 0) {
            int v28 = 1;
          }
          else {
            int v28 = -1;
          }
          uint64_t v65 = v25 + 2;
          uint64_t v66 = v25 + 3;
          if (v26 >= 0) {
            uint64_t v27 = (int *)(v25 + 3);
          }
          int v29 = *v27;
          if (*v27 != v69)
          {
            int v30 = *v27;
            do
            {
              uint64_t v31 = &v19[5 * v30];
              int v32 = (*a2)(a2, v70, v31[1]);
              long long v33 = v31 + 2;
              if (v32 < 0) {
                char v34 = 1;
              }
              else {
                char v34 = -1;
              }
              if (v32 >= 0) {
                long long v33 = v31 + 3;
              }
              *((unsigned char *)v31 + 16) = v34;
              int v30 = *v33;
            }
            while (v30 != v69);
          }
          uint64_t v35 = &v19[5 * v9];
          int v38 = *((char *)v35 + 16);
          unsigned int v36 = (char *)(v35 + 4);
          int v37 = v38;
          if (!v38)
          {
            uint64_t result = 0;
            *unsigned int v36 = v28;
            return result;
          }
          if (!(v28 + v37))
          {
            uint64_t result = 0;
            *unsigned int v36 = 0;
            return result;
          }
          int v40 = &v19[5 * v29];
          int v43 = *((unsigned __int8 *)v40 + 16);
          uint64_t v41 = (char *)(v40 + 4);
          int v42 = v43;
          if ((v67 & 0x80000000) == 0)
          {
            uint64_t v44 = &v19[5 * v29];
            int v47 = v44[2];
            unint64_t v46 = v44 + 2;
            int v45 = v47;
            if (v42 == 255)
            {
              uint64_t v48 = v66;
              goto LABEL_35;
            }
            unsigned int v51 = &v19[5 * v45];
            int v54 = *((char *)v51 + 16);
            uint64_t v52 = (char *)(v51 + 4);
            int v53 = v54;
            *unint64_t v46 = *((_DWORD *)v52 - 1);
            *uint64_t v66 = *((_DWORD *)v52 - 2);
            *((_DWORD *)v52 - 2) = v9;
            *((_DWORD *)v52 - 1) = v29;
            if (v54 != 1)
            {
              if (v53)
              {
                if (v53 == -1)
                {
                  char v55 = 1;
                  goto LABEL_44;
                }
LABEL_51:
                *uint64_t v52 = 0;
                if (v11)
                {
                  uint64_t v60 = &v19[5 * v11];
                  int v62 = v60[2];
                  unsigned int v61 = v60 + 2;
                  if (v9 == v62 || (v63 = &v19[5 * v11], v64 = v63[3], unsigned int v61 = v63 + 3, v9 == v64))
                  {
                    uint64_t result = 0;
                    *unsigned int v61 = v45;
                  }
                  else
                  {
                    return 0;
                  }
                }
                else
                {
                  uint64_t result = 0;
                  *(_DWORD *)(v68 + 8) = v45;
                }
                return result;
              }
LABEL_45:
              *uint64_t v41 = 0;
              goto LABEL_49;
            }
            char v59 = -1;
LABEL_48:
            *uint64_t v41 = v59;
            goto LABEL_49;
          }
          uint64_t v49 = &v19[5 * v29];
          int v50 = v49[3];
          unint64_t v46 = v49 + 3;
          int v45 = v50;
          if (v42 == 1)
          {
            uint64_t v48 = v65;
LABEL_35:
            *uint64_t v48 = v45;
            *unint64_t v46 = v9;
          }
          else
          {
            unsigned int v56 = &v19[5 * v45];
            int v58 = *((char *)v56 + 16);
            uint64_t v52 = (char *)(v56 + 4);
            int v57 = v58;
            *unint64_t v46 = *((_DWORD *)v52 - 2);
            *uint64_t v65 = *((_DWORD *)v52 - 1);
            *((_DWORD *)v52 - 2) = v29;
            *((_DWORD *)v52 - 1) = v9;
            if (v58 == -1)
            {
              char v59 = 1;
              goto LABEL_48;
            }
            if (!v57) {
              goto LABEL_45;
            }
            if (v57 != 1) {
              goto LABEL_51;
            }
            char v55 = -1;
LABEL_44:
            *unsigned int v36 = v55;
            unsigned int v36 = v41;
LABEL_49:
            uint64_t v41 = v52;
            int v29 = v45;
          }
          *unsigned int v36 = 0;
          uint64_t v52 = v41;
          int v45 = v29;
          goto LABEL_51;
        }
      }
      unsigned int v39 = &v19[5 * v15];
      v19[5 * v69 + 2] = *v19;
      *uint64_t v19 = v69;
      uint64_t result = *v17;
      *int v17 = v70;
      if (*v39 == -1) {
        *unsigned int v39 = v70;
      }
    }
    else
    {
      uint64_t result = 0;
      *(_DWORD *)(v8 + 8) = v7;
    }
  }
  return result;
}

uint64_t BINTREE_Remove(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  unsigned int __src = *(_DWORD *)(a1 + 8);
  uint64_t v8 = __src;
  int v95 = 0;
  uint64_t v93 = 0;
  long long v91 = 0u;
  long long v92 = 0u;
  double v9 = ARRAY_Init((uint64_t)&v91, *(void *)(a1 + 16), 4, 64);
  if (!v8) {
    goto LABEL_19;
  }
  uint64_t v10 = a1 + 4;
  int v11 = (*(uint64_t (**)(uint64_t, uint64_t, void, double))(a2 + 8))(a2, a3, *(unsigned int *)(a1 + 4 + 20 * v8 + 4), v9);
  if (v11)
  {
    int v12 = v11;
    while (1)
    {
      int v13 = (kaldi::nnet1::UpdatableComponent *)ARRAY_Add((unsigned int *)&v91, &__src);
      if (v13 == -1) {
        return kaldi::nnet1::UpdatableComponent::IsUpdatable(v13);
      }
      uint64_t v14 = v10 + 20 * v8;
      int v15 = (unsigned int *)(v14 + 12);
      int v16 = (unsigned int *)(v14 + 8);
      if (v12 >= 0) {
        int v17 = v15;
      }
      else {
        int v17 = v16;
      }
      uint64_t v8 = *v17;
      unsigned int __src = v8;
      if (!v8) {
        goto LABEL_19;
      }
      int v12 = (*(uint64_t (**)(uint64_t, uint64_t, void))(a2 + 8))(a2, a3, *(unsigned int *)(v10 + 20 * v8 + 4));
      if (!v12) {
        goto LABEL_12;
      }
    }
  }
  int v17 = (unsigned int *)&v95;
LABEL_12:
  unsigned int v18 = __src;
  if (!__src)
  {
LABEL_19:
    ARRAY_Flush((uint64_t)&v91);
    uint64_t result = 0;
    *a4 = 0;
    return result;
  }
  uint64_t v19 = *(unsigned int *)(v10 + 20 * v8 + 12);
  if (v19)
  {
    uint64_t v20 = 0;
    uint64_t v21 = *(unsigned int *)(v10 + 20 * v8 + 12);
    do
    {
      uint64_t v22 = v20;
      uint64_t v20 = v21;
      uint64_t v23 = v10 + 20 * v21;
      unsigned int v25 = *(_DWORD *)(v23 + 8);
      uint64_t v24 = (_DWORD *)(v23 + 8);
      uint64_t v21 = v25;
    }
    while (v25);
    *uint64_t v24 = *(_DWORD *)(v10 + 20 * v8 + 8);
    if (v22)
    {
      uint64_t v26 = v10 + 20 * v20;
      *(_DWORD *)(v10 + 20 * v22 + 8) = *(_DWORD *)(v26 + 12);
      *(_DWORD *)(v26 + 12) = v19;
    }
    *int v17 = v20;
    *(unsigned char *)(v10 + 20 * v20 + 16) = *(unsigned char *)(v10 + 20 * v8 + 16);
  }
  else
  {
    int v28 = *(_DWORD *)(v10 + 20 * v8 + 8);
    if (v28)
    {
      uint64_t v29 = 0;
      uint64_t v30 = *(unsigned int *)(v10 + 20 * v8 + 8);
      do
      {
        uint64_t v31 = v29;
        uint64_t v29 = v30;
        uint64_t v32 = v10 + 20 * v30;
        unsigned int v34 = *(_DWORD *)(v32 + 12);
        long long v33 = (_DWORD *)(v32 + 12);
        uint64_t v30 = v34;
      }
      while (v34);
      *long long v33 = 0;
      if (v31)
      {
        uint64_t v35 = v10 + 20 * v29;
        *(_DWORD *)(v10 + 20 * v31 + 12) = *(_DWORD *)(v35 + 8);
        *(_DWORD *)(v35 + 8) = v28;
      }
      *(unsigned char *)(v10 + 20 * v29 + 16) = *(unsigned char *)(v10 + 20 * v8 + 16);
    }
    else
    {
      LODWORD(v29) = 0;
    }
    *int v17 = v29;
  }
  if (v17 == (unsigned int *)&v95)
  {
    int v36 = v95;
    *(_DWORD *)(a1 + 8) = v95;
    if (!v36) {
      goto LABEL_115;
    }
    goto LABEL_32;
  }
  if (*(_DWORD *)(a1 + 8))
  {
LABEL_32:
    unsigned int v37 = *v17;
    unsigned int __src = v37;
    if (v37)
    {
      int v13 = (kaldi::nnet1::UpdatableComponent *)ARRAY_Add((unsigned int *)&v91, &__src);
      if (v13 == -1) {
        return kaldi::nnet1::UpdatableComponent::IsUpdatable(v13);
      }
      uint64_t v38 = v10 + 20 * v37;
      if (v19)
      {
        for (unsigned int __src = *(_DWORD *)(v38 + 12); __src; unsigned int __src = *(_DWORD *)(v10 + 20 * __src + 8))
        {
          int v13 = (kaldi::nnet1::UpdatableComponent *)ARRAY_Add((unsigned int *)&v91, &__src);
          if (v13 == -1) {
            return kaldi::nnet1::UpdatableComponent::IsUpdatable(v13);
          }
        }
      }
      else
      {
        for (unsigned int __src = *(_DWORD *)(v38 + 8); __src; unsigned int __src = *(_DWORD *)(v10 + 20 * __src + 12))
        {
          int v13 = (kaldi::nnet1::UpdatableComponent *)ARRAY_Add((unsigned int *)&v91, &__src);
          if (v13 == -1) {
            return kaldi::nnet1::UpdatableComponent::IsUpdatable(v13);
          }
        }
      }
    }
    uint64_t v39 = *(unsigned int *)(*((void *)&v91 + 1) + (DWORD2(v92) * (v91 - 1)));
    ARRAY_Destroy((uint64_t)&v91, v91 - 1);
    uint64_t v40 = 0;
    uint64_t v41 = v10 + 20 * v39;
    do
    {
      if (v40)
      {
        if (*(_DWORD *)(v41 + 8) == v40) {
          goto LABEL_50;
        }
        if (*(_DWORD *)(v41 + 12) == v40)
        {
LABEL_48:
          char v42 = *(unsigned char *)(v41 + 16) + 1;
LABEL_51:
          *(unsigned char *)(v41 + 16) = v42;
        }
      }
      else
      {
        if (*(_DWORD *)(v41 + 8)) {
          goto LABEL_48;
        }
        if (*(_DWORD *)(v41 + 12))
        {
LABEL_50:
          char v42 = *(unsigned char *)(v41 + 16) - 1;
          goto LABEL_51;
        }
        *(unsigned char *)(v41 + 16) = 0;
      }
      uint64_t v43 = 0;
      if (v91)
      {
        uint64_t v44 = v41;
        if (*((void *)&v91 + 1))
        {
          uint64_t v43 = *(unsigned int *)(*((void *)&v91 + 1) + (DWORD2(v92) * (v91 - 1)));
          ARRAY_Destroy((uint64_t)&v91, v91 - 1);
          uint64_t v44 = v10 + 20 * v43;
        }
      }
      else
      {
        uint64_t v44 = v41;
      }
      unint64_t v46 = (unsigned char *)(v41 + 16);
      int v45 = *(unsigned __int8 *)(v41 + 16);
      if (!*(unsigned char *)(v41 + 16))
      {
        BOOL v63 = 1;
        goto LABEL_78;
      }
      if (v45 != 2)
      {
        if (v45 != 254)
        {
          BOOL v63 = 0;
LABEL_78:
          uint64_t v40 = v39;
          if (!v43) {
            goto LABEL_114;
          }
          goto LABEL_108;
        }
        int v47 = 0;
        if (v39)
        {
          uint64_t v48 = v39;
          do
          {
            ++v47;
            uint64_t v49 = v10 + 20 * v48;
            int v50 = *(char *)(v49 + 16);
            unsigned int v51 = (unsigned int *)(v49 + 12);
            uint64_t v52 = (unsigned int *)(v49 + 8);
            if (v50 < 0) {
              uint64_t v52 = v51;
            }
            uint64_t v48 = *v52;
          }
          while (v48);
        }
        uint64_t v53 = *(unsigned int *)(v41 + 12);
        uint64_t v54 = v10 + 20 * v53;
        int v57 = *(unsigned __int8 *)(v54 + 16);
        char v55 = (unsigned char *)(v54 + 16);
        char v56 = v57;
        int v58 = v55 - 8;
        uint64_t v40 = *((unsigned int *)v55 - 2);
        if (v57 == 1)
        {
          uint64_t v59 = v10 + 20 * v40;
          int v62 = *(char *)(v59 + 16);
          uint64_t v60 = (unsigned char *)(v59 + 16);
          int v61 = v62;
          *int v58 = *((_DWORD *)v60 - 1);
          *(_DWORD *)(v41 + 12) = *((_DWORD *)v60 - 2);
          *((_DWORD *)v60 - 2) = v39;
          *((_DWORD *)v60 - 1) = v53;
          if (v62 == 1)
          {
            *char v55 = -1;
          }
          else
          {
            if (v61)
            {
              if (v61 == -1)
              {
                *unint64_t v46 = 1;
                goto LABEL_89;
              }
              goto LABEL_90;
            }
            *char v55 = 0;
          }
          char v55 = (unsigned char *)(v41 + 16);
LABEL_89:
          *char v55 = 0;
LABEL_90:
          *uint64_t v60 = 0;
        }
        else
        {
          *(_DWORD *)(v41 + 12) = v40;
          *int v58 = v39;
          *(unsigned char *)(v41 + 16) = ~v56;
          ++*v55;
          uint64_t v40 = v53;
        }
        int v79 = 0;
        if (v40)
        {
          uint64_t v80 = v40;
          do
          {
            ++v79;
            uint64_t v81 = v10 + 20 * v80;
            int v82 = *(char *)(v81 + 16);
            uint64_t v83 = (unsigned int *)(v81 + 12);
            uint64_t v84 = (unsigned int *)(v81 + 8);
            if (v82 < 0) {
              uint64_t v84 = v83;
            }
            uint64_t v80 = *v84;
          }
          while (v80);
        }
        goto LABEL_107;
      }
      int v47 = 0;
      if (v39)
      {
        uint64_t v64 = v39;
        do
        {
          ++v47;
          uint64_t v65 = v10 + 20 * v64;
          int v66 = *(char *)(v65 + 16);
          int v67 = (unsigned int *)(v65 + 12);
          uint64_t v68 = (unsigned int *)(v65 + 8);
          if (v66 < 0) {
            uint64_t v68 = v67;
          }
          uint64_t v64 = *v68;
        }
        while (v64);
      }
      uint64_t v69 = *(unsigned int *)(v41 + 8);
      uint64_t v70 = v10 + 20 * v69;
      int v73 = *(unsigned __int8 *)(v70 + 16);
      int v71 = (unsigned char *)(v70 + 16);
      char v72 = v73;
      int v74 = v71 - 4;
      uint64_t v40 = *((unsigned int *)v71 - 1);
      if (v73 != 255)
      {
        *(_DWORD *)(v41 + 8) = v40;
        *int v74 = v39;
        *(unsigned char *)(v41 + 16) = 1 - v72;
        --*v71;
        uint64_t v40 = v69;
        goto LABEL_102;
      }
      uint64_t v75 = v10 + 20 * v40;
      int v78 = *(char *)(v75 + 16);
      uint64_t v76 = (unsigned char *)(v75 + 16);
      int v77 = v78;
      *int v74 = *((_DWORD *)v76 - 2);
      *(_DWORD *)(v41 + 8) = *((_DWORD *)v76 - 1);
      *((_DWORD *)v76 - 2) = v69;
      *((_DWORD *)v76 - 1) = v39;
      if (v78 == -1)
      {
        *int v71 = 1;
        goto LABEL_99;
      }
      if (!v77)
      {
        *int v71 = 0;
LABEL_99:
        int v71 = (unsigned char *)(v41 + 16);
LABEL_100:
        *int v71 = 0;
        goto LABEL_101;
      }
      if (v77 == 1)
      {
        *unint64_t v46 = -1;
        goto LABEL_100;
      }
LABEL_101:
      unsigned char *v76 = 0;
LABEL_102:
      int v79 = 0;
      if (v40)
      {
        uint64_t v85 = v40;
        do
        {
          ++v79;
          uint64_t v86 = v10 + 20 * v85;
          int v87 = *(char *)(v86 + 16);
          uint64_t v88 = (unsigned int *)(v86 + 12);
          uint64_t v89 = (unsigned int *)(v86 + 8);
          if (v87 < 0) {
            uint64_t v89 = v88;
          }
          uint64_t v85 = *v89;
        }
        while (v85);
      }
LABEL_107:
      BOOL v63 = v47 != v79;
      if (!v43)
      {
LABEL_114:
        *(_DWORD *)(a1 + 8) = v40;
        break;
      }
LABEL_108:
      long long v90 = (_DWORD *)(v44 + 8);
      if (v39 == *(_DWORD *)(v44 + 8) || (long long v90 = (_DWORD *)(v44 + 12), v39 == *(_DWORD *)(v44 + 12))) {
        *long long v90 = v40;
      }
      uint64_t v41 = v44;
      uint64_t v39 = v43;
    }
    while (v63);
  }
LABEL_115:
  ARRAY_Flush((uint64_t)&v91);
  uint64_t result = 0;
  *a4 = v18;
  return result;
}

uint64_t BINTREE_DeleteSubTree(uint64_t result, unsigned int a2)
{
  uint64_t v3 = result;
  uint64_t v4 = (unsigned int *)(result + 4);
  uint64_t v6 = result + 4 + 20 * a2;
  int v8 = *(_DWORD *)(v6 + 8);
  int v7 = (unsigned int *)(v6 + 8);
  if (v8) {
    uint64_t result = BINTREE_DeleteSubTree(result);
  }
  if (v4[5 * a2 + 3]) {
    uint64_t result = BINTREE_DeleteSubTree(v3);
  }
  *int v7 = *v4;
  *uint64_t v4 = a2;
  return result;
}

uint64_t BINTREE_Find(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 8);
  if (!v3) {
    return 0;
  }
  uint64_t v6 = a1 + 4;
  while (1)
  {
    int v7 = (unsigned int *)(v6 + 20 * v3);
    int v8 = (*(uint64_t (**)(uint64_t, uint64_t, void))(a2 + 8))(a2, a3, *v7);
    if (!v8) {
      break;
    }
    uint64_t v9 = v6 + 20 * v3;
    uint64_t v10 = (unsigned int *)(v9 + 8);
    int v11 = (unsigned int *)(v9 + 12);
    if (v8 < 0) {
      int v11 = v10;
    }
    uint64_t v3 = *v11;
    if (!v3) {
      return 0;
    }
  }
  return *v7;
}

uint64_t BINTREE_Destruct(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2)
  {
    BINTREE_DeleteSubTree(a1, v2);
    *(_DWORD *)(a1 + 8) = 0;
  }
  uint64_t v3 = *(void *)(a1 + 16);
  return OOCAllocator_Free(v3, a1);
}

uint64_t BINTREEITT_Inc(unsigned int *a1)
{
  uint64_t v3 = a1 + 4;
  unsigned int v2 = a1[4];
  if (v2)
  {
    uint64_t v4 = *((void *)a1 + 1) + 4;
    *a1 = *(_DWORD *)(*((void *)a1 + 3) + a1[10] * (v2 - 1));
    ARRAY_Destroy((uint64_t)(a1 + 4), v2 - 1);
    unsigned int __src = *(_DWORD *)(v4 + 20 * *a1 + 12);
    if (__src)
    {
      while (1)
      {
        unsigned int v5 = (kaldi::nnet1::UpdatableComponent *)ARRAY_Add(v3, &__src);
        if (v5 == -1) {
          break;
        }
        unsigned int __src = *(_DWORD *)(v4 + 20 * __src + 8);
        if (!__src) {
          return 0;
        }
      }
      return kaldi::nnet1::UpdatableComponent::IsUpdatable(v5);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t result = 0;
    *a1 = 0;
  }
  return result;
}

uint64_t BINTREEITT_Current(unsigned int *a1)
{
  return *((void *)a1 + 1) + 20 * *a1 + 4;
}

uint64_t BINTREEITT_ReStart(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *(_DWORD *)(a1 + 16) = 0;
  uint64_t v3 = (unsigned int *)(a1 + 16);
  unsigned int v4 = *(_DWORD *)(v2 + 8);
  unsigned int __src = v4;
  if (v4)
  {
    uint64_t v5 = v2 + 4;
    while (1)
    {
      uint64_t v6 = v5 + 20 * v4;
      int v8 = *(_DWORD *)(v6 + 8);
      int v7 = (unsigned int *)(v6 + 8);
      if (!v8) {
        break;
      }
      uint64_t v9 = (kaldi::nnet1::UpdatableComponent *)ARRAY_Add(v3, &__src);
      if (v9 == -1) {
        return kaldi::nnet1::UpdatableComponent::IsUpdatable(v9);
      }
      unsigned int v4 = *v7;
      unsigned int __src = *v7;
    }
    *(_DWORD *)a1 = v4;
    unsigned int __src = *(_DWORD *)(v5 + 20 * v4 + 12);
    if (!__src) {
      return 0;
    }
    while (1)
    {
      uint64_t v9 = (kaldi::nnet1::UpdatableComponent *)ARRAY_Add(v3, &__src);
      if (v9 == -1) {
        break;
      }
      unsigned int __src = *(_DWORD *)(v5 + 20 * __src + 8);
      if (!__src) {
        return 0;
      }
    }
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(v9);
  }
  else
  {
    uint64_t result = 0;
    *(_DWORD *)a1 = 0;
  }
  return result;
}

uint64_t BINTREEITT_Init(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2;
  ARRAY_Init(a1 + 16, *(void *)(a2 + 16), 4, 64);
  return BINTREEITT_ReStart(a1);
}

void *err_ErrorGetCallback(void *result, void *a2)
{
  *uint64_t result = 0;
  *a2 = 0;
  return result;
}

uint64_t err_GenerateErrorNotSupported()
{
  return 8;
}

uint64_t err_GenerateErrorInternal()
{
  return 9;
}

uint64_t err_GenerateErrorCallback()
{
  return 6;
}

uint64_t err_GenerateErrorLimit()
{
  return 7;
}

uint64_t err_GenerateErrorVersion()
{
  return 5;
}

uint64_t VoConObject_Con2(void *a1, uint64_t a2)
{
  uint64_t result = RefCounted_Con((uint64_t)a1, 1);
  if (!result)
  {
    uint64_t v5 = 0;
    *a1 = &__VoConObject;
    a1[6] = a2;
    a1[3] = &unk_26C21AF10;
    a1[4] = 0;
    uint64_t result = PNEW_NullLogger_Con(a2, &v5);
    if (!result) {
      a1[5] = v5 + 24;
    }
  }
  return result;
}

uint64_t VoConObject_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2
    || (uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 72))(v2 - *(void *)(*(void *)v2 + 88)),
        !result))
  {
    return RefCounted_Des(a1);
  }
  return result;
}

uint64_t VoConObject_GetLogger(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (!v1) {
    return 0;
  }
  (*(void (**)(uint64_t))(*(void *)v1 + 80))(v1 - *(void *)(*(void *)v1 + 88));
  return *(void *)(a1 + 40);
}

uint64_t VoConObject_GetUserData(uint64_t a1, void *a2)
{
  *a2 = *(void *)(a1 + 32);
  return 0;
}

BOOL VoConObject_IsClosable(uint64_t a1)
{
  return (*(unsigned int (**)(uint64_t))(*(void *)a1 + 40))(a1) < 2;
}

uint64_t VoConObject_QueryInterface(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1 + 24;
  if (a2 != 256370412) {
    uint64_t v3 = 0;
  }
  *a3 = v3;
  return 0;
}

uint64_t VoConObject_SetLogger(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  if (!v4
    || (uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 72))(v4 - *(void *)(*(void *)v4 + 88)),
        !result))
  {
    (*(void (**)(uint64_t))(*(void *)a2 + 80))(a2 - *(void *)(*(void *)a2 + 88));
    uint64_t result = 0;
    *(void *)(a1 + 40) = a2;
  }
  return result;
}

uint64_t VoConObject_SetUserData(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 32) = a2;
  return 0;
}

void *GetVoConObjectClass()
{
  return &__VoConObject;
}

uint64_t GetNull()
{
  return 0;
}

uint64_t Object_Des()
{
  return 0;
}

void *GetObjectClass()
{
  return &__Object;
}

uint64_t OOC_PlacementDeleteObject(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  if (!v4) {
    OOCAllocator_Free(a1, a2);
  }
  return v4;
}

uint64_t Object_Con(void *a1)
{
  *a1 = &__Object;
  return 0;
}

uint64_t RefCounted_Con(uint64_t a1, int a2)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__RefCounted;
    *(void *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 8) = a2;
  }
  return result;
}

uint64_t RefCounted_DecRefCount(uint64_t a1)
{
  if (atomic_decrement((_DWORD *)(a1 + 8)) != 1) {
    return 0;
  }
  *(_DWORD *)(a1 + 8) = 1;
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2)
  {
    return OOC_PlacementDeleteObject(v2, a1);
  }
  else
  {
    uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)a1 + 16);
    return v4(a1);
  }
}

uint64_t RefCounted_GetRefCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t RefCounted_IncRefCount(uint64_t a1)
{
  return atomic_increment((_DWORD *)(a1 + 8));
}

void *GetRefCountedClass()
{
  return &__RefCounted;
}

uint64_t OOCAllocator_Con(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  long long v3 = a2[1];
  *(_OWORD *)a1 = *a2;
  *(_OWORD *)(a1 + 16) = v3;
  *(void *)(a1 + 32) = a3;
  return 0;
}

uint64_t OOCAllocator_Calloc(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  if (!a2)
  {
    int ErrorInternal = err_GenerateErrorInternal();
LABEL_6:
    uint64_t v6 = 0;
    goto LABEL_7;
  }
  uint64_t v5 = (*(uint64_t (**)(void))(a1 + 8))(*(void *)(a1 + 32));
  if (!v5)
  {
    int ErrorInternal = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
    goto LABEL_6;
  }
  uint64_t v6 = v5;
  int ErrorInternal = 0;
LABEL_7:
  *a4 = ErrorInternal;
  return v6;
}

uint64_t OOCAllocator_Free(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(result + 24))(*(void *)(result + 32));
  }
  return result;
}

uint64_t OOCAllocator_Malloc(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2)
  {
    int ErrorInternal = err_GenerateErrorInternal();
LABEL_6:
    uint64_t v5 = 0;
    goto LABEL_7;
  }
  uint64_t v4 = (*(uint64_t (**)(void))a1)(*(void *)(a1 + 32));
  if (!v4)
  {
    int ErrorInternal = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
    goto LABEL_6;
  }
  uint64_t v5 = v4;
  int ErrorInternal = 0;
LABEL_7:
  *a3 = ErrorInternal;
  return v5;
}

uint64_t OOCAllocator_Realloc(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  if (!a3)
  {
    int ErrorInternal = err_GenerateErrorInternal();
LABEL_6:
    uint64_t v6 = 0;
    goto LABEL_7;
  }
  uint64_t v5 = (*(uint64_t (**)(void))(a1 + 16))(*(void *)(a1 + 32));
  if (!v5)
  {
    int ErrorInternal = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
    goto LABEL_6;
  }
  uint64_t v6 = v5;
  int ErrorInternal = 0;
LABEL_7:
  *a4 = ErrorInternal;
  return v6;
}

uint64_t atomic_increment(_DWORD *a1)
{
  uint64_t v1 = *a1;
  *a1 = v1 + 1;
  return v1;
}

uint64_t atomic_decrement(_DWORD *a1)
{
  uint64_t v1 = *a1;
  *a1 = v1 - 1;
  return v1;
}

uint64_t PtrList_Con(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)(a1 + 32) = a2;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)a1 = &__PtrList;
    *(_DWORD *)(a1 + 24) = a4;
    return _PtrList_ResizeList(a1, a3);
  }
  return result;
}

uint64_t _PtrList_ResizeList(uint64_t a1, unsigned int a2)
{
  uint64_t result = 0;
  unsigned int v8 = 0;
  unsigned int v4 = *(_DWORD *)(a1 + 20);
  if (v4 < a2)
  {
    unsigned int v5 = *(_DWORD *)(a1 + 24) + v4;
    if (v5 <= a2) {
      unsigned int v6 = a2;
    }
    else {
      unsigned int v6 = v5;
    }
    uint64_t v7 = OOCAllocator_Realloc(*(void *)(a1 + 32), *(void *)(a1 + 8), 8 * v6, &v8);
    uint64_t result = v8;
    if (!v8)
    {
      *(void *)(a1 + 8) = v7;
      *(_DWORD *)(a1 + 20) = v6;
    }
  }
  return result;
}

uint64_t PtrList_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    OOCAllocator_Free(*(void *)(a1 + 32), v2);
    *(void *)(a1 + 8) = 0;
  }
  return Object_Des();
}

uint64_t PtrList_Append(uint64_t a1, uint64_t a2)
{
  uint64_t result = _PtrList_ResizeList(a1, *(_DWORD *)(a1 + 16) + 1);
  if (!result)
  {
    uint64_t v5 = *(void *)(a1 + 8);
    uint64_t v6 = *(unsigned int *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = v6 + 1;
    *(void *)(v5 + 8 * v6) = a2;
  }
  return result;
}

uint64_t PNEW_PtrList_Con(uint64_t a1, uint64_t a2, unsigned int a3, int a4, uint64_t *a5)
{
  unsigned int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 40, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = PtrList_Con(v10, a2, a3, a4);
    unsigned int v12 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *a5 = v10;
    }
  }
  return result;
}

uint64_t PtrList_ItemN(uint64_t a1, unsigned int a2)
{
  return *(void *)(*(void *)(a1 + 8) + 8 * a2);
}

uint64_t PtrList_Find(uint64_t a1, uint64_t a2, unsigned int (*a3)(uint64_t *, uint64_t *))
{
  uint64_t v7 = 0;
  uint64_t v8 = a2;
  if (!*(_DWORD *)(a1 + 16)) {
    return 0;
  }
  uint64_t v5 = 0;
  while (1)
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 8) + 8 * v5);
    if (!a3(&v8, &v7)) {
      break;
    }
    if (++v5 >= (unint64_t)*(unsigned int *)(a1 + 16)) {
      return 0;
    }
  }
  return v7;
}

uint64_t PtrList_Prepend(uint64_t a1, uint64_t a2)
{
  uint64_t result = _PtrList_ResizeList(a1, *(_DWORD *)(a1 + 16) + 1);
  if (!result)
  {
    int v5 = *(_DWORD *)(a1 + 16);
    if (v5)
    {
      uint64_t v6 = *(unsigned int *)(a1 + 16);
      do
      {
        *(void *)(*(void *)(a1 + 8) + 8 * v6) = *(void *)(*(void *)(a1 + 8) + 8 * (v6 - 1));
        --v6;
      }
      while (v6);
    }
    **(void **)(a1 + 8) = a2;
    *(_DWORD *)(a1 + 16) = v5 + 1;
  }
  return result;
}

uint64_t PtrList_Remove(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 16);
  if (v2)
  {
    uint64_t v3 = 0;
    while (*(void *)(*(void *)(result + 8) + 8 * v3) != a2)
    {
      if (v2 == ++v3) {
        return result;
      }
    }
    uint64_t v4 = (v2 - 1);
    if (v4 > v3)
    {
      do
      {
        *(void *)(*(void *)(result + 8) + 8 * v3) = *(void *)(*(void *)(result + 8) + 8 * v3 + 8);
        ++v3;
      }
      while (v4 != v3);
    }
    *(_DWORD *)(result + 16) = v4;
  }
  return result;
}

uint64_t PtrList_RemoveAll(uint64_t result)
{
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t PtrList_UdSort(uint64_t result, uint64_t (*a2)(char *, char *, uint64_t), uint64_t a3)
{
  unsigned int v4 = *(_DWORD *)(result + 16);
  if (v4) {
    return lhstdlib_udqsort(*(void *)(result + 8), v4, 8u, a3, a2);
  }
  return result;
}

void *GetPtrListClass()
{
  return &__PtrList;
}

uint64_t PtrStack_Con(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)(a1 + 32) = 0;
    *(_DWORD *)(a1 + 20) = 0;
    *(_DWORD *)(a1 + 24) = 0;
    *(_DWORD *)(a1 + 16) = a3;
    *(void *)a1 = &__PtrStack;
    *(void *)(a1 + 8) = a2;
  }
  return result;
}

uint64_t PtrStack_Des(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1) {
    OOCAllocator_Free(*(void *)(a1 + 8), v1);
  }
  return Object_Des();
}

uint64_t PtrStack_Put(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 24);
  unsigned int v5 = v4 + 1;
  if (v4 + 1 <= *(_DWORD *)(a1 + 20))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    goto LABEL_5;
  }
  unsigned int v9 = 0;
  uint64_t v6 = OOCAllocator_Realloc(*(void *)(a1 + 8), *(void *)(a1 + 32), 8 * (*(_DWORD *)(a1 + 16) + v4), &v9);
  *(void *)(a1 + 32) = v6;
  uint64_t v7 = v9;
  if (!v9)
  {
    *(_DWORD *)(a1 + 20) += *(_DWORD *)(a1 + 16);
    unsigned int v4 = *(_DWORD *)(a1 + 24);
    unsigned int v5 = v4 + 1;
LABEL_5:
    uint64_t v7 = 0;
    *(void *)(v6 + 8 * v4) = a2;
    *(_DWORD *)(a1 + 24) = v5;
  }
  return v7;
}

uint64_t PtrStack_Remove(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 24);
  if (!v1) {
    return 3;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 24) = v1 - 1;
  return result;
}

uint64_t PNEW_PtrStack_Con(uint64_t a1, uint64_t a2, int a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 40, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = Object_Con((void *)v8);
    if (result)
    {
      unsigned int v10 = result;
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *(void *)(v8 + 32) = 0;
      *(_DWORD *)(v8 + 20) = 0;
      *(_DWORD *)(v8 + 24) = 0;
      *(_DWORD *)(v8 + 16) = a3;
      *(void *)uint64_t v8 = &__PtrStack;
      *(void *)(v8 + 8) = a2;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t PtrQueue_Con(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__PtrQueue;
    *(void *)(a1 + 8) = 0;
    uint64_t result = PNEW_PtrList_Con(a2, a2, a3, a4, (uint64_t *)(a1 + 8));
    if (!result)
    {
      *(void *)(a1 + 24) = a2;
      *(_DWORD *)(a1 + 16) = a3;
      *(_DWORD *)(a1 + 20) = a4;
    }
  }
  return result;
}

uint64_t PtrQueue_Des(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    OOC_PlacementDeleteObject(*(void *)(a1 + 24), v1);
  }
  Object_Des();
  return 0;
}

BOOL PtrQueue_IsEmpty(uint64_t a1)
{
  return kaldi::MatrixBase<float>::Stride(*(void *)(a1 + 8)) == 0;
}

uint64_t PtrQueue_Item(uint64_t a1)
{
  if (!kaldi::MatrixBase<float>::Stride(*(void *)(a1 + 8))) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 8);
  return PtrList_ItemN(v2, 0);
}

uint64_t PtrQueue_NrItems(uint64_t a1)
{
  return kaldi::MatrixBase<float>::Stride(*(void *)(a1 + 8));
}

uint64_t PtrQueue_Put(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 20)
    || kaldi::MatrixBase<float>::Stride(*(void *)(a1 + 8)) != *(_DWORD *)(a1 + 16))
  {
    uint64_t v5 = *(void *)(a1 + 8);
    return PtrList_Append(v5, a2);
  }
  else
  {
    return err_GenerateErrorLimit();
  }
}

uint64_t PtrQueue_Remove(uint64_t a1)
{
  if (kaldi::MatrixBase<float>::Stride(*(void *)(a1 + 8))
    || (uint64_t result = kaldi::StandardInputImpl::MyType(0), !result))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    uint64_t v4 = PtrQueue_Item(a1);
    PtrList_Remove(v3, v4);
    return 0;
  }
  return result;
}

uint64_t adler3200(unsigned int a1, unsigned __int8 *a2, unsigned int a3)
{
  if (!a2) {
    return 1;
  }
  unsigned int v3 = HIWORD(a1);
  unsigned int v4 = (unsigned __int16)a1;
  if (a3 < 0x10)
  {
    for (; a3; --a3)
    {
      int v5 = *a2++;
      v4 += v5;
      v3 += v4;
    }
    if (v4 > 0xFFF0) {
      v4 -= 65521;
    }
    v3 %= 0xFFF1u;
    return v4 | (v3 << 16);
  }
  if (a3 >> 4 >= 0x15B)
  {
    do
    {
      a3 -= 5552;
      int v7 = -347;
      uint64_t v8 = a2;
      do
      {
        unsigned int v9 = v4 + *v8;
        unsigned int v10 = v9 + v3;
        unsigned int v11 = v9 + v8[1];
        unsigned int v12 = v10 + v11;
        unsigned int v13 = v11 + v8[2];
        unsigned int v14 = v12 + v13;
        unsigned int v15 = v13 + v8[3];
        unsigned int v16 = v14 + v15;
        unsigned int v17 = v15 + v8[4];
        unsigned int v18 = v16 + v17;
        unsigned int v19 = v17 + v8[5];
        unsigned int v20 = v18 + v19;
        unsigned int v21 = v19 + v8[6];
        int v22 = v20 + v21;
        unsigned int v23 = v21 + v8[7];
        int v24 = v22 + v23;
        unsigned int v25 = v23 + v8[8];
        int v26 = v24 + v25;
        int v27 = v25 + v8[9];
        int v28 = v26 + v27;
        int v29 = v27 + v8[10];
        int v30 = v28 + v29;
        int v31 = v29 + v8[11];
        int v32 = v30 + v31;
        int v33 = v31 + v8[12];
        int v34 = v32 + v33;
        int v35 = v33 + v8[13];
        int v36 = v34 + v35;
        int v37 = v35 + v8[14];
        int v38 = v36 + v37;
        unsigned int v4 = v37 + v8[15];
        unsigned int v3 = v38 + v4;
        v8 += 16;
      }
      while (!__CFADD__(v7++, 1));
      a2 += 5552;
      v4 %= 0xFFF1u;
      v3 %= 0xFFF1u;
    }
    while (a3 >> 4 > 0x15A);
    if (!a3) {
      return v4 | (v3 << 16);
    }
    if (a3 < 0x10) {
      goto LABEL_23;
    }
  }
  do
  {
    a3 -= 16;
    unsigned int v40 = v4 + *a2;
    unsigned int v41 = v40 + v3;
    unsigned int v42 = v40 + a2[1];
    unsigned int v43 = v41 + v42;
    unsigned int v44 = v42 + a2[2];
    unsigned int v45 = v43 + v44;
    unsigned int v46 = v44 + a2[3];
    unsigned int v47 = v45 + v46;
    unsigned int v48 = v46 + a2[4];
    unsigned int v49 = v47 + v48;
    unsigned int v50 = v48 + a2[5];
    unsigned int v51 = v49 + v50;
    unsigned int v52 = v50 + a2[6];
    int v53 = v51 + v52;
    unsigned int v54 = v52 + a2[7];
    int v55 = v53 + v54;
    unsigned int v56 = v54 + a2[8];
    int v57 = v55 + v56;
    int v58 = v56 + a2[9];
    int v59 = v57 + v58;
    int v60 = v58 + a2[10];
    int v61 = v59 + v60;
    int v62 = v60 + a2[11];
    int v63 = v61 + v62;
    int v64 = v62 + a2[12];
    int v65 = v63 + v64;
    int v66 = v64 + a2[13];
    int v67 = v65 + v66;
    int v68 = v66 + a2[14];
    int v69 = v67 + v68;
    unsigned int v4 = v68 + a2[15];
    unsigned int v3 = v69 + v4;
    a2 += 16;
  }
  while (a3 > 0xF);
  if (a3)
  {
LABEL_23:
    do
    {
      int v70 = *a2++;
      v4 += v70;
      v3 += v4;
      --a3;
    }
    while (a3);
  }
  v4 %= 0xFFF1u;
  v3 %= 0xFFF1u;
  return v4 | (v3 << 16);
}

uint64_t _DataSectionRandomReader_ConInternal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, unsigned int a8, int a9)
{
  uint64_t result = RefCounted_Con(a1, 1);
  unsigned int v25 = result;
  if (result) {
    return result;
  }
  *(void *)a1 = &__DataSectionRandomReader;
  *(void *)(a1 + 24) = &off_26C21A6A8;
  *(void *)(a1 + 80) = a4;
  *(void *)(a1 + 88) = a5;
  BOOL v18 = (a8 & 1) != 0 && (__int16)a8 <= -1;
  int v19 = a8 & 0x7FFE;
  BOOL v20 = !v18 || v19 == 0;
  unsigned int v21 = v19 << 15;
  if (v20) {
    unsigned int v21 = a8;
  }
  *(_DWORD *)(a1 + 48) = v21;
  *(void *)(a1 + 32) = &off_26C21A6E8;
  *(void *)(a1 + 40) = a6;
  unint64_t v22 = a7;
  *(void *)(a1 + 64) = a7;
  *(void *)(a1 + 72) = a3;
  *(void *)(a1 + 104) = a2;
  *(_DWORD *)(a1 + 152) = a9;
  *(_DWORD *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 136) = xmmword_20D60CCA0;
  if (v21)
  {
    unint64_t v23 = v21 + 4;
    unint64_t v22 = a7 - 4 * ((a7 + (unint64_t)v21 + 3) / v23);
    *(void *)(a1 + 56) = v22;
    if (v21 <= 0x1000)
    {
      *(_DWORD *)(a1 + 112) = 1;
      *(void *)(a1 + 120) = OOCAllocator_Malloc(a2, v23, &v25);
      uint64_t result = v25;
      if (v25) {
        return result;
      }
      unsigned int v21 = *(_DWORD *)(a1 + 48);
      unint64_t v22 = *(void *)(a1 + 56);
      int v24 = *(uint64_t (***)())(a1 + 24);
      goto LABEL_16;
    }
  }
  else
  {
    *(void *)(a1 + 56) = a7;
  }
  int v24 = &off_26C21A6A8;
LABEL_16:
  if (v22 < v21) {
    unsigned int v21 = v22;
  }
  *(_DWORD *)(a1 + 96) = v22;
  *(_DWORD *)(a1 + 100) = v21;
  return ((uint64_t (*)(uint64_t, void))*v24)(a1 + 24 - (void)v24[7], 0);
}

uint64_t DataSectionRandomReader_Des(void *a1)
{
  uint64_t v2 = a1[11];
  if (!v2
    || (uint64_t result = (**(uint64_t (***)(uint64_t))v2)(v2 - *(void *)(*(void *)v2 + 8)), !result))
  {
    OOCAllocator_Free(a1[13], a1[15]);
    return RefCounted_Des(a1);
  }
  return result;
}

uint64_t DataSectionRandomReader_Clone(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t *a4)
{
  unint64_t v4 = *(void *)(a1 + 64);
  unsigned int v5 = v4 - a2;
  if (v4 >= a2)
  {
    unsigned int v7 = *(_DWORD *)(a1 + 48);
    if (HIWORD(v7)) {
      unsigned __int16 v8 = (v7 >> 15) | 0x8001;
    }
    else {
      unsigned __int16 v8 = *(_DWORD *)(a1 + 48);
    }
    return PNEW_DataSectionRandomReader_Con(*(void *)(a1 + 104), *(void *)(a1 + 104), *(void *)(a1 + 72), *(void *)(a1 + 80), a3, *(void *)(a1 + 40) + a2, v5, v8, a4);
  }
  else
  {
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"startOffset");
  }
}

uint64_t PNEW_DataSectionRandomReader_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, unsigned int a8, uint64_t *a9)
{
  unsigned int v19 = 0;
  uint64_t v17 = OOCAllocator_Malloc(a1, 160, &v19);
  uint64_t result = v19;
  if (!v19)
  {
    uint64_t result = _DataSectionRandomReader_ConInternal(v17, a2, a3, a4, a5, a6, a7, a8, 0);
    unsigned int v19 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v17);
      *a9 = 0;
      return v19;
    }
    else
    {
      *(void *)(v17 + 16) = a1;
      *a9 = v17;
    }
  }
  return result;
}

uint64_t DataSectionRandomReader_GetDataSize(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t DataSectionRandomReader_Read(uint64_t a1, char *__dst, unint64_t a3)
{
  if (*(unsigned int *)(a1 + 96) >= a3) {
    return __DataSectionRandomReader_ReadInternalInterruptible(a1, a3, 0, __dst, &v5, &v4);
  }
  return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
}

uint64_t __DataSectionRandomReader_ReadInternalInterruptible(uint64_t a1, unint64_t a2, int a3, char *__dst, uint64_t *a5, _DWORD *a6)
{
  unsigned __int16 v8 = __dst;
  unint64_t v10 = a2;
  unsigned int v30 = 0;
  *a6 = 0;
  if (*(_DWORD *)(a1 + 48))
  {
    uint64_t v12 = 0;
    if (a2)
    {
      do
      {
        unint64_t v13 = *(unsigned int *)(a1 + 100);
        if (v10 >= v13) {
          size_t v14 = *(unsigned int *)(a1 + 100);
        }
        else {
          size_t v14 = v10;
        }
        if (*(_DWORD *)(a1 + 112))
        {
          uint64_t v15 = *(void *)(a1 + 144);
          if (*(void *)(a1 + 128) != *(void *)(a1 + 136))
          {
            uint64_t v16 = v13 + v15 + 4;
            uint64_t v17 = (**(uint64_t (***)(void, uint64_t, uint64_t, void))(a1 + 72))(*(void *)(a1 + 120), 1, v16, *(void *)(a1 + 80));
            if (!__DataSectionRandomReader_ReadCallOk(a1, v16, v17, 0, a6, &v30)) {
              return v30;
            }
            uint64_t v18 = *(void *)(a1 + 120);
            *(void *)(a1 + 136) = *(void *)(a1 + 128);
            int v19 = *(_DWORD *)(v18 + *(void *)(a1 + 144) + *(unsigned int *)(a1 + 100));
            unsigned int v20 = adler3200(0, 0, 0);
            if (v19 != adler3200(v20, *(unsigned __int8 **)(a1 + 120), *(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 144)))return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"CRC not valid"); {
            uint64_t v15 = *(void *)(a1 + 144);
            }
          }
          memcpy(v8, (const void *)(*(void *)(a1 + 120) + v15), v14);
          *(void *)(a1 + 144) += v14;
        }
        else
        {
          uint64_t v21 = (**(uint64_t (***)(void *, uint64_t, size_t, void))(a1 + 72))(v8, 1, v14, *(void *)(a1 + 80));
          int v22 = __DataSectionRandomReader_ReadCallOk(a1, v14, v21, a3, a6, &v30);
          size_t v14 = v21;
          if (!v22) {
            return v30;
          }
        }
        int v23 = *(_DWORD *)(a1 + 100) - v14;
        *(_DWORD *)(a1 + 100) = v23;
        if (v23)
        {
          v12 += v14;
        }
        else
        {
          int v24 = *(_DWORD *)(a1 + 112);
          if (!v24)
          {
            uint64_t v25 = (**(uint64_t (***)(char *, uint64_t, uint64_t, void))(a1 + 72))(v29, 1, 4, *(void *)(a1 + 80));
            if (!__DataSectionRandomReader_ReadCallOk(a1, 4, v25, a3, a6, &v30)) {
              return v30;
            }
            int v24 = *(_DWORD *)(a1 + 112);
          }
          unint64_t v26 = *(unsigned int *)(a1 + 48);
          v12 += v14;
          if ((unint64_t)*(unsigned int *)(a1 + 96) - v12 < v26) {
            LODWORD(v26) = *(_DWORD *)(a1 + 96) - v12;
          }
          *(_DWORD *)(a1 + 100) = v26;
          if (v24)
          {
            *(void *)(a1 + 128) += *(void *)(a1 + 144) + 4;
            *(void *)(a1 + 144) = 0;
          }
        }
        v8 += v14;
        v10 -= v14;
      }
      while (v10);
    }
    *(_DWORD *)(a1 + 96) -= v12;
    *a5 = v12;
  }
  else
  {
    uint64_t v27 = (**(uint64_t (***)(void *, uint64_t, unint64_t, void))(a1 + 72))(__dst, 1, a2, *(void *)(a1 + 80));
    *a5 = v27;
    __DataSectionRandomReader_ReadCallOk(a1, v10, v27, a3, a6, &v30);
  }
  return v30;
}

uint64_t DataSectionRandomReader_ReadInterruptible(uint64_t a1, char *__dst, unint64_t a3, _DWORD *a4)
{
  *a4 = 0;
  if (*(unsigned int *)(a1 + 96) >= a3) {
    return __DataSectionRandomReader_ReadInternalInterruptible(a1, a3, 0, __dst, &v5, a4);
  }
  return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
}

uint64_t DataSectionRandomReader_ReadPartial(uint64_t a1, char *__dst, unint64_t a3, uint64_t *a4)
{
  if (*(unsigned int *)(a1 + 96) >= a3) {
    unint64_t v6 = a3;
  }
  else {
    unint64_t v6 = *(unsigned int *)(a1 + 96);
  }
  return __DataSectionRandomReader_ReadInternalInterruptible(a1, v6, 1, __dst, a4, &v8);
}

uint64_t DataSectionRandomReader_Seek(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = *(void *)(a1 + 56);
  if (v2 < a2)
  {
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"seek offset out of range");
  }
  unsigned int v5 = v2 - a2;
  *(_DWORD *)(a1 + 96) = v2 - a2;
  unsigned int v6 = *(_DWORD *)(a1 + 48);
  int v7 = a2 / v6;
  unsigned int v8 = a2 + 4 * v7;
  if (v6 + v6 * v7 - a2 < v5) {
    unsigned int v5 = v6 + v6 * v7 - a2;
  }
  *(_DWORD *)(a1 + 100) = v5;
  if (*(_DWORD *)(a1 + 112))
  {
    uint64_t v9 = v7 * (v6 + 4);
    if (*(void *)(a1 + 136) == v9
      || !(*(unsigned int (**)(void, uint64_t, void))(*(void *)(a1 + 72) + 8))(*(void *)(a1 + 80), *(void *)(a1 + 40) + v9, 0))
    {
      *(void *)(a1 + 128) = v9;
      *(void *)(a1 + 144) = v8 - v9;
      return 0;
    }
  }
  else if (!(*(unsigned int (**)(void, void, void))(*(void *)(a1 + 72) + 8))(*(void *)(a1 + 80), *(void *)(a1 + 40) + v8, 0))
  {
    return 0;
  }
  return err_GenerateErrorCallback();
}

uint64_t PNEW_DataSectionRandomReader_ConForInterruptible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, unsigned int a8, int a9, uint64_t *a10)
{
  unsigned int v20 = 0;
  uint64_t v18 = OOCAllocator_Malloc(a1, 160, &v20);
  uint64_t result = v20;
  if (!v20)
  {
    uint64_t result = _DataSectionRandomReader_ConInternal(v18, a2, a3, a4, a5, a6, a7, a8, a9);
    unsigned int v20 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v18);
      *a10 = 0;
      return v20;
    }
    else
    {
      *(void *)(v18 + 16) = a1;
      *a10 = v18;
    }
  }
  return result;
}

uint64_t __DataSectionRandomReader_ReadCallOk(uint64_t a1, uint64_t a2, uint64_t a3, int a4, _DWORD *a5, _DWORD *a6)
{
  if (a3 == a2) {
    return 1;
  }
  if ((*(unsigned int (**)(void))(*(void *)(a1 + 72) + 16))(*(void *)(a1 + 80)))
  {
    int ErrorCallback = err_GenerateErrorCallback();
LABEL_5:
    int v12 = ErrorCallback;
    uint64_t result = 0;
    *a6 = v12;
    return result;
  }
  if (a4)
  {
    uint64_t result = 0;
    *a5 = 0;
  }
  else
  {
    if (!*(_DWORD *)(a1 + 152))
    {
      int ErrorCallback = kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
      goto LABEL_5;
    }
    uint64_t result = 0;
    *a5 = 1;
  }
  return result;
}

uint64_t BinBlockStreamReader_Con(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v6 = _BinBlockStreamReader_ConInternal(a1, a2, a3, a4, a5, 1, 0);
  if (!v6)
  {
    uint64_t v10 = 0;
    uint64_t inited = _BinBlockStreamReader_InitInternal(a1, 0, 1, (int *)&v10 + 1, &v10);
    if (inited)
    {
      uint64_t v6 = inited;
      BinBlockStreamReader_Des(a1);
    }
    else
    {
      if (v10 == 1)
      {
        unsigned int v8 = "Not enough data in stream";
      }
      else
      {
        if (HIDWORD(v10) != 1) {
          return 0;
        }
        unsigned int v8 = "Checksum error in data header";
      }
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v8);
    }
  }
  return v6;
}

uint64_t _BinBlockStreamReader_ConInternal(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, _DWORD *a5, int a6, uint64_t a7)
{
  uint64_t result = RefCounted_Con(a1, 1);
  unsigned int v18 = result;
  if (!result)
  {
    *(void *)a1 = &__BinBlockStreamReader;
    *(void *)(a1 + 24) = &unk_26C21A068;
    *(void *)(a1 + 32) = &unk_26C21A078;
    *(_WORD *)(a1 + 72) = 0;
    *(_DWORD *)(a1 + 112) = 0;
    *(void *)(a1 + 40) = &unk_26C21A160;
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 54) = 0;
    *(void *)(a1 + 120) = a2;
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 64) = 0;
    *(_DWORD *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = 0;
    *(_DWORD *)(a1 + 144) = a6;
    *(void *)(a1 + 148) = 0;
    *(void *)(a1 + 160) = a7;
    uint64_t v15 = (_OWORD *)OOCAllocator_Malloc(a2, 32, &v18);
    *(void *)(a1 + 80) = v15;
    uint64_t result = v18;
    if (!v18)
    {
      long long v16 = a3[1];
      *uint64_t v15 = *a3;
      v15[1] = v16;
      *(void *)(a1 + 88) = a4;
      if (a5)
      {
        *(_DWORD *)(a1 + 64) = *a5;
        uint64_t v17 = (_DWORD *)OOCAllocator_Malloc(a2, 4, &v18);
        *(void *)(a1 + 96) = v17;
        uint64_t result = v18;
        if (v18) {
          return result;
        }
        *uint64_t v17 = *a5;
      }
      else
      {
        *(void *)(a1 + 96) = 0;
        *(_DWORD *)(a1 + 64) = 1;
      }
      return PNEW_ParamDB_Con(a2, a2, (void *)(a1 + 136));
    }
  }
  return result;
}

uint64_t _BinBlockStreamReader_InitInternal(uint64_t a1, int a2, int a3, int *a4, _DWORD *a5)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  *a4 = 0;
  *a5 = 0;
  uint64_t v9 = *(void *)(a1 + 136);
  if (a2) {
    int v10 = 2;
  }
  else {
    int v10 = 0;
  }
  unsigned int v36 = ParamDB_AddPublicParam(v9, 987249153, v10, (uint64_t)__BinBlockStreamReader_IsValidInterruptibleStatus);
  if (v36) {
    return v36;
  }
  unint64_t v34 = 0;
  uint64_t v35 = 0;
  int v33 = 0;
  if ((**(uint64_t (***)(int *, uint64_t, uint64_t, void))(a1 + 80))(&v37, 1, 28, *(void *)(a1 + 88)) != 28)
  {
    if ((*(unsigned int (**)(void))(*(void *)(a1 + 80) + 16))(*(void *)(a1 + 88))) {
      goto LABEL_11;
    }
    if (ParamDB_GetParam(*(void *)(a1 + 136), 987249153) == 2)
    {
      *a5 = 1;
      return v36;
    }
    if (!a3) {
      goto LABEL_57;
    }
    int v23 = "Not enough data in stream";
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v23);
  }
  int v11 = v37;
  int v12 = v38;
  *(_DWORD *)(a1 + 48) = v37;
  *(_DWORD *)(a1 + 52) = v12;
  int v13 = v39;
  *(_DWORD *)(a1 + 56) = v39;
  int v14 = v40;
  *(_WORD *)(a1 + 60) = v40;
  int v15 = v41;
  int v16 = v42;
  *(_WORD *)(a1 + 72) = v42;
  unsigned int v17 = v43;
  if (*(_DWORD *)(a1 + 64))
  {
    if (v45)
    {
      if (v12 + v11 + v13 + v14 + v15 + v16 + v43 + v44 != v45) {
        goto LABEL_57;
      }
      int v18 = 0;
    }
    else
    {
      int v18 = 1;
    }
    if (v16) {
      int v20 = v18;
    }
    else {
      int v20 = 1;
    }
  }
  else
  {
    int v20 = 0;
  }
  if (v15 != 1)
  {
    if (!a3) {
      goto LABEL_57;
    }
    int v23 = "data has wrong byte ordering";
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v23);
  }
  if ((**(uint64_t (***)(int *, uint64_t, uint64_t, void))(a1 + 80))(&v37, 1, 12, *(void *)(a1 + 88)) != 12)
  {
    if (!(*(unsigned int (**)(void))(*(void *)(a1 + 80) + 16))(*(void *)(a1 + 88)))
    {
      if (ParamDB_GetParam(*(void *)(a1 + 136), 987249153) == 2)
      {
        *a5 = 1;
      }
      else if (a3)
      {
        unsigned int v36 = kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
      }
      else
      {
        *a4 = 1;
      }
      goto LABEL_45;
    }
LABEL_11:
    if (a3) {
      return err_GenerateErrorCallback();
    }
LABEL_57:
    int v24 = 1;
    goto LABEL_58;
  }
  if (v37 != 270012440 || v38 != v17 || v39 != 0x10000)
  {
    if (!a3) {
      goto LABEL_57;
    }
    int v23 = "Wrong stream format";
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v23);
  }
  unsigned int v36 = PNEW_DataSectionReader_ConForInterruptibleStream(*(void *)(a1 + 120), *(void *)(a1 + 120), *(void *)(a1 + 80), *(void *)(a1 + 88), (*(_DWORD *)(a1 + 112) + 40), v17, *(_DWORD *)(a1 + 64), *(unsigned __int16 *)(a1 + 72), &v35);
  if (v36) {
    return v36;
  }
  uint64_t v21 = (**(uint64_t (***)(uint64_t))(v35 + 24))(v35 + 24 - *(void *)(*(void *)(v35 + 24) + 48));
  unsigned int v36 = (*(uint64_t (**)(uint64_t, unsigned int **, unint64_t *, int *, _DWORD *))(*(void *)(v35 + 32)
                                                                                                 + 16))(v35 + 32 - *(void *)(*(void *)(v35 + 32) + 48), &v33, &v34, a4, a5);
  if (v36) {
    return v36;
  }
  if (*a5)
  {
    unsigned int ParameterSection = (*(uint64_t (**)(uint64_t))(*(void *)v35 + 32))(v35);
    goto LABEL_29;
  }
  if (*a4 == 1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v35 + 32))(v35);
  }
  unint64_t v25 = v34;
  if (v34 < 4 || v34 == v21)
  {
    if (a3) {
      return err_GenerateErrorLimit();
    }
    goto LABEL_57;
  }
  unint64_t v26 = v33;
  uint64_t v27 = *v33;
  *(_DWORD *)(a1 + 68) = v27;
  if (v27 == -1 || v25 < 12 * v27 + 4)
  {
    if (!a3)
    {
      *a4 = 1;
      return (*(uint64_t (**)(uint64_t))(*(void *)v35 + 32))(v35);
    }
    int v23 = "Stream data not consistent";
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v23);
  }
  if (v27)
  {
    uint64_t v29 = OOCAllocator_Malloc(*(void *)(a1 + 120), 12 * v27, &v36);
    *(void *)(a1 + 104) = v29;
    if (v36) {
      return v36;
    }
    uint64_t v30 = *(unsigned int *)(a1 + 68);
    if (v30)
    {
      int v31 = v26 + 2;
      int v32 = (_DWORD *)(v29 + 8);
      do
      {
        *(v32 - 2) = *(v31 - 1);
        *(v32 - 1) = *v31;
        *int v32 = v31[1];
        v32 += 3;
        v31 += 3;
        --v30;
      }
      while (v30);
    }
  }
  else
  {
    *(void *)(a1 + 104) = 0;
  }
  unsigned int v36 = (*(uint64_t (**)(uint64_t))(*(void *)v35 + 32))(v35);
  if (v36) {
    return v36;
  }
  *(_DWORD *)(a1 + 128) = 0;
  if (ParamDB_GetParam(*(void *)(a1 + 136), 987249153) != 2)
  {
    unsigned int ParameterSection = __BinBlockStreamReader_ReadParameterSection((void *)a1);
LABEL_29:
    unsigned int v36 = ParameterSection;
    if (ParameterSection) {
      return v36;
    }
  }
LABEL_45:
  if (v20)
  {
    int v24 = 2;
LABEL_58:
    *a4 = v24;
  }
  return v36;
}

uint64_t BinBlockStreamReader_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120);
  uint64_t result = OOC_PlacementDeleteObject(v2, *(void *)(a1 + 136));
  if (result) {
    return result;
  }
  uint64_t v4 = *(void *)(a1 + 104);
  if (v4) {
    OOCAllocator_Free(v2, v4);
  }
  uint64_t v5 = *(void *)(a1 + 80);
  if (v5)
  {
    if (!*(_DWORD *)(a1 + 112) && *(_DWORD *)(a1 + 144))
    {
      if ((*(unsigned int (**)(void))(v5 + 24))(*(void *)(a1 + 88)))
      {
        return err_GenerateErrorCallback();
      }
      uint64_t v5 = *(void *)(a1 + 80);
    }
    OOCAllocator_Free(v2, v5);
  }
  uint64_t v6 = *(void *)(a1 + 96);
  if (v6) {
    OOCAllocator_Free(v2, v6);
  }
  uint64_t result = RefCounted_Des(a1);
  if (!result)
  {
    int v7 = *(char **)(a1 + 160);
    if (v7)
    {
      unsigned int v8 = **(uint64_t (***)(int64_t))v7;
      int64_t v9 = (int64_t)&v7[-*(void *)(*(void *)v7 + 8)];
      return v8(v9);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_BorrowIStream(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

uint64_t BinBlockStreamReader_BorrowIStreamInst(uint64_t a1)
{
  return *(void *)(a1 + 88);
}

uint64_t BinBlockStreamReader_BorrowIStreamParams(uint64_t a1)
{
  return *(void *)(a1 + 96);
}

uint64_t BinBlockStreamReader_CheckCRC(uint64_t a1, _DWORD *a2)
{
  *a2 = 0;
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 40) + 200))(a1 + 40 - *(void *)(*(void *)(a1 + 40)
                                                                                                 + 208));
}

uint64_t BinBlockStreamReader_CheckCRCInterruptible(uint64_t a1, int *a2, _DWORD *a3)
{
  uint64_t v25 = *(unsigned int *)(a1 + 112);
  *a3 = 0;
  if (*(_DWORD *)(a1 + 152))
  {
    uint64_t result = 0;
    *a2 = 2;
  }
  else
  {
    uint64_t v28 = 0;
    long long v26 = 0u;
    long long v27 = 0u;
    int v24 = 1;
    uint64_t v7 = *(void *)(a1 + 80);
    uint64_t v8 = *(void *)(a1 + 88);
    uint64_t v9 = *(void *)(a1 + 120);
    uint64_t result = PtrStack_Con((uint64_t)&v26, v9, 1);
    unsigned int v29 = result;
    if (!result)
    {
      if ((*(unsigned int (**)(uint64_t, void, void))(v7 + 8))(v8, *(unsigned int *)(a1 + 112), 0))
      {
        return err_GenerateErrorCallback();
      }
      else
      {
        int v10 = 0;
        do
        {
          if (v10)
          {
            uint64_t result = (*(uint64_t (**)(void))(**(void **)v10 + 32))(*(void *)v10);
            unsigned int v29 = result;
            if (!result)
            {
              OOCAllocator_Free(v9, (uint64_t)v10);
              int v10 = *(_DWORD **)(v28 + 8 * (DWORD2(v27) - 1));
              uint64_t result = PtrStack_Remove((uint64_t)&v26);
              unsigned int v29 = result;
              if (!result)
              {
                unsigned int v11 = v10[2];
                goto LABEL_17;
              }
            }
            return result;
          }
          int v10 = (_DWORD *)OOCAllocator_Malloc(v9, 16, &v29);
          uint64_t result = v29;
          if (!v29)
          {
            uint64_t result = _BinBlockStreamReader_CreateForInterruptibleStreamInternal(v9, (_OWORD *)v7, v8, &v24, v25, 1, 0, 0, 0, v10, a2, a3);
            unsigned int v29 = result;
            if (!result) {
              goto LABEL_15;
            }
          }
          return result;
LABEL_15:
          if ((*a2 - 1) < 2 || *a3 == 1) {
            break;
          }
          unsigned int v11 = 0;
          char v10[2] = 0;
LABEL_17:
          while (v11 < (*(unsigned int (**)(uint64_t))(*(void *)(*(void *)v10 + 32) + 96))(*(void *)v10 + 32 - *(void *)(*(void *)(*(void *)v10 + 32) + 224)))
          {
            uint64_t v23 = 0;
            int v22 = 0;
            uint64_t result = __BinBlockStreamReader_SeekSectionByTocIndex_CheckCRC(*(void *)v10, v10[2], &v23, &v22, &v25, a2, a3);
            unsigned int v29 = result;
            if (result) {
              return result;
            }
            if (*a2 == 1 || *a3 == 1) {
              goto LABEL_40;
            }
            if (v22 == -1)
            {
              ++v10[2];
              uint64_t result = PtrStack_Put((uint64_t)&v26, (uint64_t)v10);
              unsigned int v29 = result;
              if (result) {
                return result;
              }
              int v10 = 0;
              break;
            }
            long long v20 = 0u;
            memset(v21, 0, sizeof(v21));
            long long v19 = 0u;
            uint64_t v17 = 0;
            uint64_t v18 = 0;
            int Param = ParamDB_GetParam(*(void *)(*(void *)v10 + 136), 987249153);
            int v13 = *(_DWORD *)(*(void *)v10 + 64);
            unsigned int v14 = *(unsigned __int16 *)(*(void *)v10 + 72);
            if (Param == 2) {
              uint64_t result = DataSectionReader_ConForInterruptibleStream(&v19, v9, v7, v8, v25, v23, v13, v14);
            }
            else {
              uint64_t result = DataSectionReader_Con(&v19, v9, v7, v8, v25, v23, v13, v14);
            }
            unsigned int v29 = result;
            if (result) {
              return result;
            }
            uint64_t v15 = (**((uint64_t (***)(char *))&v20 + 1))((char *)&v20
                                                                 - *(void *)(*((void *)&v20 + 1) + 48) + 8);
            uint64_t v18 = v15;
            while (v18 == v15 && !*a2 && !*a3)
            {
              uint64_t result = (*(uint64_t (**)(char *, uint64_t *, uint64_t *, int *, _DWORD *))(*(void *)&v21[0]
                                                                                                + 16))((char *)v21 - *(void *)(*(void *)&v21[0] + 48), &v17, &v18, a2, a3);
              unsigned int v29 = result;
              if (result) {
                return result;
              }
            }
            uint64_t result = (*(uint64_t (**)(long long *))(v19 + 32))(&v19);
            unsigned int v29 = result;
            if (result) {
              return result;
            }
            if (*a2 == 1 || *a3 == 1) {
              goto LABEL_39;
            }
            unsigned int v11 = v10[2] + 1;
            char v10[2] = v11;
          }
        }
        while (DWORD2(v27));
LABEL_39:
        if (!v10) {
          goto LABEL_42;
        }
LABEL_40:
        for (uint64_t result = PtrStack_Put((uint64_t)&v26, (uint64_t)v10); ; uint64_t result = PtrStack_Remove((uint64_t)&v26))
        {
          unsigned int v29 = result;
          if (result) {
            break;
          }
LABEL_42:
          if (!DWORD2(v27)) {
            return (*(uint64_t (**)(long long *))(v26 + 16))(&v26);
          }
          int v16 = *(void **)(v28 + 8 * (DWORD2(v27) - 1));
          if (*v16)
          {
            uint64_t result = (*(uint64_t (**)(void))(*(void *)*v16 + 32))(*v16);
            unsigned int v29 = result;
            if (result) {
              return result;
            }
          }
          OOCAllocator_Free(v9, (uint64_t)v16);
        }
      }
    }
  }
  return result;
}

uint64_t _BinBlockStreamReader_CreateForInterruptibleStreamInternal(uint64_t a1, _OWORD *a2, uint64_t a3, _DWORD *a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, int *a11, _DWORD *a12)
{
  uint64_t v17 = 0;
  uint64_t result = _PNEW_BinBlockStreamReader_ConInternal(a1, a1, a2, a3, a4, a8, a9, (uint64_t *)&v17);
  if (!result)
  {
    int v16 = v17;
    *a10 = v17;
    v16[28] = a5;
    uint64_t result = _BinBlockStreamReader_InitInternal((uint64_t)v16, a6, a7, a11, a12);
    if (!result)
    {
      if (*a12)
      {
        uint64_t result = (*(uint64_t (**)(_DWORD *))(*(void *)v16 + 32))(v16);
        if (!result) {
          *a10 = 0;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t __BinBlockStreamReader_SeekSectionByTocIndex_CheckCRC(uint64_t a1, unsigned int a2, void *a3, _DWORD *a4, void *a5, _DWORD *a6, _DWORD *a7)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  *a3 = *(unsigned int *)(*(void *)(a1 + 104) + 12 * a2 + 4);
  *a6 = 0;
  *a7 = 0;
  if ((*(unsigned int (**)(void, void, void))(*(void *)(a1 + 80) + 8))(*(void *)(a1 + 88), (*(_DWORD *)(a1 + 112) + *(_DWORD *)(*(void *)(a1 + 104) + 12 * a2 + 8)), 0))
  {
    return err_GenerateErrorCallback();
  }
  else if ((**(uint64_t (***)(_DWORD *, uint64_t, uint64_t, void))(a1 + 80))(v18, 1, 12, *(void *)(a1 + 88)) == 12)
  {
    unsigned int v16 = v18[0];
    uint64_t v15 = v18[1];
    *a4 = v18[2];
    uint64_t v17 = *(void *)(a1 + 104);
    uint64_t result = 0;
    if (*(void *)(v17 + 12 * a2) == __PAIR64__(v15, v16))
    {
      *a5 = (*(_DWORD *)(a1 + 112) + *(_DWORD *)(v17 + 12 * a2 + 8) + 12);
      *a3 = v15;
    }
    else
    {
      *a6 = 1;
    }
  }
  else if ((*(unsigned int (**)(void))(*(void *)(a1 + 80) + 16))(*(void *)(a1 + 88)))
  {
    return err_GenerateErrorCallback();
  }
  else if (ParamDB_GetParam(*(void *)(a1 + 136), 987249153) == 2)
  {
    uint64_t result = 0;
    *a7 = 1;
  }
  else
  {
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
  }
  return result;
}

uint64_t BinBlockStreamReader_CheckDependency(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(void *)(a1 + 40) + 56))(a1 + 40 - *(void *)(*(void *)(a1 + 40) + 208), a2, a3, &v5);
  if (result) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = v5 == 0;
  }
  if (!v4) {
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
  }
  return result;
}

uint64_t BinBlockStreamReader_CheckDependencyInterruptible(uint64_t a1, int a2, const char *a3, _DWORD *a4)
{
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)(a1 + 32) + 32))(a1 + 32 - *(void *)(*(void *)(a1 + 32) + 224), 270065117) == 1)
  {
    __s = 0;
    uint64_t v14 = 0;
    uint64_t v12 = 0;
    int v11 = 0;
    uint64_t v9 = *(void *)(a1 + 40);
    uint64_t v8 = a1 + 40;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t *, int *, _DWORD *))(v9 + 8))(v8 - *(void *)(v9 + 208), 270065117, 0, &v14, &v11, a4);
    if (!result)
    {
      if (*a4)
      {
        return 0;
      }
      else
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, char **, uint64_t *, _DWORD *))(*(void *)v14 + 8))(v14 - *(void *)(*(void *)v14 + 48), &__s, &v12, a4);
        if (!result)
        {
          if (*a4) {
            return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v8 + 32))(v8 - *(void *)(*(void *)v8 + 208), v14);
          }
          uint64_t result = _BinBlockStreamReader_CheckDependency(__s, v12, a2, a3);
          if (!result) {
            return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v8 + 32))(v8 - *(void *)(*(void *)v8 + 208), v14);
          }
        }
      }
    }
  }
  else
  {
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Buffer not compatible (no dependency section)");
  }
  return result;
}

uint64_t _BinBlockStreamReader_CheckDependency(char *__s, int a2, int a3, const char *a4)
{
  uint64_t v6 = __s;
  uint64_t v7 = &__s[a2];
  uint64_t v8 = "Buffer not compatible (dependency not found)";
  while (v6 < v7)
  {
    uint64_t v9 = v6 + 4;
    int v10 = *(_DWORD *)v6;
    v6 += (strlen(v6 + 4) + 8) & 0xFFFFFFFC;
    if (v10 == a3)
    {
      uint64_t result = strcmp(a4, v9);
      if (!result) {
        return result;
      }
      uint64_t v8 = "Buffer not compatible (dependency do not match)";
      break;
    }
  }
  return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v8);
}

uint64_t BinBlockStreamReader_CheckVersion(uint64_t a1, unsigned int a2)
{
  int v3 = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 32) + 64))(a1 + 32 - *(void *)(*(void *)(a1 + 32)
                                                                                              + 224));
  if (!((v3 ^ a2) >> 16) && BYTE1(v3) <= BYTE1(a2)) {
    return 0;
  }
  return err_GenerateErrorVersion();
}

BOOL BinBlockStreamReader_IsVersionAccepted(unsigned int a1, int a2)
{
  return !((a2 ^ a1) >> 16) && BYTE1(a1) <= BYTE1(a2);
}

uint64_t BinBlockStreamReader_FetchBinBlockStreamReader(uint64_t a1, int a2, int a3, void *a4)
{
  int v13 = 0;
  uint64_t v11 = 0;
  uint64_t v6 = *(void *)(a1 + 120);
  uint64_t v9 = 0;
  uint64_t result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v12, &v13, &v11, &v9);
  if (!result)
  {
    if (v9 == 1)
    {
      uint64_t v8 = "Not enough data in stream";
    }
    else
    {
      if (v13 == -1)
      {
        uint64_t v10 = 0;
        (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
        uint64_t result = _BinBlockStreamReader_CreateForInterruptibleStreamInternal(v6, *(_OWORD **)(a1 + 80), *(void *)(a1 + 88), *(_DWORD **)(a1 + 96), v11, 0, 1, 1, a1 + 24, &v10, (int *)&v9 + 1, &v9);
        if (result) {
          return result;
        }
        if (v9 == 1)
        {
          uint64_t v8 = "Not enough data in stream";
        }
        else
        {
          if (HIDWORD(v9) != 1)
          {
            uint64_t result = 0;
            *a4 = v10 + 32;
            *(_DWORD *)(a1 + 128) = 1;
            return result;
          }
          uint64_t v8 = "Checksum error in data header";
        }
        return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v8);
      }
      uint64_t v8 = "Stream format not supported";
    }
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v8);
  }
  return result;
}

uint64_t __BinBlockStreamReader_SeekSection(uint64_t a1, int a2, int a3, void *a4, _DWORD *a5, void *a6, _DWORD *a7)
{
  uint64_t v7 = *(unsigned int *)(a1 + 68);
  if (!v7)
  {
    int v14 = 0;
    LODWORD(v9) = 0;
    goto LABEL_9;
  }
  uint64_t v9 = 0;
  int v10 = 0;
  uint64_t v11 = *(int **)(a1 + 104);
  uint64_t v12 = "Data not found in the stream";
  while (1)
  {
    int v13 = *v11;
    v11 += 3;
    if (v13 == a2) {
      break;
    }
LABEL_6:
    if (v7 == ++v9) {
      goto LABEL_11;
    }
  }
  if (v10 != a3)
  {
    ++v10;
    goto LABEL_6;
  }
  int v16 = 0;
  uint64_t result = __BinBlockStreamReader_SeekSectionByTocIndex_CheckCRC(a1, v9, a4, a5, a6, &v16, a7);
  if (result) {
    return result;
  }
  if (v16 == 1)
  {
    uint64_t v12 = "CRC checking failed";
LABEL_11:
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v12);
  }
  int v14 = *(_DWORD *)(a1 + 68);
LABEL_9:
  if (v9 == v14)
  {
    uint64_t v12 = "Data not found in the stream";
    goto LABEL_11;
  }
  return 0;
}

uint64_t BinBlockStreamReader_FetchBinBlockStreamReaderInterruptible(uint64_t a1, int a2, int a3, void *a4, _DWORD *a5)
{
  int v15 = 0;
  uint64_t v13 = 0;
  uint64_t v8 = *(void *)(a1 + 120);
  uint64_t result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v14, &v15, &v13, a5);
  if (!result)
  {
    if (*a5) {
      return 0;
    }
    uint64_t v12 = 0;
    int v11 = 0;
    if (v15 != -1)
    {
      int v10 = "Stream format not supported";
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v10);
    }
    (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
    uint64_t result = _BinBlockStreamReader_CreateForInterruptibleStreamInternal(v8, *(_OWORD **)(a1 + 80), *(void *)(a1 + 88), *(_DWORD **)(a1 + 96), v13, 1, 1, 1, a1 + 24, &v12, &v11, a5);
    if (!result)
    {
      if (!*a5)
      {
        *a4 = v12 + 40;
        *(_DWORD *)(a1 + 128) = 1;
        if (v11 != 1) {
          return 0;
        }
        int v10 = "Checksum error in data header";
        return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v10);
      }
      uint64_t result = 0;
      *a4 = 0;
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchDependency(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(void *)(a1 + 40) + 152))(a1 + 40 - *(void *)(*(void *)(a1 + 40) + 208), a2, a3, &v5);
  if (result) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = v5 == 0;
  }
  if (!v4) {
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchDependencyInterruptible(void *a1, int a2, void *a3, _DWORD *a4)
{
  *a3 = 0;
  *a4 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a1[4] + 32))((uint64_t)a1 - *(void *)(a1[4] + 224) + 32, 270065117);
  if (result)
  {
    if (result == 1)
    {
      __s = 0;
      uint64_t v18 = 0;
      uint64_t v16 = 0;
      int v15 = 0;
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t *, int *, _DWORD *))(a1[5] + 8))((uint64_t)a1 - *(void *)(a1[5] + 208) + 40, 270065117, 0, &v18, &v15, a4);
      if (!result)
      {
        if (*a4)
        {
          return 0;
        }
        else
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, char **, uint64_t *, _DWORD *))(*(void *)v18 + 8))(v18 - *(void *)(*(void *)v18 + 48), &__s, &v16, a4);
          unsigned int v19 = result;
          if (!result)
          {
            if (!*a4)
            {
              uint64_t v9 = __s;
              while (v9 < &__s[v16])
              {
                int v10 = v9 + 4;
                int v11 = *(_DWORD *)v9;
                size_t v12 = strlen(v9 + 4);
                v9 += (v12 + 8) & 0xFFFFFFFC;
                if (v11 == a2)
                {
                  size_t v13 = v12 + 1;
                  uint64_t v14 = (void *)OOCAllocator_Malloc(a1[15], v12 + 1, &v19);
                  *a3 = v14;
                  uint64_t result = v19;
                  if (v19) {
                    return result;
                  }
                  memcpy(v14, v10, v13);
                  return (*(uint64_t (**)(uint64_t, uint64_t))(a1[5] + 32))((uint64_t)a1 - *(void *)(a1[5] + 208) + 40, v18);
                }
              }
            }
            return (*(uint64_t (**)(uint64_t, uint64_t))(a1[5] + 32))((uint64_t)a1 - *(void *)(a1[5] + 208) + 40, v18);
          }
        }
      }
    }
    else
    {
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Buffer not compatible (no dependency section)");
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchDependencyTypes(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(void *)(a1 + 40) + 184))(a1 + 40 - *(void *)(*(void *)(a1 + 40) + 208), a2, a3, &v5);
  if (result) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = v5 == 0;
  }
  if (!v4) {
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchDependencyTypesInterruptible(void *a1, uint64_t *a2, uint64_t *a3, _DWORD *a4)
{
  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(a1[4] + 32))((uint64_t)a1 - *(void *)(a1[4] + 224) + 32, 270065117);
  if (result)
  {
    if (result == 1)
    {
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      uint64_t v22 = 0;
      int v21 = 0;
      uint64_t v9 = (char *)(a1 + 5);
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t *, int *, _DWORD *))(a1[5] + 8))((uint64_t)a1 - *(void *)(a1[5] + 208) + 40, 270065117, 0, &v24, &v21, a4);
      if (!result)
      {
        if (*a4) {
          return 0;
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, const char **, uint64_t *, _DWORD *))(*(void *)v24 + 8))(v24 - *(void *)(*(void *)v24 + 48), &v23, &v22, a4);
        unsigned int v25 = result;
        if (!result)
        {
          if (*a4) {
            return (*(uint64_t (**)(char *, uint64_t))(*(void *)v9 + 32))(&v9[-*(void *)(*(void *)v9 + 208)], v24);
          }
          uint64_t v10 = *a3;
          if (v22 >= 5)
          {
            int v11 = v23;
            unint64_t v12 = (unint64_t)&v23[v22];
            size_t v13 = v23 + 4;
            do
            {
              int v14 = strlen(v13);
              *a3 = ++v10;
              v11 += (v14 + 8) & 0xFFFFFFFC;
              size_t v13 = v11 + 4;
            }
            while ((unint64_t)(v11 + 4) < v12);
          }
          uint64_t v15 = OOCAllocator_Malloc(a1[15], 8 * v10, &v25);
          *a2 = v15;
          uint64_t result = v25;
          if (!v25)
          {
            if (*a3)
            {
              uint64_t v16 = 0;
              unsigned int v17 = 1;
              uint64_t v18 = v23;
              do
              {
                int v19 = strlen(v18 + 4);
                *(void *)(v15 + 8 * v16) = *(unsigned int *)v18;
                v18 += (v19 + 8) & 0xFFFFFFFC;
                uint64_t v16 = v17;
              }
              while (*a3 > (unint64_t)v17++);
            }
            return (*(uint64_t (**)(char *, uint64_t))(*(void *)v9 + 32))(&v9[-*(void *)(*(void *)v9 + 208)], v24);
          }
        }
      }
    }
    else
    {
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Buffer not compatible (no dependency section)");
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchRawSectionDataStreamReaderInterruptible(uint64_t a1, int a2, int a3, void *a4, _DWORD *a5, _DWORD *a6)
{
  return _BinBlockStreamReader_FetchSectionDataStreamReaderInterruptibleExt(a1, a2, a3, 1, a4, a5, a6);
}

uint64_t _BinBlockStreamReader_FetchSectionDataStreamReaderInterruptibleExt(uint64_t a1, int a2, int a3, int a4, void *a5, _DWORD *a6, _DWORD *a7)
{
  int v21 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v18 = 0;
  uint64_t v12 = *(void *)(a1 + 120);
  if (a4) {
    BOOL v13 = 0;
  }
  else {
    BOOL v13 = *(_DWORD *)(a1 + 64) == 1;
  }
  int v14 = v13;
  uint64_t result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v20, &v21, &v19, a7);
  if (!result)
  {
    if (*a7)
    {
      return 0;
    }
    else
    {
      int v16 = v21;
      if (a4 || v21 != -1)
      {
        if (a4 == 1) {
          unsigned int v17 = 0;
        }
        else {
          unsigned int v17 = *(unsigned __int16 *)(a1 + 72);
        }
        uint64_t result = PNEW_DataSectionReader_ConForInterruptibleStream(v12, v12, *(void *)(a1 + 80), *(void *)(a1 + 88), v19, v20, v14, v17, &v18);
        if (!result)
        {
          *a5 = v18 + 32;
          *a6 = v16;
          *(_DWORD *)(a1 + 128) = 1;
        }
      }
      else
      {
        return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Stream format not supported");
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchSectionDataStreamReader(uint64_t a1, int a2, int a3, void *a4, _DWORD *a5)
{
  int v16 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v13 = 0;
  uint64_t v8 = *(void *)(a1 + 120);
  int v12 = 0;
  uint64_t result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v15, &v16, &v14, &v12);
  if (result) {
    return result;
  }
  if (v12 == 1)
  {
    uint64_t v10 = "Not enough data in stream";
LABEL_9:
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v10);
  }
  int v11 = v16;
  if (v16 == -1)
  {
    uint64_t v10 = "Stream format not supported";
    goto LABEL_9;
  }
  uint64_t result = PNEW_DataSectionReader_Con(v8, v8, *(void *)(a1 + 80), *(void *)(a1 + 88), v14, v15, *(_DWORD *)(a1 + 64), *(unsigned __int16 *)(a1 + 72), &v13);
  if (!result)
  {
    *a4 = v13 + 24;
    *a5 = v11;
    *(_DWORD *)(a1 + 128) = 1;
  }
  return result;
}

uint64_t BinBlockStreamReader_FetchSectionDataStreamReaderInterruptible(uint64_t a1, int a2, int a3, void *a4, _DWORD *a5, _DWORD *a6)
{
  return _BinBlockStreamReader_FetchSectionDataStreamReaderInterruptibleExt(a1, a2, a3, 0, a4, a5, a6);
}

uint64_t BinBlockStreamReader_GetAlignment(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 60);
}

uint64_t BinBlockStreamReader_GetCRCBlockSize(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 72);
}

uint64_t BinBlockStreamReader_GetCRCBlockSizeInterruptible(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 72);
}

uint64_t BinBlockStreamReader_GetNrSectionInstances(uint64_t result, int a2)
{
  uint64_t v2 = *(unsigned int *)(result + 68);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = result;
  LODWORD(result) = 0;
  BOOL v4 = *(int **)(v3 + 104);
  do
  {
    int v5 = *v4;
    v4 += 3;
    if (v5 == a2) {
      uint64_t result = (result + 1);
    }
    else {
      uint64_t result = result;
    }
    --v2;
  }
  while (v2);
  return result;
}

uint64_t BinBlockStreamReader_GetNrSections(uint64_t a1)
{
  return *(unsigned int *)(a1 + 68);
}

uint64_t BinBlockStreamReader_GetSectionDataIfAvailable(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v9 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int *))(*(void *)(a1 + 40) + 64))(a1 + 40 - *(void *)(*(void *)(a1 + 40) + 208), a2, a3, a4, a5, a6, a7, &v9);
  if (result) {
    BOOL v8 = 1;
  }
  else {
    BOOL v8 = v9 == 0;
  }
  if (!v8) {
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
  }
  return result;
}

uint64_t BinBlockStreamReader_GetSectionDataIfAvailableInterruptible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t *a6, uint64_t *a7, _DWORD *a8)
{
  *a8 = 0;
  *a6 = 0;
  *a7 = 0;
  unsigned int v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 + 32) + 32))(a1 + 32 - *(void *)(*(void *)(a1 + 32) + 224), a3);
  uint64_t result = 0;
  if (v16 > a4)
  {
    uint64_t v23 = 0;
    int v22 = 0;
    uint64_t v19 = *(void *)(a1 + 40);
    uint64_t v18 = a1 + 40;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *, int *, _DWORD *))(v19 + 8))(v18 - *(void *)(v19 + 208), a3, a4, &v23, &v22, a8);
    unsigned int v24 = result;
    if (!result)
    {
      if (*a8) {
        return 0;
      }
      if ((v22 ^ a5) >> 16 || BYTE1(v22) > BYTE1(a5)) {
        return err_GenerateErrorVersion();
      }
      uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)v23 + 24))(v23 - *(void *)(*(void *)v23 + 48));
      if (!v20)
      {
        uint64_t v21 = 0;
LABEL_14:
        if (*a8)
        {
          OOCAllocator_Free(a2, v21);
          return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v18 + 32))(v18 - *(void *)(*(void *)v18 + 208), v23);
        }
        else
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v18 + 32))(v18 - *(void *)(*(void *)v18 + 208), v23);
          if (!result)
          {
            *a6 = v21;
            *a7 = v20;
          }
        }
        return result;
      }
      uint64_t v21 = OOCAllocator_Malloc(a2, v20, &v24);
      uint64_t result = v24;
      if (!v24)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, _DWORD *))(*(void *)v23 + 32))(v23 - *(void *)(*(void *)v23 + 48), v21, a8);
        unsigned int v24 = result;
        if (!result) {
          goto LABEL_14;
        }
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_GetSectionDataRandomReader(uint64_t a1, int a2, int a3, void *a4, _DWORD *a5)
{
  int v16 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v13 = 0;
  uint64_t v8 = *(void *)(a1 + 120);
  int v12 = 0;
  uint64_t result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v15, &v16, &v14, &v12);
  if (result) {
    return result;
  }
  if (v12 == 1)
  {
    uint64_t v10 = "Not enough data in stream";
LABEL_9:
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v10);
  }
  int v11 = v16;
  if (v16 == -1)
  {
    uint64_t v10 = "Stream format not supported";
    goto LABEL_9;
  }
  uint64_t result = PNEW_DataSectionRandomReader_Con(v8, v8, *(void *)(a1 + 80), *(void *)(a1 + 88), a1 + 24, v14, v15, *(unsigned __int16 *)(a1 + 72), &v13);
  if (!result)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
    uint64_t result = 0;
    *a4 = v13 + 24;
    *a5 = v11;
  }
  return result;
}

uint64_t BinBlockStreamReader_GetSectionDataRandomReaderInterruptible(uint64_t a1, int a2, int a3, void *a4, _DWORD *a5, _DWORD *a6)
{
  int v22 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v19 = 0;
  uint64_t v10 = *(void *)(a1 + 120);
  uint64_t result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v21, &v22, &v20, a6);
  if (!result)
  {
    if (*a6 == 1)
    {
      return 0;
    }
    else
    {
      int v12 = v22;
      if (v22 == -1)
      {
        return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Stream format not supported");
      }
      else
      {
        uint64_t v13 = *(void *)(a1 + 88);
        uint64_t v18 = *(void *)(a1 + 80);
        uint64_t v14 = v20;
        unsigned int v15 = v21;
        unsigned int v16 = *(unsigned __int16 *)(a1 + 72);
        int Param = ParamDB_GetParam(*(void *)(a1 + 136), 987249153);
        uint64_t result = PNEW_DataSectionRandomReader_ConForInterruptible(v10, v10, v18, v13, a1 + 24, v14, v15, v16, Param == 2, &v19);
        if (!result)
        {
          (*(void (**)(uint64_t))(*(void *)a1 + 24))(a1);
          uint64_t result = 0;
          *a4 = v19 + 32;
          *a5 = v12;
        }
      }
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_GetSectionID(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  *a3 = 0;
  uint64_t v3 = *(void *)(a1 + 104);
  uint64_t result = *(unsigned int *)(v3 + 12 * a2);
  if (a2)
  {
    int v5 = 0;
    unsigned int v6 = a2 - 1;
    do
    {
      uint64_t v7 = v6;
      if (*(_DWORD *)(v3 + 12 * v6) == result) {
        *a3 = ++v5;
      }
      --v6;
    }
    while (v7);
  }
  return result;
}

uint64_t BinBlockStreamReader_GetSectionVersion(uint64_t a1, int a2, int a3, _DWORD *a4)
{
  int v9 = 0;
  int v6 = 0;
  uint64_t result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v8, &v9, &v7, &v6);
  if (!result && v6 != 1)
  {
    if (v9 == -1)
    {
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Stream format not supported");
    }
    else
    {
      uint64_t result = 0;
      *a4 = v9;
    }
  }
  return result;
}

uint64_t BinBlockStreamReader_GetSize(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

uint64_t BinBlockStreamReader_GetType(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t BinBlockStreamReader_GetVersion(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

uint64_t BinBlockStreamReader_IsDataSection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v6 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, int *))(*(void *)(a1 + 40) + 176))(a1 + 40 - *(void *)(*(void *)(a1 + 40) + 208), a2, a3, a4, &v6);
  if (result) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v6 == 1;
  }
  if (v5) {
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
  }
  return result;
}

uint64_t BinBlockStreamReader_IsDataSectionInterruptible(uint64_t a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  int v9 = 0;
  uint64_t result = __BinBlockStreamReader_SeekSection(a1, a2, a3, &v8, &v9, &v7, a5);
  if (!result) {
    *a4 = v9 != -1;
  }
  return result;
}

BOOL BinBlockStreamReader_IsValidHeaderCRC(uint64_t a1)
{
  return *(_DWORD *)(a1 + 148) == 0;
}

uint64_t BinBlockStreamReader_NotifyFinished(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
}

uint64_t BinBlockStreamReader_ReturnBinBlockStreamReader(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) = 0;
  BOOL v5 = *(uint64_t (**)(uint64_t))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 144))(a2 - *(void *)(*(void *)a2 + 224))
                                         + 32);
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 144))(a2 - *(void *)(*(void *)a2 + 224));
  return v5(v3);
}

uint64_t BinBlockStreamReader_ReturnBinBlockStreamReaderInterruptible(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) = 0;
  BOOL v5 = *(uint64_t (**)(uint64_t))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 160))(a2 - *(void *)(*(void *)a2 + 208))
                                         + 32);
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 160))(a2 - *(void *)(*(void *)a2 + 208));
  return v5(v3);
}

uint64_t BinBlockStreamReader_ReturnDependency(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t BinBlockStreamReader_ReturnDependencyTypes(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 40) + 192))(a1 + 40 - *(void *)(*(void *)(a1 + 40)
                                                                                                 + 208));
}

uint64_t BinBlockStreamReader_ReturnDependencyTypesInterruptible(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t BinBlockStreamReader_ReturnRawSectionDataStreamReaderInterruptible(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 40) + 32))(a1 + 40 - *(void *)(*(void *)(a1 + 40)
                                                                                                + 208));
}

uint64_t BinBlockStreamReader_ReturnSectionDataStreamReader(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) = 0;
  BOOL v5 = *(uint64_t (**)(uint64_t))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2 - *(void *)(*(void *)a2 + 48))
                                         + 32);
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2 - *(void *)(*(void *)a2 + 48));
  return v5(v3);
}

uint64_t BinBlockStreamReader_ReturnSectionDataStreamReaderInterruptible(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 128) = 0;
  BOOL v5 = *(uint64_t (**)(uint64_t))(*(void *)(*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2 - *(void *)(*(void *)a2 + 48))
                                         + 32);
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2 - *(void *)(*(void *)a2 + 48));
  return v5(v3);
}

uint64_t _PNEW_BinBlockStreamReader_ConInternal(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, _DWORD *a5, int a6, uint64_t a7, uint64_t *a8)
{
  unsigned int v18 = 0;
  uint64_t v16 = OOCAllocator_Malloc(a1, 168, &v18);
  uint64_t result = v18;
  if (!v18)
  {
    uint64_t result = _BinBlockStreamReader_ConInternal(v16, a2, a3, a4, a5, a6, a7);
    unsigned int v18 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v16);
      *a8 = 0;
      return v18;
    }
    else
    {
      *(void *)(v16 + 16) = a1;
      *a8 = v16;
    }
  }
  return result;
}

BOOL __BinBlockStreamReader_IsValidInterruptibleStatus(unsigned int a1)
{
  return a1 < 3;
}

uint64_t __BinBlockStreamReader_ReadParameterSection(void *a1)
{
  unsigned int v2 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[4] + 32))((uint64_t)a1 - *(void *)(a1[4] + 224) + 32, 987184693);
  if (v2 < 2)
  {
    if (v2 != 1)
    {
      ParamDB_SetParam(a1[17], 987249153, 1);
      return 0;
    }
    uint64_t v9 = 0;
    int v8 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    int v5 = 0;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t *, int *, int *))(a1[5] + 8))((uint64_t)a1 - *(void *)(a1[5] + 208) + 40, 987184693, 0, &v9, &v8, &v5);
    if (result) {
      return result;
    }
    if (v5) {
      goto LABEL_8;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, unsigned __int16 **, uint64_t *, int *))(*(void *)v9 + 8))(v9 - *(void *)(*(void *)v9 + 48), &v7, &v6, &v5);
    if (result) {
      return result;
    }
    if (v5)
    {
LABEL_8:
      BOOL v4 = "Not enough data in stream";
    }
    else
    {
      uint64_t result = ParamDB_LoadBinaryBuffer(a1[17], v7);
      if (result) {
        return result;
      }
      if (ParamDB_GetParam(a1[17], 987249153)) {
        return (*(uint64_t (**)(uint64_t, uint64_t))(a1[5] + 32))((uint64_t)a1 - *(void *)(a1[5] + 208) + 40, v9);
      }
      BOOL v4 = "Stream interruptible status can not be UNKNOWN";
    }
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v4);
  }
  return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Buffer corrupted (more than one parameter section)");
}

uint64_t PNEW_BinBlockStreamReader_Con(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, _DWORD *a5, uint64_t *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 168, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = BinBlockStreamReader_Con(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *(void *)(v12 + 16) = a1;
      *a6 = v12;
    }
  }
  return result;
}

uint64_t DataSectionReader_Con(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, int a7, unsigned int a8)
{
  uint64_t v16 = RefCounted_Con((uint64_t)a1, 1);
  if (!v16)
  {
    *a1 = &__DataSectionReader;
    a1[3] = &unk_26C21A740;
    a1[4] = &unk_26C21A778;
    __DataSectionReader_ConInternal((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8, 0);
  }
  return v16;
}

uint64_t __DataSectionReader_ConInternal(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, int a7, unsigned int a8, int a9)
{
  uint64_t v9 = result;
  *(void *)(result + 96) = a3;
  *(void *)(result + 104) = a4;
  *(_DWORD *)(result + 40) = a7;
  BOOL v10 = (a8 & 1) != 0 && (__int16)a8 <= -1;
  int v11 = a8 & 0x7FFE;
  BOOL v12 = !v10 || v11 == 0;
  unsigned int v13 = v11 << 15;
  if (v12) {
    unsigned int v14 = a8;
  }
  else {
    unsigned int v14 = v13;
  }
  *(_DWORD *)(result + 72) = v14;
  if (v14 <= 0x4000) {
    uint64_t v15 = 0x4000;
  }
  else {
    uint64_t v15 = v14;
  }
  *(void *)(result + 48) = 0;
  *(void *)(result + 56) = v15;
  *(void *)(result + 64) = a5;
  unint64_t v16 = a6;
  *(void *)(result + 88) = a6;
  *(void *)(result + 128) = a2;
  *(_DWORD *)(result + 136) = a9;
  if (v14)
  {
    *(void *)(result + 80) = a6 - 4 * ((a6 + (unint64_t)v14 + 3) / (v14 + 4));
    uint64_t result = adler3200(0, 0, 0);
    *(_DWORD *)(v9 + 120) = result;
    unsigned int v14 = *(_DWORD *)(v9 + 72);
    unint64_t v16 = *(void *)(v9 + 80);
  }
  else
  {
    *(void *)(result + 80) = a6;
  }
  if (v16 < v14) {
    unsigned int v14 = v16;
  }
  *(_DWORD *)(v9 + 112) = v16;
  *(_DWORD *)(v9 + 116) = v14;
  return result;
}

uint64_t DataSectionReader_ConForInterruptibleStream(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, int a7, unsigned int a8)
{
  uint64_t v16 = RefCounted_Con((uint64_t)a1, 1);
  if (!v16)
  {
    *a1 = &__DataSectionReader;
    a1[3] = &unk_26C21A740;
    a1[4] = &unk_26C21A778;
    __DataSectionReader_ConInternal((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8, 1);
  }
  return v16;
}

uint64_t DataSectionReader_Des(uint64_t a1)
{
  OOCAllocator_Free(*(void *)(a1 + 128), *(void *)(a1 + 48));
  return RefCounted_Des(a1);
}

uint64_t DataSectionReader_BorrowDataBlock(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(void *)(a1 + 32) + 8))(a1 + 32 - *(void *)(*(void *)(a1 + 32) + 48), a2, a3, &v5);
  if (result) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = v5 == 0;
  }
  if (!v4) {
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
  }
  return result;
}

uint64_t DataSectionReader_BorrowDataBlockInterruptible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v6 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *, uint64_t))(*(void *)(a1 + 32) + 16))(a1 + 32 - *(void *)(*(void *)(a1 + 32) + 48), a2, a3, &v6, a4);
  if (result) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v6 == 1;
  }
  if (v5) {
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"CRC check failure");
  }
  return result;
}

uint64_t DataSectionReader_BorrowDataBlockWithCheck(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v6 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, int *))(*(void *)(a1 + 32) + 16))(a1 + 32 - *(void *)(*(void *)(a1 + 32) + 48), a2, a3, a4, &v6);
  if (result) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = v6 == 0;
  }
  if (!v5) {
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Not enough data in stream");
  }
  return result;
}

uint64_t DataSectionReader_BorrowDataBlockWithCheckInterruptible(uint64_t a1, void *a2, void *a3, _DWORD *a4, _DWORD *a5)
{
  unsigned int v13 = 0;
  BOOL v10 = *(unsigned __int8 **)(a1 + 48);
  if (v10
    || (BOOL v10 = (unsigned __int8 *)OOCAllocator_Malloc(*(void *)(a1 + 128), *(void *)(a1 + 56) + 4, &v13),
        *(void *)(a1 + 48) = v10,
        (uint64_t result = v13) == 0))
  {
    uint64_t v12 = 0;
    uint64_t result = __DataSectionReader_FillBufferWithCheck(a1, v10, *(void *)(a1 + 56), &v12, a4, a5);
    unsigned int v13 = result;
    if (!result)
    {
      if (*a5)
      {
        if (*(_DWORD *)(a1 + 136))
        {
          OOCAllocator_Free(*(void *)(a1 + 128), *(void *)(a1 + 48));
          *(void *)(a1 + 48) = 0;
          return v13;
        }
        else
        {
          uint64_t result = 0;
          *a4 = 0;
        }
      }
      else
      {
        uint64_t result = 0;
        *a2 = *(void *)(a1 + 48);
        *a3 = v12;
      }
    }
  }
  return result;
}

uint64_t __DataSectionReader_FillBufferWithCheck(uint64_t a1, unsigned __int8 *a2, unint64_t a3, uint64_t *a4, _DWORD *a5, _DWORD *a6)
{
  *a5 = 2 * (*(_DWORD *)(a1 + 72) == 0);
  *a6 = 0;
  *a4 = 0;
  unint64_t v6 = *(unsigned int *)(a1 + 112);
  if (!v6) {
    return 0;
  }
  if (v6 >= a3) {
    unint64_t v11 = a3;
  }
  else {
    unint64_t v11 = *(unsigned int *)(a1 + 112);
  }
  if (*(_DWORD *)(a1 + 72))
  {
    uint64_t v13 = 0;
    uint64_t ErrorCallback = 0;
    uint64_t v15 = a2;
    while (1)
    {
      if (!v11) {
        goto LABEL_49;
      }
      unint64_t v16 = v11 >= *(unsigned int *)(a1 + 116) ? *(unsigned int *)(a1 + 116) : v11;
      if (*(_DWORD *)(a1 + 72) && (v11 > v16 + 4 || *(unsigned __int8 **)(a1 + 48) == a2))
      {
        char v18 = 0;
        uint64_t v17 = 4;
      }
      else
      {
        uint64_t v17 = 0;
        char v18 = 1;
      }
      if ((**(uint64_t (***)(unsigned __int8 *, uint64_t, uint64_t, void))(a1 + 96))(v15, 1, v17 + v16, *(void *)(a1 + 104)) != v17 + v16)break; {
      if (*(_DWORD *)(a1 + 40))
      }
        *(_DWORD *)(a1 + 120) = adler3200(*(_DWORD *)(a1 + 120), v15, v16);
      int v19 = *(_DWORD *)(a1 + 116) - v16;
      *(_DWORD *)(a1 + 116) = v19;
      if (v19)
      {
        v13 += v16;
      }
      else
      {
        if (v18)
        {
          uint64_t v20 = v27;
          if ((**(uint64_t (***)(unsigned char *, uint64_t, uint64_t, void))(a1 + 96))(v27, 1, 4, *(void *)(a1 + 104)) != 4)
          {
            if ((*(unsigned int (**)(void))(*(void *)(a1 + 96) + 16))(*(void *)(a1 + 104)))
            {
              uint64_t ErrorCallback = err_GenerateErrorCallback();
              goto LABEL_34;
            }
            *a6 = 1;
            int v22 = 3;
LABEL_36:
            if (v22 != 3) {
              return ErrorCallback;
            }
            goto LABEL_49;
          }
        }
        else
        {
          uint64_t v20 = &v15[v16];
        }
        if (*(_DWORD *)(a1 + 40))
        {
          if (*(_DWORD *)v20 != *(_DWORD *)(a1 + 120))
          {
            *a5 = 1;
LABEL_34:
            int v22 = 4;
            goto LABEL_36;
          }
          *(_DWORD *)(a1 + 120) = adler3200(0, 0, 0);
        }
        unint64_t v21 = *(unsigned int *)(a1 + 72);
        v13 += v16;
        if ((unint64_t)*(unsigned int *)(a1 + 112) - v13 < v21) {
          LODWORD(v21) = *(_DWORD *)(a1 + 112) - v13;
        }
        *(_DWORD *)(a1 + 116) = v21;
      }
      v15 += v16;
      v11 -= v16;
    }
    if ((*(unsigned int (**)(void))(*(void *)(a1 + 96) + 16))(*(void *)(a1 + 104))) {
      return err_GenerateErrorCallback();
    }
    *a6 = 1;
LABEL_49:
    *(_DWORD *)(a1 + 112) -= v13;
    *a4 = v13;
    return ErrorCallback;
  }
  uint64_t v23 = (**(uint64_t (***)(unsigned __int8 *, uint64_t, unint64_t, void))(a1 + 96))(a2, 1, v11, *(void *)(a1 + 104));
  if (v23 == v11)
  {
LABEL_47:
    uint64_t ErrorCallback = 0;
    *(_DWORD *)(a1 + 112) -= v23;
    *a4 = v23;
    return ErrorCallback;
  }
  if (!(*(unsigned int (**)(void))(*(void *)(a1 + 96) + 16))(*(void *)(a1 + 104)))
  {
    *a6 = 1;
    goto LABEL_47;
  }
  return err_GenerateErrorCallback();
}

uint64_t DataSectionReader_FillData(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v4 = 0;
  uint64_t result = __DataSectionReader_FillBufferWithCheck(a1, a2, *(void *)(a1 + 80), &v5, (_DWORD *)&v4 + 1, &v4);
  if (!result)
  {
    if (HIDWORD(v4) == 1)
    {
      uint64_t v3 = "CRC error";
    }
    else
    {
      if (!v4) {
        return 0;
      }
      uint64_t v3 = "Not enough data in stream";
    }
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v3);
  }
  return result;
}

uint64_t DataSectionReader_FillDataInterruptible(uint64_t a1, unsigned __int8 *a2, _DWORD *a3)
{
  int v7 = 0;
  uint64_t result = __DataSectionReader_FillBufferWithCheck(a1, a2, *(void *)(a1 + 80), &v8, &v7, a3);
  if (!result)
  {
    if (v7 == 1)
    {
      unint64_t v6 = "CRC error";
    }
    else
    {
      if (!*a3 || *(_DWORD *)(a1 + 136)) {
        return 0;
      }
      unint64_t v6 = "Not enough data in stream";
    }
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v6);
  }
  return result;
}

uint64_t DataSectionReader_GetDataBlockSize(uint64_t a1)
{
  return *(void *)(a1 + 56);
}

uint64_t DataSectionReader_GetDataSize(uint64_t a1)
{
  return *(void *)(a1 + 80);
}

uint64_t PNEW_DataSectionReader_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, int a7, unsigned int a8, void *a9)
{
  unsigned int v19 = 0;
  uint64_t v17 = (void *)OOCAllocator_Malloc(a1, 144, &v19);
  uint64_t result = v19;
  if (!v19)
  {
    uint64_t result = DataSectionReader_Con(v17, a2, a3, a4, a5, a6, a7, a8);
    unsigned int v19 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v17);
      *a9 = 0;
      return v19;
    }
    else
    {
      v17[2] = a1;
      *a9 = v17;
    }
  }
  return result;
}

uint64_t PNEW_DataSectionReader_ConForInterruptibleStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, int a7, unsigned int a8, void *a9)
{
  unsigned int v19 = 0;
  uint64_t v17 = (void *)OOCAllocator_Malloc(a1, 144, &v19);
  uint64_t result = v19;
  if (!v19)
  {
    uint64_t result = DataSectionReader_ConForInterruptibleStream(v17, a2, a3, a4, a5, a6, a7, a8);
    unsigned int v19 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v17);
      *a9 = 0;
      return v19;
    }
    else
    {
      v17[2] = a1;
      *a9 = v17;
    }
  }
  return result;
}

uint64_t ParamDB_Con(void *a1, uint64_t a2)
{
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    *a1 = &__ParamDB;
    a1[1] = a2;
    return PNEW_PtrList_Con(a2, a2, 0xAu, 10, a1 + 2);
  }
  return result;
}

uint64_t ParamDB_Des(uint64_t a1)
{
  if (kaldi::MatrixBase<float>::Stride(*(void *)(a1 + 16)))
  {
    unsigned int v2 = 0;
    do
    {
      uint64_t v3 = *(void *)(a1 + 8);
      uint64_t v4 = PtrList_ItemN(*(void *)(a1 + 16), v2);
      OOCAllocator_Free(v3, v4);
      ++v2;
    }
    while (v2 < kaldi::MatrixBase<float>::Stride(*(void *)(a1 + 16)));
  }
  uint64_t result = OOC_PlacementDeleteObject(*(void *)(a1 + 8), *(void *)(a1 + 16));
  if (!result)
  {
    return Object_Des();
  }
  return result;
}

uint64_t __ParamDB_AddParam(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, _DWORD *a6, int a7)
{
  unsigned int v16 = 0;
  int v17 = a2;
  PtrList_Find(*(void *)(a1 + 16), (uint64_t)&v17, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
  uint64_t v13 = OOCAllocator_Malloc(*(void *)(a1 + 8), 48, &v16);
  uint64_t result = v16;
  if (!v16)
  {
    int v15 = v17;
    *(void *)(v13 + 16) = a6;
    *(_DWORD *)uint64_t v13 = v15;
    *(_DWORD *)(v13 + 4) = a3;
    if (a6) {
      *a6 = a3;
    }
    else {
      *(_DWORD *)(v13 + 8) = a3;
    }
    *(void *)(v13 + 24) = a4;
    *(void *)(v13 + 40) = a5;
    *(_DWORD *)(v13 + 32) = a7;
    *(_DWORD *)(v13 + 36) = 0;
    return PtrList_Append(*(void *)(a1 + 16), v13);
  }
  return result;
}

uint64_t ParamDB_AddPublicParam(uint64_t a1, int a2, int a3, uint64_t a4)
{
  return __ParamDB_AddParam(a1, a2, a3, a4, 0, 0, 1);
}

BOOL CompareItem(_DWORD **a1, _DWORD **a2)
{
  return **a1 != **a2;
}

uint64_t ParamDB_GetParam(uint64_t a1, int a2)
{
  int v5 = a2;
  uint64_t v2 = PtrList_Find(*(void *)(a1 + 16), (uint64_t)&v5, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
  uint64_t v3 = *(unsigned int **)(v2 + 16);
  if (!v3) {
    uint64_t v3 = (unsigned int *)(v2 + 8);
  }
  return *v3;
}

uint64_t __ParamDB_LoadParams(uint64_t a1, unsigned __int16 *a2, int a3)
{
  int v26 = 0;
  uint64_t v5 = *a2;
  unsigned int v6 = a2[1];
  int v7 = a2 + 2;
  if (a2[1])
  {
    unsigned int v8 = 0;
    uint64_t v9 = &v7[4 * v5];
    do
    {
      uint64_t v10 = *((unsigned int *)v9 + 1);
      int v26 = *(_DWORD *)v9;
      uint64_t v11 = PtrList_Find(*(void *)(a1 + 16), (uint64_t)&v26, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
      if (v11)
      {
        uint64_t v12 = v11;
        uint64_t v13 = *(unsigned int (**)(uint64_t))(v11 + 24);
        if (v13 && !v13(v10)) {
          return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"The paramDB buffer is corrupt");
        }
        unsigned int v14 = *(_DWORD **)(v12 + 16);
        if (v14) {
          *unsigned int v14 = v10;
        }
        else {
          *(_DWORD *)(v12 + 8) = v10;
        }
        int v27 = v26;
        uint64_t v16 = PtrList_Find(*(void *)(a1 + 16), (uint64_t)&v27, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
        *(_DWORD *)(v16 + 4) = v10;
        *(_DWORD *)(v16 + 36) = 1;
      }
      else if (a3)
      {
        uint64_t result = __ParamDB_AddParam(a1, v26, v10, (uint64_t)ParameterCheck_NoCheck, 0, 0, 0);
        if (result) {
          return result;
        }
      }
      ++v8;
      v9 += 4;
    }
    while (v8 < v6);
  }
  if (v5)
  {
    for (unsigned int i = 0; i < v5; ++i)
    {
      uint64_t v18 = *((unsigned int *)v7 + 1);
      int v26 = *(_DWORD *)v7;
      uint64_t v19 = PtrList_Find(*(void *)(a1 + 16), (uint64_t)&v26, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
      if (v19)
      {
        uint64_t v20 = v19;
        unint64_t v21 = *(unsigned int (**)(uint64_t))(v19 + 24);
        if (v21 && !v21(v18)) {
          return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"The paramDB buffer is corrupt");
        }
        int v22 = *(_DWORD **)(v20 + 16);
        if (v22) {
          *int v22 = v18;
        }
        else {
          *(_DWORD *)(v20 + 8) = v18;
        }
      }
      else if (a3)
      {
        uint64_t result = __ParamDB_AddParam(a1, v26, v18, (uint64_t)ParameterCheck_NoCheck, 0, 0, 0);
        if (result) {
          return result;
        }
      }
      v7 += 4;
    }
  }
  if (!v6)
  {
    uint64_t result = kaldi::MatrixBase<float>::Stride(*(void *)(a1 + 16));
    if (!result) {
      return result;
    }
    unsigned int v23 = 0;
    int v24 = 0;
    do
    {
      unsigned int v25 = (_DWORD *)PtrList_ItemN(*(void *)(a1 + 16), v23);
      if (!v25[8]) {
        v25[1] = v25[2];
      }
      unsigned int v23 = (unsigned __int16)++v24;
    }
    while (kaldi::MatrixBase<float>::Stride(*(void *)(a1 + 16)) > (unsigned __int16)v24);
  }
  return 0;
}

uint64_t ParamDB_LoadBinaryBuffer(uint64_t a1, unsigned __int16 *a2)
{
  return __ParamDB_LoadParams(a1, a2, 0);
}

uint64_t ParamDB_SetParam(uint64_t a1, int a2, int a3)
{
  int v6 = a2;
  uint64_t result = PtrList_Find(*(void *)(a1 + 16), (uint64_t)&v6, (unsigned int (*)(uint64_t *, uint64_t *))CompareItem);
  uint64_t v5 = *(_DWORD **)(result + 16);
  if (v5) {
    *uint64_t v5 = a3;
  }
  else {
    *(_DWORD *)(result + 8) = a3;
  }
  return result;
}

uint64_t PNEW_ParamDB_Con(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  int v6 = (void *)OOCAllocator_Malloc(a1, 24, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = ParamDB_Con(v6, a2);
    unsigned int v8 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *a3 = v6;
    }
  }
  return result;
}

uint64_t ParameterCheck_NoCheck()
{
  return 1;
}

uint64_t NullLogger_GetTimerMs(uint64_t a1, void *a2)
{
  *a2 = 0;
  return 0;
}

uint64_t NullLogger_IsEnabled()
{
  return 0;
}

uint64_t NullLogger_LogBinaryData()
{
  return 0;
}

uint64_t NullLogger_LogTextArg0()
{
  return 0;
}

uint64_t NullLogger_LogTextArg1()
{
  return 0;
}

uint64_t NullLogger_LogTextArg2()
{
  return 0;
}

uint64_t NullLogger_LogTextArg3()
{
  return 0;
}

uint64_t NullLogger_LogTextArg4()
{
  return 0;
}

uint64_t NullLogger_LogTextArgVar()
{
  return 0;
}

uint64_t PNEW_NullLogger_Con(uint64_t a1, void *a2)
{
  unsigned int v6 = 0;
  uint64_t v4 = (void *)OOCAllocator_Malloc(a1, 32, &v6);
  uint64_t result = v6;
  if (!v6)
  {
    uint64_t result = RefCounted_Con((uint64_t)v4, 1);
    if (result)
    {
      unsigned int v6 = result;
      OOCAllocator_Free(a1, (uint64_t)v4);
      *a2 = 0;
      return v6;
    }
    else
    {
      *uint64_t v4 = &__NullLogger;
      v4[2] = a1;
      v4[3] = &unk_26C21AD08;
      *a2 = v4;
    }
  }
  return result;
}

uint64_t lhstdlib_qsort(uint64_t result, unsigned int a2, unsigned int a3, uint64_t (*a4)(unsigned char *, unsigned char *))
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  if (a2 >= 2)
  {
    unsigned int v4 = a3;
    if (a3)
    {
      unsigned int v6 = (unsigned char *)result;
      int v7 = 0;
      memset(v45, 0, sizeof(v45));
      memset(v44, 0, sizeof(v44));
      unint64_t v8 = result + (a2 - 1) * a3;
      uint64_t v9 = a3;
      uint64_t v43 = -(uint64_t)a3;
      uint64_t v38 = -2 * a3;
      int v37 = -2 * a3;
      unint64_t v36 = ~(unint64_t)a3;
      int v10 = -a3;
      while (1)
      {
        unsigned int v11 = ((int)v8 - (int)v6) / v4 + 1;
        if (v11 < 9) {
          break;
        }
        int v41 = v7;
        unsigned __int16 v40 = &v6[v9];
        while (1)
        {
          uint64_t v12 = (v11 >> 1) * v4;
          if (v12)
          {
            unsigned int v13 = v4;
            unsigned int v14 = v6;
            do
            {
              char v15 = v14[v12];
              v14[v12] = *v14;
              *v14++ = v15;
              --v13;
            }
            while (v13);
          }
          uint64_t v16 = (unsigned char *)(v8 + v9);
          int v17 = v6;
          while (1)
          {
            uint64_t v18 = v17;
            uint64_t v19 = v9;
            do
            {
              uint64_t v20 = v19;
              int v17 = &v18[v19];
              if ((unint64_t)&v18[v19] > v8) {
                break;
              }
              uint64_t result = a4(&v18[v19], v6);
              uint64_t v19 = v20 + v9;
            }
            while ((int)result < 1);
            uint64_t v21 = 0;
            unsigned __int16 v42 = v16;
            unint64_t v22 = (unint64_t)&v16[v43];
            do
            {
              unsigned int v23 = (unsigned char *)v22;
              uint64_t v24 = v21;
              if (v22 <= (unint64_t)v6) {
                break;
              }
              uint64_t result = a4((unsigned char *)v22, v6);
              unint64_t v22 = (unint64_t)&v23[v43];
              uint64_t v21 = v24 + v9;
            }
            while ((result & 0x80000000) == 0);
            if (v23 < v17) {
              break;
            }
            uint64_t v16 = v23;
            if (v23 != v17)
            {
              uint64_t v25 = 0;
              int v26 = &v18[v20];
              do
              {
                char v27 = v26[v25];
                v26[v25] = v23[v25];
                v23[v25++] = v27;
              }
              while (v10 + v25);
              uint64_t v16 = v23;
            }
          }
          if (v23 != v6)
          {
            uint64_t v28 = 0;
            do
            {
              char v29 = v6[v28];
              v6[v28] = v23[v28];
              v23[v28++] = v29;
            }
            while (v9 != v28);
          }
          if ((uint64_t)&v42[v36 - (void)v6 - v24] >= (uint64_t)(v8 - (void)v18 - v20)) {
            break;
          }
          if ((unint64_t)&v18[v20] < v8)
          {
            *((void *)v45 + v41) = &v18[v20];
            *((void *)v44 + v41++) = v8;
          }
          unsigned int v4 = a3;
          if (v40 >= v23)
          {
            int v7 = v41;
            goto LABEL_47;
          }
          unint64_t v8 = (unint64_t)&v42[v38 - v24];
          unsigned int v11 = (v37 - (int)v6 + (int)v42 - (int)v24) / a3 + 1;
          if (v11 < 9)
          {
            int v7 = v41;
            goto LABEL_30;
          }
        }
        if (v40 >= v23)
        {
          int v7 = v41;
        }
        else
        {
          *((void *)v45 + v41) = v6;
          *((void *)v44 + v41) = &v42[v38 - v24];
          int v7 = v41 + 1;
        }
        unsigned int v6 = &v18[v20];
        BOOL v34 = (unint64_t)&v18[v20] >= v8;
        unsigned int v4 = a3;
        if (v34)
        {
LABEL_47:
          BOOL v35 = __OFSUB__(v7--, 1);
          if (v7 < 0 != v35) {
            return result;
          }
          unsigned int v6 = (unsigned char *)*((void *)v45 + v7);
          unint64_t v8 = *((void *)v44 + v7);
        }
      }
LABEL_30:
      while (v8 > (unint64_t)v6)
      {
        uint64_t v30 = v6;
        if ((unint64_t)&v6[v9] <= v8)
        {
          int v31 = &v6[v9];
          uint64_t v30 = v6;
          do
          {
            uint64_t result = a4(v31, v30);
            if ((int)result > 0) {
              uint64_t v30 = v31;
            }
            v31 += v9;
          }
          while ((unint64_t)v31 <= v8);
        }
        if (v30 != (unsigned char *)v8)
        {
          uint64_t v32 = 0;
          do
          {
            char v33 = v30[v32];
            v30[v32] = *(unsigned char *)(v8 + v32);
            *(unsigned char *)(v8 + v32++) = v33;
          }
          while (v9 != v32);
        }
        v8 += v43;
      }
      goto LABEL_47;
    }
  }
  return result;
}

uint64_t lhstdlib_udqsort(uint64_t result, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t (*a5)(char *, char *, uint64_t))
{
  uint64_t v73 = *MEMORY[0x263EF8340];
  if (a2 >= 2 && a3)
  {
    long long v71 = 0u;
    long long v70 = 0u;
    long long v69 = 0u;
    long long v68 = 0u;
    long long v67 = 0u;
    long long v66 = 0u;
    long long v65 = 0u;
    long long v64 = 0u;
    long long v63 = 0u;
    long long v62 = 0u;
    long long v61 = 0u;
    long long v60 = 0u;
    long long v59 = 0u;
    long long v58 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    uint64_t v56 = 0;
    uint64_t v57 = result;
    uint64_t v8 = a3;
    uint64_t v72 = 0;
    uint64_t v41 = result + (a2 - 1) * a3;
    int v9 = 1;
    long long v49 = 0u;
    while (1)
    {
      unsigned int v10 = v9 - 1;
      unsigned int v11 = (char *)*(&v57 + v10);
      int v40 = v10;
      uint64_t v12 = (char *)*(&v41 + v10);
      unsigned int v13 = ((int)v12 - (int)v11) / a3 + 1;
      if (v13 >= 9) {
        break;
      }
      uint64_t v28 = v12;
LABEL_44:
      while (v28 > v11)
      {
        unint64_t v36 = v11;
        if (&v11[a3] <= v28)
        {
          int v37 = &v11[v8];
          unint64_t v36 = v11;
          do
          {
            uint64_t result = a5(v37, v36, a4);
            if ((int)result > 0) {
              unint64_t v36 = v37;
            }
            v37 += a3;
          }
          while (v37 <= v28);
        }
        if (v36 != v28)
        {
          uint64_t v38 = 0;
          do
          {
            char v39 = v36[v38];
            v36[v38] = v28[v38];
            v28[v38++] = v39;
          }
          while (v8 != v38);
        }
        v28 -= a3;
      }
      int v9 = v40;
      if (v40 <= 0) {
        return result;
      }
    }
    while (1)
    {
      uint64_t v14 = (v13 >> 1) * a3;
      char v15 = &v11[v14];
      int v16 = a5(&v11[v14], v11, a4);
      if (v14 && v16 < 0)
      {
        unsigned int v17 = a3;
        uint64_t v18 = v11;
        do
        {
          char v19 = v18[v14];
          v18[v14] = *v18;
          *v18++ = v19;
          --v17;
        }
        while (v17);
      }
      if ((a5(v12, &v11[v14], a4) & 0x80000000) != 0 && v15 != v12)
      {
        unsigned int v20 = a3;
        uint64_t v21 = v12;
        unint64_t v22 = &v11[v14];
        do
        {
          char v23 = *v22;
          *v22++ = *v21;
          *v21++ = v23;
          --v20;
        }
        while (v20);
      }
      int v24 = a5(&v11[v14], v11, a4);
      if (v14 && v24 < 0)
      {
        unsigned int v25 = a3;
        int v26 = v11;
        do
        {
          char v27 = v26[v14];
          v26[v14] = *v26;
          *v26++ = v27;
          --v25;
        }
        while (v25);
      }
      uint64_t v28 = &v11[a3];
      char v29 = &v12[-a3];
      do
      {
        while ((a5(v28, v15, a4) & 0x80000000) != 0)
          v28 += a3;
        uint64_t result = a5(v29, v15, a4);
        if ((int)result >= 1)
        {
          do
          {
            v29 -= a3;
            uint64_t result = a5(v29, v15, a4);
          }
          while ((int)result > 0);
        }
        if (v28 <= v29)
        {
          if (v28 != v29)
          {
            unsigned int v30 = a3;
            int v31 = v29;
            uint64_t v32 = v28;
            do
            {
              char v33 = *v32;
              *v32++ = *v31;
              *v31++ = v33;
              --v30;
            }
            while (v30);
          }
          if (v15 == v29) {
            BOOL v34 = v28;
          }
          else {
            BOOL v34 = v15;
          }
          if (v15 == v28) {
            char v15 = v29;
          }
          else {
            char v15 = v34;
          }
          v28 += a3;
          v29 -= a3;
        }
      }
      while (v28 <= v29);
      if (v29 - v11 > v12 - v28) {
        break;
      }
      char v29 = v12;
      BOOL v35 = v28 >= v12;
      uint64_t v12 = v28;
      if (!v35) {
        goto LABEL_39;
      }
LABEL_41:
      unsigned int v13 = ((int)v28 - (int)v11) / a3 + 1;
      uint64_t v12 = v28;
      if (v13 <= 8) {
        goto LABEL_44;
      }
    }
    uint64_t v28 = v11;
    BOOL v35 = v11 >= v29;
    unsigned int v11 = v29;
    if (v35)
    {
      unsigned int v11 = v29;
    }
    else
    {
LABEL_39:
      *(&v57 + v40) = (uint64_t)v28;
      *(&v41 + v40++) = (uint64_t)v29;
    }
    uint64_t v28 = v12;
    goto LABEL_41;
  }
  return result;
}

unint64_t lhstdlib_bsearch(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t (*a5)(uint64_t, unint64_t), _DWORD *a6)
{
  uint64_t v8 = (a3 - 1) * a4;
  if (v8 < 0)
  {
    unint64_t v19 = 0;
    unint64_t v12 = a2;
    goto LABEL_20;
  }
  unint64_t v22 = a6;
  unint64_t v11 = a2 + v8;
  unint64_t v12 = a2;
  while (a3 < 2)
  {
    if (!a3) {
      goto LABEL_15;
    }
    int v13 = a5(a1, v12);
    if (!v13)
    {
      unint64_t v19 = v12;
      goto LABEL_19;
    }
    unint64_t v14 = v12 + a4;
    unint64_t v15 = v11 - a4;
    BOOL v16 = v13 >= 0;
    a3 = 1;
LABEL_11:
    if (v16) {
      unint64_t v12 = v14;
    }
    else {
      unint64_t v11 = v15;
    }
    if (v12 > v11)
    {
LABEL_15:
      unint64_t v19 = 0;
      goto LABEL_19;
    }
  }
  unint64_t v17 = a3 >> 1;
  uint64_t v18 = (a3 & 1) + (a3 >> 1) - 1;
  unint64_t v19 = v12 + v18 * a4;
  int v20 = a5(a1, v19);
  if (v20)
  {
    unint64_t v14 = v19 + a4;
    unint64_t v15 = v19 - a4;
    BOOL v16 = v20 >= 0;
    if (v20 < 0) {
      a3 = v18;
    }
    else {
      a3 = v17;
    }
    goto LABEL_11;
  }
  v12 += v18 * a4;
LABEL_19:
  a6 = v22;
LABEL_20:
  *a6 = (v12 - a2) / a4;
  return v19;
}

uint64_t utf8_str_to_utf16(uint64_t a1, char *__s, uint64_t *a3, unint64_t *a4)
{
  unsigned int v18 = 0;
  size_t v8 = strlen(__s);
  unint64_t v17 = (unsigned __int8 *)__s;
  if (!v8)
  {
    unint64_t v14 = (_WORD *)*a3;
    if (!*a3)
    {
      if (!a1) {
        return err_GenerateErrorLimit();
      }
      unint64_t v14 = (_WORD *)OOCAllocator_Malloc(a1, 2, &v18);
      *a3 = (uint64_t)v14;
      if (v18) {
        return v18;
      }
      *a4 = 2;
    }
    *unint64_t v14 = 0;
    return v18;
  }
  size_t v9 = v8;
  unint64_t v10 = utf8_utf16_byte_count(&v17);
  if (v10 == -1) {
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"p_in");
  }
  unint64_t v11 = v10;
  if (v10 < *a4)
  {
    unint64_t v12 = (_WORD *)*a3;
    goto LABEL_5;
  }
  if (!a1) {
    return err_GenerateErrorLimit();
  }
  unint64_t v12 = (_WORD *)OOCAllocator_Realloc(a1, *a3, v10 + 2, &v18);
  *a3 = (uint64_t)v12;
  if (!v18)
  {
    *a4 = v11 + 1;
LABEL_5:
    BOOL v16 = v12;
    unint64_t v17 = (unsigned __int8 *)__s;
    if (!utf8_to_utf16((char **)&v17, (unint64_t)&__s[v9], &v16, (unint64_t)v12 + v11))
    {
      _WORD *v16 = 0;
      return v18;
    }
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"p_in");
  }
  return v18;
}

uint64_t utf16_str_to_utf8(uint64_t a1, unsigned __int16 *a2, uint64_t *a3, unint64_t *a4)
{
  unsigned int v18 = 0;
  uint64_t v8 = utf16_byte_count(a2);
  unint64_t v17 = a2;
  if (!v8)
  {
    unint64_t v14 = (unsigned char *)*a3;
    if (!*a3)
    {
      if (!a1) {
        return err_GenerateErrorLimit();
      }
      unint64_t v14 = (unsigned char *)OOCAllocator_Malloc(a1, 1, &v18);
      *a3 = (uint64_t)v14;
      if (v18) {
        return v18;
      }
      *a4 = 1;
    }
    *unint64_t v14 = 0;
    return v18;
  }
  uint64_t v9 = v8;
  unint64_t v10 = utf16_utf8_byte_count(&v17);
  if (v10 == -1) {
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"p_in");
  }
  unint64_t v11 = v10;
  if (v10 < *a4)
  {
    uint64_t v12 = *a3;
    goto LABEL_5;
  }
  if (!a1) {
    return err_GenerateErrorLimit();
  }
  uint64_t v12 = OOCAllocator_Realloc(a1, *a3, v10 + 1, &v18);
  *a3 = v12;
  if (!v18)
  {
    *a4 = v11 + 1;
LABEL_5:
    BOOL v16 = (unsigned char *)v12;
    unint64_t v17 = a2;
    if (!utf16_to_utf8(&v17, (char *)a2 + v9, &v16, v12 + v11))
    {
      unsigned char *v16 = 0;
      return v18;
    }
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"p_in");
  }
  return v18;
}

uint64_t utf8_to_utf16(char **a1, unint64_t a2, _WORD **a3, unint64_t a4)
{
  return priv_utf8_to_utf16(a1, a2, a3, a4, 0);
}

uint64_t priv_utf8_to_utf16(char **a1, unint64_t a2, _WORD **a3, unint64_t a4, void *a5)
{
  uint64_t v5 = *a1;
  if (a3) {
    unsigned int v6 = *a3;
  }
  else {
    unsigned int v6 = 0;
  }
  if ((unint64_t)v5 < a2)
  {
    uint64_t v7 = 0;
    while (1)
    {
      unint64_t v8 = *v5;
      uint64_t v9 = trailing_bytes_for_utf8_start_byte[v8];
      if (v9 == -1) {
        goto LABEL_44;
      }
      if ((unint64_t)&v5[v9] >= a2)
      {
        uint64_t v19 = 2;
        goto LABEL_45;
      }
      if ((v8 & 0xF8) == 0xF0)
      {
        int v10 = v5[1];
        if (v10 > -65) {
          goto LABEL_40;
        }
        int v11 = v5[2];
        if (v11 > -65)
        {
LABEL_41:
          v5 += 2;
          goto LABEL_44;
        }
        int v12 = v5[3];
        if (v12 > -65)
        {
          v5 += 3;
          goto LABEL_44;
        }
        v5 += 4;
        unint64_t v8 = v12
           + ((((unint64_t)v10 << 6) + (v8 << 12) + v11) << 6);
      }
      else if ((v8 & 0xF0) == 0xE0)
      {
        int v13 = v5[1];
        if (v13 > -65)
        {
LABEL_40:
          ++v5;
          goto LABEL_44;
        }
        int v14 = v5[2];
        if (v14 > -65) {
          goto LABEL_41;
        }
        v5 += 3;
        unint64_t v8 = ((unint64_t)v13 << 6) + (v8 << 12) + v14;
      }
      else if ((v8 & 0xE0) == 0xC0)
      {
        int v15 = v5[1];
        if (v15 > -65)
        {
          uint64_t v19 = 1;
          ++v5;
          goto LABEL_45;
        }
        v5 += 2;
        unint64_t v8 = v15 + (v8 << 6);
      }
      else
      {
        ++v5;
      }
      unint64_t v16 = v8 - priv_utf8_to_utf16_shifted_utf8_marks[v9];
      if (v16 >> 16)
      {
        if (v16 >> 16 > 0x10)
        {
LABEL_38:
          v5 += (char)~(_BYTE)v9;
LABEL_44:
          uint64_t v19 = 1;
          goto LABEL_45;
        }
        int v17 = v16 & 0x3FF | 0xDC00;
        LODWORD(v16) = ((v16 + 67043328) >> 10) - 10240;
        if (v6)
        {
LABEL_27:
          if (v17) {
            uint64_t v18 = 2;
          }
          else {
            uint64_t v18 = 1;
          }
          if ((unint64_t)&v6[v18] > a4)
          {
            v5 += ~v9;
            uint64_t v19 = 3;
            goto LABEL_45;
          }
          *unsigned int v6 = v16;
          if (v17)
          {
            v6[1] = v17;
            v6 += 2;
          }
          else
          {
            ++v6;
          }
        }
      }
      else
      {
        if ((v16 | 0x400) >> 10 == 55) {
          goto LABEL_38;
        }
        int v17 = 0;
        if (v6) {
          goto LABEL_27;
        }
      }
      ++v7;
      if ((unint64_t)v5 >= a2) {
        goto LABEL_37;
      }
    }
  }
  uint64_t v7 = 0;
LABEL_37:
  uint64_t v19 = 0;
LABEL_45:
  *a1 = v5;
  if (a3) {
    *a3 = v6;
  }
  if (a5) {
    *a5 = v7;
  }
  return v19;
}

uint64_t priv_utf16_to_utf8(unsigned __int16 **a1, unint64_t a2, unsigned char **a3, unint64_t a4)
{
  unsigned int v4 = *a1;
  if (a3) {
    uint64_t v5 = *a3;
  }
  else {
    uint64_t v5 = 0;
  }
  if ((unint64_t)v4 >= a2)
  {
    uint64_t v14 = 0;
    goto LABEL_37;
  }
  unsigned int v6 = *a1;
  while (1)
  {
    unsigned int v8 = *v6++;
    unint64_t v7 = v8;
    int v9 = v8 & 0xFC00;
    if (v9 == 55296) {
      break;
    }
    if (v9 == 56320) {
      goto LABEL_32;
    }
    if (v5) {
      goto LABEL_13;
    }
LABEL_29:
    unsigned int v4 = v6;
    if ((unint64_t)v6 >= a2)
    {
      uint64_t v14 = 0;
      unsigned int v4 = v6;
      goto LABEL_37;
    }
  }
  if ((unint64_t)v6 >= a2)
  {
    uint64_t v14 = 2;
    goto LABEL_37;
  }
  int v10 = *v6;
  if ((v10 & 0xFC00) != 0xDC00)
  {
LABEL_32:
    uint64_t v14 = 1;
    goto LABEL_37;
  }
  unint64_t v7 = (v10 - 56320) + (v7 << 10) - 56557568;
  unsigned int v6 = v4 + 2;
  if (!v5) {
    goto LABEL_29;
  }
LABEL_13:
  if (v7 < 0x80)
  {
    if ((unint64_t)(v5 + 1) > a4) {
      goto LABEL_33;
    }
    LODWORD(v11) = 0;
    *uint64_t v5 = v7;
    goto LABEL_28;
  }
  if (v7 < 0x10000) {
    uint64_t v11 = 2;
  }
  else {
    uint64_t v11 = 3;
  }
  if (v7 <= 0x7FF) {
    uint64_t v12 = 1;
  }
  else {
    uint64_t v12 = v11;
  }
  int v13 = &v5[v12];
  if ((unint64_t)(v13 + 1) <= a4)
  {
    *int v13 = v7 & 0x3F | 0x80;
    if (v7 <= 0x7FF)
    {
      *(v13 - 1) = (v7 >> 6) | 0xC0;
      LODWORD(v11) = 1;
    }
    else
    {
      *(v13 - 1) = (v7 >> 6) & 0x3F | 0x80;
      if ((v7 - 2048) >> 11 > 0x1E)
      {
        *(v13 - 2) = (v7 >> 12) & 0x3F | 0x80;
        *(v13 - 3) = (v7 >> 18) | 0xF0;
      }
      else
      {
        *(v13 - 2) = (v7 >> 12) | 0xE0;
      }
    }
LABEL_28:
    v5 += (v11 + 1);
    goto LABEL_29;
  }
LABEL_33:
  uint64_t v15 = 0x7FFFFFFFFFFFFFFFLL;
  if (v7 >> 16) {
    uint64_t v15 = 0x7FFFFFFFFFFFFFFELL;
  }
  unsigned int v4 = &v6[v15];
  uint64_t v14 = 3;
LABEL_37:
  *a1 = v4;
  if (a3) {
    *a3 = v5;
  }
  return v14;
}

uint64_t utf16_utf8_byte_count(unsigned __int16 **a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = *a1 + 1;
  unsigned int v3 = **a1;
  if (**a1)
  {
    uint64_t v4 = 0;
    while (1)
    {
      if (v3 > 0x7F)
      {
        if (v3 > 0x7FF)
        {
          if (v3 >> 11 <= 0x1A) {
            goto LABEL_12;
          }
          if (v3 >> 10 > 0x36)
          {
            if (v3 < 0xE000)
            {
LABEL_17:
              uint64_t v4 = -1;
              uint64_t v2 = v1;
              goto LABEL_16;
            }
LABEL_12:
            v4 += 3;
            goto LABEL_13;
          }
          if ((*v2 & 0xFC00) != 0xDC00) {
            goto LABEL_17;
          }
          v4 += 4;
          uint64_t v2 = v1 + 2;
        }
        else
        {
          v4 += 2;
        }
      }
      else
      {
        ++v4;
      }
LABEL_13:
      uint64_t v1 = v2;
      unsigned int v5 = (unsigned __int16)*v2++;
      unsigned int v3 = v5;
      if (!v5) {
        goto LABEL_16;
      }
    }
  }
  uint64_t v4 = 0;
LABEL_16:
  *a1 = v2;
  return v4;
}

uint64_t utf8_utf16_byte_count(unsigned __int8 **a1)
{
  uint64_t v1 = 0;
  uint64_t v2 = *a1;
  while (1)
  {
    unsigned int v3 = v2;
    unsigned int v6 = *v2;
    uint64_t v4 = v2 + 1;
    uint64_t v5 = v6;
    if (!v6) {
      break;
    }
    uint64_t v7 = trailing_bytes_for_utf8_start_byte[v5];
    if ((v5 & 0xF8) == 0xF0) {
      uint64_t v8 = 4;
    }
    else {
      uint64_t v8 = 2;
    }
    v1 += v8;
    uint64_t v2 = &v4[v7];
    if (v7 == -1)
    {
      uint64_t v1 = -1;
      goto LABEL_9;
    }
  }
  unsigned int v3 = v4;
LABEL_9:
  *a1 = v3;
  return v1;
}

uint64_t utf8full_check(char **a1, unint64_t a2)
{
  return priv_utf8_to_utf16(a1, a2, 0, 0, 0);
}

uint64_t utf16_byte_count(_WORD *a1)
{
  __int16 v1 = *a1;
  if (!*a1) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v4 = a1 + 1;
  do
  {
    int v5 = v1 & 0xFC00;
    if (v5 == 55296) {
      uint64_t v6 = 4;
    }
    else {
      uint64_t v6 = 2;
    }
    if (v5 == 56320) {
      uint64_t v7 = 0;
    }
    else {
      uint64_t v7 = v6;
    }
    result += v7;
    int v8 = *v4++;
    __int16 v1 = v8;
  }
  while (v8);
  return result;
}

uint64_t catParseFormatString(char *a1, char *a2, void *a3, unsigned char *a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  size_t v8 = strlen(a1);
  if (v8 - 13 < 0xFFFFFFFFFFFFFFF4) {
    return 0xFFFFFFFFLL;
  }
  size_t v10 = v8;
  *a4 = a1[v8 - 1];
  uint64_t v11 = strpbrk(a1, "123456789");
  if (v11)
  {
    uint64_t v12 = &a1[v10 + ~(unint64_t)v11];
    __memcpy_chk();
    __s1[(void)v12] = 0;
    uint64_t v13 = atoi(__s1);
  }
  else
  {
    uint64_t v13 = 0;
  }
  *a3 = v13;
  __s1[0] = *a1;
  __s1[1] = 0;
  uint64_t v14 = strpbrk(__s1, "-+0 #");
  if (v14) {
    char v15 = *v14;
  }
  else {
    char v15 = 32;
  }
  uint64_t result = 0;
  *a2 = v15;
  return result;
}

size_t catUnsignedLongToASCII(char *__s, int a2, unint64_t a3, unsigned int a4, int a5, unint64_t a6, char *a7, uint64_t a8)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  char v28 = 0;
  if (a4)
  {
    uint64_t v13 = 0;
    if (a5) {
      char v14 = 55;
    }
    else {
      char v14 = 87;
    }
    do
    {
      int v15 = a3 % a4;
      if (v15 << 24 >= 167772160) {
        char v16 = v14;
      }
      else {
        char v16 = 48;
      }
      v26[v13-- + 19] = v16 + v15;
      BOOL v17 = a3 >= a4;
      a3 /= a4;
    }
    while (v17);
    uint64_t v18 = -v13;
    uint64_t v19 = &v28 + v13;
    if (__s)
    {
LABEL_10:
      size_t v20 = strlen(__s);
      uint64_t v21 = v20 + v18;
      goto LABEL_15;
    }
  }
  else
  {
    if (a3 > 0xFF) {
      return 4294967293;
    }
    uint64_t v19 = &v27;
    char v27 = a3;
    uint64_t v18 = 1;
    if (__s) {
      goto LABEL_10;
    }
  }
  size_t v20 = 0;
  uint64_t v21 = v18;
LABEL_15:
  if (a6 >= v20 + v18) {
    size_t v23 = a6 - (v20 + v18);
  }
  else {
    size_t v23 = 0;
  }
  size_t v22 = v23 + v21;
  if (a7)
  {
    if (a8 - (uint64_t)a7 <= v22)
    {
      return 4294967294;
    }
    else
    {
      if (a2 == 32)
      {
        memset(a7, 32, v23);
        int v24 = &a7[v23];
        if (__s)
        {
          memcpy(v24, __s, v20);
          v24 += v20;
        }
      }
      else
      {
        if (__s)
        {
          memcpy(a7, __s, v20);
          a7 += v20;
        }
        memset(a7, a2, v23);
        int v24 = &a7[v23];
      }
      strcpy(v24, v19);
    }
  }
  return v22;
}

size_t spr_pcat(void *a1, uint64_t a2, char *a3, const char *a4)
{
  __int16 v12 = 0;
  size_t v11 = 0;
  if ((catParseFormatString(a3, (char *)&v12 + 1, &v11, &v12) & 0x80000000) != 0) {
    return 0xFFFFFFFFLL;
  }
  if ((char)v12 == 115)
  {
    if ((SHIBYTE(v12) | 0x10) == 0x30)
    {
      size_t v8 = strlen(a4);
      if (v8 <= v11) {
        size_t v9 = v11;
      }
      else {
        size_t v9 = v8;
      }
      if (v11 >= v8) {
        size_t v10 = v11 - v8;
      }
      else {
        size_t v10 = 0;
      }
      if (a1)
      {
        if (a2 - (uint64_t)a1 <= v9)
        {
          return 4294967294;
        }
        else
        {
          memset(a1, HIBYTE(v12), v10);
          strcpy((char *)a1 + v10, a4);
        }
      }
      return v9;
    }
    return 0xFFFFFFFFLL;
  }
  if ((char)v12 != 112) {
    return 0xFFFFFFFFLL;
  }
  return catUnsignedLongToASCII(0, 48, (unint64_t)a4, 0x10u, 1, 0x10uLL, (char *)a1, a2);
}

uint64_t spr_pcat_noerr(void *a1, uint64_t a2, char *a3, const char *a4)
{
  LODWORD(result) = spr_pcat(a1, a2, a3, a4);
  if (result == -2) {
    return 0;
  }
  else {
    return result;
  }
}

uint64_t LHString_Con(void *a1, uint64_t a2)
{
  return LHString_ConFromCPtr(a1, a2, gc_szEmptyString);
}

uint64_t LHString_ConFromCPtr(void *a1, uint64_t a2, const char *a3)
{
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    *a1 = &__LHString;
    return LHString_ConFromCPtrInterval((uint64_t)a1, a2, a3, 0);
  }
  return result;
}

uint64_t LHString_ConFromCPtrInterval(uint64_t a1, uint64_t a2, const char *a3, const char *a4)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__LHString;
    *(void *)(a1 + 24) = a2;
    uint64_t result = __LHString_GetCopy(a1, a3, a4, (char **)(a1 + 8));
    if (!result)
    {
      int v9 = strlen(*(const char **)(a1 + 8));
      uint64_t result = 0;
      *(void *)(a1 + 16) = (v9 + 1);
    }
  }
  return result;
}

uint64_t __LHString_GetCopy(uint64_t a1, const char *a2, const char *a3, char **a4)
{
  if (a2) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = (const char *)&gc_szEmptyString;
  }
  if (!a3) {
    a3 = &v6[strlen(v6)];
  }
  unsigned int v12 = 0;
  unsigned int v7 = a3 - v6;
  size_t v8 = (char *)OOCAllocator_Malloc(*(void *)(a1 + 24), (a3 - v6 + 1), &v12);
  uint64_t v9 = v12;
  if (!v12)
  {
    size_t v10 = strncpy(v8, v6, v7);
    v10[v7] = 0;
    *a4 = v10;
    return v12;
  }
  return v9;
}

uint64_t LHString_Reserve(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t result = 0;
  unsigned int v8 = 0;
  if (*(_DWORD *)(a1 + 16) >= a2) {
    goto LABEL_4;
  }
  uint64_t v7 = OOCAllocator_Realloc(*(void *)(a1 + 24), *(void *)(a1 + 8), a2, &v8);
  *(void *)(a1 + 8) = v7;
  if (v7)
  {
    *(_DWORD *)(a1 + 16) = a2;
    uint64_t result = v8;
LABEL_4:
    *(_DWORD *)(a1 + 20) = a3;
    return result;
  }
  return kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
}

uint64_t LHString_Des(uint64_t *a1)
{
  OOCAllocator_Free(a1[3], a1[1]);
  a1[2] = 0;
  return Object_Des();
}

uint64_t LHString_Append(uint64_t a1, const char *a2)
{
  unsigned int v3 = a2;
  return LHString_AppendEx(a1, &v3, 1u);
}

uint64_t LHString_AppendEx(uint64_t a1, const char **a2, unsigned int a3)
{
  uint64_t v4 = a2;
  int v6 = 0;
  if (a3)
  {
    uint64_t v7 = a3;
    unsigned int v8 = a2;
    do
    {
      if (*v8) {
        v6 += strlen(*v8);
      }
      ++v8;
      --v7;
    }
    while (v7);
  }
  unsigned int v9 = strlen(*(const char **)(a1 + 8));
  if (v9 == -1 || v9 >= ~v6)
  {
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"string too long");
  }
  else
  {
    unsigned int v12 = v6 + v9 + 1;
    while (1)
    {
      unsigned int v13 = *(_DWORD *)(a1 + 16);
      if (v12 <= v13) {
        break;
      }
      int v14 = *(_DWORD *)(a1 + 20);
      unsigned int v15 = v14 + v13;
      if (v14) {
        unsigned int v16 = v15;
      }
      else {
        unsigned int v16 = v12;
      }
      uint64_t result = LHString_Reserve(a1, v16, v14);
      if (result) {
        return result;
      }
    }
    if (a3)
    {
      uint64_t v17 = a3;
      do
      {
        if (*v4)
        {
          size_t v18 = strlen(*v4);
          if (v18)
          {
            size_t v19 = v18;
            if (v18 + strlen(*(const char **)(a1 + 8)) < *(unsigned int *)(a1 + 16)) {
              strncat(*(char **)(a1 + 8), *v4, v19);
            }
          }
        }
        ++v4;
        --v17;
      }
      while (v17);
    }
    return 0;
  }
}

size_t LHString_Length(uint64_t a1)
{
  return strlen(*(const char **)(a1 + 8));
}

uint64_t LHString_Erase(uint64_t a1)
{
  return LHString_SetContentFromNCPtr(a1, gc_szEmptyString, 0);
}

uint64_t LHString_SetContentFromCPtr(uint64_t a1, char *__s)
{
  unsigned int v4 = strlen(__s);
  return LHString_SetContentFromNCPtr(a1, __s, v4);
}

uint64_t LHString_SetContentFromNCPtr(uint64_t a1, const char *a2, unsigned int a3)
{
  size_t v6 = a3 + 1;
  while (1)
  {
    unsigned int v7 = *(_DWORD *)(a1 + 16);
    if (v6 <= v7) {
      break;
    }
    int v8 = *(_DWORD *)(a1 + 20);
    unsigned int v9 = v8 + v7;
    if (v8) {
      unsigned int v10 = v9;
    }
    else {
      unsigned int v10 = v6;
    }
    uint64_t result = LHString_Reserve(a1, v10, v8);
    if (result) {
      return result;
    }
  }
  bzero(*(void **)(a1 + 8), v6);
  strncpy(*(char **)(a1 + 8), a2, a3);
  return 0;
}

uint64_t LHString_Split(uint64_t a1, char *__s2, uint64_t a3)
{
  unsigned int v3 = *(char **)(a1 + 8);
  if (!*v3) {
    return 0;
  }
  uint64_t v9 = 0;
  while (1)
  {
    unsigned int v7 = strstr(v3, __s2);
    uint64_t result = PNEW_LHString_ConFromCPtrInterval(*(void *)(a1 + 24), *(void *)(a1 + 24), v3, v7, &v9);
    if (result) {
      break;
    }
    if (**(unsigned char **)(v9 + 8))
    {
      uint64_t result = PtrList_Append(a3, v9);
      if (result) {
        return result;
      }
    }
    else
    {
      uint64_t result = OOC_PlacementDeleteObject(*(void *)(a1 + 24), v9);
      if (result) {
        return result;
      }
    }
    unsigned int v3 = v7 + 1;
    if (!v7) {
      return 0;
    }
  }
  return result;
}

uint64_t PNEW_LHString_ConFromCPtrInterval(uint64_t a1, uint64_t a2, const char *a3, const char *a4, uint64_t *a5)
{
  unsigned int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 32, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = LHString_ConFromCPtrInterval(v10, a2, a3, a4);
    unsigned int v12 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *a5 = v10;
    }
  }
  return result;
}

void *GetLHStringClass()
{
  return &__LHString;
}

uint64_t lhi_IsValidLanguageString(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    size_t v2 = strlen((const char *)result);
    if (v2 < 3) {
      return 0;
    }
    if (v2 != 3)
    {
      unint64_t v3 = 3;
      while (1)
      {
        int v4 = *(unsigned __int8 *)(v1 + v3);
        if (v4 != 124 && v4 != 0) {
          break;
        }
        v3 += 4;
        if (v3 >= v2) {
          return 1;
        }
      }
      return 0;
    }
    return 1;
  }
  return result;
}

uint64_t lhi_LogPhoneticTranscriptions(uint64_t a1, const char *a2, const char *a3, uint64_t a4, unint64_t a5)
{
  uint64_t result = 0;
  *(void *)&v19[1] = *MEMORY[0x263EF8340];
  if (a4)
  {
    if (a5)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1 - *(void *)(*(void *)a1 + 88));
      if (result)
      {
        unsigned int v16 = a2;
        unint64_t v10 = 0;
        size_t v11 = &v18;
        unsigned int v12 = 1;
        do
        {
          if (*(_DWORD *)(a4 + 24 * v10) == 1)
          {
            unsigned int v13 = *(const char **)(a4 + 24 * v10 + 8);
            int v14 = v11;
          }
          else
          {
            int v14 = v11;
            unsigned int v13 = "<non-phonetic>";
          }
          v11 += (int)spr_pcat_noerr(v14, (uint64_t)v19, "s", v13);
          if (a5 == v12) {
            break;
          }
          unint64_t v10 = v12;
          v11 += (int)spr_pcat_noerr(v11, (uint64_t)v19, "s", " ");
          ++v12;
        }
        while (a5 > v10);
        *size_t v11 = 0;
        return (*(uint64_t (**)(uint64_t, const char *, const char *, ...))(*(void *)a1 + 32))(a1 - *(void *)(*(void *)a1 + 88), v16, "Found %d transcriptions for '%s': %s", v15, v16, a3);
      }
    }
  }
  return result;
}

uint64_t EDConstants_Con(void *a1, uint64_t a2, int a3)
{
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    *a1 = &__EDConstants;
    a1[1] = a2;
    if (a3 == 24)
    {
      return 0;
    }
    else
    {
      return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"u32BufferSize");
    }
  }
  return result;
}

uint64_t PNEW_EDConstants_Con(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  unsigned int v10 = 0;
  int v8 = (void *)OOCAllocator_Malloc(a1, 16, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = EDConstants_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

uint64_t CDSHash_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = 0;
  uint64_t result = VoConObject_Con2((void *)a1, a2);
  if (!result)
  {
    *(void *)a1 = &__CDSHash;
    *(void *)(a1 + 104) = a2;
    if ((*(unsigned int (**)(uint64_t))(*(void *)a3 + 56))(a3 - *(void *)(*(void *)a3 + 224)) == 388438978)
    {
      unsigned int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 64))(a3 - *(void *)(*(void *)a3 + 224));
      if (BinBlockStreamReader_IsVersionAccepted(v7, 0x10000))
      {
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))a3)(a3 - *(void *)(*(void *)a3 + 224), 1162560581, 0, &v10);
        if (!result)
        {
          uint64_t result = PNEW_EHashTableFSM_Con2(*(void *)(a1 + 104), *(void *)(a1 + 104), v10, (uint64_t *)(a1 + 56));
          if (!result)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16))(a3 - *(void *)(*(void *)a3 + 224), v10);
            if (!result)
            {
              uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t *, uint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), *(void *)(a1 + 104), 1128612933, 0, 0x10000, &v12, &v11);
              if (!result)
              {
                unsigned int v8 = v11 >> 2;
                *(_DWORD *)(a1 + 64) = v11 >> 2;
                uint64_t v9 = v12 + 2 * v8;
                *(void *)(a1 + 72) = v12;
                *(void *)(a1 + 80) = v9;
                uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t, uint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), *(void *)(a1 + 104), 1329808453, 0, 0x10000, a1 + 88, &v11);
                if (!result) {
                  return PNEW_EDConstants_Con(*(void *)(a1 + 104), *(void *)(a1 + 88), v11, (void *)(a1 + 96));
                }
              }
            }
          }
        }
      }
      else
      {
        return err_GenerateErrorVersion();
      }
    }
    else
    {
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Wrong Buffer Type");
    }
  }
  return result;
}

uint64_t CDSHash_Des(void *a1)
{
  uint64_t result = _CDSHash_Cleanup(a1);
  if (!result)
  {
    return VoConObject_Des((uint64_t)a1);
  }
  return result;
}

uint64_t _CDSHash_Cleanup(void *a1)
{
  OOCAllocator_Free(a1[13], a1[11]);
  a1[11] = 0;
  uint64_t v2 = a1[12];
  if (v2)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[13], v2);
    if (result) {
      return result;
    }
    a1[12] = 0;
  }
  OOCAllocator_Free(a1[13], a1[9]);
  a1[9] = 0;
  uint64_t v4 = a1[7];
  if (!v4) {
    return 0;
  }
  uint64_t result = OOC_PlacementDeleteObject(a1[13], v4);
  if (!result) {
    a1[7] = 0;
  }
  return result;
}

uint64_t CDSHash_DecodeKey(uint64_t result, int a2, uint64_t a3)
{
  uint64_t v3 = (a2 - 1);
  if (a2 == 1)
  {
    uint64_t v3 = 0;
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v6 = *(void *)(result + 72);
    uint64_t v5 = *(void *)(result + 80);
    do
    {
      int v7 = 0;
      do
      {
        uint64_t v8 = (unsigned __int16)v7;
        int v9 = *(unsigned __int16 *)(v5 + 2 * (unsigned __int16)v7++);
      }
      while (v9 != *(unsigned __int16 *)(a3 + 2 * v4));
      *(_WORD *)(a3 + 2 * v4++) = *(_WORD *)(v6 + 2 * v8);
    }
    while (v4 != v3);
  }
  *(_WORD *)(a3 + 2 * v3) = 0;
  return result;
}

uint64_t CDSHash_GetInputHash(uint64_t a1, uint64_t a2, int a3, int *a4, unsigned int *a5)
{
  unsigned int v19 = 0;
  uint64_t v10 = LH_wcslen(a2);
  uint64_t v11 = v10 + 1;
  uint64_t v12 = OOCAllocator_Malloc(*(void *)(a1 + 104), 2 * (v10 + 1), &v19);
  if (v19) {
    return v19;
  }
  unsigned int v13 = (unsigned __int16 *)v12;
  if (v10)
  {
    unint64_t v14 = 0;
    while (1)
    {
      int v18 = 0;
      __int16 v17 = *(_WORD *)(a2 + 2 * v14);
      if (!v17)
      {
        uint64_t v11 = v14 + 1;
        goto LABEL_14;
      }
      if (lhstdlib_bsearch((uint64_t)&v17, *(void *)(a1 + 72), *(unsigned int *)(a1 + 64), 2uLL, (uint64_t (*)(uint64_t, unint64_t))CmpLH_U16, &v18))
      {
        unint64_t v15 = v14 + 1;
      }
      else
      {
        if (!a3 || !v14)
        {
          *a5 = 0;
          if (v13) {
            goto LABEL_19;
          }
          return v19;
        }
        unint64_t v15 = v14 + 1;
        uint64_t v11 = v14 + 1;
      }
      v13[v14] = *(_WORD *)(*(void *)(a1 + 80) + 2 * v18);
      unint64_t v14 = v15;
      if (v15 >= v11 - 1) {
        goto LABEL_14;
      }
    }
  }
  uint64_t v11 = 1;
LABEL_14:
  v13[v11 - 1] = *(_WORD *)(*(void *)(*(void *)(a1 + 96) + 8) + 8);
  if (!EHashTableFSM_HashLongestMatch(*(uint64_t **)(a1 + 56), v13, v11, a4, a5) && (!a3 || !*a5)) {
    *a5 = 0;
  }
LABEL_19:
  OOCAllocator_Free(*(void *)(a1 + 104), (uint64_t)v13);
  return v19;
}

uint64_t CmpLH_U16(unsigned __int16 *a1, unsigned __int16 *a2)
{
  unsigned int v2 = *a1;
  unsigned int v3 = *a2;
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t CDSHash_GetNbrKeyEntries(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 96) + 8) + 12) | (*(unsigned __int16 *)(*(void *)(*(void *)(a1 + 96) + 8) + 10) << 16);
}

uint64_t CDSHash_UnhashKey(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 56) + 32))(*(void *)(a1 + 56));
}

void *GetCDSHashClass()
{
  return &__CDSHash;
}

uint64_t CDSBase_Con(void *a1, uint64_t a2, _OWORD *a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v8 = 0;
  uint64_t result = PNEW_BinBlockStreamReader_Con(a2, a2, a3, a4, a5, &v8);
  if (!result)
  {
    uint64_t result = CDSHash_Con((uint64_t)a1, a2, v8 + 32);
    if (!result)
    {
      *a1 = &__CDSBase;
      uint64_t result = _CDSBase_Init((uint64_t)a1, v8 + 32);
      if (!result) {
        return (*(uint64_t (**)(uint64_t))(*(void *)v8 + 32))(v8);
      }
    }
  }
  return result;
}

uint64_t _CDSBase_Init(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 56))(a2 - *(void *)(*(void *)a2 + 224)) == 388438978)
  {
    unsigned int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 64))(a2 - *(void *)(*(void *)a2 + 224));
    if (BinBlockStreamReader_IsVersionAccepted(v4, 0x10000))
    {
      uint64_t v7 = 0;
      uint64_t v8 = 0;
      uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))a2)(a2 - *(void *)(*(void *)a2 + 224), 1096172613, 0, &v6);
      if (!result)
      {
        uint64_t result = PNEW_EHashTableFSM_Con2(*(void *)(a1 + 104), *(void *)(a1 + 104), v6, (uint64_t *)(a1 + 112));
        if (!result)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2 - *(void *)(*(void *)a2 + 224), v6);
          if (!result)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t, uint64_t *))(*(void *)a2 + 48))(a2 - *(void *)(*(void *)a2 + 224), *(void *)(a1 + 104), 1145128005, 0, 0x10000, a1 + 120, &v7);
            if (!result)
            {
              uint64_t result = PNEW_EBitMap_Con(*(void *)(a1 + 104), *(void *)(a1 + 120), (uint64_t *)(a1 + 128));
              if (!result)
              {
                uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t *, uint64_t *))(*(void *)a2 + 48))(a2 - *(void *)(*(void *)a2 + 224), *(void *)(a1 + 104), 1128547397, 0, 0x10000, &v8, &v7);
                if (!result)
                {
                  *(void *)(a1 + 136) = v8;
                  *(_DWORD *)(a1 + 144) = *(_DWORD *)(*(void *)(*(void *)(a1 + 96) + 8) + 18);
                  *(unsigned char *)(a1 + 147) = 0;
                }
              }
            }
          }
        }
      }
    }
    else
    {
      return err_GenerateErrorVersion();
    }
  }
  else
  {
    return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Wrong Buffer Type");
  }
  return result;
}

uint64_t CDSBase_Des(void *a1)
{
  OOCAllocator_Free(a1[13], a1[17]);
  OOCAllocator_Free(a1[13], a1[15]);
  uint64_t result = OOC_PlacementDeleteObject(a1[13], a1[16]);
  if (!result)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[13], a1[14]);
    if (!result)
    {
      return CDSHash_Des(a1);
    }
  }
  return result;
}

uint64_t CDSBase_GetFieldSeparator(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 96) + 8) + 2);
}

uint64_t CDSBase_GetNbrValueEntries(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 96) + 8) + 16) | (*(unsigned __int16 *)(*(void *)(*(void *)(a1 + 96) + 8) + 14) << 16);
}

uint64_t CDSBase_GetOutputString(uint64_t a1, uint64_t a2, int a3, uint64_t *a4, unsigned int *a5, int *a6, unsigned int *a7)
{
  int v26 = 0;
  *a4 = 0;
  *a5 = 0;
  *a6 = 0;
  *a7 = 0;
  uint64_t result = CDSHash_GetInputHash(a1, a2, a3, &v26, a7);
  unsigned int v27 = result;
  if (!result)
  {
    if (!*a7) {
      return 0;
    }
    int v13 = **(unsigned __int16 **)(*(void *)(a1 + 96) + 8);
    uint64_t v14 = *(void *)(a1 + 128);
    *(void *)(v14 + 16) = (v26 * v13);
    uint64_t NBits = EBitMap_GetNBits(v14, v13);
    uint64_t v16 = OOCAllocator_Malloc(*(void *)(a1 + 104), 2 * *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 96) + 8) + 4), &v27);
    uint64_t result = v27;
    if (!v27)
    {
      unsigned int v17 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 112) + 32))(*(void *)(a1 + 112), NBits, v16);
      uint64_t v18 = OOCAllocator_Malloc(*(void *)(a1 + 104), v17 + 1, &v27);
      uint64_t result = v27;
      if (!v27)
      {
        if (v17)
        {
          int v19 = 0;
          size_t v20 = (unsigned char *)v18;
          uint64_t v21 = (unsigned __int16 *)v16;
          uint64_t v22 = v17;
          do
          {
            unsigned int v23 = *v21++;
            int v24 = *(char *)(*(void *)(a1 + 136) + v23);
            *v20++ = *(unsigned char *)(*(void *)(a1 + 136) + v23);
            if (*(char *)(*(void *)(*(void *)(a1 + 96) + 8) + 2) == v24) {
              ++v19;
            }
            --v22;
          }
          while (v22);
          int v25 = v19 + 1;
        }
        else
        {
          int v25 = 1;
          if (!v16)
          {
LABEL_15:
            *(unsigned char *)(v18 + v17) = 0;
            *a4 = v18;
            *a5 = v17;
            *a6 = v25;
            return v27;
          }
        }
        OOCAllocator_Free(*(void *)(a1 + 104), v16);
        goto LABEL_15;
      }
    }
  }
  return result;
}

uint64_t CDSBase_GetTranscriptionType(uint64_t a1)
{
  return *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 96) + 8) + 22);
}

void *GetCDSBaseClass()
{
  return &__CDSBase;
}

uint64_t EBitMap_AlignAddr(uint64_t result, char a2)
{
  int v2 = *(_DWORD *)(result + 16);
  while ((v2++ & ~(-1 << a2)) != 0)
    ;
  *(void *)(result + 16) = (v2 - 1);
  return result;
}

uint64_t EBitMap_GetNBits(uint64_t a1, int a2)
{
  int v2 = *(_DWORD *)(a1 + 24);
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = v3 + a2;
  *(void *)(a1 + 16) = v4;
  if (v4 <= v3)
  {
    int v5 = 0;
  }
  else
  {
    int v5 = 0;
    unsigned int v6 = v3;
    do
    {
      v5 |= *(unsigned __int8 *)(*(void *)(a1 + 8) + ((unint64_t)v6 >> v2)) >> (v6 & 7) << (v6 - v3);
      unsigned int v6 = (v6 & 0xFFFFFFF8) + 8;
    }
    while (v6 < v4);
  }
  return v5 & ~(-1 << a2);
}

uint64_t PNEW_EBitMap_Con(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = OOCAllocator_Malloc(a1, 32, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = Object_Con((void *)v6);
    if (result)
    {
      unsigned int v8 = result;
      OOCAllocator_Free(a1, v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *(void *)uint64_t v6 = &__EBitMap;
      *(void *)(v6 + 8) = a2;
      *(void *)(v6 + 16) = 0;
      *(_DWORD *)(v6 + 24) = 3;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t EHuffmanBitmap_Decode(uint64_t a1, uint64_t a2)
{
  EHuffman_Reset(a1);
  int v4 = *(_DWORD *)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 16) >> v4;
  uint64_t v6 = *(void *)(a2 + 16) & 7;
  while (EHuffman_Eat(a1))
  {
    if (v6 == 7)
    {
      ++v5;
      LODWORD(v6) = 0;
    }
    else
    {
      LODWORD(v6) = v6 + 1;
    }
  }
  *(void *)(a2 + 16) = ((v5 << v4) | v6) + 1;
  return EHuffman_GetResult(a1);
}

uint64_t PNEW_EHuffmanBitmap_Con2(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  unsigned int v10 = 0;
  unsigned int v8 = (void *)OOCAllocator_Malloc(a1, 64, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = EHuffman_Con2(v8, a2, a3);
    if (result)
    {
      unsigned int v10 = result;
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *unsigned int v8 = &__EHuffmanBitmap;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t _EHashTable_Con(void *a1)
{
  uint64_t result = Object_Con(a1);
  if (!result) {
    *a1 = &__EHashTable;
  }
  return result;
}

void *GetEHashTableClass()
{
  return &__EHashTable;
}

uint64_t EHashTableFSM_Con2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = _EHashTable_Con((void *)a1);
  if (!result)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    *(void *)a1 = &__EHashTableFSM;
    *(void *)(a1 + 96) = a2;
    uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))a3)(a3 - *(void *)(*(void *)a3 + 224), 1313231686, 0, &v7);
    if (!result)
    {
      uint64_t result = PNEW_EHashTableFirstNode_Con2(*(void *)(a1 + 96), *(void *)(a1 + 96), v7, (uint64_t *)(a1 + 8));
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16))(a3 - *(void *)(*(void *)a3 + 224), v7);
        if (!result)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t, uint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), *(void *)(a1 + 96), 1296192326, 0, 0x10000, a1 + 16, &v8);
          if (!result)
          {
            *(_DWORD *)(a1 + 32) = 8 * v8;
            uint64_t result = PNEW_EBitMap_Con(*(void *)(a1 + 96), *(void *)(a1 + 16), (uint64_t *)(a1 + 24));
            if (!result)
            {
              uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))a3)(a3 - *(void *)(*(void *)a3 + 224), 1145656134, 0, &v7);
              if (!result)
              {
                uint64_t result = PNEW_EHuffmanBitmap_Con2(*(void *)(a1 + 96), *(void *)(a1 + 96), v7, (void *)(a1 + 40));
                if (!result)
                {
                  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16))(a3 - *(void *)(*(void *)a3 + 224), v7);
                  if (!result)
                  {
                    uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))a3)(a3 - *(void *)(*(void *)a3 + 224), 1313166150, 0, &v7);
                    if (!result)
                    {
                      uint64_t result = PNEW_EHuffmanBitmap_Con2(*(void *)(a1 + 96), *(void *)(a1 + 96), v7, (void *)(a1 + 48));
                      if (!result)
                      {
                        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16))(a3 - *(void *)(*(void *)a3 + 224), v7);
                        if (!result)
                        {
                          uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))a3)(a3 - *(void *)(*(void *)a3 + 224), 1179603782, 0, &v7);
                          if (!result)
                          {
                            uint64_t result = PNEW_EHuffmanBitmap_Con2(*(void *)(a1 + 96), *(void *)(a1 + 96), v7, (void *)(a1 + 56));
                            if (!result)
                            {
                              uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16))(a3 - *(void *)(*(void *)a3 + 224), v7);
                              if (!result)
                              {
                                uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))a3)(a3 - *(void *)(*(void *)a3 + 224), 1095258950, 0, &v7);
                                if (!result)
                                {
                                  uint64_t result = PNEW_EHuffmanBitmap_Con2(*(void *)(a1 + 96), *(void *)(a1 + 96), v7, (void *)(a1 + 64));
                                  if (!result)
                                  {
                                    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16))(a3 - *(void *)(*(void *)a3 + 224), v7);
                                    if (!result)
                                    {
                                      uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, void, uint64_t *))a3)(a3 - *(void *)(*(void *)a3 + 224), 1229738822, 0, &v7);
                                      if (!result)
                                      {
                                        uint64_t result = PNEW_EHuffmanBitmap_Con2(*(void *)(a1 + 96), *(void *)(a1 + 96), v7, (void *)(a1 + 72));
                                        if (!result)
                                        {
                                          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 16))(a3 - *(void *)(*(void *)a3 + 224), v7);
                                          if (!result)
                                          {
                                            uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t, uint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), *(void *)(a1 + 96), 1329812294, 0, 0x10000, a1 + 80, &v8);
                                            if (!result) {
                                              return PNEW_FSMConstants_Con(*(void *)(a1 + 96), *(unsigned __int16 **)(a1 + 80), (uint64_t *)(a1 + 88));
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t EHashTableFSM_Des(void *a1)
{
  uint64_t result = _EHashTableFSM_Cleanup(a1);
  if (!result)
  {
    return Object_Des();
  }
  return result;
}

uint64_t _EHashTableFSM_Cleanup(void *a1)
{
  uint64_t v2 = a1[11];
  if (v2)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[12], v2);
    if (result) {
      return result;
    }
    a1[11] = 0;
  }
  OOCAllocator_Free(a1[12], a1[10]);
  a1[10] = 0;
  uint64_t v4 = a1[9];
  if (v4)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[12], v4);
    if (result) {
      return result;
    }
    a1[9] = 0;
  }
  uint64_t v5 = a1[8];
  if (v5)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[12], v5);
    if (result) {
      return result;
    }
    a1[8] = 0;
  }
  uint64_t v6 = a1[7];
  if (v6)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[12], v6);
    if (result) {
      return result;
    }
    a1[7] = 0;
  }
  uint64_t v7 = a1[6];
  if (v7)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[12], v7);
    if (result) {
      return result;
    }
    a1[6] = 0;
  }
  uint64_t v8 = a1[5];
  if (v8)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[12], v8);
    if (result) {
      return result;
    }
    a1[5] = 0;
  }
  uint64_t v9 = a1[3];
  if (v9)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[12], v9);
    if (result) {
      return result;
    }
    a1[3] = 0;
  }
  OOCAllocator_Free(a1[12], a1[2]);
  a1[2] = 0;
  uint64_t v10 = a1[1];
  if (!v10) {
    return 0;
  }
  uint64_t result = OOC_PlacementDeleteObject(a1[12], v10);
  if (!result) {
    a1[1] = 0;
  }
  return result;
}

uint64_t EHashTableFSM_Hash(uint64_t *a1, unsigned __int16 *a2, unsigned int a3, int *a4)
{
  return EHashTableFSM_HashLongestMatch(a1, a2, a3, a4, 0);
}

uint64_t EHashTableFSM_HashLongestMatch(uint64_t *a1, unsigned __int16 *a2, unsigned int a3, int *a4, unsigned int *a5)
{
  unsigned int v53 = 0;
  *a4 = 0;
  if (a5) {
    *a5 = 0;
  }
  uint64_t result = EHashTableFirstNode_Hash(a1[1], *a2, a4, &v53);
  if (result)
  {
    unsigned int v11 = v53;
    uint64_t v12 = a1[11];
    if (v53 <= *(unsigned __int8 *)(v12 + 18))
    {
      unsigned int v11 = *(_DWORD *)(v12 + 8);
      unsigned int v53 = v11;
    }
    if (a3 == 1) {
      return 1;
    }
    unsigned int v47 = a3 - 1;
    long long v48 = a5;
    if (a3)
    {
      long long v50 = a2;
      int v13 = 0;
      unsigned int v14 = *(unsigned __int16 *)(v12 + 14);
      unsigned int v51 = *(unsigned __int16 *)(v12 + 12);
      unsigned int v52 = 0;
      unsigned int v15 = 1;
      unint64_t v16 = v11;
      unsigned int v49 = a3;
      while (1)
      {
        uint64_t v17 = a1[3];
        *(void *)(v17 + 16) = v16;
        unsigned int v18 = EHuffmanBitmap_Decode(a1[5], v17);
        unsigned int v19 = v18;
        if (v18 < v51) {
          break;
        }
        if (v18 != v51)
        {
          if (v18 - v51 <= 1) {
            int v22 = 1;
          }
          else {
            int v22 = v18 - v51;
          }
          unsigned int v23 = v15 + v22;
          do
          {
            unsigned int v24 = v14;
            if (v15 < a3) {
              unsigned int v24 = v50[v15];
            }
            unsigned __int16 v25 = EHuffmanBitmap_Decode(a1[6], a1[3]);
            if (v14 == v25)
            {
              int v13 = *a4;
              unsigned int v52 = v15;
            }
            if (v24 != v25) {
              goto LABEL_77;
            }
            ++v15;
            --v22;
          }
          while (v22);
          unsigned int v15 = v23;
        }
        if (v15 == a3) {
          goto LABEL_75;
        }
        unint64_t v26 = EHuffmanBitmap_Decode(a1[9], a1[3]);
        unint64_t v16 = v26;
        uint64_t v27 = a1[11];
        unint64_t v28 = *(unsigned __int8 *)(v27 + 18);
        if (v26 > v28) {
          unint64_t v16 = v26 << *(unsigned char *)(v27 + 16);
        }
        if (v16)
        {
          if (v16 <= v28)
          {
            uint64_t v29 = a1[3];
LABEL_70:
            EBitMap_AlignAddr(v29, *(unsigned char *)(v27 + 16));
            unint64_t v16 = *(void *)(a1[3] + 16);
          }
        }
        else
        {
          int LeafWidth = EHuffman_GetLeafWidth(a1[9]);
          unint64_t v16 = EBitMap_GetNBits(a1[3], LeafWidth) << *(unsigned char *)(a1[11] + 16);
        }
LABEL_71:
        if (v15 > a3)
        {
          unsigned int v11 = v53;
          goto LABEL_74;
        }
      }
      unsigned int v20 = v14;
      if (v15 < a3) {
        unsigned int v20 = v50[v15];
      }
      int v21 = EHuffmanBitmap_Decode(a1[6], a1[3]);
      if (v14 == (unsigned __int16)v21)
      {
        int v13 = *a4;
        if (v20 == v14)
        {
          unsigned int v52 = v15;
LABEL_43:
          unsigned int v35 = 1;
          if (v19 >= 2)
          {
            while (1)
            {
              if (v20 <= (unsigned __int16)v21) {
                goto LABEL_57;
              }
              v21 += EHuffmanBitmap_Decode(a1[7], a1[3]);
              if (v14 != (unsigned __int16)v21) {
                break;
              }
              int v13 = *a4;
              if (v14 != v20)
              {
                int v39 = v13 + 1;
                unsigned int v52 = v15;
LABEL_55:
                *a4 = v39;
                goto LABEL_56;
              }
              unsigned int v52 = v15;
LABEL_56:
              if (++v35 >= v19) {
                goto LABEL_57;
              }
            }
            unint64_t v36 = EHuffmanBitmap_Decode(a1[9], a1[3]);
            unint64_t v16 = v36;
            uint64_t v37 = a1[11];
            if (v36 > *(unsigned __int8 *)(v37 + 18)) {
              unint64_t v16 = v36 << *(unsigned char *)(v37 + 16);
            }
            if (!v16)
            {
              int v38 = EHuffman_GetLeafWidth(a1[9]);
              unint64_t v16 = EBitMap_GetNBits(a1[3], v38) << *(unsigned char *)(a1[11] + 16);
            }
            if (v20 == (unsigned __int16)v21) {
              goto LABEL_56;
            }
            int v39 = *a4 + EHuffmanBitmap_Decode(a1[8], a1[3]);
            goto LABEL_55;
          }
LABEL_57:
          if (v20 != (unsigned __int16)v21) {
            goto LABEL_77;
          }
          ++v15;
          a3 = v49;
          if (v15 == v49) {
            goto LABEL_75;
          }
          if (v16 > *(unsigned __int8 *)(a1[11] + 18)) {
            goto LABEL_71;
          }
          EHuffmanBitmap_Decode(a1[8], a1[3]);
          BOOL v40 = v19 >= v35;
          unsigned int v41 = v19 - v35;
          if (v41 != 0 && v40)
          {
            do
            {
              v20 += EHuffmanBitmap_Decode(a1[7], a1[3]);
              if (v14 != (unsigned __int16)v20)
              {
                unint64_t v42 = EHuffmanBitmap_Decode(a1[9], a1[3]);
                uint64_t v43 = a1[11];
                if (v42 > *(unsigned __int8 *)(v43 + 18)) {
                  v42 <<= *(unsigned char *)(v43 + 16);
                }
                if (!v42)
                {
                  int v44 = EHuffman_GetLeafWidth(a1[9]);
                  EBitMap_GetNBits(a1[3], v44);
                }
                EHuffmanBitmap_Decode(a1[8], a1[3]);
              }
              --v41;
            }
            while (v41);
          }
          uint64_t v29 = a1[3];
          uint64_t v27 = a1[11];
          goto LABEL_70;
        }
        int v33 = v13 + 1;
        unsigned int v52 = v15;
      }
      else
      {
        unint64_t v30 = EHuffmanBitmap_Decode(a1[9], a1[3]);
        unint64_t v16 = v30;
        uint64_t v31 = a1[11];
        if (v30 > *(unsigned __int8 *)(v31 + 18)) {
          unint64_t v16 = v30 << *(unsigned char *)(v31 + 16);
        }
        if (!v16)
        {
          int v32 = EHuffman_GetLeafWidth(a1[9]);
          unint64_t v16 = EBitMap_GetNBits(a1[3], v32) << *(unsigned char *)(a1[11] + 16);
        }
        if (v20 == (unsigned __int16)v21) {
          goto LABEL_43;
        }
        int v33 = *a4 + EHuffmanBitmap_Decode(a1[8], a1[3]);
      }
      *a4 = v33;
      goto LABEL_43;
    }
    int v13 = 0;
    unsigned int v52 = 0;
LABEL_74:
    if (v11 == 1)
    {
LABEL_75:
      long long v45 = v48;
      if (!v48) {
        return 1;
      }
      uint64_t result = 1;
      unsigned int v46 = v47;
    }
    else
    {
LABEL_77:
      uint64_t result = 0;
      *a4 = v13;
      long long v45 = v48;
      unsigned int v46 = v52;
      if (!v48) {
        return result;
      }
    }
    *long long v45 = v46;
  }
  return result;
}

uint64_t EHashTableFSM_Unhash(uint64_t *a1, unsigned int a2, _WORD *a3)
{
  unsigned int v3 = a3;
  unsigned int v47 = 0;
  unsigned int v48 = a2;
  EHashTableFirstNode_Unhash(a1[1], &v48, a3, &v47);
  unsigned int v5 = v47;
  uint64_t v6 = a1[11];
  if (v47 <= *(unsigned __int8 *)(v6 + 18))
  {
    uint64_t v7 = *(unsigned int *)(v6 + 8);
    *(void *)(a1[3] + 16) = v7;
    if (v5 >= 2)
    {
      unsigned int v8 = 1;
      do
      {
        _EHashTableFSM_SkipState(a1);
        ++v8;
      }
      while (v8 < v47);
      LODWORD(v7) = *(_DWORD *)(a1[3] + 16);
      uint64_t v6 = a1[11];
    }
    unsigned int v47 = v7;
    unsigned int v5 = v7;
  }
  int v9 = *(unsigned __int16 *)(v6 + 14);
  unsigned int v10 = *(unsigned __int16 *)(v6 + 12);
  uint64_t v11 = 1;
  unint64_t v12 = v5;
  int v44 = v3;
  unsigned int v43 = v10;
  do
  {
    while (1)
    {
      while (1)
      {
        uint64_t v13 = a1[3];
        *(void *)(v13 + 16) = v12;
        unsigned int v14 = EHuffmanBitmap_Decode(a1[5], v13);
        if (v14 >= v10) {
          break;
        }
        if (!v14)
        {
          uint64_t v34 = v11;
          goto LABEL_67;
        }
        int v15 = 0;
        int v16 = 0;
        unsigned int v46 = v14;
        unsigned int v17 = v14 - 1;
        while (1)
        {
          uint64_t v18 = v16 ? 56 : 48;
          v15 += EHuffmanBitmap_Decode(*(uint64_t *)((char *)a1 + v18), a1[3]);
          if (v9 == (unsigned __int16)v15)
          {
            unint64_t v19 = 1;
          }
          else
          {
            unint64_t v20 = EHuffmanBitmap_Decode(a1[9], a1[3]);
            unint64_t v12 = v20;
            uint64_t v21 = a1[11];
            if (v20 > *(unsigned __int8 *)(v21 + 18)) {
              unint64_t v12 = v20 << *(unsigned char *)(v21 + 16);
            }
            if (!v12)
            {
              int LeafWidth = EHuffman_GetLeafWidth(a1[9]);
              unint64_t v12 = EBitMap_GetNBits(a1[3], LeafWidth) << *(unsigned char *)(a1[11] + 16);
            }
            unint64_t v19 = EHuffmanBitmap_Decode(a1[8], a1[3]);
            if (v19 >= v48)
            {
              uint64_t v23 = a1[11];
              if (v12 <= *(unsigned __int8 *)(v23 + 18))
              {
                uint64_t v24 = a1[3];
                uint64_t v45 = *(void *)(v24 + 16);
                if (v16 + 1 < v46)
                {
                  unsigned int v25 = v17;
                  int v26 = v15;
                  do
                  {
                    v26 += EHuffmanBitmap_Decode(a1[7], a1[3]);
                    if (v9 != (unsigned __int16)v26)
                    {
                      unint64_t v27 = EHuffmanBitmap_Decode(a1[9], a1[3]);
                      uint64_t v28 = a1[11];
                      if (v27 > *(unsigned __int8 *)(v28 + 18)) {
                        v27 <<= *(unsigned char *)(v28 + 16);
                      }
                      if (!v27)
                      {
                        int v29 = EHuffman_GetLeafWidth(a1[9]);
                        EBitMap_GetNBits(a1[3], v29);
                      }
                      EHuffmanBitmap_Decode(a1[8], a1[3]);
                    }
                    --v25;
                  }
                  while (v25);
                  uint64_t v24 = a1[3];
                  uint64_t v23 = a1[11];
                }
                EBitMap_AlignAddr(v24, *(unsigned char *)(v23 + 16));
                if (v12 >= 2)
                {
                  unsigned int v30 = 2;
                  do
                    _EHashTableFSM_SkipState(a1);
                  while (v12 > v30++);
                }
                uint64_t v32 = a1[3];
                unint64_t v12 = *(void *)(v32 + 16);
                *(void *)(v32 + 16) = v45;
              }
            }
          }
          unsigned int v33 = v48;
          if (v19 >= v48) {
            break;
          }
          v48 -= v19;
          ++v16;
          --v17;
          if (v16 == v46)
          {
            uint64_t v34 = v11;
            unsigned int v3 = v44;
            unsigned int v10 = v43;
            goto LABEL_67;
          }
        }
        unsigned int v3 = v44;
        if (v44) {
          v44[v11] = v15;
        }
        *(void *)(a1[3] + 16) = v12;
        unsigned int v10 = v43;
        if (v9 != (unsigned __int16)v15)
        {
          uint64_t v34 = (v11 + 1);
          goto LABEL_67;
        }
        unsigned int v48 = v33 - 1;
        if (v33 == 1) {
          return v11;
        }
      }
      if (v14 != v10) {
        break;
      }
LABEL_49:
      --v48;
      uint64_t v11 = (v11 - 1);
      if (!v48) {
        return v11;
      }
    }
    if (v14 - v10 <= 1) {
      int v35 = 1;
    }
    else {
      int v35 = v14 - v10;
    }
    uint64_t v34 = (v11 + v35);
    do
    {
      unsigned __int16 v36 = EHuffmanBitmap_Decode(a1[6], a1[3]);
      if (v3) {
        v3[v11] = v36;
      }
      LODWORD(v11) = v11 + 1;
      --v35;
    }
    while (v35);
    if (v9 == v36)
    {
      LODWORD(v11) = v34;
      goto LABEL_49;
    }
    unint64_t v37 = EHuffmanBitmap_Decode(a1[9], a1[3]);
    unint64_t v12 = v37;
    uint64_t v38 = a1[11];
    unint64_t v39 = *(unsigned __int8 *)(v38 + 18);
    if (v37 > v39) {
      unint64_t v12 = v37 << *(unsigned char *)(v38 + 16);
    }
    if (v12)
    {
      if (v12 <= v39)
      {
        EBitMap_AlignAddr(a1[3], *(unsigned char *)(v38 + 16));
        if (v12 >= 2)
        {
          unsigned int v40 = 1;
          do
          {
            _EHashTableFSM_SkipState(a1);
            ++v40;
          }
          while (v40 < v12);
        }
        unint64_t v12 = *(void *)(a1[3] + 16);
      }
    }
    else
    {
      int v41 = EHuffman_GetLeafWidth(a1[9]);
      unint64_t v12 = EBitMap_GetNBits(a1[3], v41) << *(unsigned char *)(a1[11] + 16);
    }
LABEL_67:
    uint64_t v11 = v34;
  }
  while (v48);
  return v11;
}

uint64_t _EHashTableFSM_SkipState(uint64_t *a1)
{
  unsigned int v2 = EHuffmanBitmap_Decode(a1[5], a1[3]);
  uint64_t v3 = a1[11];
  int v4 = *(unsigned __int16 *)(v3 + 14);
  LODWORD(v3) = *(unsigned __int16 *)(v3 + 12);
  BOOL v5 = v2 >= v3;
  unsigned int v6 = v2 - v3;
  if (v5)
  {
    if (v6)
    {
      int v15 = v6 <= 1 ? 1 : v6;
      do
      {
        unsigned __int16 v16 = EHuffmanBitmap_Decode(a1[6], a1[3]);
        --v15;
      }
      while (v15);
      if (v4 != v16)
      {
        unint64_t v17 = EHuffmanBitmap_Decode(a1[9], a1[3]);
        uint64_t v18 = a1[11];
        if (v17 > *(unsigned __int8 *)(v18 + 18)) {
          v17 <<= *(unsigned char *)(v18 + 16);
        }
        if (!v17)
        {
          int LeafWidth = EHuffman_GetLeafWidth(a1[9]);
          EBitMap_GetNBits(a1[3], LeafWidth);
        }
      }
    }
  }
  else
  {
    unsigned __int16 v7 = EHuffmanBitmap_Decode(a1[6], a1[3]);
    if (v4 != v7)
    {
      unint64_t v8 = EHuffmanBitmap_Decode(a1[9], a1[3]);
      uint64_t v9 = a1[11];
      if (v8 > *(unsigned __int8 *)(v9 + 18)) {
        v8 <<= *(unsigned char *)(v9 + 16);
      }
      if (!v8)
      {
        int v10 = EHuffman_GetLeafWidth(a1[9]);
        EBitMap_GetNBits(a1[3], v10);
      }
      EHuffmanBitmap_Decode(a1[8], a1[3]);
    }
    if (v2 >= 2)
    {
      unsigned int v11 = v2 - 1;
      do
      {
        v7 += EHuffmanBitmap_Decode(a1[7], a1[3]);
        if (v4 != v7)
        {
          unint64_t v12 = EHuffmanBitmap_Decode(a1[9], a1[3]);
          uint64_t v13 = a1[11];
          if (v12 > *(unsigned __int8 *)(v13 + 18)) {
            v12 <<= *(unsigned char *)(v13 + 16);
          }
          if (!v12)
          {
            int v14 = EHuffman_GetLeafWidth(a1[9]);
            EBitMap_GetNBits(a1[3], v14);
          }
          EHuffmanBitmap_Decode(a1[8], a1[3]);
        }
        --v11;
      }
      while (v11);
    }
  }
  uint64_t v20 = a1[3];
  char v21 = *(unsigned char *)(a1[11] + 16);
  return EBitMap_AlignAddr(v20, v21);
}

uint64_t PNEW_EHashTableFSM_Con2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 104, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = EHashTableFSM_Con2(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

uint64_t EHashTableFirstNode_Con2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    unint64_t v8 = 0;
    *(void *)a1 = &__EHashTableFirstNode;
    *(void *)(a1 + 48) = a2;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t, unint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), a2, 1313164870, 0, 0x10000, a1 + 16, &v8);
    if (!result)
    {
      *(_DWORD *)(a1 + 8) = v8 >> 1;
      uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t, unint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), *(void *)(a1 + 48), 1414745670, 0, 0x10000, a1 + 24, &v8);
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, uint64_t, unint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), *(void *)(a1 + 48), 1095257670, 0, 0x10000, a1 + 40, &v8);
        if (!result)
        {
          unint64_t v7 = 4 * (unint64_t)*(unsigned int *)(a1 + 8) / v8;
          *(_DWORD *)(a1 + 32) = v7;
          if ((v7 - 1) >= 2) {
            return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"invalid hash value width");
          }
          else {
            return 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t EHashTableFirstNode_Des(uint64_t *a1)
{
  _EHashTableFirstNode_Cleanup(a1);
  return Object_Des();
}

uint64_t _EHashTableFirstNode_Cleanup(uint64_t *a1)
{
  a1[5] = 0;
  OOCAllocator_Free(a1[6], a1[3]);
  a1[3] = 0;
  OOCAllocator_Free(a1[6], a1[2]);
  a1[2] = 0;
  return 0;
}

uint64_t EHashTableFirstNode_Hash(uint64_t a1, unsigned int a2, _DWORD *a3, _DWORD *a4)
{
  int v4 = *(_DWORD *)(a1 + 8);
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v6 = *(void *)(a1 + 40);
  int v7 = *(_DWORD *)(a1 + 32);
  if (v7 == 1)
  {
    if (v4)
    {
      uint64_t v8 = 0;
      int v9 = 0;
      while (*(unsigned __int16 *)(v5 + 2 * v8) < a2)
      {
        v9 += *(_DWORD *)(v6 + 4 * v8++);
        if (v4 == v8) {
          return 0;
        }
      }
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  if (v7 != 2 || !v4)
  {
LABEL_13:
    LODWORD(v8) = 0;
    int v9 = 0;
    goto LABEL_14;
  }
  uint64_t v8 = 0;
  int v9 = 0;
  while (*(unsigned __int16 *)(v5 + 2 * v8) < a2)
  {
    v9 += *(unsigned __int16 *)(v6 + 2 * v8++);
    if (v4 == v8) {
      return 0;
    }
  }
LABEL_14:
  if (v8 == v4 || *(unsigned __int16 *)(v5 + 2 * v8) != a2) {
    return 0;
  }
  *a3 = v9;
  *a4 = *(_DWORD *)(*(void *)(a1 + 24) + 4 * v8);
  return 1;
}

uint64_t EHashTableFirstNode_Unhash(uint64_t result, unsigned int *a2, _WORD *a3, _DWORD *a4)
{
  int v4 = *(unsigned __int16 **)(result + 40);
  unsigned int v5 = *a2 + 1;
  int v6 = *(_DWORD *)(result + 32);
  if (v6 != 1)
  {
    if (v6 == 2)
    {
      unsigned int v7 = *v4;
      if (v5 > v7)
      {
        unsigned int v8 = 0;
        do
        {
          v5 -= v7;
          unsigned int v7 = v4[++v8];
        }
        while (v5 > v7);
        goto LABEL_12;
      }
    }
LABEL_11:
    unsigned int v8 = 0;
    goto LABEL_12;
  }
  unsigned int v9 = *(_DWORD *)v4;
  if (*(_DWORD *)v4 >= v5) {
    goto LABEL_11;
  }
  unsigned int v8 = 0;
  do
  {
    v5 -= v9;
    unsigned int v9 = *(_DWORD *)&v4[2 * ++v8];
  }
  while (v9 < v5);
LABEL_12:
  *a2 = v5;
  if (a3) {
    *a3 = *(_WORD *)(*(void *)(result + 16) + 2 * v8);
  }
  *a4 = *(_DWORD *)(*(void *)(result + 24) + 4 * v8);
  return result;
}

uint64_t PNEW_EHashTableFirstNode_Con2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 56, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = EHashTableFirstNode_Con2(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

uint64_t FSMConstants_Con(uint64_t a1, unsigned __int16 *a2)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__FSMConstants;
    *(_WORD *)(a1 + 12) = bswap32(*a2) >> 16;
    *(_DWORD *)(a1 + 8) = bswap32(*(_DWORD *)((char *)a2 + 7));
    *(_WORD *)(a1 + 14) = bswap32(a2[2]) >> 16;
    *(unsigned char *)(a1 + 16) = *((unsigned char *)a2 + 2);
    *(unsigned char *)(a1 + 17) = *((unsigned char *)a2 + 3);
    *(unsigned char *)(a1 + 18) = *((unsigned char *)a2 + 6);
  }
  return result;
}

uint64_t PNEW_FSMConstants_Con(uint64_t a1, unsigned __int16 *a2, uint64_t *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = OOCAllocator_Malloc(a1, 24, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = FSMConstants_Con(v6, a2);
    unsigned int v8 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *a3 = v6;
    }
  }
  return result;
}

uint64_t _ELeaf_Con(void *a1)
{
  uint64_t result = Object_Con(a1);
  if (!result) {
    *a1 = &__ELeaf;
  }
  return result;
}

void *GetELeafClass()
{
  return &__ELeaf;
}

uint64_t EHuffman_Con2(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    uint64_t v10 = 0;
    *a1 = &__EHuffman;
    a1[7] = a2;
    unsigned int v7 = (unsigned __int16 **)(a1 + 1);
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, void *, uint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), a2, 1381258568, 0, 0x10000, a1 + 1, &v10);
    if (!result)
    {
      int v8 = (*v7)[1];
      if (v8 == 8 || v8 == 16)
      {
        uint64_t result = _EHuffman_CreateTree((uint64_t)a1, (uint64_t)(*v7 + 2), v8, **v7);
        if (!result)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t, void, uint64_t, void *, uint64_t *))(*(void *)a3 + 48))(a3 - *(void *)(*(void *)a3 + 224), a1[7], 1162630472, 0, 0x10000, a1 + 4, &v10);
          if (!result) {
            return _EHuffman_CreateLeafArray((uint64_t)a1, a1[4] + 2, *(unsigned __int16 *)a1[4], v10 - 2);
          }
        }
      }
      else
      {
        return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"invalid width of huffman tree buffer");
      }
    }
  }
  return result;
}

uint64_t _EHuffman_CreateTree(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (a3 == 16)
  {
    uint64_t v6 = 0;
    uint64_t result = PNEW_ETree16_Con(*(void *)(a1 + 56), a2, a4, &v6);
    if (result) {
      return result;
    }
    goto LABEL_6;
  }
  if (a3 == 8)
  {
    uint64_t v6 = 0;
    uint64_t result = PNEW_ETree08_Con(*(void *)(a1 + 56), a2, a4, &v6);
    if (result) {
      return result;
    }
LABEL_6:
    *(void *)(a1 + 24) = v6;
    return result;
  }
  return 0;
}

uint64_t _EHuffman_CreateLeafArray(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = 0;
  uint64_t result = PNEW_ELeaf08_Con(*(void *)(a1 + 56), a2, a3, 8 * a4 / (unint64_t)a3, &v6);
  if (!result) {
    *(void *)(a1 + 48) = v6;
  }
  return result;
}

uint64_t EHuffman_Des(uint64_t *a1)
{
  uint64_t result = _EHuffman_Cleanup(a1);
  if (!result)
  {
    return Object_Des();
  }
  return result;
}

uint64_t _EHuffman_Cleanup(uint64_t *a1)
{
  uint64_t v2 = a1[3];
  if (v2)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[7], v2);
    if (result) {
      return result;
    }
    a1[3] = 0;
  }
  OOCAllocator_Free(a1[7], a1[1]);
  a1[1] = 0;
  uint64_t v4 = a1[6];
  if (v4)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[7], v4);
    if (result) {
      return result;
    }
    a1[6] = 0;
  }
  OOCAllocator_Free(a1[7], a1[4]);
  uint64_t result = 0;
  a1[4] = 0;
  return result;
}

uint64_t EHuffman_Eat(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 24))(*(void *)(a1 + 24));
}

uint64_t EHuffman_GetLeafWidth(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48));
}

uint64_t EHuffman_GetResult(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 48) + 24))(*(void *)(a1 + 48), *(unsigned int *)(*(void *)(a1 + 24) + 12));
}

uint64_t EHuffman_Reset(uint64_t a1)
{
  return ETree_Reset(*(void *)(a1 + 24));
}

void *GetEHuffmanClass()
{
  return &__EHuffman;
}

uint64_t _ETree_Con(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__ETree;
    *(_DWORD *)(a1 + 8) = a3 - 1;
    *(_DWORD *)(a1 + 12) = a3 - 1;
    *(void *)(a1 + 16) = a2;
    *(_DWORD *)(a1 + 24) = a4;
  }
  return result;
}

uint64_t ETree_Reset(uint64_t result)
{
  *(_DWORD *)(result + 12) = *(_DWORD *)(result + 8);
  return result;
}

void *GetETreeClass()
{
  return &__ETree;
}

uint64_t ELeaf08_GetLeafWidth(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t ELeaf08_GetResult(uint64_t a1, int a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  unsigned int v3 = v2 * a2 + v2;
  if (v2 * a2 >= v3)
  {
    int v4 = 0;
  }
  else
  {
    int v4 = 0;
    unsigned int v5 = v2 * a2;
    do
    {
      v4 |= *(unsigned __int8 *)(*(void *)(a1 + 8) + ((unint64_t)v5 >> 3)) >> (v5 & 7) << (v5 - v2 * a2);
      unsigned int v5 = (v5 & 0xFFFFFFF8) + 8;
    }
    while (v5 < v3);
  }
  return v4 & ~(-1 << v2);
}

uint64_t PNEW_ELeaf08_Con(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t *a5)
{
  unsigned int v12 = 0;
  uint64_t v10 = OOCAllocator_Malloc(a1, 24, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = _ELeaf_Con((void *)v10);
    if (result)
    {
      unsigned int v12 = result;
      OOCAllocator_Free(a1, v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *(void *)uint64_t v10 = &__ELeaf08;
      *(void *)(v10 + 8) = a2;
      *(_DWORD *)(v10 + 16) = a3;
      *(_DWORD *)(v10 + 20) = a4;
      *a5 = v10;
    }
  }
  return result;
}

BOOL ETree08_Eat(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  unsigned int v3 = (unsigned __int8 *)(v2 + 2 * *(unsigned int *)(a1 + 12));
  if (!a2) {
    ++v3;
  }
  unsigned int v4 = *v3;
  *(_DWORD *)(a1 + 12) = v4;
  return *(unsigned __int8 *)(v2 + 2 * v4) != 255;
}

uint64_t PNEW_ETree08_Con(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  unsigned int v10 = 0;
  int v8 = (void *)OOCAllocator_Malloc(a1, 32, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = _ETree_Con((uint64_t)v8, a2, a3, 8);
    if (result)
    {
      unsigned int v10 = result;
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *int v8 = &__ETree08;
      *a4 = v8;
    }
  }
  return result;
}

BOOL ETree16_Eat(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  unsigned int v3 = *(unsigned __int16 *)(v2 + 4 * *(unsigned int *)(a1 + 12) + 2 * (a2 == 0));
  *(_DWORD *)(a1 + 12) = v3;
  return *(__int16 *)(v2 + 4 * v3) != -1;
}

uint64_t PNEW_ETree16_Con(uint64_t a1, uint64_t a2, int a3, void *a4)
{
  unsigned int v10 = 0;
  int v8 = (void *)OOCAllocator_Malloc(a1, 32, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = _ETree_Con((uint64_t)v8, a2, a3, 16);
    if (result)
    {
      unsigned int v10 = result;
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *int v8 = &__ETree16;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t fi_init(_WORD *a1, uint64_t a2, _WORD *a3, uint64_t a4, void *a5, int a6, uint64_t a7, uint64_t a8, __int16 a9, unsigned __int8 a10)
{
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  uint64_t v35 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v37);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t inited = InitRsrcFunction(a3, a4, &v36);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t v18 = heap_Calloc(*(void **)(v37 + 8), 1, 16);
  if (!v18) {
    return 2692751370;
  }
  unint64_t v19 = (void *)v18;
  v31[4] = 0;
  v31[0] = a1;
  v31[1] = a2;
  v31[2] = a3;
  v31[3] = a4;
  __strcpy_chk();
  int v32 = a6;
  __int16 v34 = a10;
  __int16 v33 = a9;
  uint64_t ObjcForThisApi_1 = getObjcForThisApi_1(v37, v36);
  AddRefCounteduint64_t Object = objc_GetAddRefCountedObject(ObjcForThisApi_1, a7, (uint64_t (*)(void, void, uint64_t, long long *, uint64_t))fi_ObjcLoad, (void (*)(void, void, long long *))fi_ObjcClose, (uint64_t)v31, &v35);
  if ((AddRefCountedObject & 0x80000000) != 0)
  {
    uint64_t v28 = AddRefCountedObject;
  }
  else
  {
    uint64_t v22 = *(void *)(v35 + 32);
    v19[1] = v22;
    uint64_t v23 = *(uint64_t **)v22;
    if (!parse_fi_binary_model(*(uint64_t **)v22, *(void *)(v22 + 8), v19))
    {
      uint64_t v28 = 0;
      *a5 = v19;
      return v28;
    }
    log_OutText(*v23, (uint64_t)"FastInfer", 0, 0, (uint64_t)"parse binary model failed!", v24, v25, v26, v30);
    uint64_t v27 = getObjcForThisApi_1(v37, v36);
    objc_ReleaseObject(v27, v22 + 16);
    uint64_t v28 = 2692751367;
  }
  heap_Free(*(void **)(v37 + 8), (uint64_t)v19);
  return v28;
}

uint64_t fi_ObjcLoad(_WORD *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v36);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t inited = InitRsrcFunction(*(_WORD **)(a5 + 16), *(void *)(a5 + 24), &v37);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t v11 = 2692751367;
  memcpy(__dst, v36, sizeof(__dst));
  *(_OWORD *)&__dst[32] = *(_OWORD *)(v37 + 32);
  uint64_t v12 = *(unsigned int *)(a5 + 40);
  int v13 = *(unsigned __int8 *)(a5 + 46);
  int v14 = *(unsigned __int16 *)(a5 + 44);
  unint64_t v42 = 0;
  unsigned __int8 v41 = 0;
  uint64_t v40 = 0;
  uint64_t v38 = 0;
  unint64_t v39 = 0;
  uint64_t v15 = heap_Calloc(*(void **)&__dst[8], 1, 272);
  if (v15)
  {
    uint64_t v16 = v15;
    if (fi_rsc_create(__dst, &v38))
    {
LABEL_5:
      if (v38)
      {
        fi_rsc_destroy(v38);
        uint64_t v38 = 0;
      }
      heap_Free(*(void **)&__dst[8], v16);
      goto LABEL_10;
    }
    *(void *)uint64_t v16 = v38;
    if ((ssftriff_reader_ObjOpen(a1, a2, v12, a3, (char *)(a5 + 32), v14 | (v13 << 16), (uint64_t *)&v42) & 0x80000000) != 0)
    {
      uint64_t v11 = 2692751364;
      goto LABEL_5;
    }
    uint64_t v29 = ssftriff_reader_OpenChunk((uint64_t)v42, (unsigned char *)&v40 + 4, (unsigned int *)&v40, &v39, v25, v26, v27, v28);
    uint64_t v33 = v29;
    if ((v29 & 0x80000000) != 0)
    {
      uint64_t v11 = v29;
      goto LABEL_5;
    }
    if (HIDWORD(v40) ^ 0x4D424946 | v41)
    {
      log_OutText(*v38, (uint64_t)"FastInfer", 0, 0, (uint64_t)"not found chunk: %s", v30, v31, v32, (uint64_t)"FIBM");
      goto LABEL_5;
    }
    __int16 v34 = (void *)(*(uint64_t (**)(uint64_t, void))v38[1])(v38[2], v40);
    *(void *)(v16 + 8) = v34;
    if (!v34)
    {
      uint64_t v11 = 2692751370;
      goto LABEL_5;
    }
    memcpy(v34, v39, v40);
    strcpy((char *)(v16 + 16), a3);
    *(void *)(a4 + 32) = v16;
    uint64_t v11 = v33;
  }
  else
  {
    uint64_t v11 = 2692751370;
  }
LABEL_10:
  if (v42)
  {
    ssftriff_reader_CloseChunk((uint64_t)v42);
    ssftriff_reader_ObjClose(v42, v17, v18, v19, v20, v21, v22, v23);
  }
  return v11;
}

uint64_t fi_ObjcClose(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t v8 = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v8);
  if ((result & 0x80000000) == 0)
  {
    unsigned int v5 = *(void **)(a3 + 32);
    if (!v5) {
      return 0;
    }
    uint64_t v6 = v8;
    unsigned int v7 = (void *)*v5;
    if (v5[1])
    {
      (*(void (**)(void))(v7[1] + 48))(v7[2]);
      v5[1] = 0;
    }
    else if (!v7)
    {
LABEL_7:
      heap_Free(*(void **)(v6 + 8), (uint64_t)v5);
      return 0;
    }
    fi_rsc_destroy(v7);
    goto LABEL_7;
  }
  return result;
}

uint64_t getObjcForThisApi_1(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  __s1 = 0;
  if (a2
    && ((paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"clcpppipelinemode", &__s1) & 0x80000000) != 0
     || !__s1
     || !*__s1
     || !strcmp(__s1, "internal")))
  {
    uint64_t v2 = a2;
  }
  return *(void *)(v2 + 48);
}

uint64_t fi_deinit(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (!a3) {
    return 0;
  }
  if (*a3) {
    fi_net_destroy(*a3);
  }
  uint64_t v6 = a3[1];
  uint64_t ObjcForThisApi_1 = getObjcForThisApi_1(a1, a2);
  uint64_t v8 = objc_ReleaseObject(ObjcForThisApi_1, v6 + 16);
  heap_Free(*(void **)(a1 + 8), (uint64_t)a3);
  return v8;
}

uint64_t fi_predict(uint64_t ***a1, const void **a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 2692751360;
  if (!a1) {
    return 2692751367;
  }
  unsigned int v9 = *a1;
  unsigned int v10 = *v9;
  if (!fi_net_predict(v9, a2, a3, a4, a5, a6, a7, a8)) {
    return 0;
  }
  log_OutText(*v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"FI Prediction failed!", v11, v12, v13, v15);
  return v8;
}

double fabs_fdlibm(double a1)
{
  return fabs(a1);
}

BOOL almost_equal_floats(double a1, float a2)
{
  float v2 = fabs((float)(*(float *)&a1 - a2));
  if (v2 < 0.00001) {
    return 1;
  }
  *((float *)&a1 + 1) = a2;
  float32x2_t v4 = vcvt_f32_f64(vabsq_f64(vcvtq_f64_f32(*(float32x2_t *)&a1)));
  if (v4.f32[0] <= v4.f32[1]) {
    v4.f32[0] = v4.f32[1];
  }
  return (float)(v2 / v4.f32[0]) < 0.01;
}

float fast_exp_single(float a1)
{
  return expf(fmaxf(fminf(a1, 80.0), -80.0));
}

void fast_exp(float *a1, int a2, float *a3)
{
  unsigned int v3 = a3;
  float32x2_t v4 = a1;
  if (((a3 | a1) & 0x1F) != 0)
  {
    if (a2 >= 1)
    {
      uint64_t v5 = a2;
      do
      {
        float v6 = *v4++;
        *v3++ = expf(fmaxf(fminf(v6, 80.0), -80.0));
        --v5;
      }
      while (v5);
    }
  }
  else if (a2 >= 1)
  {
    uint64_t v7 = a2;
    do
    {
      float v8 = *v4++;
      *v3++ = expf(fmaxf(fminf(v8, 80.0), -80.0));
      --v7;
    }
    while (v7);
  }
}

float Q_rsqrt(float a1)
{
  return (float)((float)((float)((float)(a1 * -0.5) * COERCE_FLOAT(1597463174 - (SLODWORD(a1) >> 1)))
                       * COERCE_FLOAT(1597463174 - (SLODWORD(a1) >> 1)))
               + 1.5)
       * COERCE_FLOAT(1597463174 - (SLODWORD(a1) >> 1));
}

float Q_powf_1_75(float a1)
{
  return (float)(a1 * a1)
       * (float)((float)((float)((float)((float)(a1 * -0.25)
                                       * (float)(COERCE_FLOAT(1331219312 - (SLODWORD(a1) >> 2))
                                               * COERCE_FLOAT(1331219312 - (SLODWORD(a1) >> 2))))
                               * (float)(COERCE_FLOAT(1331219312 - (SLODWORD(a1) >> 2))
                                       * COERCE_FLOAT(1331219312 - (SLODWORD(a1) >> 2))))
                       + 1.25)
               * COERCE_FLOAT(1331219312 - (SLODWORD(a1) >> 2)));
}

float *fill_array_f32(float *result, unsigned int a2, float a3)
{
  if ((result & 0x1F) != 0)
  {
    if (a2)
    {
      uint64_t v3 = a2;
      do
      {
        *result++ = a3;
        --v3;
      }
      while (v3);
    }
  }
  else if (a2)
  {
    uint64_t v4 = a2;
    do
    {
      *result++ = a3;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t max_array_f32(uint64_t result, float *a2, float *a3)
{
  if (((a3 | a2) & 0x1F) != 0)
  {
    if (result)
    {
      uint64_t v3 = result;
      do
      {
        if (*a3 > *a2) {
          *a2 = *a3;
        }
        ++a2;
        ++a3;
        --v3;
      }
      while (v3);
    }
  }
  else if (result)
  {
    uint64_t v4 = result;
    do
    {
      if (*a3 > *a2) {
        *a2 = *a3;
      }
      ++a2;
      ++a3;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t relu_array_f32(uint64_t result, float *a2)
{
  if ((a2 & 0x1F) != 0)
  {
    if (result)
    {
      uint64_t v2 = result;
      do
      {
        if (*a2 < 0.0) {
          *a2 = 0.0;
        }
        ++a2;
        --v2;
      }
      while (v2);
    }
  }
  else if (result)
  {
    uint64_t v3 = result;
    do
    {
      if (*a2 < 0.0) {
        *a2 = 0.0;
      }
      ++a2;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t leaky_array_f32(uint64_t result, float *a2, float a3)
{
  if ((a2 & 0x1F) != 0)
  {
    if (result)
    {
      uint64_t v3 = result;
      do
      {
        if (*a2 < 0.0) {
          *a2 = *a2 * a3;
        }
        ++a2;
        --v3;
      }
      while (v3);
    }
  }
  else if (result)
  {
    uint64_t v4 = result;
    do
    {
      if (*a2 < 0.0) {
        *a2 = *a2 * a3;
      }
      ++a2;
      --v4;
    }
    while (v4);
  }
  return result;
}

float softsign_array_f32(unsigned int a1, float *a2)
{
  if ((a2 & 0x1F) != 0)
  {
    if (a1)
    {
      uint64_t v2 = a1;
      float result = 1.0;
      do
      {
        float v4 = fabs(*a2);
        *a2 = *a2 / (float)(v4 + 1.0);
        ++a2;
        --v2;
      }
      while (v2);
    }
  }
  else if (a1)
  {
    uint64_t v5 = a1;
    float result = 1.0;
    do
    {
      float v6 = fabs(*a2);
      *a2 = *a2 / (float)(v6 + 1.0);
      ++a2;
      --v5;
    }
    while (v5);
  }
  return result;
}

void gmm_c(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a2 >= 1)
  {
    uint64_t v10 = 0;
    uint64_t v11 = a2;
    uint64_t v12 = a1;
    do
    {
      if (a1 >= 1)
      {
        uint64_t v13 = 0;
        float v14 = *(float *)(a5 + 4 * v10) * *(float *)(a5 + 4 * v10);
        float v15 = *(float *)(a3 + 4 * v10)
            * (float)((float)((float)((float)((float)((float)(v14 * 6.2832) * -0.5)
                                            * COERCE_FLOAT(1597463174 - (COERCE_INT(v14 * 6.2832) >> 1)))
                                    * COERCE_FLOAT(1597463174 - (COERCE_INT(v14 * 6.2832) >> 1)))
                            + 1.5)
                    * COERCE_FLOAT(1597463174 - (COERCE_INT(v14 * 6.2832) >> 1)));
        float v16 = 1.0 / (float)((float)(v14 * 2.0) + 1.0e-10);
        do
        {
          float v17 = (float)(int)v13 - *(float *)(a4 + 4 * v10);
          *(float *)(a6 + 4 * v13) = *(float *)(a6 + 4 * v13)
                                   + (float)(v15 * expf(fmaxf(fminf(v16 * (float)-(float)(v17 * v17), 80.0), -80.0)));
          ++v13;
        }
        while (v12 != v13);
      }
      ++v10;
    }
    while (v10 != v11);
  }
}

double exp_fdlibm(double a1)
{
  uint64_t v1 = *(void *)&a1 >> 63;
  uint64_t v2 = HIDWORD(*(void *)&a1) & 0x7FFFFFFFLL;
  if (v2 < 0x40862E42)
  {
    if (v2 < 0x3FD62E43)
    {
      int v8 = 0;
      double v6 = 0.0;
      if (a1 + 1.0e300 > 1.0 && v2 >> 20 <= 0x3E2) {
        return a1 + 1.0;
      }
      double v7 = 0.0;
LABEL_19:
      double v10 = a1
          - a1
          * a1
          * (a1
           * a1
           * (a1 * a1 * (a1 * a1 * (a1 * a1 * 0.000000041381368 + -0.00000165339022) + 0.0000661375632) + -0.00277777778)
           + 0.166666667);
      double v11 = a1 * v10;
      if (v8)
      {
        double v12 = v6 - (v7 - v11 / (2.0 - v10)) + 1.0;
        int v13 = v8 << 20;
        if (v8 < -1021) {
          return COERCE_DOUBLE(COERCE_UNSIGNED_INT64(v6 - (v7 - v11 / (2.0 - v10)) + 1.0) | ((unint64_t)(v13 + 1048576000 + HIDWORD(v12)) << 32))
        }
               * 9.33263619e-302;
        unint64_t v9 = COERCE_UNSIGNED_INT64(v6 - (v7 - v11 / (2.0 - v10)) + 1.0) | ((unint64_t)(v13 + HIDWORD(v12)) << 32);
        return *(double *)&v9;
      }
      a1 = a1 - v11 / (v10 + -2.0);
      return a1 + 1.0;
    }
    if (v2 <= 0x3FF0A2B1)
    {
      double v6 = a1 - dbl_20D6B2E40[v1];
      double v7 = dbl_20D6B2E50[v1];
      int v8 = (a1 >= 0.0) - (*(void *)&a1 >> 63);
LABEL_18:
      a1 = v6 - v7;
      goto LABEL_19;
    }
LABEL_17:
    int v8 = (int)(dbl_20D6B2E30[v1] + a1 * 1.44269504);
    double v6 = a1 + (double)v8 * -0.69314718;
    double v7 = (double)v8 * 1.90821493e-10;
    goto LABEL_18;
  }
  if (v2 >> 20 < 0x7FF)
  {
    if (a1 > 709.782713)
    {
      unint64_t v9 = 0x7FF0000000000000;
      return *(double *)&v9;
    }
    double v4 = 0.0;
    if (a1 < -745.133219) {
      return v4;
    }
    goto LABEL_17;
  }
  int v3 = HIDWORD(a1) & 0xFFFFF | LODWORD(a1);
  double v4 = 0.0;
  if (a1 >= 0.0) {
    double v4 = a1;
  }
  double v5 = a1 + a1;
  if (v3) {
    return v5;
  }
  return v4;
}

double log_fdlibm(double a1)
{
  uint64_t v1 = HIDWORD(*(void *)&a1);
  if (SHIDWORD(a1) >= 0x100000)
  {
    int v2 = -1023;
  }
  else
  {
    if (!(HIDWORD(a1) & 0x7FFFFFFF | LODWORD(a1))) {
      return 4286578690.0;
    }
    if ((*(void *)&a1 & 0x8000000000000000) != 0) {
      return 2147483650.0;
    }
    a1 = a1 * 1.80143985e16;
    uint64_t v1 = HIDWORD(*(void *)&a1);
    int v2 = -1077;
  }
  if ((int)v1 >= 2146435072) {
    return a1 + a1;
  }
  unsigned int v4 = (v1 & 0xFFFFF) + 614244;
  int v5 = v2 + ((int)v1 >> 20) + (v4 >> 20);
  double v6 = COERCE_DOUBLE(LODWORD(a1) | ((unint64_t)((v4 & 0x100000 | v1 & 0xFFFFF) ^ 0x3FF00000) << 32)) + -1.0;
  if (((v1 + 2) & 0xFFFFFu) > 2)
  {
    double v9 = v6 / (v6 + 2.0);
    double v10 = (double)v5;
    double v11 = v9 * v9;
    double v12 = v11 * v11 * (v11 * v11 * (v11 * v11 * 0.153138377 + 0.222221984) + 0.4)
        + v11 * (v11 * v11 * (v11 * v11 * (v11 * v11 * 0.147981986 + 0.181835722) + 0.285714287) + 0.666666667);
    if ((int)(((v1 & 0xFFFFF) - 398458) | (440401 - (v1 & 0xFFFFF))) < 1)
    {
      double v16 = v6 - v12;
      if (!v5) {
        return v6 - v9 * v16;
      }
      double v15 = v10 * -1.90821493e-10 + v9 * v16;
    }
    else
    {
      double v13 = v6 * (v6 * 0.5);
      double v14 = v13 + v12;
      if (!v5)
      {
        double v8 = v13 - v9 * v14;
        return v6 - v8;
      }
      double v15 = v13 - (v10 * 1.90821493e-10 + v9 * v14);
    }
    return -(v15 - v6 - v10 * 0.69314718);
  }
  double v7 = fabs(v6);
  if (v7 >= 1.0e-150 && v7 / fmax(v7, 0.0) >= 0.00000001)
  {
    double v8 = v6 * v6 * (v6 * -0.333333333 + 0.5);
    if (v5) {
      return -(v8 + (double)v5 * -1.90821493e-10 - v6 - (double)v5 * 0.69314718);
    }
    return v6 - v8;
  }
  if (v5) {
    return (double)v5 * 1.90821493e-10 + (double)v5 * 0.69314718;
  }
  else {
    return 0.0;
  }
}

float get_amp(uint64_t a1, float *a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v3 = a3;
    unsigned int v4 = (float *)(a1 + 4);
    do
    {
      float result = sqrtf((float)(*v4 * *v4) + (float)(*(v4 - 1) * *(v4 - 1)));
      *a2++ = result;
      v4 += 2;
      --v3;
    }
    while (v3);
  }
  return result;
}

float reflect_padding(uint64_t a1, int a2, int a3)
{
  if (a3)
  {
    unsigned int v3 = a3 + 1;
    if ((a3 + 1) > 2) {
      uint64_t v4 = (a3 + 1);
    }
    else {
      uint64_t v4 = 2;
    }
    unsigned int v5 = a3 - 1;
    uint64_t v6 = v4 - 1;
    uint64_t v7 = v6;
    do
    {
      *(_DWORD *)(a1 + 4 * v5--) = *(_DWORD *)(a1 + 4 * v3++);
      --v7;
    }
    while (v7);
    unsigned int v8 = a3 + a2;
    unsigned int v9 = a3 + a2 - 2;
    do
    {
      float result = *(float *)(a1 + 4 * v9);
      *(float *)(a1 + 4 * v8++) = result;
      --v9;
      --v6;
    }
    while (v6);
  }
  return result;
}

float interleave(int a1, int *a2, float *a3, uint64_t a4)
{
  if ((((a3 | a2) | a4) & 0x1F) != 0)
  {
    if (a1 >= 1)
    {
      uint64_t v4 = a1;
      unsigned int v5 = (float *)(a4 + 4);
      do
      {
        int v6 = *a2++;
        *((_DWORD *)v5 - 1) = v6;
        float v7 = *a3++;
        float result = v7;
        *unsigned int v5 = v7;
        v5 += 2;
        --v4;
      }
      while (v4);
    }
  }
  else if (a1 >= 1)
  {
    uint64_t v9 = a1;
    double v10 = (float *)(a4 + 4);
    do
    {
      int v11 = *a2++;
      *((_DWORD *)v10 - 1) = v11;
      float v12 = *a3++;
      float result = v12;
      *double v10 = v12;
      v10 += 2;
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t sample_from_pdf(float *a1, int a2, float a3, float a4, float a5)
{
  uint64_t v9 = a2;
  if (a2 <= 0)
  {
    fast_exp(a1, a2, a1);
    float v16 = 1.0e-18;
  }
  else
  {
    uint64_t v10 = 0;
    float v11 = a3 + 1.0;
    do
    {
      a1[v10] = v11 * a1[v10];
      ++v10;
    }
    while (a2 != v10);
    fast_exp(a1, a2, a1);
    float v12 = 0.0;
    uint64_t v13 = v9;
    double v14 = a1;
    do
    {
      float v15 = *v14++;
      float v12 = v12 + v15;
      --v13;
    }
    while (v13);
    float v16 = v12 + 1.0e-18;
  }
  float v17 = 1.0 / v16;
  float v18 = fmaxf(-(float)(a4 - (float)(v17 * *a1)), 0.0);
  *a1 = v18;
  uint64_t result = (a2 - 1);
  if (a2 > 1)
  {
    uint64_t v20 = a1 + 1;
    uint64_t v21 = v9 - 1;
    do
    {
      float v18 = v18 + fmaxf((float)(v17 * *v20) - a4, 0.0);
      *v20++ = v18;
      --v21;
    }
    while (v21);
    uint64_t v22 = 0;
    while ((float)(a1[(int)result] * a5) > a1[v22])
    {
      if (result == ++v22) {
        return result;
      }
    }
    return v22;
  }
  return result;
}

float prepare_cdf(float *a1, unsigned int a2, float a3, float a4)
{
  if (a2)
  {
    uint64_t v7 = 0;
    float v8 = a3 + 1.0;
    uint64_t v9 = a2;
    do
    {
      a1[v7] = v8 * a1[v7];
      ++v7;
    }
    while (a2 != v7);
    fast_exp(a1, a2, a1);
    float v10 = 0.0;
    float v11 = a1;
    do
    {
      float v12 = *v11++;
      float v10 = v10 + v12;
      --v9;
    }
    while (v9);
    float v13 = v10 + 1.0e-18;
  }
  else
  {
    fast_exp(a1, 0, a1);
    float v13 = 1.0e-18;
  }
  float v14 = 1.0 / v13;
  float v15 = fmaxf(-(float)(a4 - (float)(v14 * *a1)), 0.0);
  *a1 = v15;
  if (a2 >= 2)
  {
    float v16 = a1 + 1;
    uint64_t v17 = a2 - 1;
    do
    {
      float v15 = v15 + fmaxf((float)(v14 * *v16) - a4, 0.0);
      *v16++ = v15;
      --v17;
    }
    while (v17);
  }
  return a1[a2 - 1];
}

uint64_t sample_cdf(uint64_t a1, unsigned int a2, float a3)
{
  uint64_t v3 = a2 - 1;
  if (a2 == 1) {
    return 0;
  }
  uint64_t v5 = 0;
  float v6 = *(float *)(a1 + 4 * v3) * a3;
  uint64_t result = a2 >> 1;
  while (*(float *)(a1 + 4 * v5) < v6)
  {
    if (v3 == ++v5) {
      return result;
    }
  }
  return v5;
}

void celt_lpc(void *a1, void *a2, float *a3, unsigned int a4)
{
  float v8 = *a3;
  size_t v9 = 4 * a4;
  bzero(a1, v9);
  bzero(a2, v9);
  if (*a3 != 0.0)
  {
    uint64_t v10 = 0;
    uint64_t v11 = -1;
    do
    {
      if (v10 == a4) {
        break;
      }
      float v12 = 0.0;
      if (v10)
      {
        float v13 = (float *)a1;
        uint64_t v14 = v10;
        do
        {
          float v15 = *v13++;
          float v12 = v12 + (float)(v15 * a3[v14--]);
        }
        while (v14);
      }
      uint64_t v16 = v10 + 1;
      float v17 = (float)-(float)(v12 + a3[(v10 + 1)]) / v8;
      *((float *)a2 + v10) = v17;
      *((float *)a1 + v10) = v17;
      if (((v10 + 1) & 0xFFFFFFFELL) != 0)
      {
        unint64_t v18 = 0;
        uint64_t v19 = v11;
        do
        {
          float v20 = *((float *)a1 + v18);
          float v21 = *((float *)a1 + v19);
          *((float *)a1 + v18) = v20 + (float)(v17 * v21);
          *((float *)a1 + v19) = v21 + (float)(v17 * v20);
          ++v18;
          --v19;
        }
        while (v18 < v16 >> 1);
      }
      float v8 = v8 + (float)((float)-(float)(v17 * v17) * v8);
      ++v11;
      uint64_t v10 = v16;
    }
    while (v8 >= (float)(*a3 * 0.001));
  }
}

float ulaw2lin8(float a1)
{
  float v1 = a1 + -128.0;
  float v2 = flt_20D6B2DF0[v1 >= 0.0];
  return v2 * (float)(expf(fmaxf(fminf((float)(fabsf(v1) * 0.0078125) * 5.5452, 80.0), -80.0)) + -1.0);
}

uint64_t lin2ulaw8(float a1)
{
  float v1 = (float)(fabsf(a1) * 0.007782) + 1.0;
  if (a1 < 0.0) {
    float v2 = -(float)((float)((float)((float)((float)((float)((SLODWORD(v1) >> 23) - 127) + 1.0)
  }
                                        + (float)((float)((float)(COERCE_FLOAT(LODWORD(v1) - (((SLODWORD(v1) >> 23) - 127) << 23))
                                                                + -1.5)
                                                        * (float)((float)((float)(COERCE_FLOAT(LODWORD(v1)- (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* (float)((float)((float)(COERCE_FLOAT(LODWORD(v1) - (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* 0.16541)+ -0.33951))+ 0.95909))+ -0.41445))* 0.69315)* 128.0)/ 5.5452);
  else {
    float v2 = (float)((float)((float)((float)((float)((SLODWORD(v1) >> 23) - 127) + 1.0)
  }
                               + (float)((float)((float)(COERCE_FLOAT(LODWORD(v1) - (((SLODWORD(v1) >> 23) - 127) << 23))
                                                       + -1.5)
                                               * (float)((float)((float)(COERCE_FLOAT(LODWORD(v1)- (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* (float)((float)((float)(COERCE_FLOAT(LODWORD(v1)- (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* 0.16541)+ -0.33951))+ 0.95909))+ -0.41445))* 0.69315)* 128.0)/ 5.5452;
  float v3 = v2 + 128.0;
  if (v3 < 0.0) {
    float v3 = 0.0;
  }
  float v4 = v3 + 0.5;
  BOOL v5 = v3 <= 255.0;
  float v6 = 255.5;
  if (v5) {
    return v4;
  }
  return v6;
}

float ulaw2lin7(float a1)
{
  float v1 = a1 + -64.0;
  float v2 = flt_20D6B2DF8[v1 >= 0.0];
  return v2 * (float)(expf(fmaxf(fminf((float)(fabsf(v1) * 0.015625) * 4.852, 80.0), -80.0)) + -1.0);
}

uint64_t lin2ulaw7(float a1)
{
  float v1 = (float)(fabsf(a1) * 0.0038757) + 1.0;
  if (a1 < 0.0) {
    float v2 = -(float)((float)((float)((float)((float)((float)((SLODWORD(v1) >> 23) - 127) + 1.0)
  }
                                        + (float)((float)((float)(COERCE_FLOAT(LODWORD(v1) - (((SLODWORD(v1) >> 23) - 127) << 23))
                                                                + -1.5)
                                                        * (float)((float)((float)(COERCE_FLOAT(LODWORD(v1)- (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* (float)((float)((float)(COERCE_FLOAT(LODWORD(v1) - (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* 0.16541)+ -0.33951))+ 0.95909))+ -0.41445))* 0.69315)* 64.0)/ 4.852);
  else {
    float v2 = (float)((float)((float)((float)((float)((SLODWORD(v1) >> 23) - 127) + 1.0)
  }
                               + (float)((float)((float)(COERCE_FLOAT(LODWORD(v1) - (((SLODWORD(v1) >> 23) - 127) << 23))
                                                       + -1.5)
                                               * (float)((float)((float)(COERCE_FLOAT(LODWORD(v1)- (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* (float)((float)((float)(COERCE_FLOAT(LODWORD(v1)- (((SLODWORD(v1) >> 23) - 127) << 23))+ -1.5)* 0.16541)+ -0.33951))+ 0.95909))+ -0.41445))* 0.69315)* 64.0)/ 4.852;
  float v3 = v2 + 64.0;
  if (v3 < 0.0) {
    float v3 = 0.0;
  }
  float v4 = v3 + 0.5;
  BOOL v5 = v3 <= 127.0;
  float v6 = 127.5;
  if (v5) {
    return v4;
  }
  return v6;
}

uint64_t opus_fft_alloc_twiddles(uint64_t *a1, unsigned int a2, uint64_t *a3)
{
  *a3 = 0;
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 64))(a1[2], 1, 64);
  uint64_t v10 = v6;
  if (v6)
  {
    *(_DWORD *)uint64_t v6 = a2;
    *(float *)(v6 + 4) = 1.0 / (float)a2;
    uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[1] + 72))(a1[2], 8 * a2);
    *(void *)(v10 + 56) = v11;
    if (v11)
    {
      uint64_t v15 = a2;
      if (a2)
      {
        uint64_t v16 = 0;
        float v17 = (float *)(v11 + 4);
        do
        {
          __float2 v18 = __sincosf_stret((float)(-6.2832 / (float)a2) * (float)v16);
          *(v17 - 1) = v18.__cosval;
          *float v17 = v18.__sinval;
          ++v16;
          v17 += 2;
        }
        while (a2 != v16);
      }
      unsigned int v19 = 0;
      unsigned int v20 = 0;
      *(_DWORD *)(v10 + 8) = -1;
      uint64_t v21 = v10 + 12;
      int v22 = 1;
      unsigned int v23 = a2;
      unsigned int v24 = 4;
      do
      {
        unsigned int v25 = v22;
        unsigned int v26 = v19;
        if (v23 % v24)
        {
          do
          {
            int v27 = v24 + 2;
            if (v24 == 2) {
              int v27 = 3;
            }
            if (v24 == 4) {
              unsigned int v24 = 2;
            }
            else {
              unsigned int v24 = v27;
            }
            if (v24 * v24 > v23 || v24 > 0x7D00) {
              unsigned int v24 = v23;
            }
          }
          while (v23 % v24);
          if (v24 > 5)
          {
            uint64_t v36 = 7;
            goto LABEL_37;
          }
        }
        uint64_t v29 = 2 * v20;
        *(_WORD *)(v21 + 2 * v29) = v24;
        if (v24 == 2 && v20 >= 2)
        {
          *(_WORD *)(v21 + 2 * v29) = 4;
          *(_WORD *)(v10 + 16) = 2;
        }
        v23 /= v24;
        ++v20;
        ++v22;
        unsigned int v19 = v26 + 2;
      }
      while (v23 > 1);
      if (v20 >= 2)
      {
        unint64_t v30 = (unint64_t)v25 >> 1;
        if (v30 <= 1) {
          unint64_t v30 = 1;
        }
        uint64_t v31 = (__int16 *)(v10 + 12);
        do
        {
          __int16 v32 = *v31;
          *uint64_t v31 = *(_WORD *)(v21 + 2 * v26);
          v31 += 2;
          *(_WORD *)(v21 + 2 * v26) = v32;
          v26 -= 2;
          --v30;
        }
        while (v30);
      }
      if (v20)
      {
        uint64_t v33 = 0;
        uint64_t v34 = 2 * v25;
        do
        {
          a2 /= *(unsigned __int16 *)(v21 + 2 * v33);
          *(_WORD *)(v21 + 2 * (v33 + 1)) = a2;
          v33 += 2;
        }
        while (v34 != v33);
      }
      uint64_t v35 = (_WORD *)(*(uint64_t (**)(uint64_t, uint64_t))(a1[1] + 72))(a1[2], 2 * v15);
      *(void *)(v10 + 48) = v35;
      if (v35)
      {
        compute_bitrev_table(0, v35, 1, (unsigned __int16 *)(v10 + 12));
        uint64_t v36 = 0;
        goto LABEL_42;
      }
    }
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v38);
    uint64_t v36 = 10;
LABEL_37:
    if (*(void *)(v10 + 56))
    {
      (*(void (**)(uint64_t))(a1[1] + 80))(a1[2]);
      *(void *)(v10 + 56) = 0;
    }
    if (*(void *)(v10 + 48))
    {
      (*(void (**)(uint64_t))(a1[1] + 80))(a1[2]);
      *(void *)(v10 + 48) = 0;
    }
    (*(void (**)(uint64_t, uint64_t))(a1[1] + 80))(a1[2], v10);
    uint64_t v10 = 0;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v38);
    uint64_t v36 = 10;
  }
LABEL_42:
  *a3 = v10;
  return v36;
}

uint64_t compute_bitrev_table(uint64_t result, _WORD *a2, uint64_t a3, unsigned __int16 *a4)
{
  int v5 = result;
  uint64_t v6 = *a4;
  int v7 = a4[1];
  if (v7 == 1)
  {
    if (*a4)
    {
      int v8 = 0;
      do
      {
        *a2 = v8++ + result;
        a2 += a3;
      }
      while (v6 > (unsigned __int16)v8);
    }
  }
  else if (*a4)
  {
    int v9 = 0;
    uint64_t v10 = a4 + 2;
    uint64_t v11 = v6 * a3;
    uint64_t v12 = 2 * a3;
    do
    {
      uint64_t result = compute_bitrev_table((unsigned __int16)v5, a2, v11, v10);
      v5 += v7;
      ++v9;
      a2 = (_WORD *)((char *)a2 + v12);
    }
    while ((int)v6 > (__int16)v9);
  }
  return result;
}

uint64_t opus_fft_impl(uint64_t result, int8x16_t *a2)
{
  uint64_t v208 = *MEMORY[0x263EF8340];
  uint64_t v2 = 1;
  int v3 = *(_DWORD *)(result + 8);
  v207[0] = 1;
  float v4 = (unsigned __int16 *)(result + 14);
  int v5 = -1;
  int v6 = 1;
  do
  {
    v6 *= *(v4 - 1);
    v207[v2] = v6;
    int v7 = *v4;
    v4 += 2;
    ++v2;
    v5 += 2;
  }
  while (v7 != 1);
  int v202 = v3 & ~(v3 >> 31);
  int v8 = *(unsigned __int16 *)(result + 2 * v5 + 12);
  v206 = &a2->i8[4];
  i32 = (float *)a2[2].i32;
  uint64_t v9 = v2 - 2;
  uint64_t v203 = result;
  do
  {
    unsigned int v10 = v8;
    uint64_t v204 = v9;
    if (v9)
    {
      unsigned int v11 = 2 * v9;
      int v8 = *(unsigned __int16 *)(result + 4 * (int)v9 + 10);
      int v12 = v9;
    }
    else
    {
      unsigned int v11 = 0;
      int v12 = 0;
      int v8 = 1;
    }
    switch(*(_WORD *)(result + 2 * v11 + 12))
    {
      case 2:
        int v13 = v207[v12];
        if (v10 == 1)
        {
          if (v13)
          {
            uint64_t v14 = a2;
            do
            {
              float32x4_t v15 = (float32x4_t)vextq_s8(*v14, *v14, 8uLL);
              v16.i64[0] = vaddq_f32(v15, *(float32x4_t *)v14).u64[0];
              v16.i64[1] = vsubq_f32(v15, *(float32x4_t *)v14).i64[1];
              *v14++ = v16;
              --v13;
            }
            while (v13);
          }
        }
        else
        {
          for (unsigned int i = i32; v13; --v13)
          {
            float v137 = *i;
            float v138 = i[1];
            float v139 = *(i - 8);
            float v140 = *(i - 7);
            float *i = v139 - *i;
            i[1] = v140 - v138;
            *(i - 8) = v137 + v139;
            *(i - 7) = v138 + v140;
            float v141 = i[2];
            float v142 = i[3];
            float v143 = (float)(v141 + v142) * 0.70711;
            float v144 = (float)(v142 - v141) * 0.70711;
            float v145 = *(i - 6);
            float v146 = *(i - 5);
            i[2] = v145 - v143;
            i[3] = v146 - v144;
            *(i - 6) = v145 + v143;
            *(i - 5) = v144 + v146;
            float v148 = i[4];
            float v147 = i[5];
            float v149 = *(i - 4);
            float v150 = *(i - 3);
            i[4] = v149 - v147;
            i[5] = v148 + v150;
            *(i - 4) = v147 + v149;
            *(i - 3) = v150 - v148;
            float v152 = i[6];
            float v151 = i[7];
            float v153 = (float)(v151 - v152) * 0.70711;
            float v154 = (float)(v151 + v152) * -0.70711;
            float v155 = *(i - 2);
            float v156 = *(i - 1);
            i[6] = v155 - v153;
            i[7] = v156 - v154;
            *(i - 2) = v155 + v153;
            *(i - 1) = v154 + v156;
            i += 16;
          }
        }
        break;
      case 3:
        uint64_t v17 = v207[v12];
        if (v17)
        {
          int v18 = 0;
          uint64_t v19 = 0;
          uint64_t v20 = (v17 << v202);
          uint64_t v21 = *(void *)(v203 + 56);
          uint64_t v22 = v10;
          float v23 = *(float *)(v21 + 8 * v20 * (unint64_t)v10 + 4);
          uint64_t v24 = 2 * v10;
          unsigned int v25 = (float *)(v21 + 4);
          uint64_t v26 = 16 * v20;
          uint64_t v27 = 4 * v22;
          uint64_t v28 = 8 * v20;
          do
          {
            uint64_t v29 = v25;
            unint64_t v30 = v25;
            uint64_t v31 = v22;
            __int16 v32 = (float *)&v206[8 * v18];
            do
            {
              uint64_t v33 = &v32[v24];
              float v34 = v32[v24 - 1];
              float v35 = v32[v24];
              float v36 = *(v29 - 1);
              float v37 = (float)(v34 * v36) - (float)(v35 * *v29);
              float v38 = (float)(v36 * v35) + (float)(v34 * *v29);
              unint64_t v39 = &v32[v27];
              float v40 = v32[v27 - 1];
              float v41 = v32[4 * v22];
              float v42 = *(v30 - 1);
              float v43 = (float)(v40 * v42) - (float)(v41 * *v30);
              float v44 = (float)(v42 * v41) + (float)(v40 * *v30);
              float v45 = v38 + v44;
              float v46 = v38 - v44;
              *(v33 - 1) = *(v32 - 1) - (float)((float)(v37 + v43) * 0.5);
              *uint64_t v33 = *v32 - (float)(v45 * 0.5);
              float v47 = v23 * (float)(v37 - v43);
              float v48 = v23 * v46;
              *(v32 - 1) = (float)(v37 + v43) + *(v32 - 1);
              *__int16 v32 = v45 + *v32;
              v32 += 2;
              float v49 = *v33 - v47;
              *(v39 - 1) = v48 + *(v33 - 1);
              *unint64_t v39 = v49;
              float v50 = *(v33 - 1) - v48;
              float v51 = v47 + *v33;
              *(v33 - 1) = v50;
              *uint64_t v33 = v51;
              unint64_t v30 = (float *)((char *)v30 + v26);
              uint64_t v29 = (float *)((char *)v29 + v28);
              --v31;
            }
            while (v31);
            ++v19;
            v18 += v8;
          }
          while (v19 != v17);
        }
        break;
      case 4:
        uint64_t v52 = v207[v12];
        if (v10 == 1)
        {
          if (v52)
          {
            unsigned int v53 = (float *)a2;
            do
            {
              float v54 = v53[1];
              float v55 = v53[4];
              float v56 = v53[5];
              float v57 = *v53 - v55;
              float v58 = v54 - v56;
              float v59 = *v53 + v55;
              float v60 = v54 + v56;
              float v61 = v53[2];
              float v62 = v53[3];
              float v63 = v53[6];
              float v64 = v53[7];
              v53[4] = v59 - (float)(v61 + v63);
              v53[5] = v60 - (float)(v62 + v64);
              *unsigned int v53 = v59 + (float)(v61 + v63);
              v53[1] = v60 + (float)(v62 + v64);
              v53[2] = v57 + (float)(v62 - v64);
              v53[3] = v58 - (float)(v61 - v63);
              v53[6] = v57 - (float)(v62 - v64);
              v53[7] = v58 + (float)(v61 - v63);
              v53 += 8;
              LODWORD(v52) = v52 - 1;
            }
            while (v52);
          }
        }
        else if (v52)
        {
          int v157 = 0;
          uint64_t v158 = 0;
          uint64_t v159 = (v52 << v202);
          uint64_t v160 = *(void *)(v203 + 56) + 4;
          uint64_t v161 = 24 * v159;
          uint64_t v162 = 16 * v159;
          uint64_t v163 = 8 * v159;
          do
          {
            if (v10)
            {
              uint64_t v164 = 0;
              uint64_t v165 = (uint64_t)&v206[8 * v10 + 8 * v157];
              uint64_t v166 = (uint64_t)&v206[16 * v10 + 8 * v157];
              uint64_t v167 = (uint64_t)&v206[24 * v10 + 8 * v157];
              v168 = (float *)v160;
              v169 = (float *)v160;
              v170 = (float *)v160;
              v171 = &v206[8 * v157];
              do
              {
                v172 = (float *)&v171[v164];
                v173 = (float *)(v165 + v164);
                float v174 = *(float *)(v165 + v164 - 4);
                float v175 = *(float *)(v165 + v164);
                float v176 = *(v168 - 1);
                float v177 = (float)(v174 * v176) - (float)(v175 * *v168);
                float v178 = (float)(v176 * v175) + (float)(v174 * *v168);
                v179 = (float *)(v166 + v164);
                float v180 = *(float *)(v166 + v164 - 4);
                float v181 = *(float *)(v166 + v164);
                float v182 = *(v169 - 1);
                float v183 = (float)(v180 * v182) - (float)(v181 * *v169);
                float v184 = (float)(v182 * v181) + (float)(v180 * *v169);
                v185 = (float *)(v167 + v164);
                float v186 = *(float *)(v167 + v164 - 4);
                float v187 = *(float *)(v167 + v164);
                float v188 = *(v170 - 1);
                float v189 = (float)(v186 * v188) - (float)(v187 * *v170);
                float v190 = (float)(v188 * v187) + (float)(v186 * *v170);
                float v191 = *(float *)&v171[v164 - 4];
                float v192 = *(float *)&v171[v164];
                float v193 = v191 - v183;
                float v194 = v192 - v184;
                float v195 = v183 + v191;
                float v196 = v184 + v192;
                float v197 = v177 + v189;
                float v198 = v178 + v190;
                float v199 = v177 - v189;
                float v200 = v178 - v190;
                *(v179 - 1) = v195 - v197;
                float *v179 = v196 - v198;
                *(v172 - 1) = v195 + v197;
                float *v172 = v198 + v196;
                *(v173 - 1) = v193 + v200;
                float *v173 = v194 - v199;
                v164 += 8;
                *(v185 - 1) = v193 - v200;
                float *v185 = v194 + v199;
                v170 = (float *)((char *)v170 + v161);
                v169 = (float *)((char *)v169 + v162);
                v168 = (float *)((char *)v168 + v163);
              }
              while (8 * v10 != v164);
            }
            ++v158;
            v157 += v8;
          }
          while (v158 != v52);
        }
        break;
      case 5:
        uint64_t v65 = v207[v12];
        if (v65)
        {
          int v66 = 0;
          uint64_t v67 = 0;
          uint64_t v68 = (v65 << v202);
          uint64_t v69 = *(void *)(v203 + 56);
          unint64_t v70 = v68 * (unint64_t)v10;
          long long v71 = (float *)(v69 + 8 * v70);
          float v72 = *v71;
          float v73 = v71[1];
          int v74 = (float *)(v69 + 16 * v70);
          float v75 = *v74;
          float v76 = v74[1];
          int v77 = (float *)(v69 + 4);
          uint64_t v78 = 24 * v68;
          uint64_t v79 = 32 * v68;
          uint64_t v80 = 16 * v68;
          uint64_t v81 = 8 * v68;
          do
          {
            if (v10)
            {
              uint64_t v82 = 0;
              uint64_t v83 = (uint64_t)&a2[2 * v10].i64[v66];
              uint64_t v84 = (uint64_t)&a2->i64[3 * v10 + v66];
              uint64_t v85 = (uint64_t)&a2[v10].i64[v66];
              uint64_t v86 = v77;
              uint64_t v87 = (uint64_t)&a2->i64[v10 + v66];
              uint64_t v88 = v77;
              uint64_t v89 = v77;
              long long v90 = v77;
              long long v91 = &a2->i8[8 * v66];
              do
              {
                long long v92 = (float *)(v83 + v82);
                uint64_t v93 = (float *)(v84 + v82);
                int v94 = (float *)(v85 + v82);
                int v95 = (float *)(v87 + v82);
                uint64_t v96 = (float *)&v91[v82];
                float v98 = *(float *)&v91[v82];
                float v97 = *(float *)&v91[v82 + 4];
                float v99 = *(v86 - 1);
                float v100 = *(float *)(v87 + v82);
                float v101 = *(float *)(v87 + v82 + 4);
                float v102 = (float)(v100 * v99) - (float)(v101 * *v86);
                float v103 = (float)(v99 * v101) + (float)(v100 * *v86);
                float v105 = *(float *)(v85 + v82);
                float v104 = *(float *)(v85 + v82 + 4);
                float v106 = *(v88 - 1);
                float v107 = (float)(v105 * v106) - (float)(v104 * *v88);
                float v108 = (float)(v106 * v104) + (float)(v105 * *v88);
                float v109 = *(v90 - 1);
                float v110 = *(float *)(v84 + v82);
                float v111 = *(float *)(v84 + v82 + 4);
                float v112 = (float)(v110 * v109) - (float)(v111 * *v90);
                float v113 = v109 * v111;
                float v114 = *(v89 - 1);
                float v115 = *(float *)(v83 + v82);
                float v116 = *(float *)(v83 + v82 + 4);
                float v117 = v113 + (float)(v110 * *v90);
                float v118 = (float)(v115 * v114) - (float)(v116 * *v89);
                float v119 = (float)(v114 * v116) + (float)(v115 * *v89);
                float v120 = v102 + v118;
                float v121 = v103 + v119;
                float v122 = v102 - v118;
                float v123 = v103 - v119;
                float v124 = v107 + v112;
                float v125 = v108 + v117;
                float v126 = v107 - v112;
                float v127 = v108 - v117;
                *uint64_t v96 = v98 + (float)(v124 + v120);
                v96[1] = v97 + (float)(v125 + v121);
                float v128 = v98 + (float)((float)(v75 * v124) + (float)(v120 * v72));
                float v129 = v97 + (float)((float)(v75 * v125) + (float)(v121 * v72));
                float v130 = (float)(v76 * v127) + (float)(v123 * v73);
                float v131 = (float)(v76 * v126) + (float)(v122 * v73);
                float v132 = v98 + (float)((float)(v72 * v124) + (float)(v120 * v75));
                float v133 = v97 + (float)((float)(v72 * v125) + (float)(v121 * v75));
                float v134 = (float)(v127 * v73) - (float)(v123 * v76);
                *int v95 = v128 - v130;
                v95[1] = v129 + v131;
                float v135 = (float)(v122 * v76) - (float)(v126 * v73);
                *long long v92 = v130 + v128;
                v92[1] = v129 - v131;
                v82 += 8;
                long long v90 = (float *)((char *)v90 + v78);
                *int v94 = v134 + v132;
                v94[1] = v133 + v135;
                *uint64_t v93 = v132 - v134;
                v93[1] = v133 - v135;
                uint64_t v89 = (float *)((char *)v89 + v79);
                uint64_t v88 = (float *)((char *)v88 + v80);
                uint64_t v86 = (float *)((char *)v86 + v81);
              }
              while (8 * v10 != v82);
            }
            ++v67;
            v66 += v8;
          }
          while (v67 != v65);
        }
        break;
      default:
        break;
    }
    uint64_t result = v203;
    uint64_t v9 = v204 - 1;
  }
  while (v204 > 0);
  return result;
}

uint64_t opus_fft_c(unsigned int *a1, float32x2_t *a2, int8x16_t *a3)
{
  uint64_t v3 = *a1;
  if (v3)
  {
    float v4 = (const float *)(a1 + 1);
    int v5 = (unsigned __int16 *)*((void *)a1 + 6);
    float32x2_t v6 = vld1_dup_f32(v4);
    do
    {
      unsigned int v8 = *v5++;
      uint64_t v7 = v8;
      float32x2_t v9 = *a2++;
      *(float32x2_t *)&a3->i8[8 * v7] = vmul_f32(v6, v9);
      --v3;
    }
    while (v3);
  }
  return opus_fft_impl((uint64_t)a1, a3);
}

float window_function(int a1, float a2, float a3)
{
  float v3 = -1.0;
  if (a1 == 1) {
    return 1.0 - fabsf((float)(a2 - (float)((float)(a3 + -1.0) * 0.5)) / (float)(a3 * 0.5));
  }
  if (!a1) {
    return (float)(cosf((float)(a2 * 6.2832) / (float)(a3 + -1.0)) * -0.5) + 0.5;
  }
  return v3;
}

uint64_t fi_stft(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, unsigned int a7, unsigned int a8)
{
  uint64_t v27 = 0;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  uint64_t v14 = a7;
  float32x4_t v15 = (float *)(a2 + 4 * a7);
  int8x16_t v16 = &v15[a7];
  reflect_padding(a3, a5, a7 >> 1);
  uint64_t v17 = fft_plan_dft_r2c_1d(a1, v14, (uint64_t)v16, a4, 3u, (unsigned int *)&v23);
  if (!v17)
  {
    unsigned int v18 = a8 + a8 * (a5 / a8);
    if (v18)
    {
      for (unsigned int i = 0; i < v18; i += a8)
      {
        xmy_toz(a7, v15, (float *)(a3 + 4 * i), v16);
        v21[2] = v25;
        v21[3] = v26;
        uint64_t v22 = v27;
        v21[0] = v23;
        v21[1] = v24;
        fft_execute((unsigned int *)v21);
        *(void *)&long long v25 = v25 + 8 * v14;
      }
    }
    *(void *)&long long v25 = &v16[a7];
  }
  fft_destroy_plan(a1, (uint64_t)&v23);
  return v17;
}

uint64_t fi_istft(uint64_t *a1, float *a2, uint64_t a3, float *a4, unsigned int a5, uint64_t a6, uint64_t a7, unsigned int a8)
{
  LODWORD(v10) = a5;
  int v13 = a1;
  int v14 = a8 * a5;
  int v57 = a7 - a8;
  uint64_t v64 = 0;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  unsigned int v52 = a7 + a8 - 1;
  unsigned int v15 = v52 / a8;
  int v16 = v52 / a8 - 1;
  BOOL v17 = v52 / a8 < a5 && a7 >= a8;
  uint64_t v19 = a1[1];
  uint64_t v18 = a1[2];
  uint64_t v20 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v19 + 16);
  unsigned int v21 = v16 * a8;
  int v55 = a8 * a5 + a7 - a8;
  uint64_t v53 = v16 * a8 + a7;
  if (v17) {
    uint64_t v22 = v21 + a7;
  }
  else {
    uint64_t v22 = a8 * a5 + a7 - a8;
  }
  uint64_t v23 = v20(v18, v22, 4);
  if (v23)
  {
    uint64_t v27 = (float *)v23;
    unsigned int v54 = a8;
    unsigned int v51 = v14;
    uint64_t v28 = &a2[a7];
    uint64_t v29 = fft_plan_dft_c2r_1d((uint64_t)v13, a7, (uint64_t)&v28[a7 + a7], (uint64_t)&v28[a7], 3u, (unsigned int *)&v60);
    if (v29)
    {
      uint64_t v30 = v29;
LABEL_40:
      double v45 = fft_destroy_plan((uint64_t)v13, (uint64_t)&v60);
      (*(void (**)(uint64_t, float *, double))(v13[1] + 48))(v13[2], v27, v45);
      return v30;
    }
    float v50 = a2;
    uint64_t v31 = a7 + (v10 - 1) * v54;
    __int16 v32 = a4;
    bzero(a4, 4 * v31);
    if (v10)
    {
      float v48 = v27;
      float v49 = v13;
      unsigned int v33 = 0;
      int v34 = 0;
      uint64_t v10 = v10;
      uint64_t v35 = v10;
      do
      {
        *(void *)&long long v61 = a3 + 8 * v33;
        v58[2] = v62;
        v58[3] = v63;
        uint64_t v59 = v64;
        v58[0] = v60;
        v58[1] = v61;
        fft_execute((unsigned int *)v58);
        fi_multiply_add_ansic(&a4[v34], &v28[a7], v28, a7);
        v34 += v54;
        v33 += a7;
        --v35;
      }
      while (v35);
      uint64_t v27 = v48;
      int v13 = v49;
      __int16 v32 = a4;
      if (v15 < v10)
      {
        if (a7 < v54)
        {
          log_OutText(*v49, (uint64_t)"FastInfer", 0, 0, (uint64_t)"hop_size > window_size!", v36, v37, v38, (uint64_t)v48);
          uint64_t v30 = 7;
          goto LABEL_40;
        }
        if (v52 >= v54)
        {
          int v41 = 0;
          if (v15 <= 1) {
            uint64_t v42 = 1;
          }
          else {
            uint64_t v42 = v15;
          }
          do
          {
            axpy(a7, v50, 1, &v48[v41], 1, 1.0);
            v41 += v54;
            --v42;
          }
          while (v42);
        }
        uint64_t v43 = v53;
        if (v53)
        {
          float v44 = v48;
          do
          {
            if (*v44 != 0.0) {
              *float v44 = 1.0 / *v44;
            }
            ++v44;
            --v43;
          }
          while (v43);
        }
        xmy(v15 * v54, v48, 1, a4, 1);
        xmy(v57, &v48[v15 * v54], 1, &a4[v51], 1);
        do
        {
          xmy(v54, &v48[v21], 1, &a4[v15 * v54], 1);
          ++v15;
        }
        while (v15 != v10);
LABEL_39:
        uint64_t v30 = 0;
        goto LABEL_40;
      }
      int v39 = 0;
      do
      {
        axpy(a7, v50, 1, &v48[v39], 1, 1.0);
        v39 += v54;
        --v10;
      }
      while (v10);
    }
    if (v31)
    {
      float v40 = v27;
      do
      {
        if (*v40 != 0.0) {
          *float v40 = 1.0 / *v40;
        }
        ++v40;
        --v31;
      }
      while (v31);
    }
    xmy(v55, v27, 1, v32, 1);
    goto LABEL_39;
  }
  log_OutText(*v13, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Memory allocation failed", v24, v25, v26, v47);
  fft_destroy_plan((uint64_t)v13, (uint64_t)&v60);
  return 10;
}

float xmy(int a1, float *a2, int a3, float *a4, int a5)
{
  if ((a2 & 0x1F) != 0)
  {
    if (a1 >= 1)
    {
      uint64_t v5 = a1;
      do
      {
        float result = *a2 * *a4;
        *a4 = result;
        a4 += a5;
        a2 += a3;
        --v5;
      }
      while (v5);
    }
  }
  else if (a1 >= 1)
  {
    uint64_t v7 = a1;
    do
    {
      float result = *a2 * *a4;
      *a4 = result;
      a4 += a5;
      a2 += a3;
      --v7;
    }
    while (v7);
  }
  return result;
}

float xmy_toz(int a1, float *a2, float *a3, float *a4)
{
  if (((a3 | a2) & 0xF) != 0)
  {
    if (a1 >= 1)
    {
      uint64_t v4 = a1;
      do
      {
        float v5 = *a3++;
        float v6 = v5;
        float v7 = *a2++;
        float result = v6 * v7;
        *a4++ = result;
        --v4;
      }
      while (v4);
    }
  }
  else if (a1 >= 1)
  {
    uint64_t v9 = a1;
    do
    {
      float v10 = *a3++;
      float v11 = v10;
      float v12 = *a2++;
      float result = v11 * v12;
      *a4++ = result;
      --v9;
    }
    while (v9);
  }
  return result;
}

float *fi_multiply_add_ansic(float *result, float *a2, float *a3, unsigned int a4)
{
  if (a4)
  {
    uint64_t v4 = a4;
    do
    {
      float v5 = *a2++;
      float v6 = v5;
      float v7 = *a3++;
      *float result = *result + (float)(v6 * v7);
      ++result;
      --v4;
    }
    while (v4);
  }
  return result;
}

float fi_multiply_multiply_add_ansic(float *a1, float *a2, float *a3, float *a4, float *a5, unsigned int a6)
{
  if (a6)
  {
    uint64_t v6 = a6;
    do
    {
      float v7 = *a1++;
      float v8 = v7;
      float v9 = *a2++;
      float v10 = v9;
      float v11 = *a3++;
      float v12 = v11;
      float v13 = *a4++;
      float result = (float)(v12 * v13) + (float)(v8 * v10);
      *a5++ = result;
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t fft_plan_dft_c2r_1d(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int *a6)
{
  *(_OWORD *)a6 = 0u;
  *((_OWORD *)a6 + 1) = 0u;
  *((void *)a6 + 8) = 0;
  *((_OWORD *)a6 + 2) = 0u;
  *((_OWORD *)a6 + 3) = 0u;
  *((void *)a6 + 4) = 0;
  *((void *)a6 + 5) = a4;
  *((void *)a6 + 2) = a3;
  *((void *)a6 + 3) = 0;
  *a6 = a2;
  a6[1] = 2;
  a6[2] = a5;
  uint64_t v9 = (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 64))(*(void *)(a1 + 16));
  *((void *)a6 + 6) = v9;
  if (v9)
  {
    uint64_t v10 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 8) + 64))(*(void *)(a1 + 16), a2, 4);
    *((void *)a6 + 7) = v10;
    if (v10)
    {
      uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(*(void *)(a1 + 8) + 64))(*(void *)(a1 + 16), (unint64_t)(5 * a2) >> 2, 4);
      *((void *)a6 + 8) = v11;
      if (v11)
      {
        float v12 = (_DWORD *)*((void *)a6 + 7);
        *float v12 = 0;
        makewt(*a6 >> 2, v12, v11);
        makect(*a6 >> 2, *((void *)a6 + 7), (float *)(*((void *)a6 + 8) + 4 * ((unint64_t)*a6 >> 2)));
        return 0;
      }
    }
    if (*((void *)a6 + 6))
    {
      (*(void (**)(void))(*(void *)(a1 + 8) + 80))(*(void *)(a1 + 16));
      *((void *)a6 + 6) = 0;
    }
  }
  if (*((void *)a6 + 7))
  {
    (*(void (**)(void))(*(void *)(a1 + 8) + 80))(*(void *)(a1 + 16));
    *((void *)a6 + 7) = 0;
  }
  if (*((void *)a6 + 8))
  {
    (*(void (**)(void))(*(void *)(a1 + 8) + 80))(*(void *)(a1 + 16));
    *((void *)a6 + 8) = 0;
  }
  return 10;
}

void makewt(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  *a2 = a1;
  a2[1] = 1;
  if ((int)a1 >= 3)
  {
    unint64_t v6 = a1 >> 1;
    float v7 = 0.7854 / (float)(int)v6;
    float v8 = cosf(v7 * (float)(int)v6);
    *(_DWORD *)a3 = 1065353216;
    *(float *)(a3 + 4) = v8;
    if (v6 == 4)
    {
      __float2 v9 = __sincosf_stret(v7 + v7);
      *(float *)(a3 + 8) = v9.__cosval;
      *(float *)(a3 + 12) = v9.__sinval;
    }
    else if (a1 >= 0xA)
    {
      makeipt(a1, (uint64_t)a2);
      *(float *)(a3 + 8) = 0.5 / cosf(v7 + v7);
      *(float *)(a3 + 12) = 0.5 / cosf(v7 * 6.0);
      uint64_t v10 = (float *)(a3 + 28);
      unint64_t v11 = 4;
      do
      {
        __float2 v12 = __sincosf_stret(v7 * (float)(int)v11);
        *(v10 - 3) = v12.__cosval;
        *(v10 - 2) = v12.__sinval;
        __float2 v13 = __sincosf_stret((float)(v7 * 3.0) * (float)(int)v11);
        *(v10 - 1) = v13.__cosval;
        *uint64_t v10 = -v13.__sinval;
        v11 += 4;
        v10 += 4;
      }
      while (v11 < v6);
    }
    if (a1 >= 6)
    {
      unsigned int v14 = 0;
      do
      {
        uint64_t v15 = v14 + v6;
        unint64_t v16 = v6 >> 1;
        *(_DWORD *)(a3 + 4 * v15) = 1065353216;
        *(float *)(a3 + 4 * (v15 + 1)) = v8;
        if (v16 == 4)
        {
          int v17 = *(_DWORD *)(a3 + 4 * (v14 + 5));
          *(_DWORD *)(a3 + 4 * (v15 + 2)) = *(_DWORD *)(a3 + 4 * (v14 + 4));
          *(_DWORD *)(a3 + 4 * (v15 + 3)) = v17;
        }
        else if (v6 >= 0xA)
        {
          float v18 = *(float *)(a3 + 4 * (v14 + 6));
          *(float *)(a3 + 4 * (v15 + 2)) = 0.5 / *(float *)(a3 + 4 * (v14 + 4));
          *(float *)(a3 + 4 * (v15 + 3)) = 0.5 / v18;
          uint64_t v19 = (long long *)(a3 + 32 + 4 * v14);
          uint64_t v20 = (_OWORD *)(a3 + 16 + 4 * v15);
          unint64_t v21 = 4;
          do
          {
            long long v22 = *v19;
            v19 += 2;
            *v20++ = v22;
            v21 += 4;
          }
          while (v21 < v16);
        }
        unsigned int v14 = v15;
        BOOL v23 = v6 > 5;
        LODWORD(v6) = v6 >> 1;
      }
      while (v23);
    }
  }
}

void makect(unsigned int a1, uint64_t a2, float *a3)
{
  *(_DWORD *)(a2 + 4) = a1;
  if ((int)a1 >= 2)
  {
    LODWORD(v5) = a1 >> 1;
    float v6 = 0.7854 / (float)(a1 >> 1);
    float v7 = cosf(v6 * (float)(a1 >> 1));
    *a3 = v7;
    a3[v5] = v7 * 0.5;
    if (a1 >= 4)
    {
      if (v5 <= 2) {
        uint64_t v5 = 2;
      }
      else {
        uint64_t v5 = v5;
      }
      uint64_t v8 = 4 * a1 - 4;
      for (uint64_t i = 1; i != v5; ++i)
      {
        __float2 v10 = __sincosf_stret(v6 * (float)(int)i);
        a3[i] = v10.__cosval * 0.5;
        *(float *)((char *)a3 + v8) = v10.__sinval * 0.5;
        v8 -= 4;
      }
    }
  }
}

uint64_t fft_plan_dft_r2c_1d(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int *a6)
{
  *(_OWORD *)a6 = 0u;
  *((_OWORD *)a6 + 1) = 0u;
  *((void *)a6 + 8) = 0;
  *((_OWORD *)a6 + 2) = 0u;
  *((_OWORD *)a6 + 3) = 0u;
  *((void *)a6 + 2) = 0;
  *((void *)a6 + 3) = a3;
  *((void *)a6 + 4) = a4;
  *((void *)a6 + 5) = 0;
  *a6 = a2;
  a6[1] = 1;
  a6[2] = a5;
  uint64_t v9 = (*(uint64_t (**)(void))(*(void *)(a1 + 8) + 64))(*(void *)(a1 + 16));
  *((void *)a6 + 6) = v9;
  if (v9)
  {
    uint64_t v10 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 8) + 64))(*(void *)(a1 + 16), a2, 4);
    *((void *)a6 + 7) = v10;
    if (v10)
    {
      uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(*(void *)(a1 + 8) + 64))(*(void *)(a1 + 16), (unint64_t)(5 * a2) >> 2, 4);
      *((void *)a6 + 8) = v11;
      if (v11)
      {
        __float2 v12 = (_DWORD *)*((void *)a6 + 7);
        *__float2 v12 = 0;
        makewt(*a6 >> 2, v12, v11);
        makect(*a6 >> 2, *((void *)a6 + 7), (float *)(*((void *)a6 + 8) + 4 * ((unint64_t)*a6 >> 2)));
        return 0;
      }
    }
    if (*((void *)a6 + 6))
    {
      (*(void (**)(void))(*(void *)(a1 + 8) + 80))(*(void *)(a1 + 16));
      *((void *)a6 + 6) = 0;
    }
  }
  if (*((void *)a6 + 7))
  {
    (*(void (**)(void))(*(void *)(a1 + 8) + 80))(*(void *)(a1 + 16));
    *((void *)a6 + 7) = 0;
  }
  if (*((void *)a6 + 8))
  {
    (*(void (**)(void))(*(void *)(a1 + 8) + 80))(*(void *)(a1 + 16));
    *((void *)a6 + 8) = 0;
  }
  return 10;
}

float32_t fft_execute(unsigned int *a1)
{
  unint64_t v1 = *a1;
  uint64_t v2 = (float *)*((void *)a1 + 2);
  float v3 = (_DWORD *)*((void *)a1 + 4);
  if (a1[1] == 1)
  {
    uint64_t v4 = (float *)*((void *)a1 + 6);
    uint64_t v5 = (int *)*((void *)a1 + 7);
    uint64_t v6 = *((void *)a1 + 8);
    if (v2)
    {
      memcpy(*((void **)a1 + 6), v2, 4 * (2 * v1));
      float32_t result = cftfsub(2 * v1, (uint64_t)v4, (uint64_t)v5, *v5, v6);
      if ((int)v1 >= 1)
      {
        uint64_t v8 = (float *)(v3 + 1);
        uint64_t v9 = v4 + 1;
        do
        {
          *(v8 - 1) = *(v9 - 1);
          float v10 = *v9;
          v9 += 2;
          float32_t result = -v10;
          *uint64_t v8 = -v10;
          v8 += 2;
          --v1;
        }
        while (v1);
      }
    }
    else
    {
      memcpy(*((void **)a1 + 6), *((const void **)a1 + 3), 4 * v1);
      rdft(v1, 1, v4, v5, v6);
      *float v3 = *(_DWORD *)v4;
      v3[1] = 0;
      unint64_t v17 = v1 >> 1;
      if ((int)v1 >= 4)
      {
        unint64_t v18 = v17 - 1;
        uint64_t v19 = (float *)(v3 + 3);
        uint64_t v20 = v4 + 3;
        do
        {
          *(v19 - 1) = *(v20 - 1);
          float v21 = *v20;
          v20 += 2;
          *uint64_t v19 = -v21;
          v19 += 2;
          --v18;
        }
        while (v18);
      }
      float32_t result = v4[1];
      long long v22 = (float32_t *)&v3[2 * v17];
      *long long v22 = result;
      v22[1] = 0.0;
    }
  }
  else
  {
    uint64_t v11 = *((void *)a1 + 6);
    __float2 v12 = (int *)*((void *)a1 + 7);
    uint64_t v13 = *((void *)a1 + 8);
    if (v3)
    {
      memcpy(*((void **)a1 + 6), v2, 4 * (2 * v1));
      float32_t result = cftbsub(2 * v1, v11, (uint64_t)v12, *v12, v13);
      if ((int)v1 >= 1)
      {
        unsigned int v14 = (float *)(v3 + 1);
        uint64_t v15 = (float *)(v11 + 4);
        do
        {
          *(v14 - 1) = *(v15 - 1);
          float v16 = *v15;
          v15 += 2;
          float32_t result = -v16;
          *unsigned int v14 = -v16;
          v14 += 2;
          --v1;
        }
        while (v1);
      }
    }
    else
    {
      BOOL v23 = (float *)*((void *)a1 + 5);
      *(float *)uint64_t v11 = *v2;
      *(float *)(v11 + 4) = v2[2 * (v1 >> 1)];
      if ((int)v1 >= 4)
      {
        uint64_t v24 = (v1 >> 1) - 1;
        uint64_t v25 = v2 + 3;
        uint64_t v26 = (float *)(v11 + 12);
        do
        {
          *(v26 - 1) = *(v25 - 1);
          float v27 = *v25;
          v25 += 2;
          *uint64_t v26 = -v27;
          v26 += 2;
          --v24;
        }
        while (v24);
      }
      float32_t result = rdft(v1, -1, (float *)v11, v12, v13);
      if ((int)v1 >= 1)
      {
        do
        {
          float v28 = *(float *)v11;
          v11 += 4;
          float32_t result = v28 + v28;
          *v23++ = v28 + v28;
          --v1;
        }
        while (v1);
      }
    }
  }
  return result;
}

double fft_destroy_plan(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + 48))
  {
    (*(void (**)(void))(*(void *)(a1 + 8) + 80))(*(void *)(a1 + 16));
    *(void *)(a2 + 48) = 0;
  }
  if (*(void *)(a2 + 56))
  {
    (*(void (**)(void))(*(void *)(a1 + 8) + 80))(*(void *)(a1 + 16));
    *(void *)(a2 + 56) = 0;
  }
  if (*(void *)(a2 + 64))
  {
    (*(void (**)(void))(*(void *)(a1 + 8) + 80))(*(void *)(a1 + 16));
    *(void *)(a2 + 64) = 0;
  }
  *(void *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 0;
  double result = 0.0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  return result;
}

float32_t cftfsub(unsigned int a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  if ((int)a1 < 9)
  {
    if (a1 == 4)
    {
      v11.i64[0] = *(void *)a2;
      v12.i64[0] = *(void *)(a2 + 8);
      v11.i64[1] = *(void *)a2;
      v12.i64[1] = v12.i64[0];
      *(void *)&long long v13 = vaddq_f32(v11, v12).u64[0];
      float32x4_t v10 = vsubq_f32(v11, v12);
      *((void *)&v13 + 1) = v10.i64[1];
      *(_OWORD *)a2 = v13;
    }
    else if (a1 == 8)
    {
      v10.f32[0] = cftf040((float *)a2);
    }
  }
  else if (a1 < 0x21)
  {
    if (a1 == 32)
    {
      cftf161((float *)a2, (float *)(a5 + 4 * (a4 - 8)));
      *(double *)v10.i64 = bitrv216(a2);
    }
    else
    {
      cftf081((float *)a2, a5);
      v10.i64[0] = *(void *)(a2 + 8);
      *(void *)&long long v14 = *(void *)(a2 + 48);
      uint64_t v15 = *(void *)(a2 + 24);
      *(void *)(a2 + 8) = *(void *)(a2 + 32);
      *((void *)&v14 + 1) = v10.i64[0];
      *(_OWORD *)(a2 + 24) = v14;
      *(void *)(a2 + 48) = v15;
    }
  }
  else
  {
    cftf1st(a1, (float *)a2, (float *)(a5 + 4 * (int)(a4 - (a1 >> 2))));
    if (a1 < 0x201)
    {
      if (a1 < 0x81) {
        cftfx41(a1, (float *)a2, a4, a5);
      }
      else {
        cftleaf(a1, 1, (float *)a2, a4, a5);
      }
    }
    else
    {
      cftrec4(a1, a2, a4, a5);
    }
    v10.f32[0] = bitrv2(a1, a3, a2);
  }
  return v10.f32[0];
}

float32_t cftbsub(unsigned int a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  if ((int)a1 < 9)
  {
    if (a1 == 4)
    {
      v11.i64[0] = *(void *)a2;
      v12.i64[0] = *(void *)(a2 + 8);
      v11.i64[1] = *(void *)a2;
      v12.i64[1] = v12.i64[0];
      *(void *)&long long v13 = vaddq_f32(v11, v12).u64[0];
      float32x4_t v10 = vsubq_f32(v11, v12);
      *((void *)&v13 + 1) = v10.i64[1];
      *(_OWORD *)a2 = v13;
    }
    else if (a1 == 8)
    {
      v10.f32[0] = cftb040((float *)a2);
    }
  }
  else if (a1 < 0x21)
  {
    if (a1 == 32)
    {
      cftf161((float *)a2, (float *)(a5 + 4 * (a4 - 8)));
      *(double *)v10.i64 = bitrv216neg(a2);
    }
    else
    {
      cftf081((float *)a2, a5);
      *(double *)v10.i64 = bitrv208neg(a2);
    }
  }
  else
  {
    cftb1st(a1, (float *)a2, (float *)(a5 + 4 * (int)(a4 - (a1 >> 2))));
    if (a1 < 0x201)
    {
      if (a1 < 0x81) {
        cftfx41(a1, (float *)a2, a4, a5);
      }
      else {
        cftleaf(a1, 1, (float *)a2, a4, a5);
      }
    }
    else
    {
      cftrec4(a1, a2, a4, a5);
    }
    v10.f32[0] = bitrv2conj(a1, a3, a2);
  }
  return v10.f32[0];
}

float32_t rdft(int a1, int a2, float *a3, int *a4, uint64_t a5)
{
  int v9 = a4[1];
  uint64_t v10 = *a4;
  if (a2 < 0)
  {
    float32_t result = (float)(*a3 - a3[1]) * 0.5;
    float v13 = *a3 - result;
    *a3 = v13;
    a3[1] = result;
    if (a1 < 5)
    {
      if (a1 == 4)
      {
        float v20 = a3[2];
        float v21 = a3[3];
        float v22 = result - v21;
        float32_t result = result + v21;
        *a3 = v13 + v20;
        a3[1] = result;
        a3[2] = v13 - v20;
        a3[3] = v22;
      }
    }
    else
    {
      rftbsub(a1, (uint64_t)a3, v9, a5 + 4 * v10);
      return cftbsub(a1, (uint64_t)a3, (uint64_t)a4, v10, a5);
    }
  }
  else
  {
    if (a1 < 5)
    {
      float v11 = *a3;
      if (a1 == 4)
      {
        float v15 = a3[1];
        float v14 = a3[2];
        float v16 = v11 - v14;
        float v17 = a3[3];
        float v11 = v11 + v14;
        a3[1] = v15 + v17;
        a3[2] = v16;
        a3[3] = v15 - v17;
      }
    }
    else
    {
      cftfsub(a1, (uint64_t)a3, (uint64_t)a4, *a4, a5);
      rftfsub(a1, (uint64_t)a3, v9, a5 + 4 * v10);
      float v11 = *a3;
    }
    float v18 = a3[1];
    float v19 = v11 - v18;
    float32_t result = v11 + v18;
    *a3 = result;
    a3[1] = v19;
  }
  return result;
}

float rftfsub(int a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a1 >= 6)
  {
    unint64_t v4 = a1 >> 1;
    int v5 = 2 * a3 / (int)v4;
    uint64_t v6 = (float *)(a4 - 4 * v5 + 4 * a3);
    uint64_t v7 = 4 * v5;
    uint64_t v8 = -4 * v5;
    int v9 = (float *)(a2 + 4 * a1 - 4);
    uint64_t v10 = (float *)(a4 + v7);
    float v11 = (float *)(a2 + 12);
    unint64_t v12 = 2;
    float result = 0.5;
    do
    {
      float v14 = 0.5 - *v6;
      float v15 = *(v11 - 1);
      float v16 = v15 - *(v9 - 1);
      float v17 = *v11 + *v9;
      float v18 = (float)(v14 * v16) - (float)(*v10 * v17);
      float v19 = (float)(*v10 * v16) + (float)(v14 * v17);
      float v20 = *v11 - v19;
      *(v11 - 1) = v15 - v18;
      *float v11 = v20;
      v12 += 2;
      uint64_t v6 = (float *)((char *)v6 + v8);
      float v21 = *v9 - v19;
      *(v9 - 1) = *(v9 - 1) + v18;
      *int v9 = v21;
      v9 -= 2;
      uint64_t v10 = (float *)((char *)v10 + v7);
      v11 += 2;
    }
    while (v12 < v4);
  }
  return result;
}

float rftbsub(int a1, uint64_t a2, int a3, uint64_t a4)
{
  if (a1 >= 6)
  {
    unint64_t v4 = a1 >> 1;
    int v5 = 2 * a3 / (int)v4;
    uint64_t v6 = (float *)(a4 - 4 * v5 + 4 * a3);
    uint64_t v7 = 4 * v5;
    uint64_t v8 = -4 * v5;
    int v9 = (float *)(a2 + 4 * a1 - 4);
    uint64_t v10 = (float *)(a4 + v7);
    float v11 = (float *)(a2 + 12);
    unint64_t v12 = 2;
    float result = 0.5;
    do
    {
      float v14 = 0.5 - *v6;
      float v15 = *(v11 - 1);
      float v16 = v15 - *(v9 - 1);
      float v17 = *v11 + *v9;
      float v18 = (float)(*v10 * v17) + (float)(v14 * v16);
      float v19 = (float)(v14 * v17) - (float)(*v10 * v16);
      float v20 = *v11 - v19;
      *(v11 - 1) = v15 - v18;
      *float v11 = v20;
      v12 += 2;
      uint64_t v6 = (float *)((char *)v6 + v8);
      float v21 = *v9 - v19;
      *(v9 - 1) = *(v9 - 1) + v18;
      *int v9 = v21;
      v9 -= 2;
      uint64_t v10 = (float *)((char *)v10 + v7);
      v11 += 2;
    }
    while (v12 < v4);
  }
  return result;
}

uint64_t makeipt(uint64_t result, uint64_t a2)
{
  *(void *)(a2 + 8) = 0x1000000000;
  if ((int)result >= 33)
  {
    int v2 = 2;
    do
    {
      int v3 = 2 * v2;
      if (v2 < 2 * v2)
      {
        int v4 = 16 * v2;
        int v5 = (_DWORD *)(a2 + 4 * (v2 + (uint64_t)v3));
        uint64_t v6 = (_DWORD *)(a2 + 8 * v2);
        uint64_t v7 = (int *)(a2 + 4 * v2);
        uint64_t v8 = v3 - (uint64_t)v2;
        do
        {
          int v9 = *v7++;
          *v6++ = 4 * v9;
          *v5++ = v4 + 4 * v9;
          --v8;
        }
        while (v8);
      }
      int v2 = v3;
      BOOL v10 = result > 0x83;
      float result = result >> 2;
    }
    while (v10);
  }
  return result;
}

float cftf1st(int a1, float *a2, float *a3)
{
  uint64_t v3 = 2 * (a1 >> 3);
  int v4 = 4 * (a1 >> 3);
  float v5 = a2[v4];
  float v6 = a2[1];
  float v7 = *a2 + v5;
  uint64_t v8 = &a2[4 * (a1 >> 3)];
  float v9 = v8[1];
  float v10 = v6 + v9;
  float v11 = *a2 - v5;
  uint64_t v12 = 2 * (a1 >> 3);
  float v13 = a2[v12];
  float v14 = v6 - v9;
  float v15 = a2[6 * (a1 >> 3)];
  float v16 = v13 + v15;
  float v17 = a2[(int)(v3 | 1)];
  int v18 = (6 * (a1 >> 3)) | 1;
  float v19 = a2[v18];
  float v20 = v13 - v15;
  *a2 = v7 + v16;
  a2[1] = v10 + (float)(v17 + v19);
  a2[v12] = v7 - v16;
  a2[(int)(v3 | 1)] = v10 - (float)(v17 + v19);
  a2[v4] = v11 - (float)(v17 - v19);
  v8[1] = v14 + v20;
  a2[6 * (a1 >> 3)] = v11 + (float)(v17 - v19);
  a2[v18] = v14 - v20;
  uint64_t v21 = (uint64_t)a1 >> 3;
  float v22 = a3[1];
  float v23 = a3[2];
  float v24 = a3[3];
  uint64_t v25 = v21 - 2;
  if (a1 < 40)
  {
    float v48 = 0.0;
    float v47 = 1.0;
    float v49 = 1.0;
    float v50 = 0.0;
  }
  else
  {
    uint64_t v26 = 0;
    uint64_t v27 = 24 * v21;
    uint64_t v28 = v27 + 12;
    uint64_t v29 = 4 * v4;
    uint64_t v30 = v29 + 12;
    uint64_t v31 = v29 - 4;
    uint64_t v32 = v27 - 4;
    unsigned int v33 = a3 + 7;
    uint64_t v34 = 24 * (a1 >> 3) + 16;
    uint64_t v35 = 2 * (a1 >> 3);
    uint64_t v36 = v35 * 4 - 8;
    uint64_t v37 = 8 * v3 + 16;
    uint64_t v38 = 8 * v3 - 8;
    uint64_t v39 = 12 * v3 - 8;
    float v40 = 1.0;
    float v41 = 0.0;
    float v42 = 0.0;
    uint64_t v43 = 16 * v3 - 16;
    uint64_t v44 = 2;
    uint64_t v45 = (v3 << 34) - 0x200000000;
    float v46 = 1.0;
    do
    {
      float v47 = v33[v26 - 3];
      float v48 = v33[v26 - 2];
      float v49 = v33[v26 - 1];
      float v50 = v33[v26];
      float v51 = v40 + v49;
      unsigned int v52 = &a2[v26];
      uint64_t v53 = (float *)((char *)a2 + v37);
      float v54 = *(float *)((char *)a2 + v37 - 8);
      float v55 = a2[v26 + 2];
      float v56 = a2[v26 + 3];
      float v57 = v41 + v50;
      float v58 = v55 + v54;
      float v59 = *(float *)((char *)a2 + v30);
      float v60 = v56 + v59;
      float v61 = v55 - v54;
      float v62 = v56 - v59;
      float v63 = a2[v26 + 4];
      float v64 = a2[v26 + 5];
      float v65 = *(float *)((char *)a2 + v37);
      float v66 = *(float *)((char *)a2 + v37 + 4);
      float v67 = v63 + v65;
      float v68 = v64 + v66;
      float v69 = v63 - v65;
      float v70 = v64 - v66;
      long long v71 = &a2[v35];
      float v72 = (float *)((char *)a2 + v34);
      float v73 = *(float *)((char *)a2 + v34 - 8);
      float v74 = v23 * (float)(v46 + v47);
      float v75 = a2[v35 + 2];
      float v76 = a2[v35 + 3];
      float v77 = v75 + v73;
      float v78 = *(float *)((char *)a2 + v28);
      float v79 = v23 * (float)(v42 + v48);
      float v80 = v76 + v78;
      float v81 = v75 - v73;
      float v82 = v76 - v78;
      float v84 = a2[v35 + 4];
      float v83 = a2[v35 + 5];
      float v85 = v24 * v51;
      float v87 = *(float *)((char *)a2 + v34);
      float v86 = *(float *)((char *)a2 + v34 + 4);
      float v88 = v84 + v87;
      float v89 = v84 - v87;
      float v90 = v24 * v57;
      v52[2] = v58 + v77;
      void v52[3] = v60 + v80;
      v52[4] = v67 + v88;
      v52[5] = v68 + (float)(v83 + v86);
      v71[2] = v58 - v77;
      v71[3] = v60 - v80;
      v71[4] = v67 - v88;
      v71[5] = v68 - (float)(v83 + v86);
      *(v53 - 2) = (float)(v74 * (float)(v61 - v82)) - (float)(v79 * (float)(v62 + v81));
      float v91 = v69 - (float)(v83 - v86);
      *(float *)((char *)a2 + v30) = (float)(v79 * (float)(v61 - v82)) + (float)(v74 * (float)(v62 + v81));
      float v92 = v61 + v82;
      float v93 = v62 - v81;
      *uint64_t v53 = (float)(v47 * v91) - (float)(v48 * (float)(v70 + v89));
      v53[1] = (float)(v48 * v91) + (float)(v47 * (float)(v70 + v89));
      float v94 = (float)((float)(v24 * v57) * v93) + (float)(v85 * v92);
      float v95 = (float)(v85 * v93) - (float)((float)(v24 * v57) * v92);
      float v96 = v69 + (float)(v83 - v86);
      *(v72 - 2) = v94;
      float v97 = v70 - v89;
      *(float *)((char *)a2 + v28) = v95;
      *float v72 = (float)(v50 * v97) + (float)(v49 * v96);
      v72[1] = (float)(v49 * v97) - (float)(v50 * v96);
      float v98 = (float *)((char *)a2 + v36);
      float v99 = (float *)((char *)a2 + v39);
      float v101 = *(float *)((char *)a2 + v39 - 4);
      float v100 = *(float *)((char *)a2 + v39);
      float v102 = *(float *)((char *)a2 + v36);
      float v103 = *(float *)((char *)a2 + v36 + 4);
      float v104 = v102 + v100;
      float v105 = *(float *)((char *)a2 + v32);
      float v106 = v102 - v100;
      float v107 = *(float *)((char *)a2 + v36 - 8);
      float v108 = *(float *)((char *)a2 + v36 - 4);
      float v109 = *(float *)((char *)a2 + v39 - 8);
      float v110 = v107 + v109;
      float v111 = v108 + v101;
      float v112 = v107 - v109;
      float v113 = v108 - v101;
      float v114 = (float *)((char *)a2 + v38);
      float v115 = *(float *)((char *)a2 + v38 - 4);
      float v116 = *(float *)((char *)a2 + v38);
      float v117 = (float *)((char *)a2 + v43);
      float v118 = v103 + v105;
      float v119 = *(float *)((char *)a2 + v43 + 4);
      float v120 = *(float *)((char *)a2 + v43 + 8);
      float v121 = v116 + v120;
      float v122 = *(float *)((char *)a2 + v31);
      float v123 = v103 - v105;
      uint64_t v124 = (v45 >> 30) | 4;
      float v125 = *(float *)((char *)a2 + v124);
      float v126 = v116 - v120;
      float v127 = *(float *)((char *)a2 + v38 - 8);
      float v128 = v122 + v125;
      float v129 = *(float *)((char *)a2 + v43);
      float v130 = v127 + v129;
      float v131 = v122 - v125;
      float v132 = v127 - v129;
      *float v98 = v104 + v121;
      v98[1] = v118 + v128;
      *(v98 - 2) = v110 + v130;
      *(v98 - 1) = v111 + (float)(v115 + v119);
      *float v114 = v104 - v121;
      *(float *)((char *)a2 + v31) = v118 - v128;
      *(v114 - 2) = v110 - v130;
      *(v114 - 1) = v111 - (float)(v115 + v119);
      float v133 = (float)(v79 * (float)(v106 - v131)) - (float)(v74 * (float)(v123 + v126));
      float v134 = (float)(v74 * (float)(v106 - v131)) + (float)(v79 * (float)(v123 + v126));
      float v135 = v106 + v131;
      float v136 = v123 - v126;
      float *v99 = v133;
      *(float *)((char *)a2 + v32) = v134;
      v44 += 4;
      *(v99 - 2) = (float)(v48 * (float)(v112 - (float)(v115 - v119))) - (float)(v47 * (float)(v113 + v132));
      *(v99 - 1) = (float)(v47 * (float)(v112 - (float)(v115 - v119))) + (float)(v48 * (float)(v113 + v132));
      v28 += 16;
      v30 += 16;
      v31 -= 16;
      v26 += 4;
      v34 += 16;
      v117[2] = (float)(v85 * v136) + (float)(v90 * v135);
      v36 -= 16;
      v37 += 16;
      v35 += 4;
      v38 -= 16;
      *(float *)((char *)a2 + v124) = (float)(v90 * v136) - (float)(v85 * v135);
      v39 -= 16;
      v45 -= 0x400000000;
      v43 -= 16;
      float v41 = v50;
      v32 -= 16;
      *float v117 = (float)(v49 * (float)(v113 - v132)) + (float)(v50 * (float)(v112 + (float)(v115 - v119)));
      v117[1] = (float)(v50 * (float)(v113 - v132)) - (float)(v49 * (float)(v112 + (float)(v115 - v119)));
      float v40 = v49;
      float v42 = v48;
      float v46 = v47;
    }
    while (v44 < v25);
  }
  float v137 = v23 * (float)(v22 + v47);
  float v138 = v23 * (float)(v22 + v48);
  float v139 = v24 * (float)(v49 - v22);
  float v140 = v24 * (float)(v50 - v22);
  float v141 = a2[v25];
  float v142 = &a2[5 * v21];
  float v143 = *(v142 - 2);
  float v144 = *(v142 - 1);
  float v145 = v141 + v143;
  float v146 = &a2[v21];
  float v147 = *(v146 - 1);
  float v148 = v147 + v144;
  float v149 = v141 - v143;
  float v150 = v147 - v144;
  float v151 = &a2[3 * (int)v21];
  float v152 = &a2[7 * v21];
  float v153 = *(v152 - 2);
  float v154 = *(v151 - 2);
  float v155 = *(v151 - 1);
  float v156 = v154 + v153;
  int v157 = &a2[7 * v21];
  float v158 = *(v157 - 1);
  float v159 = v154 - v153;
  a2[v25] = v145 + v156;
  *(v146 - 1) = v148 + (float)(v155 + v158);
  *(v151 - 2) = v145 - v156;
  *(v151 - 1) = v148 - (float)(v155 + v158);
  float v160 = v149 - (float)(v155 - v158);
  *(v142 - 2) = (float)(v137 * v160) - (float)(v138 * (float)(v150 + v159));
  *(v142 - 1) = (float)(v138 * v160) + (float)(v137 * (float)(v150 + v159));
  float v161 = v149 + (float)(v155 - v158);
  float v162 = v150 - v159;
  *(v152 - 2) = (float)(v140 * v162) + (float)(v139 * v161);
  *(v157 - 1) = (float)(v139 * v162) - (float)(v140 * v161);
  float v163 = v146[1];
  float v164 = v142[1];
  float v165 = *v146 + *v142;
  float v166 = v163 + v164;
  float v167 = *v146 - *v142;
  float v168 = v163 - v164;
  float v169 = v151[1];
  float v170 = v157[1];
  float v171 = *v151 + *v157;
  float v172 = v169 + v170;
  float v173 = *v151 - *v157;
  float v174 = v169 - v170;
  *float v146 = v165 + v171;
  v146[1] = v166 + v172;
  *float v151 = v165 - v171;
  v151[1] = v166 - v172;
  *float v142 = v22 * (float)((float)(v167 - v174) - (float)(v168 + v173));
  v142[1] = v22 * (float)((float)(v168 + v173) + (float)(v167 - v174));
  float v175 = v167 + v174;
  float v176 = v168 - v173;
  *int v157 = -(float)(v22 * (float)(v176 + v175));
  v157[1] = -(float)(v22 * (float)(v176 - v175));
  float v177 = v146[2];
  float v178 = v146[3];
  float v179 = v142[2];
  float v180 = v142[3];
  float v181 = v177 + v179;
  float v182 = v178 + v180;
  float v183 = v177 - v179;
  float v184 = v178 - v180;
  float v185 = v151[2];
  float v186 = v151[3];
  float v187 = v157[2];
  float v188 = v157[3];
  float v189 = v185 + v187;
  float v190 = v186 + v188;
  float v191 = v185 - v187;
  float v192 = v186 - v188;
  v146[2] = v181 + v189;
  v146[3] = v182 + v190;
  v151[2] = v181 - v189;
  v151[3] = v182 - v190;
  v142[2] = (float)(v138 * (float)(v183 - v192)) - (float)(v137 * (float)(v184 + v191));
  v142[3] = (float)(v137 * (float)(v183 - v192)) + (float)(v138 * (float)(v184 + v191));
  float v193 = v183 + v192;
  float v194 = (float)(v139 * (float)(v184 - v191)) + (float)(v140 * v193);
  float result = (float)(v140 * (float)(v184 - v191)) - (float)(v139 * v193);
  v157[2] = v194;
  v157[3] = result;
  return result;
}

void cftrec4(int a1, uint64_t a2, int a3, uint64_t a4)
{
  int v7 = a1;
  int v8 = a1;
  if (a1 >= 513)
  {
    unsigned int v9 = a1;
    do
    {
      int v8 = v9 >> 2;
      cftmdl1(v9 >> 2, (float *)(a2 + 4 * (int)(v7 - (v9 >> 2))), a4 + 4 * (int)(a3 - (v9 >> 3)));
      BOOL v10 = v9 > 0x803;
      v9 >>= 2;
    }
    while (v10);
  }
  cftleaf(v8, 1, (float *)(a2 + 4 * (v7 - v8)), a3, a4);
  if (v7 - v8 >= 1)
  {
    int v11 = 1;
    do
    {
      int v12 = cfttree(v8, v7 - v8, v11, a2, a3, a4);
      cftleaf(v8, v12, (float *)(a2 + 4 * (-2 * v8 + v7)), a3, a4);
      ++v11;
      v7 -= v8;
    }
    while (v7 - v8 > 0);
  }
}

float cftleaf(int a1, int a2, float *a3, int a4, uint64_t a5)
{
  int v7 = (float *)(a5 + 4 * a4 - 32);
  if (a1 == 512)
  {
    uint64_t v8 = a5 + 4 * a4;
    uint64_t v9 = v8 - 256;
    cftmdl1(128, a3, v8 - 256);
    cftf161(a3, v7);
    BOOL v10 = (float *)(v8 - 128);
    cftf162(a3 + 32, (float *)(v8 - 128));
    cftf161(a3 + 64, v7);
    cftf161(a3 + 96, v7);
    uint64_t v11 = v8 - 512;
    cftmdl2(128, a3 + 128, v11);
    cftf161(a3 + 128, v7);
    cftf162(a3 + 160, v10);
    cftf161(a3 + 192, v7);
    cftf162(a3 + 224, v10);
    cftmdl1(128, a3 + 256, v9);
    cftf161(a3 + 256, v7);
    cftf162(a3 + 288, v10);
    cftf161(a3 + 320, v7);
    cftf161(a3 + 352, v7);
    int v12 = a3 + 384;
    if (a2)
    {
      cftmdl1(128, v12, v9);
      cftf161(a3 + 480, v7);
    }
    else
    {
      cftmdl2(128, v12, v11);
      cftf162(a3 + 480, v10);
    }
    cftf161(a3 + 384, v7);
    cftf162(a3 + 416, v10);
    return cftf161(a3 + 448, v7);
  }
  else
  {
    uint64_t v13 = a5 + 4 * a4;
    uint64_t v14 = v13 - 128;
    cftmdl1(64, a3, v13 - 128);
    cftf081(a3, (uint64_t)v7);
    cftf082(a3 + 16, v7);
    cftf081(a3 + 32, (uint64_t)v7);
    cftf081(a3 + 48, (uint64_t)v7);
    uint64_t v15 = v13 - 256;
    cftmdl2(64, a3 + 64, v15);
    cftf081(a3 + 64, (uint64_t)v7);
    cftf082(a3 + 80, v7);
    cftf081(a3 + 96, (uint64_t)v7);
    cftf082(a3 + 112, v7);
    cftmdl1(64, a3 + 128, v14);
    cftf081(a3 + 128, (uint64_t)v7);
    cftf082(a3 + 144, v7);
    cftf081(a3 + 160, (uint64_t)v7);
    cftf081(a3 + 176, (uint64_t)v7);
    float v16 = a3 + 192;
    if (a2)
    {
      cftmdl1(64, v16, v14);
      cftf081(a3 + 240, (uint64_t)v7);
    }
    else
    {
      cftmdl2(64, v16, v15);
      cftf082(a3 + 240, v7);
    }
    cftf081(a3 + 192, (uint64_t)v7);
    cftf082(a3 + 208, v7);
    return cftf081(a3 + 224, (uint64_t)v7);
  }
}

float cftfx41(int a1, float *a2, int a3, uint64_t a4)
{
  uint64_t v5 = a4 + 4 * a3;
  float v6 = (float *)(v5 - 32);
  if (a1 == 128)
  {
    uint64_t v8 = a3;
    cftf161(a2, (float *)(v5 - 32));
    cftf162(a2 + 32, (float *)(a4 + 4 * v8 - 128));
    cftf161(a2 + 64, v6);
    return cftf161(a2 + 96, v6);
  }
  else
  {
    cftf081(a2, v5 - 32);
    cftf082(a2 + 16, v6);
    cftf081(a2 + 32, (uint64_t)v6);
    return cftf081(a2 + 48, (uint64_t)v6);
  }
}

float bitrv2(int a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = a1 >> 2;
  if (a1 < 36)
  {
    int v8 = a1 >> 1;
    uint64_t v9 = 4;
    int v4 = 1;
    if (v3 == 8)
    {
LABEL_8:
      uint64_t v10 = 0;
      uint64_t v11 = 8 * v4;
      uint64_t v12 = v4;
      uint64_t v13 = a2 + 4 * v4;
      uint64_t v231 = 2 * (int)v9 + v8;
      uint64_t v232 = v4;
      uint64_t v233 = a2;
      do
      {
        uint64_t v14 = v10 + v12;
        if (v10)
        {
          uint64_t v15 = 0;
          uint64_t v16 = 0;
          uint64_t v234 = v10 + v12;
          uint64_t v17 = *(int *)(a2 + 4 * v14);
          uint64_t v18 = 4 * (int)v10;
          uint64_t v239 = (v9 << 33) + (v17 << 33);
          uint64_t v240 = 8 * v17;
          unint64_t v238 = ((unint64_t)(3 * v9) << 32) + (v17 << 33);
          uint64_t v19 = v231 + (int)v9 + 2 * v17;
          uint64_t v237 = (v19 << 32) + 0x300000000;
          int v236 = 2 * v17;
          int v20 = v9 + 2 * v17;
          int v21 = 2 * (v9 + v17);
          int v22 = 3 * v9 + 2 * v17;
          int v23 = v8 + 3 * v9 + 2 + 2 * v17;
          uint64_t v24 = v231 + 2 * v17;
          uint64_t v25 = (v24 << 32) + 0x300000000;
          uint64_t v26 = (v24 << 32) + 0x200000000;
          uint64_t v27 = (int)v9 + (uint64_t)v8 + 2 * v17;
          uint64_t v28 = (v27 << 32) + 0x300000000;
          uint64_t v29 = (v27 << 32) + 0x200000000;
          uint64_t v30 = 4 * (int)v9 + 8 * v17;
          uint64_t v31 = a3 + 8 * (int)v9 + 8 * v17;
          uint64_t v32 = a3 + 12 * (int)v9 + 8 * v17;
          uint64_t v33 = 4 * v19;
          uint64_t v34 = 4 * v27;
          uint64_t v35 = 4 * v24;
          uint64_t v36 = a3;
          uint64_t v235 = v10;
          uint64_t v37 = 4 * v8 + 8 * v17;
          do
          {
            uint64_t v38 = v13;
            uint64_t v39 = v18 + 2 * *(int *)(v13 + v16);
            float v40 = (_DWORD *)(v36 + v240);
            int v41 = *(_DWORD *)(v36 + v240);
            int v42 = *(_DWORD *)(v36 + v240 + 4);
            uint64_t v43 = (4 * v39) | 4;
            int v44 = *(_DWORD *)(a3 + v43);
            *float v40 = *(_DWORD *)(a3 + 4 * v39);
            v40[1] = v44;
            *(_DWORD *)(a3 + 4 * v39) = v41;
            uint64_t v45 = (int)v39 + (uint64_t)(int)v11;
            float v46 = (_DWORD *)(v36 + v30);
            *(_DWORD *)(a3 + v43) = v42;
            int v47 = *(_DWORD *)(v36 + v30);
            int v48 = *(_DWORD *)(v36 + v30 + 4);
            uint64_t v49 = (4 * v45) | 4;
            int v50 = *(_DWORD *)(a3 + v49);
            *float v46 = *(_DWORD *)(a3 + 4 * v45);
            v46[1] = v50;
            *(_DWORD *)(a3 + 4 * v45) = v47;
            *(_DWORD *)(a3 + v49) = v48;
            int v51 = *(_DWORD *)(v31 + 4 * v16);
            uint64_t v52 = (int)v45 - (uint64_t)(int)v9;
            uint64_t v53 = ((v239 + v15) >> 30) | 4;
            int v54 = *(_DWORD *)(a3 + v53);
            uint64_t v55 = (4 * v52) | 4;
            int v56 = *(_DWORD *)(a3 + v55);
            *(_DWORD *)(v31 + 4 * v16) = *(_DWORD *)(a3 + 4 * v52);
            *(_DWORD *)(a3 + v53) = v56;
            *(_DWORD *)(a3 + 4 * v52) = v51;
            *(_DWORD *)(a3 + v55) = v54;
            uint64_t v57 = v11 + (int)v52;
            int v58 = *(_DWORD *)(v32 + 4 * v16);
            uint64_t v59 = ((uint64_t)(v238 + v15) >> 30) | 4;
            float v60 = (_DWORD *)(a3 + 4 * v57);
            int v61 = *(_DWORD *)(a3 + v59);
            uint64_t v62 = (4 * v57) | 4;
            int v63 = *(_DWORD *)(a3 + v62);
            *(_DWORD *)(v32 + 4 * v16) = *v60;
            *(_DWORD *)(a3 + v59) = v63;
            *float v60 = v58;
            *(_DWORD *)(a3 + v62) = v61;
            v57 += 2;
            float v64 = (_DWORD *)(v36 + v33);
            int v65 = *(_DWORD *)(v36 + v33);
            int v66 = *(_DWORD *)(v36 + v33 + 4);
            int v67 = v60[3];
            *float v64 = *(_DWORD *)(a3 + 4 * v57);
            v64[1] = v67;
            *(_DWORD *)(a3 + 4 * v57) = v65;
            v60[3] = v66;
            uint64_t v68 = (int)v57 - (uint64_t)(int)v11;
            float v69 = (_DWORD *)(v36 + v35);
            int v70 = *(_DWORD *)(v36 + v35);
            int v71 = *(_DWORD *)(v36 + v35 + 4);
            float v72 = (_DWORD *)(a3 + 4 * v68);
            int v73 = v72[1];
            *float v69 = *v72;
            v69[1] = v73;
            *float v72 = v70;
            v72[1] = v71;
            uint64_t v74 = (int)v68 + (uint64_t)(int)v9;
            float v75 = (_DWORD *)(v36 + v34);
            int v76 = *(_DWORD *)(v36 + v34);
            int v77 = *(_DWORD *)(v36 + v34 + 4);
            float v78 = (_DWORD *)(a3 + 4 * v74);
            int v79 = v78[1];
            *float v75 = *v78;
            v75[1] = v79;
            _DWORD *v78 = v76;
            v78[1] = v77;
            uint64_t v80 = (int)v74 - (uint64_t)(int)v11;
            float v81 = (_DWORD *)(v36 + v37);
            int v82 = *(_DWORD *)(v36 + v37);
            int v83 = *(_DWORD *)(v36 + v37 + 4);
            float v84 = (_DWORD *)(a3 + 4 * v80);
            int v85 = v84[1];
            *float v81 = *v84;
            v81[1] = v85;
            *float v84 = v82;
            v84[1] = v83;
            float v86 = (_DWORD *)(a3 + 4 * ((int)v80 + (uint64_t)v8));
            int v87 = *(_DWORD *)(v36 + v37 + 8);
            int v88 = *(_DWORD *)(v36 + v37 + 12);
            int v89 = v86[1];
            v81[2] = *v86;
            v81[3] = v89;
            *float v86 = v87;
            v86[1] = v88;
            uint64_t v90 = (v29 + v15) >> 30;
            int v91 = *(_DWORD *)(a3 + v90);
            uint64_t v92 = (v28 + v15) >> 30;
            int v93 = *(_DWORD *)(a3 + v92);
            uint64_t v94 = (int)v74 + v8;
            float v95 = (_DWORD *)(a3 + 4 * v94);
            int v96 = v95[1];
            *(_DWORD *)(a3 + v90) = *v95;
            *(_DWORD *)(a3 + v92) = v96;
            *float v95 = v91;
            v95[1] = v93;
            uint64_t v97 = v94 - (int)v9;
            uint64_t v98 = (v26 + v15) >> 30;
            int v99 = *(_DWORD *)(a3 + v98);
            uint64_t v100 = (v25 + v15) >> 30;
            int v101 = *(_DWORD *)(a3 + v100);
            float v102 = (_DWORD *)(a3 + 4 * v97);
            int v103 = v102[1];
            *(_DWORD *)(a3 + v98) = *v102;
            *(_DWORD *)(a3 + v100) = v103;
            *float v102 = v99;
            v102[1] = v101;
            uint64_t v104 = (int)v97 + (uint64_t)(int)v11;
            int v105 = *(_DWORD *)(a3 + 4 * (v23 + (int)v16));
            uint64_t v106 = (v237 + v15) >> 30;
            int v107 = *(_DWORD *)(a3 + v106);
            float v108 = (_DWORD *)(a3 + 4 * v104);
            int v109 = v108[1];
            *(_DWORD *)(a3 + 4 * (v23 + (int)v16)) = *v108;
            *(_DWORD *)(a3 + v106) = v109;
            *float v108 = v105;
            v108[1] = v107;
            LODWORD(v106) = v22 + v16 + 2;
            v104 -= 2;
            int v110 = *(_DWORD *)(a3 + 4 * (int)v106);
            LODWORD(v98) = v22 + v16 + 3;
            int v111 = *(_DWORD *)(a3 + 4 * (int)v98);
            int v112 = *(v108 - 1);
            *(_DWORD *)(a3 + 4 * (int)v106) = *(_DWORD *)(a3 + 4 * v104);
            *(_DWORD *)(a3 + 4 * (int)v98) = v112;
            *(_DWORD *)(a3 + 4 * v104) = v110;
            *(v108 - 1) = v111;
            LODWORD(v106) = v21 + v16 + 2;
            int v113 = *(_DWORD *)(a3 + 4 * (int)v106);
            uint64_t v114 = (int)v104 - (uint64_t)(int)v11;
            LODWORD(v98) = v21 + v16 + 3;
            int v115 = *(_DWORD *)(a3 + 4 * (int)v98);
            float v116 = (_DWORD *)(a3 + 4 * v114);
            int v117 = v116[1];
            *(_DWORD *)(a3 + 4 * (int)v106) = *v116;
            *(_DWORD *)(a3 + 4 * (int)v98) = v117;
            *float v116 = v113;
            v116[1] = v115;
            LODWORD(v106) = v20 + v16 + 2;
            int v118 = *(_DWORD *)(a3 + 4 * (int)v106);
            uint64_t v119 = (int)v114 + (uint64_t)(int)v9;
            LODWORD(v98) = v20 + v16 + 3;
            int v120 = *(_DWORD *)(a3 + 4 * (int)v98);
            float v121 = (_DWORD *)(a3 + 4 * v119);
            int v122 = v121[1];
            *(_DWORD *)(a3 + 4 * (int)v106) = *v121;
            *(_DWORD *)(a3 + 4 * (int)v98) = v122;
            *float v121 = v118;
            v121[1] = v120;
            LODWORD(v106) = v236 + v16 + 2;
            int v123 = *(_DWORD *)(a3 + 4 * (int)v106);
            uint64_t v124 = (_DWORD *)(a3 + 4 * ((int)v119 - (uint64_t)(int)v11));
            int v125 = v124[1];
            *(_DWORD *)(a3 + 4 * (int)v106) = *v124;
            LODWORD(v98) = v236 + v16 + 3;
            int v126 = *(_DWORD *)(a3 + 4 * (int)v98);
            *(_DWORD *)(a3 + 4 * (int)v98) = v125;
            uint64_t v13 = v38;
            *uint64_t v124 = v123;
            v124[1] = v126;
            v16 += 4;
            v36 += 16;
            v15 += 0x400000000;
            --v10;
          }
          while (v10);
          uint64_t v12 = v232;
          a2 = v233;
          uint64_t v14 = v234;
          uint64_t v10 = v235;
        }
        else
        {
          LODWORD(v18) = 0;
        }
        uint64_t v127 = 2 * *(int *)(a2 + 4 * v14) + (int)v18;
        uint64_t v128 = v127 + 2;
        uint64_t v129 = (int)v127 + (uint64_t)v8;
        int v130 = *(_DWORD *)(a3 + 4 * (v127 + 2));
        uint64_t v131 = a3 + 4 * v127;
        int v132 = *(_DWORD *)(v131 + 12);
        float v133 = (_DWORD *)(a3 + 4 * v129);
        int v134 = v133[1];
        *(_DWORD *)(a3 + 4 * v128) = *v133;
        *(_DWORD *)(v131 + 12) = v134;
        *float v133 = v130;
        v133[1] = v132;
        uint64_t v135 = (int)v128 + (uint64_t)(int)v9;
        uint64_t v136 = (int)v129 + (uint64_t)(int)v11;
        int v137 = *(_DWORD *)(a3 + 4 * v135);
        uint64_t v138 = (4 * v135) | 4;
        int v139 = *(_DWORD *)(a3 + v138);
        float v140 = (_DWORD *)(a3 + 4 * v136);
        int v141 = v140[1];
        *(_DWORD *)(a3 + 4 * v135) = *v140;
        *(_DWORD *)(a3 + v138) = v141;
        _DWORD *v140 = v137;
        v140[1] = v139;
        uint64_t v142 = (int)v135 + (uint64_t)(int)v9;
        uint64_t v143 = (int)v136 - (uint64_t)(int)v9;
        float v144 = (int *)(a3 + 4 * v142);
        int v145 = *v144;
        uint64_t v146 = (4 * v142) | 4;
        int v147 = *(_DWORD *)(a3 + v146);
        float v148 = (int *)(a3 + 4 * v143);
        int v149 = v148[1];
        *float v144 = *v148;
        *(_DWORD *)(a3 + v146) = v149;
        *float v148 = v145;
        v148[1] = v147;
        int v150 = *(v144 - 2);
        int v151 = *(v144 - 1);
        float v152 = (int *)(a3 + 4 * ((int)v143 - (uint64_t)v8));
        int v153 = v152[1];
        *(v144 - 2) = *v152;
        *(v144 - 1) = v153;
        *float v152 = v150;
        v152[1] = v151;
        float v154 = (int *)(a3 + 4 * ((int)v142 + v8));
        int v155 = *v154;
        int v156 = v154[1];
        int v157 = *(_DWORD *)(a3 + 4 * ((int)v143 + 3));
        *float v154 = *(_DWORD *)(a3 + 4 * ((int)v143 + 2));
        v154[1] = v157;
        *(_DWORD *)(a3 + 4 * ((int)v143 + 2)) = v155;
        *(_DWORD *)(a3 + 4 * ((int)v143 + 3)) = v156;
        LODWORD(v142) = v142 + v9;
        float result = *(float *)(a3 + 4 * (int)v142);
        uint64_t v159 = (4 * (int)v142) | 4;
        int v160 = *(_DWORD *)(a3 + v159);
        float v161 = (_DWORD *)(a3 + 4 * ((int)v143 + (int)v11));
        int v162 = v161[1];
        *(_DWORD *)(a3 + 4 * (int)v142) = *v161;
        *(_DWORD *)(a3 + v159) = v162;
        *(float *)float v161 = result;
        v161[1] = v160;
        ++v10;
      }
      while (v10 != v12);
      return result;
    }
  }
  else
  {
    int v4 = 1;
    do
    {
      int v5 = v4;
      v4 *= 2;
      unsigned int v6 = v3 >> 2;
      BOOL v7 = v3 > 0x23;
      v3 >>= 2;
    }
    while (v7);
    int v8 = a1 >> 1;
    uint64_t v9 = (8 * v5);
    if (v6 == 8)
    {
      if (v4 < 1) {
        return result;
      }
      goto LABEL_8;
    }
    if (v4 < 1) {
      return result;
    }
  }
  uint64_t v163 = 0;
  uint64_t v164 = v4;
  uint64_t v165 = (int)v9;
  uint64_t v166 = v8;
  int v167 = v8 + v9 + 2;
  uint64_t v168 = a3 + 4;
  uint64_t v169 = a2 + 4 * v4;
  uint64_t v170 = v165 + v8;
  do
  {
    uint64_t v171 = v163 + v164;
    if (v163)
    {
      uint64_t v172 = 0;
      int v173 = *(_DWORD *)(a2 + 4 * v171);
      uint64_t v174 = 4 * (int)v163;
      uint64_t v175 = v170 + v173;
      uint64_t v176 = (v175 << 32) + 0x300000000;
      int v177 = v165 + v173;
      int v178 = v167 + v173;
      float v179 = (int *)(v168 + 4 * v173);
      float v180 = (int *)(v168 + 4 * (v165 + v173));
      float v181 = (int *)(a3 + 8 + 4 * (v166 + v173));
      uint64_t v182 = v163;
      float v183 = (int *)(v168 + 4 * v175);
      do
      {
        uint64_t v184 = *(int *)(v169 + v172) + v174;
        int v185 = *(v179 - 1);
        int v186 = *v179;
        float v187 = (int *)(a3 + 4 * v184);
        int v188 = v187[1];
        *(v179 - 1) = *v187;
        int *v179 = v188;
        *float v187 = v185;
        v187[1] = v186;
        uint64_t v189 = v165 + (int)v184;
        int v190 = *(v180 - 1);
        int v191 = *v180;
        float v192 = (int *)(a3 + 4 * v189);
        int v193 = v192[1];
        *(v180 - 1) = *v192;
        *float v180 = v193;
        *float v192 = v190;
        v192[1] = v191;
        int v194 = *(v183 - 1);
        int v195 = *v183;
        int v196 = v192[3];
        *(v183 - 1) = *(_DWORD *)(a3 + 4 * (v189 + 2));
        *float v183 = v196;
        *(_DWORD *)(a3 + 4 * (v189 + 2)) = v194;
        v192[3] = v195;
        uint64_t v197 = (int)v189 + 2 - v165;
        int v198 = *(v181 - 2);
        int v199 = *(v181 - 1);
        float v200 = (int *)(a3 + 4 * v197);
        int v201 = v200[1];
        *(v181 - 2) = *v200;
        *(v181 - 1) = v201;
        *float v200 = v198;
        v200[1] = v199;
        int v202 = (int *)(a3 + 4 * ((int)v197 + (int)v166));
        int v203 = *v181;
        int v204 = v181[1];
        int v205 = v202[1];
        *float v181 = *v202;
        v181[1] = v205;
        v181 += 4;
        *int v202 = v203;
        v202[1] = v204;
        int v206 = *(_DWORD *)(a3 + 4 * (v178 + (int)v172));
        int v207 = *(_DWORD *)(a3 + (v176 >> 30));
        uint64_t v208 = (_DWORD *)(a3 + 4 * ((int)v189 + 2 + (int)v166));
        int v209 = v208[1];
        *(_DWORD *)(a3 + 4 * (v178 + (int)v172)) = *v208;
        *(_DWORD *)(a3 + (v176 >> 30)) = v209;
        *uint64_t v208 = v206;
        v208[1] = v207;
        LODWORD(v208) = v177 + v172 + 2;
        int v210 = *(_DWORD *)(a3 + 4 * (int)v208);
        LODWORD(v202) = v177 + v172 + 3;
        int v211 = *(_DWORD *)(a3 + 4 * (int)v202);
        LODWORD(v189) = v189 + v166;
        v212 = (_DWORD *)(a3 + 4 * (int)v189);
        int v213 = v212[1];
        *(_DWORD *)(a3 + 4 * (int)v208) = *v212;
        *(_DWORD *)(a3 + 4 * (int)v202) = v213;
        _DWORD *v212 = v210;
        v212[1] = v211;
        LODWORD(v208) = v173 + v172 + 2;
        int v214 = *(_DWORD *)(a3 + 4 * (int)v208);
        LODWORD(v202) = v173 + v172 + 3;
        int v215 = *(_DWORD *)(a3 + 4 * (int)v202);
        v216 = (_DWORD *)(a3 + 4 * ((int)v189 - v165));
        int v217 = v216[1];
        *(_DWORD *)(a3 + 4 * (int)v208) = *v216;
        v172 += 4;
        v176 += 0x400000000;
        v179 += 4;
        *(_DWORD *)(a3 + 4 * (int)v202) = v217;
        _DWORD *v216 = v214;
        v216[1] = v215;
        v180 += 4;
        v183 += 4;
        --v182;
      }
      while (v182);
    }
    else
    {
      LODWORD(v174) = 0;
    }
    uint64_t v218 = *(int *)(a2 + 4 * v171) + (uint64_t)(int)v174;
    uint64_t v219 = v218 + 2;
    int v220 = v218 + v166;
    int v221 = *(_DWORD *)(a3 + 4 * (v218 + 2));
    uint64_t v222 = a3 + 4 * v218;
    v223 = (_DWORD *)(a3 + 4 * ((int)v218 + (int)v166));
    int v224 = v223[1];
    *(_DWORD *)(a3 + 4 * v219) = *v223;
    int v225 = *(_DWORD *)(v222 + 12);
    *(_DWORD *)(v222 + 12) = v224;
    _DWORD *v223 = v221;
    v223[1] = v225;
    uint64_t v226 = v165 + (int)v219;
    LODWORD(v219) = v220 + v165;
    uint64_t v227 = a3 + 4 * v226;
    float result = *(float *)v227;
    int v228 = *(_DWORD *)(v227 + 4);
    v229 = (_DWORD *)(a3 + 4 * (int)v219);
    int v230 = v229[1];
    *(_DWORD *)uint64_t v227 = *v229;
    *(_DWORD *)(v227 + 4) = v230;
    *(float *)v229 = result;
    v229[1] = v228;
    ++v163;
  }
  while (v163 != v164);
  return result;
}

float cftf161(float *a1, float *a2)
{
  float v2 = a1[1];
  float v3 = a1[16];
  float v4 = a1[17];
  float v5 = *a1 + v3;
  float v6 = v2 + v4;
  float v7 = *a1 - v3;
  float v8 = v2 - v4;
  float v9 = a1[8];
  float v10 = a1[9];
  float v11 = a1[24];
  float v12 = a1[25];
  float v13 = v10 - v12;
  float v122 = v5 + (float)(v9 + v11);
  float v123 = v6 + (float)(v10 + v12);
  float v118 = v6 - (float)(v10 + v12);
  float v119 = v5 - (float)(v9 + v11);
  float v117 = v7 - (float)(v10 - v12);
  float v14 = v8 + (float)(v9 - v11);
  float v15 = v7 + v13;
  float v16 = v8 - (float)(v9 - v11);
  float v17 = a1[2];
  float v18 = a1[3];
  float v19 = a1[18];
  float v20 = a1[19];
  float v21 = v17 + v19;
  float v22 = v18 + v20;
  float v23 = v17 - v19;
  float v24 = v18 - v20;
  float v25 = a1[10];
  float v26 = a1[11];
  float v27 = a1[26];
  float v28 = a1[27];
  float v29 = v25 - v27;
  float v30 = v26 - v28;
  float v120 = v22 + (float)(v26 + v28);
  float v121 = v21 + (float)(v25 + v27);
  float v31 = v21 - (float)(v25 + v27);
  float v32 = a2[2];
  float v33 = a2[3];
  float v34 = v22 - (float)(v26 + v28);
  float v35 = (float)(v32 * (float)(v23 - v30)) - (float)(v33 * (float)(v24 + v29));
  float v36 = (float)(v33 * (float)(v23 - v30)) + (float)(v32 * (float)(v24 + v29));
  float v37 = v23 + v30;
  float v38 = v24 - v29;
  float v39 = (float)(v33 * (float)(v23 + v30)) - (float)(v32 * v38);
  float v40 = (float)(v32 * v37) + (float)(v33 * v38);
  float v41 = a1[6];
  float v42 = a1[7];
  float v43 = a1[22];
  float v44 = a1[23];
  float v45 = a1[14];
  float v46 = a1[15];
  float v47 = a1[30];
  float v48 = a1[31];
  float v49 = (float)(v41 - v43) - (float)(v46 - v48);
  float v50 = (float)(v42 - v44) + (float)(v45 - v47);
  float v51 = (float)(v33 * v49) - (float)(v32 * v50);
  float v52 = (float)(v32 * v49) + (float)(v33 * v50);
  float v53 = (float)(v41 - v43) + (float)(v46 - v48);
  float v54 = (float)(v42 - v44) - (float)(v45 - v47);
  float v55 = (float)(v32 * v53) - (float)(v33 * v54);
  float v56 = v33 * v53;
  float v58 = a1[4];
  float v57 = a1[5];
  float v59 = v56 + (float)(v32 * v54);
  float v60 = a1[20];
  float v61 = a1[21];
  float v62 = v58 + v60;
  float v63 = v58 - v60;
  float v64 = v57 + v61;
  float v65 = v57 - v61;
  float v67 = a1[12];
  float v66 = a1[13];
  float v68 = a1[28];
  float v69 = a1[29];
  float v70 = v67 + v68;
  float v71 = v67 - v68;
  float v72 = v66 + v69;
  float v73 = v66 - v69;
  float v74 = v62 + v70;
  float v75 = v62 - v70;
  float v76 = v64 + v72;
  float v77 = v64 - v72;
  float v78 = (float)(v63 - v73) - (float)(v65 + v71);
  float v79 = (float)(v65 + v71) + (float)(v63 - v73);
  float v80 = v63 + v73;
  float v81 = v65 - v71;
  float v82 = v81 + v80;
  float v83 = v81 - v80;
  float v84 = v41 + v43;
  float v85 = v42 + v44;
  float v86 = v84 + (float)(v45 + v47);
  float v87 = v84 - (float)(v45 + v47);
  float v88 = (float)(v42 + v44) + (float)(v46 + v48);
  float v89 = v85 - (float)(v46 + v48);
  float v90 = a2[1];
  float v91 = v90 * v82;
  float v92 = v15 - v91;
  float v93 = v15 + v91;
  float v94 = v90 * v83;
  float v95 = v16 - v94;
  float v96 = v16 + v94;
  float v97 = v39 - v55;
  float v98 = v39 + v55;
  float v99 = v40 - v59;
  float v100 = v40 + v59;
  a1[24] = v92 + v97;
  a1[25] = v95 + v99;
  a1[26] = v92 - v97;
  a1[27] = v95 - v99;
  a1[28] = v93 - v100;
  a1[29] = v96 + v98;
  float v101 = v90 * v78;
  float v102 = v90 * v79;
  a1[30] = v93 + v100;
  a1[31] = v96 - v98;
  float v103 = v117 + v101;
  float v104 = v14 + v102;
  float v105 = v117 - v101;
  float v106 = v14 - v102;
  float v107 = v35 + v51;
  float v108 = v35 - v51;
  a1[16] = v103 + v107;
  a1[17] = v104 + (float)(v36 + v52);
  a1[18] = v103 - v107;
  a1[19] = v104 - (float)(v36 + v52);
  a1[20] = v105 - (float)(v36 - v52);
  a1[21] = v106 + v108;
  a1[22] = v105 + (float)(v36 - v52);
  a1[23] = v106 - v108;
  float v109 = v90 * (float)((float)(v31 - v89) - (float)(v34 + v87));
  float v110 = v90 * (float)((float)(v34 + v87) + (float)(v31 - v89));
  float v111 = v34 - v87;
  float v112 = v90 * (float)((float)(v31 + v89) - v111);
  float v113 = v90 * (float)(v111 + (float)(v31 + v89));
  float v114 = v118 + v75;
  float v115 = v118 - v75;
  a1[8] = (float)(v119 - v77) + v109;
  a1[9] = v114 + v110;
  a1[10] = (float)(v119 - v77) - v109;
  a1[11] = v114 - v110;
  a1[12] = (float)(v119 + v77) - v113;
  a1[13] = v115 + v112;
  a1[14] = (float)(v119 + v77) + v113;
  a1[15] = v115 - v112;
  *a1 = (float)(v122 + v74) + (float)(v121 + v86);
  a1[1] = (float)(v123 + v76) + (float)(v120 + v88);
  a1[2] = (float)(v122 + v74) - (float)(v121 + v86);
  a1[3] = (float)(v123 + v76) - (float)(v120 + v88);
  a1[4] = (float)(v122 - v74) - (float)(v120 - v88);
  a1[5] = (float)(v123 - v76) + (float)(v121 - v86);
  float result = (float)(v123 - v76) - (float)(v121 - v86);
  a1[6] = (float)(v122 - v74) + (float)(v120 - v88);
  a1[7] = result;
  return result;
}

double bitrv216(uint64_t a1)
{
  double result = *(double *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)&long long v3 = *(void *)(a1 + 24);
  *(void *)&long long v4 = *(void *)(a1 + 40);
  *(void *)&long long v5 = *(void *)(a1 + 96);
  uint64_t v6 = *(void *)(a1 + 104);
  uint64_t v8 = *(void *)(a1 + 56);
  *(void *)&long long v7 = *(void *)(a1 + 64);
  *((void *)&v7 + 1) = *(void *)(a1 + 32);
  *(void *)&long long v9 = *(void *)(a1 + 112);
  *(_OWORD *)(a1 + 8) = v7;
  *((void *)&v5 + 1) = v2;
  *(_OWORD *)(a1 + 24) = v5;
  uint64_t v10 = *(void *)(a1 + 88);
  *(void *)(a1 + 40) = *(void *)(a1 + 80);
  *((double *)&v9 + 1) = result;
  *((void *)&v4 + 1) = v6;
  *((void *)&v3 + 1) = v10;
  *(_OWORD *)(a1 + 80) = v4;
  *(_OWORD *)(a1 + 96) = v3;
  *(_OWORD *)(a1 + 56) = v9;
  *(void *)(a1 + 112) = v8;
  return result;
}

float cftf081(float *a1, uint64_t a2)
{
  float v2 = *(float *)(a2 + 4);
  float v3 = a1[1];
  float v4 = a1[8];
  float v5 = a1[9];
  float v6 = *a1 + v4;
  float v7 = v3 + v5;
  float v8 = *a1 - v4;
  float v9 = v3 - v5;
  float v10 = a1[4];
  float v11 = a1[5];
  float v12 = a1[12];
  float v13 = a1[13];
  float v14 = v10 + v12;
  float v15 = v11 + v13;
  float v16 = v10 - v12;
  float v17 = v11 - v13;
  float v18 = v6 + v14;
  float v19 = v7 + v15;
  float v20 = v6 - v14;
  float v21 = v7 - v15;
  float v22 = v8 - v17;
  float v23 = v9 + v16;
  float v24 = v8 + v17;
  float v25 = v9 - v16;
  float v26 = a1[2];
  float v27 = a1[3];
  float v28 = a1[10];
  float v29 = a1[11];
  float v30 = v26 + v28;
  float v31 = v27 + v29;
  float v32 = v26 - v28;
  float v33 = v27 - v29;
  float v34 = a1[6];
  float v35 = a1[7];
  float v36 = a1[14];
  float v37 = a1[15];
  float v38 = v34 + v36;
  float v39 = v35 + v37;
  float v40 = v34 - v36;
  float v41 = v35 - v37;
  float v42 = v30 + v38;
  float v43 = v30 - v38;
  float v44 = v32 - v41;
  float v45 = v32 + v41;
  float v46 = v33 + v40;
  float v47 = v33 - v40;
  float v48 = v2 * (float)(v44 - v46);
  float v49 = v2 * (float)(v46 + v44);
  float v50 = v2 * (float)(v45 - v47);
  float v51 = v2 * (float)(v47 + v45);
  a1[8] = v22 + v48;
  a1[9] = v23 + v49;
  a1[10] = v22 - v48;
  a1[11] = v23 - v49;
  a1[12] = v24 - v51;
  a1[13] = v25 + v50;
  a1[14] = v24 + v51;
  a1[15] = v25 - v50;
  *a1 = v18 + v42;
  a1[1] = v19 + (float)(v31 + v39);
  a1[2] = v18 - v42;
  a1[3] = v19 - (float)(v31 + v39);
  a1[4] = v20 - (float)(v31 - v39);
  a1[5] = v21 + v43;
  float result = v21 - v43;
  a1[6] = v20 + (float)(v31 - v39);
  a1[7] = result;
  return result;
}

float cftf040(float *a1)
{
  float v1 = a1[1];
  float v2 = a1[4];
  float v3 = a1[5];
  float v4 = *a1 + v2;
  float v5 = v1 + v3;
  float v6 = *a1 - v2;
  float v7 = v1 - v3;
  float v8 = a1[2];
  float v9 = a1[3];
  float v10 = a1[6];
  float v11 = a1[7];
  float v12 = v8 + v10;
  float v13 = v9 + v11;
  float v14 = v8 - v10;
  float v15 = v9 - v11;
  *a1 = v4 + v12;
  a1[1] = v5 + v13;
  a1[2] = v6 - v15;
  a1[3] = v7 + v14;
  a1[4] = v4 - v12;
  a1[5] = v5 - v13;
  float result = v6 + v15;
  a1[6] = result;
  a1[7] = v7 - v14;
  return result;
}

float cftb1st(int a1, float *a2, float *a3)
{
  uint64_t v3 = 2 * (a1 >> 3);
  int v4 = 4 * (a1 >> 3);
  float v5 = a2[v4];
  float v6 = a2[1];
  float v7 = *a2 + v5;
  float v8 = &a2[4 * (a1 >> 3)];
  float v9 = v8[1];
  float v10 = (float)-v6 - v9;
  float v11 = *a2 - v5;
  uint64_t v12 = 2 * (a1 >> 3);
  float v13 = a2[v12];
  float v14 = v9 - v6;
  float v15 = a2[6 * (a1 >> 3)];
  float v16 = v13 + v15;
  float v17 = a2[(int)(v3 | 1)];
  int v18 = (6 * (a1 >> 3)) | 1;
  float v19 = a2[v18];
  float v20 = v13 - v15;
  *a2 = v7 + v16;
  a2[1] = v10 - (float)(v17 + v19);
  a2[v12] = v7 - v16;
  a2[(int)(v3 | 1)] = v10 + (float)(v17 + v19);
  a2[v4] = v11 + (float)(v17 - v19);
  v8[1] = v14 + v20;
  a2[6 * (a1 >> 3)] = v11 - (float)(v17 - v19);
  a2[v18] = v14 - v20;
  uint64_t v21 = (uint64_t)a1 >> 3;
  float v22 = a3[1];
  float v23 = a3[2];
  float v24 = a3[3];
  uint64_t v25 = v21 - 2;
  if (a1 < 40)
  {
    float v48 = 0.0;
    float v47 = 1.0;
    float v49 = 1.0;
    float v50 = 0.0;
  }
  else
  {
    uint64_t v26 = 0;
    uint64_t v27 = 24 * v21;
    uint64_t v28 = v27 + 12;
    uint64_t v29 = 4 * v4;
    uint64_t v30 = v29 + 12;
    uint64_t v31 = v29 - 4;
    uint64_t v32 = v27 - 4;
    float v33 = a3 + 7;
    uint64_t v34 = 24 * (a1 >> 3) + 16;
    uint64_t v35 = 2 * (a1 >> 3);
    uint64_t v36 = v35 * 4 - 8;
    uint64_t v37 = 8 * v3 + 16;
    uint64_t v38 = 8 * v3 - 8;
    uint64_t v39 = 12 * v3 - 8;
    float v40 = 1.0;
    float v41 = 0.0;
    float v42 = 0.0;
    uint64_t v43 = 16 * v3 - 16;
    uint64_t v44 = 2;
    uint64_t v45 = (v3 << 34) - 0x200000000;
    float v46 = 1.0;
    do
    {
      float v47 = v33[v26 - 3];
      float v48 = v33[v26 - 2];
      float v49 = v33[v26 - 1];
      float v50 = v33[v26];
      float v51 = v40 + v49;
      float v52 = &a2[v26];
      float v53 = (float *)((char *)a2 + v37);
      float v54 = *(float *)((char *)a2 + v37 - 8);
      float v55 = v41 + v50;
      float v56 = a2[v26 + 2];
      float v57 = a2[v26 + 3];
      float v58 = v56 + v54;
      float v59 = *(float *)((char *)a2 + v30);
      float v60 = -v57;
      float v61 = v56 - v54;
      float v62 = v59 - v57;
      float v63 = a2[v26 + 4];
      float v64 = a2[v26 + 5];
      float v65 = v60 - v59;
      float v67 = *(float *)((char *)a2 + v37);
      float v66 = *(float *)((char *)a2 + v37 + 4);
      float v68 = v63 + v67;
      float v69 = (float)-v64 - v66;
      float v70 = v63 - v67;
      float v71 = v23 * (float)(v46 + v47);
      float v72 = v66 - v64;
      float v73 = &a2[v35];
      float v74 = (float *)((char *)a2 + v34);
      float v75 = *(float *)((char *)a2 + v34 - 8);
      float v76 = v23 * (float)(v42 + v48);
      float v78 = a2[v35 + 2];
      float v77 = a2[v35 + 3];
      float v79 = v78 + v75;
      float v80 = *(float *)((char *)a2 + v28);
      float v81 = v77 + v80;
      float v82 = v24 * v51;
      float v83 = v78 - v75;
      float v84 = v77 - v80;
      float v86 = a2[v35 + 4];
      float v85 = a2[v35 + 5];
      float v87 = v24 * v55;
      float v88 = *(float *)((char *)a2 + v34);
      float v89 = *(float *)((char *)a2 + v34 + 4);
      float v90 = v86 + v88;
      float v91 = v85 + v89;
      float v92 = v86 - v88;
      float v93 = v85 - v89;
      v52[4] = v68 + v90;
      v52[5] = v69 - v91;
      v52[2] = v58 + v79;
      void v52[3] = v65 - v81;
      v73[2] = v58 - v79;
      v73[3] = v65 + v81;
      v73[4] = v68 - v90;
      v73[5] = v69 + v91;
      *(v53 - 2) = (float)(v71 * (float)(v61 + v84)) - (float)(v76 * (float)(v62 + v83));
      *(float *)((char *)a2 + v30) = (float)(v76 * (float)(v61 + v84)) + (float)(v71 * (float)(v62 + v83));
      float v94 = v62 - v83;
      *float v53 = (float)(v47 * (float)(v70 + v93)) - (float)(v48 * (float)(v72 + v92));
      v53[1] = (float)(v48 * (float)(v70 + v93)) + (float)(v47 * (float)(v72 + v92));
      *(v74 - 2) = (float)(v87 * v94) + (float)(v82 * (float)(v61 - v84));
      float v95 = v70 - v93;
      *(float *)((char *)a2 + v28) = (float)(v82 * v94) - (float)(v87 * (float)(v61 - v84));
      *float v74 = (float)(v50 * (float)(v72 - v92)) + (float)(v49 * v95);
      v74[1] = (float)(v49 * (float)(v72 - v92)) - (float)(v50 * v95);
      float v96 = (float *)((char *)a2 + v36);
      float v97 = (float *)((char *)a2 + v39);
      float v99 = *(float *)((char *)a2 + v39 - 4);
      float v98 = *(float *)((char *)a2 + v39);
      float v100 = *(float *)((char *)a2 + v36);
      float v101 = *(float *)((char *)a2 + v36 + 4);
      float v102 = v100 + v98;
      float v103 = -v101;
      float v104 = *(float *)((char *)a2 + v32);
      float v105 = v100 - v98;
      float v107 = *(float *)((char *)a2 + v36 - 8);
      float v106 = *(float *)((char *)a2 + v36 - 4);
      float v108 = *(float *)((char *)a2 + v39 - 8);
      float v109 = v107 + v108;
      float v110 = -v106;
      float v111 = v107 - v108;
      float v112 = (float *)((char *)a2 + v38);
      float v113 = *(float *)((char *)a2 + v38);
      float v114 = (float *)((char *)a2 + v43);
      float v115 = *(float *)((char *)a2 + v31);
      float v116 = v99 - v106;
      float v117 = *(float *)((char *)a2 + v43 + 4);
      float v118 = *(float *)((char *)a2 + v43 + 8);
      uint64_t v119 = (v45 >> 30) | 4;
      float v120 = *(float *)((char *)a2 + v119);
      float v121 = v104 - v101;
      float v122 = v113 + v118;
      float v123 = v115 + v120;
      float v124 = v113 - v118;
      float v125 = v115 - v120;
      float v126 = v103 - v104;
      float v128 = *(float *)((char *)a2 + v38 - 8);
      float v127 = *(float *)((char *)a2 + v38 - 4);
      float v129 = *(float *)((char *)a2 + v43);
      float v130 = v127 + v117;
      float v131 = v110 - v99;
      float v132 = v127 - v117;
      *float v96 = v102 + v122;
      v96[1] = v126 - v123;
      *(v96 - 2) = v109 + (float)(v128 + v129);
      *(v96 - 1) = v131 - v130;
      float *v112 = v102 - v122;
      *(float *)((char *)a2 + v31) = v126 + v123;
      *(v112 - 2) = v109 - (float)(v128 + v129);
      *(v112 - 1) = v131 + v130;
      float v133 = (float)(v76 * (float)(v105 + v125)) - (float)(v71 * (float)(v121 + v124));
      float v134 = (float)(v71 * (float)(v105 + v125)) + (float)(v76 * (float)(v121 + v124));
      float v135 = v105 - v125;
      float v136 = v121 - v124;
      *float v97 = v133;
      *(float *)((char *)a2 + v32) = v134;
      v44 += 4;
      *(v97 - 2) = (float)(v48 * (float)(v111 + v132)) - (float)(v47 * (float)(v116 + (float)(v128 - v129)));
      *(v97 - 1) = (float)(v47 * (float)(v111 + v132)) + (float)(v48 * (float)(v116 + (float)(v128 - v129)));
      v28 += 16;
      v30 += 16;
      v31 -= 16;
      v26 += 4;
      v34 += 16;
      v114[2] = (float)(v82 * v136) + (float)(v87 * v135);
      v36 -= 16;
      v37 += 16;
      v35 += 4;
      v38 -= 16;
      *(float *)((char *)a2 + v119) = (float)(v87 * v136) - (float)(v82 * v135);
      v39 -= 16;
      v45 -= 0x400000000;
      v43 -= 16;
      float v41 = v50;
      v32 -= 16;
      *float v114 = (float)(v49 * (float)(v116 - (float)(v128 - v129))) + (float)(v50 * (float)(v111 - v132));
      v114[1] = (float)(v50 * (float)(v116 - (float)(v128 - v129))) - (float)(v49 * (float)(v111 - v132));
      float v40 = v49;
      float v42 = v48;
      float v46 = v47;
    }
    while (v44 < v25);
  }
  float v137 = v23 * (float)(v22 + v47);
  float v138 = v23 * (float)(v22 + v48);
  float v139 = v24 * (float)(v49 - v22);
  float v140 = v24 * (float)(v50 - v22);
  float v141 = a2[v25];
  uint64_t v142 = &a2[5 * v21];
  float v143 = *(v142 - 2);
  float v144 = *(v142 - 1);
  float v145 = v141 + v143;
  uint64_t v146 = &a2[v21];
  float v147 = *(v146 - 1);
  float v148 = (float)-v147 - v144;
  float v149 = v141 - v143;
  float v150 = v144 - v147;
  int v151 = &a2[3 * (int)v21];
  float v152 = &a2[7 * v21];
  float v153 = *(v152 - 2);
  float v154 = *(v151 - 2);
  float v155 = *(v151 - 1);
  float v156 = v154 + v153;
  int v157 = &a2[7 * v21];
  float v158 = *(v157 - 1);
  float v159 = v154 - v153;
  a2[v25] = v145 + v156;
  *(v146 - 1) = v148 - (float)(v155 + v158);
  *(v151 - 2) = v145 - v156;
  *(v151 - 1) = v148 + (float)(v155 + v158);
  float v160 = v149 + (float)(v155 - v158);
  *(v142 - 2) = (float)(v137 * v160) - (float)(v138 * (float)(v150 + v159));
  *(v142 - 1) = (float)(v138 * v160) + (float)(v137 * (float)(v150 + v159));
  float v161 = v149 - (float)(v155 - v158);
  float v162 = v150 - v159;
  *(v152 - 2) = (float)(v140 * v162) + (float)(v139 * v161);
  *(v157 - 1) = (float)(v139 * v162) - (float)(v140 * v161);
  float v163 = v146[1];
  float v164 = v142[1];
  float v165 = *v146 + *v142;
  float v166 = (float)-v163 - v164;
  float v167 = *v146 - *v142;
  float v168 = v164 - v163;
  float v169 = v151[1];
  float v170 = v157[1];
  float v171 = *v151 + *v157;
  float v172 = v169 + v170;
  float v173 = *v151 - *v157;
  float v174 = v169 - v170;
  *uint64_t v146 = v165 + v171;
  v146[1] = v166 - v172;
  *int v151 = v165 - v171;
  v151[1] = v166 + v172;
  *uint64_t v142 = v22 * (float)((float)(v167 + v174) - (float)(v168 + v173));
  v142[1] = v22 * (float)((float)(v168 + v173) + (float)(v167 + v174));
  float v175 = v167 - v174;
  float v176 = v168 - v173;
  *int v157 = -(float)(v22 * (float)(v176 + v175));
  v157[1] = -(float)(v22 * (float)(v176 - v175));
  float v177 = v146[2];
  float v178 = v146[3];
  float v179 = v142[2];
  float v180 = v142[3];
  float v181 = v177 + v179;
  float v182 = (float)-v178 - v180;
  float v183 = v177 - v179;
  float v184 = v180 - v178;
  float v185 = v151[2];
  float v186 = v151[3];
  float v187 = v157[2];
  float v188 = v157[3];
  float v189 = v185 + v187;
  float v190 = v186 + v188;
  float v191 = v185 - v187;
  float v192 = v186 - v188;
  v146[2] = v181 + v189;
  v146[3] = v182 - v190;
  v151[2] = v181 - v189;
  v151[3] = v182 + v190;
  v142[2] = (float)(v138 * (float)(v183 + v192)) - (float)(v137 * (float)(v184 + v191));
  v142[3] = (float)(v137 * (float)(v183 + v192)) + (float)(v138 * (float)(v184 + v191));
  float v193 = v183 - v192;
  float v194 = (float)(v139 * (float)(v184 - v191)) + (float)(v140 * v193);
  float result = (float)(v140 * (float)(v184 - v191)) - (float)(v139 * v193);
  v157[2] = v194;
  v157[3] = result;
  return result;
}

float bitrv2conj(int a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = a1 >> 2;
  if (a1 < 36)
  {
    int v8 = a1 >> 1;
    uint64_t v9 = 4;
    int v4 = 1;
    if (v3 == 8)
    {
LABEL_8:
      uint64_t v10 = 0;
      uint64_t v11 = 8 * v4;
      uint64_t v12 = v4;
      uint64_t v13 = a2 + 4 * v4;
      uint64_t v235 = 2 * (int)v9 + v8;
      uint64_t v236 = v4;
      uint64_t v237 = a2;
      do
      {
        uint64_t v14 = v10 + v12;
        if (v10)
        {
          uint64_t v15 = 0;
          uint64_t v16 = 0;
          uint64_t v238 = v10 + v12;
          uint64_t v17 = *(int *)(a2 + 4 * v14);
          uint64_t v18 = 4 * (int)v10;
          uint64_t v243 = (v9 << 33) + (v17 << 33);
          uint64_t v244 = 8 * v17;
          unint64_t v242 = ((unint64_t)(3 * v9) << 32) + (v17 << 33);
          uint64_t v19 = v235 + (int)v9 + 2 * v17;
          uint64_t v241 = (v19 << 32) + 0x300000000;
          int v240 = 2 * v17;
          int v20 = v9 + 2 * v17;
          int v21 = 2 * (v9 + v17);
          int v22 = 3 * v9 + 2 * v17;
          int v23 = v8 + 3 * v9 + 2 + 2 * v17;
          uint64_t v24 = v235 + 2 * v17;
          uint64_t v25 = (v24 << 32) + 0x300000000;
          uint64_t v26 = (v24 << 32) + 0x200000000;
          uint64_t v27 = (int)v9 + (uint64_t)v8 + 2 * v17;
          uint64_t v28 = (v27 << 32) + 0x300000000;
          uint64_t v29 = (v27 << 32) + 0x200000000;
          uint64_t v30 = 4 * (int)v9 + 8 * v17;
          uint64_t v31 = a3 + 8 * (int)v9 + 8 * v17;
          uint64_t v32 = a3 + 12 * (int)v9 + 8 * v17;
          uint64_t v33 = 4 * v19;
          uint64_t v34 = 4 * v27;
          uint64_t v35 = 4 * v24;
          uint64_t v36 = a3;
          uint64_t v239 = v10;
          uint64_t v37 = 4 * v8 + 8 * v17;
          do
          {
            uint64_t v38 = v13;
            uint64_t v39 = v18 + 2 * *(int *)(v13 + v16);
            uint64_t v40 = v36 + v244;
            int v41 = *(_DWORD *)(v36 + v244);
            float v42 = -*(float *)(v36 + v244 + 4);
            uint64_t v43 = (4 * v39) | 4;
            float v44 = -*(float *)(a3 + v43);
            *(_DWORD *)uint64_t v40 = *(_DWORD *)(a3 + 4 * v39);
            *(float *)(v40 + 4) = v44;
            *(_DWORD *)(a3 + 4 * v39) = v41;
            *(float *)(a3 + v43) = v42;
            uint64_t v45 = (int)v39 + (uint64_t)(int)v11;
            uint64_t v46 = v36 + v30;
            int v47 = *(_DWORD *)(v36 + v30);
            uint64_t v48 = (4 * v45) | 4;
            float v49 = -*(float *)(v36 + v30 + 4);
            float v50 = -*(float *)(a3 + v48);
            *(_DWORD *)uint64_t v46 = *(_DWORD *)(a3 + 4 * v45);
            *(float *)(v46 + 4) = v50;
            *(_DWORD *)(a3 + 4 * v45) = v47;
            *(float *)(a3 + v48) = v49;
            uint64_t v51 = (int)v45 - (uint64_t)(int)v9;
            int v52 = *(_DWORD *)(v31 + 4 * v16);
            uint64_t v53 = ((v243 + v15) >> 30) | 4;
            float v54 = *(float *)(a3 + v53);
            uint64_t v55 = (4 * v51) | 4;
            float v56 = -*(float *)(a3 + v55);
            *(_DWORD *)(v31 + 4 * v16) = *(_DWORD *)(a3 + 4 * v51);
            *(float *)(a3 + v53) = v56;
            *(_DWORD *)(a3 + 4 * v51) = v52;
            *(float *)(a3 + v55) = -v54;
            uint64_t v57 = v11 + (int)v51;
            int v58 = *(_DWORD *)(v32 + 4 * v16);
            uint64_t v59 = ((uint64_t)(v242 + v15) >> 30) | 4;
            uint64_t v60 = a3 + 4 * v57;
            uint64_t v61 = (4 * v57) | 4;
            float v62 = -*(float *)(a3 + v59);
            float v63 = -*(float *)(a3 + v61);
            *(_DWORD *)(v32 + 4 * v16) = *(_DWORD *)v60;
            *(float *)(a3 + v59) = v63;
            *(_DWORD *)uint64_t v60 = v58;
            *(float *)(a3 + v61) = v62;
            v57 += 2;
            uint64_t v64 = v36 + v33;
            int v65 = *(_DWORD *)(v36 + v33);
            float v66 = -*(float *)(v36 + v33 + 4);
            float v67 = -*(float *)(v60 + 12);
            *(_DWORD *)uint64_t v64 = *(_DWORD *)(a3 + 4 * v57);
            *(float *)(v64 + 4) = v67;
            *(_DWORD *)(a3 + 4 * v57) = v65;
            uint64_t v68 = (int)v57 - (uint64_t)(int)v11;
            *(float *)(v60 + 12) = v66;
            uint64_t v69 = v36 + v35;
            int v70 = *(_DWORD *)(v36 + v35);
            uint64_t v71 = a3 + 4 * v68;
            float v72 = -*(float *)(v36 + v35 + 4);
            float v73 = -*(float *)(v71 + 4);
            *(_DWORD *)uint64_t v69 = *(_DWORD *)v71;
            *(float *)(v69 + 4) = v73;
            *(_DWORD *)uint64_t v71 = v70;
            *(float *)(v71 + 4) = v72;
            uint64_t v74 = (int)v68 + (uint64_t)(int)v9;
            uint64_t v75 = v36 + v34;
            int v76 = *(_DWORD *)(v36 + v34);
            float v77 = -*(float *)(v36 + v34 + 4);
            uint64_t v78 = a3 + 4 * v74;
            float v79 = -*(float *)(v78 + 4);
            *(_DWORD *)uint64_t v75 = *(_DWORD *)v78;
            *(float *)(v75 + 4) = v79;
            *(_DWORD *)uint64_t v78 = v76;
            *(float *)(v78 + 4) = v77;
            uint64_t v80 = (int)v74 - (uint64_t)(int)v11;
            uint64_t v81 = v36 + v37;
            int v82 = *(_DWORD *)(v36 + v37);
            float v83 = -*(float *)(v36 + v37 + 4);
            uint64_t v84 = a3 + 4 * v80;
            float v85 = -*(float *)(v84 + 4);
            *(_DWORD *)uint64_t v81 = *(_DWORD *)v84;
            *(float *)(v81 + 4) = v85;
            *(_DWORD *)uint64_t v84 = v82;
            *(float *)(v84 + 4) = v83;
            int v86 = *(_DWORD *)(v36 + v37 + 8);
            uint64_t v87 = a3 + 4 * ((int)v80 + (uint64_t)v8);
            float v88 = -*(float *)(v36 + v37 + 12);
            float v89 = -*(float *)(v87 + 4);
            *(_DWORD *)(v81 + 8) = *(_DWORD *)v87;
            *(float *)(v81 + 12) = v89;
            *(_DWORD *)uint64_t v87 = v86;
            *(float *)(v87 + 4) = v88;
            uint64_t v90 = (v29 + v15) >> 30;
            uint64_t v91 = (v28 + v15) >> 30;
            int v92 = *(_DWORD *)(a3 + v90);
            uint64_t v93 = (int)v74 + v8;
            uint64_t v94 = a3 + 4 * v93;
            float v95 = -*(float *)(a3 + v91);
            float v96 = -*(float *)(v94 + 4);
            *(_DWORD *)(a3 + v90) = *(_DWORD *)v94;
            *(float *)(a3 + v91) = v96;
            uint64_t v97 = v93 - (int)v9;
            uint64_t v98 = (v26 + v15) >> 30;
            *(_DWORD *)uint64_t v94 = v92;
            *(float *)(v94 + 4) = v95;
            uint64_t v99 = (v25 + v15) >> 30;
            float v100 = *(float *)(a3 + v99);
            uint64_t v101 = a3 + 4 * v97;
            int v102 = *(_DWORD *)(a3 + v98);
            float v103 = -*(float *)(v101 + 4);
            *(_DWORD *)(a3 + v98) = *(_DWORD *)v101;
            *(float *)(a3 + v99) = v103;
            *(_DWORD *)uint64_t v101 = v102;
            *(float *)(v101 + 4) = -v100;
            int v104 = *(_DWORD *)(a3 + 4 * (v23 + (int)v16));
            uint64_t v105 = (v241 + v15) >> 30;
            uint64_t v106 = (int)v97 + (uint64_t)(int)v11;
            uint64_t v107 = a3 + 4 * v106;
            float v108 = -*(float *)(v107 + 4);
            float v109 = -*(float *)(a3 + v105);
            *(_DWORD *)(a3 + 4 * (v23 + (int)v16)) = *(_DWORD *)v107;
            *(float *)(a3 + v105) = v108;
            *(_DWORD *)uint64_t v107 = v104;
            *(float *)(v107 + 4) = v109;
            LODWORD(v105) = v22 + v16 + 2;
            v106 -= 2;
            LODWORD(v99) = v22 + v16 + 3;
            int v110 = *(_DWORD *)(a3 + 4 * (int)v105);
            float v111 = *(float *)(a3 + 4 * (int)v99);
            float v112 = -*(float *)(v107 - 4);
            *(_DWORD *)(a3 + 4 * (int)v105) = *(_DWORD *)(a3 + 4 * v106);
            *(float *)(a3 + 4 * (int)v99) = v112;
            *(_DWORD *)(a3 + 4 * v106) = v110;
            LODWORD(v105) = v21 + v16 + 2;
            uint64_t v113 = (int)v106 - (uint64_t)(int)v11;
            *(float *)(v107 - 4) = -v111;
            LODWORD(v99) = v21 + v16 + 3;
            float v114 = *(float *)(a3 + 4 * (int)v99);
            uint64_t v115 = a3 + 4 * v113;
            int v116 = *(_DWORD *)(a3 + 4 * (int)v105);
            float v117 = -*(float *)(v115 + 4);
            *(_DWORD *)(a3 + 4 * (int)v105) = *(_DWORD *)v115;
            *(float *)(a3 + 4 * (int)v99) = v117;
            LODWORD(v105) = v20 + v16 + 2;
            *(_DWORD *)uint64_t v115 = v116;
            *(float *)(v115 + 4) = -v114;
            int v118 = *(_DWORD *)(a3 + 4 * (int)v105);
            LODWORD(v99) = v20 + v16 + 3;
            float v119 = *(float *)(a3 + 4 * (int)v99);
            uint64_t v120 = (int)v113 + (uint64_t)(int)v9;
            uint64_t v121 = a3 + 4 * v120;
            float v122 = *(float *)(v121 + 4);
            *(_DWORD *)(a3 + 4 * (int)v105) = *(_DWORD *)v121;
            *(float *)(a3 + 4 * (int)v99) = -v122;
            *(_DWORD *)uint64_t v121 = v118;
            *(float *)(v121 + 4) = -v119;
            LODWORD(v105) = v240 + v16 + 2;
            int v123 = *(_DWORD *)(a3 + 4 * (int)v105);
            uint64_t v124 = a3 + 4 * ((int)v120 - (uint64_t)(int)v11);
            float v125 = *(float *)(v124 + 4);
            *(_DWORD *)(a3 + 4 * (int)v105) = *(_DWORD *)v124;
            LODWORD(v99) = v240 + v16 + 3;
            float v126 = *(float *)(a3 + 4 * (int)v99);
            *(float *)(a3 + 4 * (int)v99) = -v125;
            *(_DWORD *)uint64_t v124 = v123;
            *(float *)(v124 + 4) = -v126;
            uint64_t v13 = v38;
            v16 += 4;
            v36 += 16;
            v15 += 0x400000000;
            --v10;
          }
          while (v10);
          uint64_t v12 = v236;
          a2 = v237;
          uint64_t v14 = v238;
          uint64_t v10 = v239;
        }
        else
        {
          LODWORD(v18) = 0;
        }
        uint64_t v127 = 2 * *(int *)(a2 + 4 * v14) + (int)v18;
        uint64_t v128 = v127 + 2;
        *(float *)(a3 + ((4 * v127) | 4)) = -*(float *)(a3 + ((4 * v127) | 4));
        int v129 = *(_DWORD *)(a3 + 4 * (v127 + 2));
        uint64_t v130 = (int)v127 + (uint64_t)v8;
        uint64_t v131 = a3 + 4 * v127;
        float v132 = -*(float *)(v131 + 12);
        uint64_t v133 = a3 + 4 * v130;
        float v134 = -*(float *)(v133 + 4);
        *(_DWORD *)(a3 + 4 * v128) = *(_DWORD *)v133;
        *(float *)(v131 + 12) = v134;
        *(_DWORD *)uint64_t v133 = v129;
        *(float *)(v133 + 4) = v132;
        *(float *)(v133 + 12) = -*(float *)(v133 + 12);
        uint64_t v135 = (int)v128 + (uint64_t)(int)v9;
        uint64_t v136 = (int)v130 + (uint64_t)(int)v11;
        int v137 = *(_DWORD *)(a3 + 4 * v135);
        uint64_t v138 = (4 * v135) | 4;
        float v139 = -*(float *)(a3 + v138);
        uint64_t v140 = a3 + 4 * v136;
        float v141 = -*(float *)(v140 + 4);
        *(_DWORD *)(a3 + 4 * v135) = *(_DWORD *)v140;
        *(float *)(a3 + v138) = v141;
        *(_DWORD *)uint64_t v140 = v137;
        *(float *)(v140 + 4) = v139;
        uint64_t v142 = (int)v135 + (uint64_t)(int)v9;
        uint64_t v143 = (int)v136 - (uint64_t)(int)v9;
        float v144 = (float *)(a3 + 4 * v142);
        float v145 = *v144;
        uint64_t v146 = (4 * v142) | 4;
        float v147 = *(float *)(a3 + v146);
        float v148 = (float *)(a3 + 4 * v143);
        float v149 = -v148[1];
        *float v144 = *v148;
        *(float *)(a3 + v146) = v149;
        *float v148 = v145;
        v148[1] = -v147;
        int v150 = *((_DWORD *)v144 - 2);
        float v151 = -*(v144 - 1);
        float v152 = (float *)(a3 + 4 * ((int)v143 - (uint64_t)v8));
        float v153 = -v152[1];
        *(v144 - 2) = *v152;
        *(v144 - 1) = v153;
        *(_DWORD *)float v152 = v150;
        v152[1] = v151;
        float v154 = (float *)(a3 + 4 * ((int)v142 + v8));
        float v155 = *v154;
        float v156 = -v154[1];
        float v157 = -*(float *)(a3 + 4 * ((int)v143 + 3));
        *float v154 = *(float *)(a3 + 4 * ((int)v143 + 2));
        v154[1] = v157;
        *(float *)(a3 + 4 * ((int)v143 + 2)) = v155;
        *(float *)(a3 + 4 * ((int)v143 + 3)) = v156;
        LODWORD(v142) = v142 + v9;
        float v158 = (float *)(a3 + 4 * (int)v142);
        *(v158 - 1) = -*(v158 - 1);
        float v159 = *v158;
        uint64_t v160 = (4 * (int)v142) | 4;
        float v161 = -*(float *)(a3 + v160);
        float v162 = (float *)(a3 + 4 * ((int)v143 + (int)v11));
        float v163 = -v162[1];
        *float v158 = *v162;
        *(float *)(a3 + v160) = v163;
        *float v162 = v159;
        v162[1] = v161;
        float result = -v162[3];
        v162[3] = result;
        ++v10;
      }
      while (v10 != v12);
      return result;
    }
  }
  else
  {
    int v4 = 1;
    do
    {
      int v5 = v4;
      v4 *= 2;
      unsigned int v6 = v3 >> 2;
      BOOL v7 = v3 > 0x23;
      v3 >>= 2;
    }
    while (v7);
    int v8 = a1 >> 1;
    uint64_t v9 = (8 * v5);
    if (v6 == 8)
    {
      if (v4 < 1) {
        return result;
      }
      goto LABEL_8;
    }
    if (v4 < 1) {
      return result;
    }
  }
  uint64_t v165 = 0;
  uint64_t v166 = v4;
  uint64_t v167 = (int)v9;
  uint64_t v168 = v8;
  int v169 = v8 + v9 + 2;
  uint64_t v170 = a3 + 4;
  uint64_t v171 = a2 + 4 * v4;
  uint64_t v172 = v167 + v8;
  do
  {
    uint64_t v173 = v165 + v166;
    if (v165)
    {
      uint64_t v174 = 0;
      int v175 = *(_DWORD *)(a2 + 4 * v173);
      uint64_t v176 = 4 * (int)v165;
      uint64_t v177 = v172 + v175;
      uint64_t v178 = (v177 << 32) + 0x300000000;
      int v179 = v167 + v175;
      int v180 = v169 + v175;
      float v181 = (float *)(v170 + 4 * v175);
      float v182 = (float *)(v170 + 4 * (v167 + v175));
      uint64_t v183 = a3 + 8 + 4 * (v168 + v175);
      uint64_t v184 = v165;
      float v185 = (float *)(v170 + 4 * v177);
      do
      {
        uint64_t v186 = *(int *)(v171 + v174) + v176;
        int v187 = *((_DWORD *)v181 - 1);
        float v188 = -*v181;
        float v189 = (float *)(a3 + 4 * v186);
        float v190 = -v189[1];
        *(v181 - 1) = *v189;
        *float v181 = v190;
        *(_DWORD *)float v189 = v187;
        v189[1] = v188;
        uint64_t v191 = v167 + (int)v186;
        int v192 = *((_DWORD *)v182 - 1);
        float v193 = (float *)(a3 + 4 * v191);
        float v194 = -*v182;
        float v195 = -v193[1];
        *(v182 - 1) = *v193;
        *float v182 = v195;
        *(_DWORD *)float v193 = v192;
        v193[1] = v194;
        int v196 = *((_DWORD *)v185 - 1);
        float v197 = -*v185;
        float v198 = -v193[3];
        *(v185 - 1) = *(float *)(a3 + 4 * (v191 + 2));
        float *v185 = v198;
        *(_DWORD *)(a3 + 4 * (v191 + 2)) = v196;
        v193[3] = v197;
        uint64_t v199 = (int)v191 + 2 - v167;
        int v200 = *(_DWORD *)(v183 - 8);
        float v201 = -*(float *)(v183 - 4);
        uint64_t v202 = a3 + 4 * v199;
        float v203 = -*(float *)(v202 + 4);
        *(_DWORD *)(v183 - 8) = *(_DWORD *)v202;
        *(float *)(v183 - 4) = v203;
        *(_DWORD *)uint64_t v202 = v200;
        *(float *)(v202 + 4) = v201;
        int v204 = *(_DWORD *)v183;
        float v205 = -*(float *)(v183 + 4);
        uint64_t v206 = a3 + 4 * ((int)v199 + (int)v168);
        float v207 = -*(float *)(v206 + 4);
        *(_DWORD *)uint64_t v183 = *(_DWORD *)v206;
        *(float *)(v183 + 4) = v207;
        v183 += 16;
        *(_DWORD *)uint64_t v206 = v204;
        *(float *)(v206 + 4) = v205;
        int v208 = *(_DWORD *)(a3 + 4 * (v180 + (int)v174));
        uint64_t v209 = a3 + 4 * ((int)v191 + 2 + (int)v168);
        float v210 = -*(float *)(a3 + (v178 >> 30));
        float v211 = -*(float *)(v209 + 4);
        *(_DWORD *)(a3 + 4 * (v180 + (int)v174)) = *(_DWORD *)v209;
        *(float *)(a3 + (v178 >> 30)) = v211;
        *(_DWORD *)uint64_t v209 = v208;
        *(float *)(v209 + 4) = v210;
        LODWORD(v209) = v179 + v174 + 2;
        int v212 = *(_DWORD *)(a3 + 4 * (int)v209);
        LODWORD(v206) = v179 + v174 + 3;
        uint64_t v213 = (int)v191 + (int)v168;
        float v214 = -*(float *)(a3 + 4 * (int)v206);
        uint64_t v215 = a3 + 4 * v213;
        float v216 = -*(float *)(v215 + 4);
        *(_DWORD *)(a3 + 4 * (int)v209) = *(_DWORD *)v215;
        *(float *)(a3 + 4 * (int)v206) = v216;
        LODWORD(v209) = v175 + v174 + 2;
        *(_DWORD *)uint64_t v215 = v212;
        *(float *)(v215 + 4) = v214;
        int v217 = *(_DWORD *)(a3 + 4 * (int)v209);
        LODWORD(v206) = v175 + v174 + 3;
        float v218 = *(float *)(a3 + 4 * (int)v206);
        uint64_t v219 = a3 + 4 * (v213 - v167);
        float v220 = *(float *)(v219 + 4);
        *(_DWORD *)(a3 + 4 * (int)v209) = *(_DWORD *)v219;
        v174 += 4;
        v178 += 0x400000000;
        v181 += 4;
        *(float *)(a3 + 4 * (int)v206) = -v220;
        *(_DWORD *)uint64_t v219 = v217;
        *(float *)(v219 + 4) = -v218;
        v182 += 4;
        v185 += 4;
        --v184;
      }
      while (v184);
    }
    else
    {
      LODWORD(v176) = 0;
    }
    uint64_t v221 = *(int *)(a2 + 4 * v173) + (uint64_t)(int)v176;
    uint64_t v222 = v221 + 2;
    int v223 = v221 + v168;
    uint64_t v224 = a3 + 4 * v221;
    *(float *)(v224 + 4) = -*(float *)(v224 + 4);
    int v225 = *(_DWORD *)(a3 + 4 * (v221 + 2));
    float v226 = -*(float *)(v224 + 12);
    uint64_t v227 = a3 + 4 * ((int)v221 + (int)v168);
    float v228 = -*(float *)(v227 + 4);
    *(_DWORD *)(a3 + 4 * v222) = *(_DWORD *)v227;
    *(float *)(v224 + 12) = v228;
    *(_DWORD *)uint64_t v227 = v225;
    *(float *)(v227 + 4) = v226;
    *(float *)(v227 + 12) = -*(float *)(v227 + 12);
    uint64_t v229 = v167 + (int)v222;
    LODWORD(v222) = v223 + v167;
    int v230 = (float *)(a3 + 4 * v229);
    *(v230 - 1) = -*(v230 - 1);
    float v231 = *v230;
    float v232 = -v230[1];
    uint64_t v233 = (float *)(a3 + 4 * (int)v222);
    float v234 = -v233[1];
    *int v230 = *v233;
    v230[1] = v234;
    *uint64_t v233 = v231;
    v233[1] = v232;
    float result = -v233[3];
    v233[3] = result;
    ++v165;
  }
  while (v165 != v166);
  return result;
}

double bitrv216neg(uint64_t a1)
{
  double result = *(double *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  *(void *)&long long v6 = *(void *)(a1 + 72);
  *(void *)&long long v7 = *(void *)(a1 + 80);
  *(void *)&long long v8 = *(void *)(a1 + 88);
  *(void *)&long long v9 = *(void *)(a1 + 96);
  *(void *)&long long v11 = *(void *)(a1 + 112);
  *(void *)&long long v10 = *(void *)(a1 + 120);
  uint64_t v12 = *(void *)(a1 + 64);
  *((void *)&v10 + 1) = *(void *)(a1 + 56);
  *(void *)&long long v13 = *(void *)(a1 + 104);
  *((void *)&v8 + 1) = *(void *)(a1 + 24);
  *(_OWORD *)(a1 + 8) = v10;
  *(_OWORD *)(a1 + 24) = v8;
  *((void *)&v13 + 1) = v4;
  *((double *)&v6 + 1) = result;
  *(_OWORD *)(a1 + 40) = v13;
  *((void *)&v11 + 1) = v5;
  *(_OWORD *)(a1 + 72) = v11;
  *((void *)&v7 + 1) = v2;
  *(_OWORD *)(a1 + 88) = v7;
  *((void *)&v9 + 1) = v3;
  *(_OWORD *)(a1 + 104) = v9;
  *(_OWORD *)(a1 + 56) = v6;
  *(void *)(a1 + 120) = v12;
  return result;
}

double bitrv208neg(uint64_t a1)
{
  double result = *(double *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  *(void *)&long long v4 = *(void *)(a1 + 48);
  *(void *)&long long v3 = *(void *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 32);
  *((void *)&v3 + 1) = *(void *)(a1 + 24);
  *(void *)&long long v6 = *(void *)(a1 + 40);
  *((double *)&v6 + 1) = result;
  *(_OWORD *)(a1 + 8) = v3;
  *((void *)&v4 + 1) = v2;
  *(_OWORD *)(a1 + 40) = v4;
  *(_OWORD *)(a1 + 24) = v6;
  *(void *)(a1 + 56) = v5;
  return result;
}

float cftb040(float *a1)
{
  float v1 = a1[1];
  float v2 = a1[4];
  float v3 = a1[5];
  float v4 = *a1 + v2;
  float v5 = v1 + v3;
  float v6 = *a1 - v2;
  float v7 = v1 - v3;
  float v8 = a1[2];
  float v9 = a1[3];
  float v10 = a1[6];
  float v11 = a1[7];
  float v12 = v8 + v10;
  float v13 = v9 + v11;
  float v14 = v8 - v10;
  float v15 = v9 - v11;
  *a1 = v4 + v12;
  a1[1] = v5 + v13;
  a1[2] = v6 + v15;
  a1[3] = v7 - v14;
  a1[4] = v4 - v12;
  a1[5] = v5 - v13;
  float result = v6 - v15;
  a1[6] = result;
  a1[7] = v7 + v14;
  return result;
}

float cftmdl1(int a1, float *a2, uint64_t a3)
{
  uint64_t v3 = (uint64_t)a1 >> 3;
  uint64_t v4 = 2 * (a1 >> 3);
  int v5 = 4 * (a1 >> 3);
  float v6 = a2[v5];
  float v7 = a2[1];
  float v8 = *a2 + v6;
  float v9 = &a2[4 * (a1 >> 3)];
  float v10 = v9[1];
  float v11 = v7 + v10;
  float v12 = *a2 - v6;
  float v13 = v7 - v10;
  uint64_t v14 = 2 * (a1 >> 3);
  float v15 = a2[v14];
  float v16 = a2[6 * (a1 >> 3)];
  float v17 = v15 + v16;
  float v18 = a2[(int)(v4 | 1)];
  int v19 = (6 * (a1 >> 3)) | 1;
  float v20 = a2[v19];
  float v21 = v15 - v16;
  *a2 = v8 + v17;
  a2[1] = v11 + (float)(v18 + v20);
  a2[v14] = v8 - v17;
  a2[(int)(v4 | 1)] = v11 - (float)(v18 + v20);
  a2[v5] = v12 - (float)(v18 - v20);
  a2[6 * (a1 >> 3)] = v12 + (float)(v18 - v20);
  v9[1] = v13 + v21;
  a2[v19] = v13 - v21;
  float v22 = *(float *)(a3 + 4);
  if (a1 >= 24)
  {
    uint64_t v23 = 24 * v3;
    uint64_t v24 = v23 + 12;
    uint64_t v25 = 4 * v5;
    uint64_t v26 = v25 + 12;
    uint64_t v27 = v25 - 4;
    uint64_t v28 = v23 - 4;
    uint64_t v29 = (float *)(a3 + 28);
    uint64_t v30 = 8 * (a1 >> 3) - 8;
    uint64_t v31 = 16 * (a1 >> 3) - 8;
    uint64_t v32 = 24 * (a1 >> 3) - 8;
    uint64_t v33 = 32 * (a1 >> 3) - 8;
    uint64_t v34 = 4 * v4 + 8;
    uint64_t v35 = 8 * v4 + 8;
    uint64_t v36 = 12 * v4 + 8;
    uint64_t v37 = 2;
    uint64_t v38 = 3;
    uint64_t v39 = (v4 << 34) - 0x200000000;
    do
    {
      float v40 = *(v29 - 3);
      float v41 = *(v29 - 2);
      float v43 = *(v29 - 1);
      float v42 = *v29;
      float v44 = &a2[v38];
      float v45 = a2[v38 - 1];
      float v46 = a2[v38];
      float v47 = *(float *)((char *)a2 + v35);
      float v48 = *(float *)((char *)a2 + v26);
      float v49 = v45 + v47;
      float v50 = v46 + v48;
      float v51 = v45 - v47;
      int v52 = (float *)((char *)a2 + v34);
      float v53 = *(float *)((char *)a2 + v36);
      float v54 = v46 - v48;
      float v55 = *(float *)((char *)a2 + v34);
      float v56 = *(float *)((char *)a2 + v34 + 4);
      float v57 = v55 + v53;
      float v58 = *(float *)((char *)a2 + v24);
      float v59 = v55 - v53;
      float v60 = v56 - v58;
      *(v44 - 1) = v49 + v57;
      *float v44 = v50 + (float)(v56 + v58);
      float v61 = v50 - (float)(v56 + v58);
      float v62 = v51 - (float)(v56 - v58);
      *int v52 = v49 - v57;
      v52[1] = v61;
      float v63 = (float)(v41 * v62) + (float)(v40 * (float)(v54 + v59));
      *(float *)((char *)a2 + v35) = (float)(v40 * v62) - (float)(v41 * (float)(v54 + v59));
      float v64 = v51 + v60;
      float v65 = v54 - v59;
      *(float *)((char *)a2 + v26) = v63;
      *(float *)((char *)a2 + v36) = (float)(v42 * v65) + (float)(v43 * v64);
      *(float *)((char *)a2 + v24) = (float)(v43 * v65) - (float)(v42 * v64);
      float v66 = (float *)((char *)a2 + v30);
      float v67 = *(float *)((char *)a2 + v32);
      float v68 = *(float *)((char *)a2 + v30);
      float v69 = *(float *)((char *)a2 + v30 + 4);
      float v70 = v68 + v67;
      float v71 = *(float *)((char *)a2 + v28);
      float v72 = *(float *)((char *)a2 + v31);
      float v73 = v69 + v71;
      float v74 = v68 - v67;
      float v75 = *(float *)((char *)a2 + v33);
      float v76 = *(float *)((char *)a2 + v27);
      float v77 = v69 - v71;
      float v78 = v72 + v75;
      uint64_t v79 = (v39 >> 30) | 4;
      float v80 = *(float *)((char *)a2 + v79);
      float v81 = v72 - v75;
      *float v66 = v70 + v78;
      v66[1] = v73 + (float)(v76 + v80);
      *(float *)((char *)a2 + v31) = v70 - v78;
      *(float *)((char *)a2 + v27) = v73 - (float)(v76 + v80);
      *(float *)((char *)a2 + v32) = (float)(v41 * (float)(v74 - (float)(v76 - v80)))
                                   - (float)(v40 * (float)(v77 + v81));
      float v82 = (float)(v40 * (float)(v74 - (float)(v76 - v80))) + (float)(v41 * (float)(v77 + v81));
      float v83 = v74 + (float)(v76 - v80);
      *(float *)((char *)a2 + v28) = v82;
      v37 += 2;
      *(float *)((char *)a2 + v33) = (float)(v43 * (float)(v77 - v81)) + (float)(v42 * v83);
      v24 += 8;
      v26 += 8;
      v27 -= 8;
      *(float *)((char *)a2 + v79) = (float)(v42 * (float)(v77 - v81)) - (float)(v43 * v83);
      v28 -= 8;
      v29 += 4;
      v30 -= 8;
      v31 -= 8;
      v39 -= 0x200000000;
      v32 -= 8;
      v33 -= 8;
      v34 += 8;
      v35 += 8;
      v36 += 8;
      v38 += 2;
    }
    while (v37 < v3);
  }
  uint64_t v84 = 3 * v3;
  uint64_t v85 = 5 * v3;
  uint64_t v86 = 7 * v3;
  float v87 = a2[5 * v3];
  float v88 = &a2[v3];
  float v89 = v88[1];
  float v90 = a2[(int)v85 + 1];
  float v91 = *v88 + v87;
  float v92 = v89 + v90;
  float v93 = *v88 - v87;
  float v94 = v89 - v90;
  float v95 = a2[v84];
  float v96 = a2[v86];
  float v97 = v95 + v96;
  float v98 = a2[(int)v84 + 1];
  float v99 = a2[(int)v86 + 1];
  float v100 = v95 - v96;
  *float v88 = v91 + v97;
  v88[1] = v92 + (float)(v98 + v99);
  a2[v84] = v91 - v97;
  a2[(int)v84 + 1] = v92 - (float)(v98 + v99);
  a2[v85] = v22 * (float)((float)(v93 - (float)(v98 - v99)) - (float)(v94 + v100));
  a2[(int)v85 + 1] = v22 * (float)((float)(v94 + v100) + (float)(v93 - (float)(v98 - v99)));
  float v101 = v93 + (float)(v98 - v99);
  float v102 = v94 - v100;
  a2[v86] = -(float)(v22 * (float)(v102 + v101));
  float result = -(float)(v22 * (float)(v102 - v101));
  a2[(int)v86 + 1] = result;
  return result;
}

uint64_t cfttree(int a1, int a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  unsigned int v10 = a1;
  if ((a3 & 3) != 0)
  {
    float v11 = (float *)(a4 + 4 * (a2 - a1));
    if ((a3 & 1) == 0)
    {
      cftmdl2(a1, v11, a6 + 4 * (a5 - a1));
      return 0;
    }
    cftmdl1(a1, v11, a6 + 4 * (a5 - (a1 >> 1)));
    return 1;
  }
  do
  {
    unsigned int v12 = a3;
    v10 *= 4;
    a3 >>= 2;
  }
  while ((v12 & 0xC) == 0);
  if (((v12 >> 2) & 1) == 0)
  {
    if ((int)v10 >= 129)
    {
      do
      {
        cftmdl2(v10, (float *)(a4 + 4 * (int)(a2 - v10)), a6 + 4 * (int)(a5 - v10));
        BOOL v13 = v10 > 0x203;
        v10 >>= 2;
      }
      while (v13);
    }
    return 0;
  }
  if ((int)v10 < 129) {
    return 1;
  }
  uint64_t v14 = (v12 >> 2) & 1;
  do
  {
    cftmdl1(v10, (float *)(a4 + 4 * (int)(a2 - v10)), a6 + 4 * (int)(a5 - (v10 >> 1)));
    BOOL v13 = v10 > 0x203;
    v10 >>= 2;
  }
  while (v13);
  return v14;
}

float cftmdl2(int a1, float *a2, uint64_t a3)
{
  int v3 = a1 >> 3;
  uint64_t v4 = (uint64_t)a1 >> 3;
  uint64_t v5 = 2 * (a1 >> 3);
  float v6 = *(float *)(a3 + 4);
  float v7 = &a2[4 * (a1 >> 3)];
  float v8 = a2[1];
  float v9 = v7[1];
  float v10 = *a2 - v9;
  float v11 = v8 + *v7;
  float v12 = *a2 + v9;
  float v13 = v8 - *v7;
  uint64_t v14 = 2 * (a1 >> 3);
  float v15 = a2[v14];
  float v16 = &a2[6 * (a1 >> 3)];
  float v17 = v16[1];
  float v18 = v15 - v17;
  uint64_t v19 = (int)(v5 | 1);
  float v20 = a2[v19];
  float v21 = v20 + *v16;
  float v22 = v15 + v17;
  float v23 = v20 - *v16;
  float v24 = v6 * (float)(v18 - v21);
  float v25 = v6 * (float)(v18 + v21);
  *a2 = v10 + v24;
  a2[1] = v11 + v25;
  a2[v14] = v10 - v24;
  a2[v19] = v11 - v25;
  float v26 = v6 * (float)(v22 - v23);
  float v27 = v6 * (float)(v22 + v23);
  *float v7 = v12 - v27;
  v7[1] = v13 + v26;
  float *v16 = v12 + v27;
  v16[1] = v13 - v26;
  if (a1 >= 24)
  {
    uint64_t v28 = 4 * v3;
    uint64_t v29 = a3 + 16 * v3;
    uint64_t v30 = 24 * v3 + 8;
    uint64_t v31 = (float *)(a3 + 28);
    uint64_t v32 = 8 * v5 + 8;
    uint64_t v33 = 4 * v5 + 12;
    uint64_t v34 = 16 * v5 - 8;
    uint64_t v35 = (float *)(v29 - 8);
    uint64_t v36 = 24 * v4;
    uint64_t v37 = v36 + 12;
    uint64_t v38 = 4 * v28;
    uint64_t v39 = 4 * v28 + 12;
    uint64_t v40 = v38 - 4;
    uint64_t v41 = v36 - 4;
    uint64_t v42 = 4 * v5 - 8;
    uint64_t v43 = 8 * v5 - 8;
    uint64_t v44 = 12 * v5 - 8;
    uint64_t v45 = 2;
    uint64_t v46 = 2;
    uint64_t v47 = (v5 << 34) - 0x200000000;
    do
    {
      float v48 = *(v31 - 3);
      float v49 = *(v31 - 2);
      float v51 = *(v31 - 1);
      float v50 = *v31;
      float v52 = *(v35 - 2);
      float v53 = *(v35 - 1);
      float v54 = *v35;
      float v55 = v35[1];
      float v56 = &a2[v46];
      float v57 = *(float *)((char *)a2 + v39);
      float v58 = *(float *)((char *)a2 + v32);
      float v59 = a2[v46];
      float v60 = a2[v46 + 1];
      float v61 = v59 - v57;
      float v62 = v60 + v58;
      float v63 = v59 + v57;
      float v64 = (float *)((char *)a2 + v33);
      float v65 = *(float *)((char *)a2 + v33 - 4);
      float v66 = *(float *)((char *)a2 + v33);
      float v67 = v60 - v58;
      float v68 = *(float *)((char *)a2 + v37);
      float v69 = *(float *)((char *)a2 + v30);
      float v70 = v65 - v68;
      float v71 = v66 + v69;
      float v72 = v65 + v68;
      float v73 = v66 - v69;
      float v74 = v49 * v61;
      float v75 = (float)(v48 * v61) - (float)(v49 * v62);
      float v76 = v74 + (float)(v48 * v62);
      float v77 = (float)(v53 * v70) - (float)(v52 * v71);
      float v78 = (float)(v52 * v70) + (float)(v53 * v71);
      *float v56 = v75 + v77;
      v56[1] = v76 + v78;
      *(v64 - 1) = v75 - v77;
      *float v64 = v76 - v78;
      float v79 = (float)(v50 * v67) + (float)(v51 * v63);
      float v80 = (float)(v51 * v67) - (float)(v50 * v63);
      float v81 = (float)(v54 * v73) + (float)(v55 * v72);
      float v82 = (float)(v55 * v73) - (float)(v54 * v72);
      *(float *)((char *)a2 + v32) = v79 + v81;
      *(float *)((char *)a2 + v39) = v80 + v82;
      *(float *)((char *)a2 + v30) = v79 - v81;
      *(float *)((char *)a2 + v37) = v80 - v82;
      float v83 = (float *)((char *)a2 + v42);
      float v84 = *(float *)((char *)a2 + v41);
      float v85 = *(float *)((char *)a2 + v42);
      float v86 = *(float *)((char *)a2 + v42 + 4);
      float v87 = *(float *)((char *)a2 + v44);
      float v88 = *(float *)((char *)a2 + v43);
      float v89 = v85 - v84;
      uint64_t v90 = (v47 >> 30) | 4;
      float v91 = *(float *)((char *)a2 + v90);
      float v92 = v86 + v87;
      float v93 = v85 + v84;
      float v94 = *(float *)((char *)a2 + v40);
      float v95 = *(float *)((char *)a2 + v34);
      float v96 = v86 - v87;
      float v97 = v88 - v91;
      float v98 = v94 + v95;
      float v99 = v88 + v91;
      float v100 = v94 - v95;
      float v101 = (float)(v52 * v89) - (float)(v53 * v92);
      float v102 = (float)(v53 * v89) + (float)(v52 * v92);
      float v103 = (float)(v49 * v97) - (float)(v48 * v98);
      float v104 = (float)(v48 * v97) + (float)(v49 * v98);
      *float v83 = v101 + v103;
      v83[1] = v102 + v104;
      float v105 = (float)(v55 * v96) + (float)(v54 * v93);
      float v106 = (float)(v54 * v96) - (float)(v55 * v93);
      *(float *)((char *)a2 + v43) = v101 - v103;
      float v107 = (float)(v51 * v100) + (float)(v50 * v99);
      *(float *)((char *)a2 + v40) = v102 - v104;
      *(float *)((char *)a2 + v44) = v105 + v107;
      float v108 = (float)(v50 * v100) - (float)(v51 * v99);
      *(float *)((char *)a2 + v41) = v106 + v108;
      v45 += 2;
      v46 += 2;
      *(float *)((char *)a2 + v34) = v105 - v107;
      v30 += 8;
      v31 += 4;
      v32 += 8;
      *(float *)((char *)a2 + v90) = v106 - v108;
      v33 += 8;
      v34 -= 8;
      v35 -= 4;
      v37 += 8;
      v39 += 8;
      v40 -= 8;
      v41 -= 8;
      v47 -= 0x200000000;
      v42 -= 8;
      v43 -= 8;
      v44 -= 8;
    }
    while (v45 < v4);
  }
  float v109 = *(float *)(a3 + 4 * v5);
  float v110 = *(float *)(a3 + 4 * v19);
  uint64_t v111 = 3 * v4;
  uint64_t v112 = 5 * v4;
  uint64_t v113 = 7 * v4;
  float v114 = &a2[v4];
  uint64_t v115 = &a2[v112];
  float v116 = v115[1];
  float v117 = v114[1];
  float v118 = *v114 - v116;
  float v119 = v117 + *v115;
  float v120 = *v114 + v116;
  float v121 = a2[v111];
  float v122 = v117 - *v115;
  int v123 = &a2[v113];
  float v124 = v123[1];
  float v125 = a2[(int)v111 + 1];
  float v126 = v121 - v124;
  float v127 = a2[(int)v113];
  float v128 = v125 + v127;
  float v129 = v121 + v124;
  float v130 = v125 - v127;
  float v131 = (float)(v109 * v118) - (float)(v110 * v119);
  float v132 = (float)(v110 * v118) + (float)(v109 * v119);
  float v133 = (float)(v110 * v126) - (float)(v109 * v128);
  float v134 = (float)(v109 * v126) + (float)(v110 * v128);
  *float v114 = v131 + v133;
  v114[1] = v132 + v134;
  a2[v111] = v131 - v133;
  a2[(int)v111 + 1] = v132 - v134;
  float v135 = (float)(v110 * v120) - (float)(v109 * v122);
  float v136 = (float)(v109 * v120) + (float)(v110 * v122);
  float v137 = (float)(v109 * v129) - (float)(v110 * v130);
  float v138 = (float)(v110 * v129) + (float)(v109 * v130);
  *uint64_t v115 = v135 - v137;
  v115[1] = v136 - v138;
  a2[(int)v113] = v135 + v137;
  float result = v136 + v138;
  v123[1] = result;
  return result;
}

float cftf162(float *a1, float *a2)
{
  float v2 = a1[2];
  float v3 = a1[3];
  float v5 = a1[18];
  float v4 = a1[19];
  float v6 = a2[4];
  float v7 = a2[5];
  float v114 = (float)(v7 * (float)(v2 - v4)) + (float)(v6 * (float)(v3 + v5));
  float v116 = (float)(v6 * (float)(v2 - v4)) - (float)(v7 * (float)(v3 + v5));
  float v8 = a1[10];
  float v9 = a1[11];
  float v11 = a1[26];
  float v10 = a1[27];
  float v13 = a2[6];
  float v12 = a2[7];
  float v111 = (float)(v13 * (float)(v8 - v10)) - (float)(v12 * (float)(v9 + v11));
  float v113 = (float)-(float)(v13 * (float)(v9 + v11)) - (float)(v12 * (float)(v8 - v10));
  float v14 = v2 + v4;
  float v15 = v3 - v5;
  float v109 = (float)(v13 * v15) - (float)(v12 * v14);
  float v110 = (float)(v12 * v15) + (float)(v13 * v14);
  float v16 = (float)(v6 * (float)(v9 - v11)) - (float)(v7 * (float)(v8 + v10));
  float v17 = a1[4];
  float v18 = a1[5];
  float v20 = a1[20];
  float v19 = a1[21];
  float v21 = a2[8];
  float v22 = a2[9];
  float v23 = (float)(v21 * (float)(v17 - v19)) - (float)(v22 * (float)(v18 + v20));
  float v107 = (float)(v22 * (float)(v17 - v19)) + (float)(v21 * (float)(v18 + v20));
  float v108 = (float)(v7 * (float)(v9 - v11)) + (float)(v6 * (float)(v8 + v10));
  float v24 = a1[12];
  float v25 = a1[13];
  float v27 = a1[28];
  float v26 = a1[29];
  float v28 = (float)(v22 * (float)(v24 - v26)) - (float)(v21 * (float)(v25 + v27));
  float v29 = (float)(v21 * (float)(v24 - v26)) + (float)(v22 * (float)(v25 + v27));
  float v30 = v17 + v19;
  float v31 = v18 - v20;
  float v106 = (float)(v22 * v30) - (float)(v21 * v31);
  float v104 = (float)(v21 * v30) + (float)(v22 * v31);
  float v32 = (float)(v21 * (float)(v24 + v26)) - (float)(v22 * (float)(v25 - v27));
  float v33 = (float)(v22 * (float)(v24 + v26)) + (float)(v21 * (float)(v25 - v27));
  float v34 = a1[6];
  float v35 = a1[7];
  float v37 = a1[22];
  float v36 = a1[23];
  float v38 = v34 - v36;
  float v39 = a1[14];
  float v40 = a1[15];
  float v42 = a1[30];
  float v41 = a1[31];
  float v43 = (float)(v7 * (float)(v39 - v41)) - (float)(v6 * (float)(v40 + v42));
  float v44 = (float)(v6 * (float)(v39 - v41)) + (float)(v7 * (float)(v40 + v42));
  float v45 = v34 + v36;
  float v46 = (float)(v6 * (float)(v35 - v37)) + (float)(v7 * v45);
  float v47 = a2[1];
  float v48 = (float)(v7 * (float)(v35 - v37)) - (float)(v6 * v45);
  float v49 = a1[8];
  float v50 = a1[9];
  float v51 = v35 + v37;
  float v52 = (float)(v12 * v51) + (float)(v13 * v38);
  float v53 = (float)(v13 * v51) - (float)(v12 * v38);
  float v54 = v39 + v41;
  float v56 = a1[24];
  float v55 = a1[25];
  float v57 = v40 - v42;
  float v58 = (float)-(float)(v13 * v57) - (float)(v12 * v54);
  float v59 = (float)(v13 * v54) - (float)(v12 * v57);
  float v60 = v47 * (float)((float)(v49 - v55) - (float)(v50 + v56));
  float v61 = a1[1];
  float v62 = a1[16];
  float v63 = a1[17];
  float v64 = *a1 - v63;
  float v65 = v64 + v60;
  float v66 = v64 - v60;
  float v67 = v47 * (float)((float)(v49 - v55) + (float)(v50 + v56));
  float v68 = (float)(v61 + v62) + v67;
  float v69 = (float)(v61 + v62) - v67;
  float v70 = *a1 + v63;
  float v71 = v61 - v62;
  float v72 = v47 * (float)((float)(v49 + v55) + (float)(v50 - v56));
  float v103 = v70 - v72;
  float v73 = v70 + v72;
  float v74 = v47 * (float)((float)(v49 + v55) - (float)(v50 - v56));
  float v75 = v71 + v74;
  float v105 = v71 - v74;
  float v76 = v114 + v111;
  float v77 = v114 - v111;
  float v78 = v109 - v16;
  float v115 = v109 + v16;
  float v79 = v23 + v28;
  float v80 = v23 - v28;
  float v81 = v107 + v29;
  float v82 = v107 - v29;
  float v83 = v32;
  float v84 = v106 - v32;
  float v85 = v104 - v33;
  float v112 = v104 + v33;
  float v86 = v52 + v43;
  float v87 = v52 - v43;
  float v88 = v53 + v44;
  float v89 = v53 - v44;
  float v90 = v46 + v58;
  float v91 = v46 - v58;
  float v92 = v48 + v59;
  float v93 = v48 - v59;
  *a1 = (float)(v65 + v79) + (float)((float)(v116 + v113) + v86);
  a1[1] = (float)(v68 + v81) + (float)(v76 + v88);
  a1[2] = (float)(v65 + v79) - (float)((float)(v116 + v113) + v86);
  a1[3] = (float)(v68 + v81) - (float)(v76 + v88);
  a1[4] = (float)(v65 - v79) - (float)(v76 - v88);
  a1[5] = (float)(v68 - v81) + (float)((float)(v116 + v113) - v86);
  a1[6] = (float)(v65 - v79) + (float)(v76 - v88);
  a1[7] = (float)(v68 - v81) - (float)((float)(v116 + v113) - v86);
  float v94 = v47 * (float)((float)((float)(v116 - v113) - v89) - (float)(v77 + v87));
  float v95 = v47 * (float)((float)((float)(v116 - v113) - v89) + (float)(v77 + v87));
  a1[8] = (float)(v66 - v82) + v94;
  a1[9] = (float)(v69 + v80) + v95;
  a1[10] = (float)(v66 - v82) - v94;
  a1[11] = (float)(v69 + v80) - v95;
  float v96 = v47 * (float)((float)((float)(v116 - v113) + v89) - (float)(v77 - v87));
  float v97 = v47 * (float)((float)((float)(v116 - v113) + v89) + (float)(v77 - v87));
  a1[12] = (float)(v66 + v82) - v97;
  a1[13] = (float)(v69 - v80) + v96;
  a1[14] = (float)(v66 + v82) + v97;
  a1[15] = (float)(v69 - v80) - v96;
  a1[16] = (float)(v103 + v84) + (float)((float)(v110 - v108) - v90);
  a1[17] = (float)(v75 + v85) + (float)(v78 - v92);
  a1[18] = (float)(v103 + v84) - (float)((float)(v110 - v108) - v90);
  a1[19] = (float)(v75 + v85) - (float)(v78 - v92);
  a1[20] = (float)(v103 - v84) - (float)(v78 + v92);
  a1[21] = (float)(v75 - v85) + (float)((float)(v110 - v108) + v90);
  a1[22] = (float)(v103 - v84) + (float)(v78 + v92);
  a1[23] = (float)(v75 - v85) - (float)((float)(v110 - v108) + v90);
  float v98 = v47 * (float)((float)((float)(v110 + v108) + v93) - (float)(v115 - v91));
  float v99 = v47 * (float)((float)((float)(v110 + v108) + v93) + (float)(v115 - v91));
  a1[24] = (float)(v73 - v112) + v98;
  a1[25] = (float)(v105 + (float)(v106 + v83)) + v99;
  a1[26] = (float)(v73 - v112) - v98;
  a1[27] = (float)(v105 + (float)(v106 + v83)) - v99;
  float v100 = v47 * (float)((float)((float)(v110 + v108) - v93) - (float)(v115 + v91));
  float v101 = v47 * (float)((float)((float)(v110 + v108) - v93) + (float)(v115 + v91));
  a1[28] = (float)(v73 + v112) - v101;
  a1[29] = (float)(v105 - (float)(v106 + v83)) + v100;
  float result = (float)(v73 + v112) + v101;
  a1[30] = result;
  a1[31] = (float)(v105 - (float)(v106 + v83)) - v100;
  return result;
}

float cftf082(float *a1, float *a2)
{
  float v2 = a2[1];
  float v3 = a2[2];
  float v4 = a2[3];
  float v5 = a1[1];
  float v7 = a1[8];
  float v6 = a1[9];
  float v8 = *a1 - v6;
  float v9 = v5 + v7;
  float v10 = *a1 + v6;
  float v11 = v5 - v7;
  float v12 = a1[4];
  float v13 = a1[5];
  float v15 = a1[12];
  float v14 = a1[13];
  float v16 = v2 * (float)((float)(v12 - v14) - (float)(v13 + v15));
  float v17 = v2 * (float)((float)(v12 - v14) + (float)(v13 + v15));
  float v18 = v12 + v14;
  float v19 = v13 - v15;
  float v20 = v2 * (float)(v18 - v19);
  float v21 = v2 * (float)(v18 + v19);
  float v22 = a1[2];
  float v23 = a1[3];
  float v25 = a1[10];
  float v24 = a1[11];
  float v26 = (float)(v3 * (float)(v22 - v24)) - (float)(v4 * (float)(v23 + v25));
  float v27 = (float)(v4 * (float)(v22 - v24)) + (float)(v3 * (float)(v23 + v25));
  float v28 = v22 + v24;
  float v29 = v23 - v25;
  float v30 = (float)(v4 * v28) - (float)(v3 * v29);
  float v31 = (float)(v3 * v28) + (float)(v4 * v29);
  float v32 = a1[6];
  float v33 = a1[7];
  float v35 = a1[14];
  float v34 = a1[15];
  float v36 = (float)(v4 * (float)(v32 - v34)) - (float)(v3 * (float)(v33 + v35));
  float v37 = (float)(v3 * (float)(v32 - v34)) + (float)(v4 * (float)(v33 + v35));
  float v38 = v32 + v34;
  float v39 = v33 - v35;
  float v40 = (float)(v3 * v38) - (float)(v4 * v39);
  float v41 = (float)(v4 * v38) + (float)(v3 * v39);
  *a1 = (float)(v8 + v16) + (float)(v26 + v36);
  a1[1] = (float)(v9 + v17) + (float)(v27 + v37);
  a1[2] = (float)(v8 + v16) - (float)(v26 + v36);
  a1[3] = (float)(v9 + v17) - (float)(v27 + v37);
  a1[4] = (float)(v8 - v16) - (float)(v27 - v37);
  a1[5] = (float)(v9 - v17) + (float)(v26 - v36);
  a1[6] = (float)(v8 - v16) + (float)(v27 - v37);
  a1[7] = (float)(v9 - v17) - (float)(v26 - v36);
  a1[8] = (float)(v10 - v21) + (float)(v30 - v40);
  a1[9] = (float)(v11 + v20) + (float)(v31 - v41);
  a1[10] = (float)(v10 - v21) - (float)(v30 - v40);
  a1[11] = (float)(v11 + v20) - (float)(v31 - v41);
  float v42 = v10 + v21;
  float v43 = v11 - v20;
  a1[12] = v42 - (float)(v31 + v41);
  a1[13] = v43 + (float)(v30 + v40);
  float result = v42 + (float)(v31 + v41);
  a1[14] = result;
  a1[15] = v43 - (float)(v30 + v40);
  return result;
}

uint64_t axpy(uint64_t result, float *a2, int a3, float *a4, int a5, float a6)
{
  if (((a4 | a2) & 0x1F) != 0)
  {
    if ((int)result >= 1)
    {
      uint64_t v6 = result;
      do
      {
        *a4 = *a4 + (float)(a6 * *a2);
        a4 += a5;
        a2 += a3;
        --v6;
      }
      while (v6);
    }
  }
  else if ((int)result >= 1)
  {
    uint64_t v7 = result;
    do
    {
      *a4 = *a4 + (float)(a6 * *a2);
      a4 += a5;
      a2 += a3;
      --v7;
    }
    while (v7);
  }
  return result;
}

float dot(float *a1, signed int a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5 = (~a5 + a2);
  if ((int)v5 < 1)
  {
    unsigned int v12 = 0;
    float result = 0.0;
  }
  else
  {
    uint64_t v6 = (float *)(a3 + 4 * a5);
    float result = 0.0;
    float v8 = a1;
    do
    {
      float v9 = *v8++;
      float v10 = v9;
      float v11 = *v6++;
      float result = result + (float)(v10 * v11);
      --v5;
    }
    while (v5);
    unsigned int v12 = a2 - a5 - 1;
  }
  if ((int)v12 < a2)
  {
    float v13 = (float *)(a4 + 4 * (a5 - a2 + 1 + (unint64_t)v12));
    float v14 = &a1[v12];
    unint64_t v15 = a2 - (unint64_t)v12;
    do
    {
      float v16 = *v14++;
      float v17 = v16;
      float v18 = *v13++;
      float result = result + (float)(v17 * v18);
      --v15;
    }
    while (v15);
  }
  return result;
}

uint64_t src_generate_fir_coeffs(uint64_t *a1, unsigned int a2, float **a3, float a4)
{
  uint64_t v8 = a2;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, void, uint64_t))(a1[1] + 16))(a1[2], a2, 4);
  if (!v9) {
    goto LABEL_26;
  }
  float v13 = (float *)v9;
  if (a2)
  {
    uint64_t v14 = 0;
    float v15 = a4 + a4;
    do
    {
      float v16 = v15 * (float)((float)v14 - (float)((float)(int)(a2 - 1) * 0.5));
      float v17 = 1.0;
      if (v16 != 0.0) {
        float v17 = sinf(v16 * 3.1416) / (float)(v16 * 3.1416);
      }
      v13[v14++] = v15 * v17;
    }
    while (v8 != v14);
  }
  uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v8, 4);
  if (v18)
  {
    if (a2)
    {
      uint64_t v19 = 0;
      do
      {
        int v20 = 0;
        float v21 = (float)((float)((float)((float)v19 * 2.0) + 2.0) - (float)((float)a2 + 1.0))
            / (float)((float)a2 + 1.0);
        float v22 = (float)(sqrtf(1.0 - (float)(v21 * v21)) * 3.2) * 0.5;
        float v23 = 0.0;
        unsigned int v24 = 1;
        for (int i = 2; i != 11; ++i)
        {
          if (v24 >= 2)
          {
            int v28 = 0;
            int v26 = 1;
            float v27 = v22;
            do
            {
              float v27 = v22 * v27;
              v26 *= v28 + 2;
              ++v28;
            }
            while (v20 != v28);
          }
          else
          {
            int v26 = 1;
            float v27 = v22;
          }
          float v23 = v23 + (float)((float)(v27 / (float)v26) * (float)(v27 / (float)v26));
          ++v24;
          ++v20;
        }
        int v29 = 0;
        float v30 = 0.0;
        unsigned int v31 = 1;
        for (int j = 2; j != 11; ++j)
        {
          if (v31 >= 2)
          {
            int v35 = 0;
            int v33 = 1;
            float v34 = 1.6;
            do
            {
              float v34 = v34 * 1.6;
              v33 *= v35 + 2;
              ++v35;
            }
            while (v29 != v35);
          }
          else
          {
            int v33 = 1;
            float v34 = 1.6;
          }
          float v30 = v30 + (float)((float)(v34 / (float)v33) * (float)(v34 / (float)v33));
          ++v31;
          ++v29;
        }
        *(float *)(v18 + 4 * v19++) = (float)(v23 + 1.0) / (float)(v30 + 1.0);
      }
      while (v19 != v8);
      float v36 = v13;
      float v37 = (float *)v18;
      do
      {
        float v38 = *v37++;
        *float v36 = v38 * *v36;
        ++v36;
        --v8;
      }
      while (v8);
    }
    *a3 = v13;
    (*(void (**)(uint64_t, uint64_t))(a1[1] + 48))(a1[2], v18);
    return 0;
  }
  else
  {
LABEL_26:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v10, v11, v12, v40);
    return 10;
  }
}

uint64_t src_generate_fir_filter(uint64_t *a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5, uint64_t *a6)
{
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 48);
  if (!v12) {
    goto LABEL_13;
  }
  uint64_t v16 = v12;
  int v17 = a3 / a4;
  uint64_t v18 = a3 % a4 ? (v17 + 1) : v17;
  uint64_t v19 = (*(uint64_t (**)(uint64_t, void, uint64_t))(a1[1] + 16))(a1[2], v18 * a4, 4);
  if (!v19) {
    goto LABEL_13;
  }
  unsigned int v20 = 0;
  do
  {
    unsigned int v21 = v20 + 1;
    if (v18)
    {
      uint64_t v22 = 0;
      uint64_t v23 = v18;
      do
      {
        *(_DWORD *)(v19 + 4 * (v21 * v18 + ~v22++)) = *(_DWORD *)(a2 + 4 * v20);
        v20 += a4;
        --v23;
      }
      while (v23);
    }
    unsigned int v20 = v21;
  }
  while (v21 != a4);
  *(void *)uint64_t v16 = v19;
  *(_DWORD *)(v16 + 8) = a4;
  *(_DWORD *)(v16 + 12) = v18;
  *(_DWORD *)(v16 + 16) = a4;
  *(_DWORD *)(v16 + 20) = a5;
  *(void *)(v16 + 24) = 0;
  *(_DWORD *)(v16 + 40) = v18 - 1;
  uint64_t v24 = (*(uint64_t (**)(uint64_t))(a1[1] + 16))(a1[2]);
  *(void *)(v16 + 32) = v24;
  if (v24)
  {
    uint64_t result = 0;
    *a6 = v16;
  }
  else
  {
LABEL_13:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v13, v14, v15, v26);
    return 10;
  }
  return result;
}

uint64_t src_generate(uint64_t *a1, unsigned int a2, int a3, uint64_t *a4)
{
  uint64_t v11 = 0;
  *a4 = 0;
  uint64_t fir_filter = src_generate_fir_coeffs(a1, 0x108u, &v11, 0.5 / (float)a2);
  uint64_t v9 = v11;
  if (!fir_filter)
  {
    uint64_t fir_filter = src_generate_fir_filter(a1, (uint64_t)v11, 0x108u, a2, a3, a4);
    if (!v9) {
      return fir_filter;
    }
    goto LABEL_3;
  }
  if (v11) {
LABEL_3:
  }
    (*(void (**)(uint64_t, float *))(a1[1] + 48))(a1[2], v9);
  return fir_filter;
}

uint64_t src_filt(uint64_t *a1, int *a2, unsigned int a3, uint64_t a4)
{
  unsigned int v7 = *((_DWORD *)a1 + 6);
  int v6 = *((_DWORD *)a1 + 7);
  if (v6 >= (int)a3)
  {
    uint64_t v9 = 0;
    uint64_t v13 = (_DWORD *)a1[4];
  }
  else
  {
    LODWORD(v9) = 0;
    unsigned int v10 = *((_DWORD *)a1 + 4);
    signed int v11 = *((_DWORD *)a1 + 3);
    int v26 = *((_DWORD *)a1 + 5) % v10;
    int v27 = *((_DWORD *)a1 + 5);
    uint64_t v12 = *a1;
    float v25 = a1;
    uint64_t v13 = (_DWORD *)a1[4];
    do
    {
      unsigned int v14 = v9;
      uint64_t v15 = v13;
      float v16 = dot((float *)(v12 + 4 * v11 * v7), v11, (uint64_t)v13, (uint64_t)a2, v6);
      uint64_t v13 = v15;
      uint64_t v9 = v14 + 1;
      *(float *)(a4 + 4 * v14) = v16 * (float)v10;
      v6 += (v7 + v27) / v10;
      unsigned int v7 = (v7 + v26) % v10;
    }
    while (v6 < (int)a3);
    a1 = v25;
  }
  *((_DWORD *)a1 + 6) = v7;
  *((_DWORD *)a1 + 7) = v6 - a3;
  uint64_t v17 = *((unsigned int *)a1 + 10);
  if (v17 >= a3)
  {
    uint64_t v18 = v17 - a3;
    if (v17 != a3)
    {
      unsigned int v19 = a3;
      unsigned int v20 = v13;
      do
      {
        *v20++ = v13[v19++];
        --v18;
      }
      while (v18);
    }
    if (a3)
    {
      uint64_t v21 = a3;
      int v22 = v17 - a3;
      do
      {
        int v23 = *a2++;
        v13[v22++] = v23;
        --v21;
      }
      while (v21);
    }
  }
  else
  {
    memcpy(v13, &a2[a3 - v17], 4 * v17);
  }
  return v9;
}

void gemm(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, float32x4_t *a7, _DWORD *a8, uint64_t a9)
{
  if (!a8)
  {
    LODWORD(v15) = 1;
    unsigned int v16 = a4;
LABEL_12:
    gemm_v2((uint64_t)a1, v15, a2, a3, a4, a5, a4, a6, v16, a7, a3);
    return;
  }
  if (!*a8)
  {
    uint64_t v15 = a8[2];
    if (a8[4])
    {
      gemm_impl_qntz((uint64_t)a1, v15, a2, a3, a4, a5, a6, (uint64_t)a7, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))gemm_v5);
      return;
    }
    if (v15) {
      unsigned int v16 = a4;
    }
    else {
      unsigned int v16 = a3;
    }
    goto LABEL_12;
  }
  uint64_t v14 = *a1;
  log_OutText(v14, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Block Sparse only support SSE or NEON \n", a5, (uint64_t)a7, (uint64_t)a8, a9);
}

uint64_t gemm_impl_qntz(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  if (a9) {
    return a9(result, a2, a3, a4);
  }
  return result;
}

void gemm_ex(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float32x4_t *a9, int a10, _DWORD *a11)
{
  if (a11)
  {
    if (*a11)
    {
      uint64_t v17 = *a1;
      log_OutText(v17, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Block Sparse only support SSE or NEON\n", a5, a6, a8, (uint64_t)a9);
      return;
    }
    uint64_t v18 = a11[2];
    if (a11[4])
    {
      LODWORD(v20) = a10;
      LODWORD(v19) = a8;
      gemm_impl_ex_qntz((uint64_t)a1, v18, a2, a3, a4, a5, a6, a7, v19, (uint64_t)a9, v20, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))gemm_v5);
      return;
    }
  }
  else
  {
    LODWORD(v18) = 1;
  }
  gemm_v2((uint64_t)a1, v18, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

uint64_t gemm_impl_ex_qntz(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t (*a12)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  if (a12) {
    return a12(result, a2, a3, a4);
  }
  return result;
}

void fast_tanh(float *a1, int a2, float *a3)
{
  float v4 = a1;
  if ((a1 & 0x1F) != 0)
  {
    if (a2 >= 1)
    {
      uint64_t v5 = a2;
      do
      {
        float v6 = 1.0;
        if (*v4 <= 9.0)
        {
          float v6 = -1.0;
          if (*v4 >= -9.0) {
            float v6 = tanhf(*v4);
          }
        }
        *a3++ = v6;
        ++v4;
        --v5;
      }
      while (v5);
    }
  }
  else if (a2 >= 1)
  {
    uint64_t v7 = a2;
    do
    {
      float v8 = 1.0;
      if (*v4 <= 9.0)
      {
        float v8 = -1.0;
        if (*v4 >= -9.0) {
          float v8 = tanhf(*v4);
        }
      }
      *a3++ = v8;
      ++v4;
      --v7;
    }
    while (v7);
  }
}

void gelu_array_f32(unsigned int a1, float *a2)
{
  float v2 = a2;
  if ((a2 & 0x1F) != 0)
  {
    if (a1)
    {
      uint64_t v3 = a1;
      do
      {
        float v4 = *v2;
        float v5 = (float)(*v2 * (float)(*v2 * (float)(*v2 * 0.035677))) + (float)(*v2 * 0.79789);
        *v2++ = v4 * (float)(1.0 - (float)(1.0 / (float)(expf(v5 + v5) + 1.0)));
        --v3;
      }
      while (v3);
    }
  }
  else if (a1)
  {
    uint64_t v6 = a1;
    do
    {
      float v7 = *v2;
      float v8 = (float)(*v2 * (float)(*v2 * (float)(*v2 * 0.035677))) + (float)(*v2 * 0.79789);
      *v2++ = v7 * (float)(1.0 - (float)(1.0 / (float)(expf(v8 + v8) + 1.0)));
      --v6;
    }
    while (v6);
  }
}

void sigmoid_c(float *a1, unsigned int a2, float *a3)
{
  if (a2)
  {
    uint64_t v5 = a2;
    do
    {
      float v6 = *a1++;
      float v7 = 1.0 / (fast_exp_single(-v6) + 1.0);
      *a3++ = v7;
      --v5;
    }
    while (v5);
  }
}

void sigmoid(float *a1, unsigned int a2, float *a3)
{
}

void softmax_simple(float *a1, unsigned int a2, float *a3)
{
  uint64_t v3 = a3;
  if (a2)
  {
    uint64_t v4 = a2;
    float v5 = -3.4028e38;
    uint64_t v6 = a2;
    float v7 = a1;
    do
    {
      float v8 = *v7++;
      float v9 = v8;
      if (v8 > v5) {
        float v5 = v9;
      }
      --v6;
    }
    while (v6);
    do
    {
      *(float *)((char *)a3 + v6) = *(float *)((char *)a1 + v6) - v5;
      v6 += 4;
    }
    while (4 * a2 != v6);
    fast_exp(a3, a2, a3);
    float v10 = 0.0;
    uint64_t v11 = v4;
    uint64_t v12 = v3;
    do
    {
      float v13 = *v12++;
      float v10 = v10 + v13;
      --v11;
    }
    while (v11);
    if (v10 != 0.0)
    {
      float v14 = 1.0 / v10;
      do
      {
        *uint64_t v3 = v14 * *v3;
        ++v3;
        --v4;
      }
      while (v4);
    }
  }
  else
  {
    fast_exp(a3, 0, a3);
  }
}

void softmax_simple_temp(float *a1, unsigned int a2, float *a3, float a4)
{
  if (a4 >= 0.00000001)
  {
    uint64_t v4 = a3;
    if (a2)
    {
      uint64_t v5 = a2;
      float v6 = -3.4028e38;
      uint64_t v7 = a2;
      float v8 = a1;
      float v9 = 1.0 / a4;
      do
      {
        float v10 = *v8++;
        float v11 = v10;
        if (v10 > v6) {
          float v6 = v11;
        }
        --v7;
      }
      while (v7);
      do
      {
        *(float *)((char *)a3 + v7) = v9 * (float)(*(float *)((char *)a1 + v7) - v6);
        v7 += 4;
      }
      while (4 * a2 != v7);
      fast_exp(a3, a2, a3);
      float v12 = 0.0;
      uint64_t v13 = v5;
      float v14 = v4;
      do
      {
        float v15 = *v14++;
        float v12 = v12 + v15;
        --v13;
      }
      while (v13);
      if (v12 != 0.0)
      {
        float v16 = 1.0 / v12;
        do
        {
          *uint64_t v4 = v16 * *v4;
          ++v4;
          --v5;
        }
        while (v5);
      }
    }
    else
    {
      fast_exp(a3, 0, a3);
    }
  }
}

void softmax(float *a1, unsigned int a2, int a3, float *a4, float a5)
{
  if (a5 >= 0.00000001)
  {
    if (a3 == 1)
    {
      if ((float)(a5 + -1.0) >= 0.00000001 || (float)(1.0 - a5) >= 0.00000001)
      {
        softmax_simple_temp(a1, a2, a4, a5);
      }
      else
      {
        softmax_simple(a1, a2, a4);
      }
    }
    else if (a2)
    {
      int v8 = 0;
      uint64_t v9 = a2;
      float v10 = -3.4028e38;
      uint64_t v11 = a2;
      float v12 = 1.0 / a5;
      do
      {
        if (a1[v8] > v10) {
          float v10 = a1[v8];
        }
        v8 += a3;
        --v11;
      }
      while (v11);
      int v13 = 0;
      float v14 = v12 * v10;
      float v15 = 0.0;
      uint64_t v16 = a2;
      do
      {
        float v17 = expf((float)(v12 * a1[v13]) - v14);
        float v15 = v15 + v17;
        a4[v13] = v17;
        v13 += a3;
        --v16;
      }
      while (v16);
      if (v15 != 0.0)
      {
        int v18 = 0;
        do
        {
          a4[v18] = (float)(1.0 / v15) * a4[v18];
          v18 += a3;
          --v9;
        }
        while (v9);
      }
    }
  }
}

uint64_t oneNorm(uint64_t result, unsigned int a2, int a3, uint64_t a4)
{
  if (a2)
  {
    unsigned int v4 = 0;
    uint64_t v5 = a2;
    float v6 = 0.0;
    uint64_t v7 = a2;
    do
    {
      float v6 = v6 + *(float *)(result + 4 * v4);
      v4 += a3;
      --v7;
    }
    while (v7);
    if (v6 != 0.0)
    {
      unsigned int v8 = 0;
      float v9 = 1.0 / v6;
      do
      {
        *(float *)(a4 + 4 * v8) = v9 * *(float *)(a4 + 4 * v8);
        v8 += a3;
        --v5;
      }
      while (v5);
    }
  }
  return result;
}

uint64_t getLargestIdx(uint64_t a1, int a2)
{
  if (a2 < 1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = 0;
  LODWORD(v3) = -1;
  float v4 = -3.4028e38;
  do
  {
    float v5 = *(float *)(a1 + 4 * v2);
    if (v5 >= v4) {
      uint64_t v3 = v2;
    }
    else {
      uint64_t v3 = v3;
    }
    if (v5 >= v4) {
      float v4 = *(float *)(a1 + 4 * v2);
    }
    ++v2;
  }
  while (a2 != v2);
  return v3;
}

uint64_t sparse_sgemv_accum16_c(uint64_t result, float *a2, int a3, int *a4, uint64_t a5)
{
  if (a3 >= 1)
  {
    for (unint64_t i = 0; i < a3; i += 16)
    {
      int v7 = *a4++;
      int v6 = v7;
      if (v7 >= 1)
      {
        unsigned int v8 = (float *)(result + 4 * i);
        float v9 = *v8;
        float v10 = v8[1];
        float v11 = v8[2];
        float v12 = v8[3];
        float v13 = v8[4];
        float v14 = v8[5];
        float v15 = v8[6];
        float v16 = v8[7];
        float v17 = v8[8];
        float v18 = v8[9];
        float v19 = v8[10];
        float v20 = v8[11];
        float v21 = v8[12];
        float v22 = v8[13];
        float v23 = v8[14];
        float v24 = v8[15];
        do
        {
          uint64_t v25 = *a4++;
          float v26 = *(float *)(a5 + 4 * v25);
          float v9 = v9 + (float)(*a2 * v26);
          *unsigned int v8 = v9;
          float v10 = v10 + (float)(a2[1] * v26);
          v8[1] = v10;
          float v11 = v11 + (float)(a2[2] * v26);
          v8[2] = v11;
          float v12 = v12 + (float)(a2[3] * v26);
          v8[3] = v12;
          float v13 = v13 + (float)(a2[4] * v26);
          v8[4] = v13;
          float v14 = v14 + (float)(a2[5] * v26);
          v8[5] = v14;
          float v15 = v15 + (float)(a2[6] * v26);
          v8[6] = v15;
          float v16 = v16 + (float)(a2[7] * v26);
          v8[7] = v16;
          float v17 = v17 + (float)(a2[8] * v26);
          v8[8] = v17;
          float v18 = v18 + (float)(a2[9] * v26);
          v8[9] = v18;
          float v19 = v19 + (float)(a2[10] * v26);
          v8[10] = v19;
          float v20 = v20 + (float)(a2[11] * v26);
          v8[11] = v20;
          float v21 = v21 + (float)(a2[12] * v26);
          v8[12] = v21;
          float v22 = v22 + (float)(a2[13] * v26);
          v8[13] = v22;
          float v23 = v23 + (float)(a2[14] * v26);
          v8[14] = v23;
          float v24 = v24 + (float)(a2[15] * v26);
          v8[15] = v24;
          a2 += 16;
          --v6;
        }
        while (v6);
      }
    }
  }
  return result;
}

uint64_t sparse_sgemv_accum16(uint64_t result, float *a2, int a3, int *a4, uint64_t a5)
{
  return sparse_sgemv_accum16_c(result, a2, a3, a4, a5);
}

float accum4(unsigned int a1, float *a2, float *a3, float *a4, float *a5, float *a6)
{
  if ((a2 & 0x1F) != 0)
  {
    if (a1)
    {
      uint64_t v6 = a1;
      do
      {
        float v7 = *a2++;
        float v8 = v7;
        float v9 = *a3++;
        float v10 = v8 + v9;
        float v11 = *a4++;
        float v12 = v10 + v11;
        float v13 = *a5++;
        float result = v12 + v13;
        *a6++ = result;
        --v6;
      }
      while (v6);
    }
  }
  else if (a1)
  {
    uint64_t v15 = a1;
    do
    {
      float v16 = *a2++;
      float v17 = v16;
      float v18 = *a3++;
      float v19 = v17 + v18;
      float v20 = *a4++;
      float v21 = v19 + v20;
      float v22 = *a5++;
      float result = v21 + v22;
      *a6++ = result;
      --v15;
    }
    while (v15);
  }
  return result;
}

float *_inv_preemphasis(float *result, unsigned int a2, float a3)
{
  if (a3 != 0.0 && a2 >= 2)
  {
    float v4 = *result++;
    float v5 = v4;
    uint64_t v6 = a2 - 1;
    do
    {
      float v5 = *result + (float)(a3 * v5);
      *result++ = v5;
      --v6;
    }
    while (v6);
  }
  return result;
}

float *_scale_to_one(float *result, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    float v3 = 0.01;
    uint64_t v4 = a2;
    float v5 = result;
    do
    {
      float v6 = *v5++;
      float v7 = fabsf(v6);
      if (v7 > v3) {
        float v3 = v7;
      }
      --v4;
    }
    while (v4);
    do
    {
      *float result = *result / v3;
      ++result;
      --v2;
    }
    while (v2);
  }
  return result;
}

float *_scale_to_pcm16(float *result, unsigned int a2)
{
  if (a2)
  {
    float v2 = 0.01;
    uint64_t v3 = a2;
    uint64_t v4 = result;
    do
    {
      float v5 = *v4++;
      float v6 = fabsf(v5);
      if (v6 > v2) {
        float v2 = v6;
      }
      --v3;
    }
    while (v3);
    do
    {
      *((_WORD *)result + v3) = (int)((float)((float)(result[v3] * 32767.0) / v2) + 0.5);
      ++v3;
    }
    while (a2 != v3);
  }
  return result;
}

float32x4_t V2AddDot1x4(int a1, float *a2, __int32 *a3, int a4, float32x4_t *a5)
{
  if (a1 < 1)
  {
    float32x4_t v5 = 0uLL;
  }
  else
  {
    float32x4_t v5 = 0uLL;
    do
    {
      float v6 = *a2++;
      v7.i32[0] = *a3;
      float v8 = &a3[3 * a4];
      v7.i32[1] = a3[a4];
      v7.i32[2] = a3[2 * a4];
      ++a3;
      v7.i32[3] = *v8;
      float32x4_t v5 = vmlaq_n_f32(v5, v7, v6);
      --a1;
    }
    while (a1);
  }
  float32x4_t result = vaddq_f32(v5, *a5);
  *a5 = result;
  return result;
}

float V2AddDot4x1(int a1, float *a2, int a3, float *a4, uint64_t a5, float *a6, int a7)
{
  if (a1 < 1)
  {
    float v10 = 0.0;
    float v9 = 0.0;
    float v8 = 0.0;
    float v7 = 0.0;
  }
  else
  {
    float v7 = 0.0;
    float v8 = 0.0;
    float v9 = 0.0;
    float v10 = 0.0;
    do
    {
      float v11 = a2[a3];
      float v12 = a2[2 * a3];
      float v13 = *a2;
      float v14 = a2[3 * a3];
      ++a2;
      float v15 = *a4++;
      float v10 = v10 + (float)(v13 * v15);
      float v9 = v9 + (float)(v11 * v15);
      float v8 = v8 + (float)(v12 * v15);
      float v7 = v7 + (float)(v14 * v15);
      --a1;
    }
    while (a1);
  }
  *a6 = v10 + *a6;
  a6[a7] = v9 + a6[a7];
  a6[2 * a7] = v8 + a6[2 * a7];
  uint64_t v16 = 3 * a7;
  float result = v7 + a6[v16];
  a6[v16] = result;
  return result;
}

float V2AddDot4x4(int a1, uint64_t a2, int a3, uint64_t a4, int a5, float32x4_t *a6, int a7)
{
  if (a1 < 1)
  {
    float32x4_t v8 = 0uLL;
    float v21 = 0.0;
    float v20 = 0.0;
    float v19 = 0.0;
    float v18 = 0.0;
    float v17 = 0.0;
    float v16 = 0.0;
    float v15 = 0.0;
    float v14 = 0.0;
    float v13 = 0.0;
    float v12 = 0.0;
    float v11 = 0.0;
    float v10 = 0.0;
  }
  else
  {
    uint64_t v7 = 0;
    float32x4_t v8 = 0uLL;
    uint64_t v9 = a4 + 8 * a5;
    float v10 = 0.0;
    float v11 = 0.0;
    float v12 = 0.0;
    float v13 = 0.0;
    float v14 = 0.0;
    float v15 = 0.0;
    float v16 = 0.0;
    float v17 = 0.0;
    float v18 = 0.0;
    float v19 = 0.0;
    float v20 = 0.0;
    float v21 = 0.0;
    do
    {
      float v22 = *(float *)(a2 + 4 * a3 + 4 * v7);
      float v23 = *(float *)(a2 + 8 * a3 + 4 * v7);
      float v24 = *(float *)(a2 + 12 * a3 + 4 * v7);
      v25.i32[0] = *(_DWORD *)(a4 + 4 * v7);
      float v26 = *(float *)(a4 + 12 * a5 + 4 * v7);
      float v21 = v21 + (float)(v22 * v25.f32[0]);
      float v17 = v17 + (float)(v23 * v25.f32[0]);
      float v13 = v13 + (float)(v24 * v25.f32[0]);
      v25.i32[1] = *(_DWORD *)(a4 + 4 * a5 + 4 * v7);
      v25.i64[1] = __PAIR64__(LODWORD(v26), *(_DWORD *)(v9 + 4 * v7));
      float32x4_t v8 = vmlaq_n_f32(v8, v25, *(float *)(a2 + 4 * v7));
      float v20 = v20 + (float)(v22 * v25.f32[1]);
      float v19 = v19 + (float)(v22 * *(float *)(v9 + 4 * v7));
      float v18 = v18 + (float)(v22 * v26);
      float v16 = v16 + (float)(v23 * v25.f32[1]);
      float v15 = v15 + (float)(v23 * *(float *)(v9 + 4 * v7));
      float v14 = v14 + (float)(v23 * v26);
      float v12 = v12 + (float)(v24 * v25.f32[1]);
      float v11 = v11 + (float)(v24 * *(float *)(v9 + 4 * v7));
      float v10 = v10 + (float)(v24 * v26);
      ++v7;
    }
    while (a1 != v7);
  }
  *a6 = vaddq_f32(v8, *a6);
  int v27 = &a6->f32[a7];
  float v28 = v27[1];
  *int v27 = v21 + *v27;
  v27[1] = v20 + v28;
  float v29 = v18 + v27[3];
  v27[2] = v19 + v27[2];
  v27[3] = v29;
  a6->f32[2 * a7] = v17 + a6->f32[2 * a7];
  float v30 = &a6->f32[2 * a7];
  float v31 = v30[2];
  v30[1] = v16 + v30[1];
  v30[2] = v15 + v31;
  v30[3] = v14 + v30[3];
  a6->f32[3 * a7] = v13 + a6->f32[3 * a7];
  float v32 = &a6->f32[3 * a7];
  float v33 = v32[2];
  v32[1] = v12 + v32[1];
  v32[2] = v11 + v33;
  float result = v10 + v32[3];
  unsigned char v32[3] = result;
  return result;
}

void gemm_v2(uint64_t a1, int a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, float32x4_t *a10, int a11)
{
  int v12 = a3;
  if (a3 >= 0) {
    int v14 = a3;
  }
  else {
    int v14 = a3 + 3;
  }
  if (a4 >= 0) {
    int v15 = a4;
  }
  else {
    int v15 = a4 + 3;
  }
  int padded_len = get_padded_len(a7, 8u);
  int v17 = get_padded_len(a9, 8u);
  int v71 = v17;
  if (a2)
  {
    LODWORD(v19) = v15 & 0xFFFFFFFC;
    if (v12 < 4)
    {
      unsigned int v34 = 0;
      float v33 = (__int32 *)a8;
      float v32 = a10;
      int v24 = a4;
    }
    else
    {
      int v64 = v12;
      uint64_t v76 = 0;
      uint64_t v20 = 0;
      unsigned int v63 = v15 & 0xFFFFFFFC;
      uint64_t v19 = (int)v19;
      uint64_t v21 = (int)(v14 & 0xFFFFFFFC);
      uint64_t v22 = 16 * v17;
      uint64_t v66 = 4 * v17;
      float v23 = a10;
      int v24 = a4;
      uint64_t v65 = v21;
      uint64_t v69 = (int)v19;
      uint64_t v67 = v22;
      do
      {
        float v73 = v23;
        if (v24 < 4)
        {
          uint64_t v28 = 0;
        }
        else
        {
          uint64_t v25 = 0;
          uint64_t v26 = v19;
          uint64_t v27 = a8;
          do
          {
            V2AddDot4x4(a5, a6 + 4 * v20 * padded_len, padded_len, v27, v71, v23, a11);
            v25 += 4;
            ++v23;
            v27 += v22;
          }
          while (v25 < v26);
          uint64_t v28 = v25;
          int v24 = a4;
          uint64_t v21 = v65;
        }
        if ((int)v28 < v24)
        {
          float v29 = &a10[v76].f32[v28];
          float v30 = (float *)(a8 + v66 * v28);
          uint64_t v31 = a4 - v28;
          do
          {
            V2AddDot4x1(a5, (float *)(a6 + 4 * v20 * padded_len), padded_len, v30, v18, v29++, a11);
            float v30 = (float *)((char *)v30 + v66);
            --v31;
          }
          while (v31);
        }
        v20 += 4;
        float v23 = &v73[a11];
        v76 += a11;
        int v24 = a4;
        uint64_t v19 = v69;
        uint64_t v22 = v67;
      }
      while (v20 < v21);
      float v33 = (__int32 *)a8;
      float v32 = a10;
      unsigned int v34 = v20;
      int v12 = v64;
      LODWORD(v19) = v63;
    }
    if ((int)v34 < v12)
    {
      uint64_t v44 = v71;
      uint64_t v45 = (int)v19;
      uint64_t v46 = v34;
      uint64_t v47 = padded_len;
      uint64_t v48 = v12;
      uint64_t v49 = v24;
      uint64_t v70 = padded_len;
      float v50 = (float32x4_t *)((char *)v32 + 4 * a11 * (unint64_t)v34);
      uint64_t v51 = 4 * a11;
      uint64_t v68 = v48;
      do
      {
        if (v24 < 4)
        {
          uint64_t v55 = 0;
        }
        else
        {
          uint64_t v52 = 0;
          uint64_t v77 = v46;
          float v53 = (float *)(a6 + 4 * v46 * v47);
          float v54 = v33;
          float v74 = v50;
          do
          {
            V2AddDot1x4(a5, v53, v54, v71, v50);
            v52 += 4;
            ++v50;
            v54 += 4 * v71;
          }
          while (v52 < v45);
          uint64_t v55 = v52;
          int v24 = a4;
          uint64_t v44 = v71;
          float v32 = a10;
          uint64_t v46 = v77;
          uint64_t v47 = v70;
          uint64_t v51 = 4 * a11;
          uint64_t v48 = v68;
          float v50 = v74;
        }
        if ((int)v55 < v24)
        {
          do
          {
            if (a5 < 1)
            {
              float v57 = 0.0;
            }
            else
            {
              float v56 = (float *)&v33[v55 * v44];
              float v57 = 0.0;
              int v58 = a5;
              float v59 = (float *)(a6 + 4 * v46 * v47);
              do
              {
                float v60 = *v59++;
                float v61 = v60;
                float v62 = *v56++;
                float v57 = v57 + (float)(v61 * v62);
                --v58;
              }
              while (v58);
            }
            v32->f32[v55 + v46 * a11] = v57 + v32->f32[v55 + v46 * a11];
            ++v55;
          }
          while (v55 != v49);
        }
        ++v46;
        float v50 = (float32x4_t *)((char *)v50 + v51);
      }
      while (v46 != v48);
    }
  }
  else if (v12 >= 1)
  {
    uint64_t v35 = 0;
    uint64_t v36 = 4 * v17;
    do
    {
      if (a5 >= 1)
      {
        uint64_t v37 = 0;
        float v38 = (float *)a8;
        do
        {
          if (a4 >= 1)
          {
            float v39 = *(float *)(a6 + 4 * v35 * padded_len + 4 * v37);
            uint64_t v40 = v38;
            uint64_t v41 = a4;
            float v42 = &a10->f32[v35 * a11];
            do
            {
              float v43 = *v40++;
              *float v42 = *v42 + (float)(v39 * v43);
              ++v42;
              --v41;
            }
            while (v41);
          }
          ++v37;
          float v38 = (float *)((char *)v38 + v36);
        }
        while (v37 != a5);
      }
      ++v35;
    }
    while (v35 != v12);
  }
}

void gemm_v5(uint64_t a1, int a2, int a3, int a4, int a5, float *a6, uint64_t a7, char *a8, unsigned int a9, float *a10, int a11, uint64_t a12)
{
  if (a12)
  {
    int v12 = *(float **)(a12 + 24);
    if (v12)
    {
      uint64_t v19 = a10;
      float v20 = *v12;
      float v21 = v12[1];
      int padded_len = get_padded_len(a7, 8u);
      int v23 = get_padded_len(a9, 0x20u);
      if (a2)
      {
        if (a3 >= 1)
        {
          uint64_t v24 = 0;
          do
          {
            if (a4 >= 1)
            {
              uint64_t v25 = 0;
              uint64_t v26 = v24 * a11;
              uint64_t v27 = a8;
              do
              {
                if (a5 >= 1)
                {
                  float v28 = a10[v25 + v26];
                  float v29 = a6;
                  float v30 = v27;
                  uint64_t v31 = a5;
                  do
                  {
                    float v32 = *v29++;
                    float v33 = v32;
                    int v34 = *v30++;
                    float v28 = v28 + (float)(v33 * (float)(v21 + (float)(v20 * (float)v34)));
                    a10[v25 + v26] = v28;
                    --v31;
                  }
                  while (v31);
                }
                ++v25;
                v27 += v23;
              }
              while (v25 != a4);
            }
            ++v24;
            a6 += padded_len;
          }
          while (v24 != a3);
        }
      }
      else if (a3 >= 1)
      {
        uint64_t v35 = 0;
        do
        {
          if (a5 >= 1)
          {
            uint64_t v36 = 0;
            uint64_t v37 = a8;
            do
            {
              if (a4 >= 1)
              {
                float v38 = v37;
                float v39 = v19;
                uint64_t v40 = a4;
                do
                {
                  int v41 = *v38++;
                  *float v39 = *v39 + (float)(a6[v36 + v35 * padded_len] * (float)(v21 + (float)(v20 * (float)v41)));
                  ++v39;
                  --v40;
                }
                while (v40);
              }
              ++v36;
              v37 += v23;
            }
            while (v36 != a5);
          }
          ++v35;
          v19 += a11;
        }
        while (v35 != a3);
      }
    }
  }
}

uint64_t pack_bsc_data(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  unsigned int padded_len = get_padded_len(a3, 4u);
  unsigned int v12 = get_padded_len(a4, 4u);
  uint64_t v13 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 8) + 64))(*(void *)(a1 + 16), 1, 32);
  if (!v13) {
    return 10;
  }
  uint64_t v14 = v13;
  uint64_t result = 0;
  *(_DWORD *)(v14 + 24) = padded_len >> 2;
  *(_DWORD *)(v14 + 28) = v12 >> 2;
  uint64_t v16 = a5 + 4 * (16 * a2);
  *(void *)uint64_t v14 = a5;
  *(void *)(v14 + 8) = v16 + 4 * (v12 >> 2) + 4;
  *(void *)(v14 + 16) = v16;
  *a6 = v14;
  return result;
}

uint64_t get_bsc_data_len(int a1, uint64_t a2)
{
  return 17 * a1 + (get_padded_len(a2, 4u) >> 2) + 1;
}

uint64_t pack_bsr_data(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  unsigned int padded_len = get_padded_len(a3, 4u);
  unsigned int v12 = get_padded_len(a4, 4u);
  uint64_t v13 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 8) + 64))(*(void *)(a1 + 16), 1, 32);
  if (!v13) {
    return 10;
  }
  uint64_t v14 = v13;
  uint64_t result = 0;
  *(_DWORD *)(v14 + 24) = padded_len >> 2;
  *(_DWORD *)(v14 + 28) = v12 >> 2;
  uint64_t v16 = a5 + 4 * (16 * a2);
  *(void *)uint64_t v14 = a5;
  *(void *)(v14 + 8) = v16;
  *(void *)(v14 + 16) = v16 + 4 * (padded_len >> 2) + 4;
  *a6 = v14;
  return result;
}

const char *fi_layer_type_to_name(unsigned int a1)
{
  if (a1 > 0x49) {
    return "[]";
  }
  else {
    return off_264113440[a1];
  }
}

uint64_t fi_layer_if_has_weights(unsigned int a1)
{
  if (a1 > 0x47) {
    return 0;
  }
  else {
    return dword_20D6B2F98[a1];
  }
}

uint64_t fi_layer_free(uint64_t result)
{
  if (result)
  {
    float v1 = *(uint64_t (**)(void))(result + 136);
    if (v1) {
      return v1();
    }
  }
  return result;
}

uint64_t fi_layer_find_weights_via_offset(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *(void *)(a1 + 72) = a2 + *a3;
  float32x4_t v5 = *(uint64_t (**)(uint64_t))(a1 + 184);
  if (!v5 || (uint64_t result = v5(a1), !result))
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 152))(a1, a1 + 96, a1 + 112);
    if (!result)
    {
      uint64_t v7 = *(unsigned int *)(a1 + 96);
      int v8 = *(_DWORD *)(a1 + 112) + v7;
      *(_DWORD *)(a1 + 80) = v8;
      *(_DWORD *)(a1 + 116) = 0;
      uint64_t v9 = *(void *)(a1 + 72);
      *(void *)(a1 + 104) = v9 + v7;
      *(void *)(a1 + 88) = v9;
      *a3 += v8;
    }
  }
  return result;
}

uint64_t fi_shape_set(int a1, uint64_t a2, int a3, uint64_t a4)
{
  if (!a4) {
    return 7;
  }
  uint64_t result = 0;
  *(_DWORD *)a4 = a1;
  int v6 = *(_DWORD *)(a2 + 8);
  *(void *)(a4 + 4) = *(void *)a2;
  *(_DWORD *)(a4 + 12) = v6;
  *(_DWORD *)(a4 + 16) = a3;
  return result;
}

uint64_t fi_shape_merge(_DWORD *a1, _DWORD *a2)
{
  uint64_t v2 = 7;
  if (a1 && a2)
  {
    if (*a1 == *a2)
    {
      int v3 = a1[4];
      uint64_t v2 = 7;
      if (v3 && v3 == a2[4])
      {
        BOOL v4 = *a1 == 2 && a1[1] == a2[1];
        uint64_t v2 = 0;
        a2[v4 + 1] += a1[v4 + 1];
      }
    }
    else
    {
      return 7;
    }
  }
  return v2;
}

uint64_t fi_shape_dump(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"FI_SHAPE_T(%s): ndim=%d, dims=(%d, %d, %d), elemBytes=%d", a6, a7, a8, a3);
}

__n128 fi_shape_copy(__n128 *a1, __n128 *a2)
{
  __n128 result = *a2;
  a1[1].n128_u32[0] = a2[1].n128_u32[0];
  *a1 = result;
  return result;
}

uint64_t fi_shape_get_step(_DWORD *a1)
{
  if (*a1 == 1) {
    return 1;
  }
  else {
    return a1[1];
  }
}

uint64_t fi_shape_get_input_dim(int *a1, int *a2)
{
  int v2 = *a1;
  if (*a1 == 3)
  {
    int v3 = a1[2] * a1[1] * a1[3];
    goto LABEL_7;
  }
  if (v2 == 2)
  {
    int v3 = a1[2];
    goto LABEL_7;
  }
  if (v2 == 1)
  {
    int v3 = a1[1];
LABEL_7:
    uint64_t result = 0;
    *a2 = v3;
    return result;
  }
  return 7;
}

uint64_t fi_shape_get_conv_chw(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  if (*a1 == 2)
  {
    uint64_t result = 0;
    *a3 = a1[1];
    *a4 = a1[2];
    *a2 = 1;
  }
  else if (*a1 == 3)
  {
    uint64_t result = 0;
    *a2 = a1[1];
    *a3 = a1[2];
    *a4 = a1[3];
  }
  else
  {
    return 7;
  }
  return result;
}

uint64_t fi_shape_get_channel(_DWORD *a1)
{
  if (*a1 == 3) {
    return a1[1];
  }
  else {
    return 1;
  }
}

uint64_t fi_shape_get_size(int *a1, int *a2)
{
  int v3 = *a1;
  if (*a1 == 3)
  {
    uint64_t result = 0;
    int v5 = a1[2] * a1[1] * a1[3];
  }
  else if (v3 == 2)
  {
    uint64_t result = 0;
    int v5 = a1[2] * a1[1];
  }
  else if (v3 == 1)
  {
    uint64_t result = 0;
    int v5 = a1[1];
  }
  else
  {
    int v5 = 0;
    uint64_t result = 7;
  }
  *a2 = v5;
  return result;
}

uint64_t fi_shape_get_bytes(int *a1, _DWORD *a2)
{
  int v2 = *a1;
  if (*a1 == 3)
  {
    int v3 = a1[2] * a1[1] * a1[3];
  }
  else if (v2 == 2)
  {
    int v3 = a1[2] * a1[1];
  }
  else
  {
    if (v2 != 1) {
      return 7;
    }
    int v3 = a1[1];
  }
  uint64_t v4 = 0;
  *a2 = a1[4] * v3;
  return v4;
}

uint64_t fi_shape_is_same(unsigned int *a1, _DWORD *a2)
{
  uint64_t v2 = *a1;
  if (v2 == *a2 && a1[4] == a2[4])
  {
    if (!v2) {
      return 1;
    }
    int v3 = (int *)(a1 + 1);
    uint64_t v4 = a2 + 1;
    while (1)
    {
      int v6 = *v3++;
      int v5 = v6;
      int v7 = *v4++;
      if (v5 != v7) {
        break;
      }
      if (!--v2) {
        return 1;
      }
    }
  }
  return 0;
}

uint64_t fi_get_activation(const char *a1)
{
  uint64_t result = strcmp(a1, "linear");
  if (result)
  {
    if (!strcmp(a1, "sigmoid"))
    {
      return 1;
    }
    else if (!strcmp(a1, "hardsigmoid"))
    {
      return 6;
    }
    else if (!strcmp(a1, "tanh"))
    {
      return 2;
    }
    else if (!strcmp(a1, "relu"))
    {
      return 3;
    }
    else if (!strcmp(a1, "elu"))
    {
      return 4;
    }
    else if (!strcmp(a1, "leaky"))
    {
      return 5;
    }
    else if (!strcmp(a1, "softsign"))
    {
      return 7;
    }
    else if (!strcmp(a1, "softmax"))
    {
      return 9;
    }
    else if (!strcmp(a1, "softplus"))
    {
      return 8;
    }
    else if (!strcmp(a1, "tanh_approx"))
    {
      return 10;
    }
    else if (!strcmp(a1, "sigmoid_approx"))
    {
      return 11;
    }
    else if (!strcmp(a1, "gelu"))
    {
      return 12;
    }
    else if (!strcmp(a1, "leaky_dot_two"))
    {
      return 13;
    }
    else if (!strcmp(a1, "leaky_dot_two_inverse"))
    {
      return 14;
    }
    else
    {
      return 3;
    }
  }
  return result;
}

void fi_activate_array(float *a1, uint64_t a2, int a3)
{
  uint64_t v4 = a1;
  switch(a3)
  {
    case 0:
      return;
    case 1:
      int v5 = a1;
      goto LABEL_4;
    case 2:
      int v6 = a1;
      goto LABEL_7;
    case 3:
      relu_array_f32(a2, a1);
      return;
    case 7:
      softsign_array_f32(a2, a1);
      return;
    case 9:
      softmax(a1, a2, 1, a1, 1.0);
      return;
    case 10:
      int v6 = a1;
LABEL_7:
      fast_tanh(a1, a2, v6);
      return;
    case 11:
      int v5 = a1;
LABEL_4:
      sigmoid(a1, a2, v5);
      return;
    case 12:
      gelu_array_f32(a2, a1);
      return;
    case 13:
      float v9 = 0.2;
      goto LABEL_32;
    case 14:
      float v9 = 5.0;
LABEL_32:
      leaky_array_f32(a2, a1, v9);
      break;
    default:
      if (a2)
      {
        uint64_t v7 = a2;
        do
        {
          activate(a3, *v4);
          *(_DWORD *)v4++ = v8;
          --v7;
        }
        while (v7);
      }
      break;
  }
}

void activate(int a1, float a2)
{
  switch(a1)
  {
    case 1:
    case 11:
      exp_fdlibm((float)-a2);
      break;
    case 2:
    case 10:
      if (a2 <= 350.0) {
        exp_fdlibm((float)(a2 + a2));
      }
      break;
    case 4:
      if (a2 < 0.0) {
        exp_fdlibm(a2);
      }
      break;
    case 7:
      fabs_fdlibm(a2);
      break;
    case 8:
      double v2 = exp_fdlibm(a2);
      log_fdlibm(v2 + 1.0);
      break;
    case 12:
      float v3 = (float)((float)((float)(a2 * 0.035677) * a2) * a2) + (float)(a2 * 0.79789);
      if (v3 <= 350.0) {
        exp_fdlibm((float)(v3 + v3));
      }
      break;
    default:
      return;
  }
}

uint64_t alloc_aligned_mem(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (!a3) {
    return 0;
  }
  if (-8 - a2 < a3) {
    return 0;
  }
  uint64_t result = heap_Alloc(a1, a2 + a3 + 7);
  if (result)
  {
    uint64_t v5 = result;
    result += 8 + ((((a2 - 1) & ~(result + 8)) + 1) & (a2 - 1));
    *(void *)(result - 8) = v5;
  }
  return result;
}

void *calloc_aligned_mem(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  size_t v4 = a4 * a3;
  uint64_t v5 = (void *)alloc_aligned_mem(a1, a2, a4 * a3);
  int v6 = v5;
  if (v5) {
    bzero(v5, v4);
  }
  return v6;
}

uint64_t realloc_aligned_mem(uint64_t *a1, uint64_t a2, uint64_t a3, size_t a4)
{
  if (!a4) {
    return 0;
  }
  uint64_t v6 = a2;
  if (a2)
  {
    if (-8 - a3 >= a4)
    {
      uint64_t v7 = *(void *)(a2 - 8);
      uint64_t v8 = heap_Realloc(a1, v7, a3 + a4 + 7);
      if (v8)
      {
        uint64_t v9 = v8;
        if (v8 != v7)
        {
          uint64_t v10 = v6 - v7;
          uint64_t v11 = ((((a3 - 1) & ~(v8 + 8)) + 1) & (a3 - 1)) + 8;
          uint64_t v6 = v8 + v11;
          if (v11 != v10) {
            memmove((void *)(v8 + v11), (const void *)(v8 + v10), a4);
          }
          *(void *)(v6 - 8) = v9;
        }
        return v6;
      }
    }
    return 0;
  }
  return alloc_aligned_mem((uint64_t)a1, a3, a4);
}

void *free_aligned_mem(void *result, uint64_t a2)
{
  if (a2) {
    return heap_Free(result, *(void *)(a2 - 8));
  }
  return result;
}

uint64_t alloc_aligned_32_mem(uint64_t a1, unint64_t a2)
{
  return alloc_aligned_mem(a1, 32, a2);
}

uint64_t realloc_aligned_32_mem(uint64_t *a1, uint64_t a2, size_t a3)
{
  return realloc_aligned_mem(a1, a2, 32, a3);
}

void *calloc_aligned_32_mem(uint64_t a1, uint64_t a2, uint64_t a3)
{
  size_t v3 = a3 * a2;
  size_t v4 = (void *)alloc_aligned_mem(a1, 32, a3 * a2);
  uint64_t v5 = v4;
  if (v4) {
    bzero(v4, v3);
  }
  return v5;
}

void *free_mem(void *result, uint64_t a2)
{
  if (a2) {
    return heap_Free(result, a2);
  }
  return result;
}

BOOL fi_version_cmp(uint64_t a1, int *a2, char *__s)
{
  __lasts = 0;
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = **(uint64_t (***)(uint64_t, size_t))(a1 + 8);
  size_t v8 = strlen(__s);
  uint64_t v9 = (char *)v7(v6, v8 + 1);
  if (v9)
  {
    uint64_t v13 = v9;
    uint64_t v14 = strcpy(v9, __s);
    int v15 = strtok_r(v14, ".", &__lasts);
    int v16 = *a2;
    if (v16 == atoi(v15) && (int v17 = strtok_r(0, ".", &__lasts), v18 = a2[1], v18 == atoi(v17)))
    {
      uint64_t v19 = strtok_r(0, ".", &__lasts);
      int v20 = a2[2];
      BOOL v21 = v20 == atoi(v19);
    }
    else
    {
      BOOL v21 = 0;
    }
    (*(void (**)(void, char *))(*(void *)(a1 + 8) + 48))(*(void *)(a1 + 16), v13);
  }
  else
  {
    log_OutText(*(void *)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v10, v11, v12, v23);
    return 0;
  }
  return v21;
}

BOOL fi_feat_is_enabled(uint64_t a1, unsigned int a2, unsigned int a3)
{
  BOOL result = 0;
  if (a1)
  {
    if (a2 < a3) {
      return *(_DWORD *)(a1 + 4 * a2) == 1;
    }
  }
  return result;
}

uint64_t get_mat_length(int *a1)
{
  if (a1) {
    int v1 = *a1;
  }
  else {
    int v1 = 0;
  }
  return get_weight_length(a1) + v1;
}

uint64_t get_weight_length(_DWORD *a1)
{
  if (!a1)
  {
    int padded_len = get_padded_len(0, 8u);
    int v6 = 0;
    return (v6 * padded_len);
  }
  int v2 = a1[1];
  if ((v2 & 8) != 0) {
    unsigned int v3 = 32;
  }
  else {
    unsigned int v3 = 8;
  }
  if (v2)
  {
    int v8 = a1[2];
    if ((v2 & 2) != 0)
    {
      uint64_t v9 = get_padded_len(a1[4], 8u);
      int v10 = v8;
    }
    else
    {
      uint64_t v9 = a1[5];
      int v10 = a1[2];
    }
    return get_bsc_data_len(v10, v9);
  }
  else
  {
    if ((v2 & 2) == 0)
    {
      int padded_len = get_padded_len(a1[4], v3);
      int v6 = a1[5];
      return (v6 * padded_len);
    }
    int v4 = a1[4];
    return get_padded_len(a1[5], v3) * v4;
  }
}

uint64_t fi_net_init(uint64_t *a1, uint64_t ***a2)
{
  uint64_t v7 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 200);
  if (v7)
  {
    uint64_t result = 0;
    *uint64_t v7 = a1;
    v7[24] = (uint64_t *)12345;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"alloc pNet failed!", v4, v5, v6, v9);
    uint64_t result = 10;
  }
  *a2 = v7;
  return result;
}

uint64_t fi_net_layers_init(uint64_t **a1)
{
  if (!a1) {
    return 7;
  }
  uint64_t v2 = *((unsigned int *)a1 + 2);
  if (!v2) {
    return 7;
  }
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))((*a1)[1] + 16))((*a1)[2], v2, 8);
  a1[14] = (uint64_t *)v3;
  if (v3) {
    return 0;
  }
  log_OutText(**a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"alloc pNet->layers failed!", v4, v5, v6, v8);
  return 10;
}

uint64_t fi_net_destroy(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *(void *)result;
    if (*(void *)(result + 112))
    {
      if (!*(_DWORD *)(result + 8)) {
        goto LABEL_7;
      }
      unint64_t v3 = 0;
      do
      {
        fi_layer_free(*(void *)(*(void *)(v1 + 112) + 8 * v3));
        *(void *)(*(void *)(v1 + 112) + 8 * v3++) = 0;
      }
      while (v3 < *(unsigned int *)(v1 + 8));
      if (*(void *)(v1 + 112))
      {
LABEL_7:
        (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        *(void *)(v1 + 112) = 0;
      }
    }
    if (*(void *)(v1 + 144))
    {
      (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
      *(void *)(v1 + 144) = 0;
    }
    *(_DWORD *)(v1 + 152) = 0;
    if (*(void *)(v1 + 160))
    {
      (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
      *(void *)(v1 + 160) = 0;
    }
    *(_DWORD *)(v1 + 168) = 0;
    if (*(void *)(v1 + 128))
    {
      (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
      *(void *)(v1 + 128) = 0;
    }
    *(_DWORD *)(v1 + 136) = 0;
    uint64_t v4 = *(void *)(v2 + 16);
    uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)(v2 + 8) + 48);
    return v5(v4, v1);
  }
  return result;
}

uint64_t fi_net_predict(uint64_t **a1, const void **a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return fi_net_predict_ex(a1, a2, a3, a4, 0, 0, 1, a8);
}

uint64_t fi_net_predict_ex(uint64_t **a1, const void **a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 7;
  if (a1 && a2 && a4)
  {
    char v11 = a7;
    a1[22] = (uint64_t *)a5;
    a1[23] = (uint64_t *)a6;
    uint64_t updated = fi_net_update_shape(a1, a3, a3, (uint64_t)a4, a5, a6, a7, a8);
    if (updated)
    {
      uint64_t v8 = updated;
      uint64_t v21 = **a1;
      uint64_t v22 = "fi net update shape failed!";
    }
    else
    {
      uint64_t v23 = fi_net_validate_weights_length(a1, v14, v15, v16, v17, v18, v19, v20);
      if (v23)
      {
        uint64_t v8 = v23;
        uint64_t v21 = **a1;
        uint64_t v22 = "fi net weights invalid!";
      }
      else
      {
        uint64_t glbIn = fi_net_allocate_glbIn((uint64_t)a1);
        if (glbIn)
        {
          uint64_t v8 = glbIn;
          uint64_t v21 = **a1;
          uint64_t v22 = "fi net allocate glbIn failed!";
        }
        else
        {
          uint64_t v25 = fi_net_copy_indata_to_glbIn_then_free((uint64_t)a1, a2);
          if (v25)
          {
            uint64_t v8 = v25;
            uint64_t v21 = **a1;
            uint64_t v22 = "input data copy to aligned memory and free failed!";
          }
          else
          {
            if (v11)
            {
              if (*a2) {
                (*(void (**)(uint64_t))((*a1)[1] + 80))((*a1)[2]);
              }
              *a2 = 0;
            }
            uint64_t v8 = fi_net_forward(a1);
            if (!v8)
            {
              *a4 = a1[18];
              return v8;
            }
            uint64_t v21 = **a1;
            uint64_t v22 = "fi net do forward failed!";
          }
        }
      }
    }
    log_OutText(v21, (uint64_t)"FastInfer", 0, 0, (uint64_t)v22, v18, v19, v20, v27);
  }
  return v8;
}

uint64_t fi_net_predict_notfree_input(uint64_t **a1, const void **a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 7;
  if (a1 && a2 && a4)
  {
    uint64_t updated = fi_net_update_shape(a1, a3, a3, (uint64_t)a4, a5, a6, a7, a8);
    if (updated)
    {
      uint64_t v8 = updated;
      uint64_t v20 = **a1;
      uint64_t v21 = "fi net update shape failed!";
    }
    else
    {
      uint64_t v22 = fi_net_validate_weights_length(a1, v13, v14, v15, v16, v17, v18, v19);
      if (v22)
      {
        uint64_t v8 = v22;
        uint64_t v20 = **a1;
        uint64_t v21 = "fi net weights invalid!";
      }
      else
      {
        uint64_t glbIn = fi_net_allocate_glbIn((uint64_t)a1);
        if (glbIn)
        {
          uint64_t v8 = glbIn;
          uint64_t v20 = **a1;
          uint64_t v21 = "fi net allocate glbIn failed!";
        }
        else
        {
          uint64_t v24 = fi_net_copy_indata_to_glbIn_then_free((uint64_t)a1, a2);
          if (v24)
          {
            uint64_t v8 = v24;
            uint64_t v20 = **a1;
            uint64_t v21 = "input data copy to aligned memory and free failed!";
          }
          else
          {
            uint64_t v8 = fi_net_forward(a1);
            if (!v8)
            {
              *a4 = a1[18];
              return v8;
            }
            uint64_t v20 = **a1;
            uint64_t v21 = "fi net do forward failed!";
          }
        }
      }
    }
    log_OutText(v20, (uint64_t)"FastInfer", 0, 0, (uint64_t)v21, v17, v18, v19, v26);
  }
  return v8;
}

uint64_t fi_net_update_shape(uint64_t **a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = (_DWORD *)a1 + 13;
  if (*((_DWORD *)a1 + 13))
  {
    *(_OWORD *)(a1 + 9) = *(_OWORD *)v10;
    *((_DWORD *)a1 + 22) = *((_DWORD *)a1 + 17);
  }
  else
  {
    log_OutText(**a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"it seems no [input] for this network,pNet->inshape won't be set by pNet->netCfg.model_inshapemake sure you set pNet->inshape correctly!", a6, a7, a8, v35);
  }
  uint64_t step = fi_shape_get_step(v10);
  if (step)
  {
    if (step != a2)
    {
      log_OutText(**a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Error: input data step mismatch! model step= %d, input data step= %d", v12, v13, v14, step);
      log_OutText(**a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"fi_net_validate_and_update_network_inshape failed!", v15, v16, v17, v36);
      return 7;
    }
  }
  else
  {
    log_OutText(**a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"data step changes from %d to %d", v12, v13, v14, 0);
    *((_DWORD *)a1 + 19) = a2;
  }
  if (!*((_DWORD *)a1 + 2)) {
    goto LABEL_17;
  }
  unint64_t v19 = 0;
  uint64_t v20 = a1 + 9;
  do
  {
    uint64_t v21 = a1[14][v19];
    *(void *)(v21 + 20) = 0;
    *(void *)(v21 + 28) = 0;
    *(void *)(v21 + 40) = 0;
    *(void *)(v21 + 48) = 0;
    *(_DWORD *)(v21 + 36) = 4;
    *(_DWORD *)(v21 + 56) = 4;
    uint64_t v22 = *(uint64_t (**)(uint64_t, uint64_t **))(v21 + 144);
    if (v22)
    {
      uint64_t v23 = v22(v21, v20);
      if (v23)
      {
        uint64_t v18 = v23;
        uint64_t v29 = **a1;
        float v30 = fi_layer_type_to_name(*(_DWORD *)(v21 + 8));
        log_OutText(v29, (uint64_t)"FastInfer", 0, 0, (uint64_t)"update shape of %s layer failed!", v31, v32, v33, (uint64_t)v30);
        return v18;
      }
    }
    else
    {
      long long v24 = *(_OWORD *)v20;
      *(_DWORD *)(v21 + 36) = *((_DWORD *)v20 + 4);
      *(_OWORD *)(v21 + 20) = v24;
      long long v25 = *(_OWORD *)v20;
      *(_DWORD *)(v21 + 56) = *((_DWORD *)v20 + 4);
      *(_OWORD *)(v21 + 40) = v25;
    }
    ++v19;
    unint64_t v26 = *((unsigned int *)a1 + 2);
    uint64_t v20 = (uint64_t **)(v21 + 40);
  }
  while (v19 < v26);
  if (v26)
  {
    uint64_t v18 = 0;
    uint64_t v27 = a1[14][(v26 - 1)];
    int v28 = *(_DWORD *)(v27 + 56);
    *(_OWORD *)((char *)a1 + 92) = *(_OWORD *)(v27 + 40);
    *((_DWORD *)a1 + 27) = v28;
  }
  else
  {
LABEL_17:
    uint64_t v18 = 0;
    *(_OWORD *)((char *)a1 + 92) = *(_OWORD *)(a1 + 9);
    *((_DWORD *)a1 + 27) = *((_DWORD *)a1 + 22);
  }
  return v18;
}

uint64_t fi_net_validate_weights_length(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v32 = 0;
  log_OutText(**a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Validate weights and biases length of all layers ...", a6, a7, a8, v30);
  unint64_t v12 = *((unsigned int *)a1 + 2);
  if (!v12)
  {
LABEL_11:
    log_OutText(**a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Validate weights and biases length of all layers Done!", v9, v10, v11, v31);
    return 0;
  }
  uint64_t v13 = 0;
  while (1)
  {
    uint64_t v14 = a1[14][v13];
    if (!*(void *)(v14 + 152)) {
      goto LABEL_10;
    }
    uint64_t v15 = **a1;
    uint64_t v16 = fi_layer_type_to_name(*(_DWORD *)(v14 + 8));
    log_OutText(v15, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Validate layer %s ...", v17, v18, v19, (uint64_t)v16);
    uint64_t v20 = *(uint64_t (**)(uint64_t))(v14 + 184);
    if (v20)
    {
      uint64_t v21 = v20(v14);
      if (v21) {
        break;
      }
    }
    uint64_t v22 = (*(uint64_t (**)(uint64_t, char *, uint64_t *))(v14 + 152))(v14, (char *)&v32 + 4, &v32);
    if (v22)
    {
      uint64_t v24 = v22;
      uint64_t v25 = **a1;
      unint64_t v26 = "Get wanted weight and biases length failed!";
      goto LABEL_17;
    }
    uint64_t v23 = *(unsigned int *)(v14 + 96);
    if (HIDWORD(v32) != v23)
    {
      uint64_t v27 = **(void **)v14;
      int v28 = "weights length in model: %d Bytes, but wanted: %d Bytes";
LABEL_15:
      log_OutText(v27, (uint64_t)"FastInfer", 0, 0, (uint64_t)v28, v9, v10, v11, v23);
      return 7;
    }
    uint64_t v23 = *(unsigned int *)(v14 + 112);
    if (v32 != v23)
    {
      uint64_t v27 = **(void **)v14;
      int v28 = "biases length in model: %d Bytes, but wanted: %d Bytes";
      goto LABEL_15;
    }
    unint64_t v12 = *((unsigned int *)a1 + 2);
LABEL_10:
    if (++v13 >= v12) {
      goto LABEL_11;
    }
  }
  uint64_t v24 = v21;
  uint64_t v25 = **a1;
  unint64_t v26 = "dispatching weights for layer %d failed!";
  uint64_t v31 = v13;
LABEL_17:
  log_OutText(v25, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v9, v10, v11, v31);
  return v24;
}

uint64_t fi_net_allocate_glbIn(uint64_t a1)
{
  unsigned int v8 = 0;
  if (!a1) {
    return 7;
  }
  uint64_t bytes = fi_shape_get_bytes((int *)(a1 + 72), &v8);
  if (!bytes)
  {
    uint64_t bytes = maybe_enlarge_array(*(uint64_t **)a1, (uint64_t *)(a1 + 160), (unsigned int *)(a1 + 168), v8);
    if (bytes) {
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"enlarge pNet->glbIn failed!", v3, v4, v5, v7);
    }
    else {
      bzero(*(void **)(a1 + 160), *(unsigned int *)(a1 + 168));
    }
  }
  return bytes;
}

uint64_t fi_net_copy_indata_to_glbIn_then_free(uint64_t a1, const void **a2)
{
  LODWORD(__n) = 0;
  uint64_t v3 = *a2;
  uint64_t bytes = fi_shape_get_bytes((int *)(a1 + 72), &__n);
  if (bytes != 7) {
    memcpy(*(void **)(a1 + 160), v3, __n);
  }
  return bytes;
}

uint64_t fi_net_forward(uint64_t **a1)
{
  long long v36 = 0u;
  long long v37 = 0u;
  *((void *)&v36 + 1) = a1[15];
  if (!a1[20]) {
    return 7;
  }
  DWORD2(v37) = *((_DWORD *)a1 + 49);
  if (!*((_DWORD *)a1 + 2)) {
    return 0;
  }
  unint64_t v2 = 0;
  int v34 = a1 + 5;
  uint64_t v35 = (uint64_t *)(a1 + 18);
  while (1)
  {
    uint64_t v3 = a1[14][v2];
    LODWORD(v36) = v2;
    *(void *)&long long v37 = 1;
    unsigned int v38 = 0;
    uint64_t bytes = fi_shape_get_bytes((int *)(v3 + 40), &v38);
    if (bytes) {
      return bytes;
    }
    uint64_t v5 = maybe_enlarge_array(*a1, v35, (unsigned int *)a1 + 38, v38);
    if (v5)
    {
      uint64_t v27 = v5;
      uint64_t v28 = **a1;
      uint64_t v29 = "enlarge pNet->glbOut failed!";
      goto LABEL_37;
    }
    uint64_t v9 = *(uint64_t (**)(uint64_t))(v3 + 160);
    if (v9)
    {
      uint64_t v10 = v9(v3);
      if (v10)
      {
        uint64_t v27 = v10;
        uint64_t v30 = **a1;
        uint64_t v31 = fi_layer_type_to_name(*(_DWORD *)(v3 + 8));
        uint64_t v29 = "request global buffer failed for layer %s!";
        goto LABEL_36;
      }
    }
    uint64_t v11 = maybe_enlarge_array(*a1, (uint64_t *)a1 + 16, (unsigned int *)a1 + 34, *(_DWORD *)(v3 + 248));
    if (v11)
    {
      uint64_t v27 = v11;
      uint64_t v28 = **a1;
      uint64_t v29 = "enlarge global buffer failed!";
      goto LABEL_37;
    }
    *(void *)(v3 + 240) = a1[16];
    *(_DWORD *)(v3 + 248) = *((_DWORD *)a1 + 34);
    unint64_t v12 = *(uint64_t (**)(uint64_t))(v3 + 168);
    if (v12)
    {
      uint64_t v13 = v12(v3);
      if (v13) {
        break;
      }
    }
    uint64_t v14 = (*(uint64_t (**)(uint64_t **, uint64_t, uint64_t *, uint64_t *, long long *))(v3 + 128))(v34, v3, a1[20], a1[18], &v36);
    if (v14)
    {
      uint64_t v27 = v14;
      uint64_t v30 = **a1;
      uint64_t v31 = fi_layer_type_to_name(*(_DWORD *)(v3 + 8));
      uint64_t v29 = "forward %s layer failed!";
      goto LABEL_36;
    }
    if (DWORD1(v37) == 1)
    {
      uint64_t bytes = fi_net_update_shape_from_layer(a1, v2, v15, v16, v17, v18, v19, v20);
      if (bytes) {
        return bytes;
      }
    }
    unint64_t v21 = (*((_DWORD *)a1 + 2) - 1);
    if (v37)
    {
      if (v2 >= v21) {
        goto LABEL_17;
      }
LABEL_16:
      uint64_t v22 = a1[20];
      a1[20] = a1[18];
      a1[18] = v22;
      LODWORD(v22) = *((_DWORD *)a1 + 42);
      *((_DWORD *)a1 + 42) = *((_DWORD *)a1 + 38);
      *((_DWORD *)a1 + 38) = v22;
      goto LABEL_17;
    }
    if (v2 == v21) {
      goto LABEL_16;
    }
LABEL_17:
    uint64_t v23 = 20;
    if (v2 >= v21) {
      uint64_t v23 = 18;
    }
    uint64_t v24 = a1[22];
    if (v24)
    {
      if (*(_DWORD *)(v3 + 8) == 26)
      {
        uint64_t v25 = a1[v23];
        uint64_t v26 = *(void *)(v3 + 120);
        if (((unsigned int (*)(uint64_t *, uint64_t, uint64_t *, uint64_t))v24)(a1[23], v26, v25, v3 + 40))
        {
          unsigned int v38 = 0;
          uint64_t bytes = fi_shape_get_size((int *)(v3 + 40), (int *)&v38);
          if (bytes) {
            return bytes;
          }
          memcpy(*(void **)(v26 + 80), v25, *(_DWORD *)(v3 + 56) * v38);
        }
      }
    }
    if (++v2 >= *((unsigned int *)a1 + 2)) {
      return 0;
    }
  }
  uint64_t v27 = v13;
  uint64_t v30 = **a1;
  uint64_t v31 = fi_layer_type_to_name(*(_DWORD *)(v3 + 8));
  uint64_t v29 = "assign sublayer global buffer failed for layer %s!";
LABEL_36:
  uint64_t v33 = (uint64_t)v31;
  uint64_t v28 = v30;
LABEL_37:
  log_OutText(v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)v29, v6, v7, v8, v33);
  return v27;
}

uint64_t fi_net_update_shape_from_layer(uint64_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = *((_DWORD *)a1 + 2);
  if (v9 <= a2)
  {
    log_OutText(**a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"invalid layer_i: %d!", a6, a7, a8, a2);
    return 7;
  }
  else
  {
    unint64_t v10 = 0;
    uint64_t v11 = a1 + 9;
    unint64_t v12 = a2;
    uint64_t v13 = a1 + 9;
    do
    {
      uint64_t v14 = a1[14][v10];
      uint64_t v15 = *(uint64_t (**)(uint64_t, uint64_t **))(v14 + 144);
      if (v15)
      {
        if (v10 > v12)
        {
          uint64_t v16 = v15(a1[14][v10], v13);
          if (v16)
          {
            uint64_t v17 = v16;
            uint64_t v20 = **a1;
            unint64_t v21 = fi_layer_type_to_name(*(_DWORD *)(v14 + 8));
            log_OutText(v20, (uint64_t)"FastInfer", 0, 0, (uint64_t)"update shape of %s layer failed!", v22, v23, v24, (uint64_t)v21);
            return v17;
          }
          unsigned int v9 = *((_DWORD *)a1 + 2);
        }
        uint64_t v13 = (uint64_t **)(v14 + 40);
      }
      ++v10;
    }
    while (v10 < v9);
    uint64_t v17 = 0;
    if (v9)
    {
      uint64_t v18 = a1[14][v9 - 1];
      int v19 = *(_DWORD *)(v18 + 56);
      *(_OWORD *)((char *)a1 + 92) = *(_OWORD *)(v18 + 40);
      *((_DWORD *)a1 + 27) = v19;
    }
    else
    {
      *(_OWORD *)((char *)a1 + 92) = *v11;
      *((_DWORD *)a1 + 27) = *((_DWORD *)a1 + 22);
    }
  }
  return v17;
}

uint64_t maybe_enlarge_array(uint64_t *a1, uint64_t *a2, unsigned int *a3, unsigned int a4)
{
  uint64_t result = 0;
  if (a2 && a3)
  {
    unsigned int v7 = a4;
    if (*a3 >= a4)
    {
      return 0;
    }
    else
    {
      if (*a2)
      {
        (*(void (**)(uint64_t))(a1[1] + 48))(a1[2]);
        *a2 = 0;
      }
      uint64_t v9 = (*(uint64_t (**)(uint64_t, void))a1[1])(a1[2], v7);
      if (v9)
      {
        uint64_t v13 = v9;
        uint64_t result = 0;
        *a2 = v13;
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"enlarge array failed!", v10, v11, v12, v14);
        unsigned int v7 = 0;
        uint64_t result = 10;
      }
      *a3 = v7;
    }
  }
  return result;
}

__n128 fi_net_borrow_output_data(uint64_t a1, char *__s1, uint64_t *a3, __n128 *a4)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  if (v4)
  {
    for (unint64_t i = *(uint64_t **)(a1 + 112); ; ++i)
    {
      uint64_t v9 = *i;
      if (*(_DWORD *)(*i + 8) == 26 && !strcmp(__s1, *(const char **)(v9 + 120))) {
        break;
      }
      if (!--v4) {
        return result;
      }
    }
    *a3 = tee_layer_get_output_buffer(v9);
    unsigned __int32 v11 = *(_DWORD *)(v9 + 56);
    __n128 result = *(__n128 *)(v9 + 40);
    *a4 = result;
    a4[1].n128_u32[0] = v11;
  }
  return result;
}

uint64_t fi_net_reset(uint64_t a1)
{
  if (!a1) {
    return 7;
  }
  *(_DWORD *)(a1 + 192) = 12345;
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2)
  {
    for (unint64_t i = 0; i < v2; ++i)
    {
      uint64_t v4 = *(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 112) + 8 * i) + 176);
      if (v4)
      {
        uint64_t result = v4();
        if (result) {
          return result;
        }
        unint64_t v2 = *(unsigned int *)(a1 + 8);
      }
    }
  }
  return 0;
}

uint64_t fi_net_update_param(uint64_t a1)
{
  if (!a1) {
    return 7;
  }
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2)
  {
    for (unint64_t i = 0; i < v2; ++i)
    {
      uint64_t v4 = *(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 112) + 8 * i) + 224);
      if (v4)
      {
        uint64_t result = v4();
        if (result) {
          return result;
        }
        unint64_t v2 = *(unsigned int *)(a1 + 8);
      }
    }
  }
  return 0;
}

uint64_t fi_net_give_address(uint64_t a1)
{
  if (!a1) {
    return 7;
  }
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2)
  {
    for (unint64_t i = 0; i < v2; ++i)
    {
      uint64_t v4 = *(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 112) + 8 * i) + 232);
      if (v4)
      {
        uint64_t result = v4();
        if (result) {
          return result;
        }
        unint64_t v2 = *(unsigned int *)(a1 + 8);
      }
    }
  }
  return 0;
}

uint64_t fi_rsc_create(void *a1, void *a2)
{
  uint64_t v4 = (void *)a1[1];
  uint64_t v5 = (uint64_t (**)(uint64_t, unint64_t))calloc_aligned_32_mem((uint64_t)v4, 1, 88);
  if (v5)
  {
    uint64_t v6 = v5;
    unsigned int v7 = calloc_aligned_32_mem((uint64_t)v4, 1, 104);
    if (v7)
    {
      uint64_t v8 = v7;
      *uint64_t v6 = alloc_aligned_32_mem;
      v6[1] = (uint64_t (*)(uint64_t, unint64_t))realloc_aligned_32_mem;
      v6[2] = (uint64_t (*)(uint64_t, unint64_t))calloc_aligned_32_mem;
      v6[3] = (uint64_t (*)(uint64_t, unint64_t))alloc_aligned_mem;
      v6[4] = (uint64_t (*)(uint64_t, unint64_t))realloc_aligned_mem;
      v6[5] = (uint64_t (*)(uint64_t, unint64_t))calloc_aligned_mem;
      v6[6] = (uint64_t (*)(uint64_t, unint64_t))free_aligned_mem;
      v6[9] = (uint64_t (*)(uint64_t, unint64_t))alloc_mem;
      v6[8] = (uint64_t (*)(uint64_t, unint64_t))calloc_mem;
      v6[7] = (uint64_t (*)(uint64_t, unint64_t))realloc_mem;
      v6[10] = (uint64_t (*)(uint64_t, unint64_t))free_mem;
      v7[2] = v4;
      *unsigned int v7 = a1[4];
      v7[1] = v6;
      fi_thread_init((uint64_t)(v7 + 3), a1);
      *((_DWORD *)v8 + 24) = 2;
      *a2 = v8;
      log_OutText(*v8, (uint64_t)"FastInfer", 4, 0, (uint64_t)"FI GEMM macro: (None)", v9, v10, v11, v13);
      return 0;
    }
    free_aligned_mem(v4, (uint64_t)v6);
  }
  return 10;
}

void *fi_rsc_destroy(void *result)
{
  if (result)
  {
    uint64_t v1 = (uint64_t)result;
    fi_thread_deinit((uint64_t)(result + 3), (uint64_t)result);
    uint64_t v2 = *(void *)(v1 + 8);
    if (v2)
    {
      free_aligned_mem(*(void **)(v1 + 16), v2);
      *(void *)(v1 + 8) = 0;
    }
    uint64_t v3 = *(void **)(v1 + 16);
    return free_aligned_mem(v3, v1);
  }
  return result;
}

uint64_t get_padded_len(uint64_t result, unsigned int a2)
{
  unsigned int v2 = result / a2 * a2;
  BOOL v3 = result == v2;
  unsigned int v4 = a2 + v2;
  if (v3) {
    return result;
  }
  else {
    return v4;
  }
}

uint64_t get_padded_bytes(unsigned int a1, unsigned int a2)
{
  unsigned int v2 = a1 >> 2;
  int v3 = (a1 >> 2) / a2 * a2;
  BOOL v4 = a1 >> 2 == v3;
  unsigned int v5 = a2 + v3;
  if (!v4) {
    unsigned int v2 = v5;
  }
  return 4 * v2;
}

uint64_t fi_thread_init(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v3 = a2[50];
    *(void *)a1 = v3;
    a2 = (void *)a2[1];
  }
  else
  {
    uint64_t v3 = *(void *)a1;
  }
  *(_DWORD *)(a1 + 8) = 1;
  uint64_t result = semaphore_ObjectOpen(v3, a2, 1, 1, (uint64_t *)(a1 + 16));
  if ((result & 0x80000000) != 0) {
    *(_DWORD *)(a1 + 8) = 0;
  }
  return result;
}

uint64_t fi_thread_deinit(uint64_t a1, uint64_t a2)
{
  fi_rsc_checkDestroySecondThread(a2);
  uint64_t v3 = *(void *)(a1 + 16);
  return semaphore_ObjectClose(v3);
}

uint64_t fi_rsc_checkDestroySecondThread(uint64_t a1)
{
  uint64_t result = semaphore_Acquire(*(void **)(a1 + 40));
  if ((result & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 32) >= 2u)
    {
      *(void *)(a1 + 80) = 0;
      if ((semaphore_Release(*(void **)(a1 + 48)) & 0x80000000) == 0) {
        thread_Join(*(void **)(a1 + 64));
      }
      semaphore_ObjectClose(*(void *)(a1 + 48));
      semaphore_ObjectClose(*(void *)(a1 + 56));
      thread_ObjClose(*(void *)(a1 + 64));
      *(_DWORD *)(a1 + 32) = 1;
    }
    uint64_t v3 = *(void **)(a1 + 40);
    return semaphore_Release(v3);
  }
  return result;
}

uint64_t fi_rsc_checkCreateSecondThread(uint64_t a1)
{
  uint64_t result = semaphore_Acquire(*(void **)(a1 + 40));
  if ((result & 0x80000000) != 0) {
    return result;
  }
  if (*(_DWORD *)(a1 + 32) == 1)
  {
    log_OutText(*(void *)a1, (uint64_t)"FastInfer", 2, 0, (uint64_t)"FastInfer multithreaded mode enabled", v3, v4, v5, v11);
    uint64_t v6 = (uint64_t *)(a1 + 48);
    if ((semaphore_ObjectOpen(*(void *)(a1 + 24), *(void **)(a1 + 16), 0, 1, (uint64_t *)(a1 + 48)) & 0x80000000) != 0) {
      goto LABEL_12;
    }
    unsigned int v7 = (uint64_t *)(a1 + 56);
    if ((semaphore_ObjectOpen(*(void *)(a1 + 24), *(void **)(a1 + 16), 0, 1, (uint64_t *)(a1 + 56)) & 0x80000000) != 0)
    {
      uint64_t v8 = *v6;
    }
    else
    {
      if ((thread_ObjOpen(*(void *)(a1 + 24), *(void **)(a1 + 16), (uint64_t *)(a1 + 64)) & 0x80000000) == 0)
      {
        if (!thread_Start(*(void **)(a1 + 64)))
        {
          int v9 = 2;
          goto LABEL_13;
        }
        semaphore_ObjectClose(*v6);
        semaphore_ObjectClose(*v7);
        thread_ObjClose(*(void *)(a1 + 64));
LABEL_12:
        int v9 = 0;
LABEL_13:
        *(_DWORD *)(a1 + 32) = v9;
        goto LABEL_14;
      }
      semaphore_ObjectClose(*v6);
      uint64_t v8 = *v7;
    }
    semaphore_ObjectClose(v8);
    goto LABEL_12;
  }
LABEL_14:
  uint64_t v10 = *(void **)(a1 + 40);
  return semaphore_Release(v10);
}

uint64_t fastinfer_workerthread(uint64_t a1)
{
  do
  {
    if ((semaphore_Acquire(*(void **)(a1 + 48)) & 0x80000000) != 0) {
      break;
    }
    unsigned int v2 = *(uint64_t (**)(uint64_t, void))(a1 + 80);
    if (!v2) {
      return 0;
    }
    *(_DWORD *)(a1 + 88) = v2(a1, *(void *)(a1 + 72));
  }
  while ((semaphore_Release(*(void **)(a1 + 56)) & 0x80000000) == 0);
  *(_DWORD *)(a1 + 88) = 512;
  return 0;
}

BOOL fi_thread_checkQueueTask(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((semaphore_Acquire(*(void **)(a1 + 16)) & 0x80000000) != 0) {
    return 0;
  }
  if (*(_DWORD *)(a1 + 8) == 2)
  {
    *(void *)(a1 + 48) = a2;
    *(void *)(a1 + 56) = a3;
    int v6 = semaphore_Release(*(void **)(a1 + 24));
    BOOL v7 = v6 >= 0;
    *(_DWORD *)(a1 + 8) = ~(v6 >> 31) & 3;
  }
  else
  {
    BOOL v7 = 0;
  }
  semaphore_Release(*(void **)(a1 + 16));
  return v7;
}

uint64_t fi_thread_wait4Task(uint64_t a1)
{
  int v2 = semaphore_Acquire(*(void **)(a1 + 32));
  if ((semaphore_Acquire(*(void **)(a1 + 16)) & 0x80000000) != 0) {
    return 0;
  }
  if (v2 < 0) {
    *(_DWORD *)(a1 + 64) = 512;
  }
  *(_DWORD *)(a1 + 8) = 2;
  semaphore_Release(*(void **)(a1 + 16));
  return *(unsigned int *)(a1 + 64);
}

uint64_t fi_argmax(uint64_t result, int a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v2 = result;
  uint64_t v3 = 0;
  LODWORD(result) = 0;
  float v4 = 0.0;
  do
  {
    if (*(float *)(v2 + 4 * v3) <= v4)
    {
      uint64_t result = result;
    }
    else
    {
      float v4 = *(float *)(v2 + 4 * v3);
      uint64_t result = v3;
    }
    ++v3;
  }
  while (a2 != v3);
  return result;
}

uint64_t get_bytesOfElem(unsigned int a1, unsigned char *a2)
{
  if (a1 > 2) {
    return 7;
  }
  char v2 = a1;
  uint64_t result = 0;
  *a2 = 0x20104u >> (8 * v2);
  return result;
}

uint64_t parse_fi_binary_model_inner(uint64_t *a1, uint64_t a2, unsigned int *a3, _DWORD *a4, void *a5)
{
  int v9 = a1;
  v581 = 0;
  uint64_t v10 = fi_net_init(a1, &v581);
  if (v10)
  {
    uint64_t v14 = v10;
    uint64_t v15 = *v9;
    uint64_t v16 = "init network failed!";
LABEL_8:
    log_OutText(v15, (uint64_t)"FastInfer", 0, 0, (uint64_t)v16, v11, v12, v13, v569);
    goto LABEL_9;
  }
  *a3 = 4;
  *((_DWORD *)v581 + 2) = *(_DWORD *)(a2 + *a4);
  *a4 += *a3;
  log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v11, v12, v13, 0);
  *a3 = 12;
  uint64_t v17 = v581;
  uint64_t v18 = a2 + *a4;
  int v19 = *(uint64_t **)v18;
  *((_DWORD *)v581 + 5) = *(_DWORD *)(v18 + 8);
  *(uint64_t **)((char *)v17 + 12) = v19;
  *a4 += *a3;
  log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v20, v21, v22, 0);
  *a3 = 20;
  uint64_t v23 = v581;
  uint64_t v24 = (long long *)(a2 + *a4);
  long long v25 = *v24;
  *((_DWORD *)v581 + 17) = *((_DWORD *)v24 + 4);
  *(_OWORD *)((char *)v23 + 52) = v25;
  *a4 += *a3;
  log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v26, v27, v28, 0);
  if (fi_version_cmp((uint64_t)v9, (int *)v581 + 3, "0.0.0"))
  {
    uint64_t v32 = 0;
    uint64_t v33 = v581;
    v581[5] = *(uint64_t **)((char *)v581 + 12);
    *((_DWORD *)v33 + 12) = *((_DWORD *)v33 + 5);
    *((_DWORD *)v33 + 6) = 0;
  }
  else
  {
    *a3 = 12;
    int v34 = v581;
    uint64_t v35 = a2 + *a4;
    int v36 = *(_DWORD *)(v35 + 8);
    v581[5] = *(uint64_t **)v35;
    *((_DWORD *)v34 + 12) = v36;
    *a4 += *a3;
    log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v29, v30, v31, 0);
    *a3 = 4;
    *((_DWORD *)v581 + 6) = *(_DWORD *)(a2 + *a4);
    *a4 += *a3;
    log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v37, v38, v39, 0);
    int v40 = *((_DWORD *)v581 + 6);
    *a3 = 4 * v40;
    uint64_t v41 = *a4;
    uint64_t v32 = (uint64_t *)(a2 + v41);
    *a4 = v41 + 4 * v40;
    log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v42, v43, v44, 0);
    uint64_t v33 = v581;
  }
  v33[4] = v32;
  log_OutText(*v9, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Network layers number: ", v29, v30, v31, *((unsigned int *)v33 + 2));
  fi_shape_dump(v9, (uint64_t)v581 + 52, (uint64_t)"non-changed network model inshape: ", v45, v46, v47, v48, v49);
  uint64_t v50 = fi_net_layers_init(v581);
  if (v50)
  {
    uint64_t v14 = v50;
    uint64_t v15 = *v9;
    uint64_t v16 = "init layers failed!";
    goto LABEL_8;
  }
  if (!*((_DWORD *)v581 + 2))
  {
LABEL_175:
    log_OutText(*v9, (uint64_t)"FastInfer", 4, 0, (uint64_t)"load model done!", v11, v12, v13, v569);
    uint64_t v14 = 0;
    *a5 = v581;
    return v14;
  }
  unint64_t v53 = 0;
  v575 = v9;
  while (2)
  {
    uint64_t v579 = 0;
    v580 = 0;
    v577 = 0;
    *a3 = 4;
    uint64_t v54 = *a4;
    unsigned int v578 = *(_DWORD *)(a2 + v54);
    *a4 = v54 + 4;
    log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v11, v12, v13, (uint64_t)&byte_20D5A22AE);
    *a3 = 4;
    uint64_t v55 = *a4;
    LODWORD(v579) = *(_DWORD *)(a2 + v55);
    *a4 = v55 + 4;
    log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v56, v57, v58, (uint64_t)&byte_20D5A22AE);
    if (fi_feat_is_enabled((uint64_t)v581[4], 3u, *((_DWORD *)v581 + 6)))
    {
      *a3 = 4;
      uint64_t v62 = *a4;
      HIDWORD(v579) = *(_DWORD *)(a2 + v62);
      *a4 = v62 + 4;
      log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v59, v60, v61, (uint64_t)&byte_20D5A22AE);
    }
    *a3 = 8;
    uint64_t v63 = *a4;
    v577 = *(uint64_t **)(a2 + v63);
    *a4 = v63 + 8;
    log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v59, v60, v61, (uint64_t)&byte_20D5A22AE);
    uint64_t v67 = fi_layer_type_to_name(v578);
    switch(v578)
    {
      case 0u:
        *(long long *)((char *)__dst + 4) = 0u;
        *(long long *)((char *)&__dst[1] + 4) = 0u;
        *((void *)&__dst[0] + 1) = 0x100000001;
        *a3 = 4;
        uint64_t v162 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v162);
        *a4 = v162 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        uint64_t v163 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v163);
        *a4 = v163 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v164, v165, v166, (uint64_t)v67);
        *a3 = 4;
        uint64_t v167 = *a4;
        LODWORD(__dst[1]) = *(_DWORD *)(a2 + v167);
        *a4 = v167 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v168, v169, v170, (uint64_t)v67);
        *a3 = 4;
        uint64_t v171 = *a4;
        DWORD1(__dst[1]) = *(_DWORD *)(a2 + v171);
        *a4 = v171 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v172, v173, v174, (uint64_t)v67);
        *a3 = 4;
        uint64_t v175 = *a4;
        HIDWORD(__dst[1]) = *(_DWORD *)(a2 + v175);
        *a4 = v175 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v176, v177, v178, (uint64_t)v67);
        *a3 = 4;
        uint64_t v179 = *a4;
        LODWORD(__dst[2]) = *(_DWORD *)(a2 + v179);
        *a4 = v179 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v180, v181, v182, (uint64_t)v67);
        if (fi_feat_is_enabled((uint64_t)v581[4], 0, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          uint64_t v186 = *a4;
          DWORD2(__dst[0]) = *(_DWORD *)(a2 + v186);
          *a4 = v186 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v183, v184, v185, (uint64_t)v67);
          *a3 = 4;
          uint64_t v187 = *a4;
          HIDWORD(__dst[0]) = *(_DWORD *)(a2 + v187);
          *a4 = v187 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v188, v189, v190, (uint64_t)v67);
        }
        if (fi_feat_is_enabled((uint64_t)v581[4], 1u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          uint64_t v194 = *a4;
          DWORD2(__dst[1]) = *(_DWORD *)(a2 + v194);
          *a4 = v194 + 4;
          int v9 = v575;
          log_OutText(*v575, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v191, v192, v193, (uint64_t)v67);
        }
        else
        {
          DWORD2(__dst[1]) = 1;
          int v9 = v575;
        }
        uint64_t v566 = create_conv1d_layer(v9, __dst, &v577, (uint64_t)(v581 + 1), &v580);
        if (!v566) {
          goto LABEL_24;
        }
        uint64_t v14 = v566;
        uint64_t v15 = *v9;
        uint64_t v16 = "create conv1d layer failed!";
        goto LABEL_8;
      case 1u:
        *(long long *)((char *)__dst + 4) = 0u;
        *(long long *)((char *)&__dst[1] + 4) = 0u;
        *((void *)&__dst[0] + 1) = 0x100000001;
        *a3 = 4;
        uint64_t v195 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v195);
        *a4 = v195 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        uint64_t v196 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v196);
        *a4 = v196 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v197, v198, v199, (uint64_t)v67);
        *a3 = 4;
        uint64_t v200 = *a4;
        LODWORD(__dst[1]) = *(_DWORD *)(a2 + v200);
        *a4 = v200 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v201, v202, v203, (uint64_t)v67);
        *a3 = 4;
        uint64_t v204 = *a4;
        DWORD1(__dst[1]) = *(_DWORD *)(a2 + v204);
        *a4 = v204 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v205, v206, v207, (uint64_t)v67);
        *a3 = 4;
        uint64_t v208 = *a4;
        HIDWORD(__dst[1]) = *(_DWORD *)(a2 + v208);
        *a4 = v208 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v209, v210, v211, (uint64_t)v67);
        *a3 = 4;
        uint64_t v212 = *a4;
        LODWORD(__dst[2]) = *(_DWORD *)(a2 + v212);
        *a4 = v212 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v213, v214, v215, (uint64_t)v67);
        if (fi_feat_is_enabled((uint64_t)v581[4], 0, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          uint64_t v219 = *a4;
          DWORD2(__dst[0]) = *(_DWORD *)(a2 + v219);
          *a4 = v219 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v216, v217, v218, (uint64_t)v67);
          *a3 = 4;
          uint64_t v220 = *a4;
          HIDWORD(__dst[0]) = *(_DWORD *)(a2 + v220);
          *a4 = v220 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v221, v222, v223, (uint64_t)v67);
        }
        if (fi_feat_is_enabled((uint64_t)v581[4], 1u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          uint64_t v227 = *a4;
          DWORD2(__dst[1]) = *(_DWORD *)(a2 + v227);
          *a4 = v227 + 4;
          int v9 = v575;
          log_OutText(*v575, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v224, v225, v226, (uint64_t)v67);
        }
        else
        {
          DWORD2(__dst[1]) = 1;
          int v9 = v575;
        }
        uint64_t v567 = create_conv2d_layer(v9, __dst, &v577, &v580);
        if (!v567) {
          goto LABEL_24;
        }
        uint64_t v14 = v567;
        uint64_t v15 = *v9;
        uint64_t v16 = "create conv2d layer failed!";
        goto LABEL_8;
      case 2u:
        *(void *)((char *)__dst + 4) = 0;
        *a3 = 4;
        uint64_t v228 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v228);
        *a4 = v228 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        uint64_t v229 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v229);
        *a4 = v229 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v230, v231, v232, (uint64_t)v67);
        if (fi_feat_is_enabled((uint64_t)v581[4], 2u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          uint64_t v236 = *a4;
          DWORD2(__dst[0]) = *(_DWORD *)(a2 + v236);
          *a4 = v236 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v233, v234, v235, (uint64_t)v67);
        }
        uint64_t v237 = create_rnn_layer(v9, (uint64_t *)&v578, (uint64_t *)__dst, &v577, (uint64_t *)&v580);
        if (!v237) {
          goto LABEL_24;
        }
        uint64_t v14 = v237;
        uint64_t v15 = *v9;
        uint64_t v16 = "create rnn layer failed!";
        goto LABEL_8;
      case 3u:
        *(void *)((char *)__dst + 4) = 0;
        *(void *)((char *)__dst + 12) = 0;
        *(void *)((char *)&__dst[1] + 4) = 0;
        *a3 = 4;
        uint64_t v238 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v238);
        *a4 = v238 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        uint64_t v239 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v239);
        *a4 = v239 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v240, v241, v242, (uint64_t)v67);
        *a3 = 4;
        uint64_t v243 = *a4;
        DWORD2(__dst[0]) = *(_DWORD *)(a2 + v243);
        *a4 = v243 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v244, v245, v246, (uint64_t)v67);
        *a3 = 4;
        uint64_t v247 = *a4;
        HIDWORD(__dst[0]) = *(_DWORD *)(a2 + v247);
        *a4 = v247 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v248, v249, v250, (uint64_t)v67);
        if (LODWORD(__dst[0]) == 2)
        {
          *a3 = 4;
          uint64_t v254 = *a4;
          LODWORD(__dst[1]) = *(_DWORD *)(a2 + v254);
          *a4 = v254 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v251, v252, v253, (uint64_t)v67);
        }
        if (fi_feat_is_enabled((uint64_t)v581[4], 2u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          uint64_t v258 = *a4;
          DWORD2(__dst[1]) = *(_DWORD *)(a2 + v258);
          *a4 = v258 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v255, v256, v257, (uint64_t)v67);
        }
        if (fi_feat_is_enabled((uint64_t)v581[4], 6u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          uint64_t v262 = *a4;
          DWORD1(__dst[1]) = *(_DWORD *)(a2 + v262);
          *a4 = v262 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v259, v260, v261, (uint64_t)v67);
        }
        uint64_t v263 = create_lstm_layer(v9, &v578, __dst, &v577, v581 + 1, &v580);
        if (!v263) {
          goto LABEL_24;
        }
        uint64_t v14 = v263;
        uint64_t v15 = *v9;
        uint64_t v16 = "create lstm layer failed!";
        goto LABEL_8;
      case 4u:
        *(void *)((char *)__dst + 4) = 0;
        *(void *)((char *)__dst + 12) = 0;
        *(void *)((char *)&__dst[1] + 4) = 0;
        *a3 = 4;
        uint64_t v264 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v264);
        *a4 = v264 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        uint64_t v265 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v265);
        *a4 = v265 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v266, v267, v268, (uint64_t)v67);
        *a3 = 4;
        uint64_t v269 = *a4;
        DWORD2(__dst[0]) = *(_DWORD *)(a2 + v269);
        *a4 = v269 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v270, v271, v272, (uint64_t)v67);
        *a3 = 4;
        uint64_t v273 = *a4;
        HIDWORD(__dst[0]) = *(_DWORD *)(a2 + v273);
        *a4 = v273 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v274, v275, v276, (uint64_t)v67);
        if (LODWORD(__dst[0]) == 2)
        {
          *a3 = 4;
          uint64_t v280 = *a4;
          LODWORD(__dst[1]) = *(_DWORD *)(a2 + v280);
          *a4 = v280 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v277, v278, v279, (uint64_t)v67);
        }
        if (fi_feat_is_enabled((uint64_t)v581[4], 2u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          uint64_t v284 = *a4;
          DWORD2(__dst[1]) = *(_DWORD *)(a2 + v284);
          *a4 = v284 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v281, v282, v283, (uint64_t)v67);
        }
        if (fi_feat_is_enabled((uint64_t)v581[4], 6u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          uint64_t v288 = *a4;
          DWORD1(__dst[1]) = *(_DWORD *)(a2 + v288);
          *a4 = v288 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v285, v286, v287, (uint64_t)v67);
        }
        uint64_t v289 = create_blstm_layer(v9, (uint64_t *)&v578, __dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!v289) {
          goto LABEL_24;
        }
        uint64_t v14 = v289;
        uint64_t v15 = *v9;
        uint64_t v16 = "create blstm layer failed!";
        goto LABEL_8;
      case 5u:
        *(void *)&__dst[0] = 0;
        *a3 = 4;
        uint64_t v290 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v290);
        *a4 = v290 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        if (fi_feat_is_enabled((uint64_t)v581[4], 5u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          uint64_t v294 = *a4;
          DWORD1(__dst[0]) = *(_DWORD *)(a2 + v294);
          *a4 = v294 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v291, v292, v293, (uint64_t)v67);
        }
        else
        {
          DWORD1(__dst[0]) = 1;
        }
        uint64_t tee_param = create_fc_layer(v9, (uint64_t *)&v578, __dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (tee_param) {
          goto LABEL_177;
        }
        goto LABEL_24;
      case 6u:
        *a3 = 4;
        uint64_t v295 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v295);
        *a4 = v295 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t v296 = create_softmax_layer(v9, (uint64_t *)&v578, __dst, &v577, (uint64_t *)&v580);
        if (!v296) {
          goto LABEL_24;
        }
        uint64_t v14 = v296;
        uint64_t v15 = *v9;
        uint64_t v16 = "create softmax layer failed!";
        goto LABEL_8;
      case 7u:
        *a3 = 4;
        uint64_t v297 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v297);
        *a4 = v297 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t v298 = create_flatten_layer(v9, __dst, &v580);
        if (!v298) {
          goto LABEL_24;
        }
        uint64_t v14 = v298;
        uint64_t v15 = *v9;
        uint64_t v16 = "create flatten layer failed!";
        goto LABEL_8;
      case 8u:
      case 9u:
      case 0xAu:
      case 0xBu:
      case 0xCu:
      case 0xDu:
        unint64_t v68 = v53;
        *(long long *)((char *)__dst + 4) = 0u;
        *(long long *)((char *)&__dst[1] + 4) = 0u;
        *((void *)&__dst[0] + 1) = 0x100000001;
        *a3 = 4;
        uint64_t v69 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v69);
        *a4 = v69 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        uint64_t v70 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v70);
        *a4 = v70 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v71, v72, v73, (uint64_t)v67);
        *a3 = 4;
        uint64_t v74 = *a4;
        LODWORD(__dst[1]) = *(_DWORD *)(a2 + v74);
        *a4 = v74 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v75, v76, v77, (uint64_t)v67);
        *a3 = 4;
        uint64_t v78 = *a4;
        DWORD1(__dst[1]) = *(_DWORD *)(a2 + v78);
        *a4 = v78 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v79, v80, v81, (uint64_t)v67);
        *a3 = 4;
        uint64_t v82 = *a4;
        HIDWORD(__dst[1]) = *(_DWORD *)(a2 + v82);
        *a4 = v82 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v83, v84, v85, (uint64_t)v67);
        *a3 = 4;
        uint64_t v86 = *a4;
        LODWORD(__dst[2]) = *(_DWORD *)(a2 + v86);
        *a4 = v86 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v87, v88, v89, (uint64_t)v67);
        if (fi_feat_is_enabled((uint64_t)v581[4], 0, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          uint64_t v93 = *a4;
          DWORD2(__dst[0]) = *(_DWORD *)(a2 + v93);
          *a4 = v93 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v90, v91, v92, (uint64_t)v67);
          *a3 = 4;
          uint64_t v94 = *a4;
          HIDWORD(__dst[0]) = *(_DWORD *)(a2 + v94);
          *a4 = v94 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v95, v96, v97, (uint64_t)v67);
        }
        uint64_t v98 = create_pooling1d_layer(v9, v578, __dst, &v577, &v580);
        if (!v98) {
          goto LABEL_23;
        }
        uint64_t v14 = v98;
        uint64_t v15 = *v9;
        uint64_t v16 = "create pooling1d layer failed!";
        goto LABEL_8;
      case 0xEu:
      case 0xFu:
      case 0x10u:
      case 0x11u:
      case 0x12u:
      case 0x13u:
        unint64_t v68 = v53;
        *(long long *)((char *)__dst + 4) = 0u;
        *(long long *)((char *)&__dst[1] + 4) = 0u;
        *((void *)&__dst[0] + 1) = 0x100000001;
        *a3 = 4;
        uint64_t v99 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v99);
        *a4 = v99 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        uint64_t v100 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v100);
        *a4 = v100 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v101, v102, v103, (uint64_t)v67);
        *a3 = 4;
        uint64_t v104 = *a4;
        LODWORD(__dst[1]) = *(_DWORD *)(a2 + v104);
        *a4 = v104 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v105, v106, v107, (uint64_t)v67);
        *a3 = 4;
        uint64_t v108 = *a4;
        DWORD1(__dst[1]) = *(_DWORD *)(a2 + v108);
        *a4 = v108 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v109, v110, v111, (uint64_t)v67);
        *a3 = 4;
        uint64_t v112 = *a4;
        HIDWORD(__dst[1]) = *(_DWORD *)(a2 + v112);
        *a4 = v112 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v113, v114, v115, (uint64_t)v67);
        *a3 = 4;
        uint64_t v116 = *a4;
        LODWORD(__dst[2]) = *(_DWORD *)(a2 + v116);
        *a4 = v116 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v117, v118, v119, (uint64_t)v67);
        if (fi_feat_is_enabled((uint64_t)v581[4], 0, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          uint64_t v123 = *a4;
          DWORD2(__dst[0]) = *(_DWORD *)(a2 + v123);
          *a4 = v123 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v120, v121, v122, (uint64_t)v67);
          *a3 = 4;
          uint64_t v124 = *a4;
          HIDWORD(__dst[0]) = *(_DWORD *)(a2 + v124);
          *a4 = v124 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v125, v126, v127, (uint64_t)v67);
        }
        uint64_t v128 = create_pooling2d_layer(v9, v578, __dst, &v577, &v580);
        if (v128)
        {
          uint64_t v14 = v128;
          uint64_t v15 = *v9;
          uint64_t v16 = "create pooling2d layer failed!";
          goto LABEL_8;
        }
LABEL_23:
        unint64_t v53 = v68;
        goto LABEL_24;
      case 0x14u:
        memset(__dst, 0, 56);
        *a3 = 4;
        uint64_t v299 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v299);
        *a4 = v299 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        uint64_t v300 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v300);
        *a4 = v300 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v301, v302, v303, (uint64_t)v67);
        int v304 = DWORD1(__dst[0]);
        *a3 = DWORD1(__dst[0]);
        uint64_t v305 = *a4;
        *((void *)&__dst[0] + 1) = a2 + v305;
        *a4 = v305 + v304;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v306, v307, v308, (uint64_t)v67);
        *a3 = 4;
        uint64_t v309 = *a4;
        LODWORD(__dst[1]) = *(_DWORD *)(a2 + v309);
        *a4 = v309 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v310, v311, v312, (uint64_t)v67);
        if (LODWORD(__dst[1]))
        {
          int v316 = LODWORD(__dst[0]) * LODWORD(__dst[0]);
          *a3 = 4 * LODWORD(__dst[0]) * LODWORD(__dst[0]);
          uint64_t v317 = *a4;
          uint64_t v318 = a2 + v317;
          *a4 = v317 + 4 * v316;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v313, v314, v315, (uint64_t)v67);
          *((void *)&__dst[1] + 1) = v318;
        }
        *a3 = 4;
        uint64_t v319 = *a4;
        LODWORD(__dst[2]) = *(_DWORD *)(a2 + v319);
        *a4 = v319 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v313, v314, v315, (uint64_t)v67);
        if (LODWORD(__dst[2]))
        {
          int v323 = __dst[0];
          *a3 = 4 * LODWORD(__dst[0]);
          uint64_t v324 = *a4;
          uint64_t v325 = a2 + v324;
          *a4 = v324 + 4 * v323;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v320, v321, v322, (uint64_t)v67);
          *((void *)&__dst[2] + 1) = v325;
        }
        LODWORD(__dst[3]) = 0;
        uint64_t v326 = create_label_layer(v9, (unsigned int *)__dst, &v577, (uint64_t *)&v580);
        if (!v326) {
          goto LABEL_24;
        }
        uint64_t v14 = v326;
        uint64_t v15 = *v9;
        uint64_t v16 = "create label layer failed!";
        goto LABEL_8;
      case 0x15u:
        *a3 = 4;
        uint64_t v327 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v327);
        *a4 = v327 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t v331 = create_repeat_layer(v9, (uint64_t *)&v578, __dst, &v577, &v580, v328, v329, v330);
        if (!v331) {
          goto LABEL_24;
        }
        uint64_t v14 = v331;
        uint64_t v15 = *v9;
        uint64_t v16 = "create repeat layer failed!";
        goto LABEL_8;
      case 0x16u:
      case 0x28u:
        uint64_t norm_layer = create_norm_layer(v9, (uint64_t *)&v578, (uint64_t *)&v580);
        if (!norm_layer) {
          goto LABEL_24;
        }
        uint64_t v14 = norm_layer;
        uint64_t v15 = *v9;
        uint64_t v16 = "create norm layer failed!";
        goto LABEL_8;
      case 0x17u:
        *(void *)((char *)__dst + 4) = 0;
        *(void *)((char *)__dst + 12) = 0;
        *a3 = 4;
        uint64_t v332 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v332);
        *a4 = v332 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        uint64_t v333 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v333);
        *a4 = v333 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v334, v335, v336, (uint64_t)v67);
        *a3 = 4;
        uint64_t v337 = *a4;
        DWORD2(__dst[0]) = *(_DWORD *)(a2 + v337);
        *a4 = v337 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v338, v339, v340, (uint64_t)v67);
        *a3 = 4;
        uint64_t v341 = *a4;
        HIDWORD(__dst[0]) = *(_DWORD *)(a2 + v341);
        *a4 = v341 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v342, v343, v344, (uint64_t)v67);
        if (fi_feat_is_enabled((uint64_t)v581[4], 2u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          uint64_t v348 = *a4;
          LODWORD(__dst[1]) = *(_DWORD *)(a2 + v348);
          *a4 = v348 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v345, v346, v347, (uint64_t)v67);
        }
        uint64_t v349 = create_gru_layer(v9, (uint64_t)&v578, __dst, &v577, (uint64_t)(v581 + 1), &v580);
        if (!v349) {
          goto LABEL_24;
        }
        uint64_t v14 = v349;
        uint64_t v15 = *v9;
        uint64_t v16 = "create gru layer failed!";
        goto LABEL_8;
      case 0x18u:
        *(void *)((char *)__dst + 4) = 0;
        *(void *)((char *)__dst + 12) = 0;
        *a3 = 4;
        uint64_t v350 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v350);
        *a4 = v350 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        uint64_t v351 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v351);
        *a4 = v351 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v352, v353, v354, (uint64_t)v67);
        *a3 = 4;
        uint64_t v355 = *a4;
        DWORD2(__dst[0]) = *(_DWORD *)(a2 + v355);
        *a4 = v355 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v356, v357, v358, (uint64_t)v67);
        *a3 = 4;
        uint64_t v359 = *a4;
        HIDWORD(__dst[0]) = *(_DWORD *)(a2 + v359);
        *a4 = v359 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v360, v361, v362, (uint64_t)v67);
        if (fi_feat_is_enabled((uint64_t)v581[4], 2u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          uint64_t v366 = *a4;
          LODWORD(__dst[1]) = *(_DWORD *)(a2 + v366);
          *a4 = v366 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v363, v364, v365, (uint64_t)v67);
        }
        uint64_t v367 = create_bgru_layer(v9, (uint64_t *)&v578, __dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!v367) {
          goto LABEL_24;
        }
        uint64_t v14 = v367;
        uint64_t v15 = *v9;
        uint64_t v16 = "create bgru layer failed!";
        goto LABEL_8;
      case 0x19u:
        v570 = a5;
        unint64_t v368 = v53;
        *a3 = 4;
        uint64_t v369 = *a4;
        int v572 = *(_DWORD *)(a2 + v369);
        *a4 = v369 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        uint64_t v370 = *a4;
        uint64_t v371 = *(unsigned int *)(a2 + v370);
        *a4 = v370 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v372, v373, v374, (uint64_t)v67);
        uint64_t v375 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v9[1] + 16))(v9[2], v371, 8);
        if (!v375)
        {
          log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v376, v377, v378, v569);
          uint64_t v14 = 0;
          void *v570 = v581;
          return v14;
        }
        uint64_t v379 = v375;
        uint64_t v380 = v371;
        uint64_t v381 = v375;
        if (v371)
        {
          while (1)
          {
            uint64_t v382 = parse_fi_binary_model_inner(v9, a2, a3, a4, v381);
            if (v382) {
              break;
            }
            v381 += 8;
            if (!--v380) {
              goto LABEL_88;
            }
          }
          uint64_t v14 = v382;
          log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"parse nest layer submodel failed!", v383, v384, v385, v569);
LABEL_180:
          a5 = v570;
          goto LABEL_9;
        }
LABEL_88:
        uint64_t v386 = create_nest_layer(v9, v572, v371, v379, &v580);
        unint64_t v53 = v368;
        a5 = v570;
        if (v386)
        {
          uint64_t v14 = v386;
          uint64_t v15 = *v9;
          uint64_t v16 = "create nest layer failed!";
          goto LABEL_8;
        }
        goto LABEL_24;
      case 0x1Au:
        *(void *)&__dst[0] = 0;
        uint64_t tee_param = create_tee_param(v9, (uint64_t *)__dst);
        if (tee_param) {
          goto LABEL_177;
        }
        *a3 = 72;
        uint64_t v390 = *(void *)&__dst[0];
        uint64_t v391 = a2 + *a4;
        **(_OWORD **)&__dst[0] = *(_OWORD *)v391;
        long long v393 = *(_OWORD *)(v391 + 32);
        long long v392 = *(_OWORD *)(v391 + 48);
        long long v394 = *(_OWORD *)(v391 + 16);
        *(void *)(v390 + 64) = *(void *)(v391 + 64);
        *(_OWORD *)(v390 + 32) = v393;
        *(_OWORD *)(v390 + 48) = v392;
        *(_OWORD *)(v390 + 16) = v394;
        *a4 += *a3;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v387, v388, v389, (uint64_t)v67);
        uint64_t v395 = tee_param_alloc_sources(v9, *(uint64_t *)&__dst[0]);
        if (v395)
        {
          uint64_t v14 = v395;
          free_tee_param((uint64_t)v9, *(uint64_t *)&__dst[0]);
          goto LABEL_9;
        }
        v570 = a5;
        unint64_t v571 = v53;
        if (*(_DWORD *)(*(void *)&__dst[0] + 68))
        {
          uint64_t v399 = 0;
          unint64_t v400 = 0;
          while (1)
          {
            *a3 = 4;
            uint64_t v401 = *a4;
            uint64_t v402 = a2;
            unsigned int v403 = *(_DWORD *)(a2 + v401);
            *a4 = v401 + 4;
            log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v396, v397, v398, (uint64_t)v67);
            *a3 = v403;
            uint64_t v404 = *a4;
            v573 = (char *)(v402 + v404);
            *a4 = v404 + v403;
            log_OutText(*v575, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v405, v406, v407, (uint64_t)v67);
            *a3 = 4;
            *(_DWORD *)(*(void *)(*(void *)&__dst[0] + 72) + v399 + 8) = *(_DWORD *)(v402 + *a4);
            *a4 += *a3;
            log_OutText(*v575, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v408, v409, v410, (uint64_t)v67);
            *a3 = 4;
            *(_DWORD *)(*(void *)(*(void *)&__dst[0] + 72) + v399 + 12) = *(_DWORD *)(v402 + *a4);
            *a4 += *a3;
            log_OutText(*v575, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v411, v412, v413, (uint64_t)v67);
            *a3 = 4;
            uint64_t v414 = *a4;
            int v415 = *(_DWORD *)(v402 + v414);
            *a4 = v414 + 4;
            int v9 = v575;
            log_OutText(*v575, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v416, v417, v418, (uint64_t)v67);
            uint64_t v419 = *(void *)(*(void *)&__dst[0] + 72) + v399;
            *(_DWORD *)(v419 + 16) = v415;
            uint64_t source_layer = tee_source_cfg_get_source_layer(v575, (void *)v419, v573, v581[14], v571, v420, v421, v422);
            if (source_layer) {
              break;
            }
            ++v400;
            v399 += 24;
            a2 = v402;
            if (v400 >= *(unsigned int *)(*(void *)&__dst[0] + 68)) {
              goto LABEL_96;
            }
          }
          uint64_t v14 = source_layer;
          free_tee_param((uint64_t)v575, *(uint64_t *)&__dst[0]);
          goto LABEL_180;
        }
LABEL_96:
        uint64_t tee_layer_take_param_ownership = create_tee_layer_take_param_ownership(v9, (uint64_t *)__dst, (uint64_t *)&v580);
        if (tee_layer_take_param_ownership)
        {
          uint64_t v14 = tee_layer_take_param_ownership;
          free_tee_param((uint64_t)v9, *(uint64_t *)&__dst[0]);
          uint64_t v15 = *v9;
          uint64_t v16 = "create tee layer failed!";
          goto LABEL_8;
        }
        unint64_t v53 = v571;
        goto LABEL_24;
      case 0x1Bu:
        *a3 = 64;
        uint64_t v425 = *a4;
        long long v426 = *(_OWORD *)(a2 + v425 + 16);
        __dst[0] = *(_OWORD *)(a2 + v425);
        __dst[1] = v426;
        long long v427 = *(_OWORD *)(a2 + v425 + 48);
        __dst[2] = *(_OWORD *)(a2 + v425 + 32);
        __dst[3] = v427;
        *a4 = v425 + 64;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t wavernn_layer = create_wavernn_layer(v9, __dst, (uint64_t)(v581 + 1), (uint64_t)(v581 + 24), (uint64_t *)&v580);
        if (!wavernn_layer) {
          goto LABEL_24;
        }
        uint64_t v14 = wavernn_layer;
        uint64_t v15 = *v9;
        uint64_t v16 = "create wavernn layer failed!";
        goto LABEL_8;
      case 0x1Cu:
        *(void *)&__dst[0] = 0;
        *a3 = 4;
        uint64_t v429 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v429);
        *a4 = v429 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        uint64_t v430 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v430);
        *a4 = v430 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v431, v432, v433, (uint64_t)v67);
        uint64_t sampling_layer = create_sampling_layer(v9, __dst, (uint64_t)(v581 + 24), (uint64_t *)&v580);
        if (!sampling_layer) {
          goto LABEL_24;
        }
        uint64_t v14 = sampling_layer;
        uint64_t v15 = *v9;
        uint64_t v16 = "create sampling layer failed!";
        goto LABEL_8;
      case 0x1Fu:
        v435 = a5;
        *a3 = 4;
        uint64_t v436 = *a4;
        unsigned int v574 = *(_DWORD *)(a2 + v436);
        __dst[0] = 0uLL;
        *a4 = v436 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        uint64_t v437 = *a4;
        unsigned int v438 = *(_DWORD *)(a2 + v437);
        *a4 = v437 + 4;
        log_OutText(*v575, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v439, v440, v441, (uint64_t)v67);
        *a3 = v438;
        uint64_t v442 = *a4;
        unint64_t v443 = v53;
        uint64_t v444 = a2 + v442;
        *a4 = v442 + v438;
        int v9 = v575;
        log_OutText(*v575, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v445, v446, v447, (uint64_t)v67);
        uint64_t v448 = v444;
        unint64_t v53 = v443;
        uint64_t v449 = config_merge_layer_param(v575, (uint64_t)__dst, v574, v448, v581[14], v443);
        if (!v449)
        {
          uint64_t v450 = create_merge_layer(v575, __dst, &v580);
          a5 = v435;
          if (v450)
          {
            uint64_t v14 = v450;
            uint64_t v15 = *v575;
            uint64_t v16 = "create merge layer failed!";
            goto LABEL_8;
          }
LABEL_24:
          if (fi_layer_if_has_weights(v578) == 1)
          {
            LOBYTE(__dst[0]) = 0;
            uint64_t bytesOfElem = get_bytesOfElem(*((_DWORD *)v581 + 12), __dst);
            if (bytesOfElem)
            {
              uint64_t v14 = bytesOfElem;
              uint64_t v15 = *v9;
              uint64_t v16 = "get bytes of elem failed!";
              goto LABEL_8;
            }
            *a3 = 4;
            *((_DWORD *)v580 + 20) = *(_DWORD *)(a2 + *a4);
            *a4 += *a3;
            log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v11, v12, v13, (uint64_t)v67);
            *a3 = 4;
            *((_DWORD *)v580 + 24) = *(_DWORD *)(a2 + *a4);
            *a4 += *a3;
            log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v133, v134, v135, (uint64_t)v67);
            *a3 = 4;
            *((_DWORD *)v580 + 28) = *(_DWORD *)(a2 + *a4);
            *a4 += *a3;
            log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v136, v137, v138, (uint64_t)v67);
            uint64_t v139 = *a4;
            *a4 += 32 - (*a4 & 0x1F);
            log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"Skip PADDING Bytes [start, len, end]:  %d,  %d, %d", v140, v141, v142, v139);
            uint64_t v143 = v580;
            unsigned int v144 = *((_DWORD *)v580 + 20) / LOBYTE(__dst[0]) * LOBYTE(__dst[0]);
            *a3 = v144;
            uint64_t v145 = *a4;
            v143[9] = (uint64_t *)(a2 + v145);
            *a4 = v145 + v144;
            log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v146, v147, v148, (uint64_t)v67);
            log_OutText(*v9, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Layer:%s, weights bytes: %d, biases bytes: %d, total bytes: %d", v149, v150, v151, (uint64_t)v67);
            float v152 = v580;
            float v153 = v580[9];
            v580[13] = (uint64_t *)((char *)v153 + *((unsigned int *)v580 + 24));
            v152[11] = v153;
          }
          else
          {
            log_OutText(*v9, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Layer %s does not have weights and biases, skipped.", v129, v130, v131, (uint64_t)v67);
            float v152 = v580;
          }
          v581[14][v53++] = (uint64_t)v152;
          if (v53 >= *((unsigned int *)v581 + 2)) {
            goto LABEL_175;
          }
          continue;
        }
        uint64_t v14 = v449;
        a5 = v435;
LABEL_9:
        uint64_t v51 = v581;
        *a5 = v581;
        fi_net_destroy((uint64_t)v51);
        return v14;
      case 0x20u:
        *a3 = 4;
        uint64_t v451 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v451);
        *a4 = v451 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t mulaw_layer = create_mulaw_layer(v9, __dst, (uint64_t *)&v580);
        if (!mulaw_layer) {
          goto LABEL_24;
        }
        uint64_t v14 = mulaw_layer;
        uint64_t v15 = *v9;
        uint64_t v16 = "create mulaw layer failed!";
        goto LABEL_8;
      case 0x21u:
        *a3 = 20;
        uint64_t v453 = *a4;
        __dst[0] = *(_OWORD *)(a2 + v453);
        LODWORD(__dst[1]) = *(_DWORD *)(a2 + v453 + 16);
        *a4 = v453 + 20;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t v454 = create_ffn_layer(v9, __dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!v454) {
          goto LABEL_24;
        }
        uint64_t v14 = v454;
        uint64_t v15 = *v9;
        uint64_t v16 = "create ffn layer failed!";
        goto LABEL_8;
      case 0x22u:
        *a3 = 64;
        uint64_t v455 = *a4;
        long long v456 = *(_OWORD *)(a2 + v455 + 16);
        __dst[0] = *(_OWORD *)(a2 + v455);
        __dst[1] = v456;
        long long v457 = *(_OWORD *)(a2 + v455 + 48);
        __dst[2] = *(_OWORD *)(a2 + v455 + 32);
        __dst[3] = v457;
        *a4 = v455 + 64;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t v458 = create_att_layer(v9, (unsigned int *)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!v458) {
          goto LABEL_24;
        }
        uint64_t v14 = v458;
        uint64_t v15 = *v9;
        uint64_t v16 = "create att layer failed!";
        goto LABEL_8;
      case 0x23u:
        *a3 = 44;
        uint64_t v459 = *a4;
        long long v460 = *(_OWORD *)(a2 + v459 + 16);
        __dst[0] = *(_OWORD *)(a2 + v459);
        __dst[1] = v460;
        *(long long *)((char *)&__dst[1] + 12) = *(_OWORD *)(a2 + v459 + 28);
        *a4 = v459 + 44;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t v461 = create_trans_enc_layer(v9, __dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!v461) {
          goto LABEL_24;
        }
        uint64_t v14 = v461;
        uint64_t v15 = *v9;
        uint64_t v16 = "create trans_enc layer failed!";
        goto LABEL_8;
      case 0x24u:
        *a3 = 48;
        uint64_t v462 = *a4;
        long long v463 = *(_OWORD *)(a2 + v462 + 16);
        __dst[0] = *(_OWORD *)(a2 + v462);
        __dst[1] = v463;
        __dst[2] = *(_OWORD *)(a2 + v462 + 32);
        *a4 = v462 + 48;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t v464 = create_trans_encoder(v9, (unsigned int *)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!v464) {
          goto LABEL_24;
        }
        uint64_t v14 = v464;
        uint64_t v15 = *v9;
        uint64_t v16 = "create trans_encoder failed!";
        goto LABEL_8;
      case 0x25u:
        *a3 = 52;
        uint64_t v465 = *a4;
        long long v466 = *(_OWORD *)(a2 + v465 + 16);
        __dst[0] = *(_OWORD *)(a2 + v465);
        __dst[1] = v466;
        __dst[2] = *(_OWORD *)(a2 + v465 + 32);
        LODWORD(__dst[3]) = *(_DWORD *)(a2 + v465 + 48);
        *a4 = v465 + 52;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t v467 = create_trans_dec_layer(v9, __dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!v467) {
          goto LABEL_24;
        }
        uint64_t v14 = v467;
        uint64_t v15 = *v9;
        uint64_t v16 = "create trans_dec layer failed!";
        goto LABEL_8;
      case 0x26u:
        *a3 = 56;
        uint64_t v468 = *a4;
        long long v469 = *(_OWORD *)(a2 + v468 + 16);
        __dst[0] = *(_OWORD *)(a2 + v468);
        __dst[1] = v469;
        __dst[2] = *(_OWORD *)(a2 + v468 + 32);
        *(void *)&__dst[3] = *(void *)(a2 + v468 + 48);
        *a4 = v468 + 56;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t v470 = create_trans_decoder(v9, (unsigned int *)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!v470) {
          goto LABEL_24;
        }
        uint64_t v14 = v470;
        uint64_t v15 = *v9;
        uint64_t v16 = "create trans_decoder failed!";
        goto LABEL_8;
      case 0x27u:
        *a3 = 8;
        uint64_t v471 = *a4;
        *(void *)&__dst[0] = *(void *)(a2 + v471);
        *a4 = v471 + 8;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t v472 = create_embedding_layer(v9, (uint64_t *)__dst, &v580);
        if (!v472) {
          goto LABEL_24;
        }
        uint64_t v14 = v472;
        uint64_t v15 = *v9;
        uint64_t v16 = "create embedding layer failed!";
        goto LABEL_8;
      case 0x29u:
        *a3 = 72;
        uint64_t v473 = *a4;
        long long v474 = *(_OWORD *)(a2 + v473 + 48);
        __dst[2] = *(_OWORD *)(a2 + v473 + 32);
        __dst[3] = v474;
        *(void *)&__dst[4] = *(void *)(a2 + v473 + 64);
        long long v475 = *(_OWORD *)(a2 + v473 + 16);
        __dst[0] = *(_OWORD *)(a2 + v473);
        __dst[1] = v475;
        *a4 = v473 + 72;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t v476 = create_att_albert_layer(v9, (unsigned int *)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!v476) {
          goto LABEL_24;
        }
        uint64_t v14 = v476;
        uint64_t v15 = *v9;
        uint64_t v16 = "create att albert layer failed!";
        goto LABEL_8;
      case 0x2Au:
        *a3 = 48;
        uint64_t v477 = *a4;
        long long v478 = *(_OWORD *)(a2 + v477 + 16);
        __dst[0] = *(_OWORD *)(a2 + v477);
        __dst[1] = v478;
        __dst[2] = *(_OWORD *)(a2 + v477 + 32);
        *a4 = v477 + 48;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t v479 = create_albert_trans_enc_layer(v9, (uint64_t)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!v479) {
          goto LABEL_24;
        }
        uint64_t v14 = v479;
        uint64_t v15 = *v9;
        uint64_t v16 = "create albert trans_enc layer failed!";
        goto LABEL_8;
      case 0x2Bu:
        *a3 = 96;
        uint64_t v480 = *a4;
        long long v481 = *(_OWORD *)(a2 + v480 + 48);
        __dst[2] = *(_OWORD *)(a2 + v480 + 32);
        __dst[3] = v481;
        long long v482 = *(_OWORD *)(a2 + v480 + 80);
        __dst[4] = *(_OWORD *)(a2 + v480 + 64);
        __dst[5] = v482;
        long long v483 = *(_OWORD *)(a2 + v480 + 16);
        __dst[0] = *(_OWORD *)(a2 + v480);
        __dst[1] = v483;
        *a4 = v480 + 96;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t v484 = create_albert_trans_encoder(v9, (unsigned int *)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!v484) {
          goto LABEL_24;
        }
        uint64_t v14 = v484;
        uint64_t v15 = *v9;
        uint64_t v16 = "create albert trans_encoder failed!";
        goto LABEL_8;
      case 0x32u:
        *a3 = 36;
        uint64_t v485 = *a4;
        long long v486 = *(_OWORD *)(a2 + v485 + 16);
        __dst[0] = *(_OWORD *)(a2 + v485);
        __dst[1] = v486;
        LODWORD(__dst[2]) = *(_DWORD *)(a2 + v485 + 32);
        *a4 = v485 + 36;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t tee_param = create_conv1d_norm_layer(v9, (uint64_t)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (tee_param) {
          goto LABEL_177;
        }
        goto LABEL_24;
      case 0x33u:
        *a3 = 8;
        uint64_t v487 = *a4;
        *(void *)&__dst[0] = *(void *)(a2 + v487);
        *a4 = v487 + 8;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t tee_param = create_conv1d_bank(v9, (uint64_t *)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (tee_param) {
          goto LABEL_177;
        }
        goto LABEL_24;
      case 0x34u:
        *a3 = 16;
        uint64_t v488 = *a4;
        __dst[0] = *(_OWORD *)(a2 + v488);
        *a4 = v488 + 16;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t tee_param = create_conv1d_proj_layer(v9, (unsigned int *)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (tee_param) {
          goto LABEL_177;
        }
        goto LABEL_24;
      case 0x35u:
        *a3 = 8;
        uint64_t v489 = *a4;
        *(void *)&__dst[0] = *(void *)(a2 + v489);
        *a4 = v489 + 8;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t tee_param = create_highway_layer(v9, (uint64_t *)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (tee_param) {
          goto LABEL_177;
        }
        goto LABEL_24;
      case 0x36u:
        *a3 = 12;
        uint64_t v490 = *a4;
        *(void *)&__dst[0] = *(void *)(a2 + v490);
        DWORD2(__dst[0]) = *(_DWORD *)(a2 + v490 + 8);
        *a4 = v490 + 12;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t tee_param = create_highways(v9, (unsigned int *)__dst, &v577, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (tee_param) {
          goto LABEL_177;
        }
        goto LABEL_24;
      case 0x37u:
        *a3 = 36;
        uint64_t v491 = *a4;
        long long v492 = *(_OWORD *)(a2 + v491 + 16);
        __dst[0] = *(_OWORD *)(a2 + v491);
        __dst[1] = v492;
        LODWORD(__dst[2]) = *(_DWORD *)(a2 + v491 + 32);
        *a4 = v491 + 36;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t tee_param = create_cbhg_layer(v9, (uint64_t)__dst, &v577, (uint64_t)(v581 + 1), &v580);
        if (tee_param) {
          goto LABEL_177;
        }
        goto LABEL_24;
      case 0x38u:
        *a3 = 24;
        uint64_t v493 = *a4;
        __dst[0] = *(_OWORD *)(a2 + v493);
        *(void *)&__dst[1] = *(void *)(a2 + v493 + 16);
        *a4 = v493 + 24;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t gl_layer = create_gl_layer(v9, (uint64_t *)&v578, __dst, (uint64_t *)&v580);
        if (!gl_layer) {
          goto LABEL_24;
        }
        uint64_t v14 = gl_layer;
        uint64_t v15 = *v9;
        uint64_t v16 = "create gl layer failed!";
        goto LABEL_8;
      case 0x3Eu:
        *a3 = 88;
        uint64_t v495 = *a4;
        long long v496 = *(_OWORD *)(a2 + v495 + 48);
        __dst[2] = *(_OWORD *)(a2 + v495 + 32);
        __dst[3] = v496;
        __dst[4] = *(_OWORD *)(a2 + v495 + 64);
        *(void *)&__dst[5] = *(void *)(a2 + v495 + 80);
        long long v497 = *(_OWORD *)(a2 + v495 + 16);
        __dst[0] = *(_OWORD *)(a2 + v495);
        __dst[1] = v497;
        *a4 = v495 + 88;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t tee_param = create_tacodecoder_layer(v9, (uint64_t)__dst, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (tee_param) {
          goto LABEL_177;
        }
        goto LABEL_24;
      case 0x3Fu:
      case 0x42u:
        *a3 = 188;
        uint64_t v155 = *a4;
        long long v156 = *(_OWORD *)(a2 + v155 + 144);
        __dst[8] = *(_OWORD *)(a2 + v155 + 128);
        __dst[9] = v156;
        __dst[10] = *(_OWORD *)(a2 + v155 + 160);
        *(long long *)((char *)&__dst[10] + 12) = *(_OWORD *)(a2 + v155 + 172);
        long long v157 = *(_OWORD *)(a2 + v155 + 80);
        __dst[4] = *(_OWORD *)(a2 + v155 + 64);
        __dst[5] = v157;
        long long v158 = *(_OWORD *)(a2 + v155 + 112);
        __dst[6] = *(_OWORD *)(a2 + v155 + 96);
        __dst[7] = v158;
        long long v159 = *(_OWORD *)(a2 + v155 + 16);
        __dst[0] = *(_OWORD *)(a2 + v155);
        __dst[1] = v159;
        long long v160 = *(_OWORD *)(a2 + v155 + 48);
        __dst[2] = *(_OWORD *)(a2 + v155 + 32);
        __dst[3] = v160;
        *a4 = v155 + 188;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t tee_param = create_tacotron(v9, __dst, &v577, (uint64_t)(v581 + 1), v578, (uint64_t *)&v580);
        if (tee_param) {
          goto LABEL_177;
        }
        goto LABEL_24;
      case 0x40u:
        *a3 = 8;
        uint64_t v498 = *a4;
        *(void *)&__dst[0] = *(void *)(a2 + v498);
        *a4 = v498 + 8;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t invpreemph_layer = create_invpreemph_layer(v9, (uint64_t *)&v578, __dst, (uint64_t *)&v580);
        if (!invpreemph_layer) {
          goto LABEL_24;
        }
        uint64_t v14 = invpreemph_layer;
        uint64_t v15 = *v9;
        uint64_t v16 = "create invpreemph layer failed!";
        goto LABEL_8;
      case 0x41u:
        *a3 = 180;
        uint64_t v500 = *a4;
        long long v501 = *(_OWORD *)(a2 + v500 + 144);
        __dst[8] = *(_OWORD *)(a2 + v500 + 128);
        __dst[9] = v501;
        __dst[10] = *(_OWORD *)(a2 + v500 + 160);
        LODWORD(__dst[11]) = *(_DWORD *)(a2 + v500 + 176);
        long long v502 = *(_OWORD *)(a2 + v500 + 80);
        __dst[4] = *(_OWORD *)(a2 + v500 + 64);
        __dst[5] = v502;
        long long v503 = *(_OWORD *)(a2 + v500 + 112);
        __dst[6] = *(_OWORD *)(a2 + v500 + 96);
        __dst[7] = v503;
        long long v504 = *(_OWORD *)(a2 + v500 + 16);
        __dst[0] = *(_OWORD *)(a2 + v500);
        __dst[1] = v504;
        long long v505 = *(_OWORD *)(a2 + v500 + 48);
        __dst[2] = *(_OWORD *)(a2 + v500 + 32);
        __dst[3] = v505;
        *a4 = v500 + 180;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t tee_param = create_lpcnet_layer(v9, __dst, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (tee_param) {
          goto LABEL_177;
        }
        goto LABEL_24;
      case 0x43u:
        *a3 = 244;
        uint64_t v506 = *a4;
        long long v507 = *(_OWORD *)(a2 + v506 + 208);
        char __dst[12] = *(_OWORD *)(a2 + v506 + 192);
        __dst[13] = v507;
        __dst[14] = *(_OWORD *)(a2 + v506 + 224);
        LODWORD(__dst[15]) = *(_DWORD *)(a2 + v506 + 240);
        long long v508 = *(_OWORD *)(a2 + v506 + 144);
        __dst[8] = *(_OWORD *)(a2 + v506 + 128);
        __dst[9] = v508;
        long long v509 = *(_OWORD *)(a2 + v506 + 176);
        __dst[10] = *(_OWORD *)(a2 + v506 + 160);
        __dst[11] = v509;
        long long v510 = *(_OWORD *)(a2 + v506 + 80);
        __dst[4] = *(_OWORD *)(a2 + v506 + 64);
        __dst[5] = v510;
        long long v511 = *(_OWORD *)(a2 + v506 + 112);
        __dst[6] = *(_OWORD *)(a2 + v506 + 96);
        __dst[7] = v511;
        long long v512 = *(_OWORD *)(a2 + v506 + 16);
        __dst[0] = *(_OWORD *)(a2 + v506);
        __dst[1] = v512;
        long long v513 = *(_OWORD *)(a2 + v506 + 48);
        __dst[2] = *(_OWORD *)(a2 + v506 + 32);
        __dst[3] = v513;
        *a4 = v506 + 244;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t tee_param = create_multiband_lpcnet_layer(v9, __dst, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (tee_param) {
          goto LABEL_177;
        }
        goto LABEL_24;
      case 0x44u:
        *a3 = 264;
        uint64_t v514 = *a4;
        memcpy(__dst, (const void *)(a2 + v514), 0x108uLL);
        *a4 = v514 + 264;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v515, v516, v517, (uint64_t)v67);
        uint64_t tee_param = create_tacotron_stream(v9, (int32x2_t *)__dst, &v577, (uint64_t)(v581 + 1), v578, (uint64_t *)&v580);
        if (tee_param) {
          goto LABEL_177;
        }
        goto LABEL_24;
      case 0x45u:
        *(long long *)((char *)__dst + 4) = 0u;
        *(long long *)((char *)&__dst[1] + 4) = 0u;
        *((void *)&__dst[0] + 1) = 0x100000001;
        *a3 = 4;
        uint64_t v518 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v518);
        *a4 = v518 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        uint64_t v519 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v519);
        *a4 = v519 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v520, v521, v522, (uint64_t)v67);
        *a3 = 4;
        uint64_t v523 = *a4;
        LODWORD(__dst[1]) = *(_DWORD *)(a2 + v523);
        *a4 = v523 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v524, v525, v526, (uint64_t)v67);
        *a3 = 4;
        uint64_t v527 = *a4;
        DWORD1(__dst[1]) = *(_DWORD *)(a2 + v527);
        *a4 = v527 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v528, v529, v530, (uint64_t)v67);
        *a3 = 4;
        uint64_t v531 = *a4;
        HIDWORD(__dst[1]) = *(_DWORD *)(a2 + v531);
        *a4 = v531 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v532, v533, v534, (uint64_t)v67);
        *a3 = 4;
        uint64_t v535 = *a4;
        LODWORD(__dst[2]) = *(_DWORD *)(a2 + v535);
        *a4 = v535 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v536, v537, v538, (uint64_t)v67);
        if (fi_feat_is_enabled((uint64_t)v581[4], 0, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          uint64_t v542 = *a4;
          DWORD2(__dst[0]) = *(_DWORD *)(a2 + v542);
          *a4 = v542 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v539, v540, v541, (uint64_t)v67);
          *a3 = 4;
          uint64_t v543 = *a4;
          HIDWORD(__dst[0]) = *(_DWORD *)(a2 + v543);
          *a4 = v543 + 4;
          log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v544, v545, v546, (uint64_t)v67);
        }
        if (fi_feat_is_enabled((uint64_t)v581[4], 1u, *((_DWORD *)v581 + 6)))
        {
          *a3 = 4;
          uint64_t v550 = *a4;
          DWORD2(__dst[1]) = *(_DWORD *)(a2 + v550);
          *a4 = v550 + 4;
          int v9 = v575;
          log_OutText(*v575, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v547, v548, v549, (uint64_t)v67);
        }
        else
        {
          DWORD2(__dst[1]) = 1;
          int v9 = v575;
        }
        uint64_t convtrans1d_layer = create_convtrans1d_layer(v9, __dst, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (!convtrans1d_layer) {
          goto LABEL_24;
        }
        uint64_t v14 = convtrans1d_layer;
        uint64_t v15 = *v9;
        uint64_t v16 = "create convtrans1d layer failed!";
        goto LABEL_8;
      case 0x46u:
        *a3 = 120;
        uint64_t v551 = *a4;
        long long v552 = *(_OWORD *)(a2 + v551 + 80);
        __dst[4] = *(_OWORD *)(a2 + v551 + 64);
        __dst[5] = v552;
        __dst[6] = *(_OWORD *)(a2 + v551 + 96);
        *(void *)&__dst[7] = *(void *)(a2 + v551 + 112);
        long long v553 = *(_OWORD *)(a2 + v551 + 16);
        __dst[0] = *(_OWORD *)(a2 + v551);
        __dst[1] = v553;
        long long v554 = *(_OWORD *)(a2 + v551 + 48);
        __dst[2] = *(_OWORD *)(a2 + v551 + 32);
        __dst[3] = v554;
        *a4 = v551 + 120;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t tee_param = create_mrf_layer(v9, (unsigned int *)__dst, (uint64_t)(v581 + 1), (uint64_t *)&v580);
        if (tee_param) {
          goto LABEL_177;
        }
        goto LABEL_24;
      case 0x47u:
        *(void *)&__dst[0] = 0;
        *a3 = 4;
        uint64_t v555 = *a4;
        LODWORD(__dst[0]) = *(_DWORD *)(a2 + v555);
        *a4 = v555 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        *a3 = 4;
        uint64_t v556 = *a4;
        DWORD1(__dst[0]) = *(_DWORD *)(a2 + v556);
        *a4 = v556 + 4;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v557, v558, v559, (uint64_t)v67);
        uint64_t tee_param = create_pqmf_layer(v9, __dst, &v580);
        if (!tee_param) {
          goto LABEL_24;
        }
LABEL_177:
        uint64_t v14 = tee_param;
        goto LABEL_9;
      case 0x48u:
        *a3 = 44;
        uint64_t v560 = *a4;
        long long v561 = *(_OWORD *)(a2 + v560 + 16);
        __dst[0] = *(_OWORD *)(a2 + v560);
        __dst[1] = v561;
        *(long long *)((char *)&__dst[1] + 12) = *(_OWORD *)(a2 + v560 + 28);
        *a4 = v560 + 44;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t v562 = create_reshape_layer(v9, __dst, &v580);
        if (!v562) {
          goto LABEL_24;
        }
        uint64_t v14 = v562;
        uint64_t v15 = *v9;
        uint64_t v16 = "create reshape layer failed!";
        goto LABEL_8;
      case 0x49u:
        *a3 = 32;
        uint64_t v563 = *a4;
        long long v564 = *(_OWORD *)(a2 + v563 + 16);
        __dst[0] = *(_OWORD *)(a2 + v563);
        __dst[1] = v564;
        *a4 = v563 + 32;
        log_OutText(*v9, (uint64_t)"FastInfer", 3, 0, (uint64_t)"layer: %s, Read: %s, Bytes [start, len, end]:  %d,  %d, %d", v64, v65, v66, (uint64_t)v67);
        uint64_t v565 = create_upsample_layer(v9, __dst, &v580);
        if (!v565) {
          goto LABEL_24;
        }
        uint64_t v14 = v565;
        uint64_t v15 = *v9;
        uint64_t v16 = "create upsample layer failed!";
        goto LABEL_8;
      default:
        log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"error: unknown layer type %s!", v64, v65, v66, (uint64_t)v67);
        uint64_t v14 = 7;
        goto LABEL_9;
    }
  }
}

uint64_t parse_fi_binary_model(uint64_t *a1, uint64_t a2, void *a3)
{
  unsigned int v5 = 0;
  int v4 = 0;
  return parse_fi_binary_model_inner(a1, a2, &v5, &v4, a3);
}

uint64_t create_pooling_layer(uint64_t *a1, int a2, long long *a3, uint64_t **a4, uint64_t ***a5)
{
  uint64_t v15 = 0;
  uint64_t v11 = create_conv_layer(a1, a3, a4, &v15);
  if (v11)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"create pooling layer failed when call create_conv_layer()!", v8, v9, v10, v14);
    uint64_t v12 = v15;
  }
  else
  {
    uint64_t v12 = v15;
    *((_DWORD *)v15 + 2) = a2;
    *((_DWORD *)v12 + 3) = 0;
    v12[16] = (uint64_t *)forward_pooling_layer;
    v12[17] = (uint64_t *)free_pooling_buffer;
  }
  *a5 = v12;
  return v11;
}

uint64_t create_conv_layer(uint64_t *a1, long long *a2, uint64_t **a3, uint64_t ***a4)
{
  uint64_t v11 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v11 && (uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 64)) != 0)
  {
    uint64_t v13 = v12;
    v11[15] = (uint64_t *)v12;
    *uint64_t v11 = a1;
    if (a3) {
      *(uint64_t **)((char *)v11 + 60) = *a3;
    }
    uint64_t result = 0;
    long long v15 = *a2;
    long long v16 = a2[1];
    *(_DWORD *)(v13 + 32) = *((_DWORD *)a2 + 8);
    *(_OWORD *)uint64_t v13 = v15;
    *(_OWORD *)(v13 + 16) = v16;
    v11[20] = (uint64_t *)conv_layer_request_glbBuf;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v17);
    free_conv_buffer(v11);
    uint64_t result = 10;
  }
  *a4 = v11;
  return result;
}

uint64_t forward_pooling_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *(int **)(a2 + 120);
  uint64_t v64 = 0;
  int v63 = 0;
  int v9 = v8[1];
  int v57 = *v8;
  int v11 = v8[14];
  int v10 = v8[15];
  uint64_t v12 = *(char **)(a2 + 240);
  bzero(v12, *(unsigned int *)(a2 + 248));
  uint64_t conv_chw = fi_shape_get_conv_chw((_DWORD *)(a2 + 20), (_DWORD *)&v64 + 1, &v64, &v63);
  if (conv_chw)
  {
    uint64_t v17 = conv_chw;
    uint64_t v18 = **(void **)a2;
    int v19 = "fi_shape_get_conv_chw error!";
LABEL_5:
    log_OutText(v18, (uint64_t)"FastInfer", 0, 0, (uint64_t)v19, v14, v15, v16, v53);
    return v17;
  }
  int v59 = v11;
  int v61 = v10;
  int v55 = v9;
  unsigned int v20 = HIDWORD(v64);
  uint64_t v21 = im2row_2d_or_1d(*(_DWORD *)(a2 + 20), a3, SHIDWORD(v64), v64, v63, (uint64_t)v8, (uint64_t)v12);
  if (v21)
  {
    uint64_t v17 = v21;
    uint64_t v18 = **(void **)a2;
    int v19 = "im2row_2d_or_1d_failed!";
    goto LABEL_5;
  }
  if (!v20) {
    return 0;
  }
  int v23 = 0;
  uint64_t v24 = (v9 * v57);
  uint64_t v25 = (v59 * v61);
  if (v24) {
    BOOL v26 = v12 == 0;
  }
  else {
    BOOL v26 = 1;
  }
  char v27 = v26;
  char v62 = v27;
  int v54 = v25 * v55 * v57;
  unsigned int v28 = 0;
  while (!v25)
  {
LABEL_50:
    uint64_t v17 = 0;
    ++v28;
    v23 += v54;
    if (v28 >= v20) {
      return v17;
    }
  }
  uint64_t v29 = 0;
  unsigned int v56 = v28;
  int v30 = v28 * v25;
  int v58 = v23;
  while (2)
  {
    uint64_t v31 = a4;
    if (!a5
      || (uint64_t v31 = a4, *(_DWORD *)(a5 + 16))
      || (is_same = fi_shape_is_same((unsigned int *)(a2 + 20), (_DWORD *)(a2 + 40)), uint64_t v31 = a3, is_same))
    {
      uint64_t v33 = (float *)&v12[4 * v23];
      int v34 = (float *)&v12[4 * v23 + 4];
      uint64_t v35 = (v30 + v29);
      uint64_t v36 = (v35 * v24);
      switch(*(_DWORD *)(a2 + 8))
      {
        case 8:
        case 0xC:
        case 0xE:
        case 0x12:
          if (!v24) {
            goto LABEL_35;
          }
          unsigned int v37 = 0;
          float v38 = 0.0;
          uint64_t v39 = v24;
          do
          {
            float v40 = *v33++;
            float v38 = v38 + v40;
            if (v40 != 0.0) {
              ++v37;
            }
            --v39;
          }
          while (v39);
          if (v37) {
            float v41 = v38 / (float)v37;
          }
          else {
LABEL_35:
          }
            float v41 = 0.0;
          goto LABEL_40;
        case 9:
        case 0xF:
          float v41 = 0.0;
          if (v24)
          {
            uint64_t v46 = v24;
            do
            {
              float v47 = *v33++;
              float v41 = v41 + v47;
              --v46;
            }
            while (v46);
            float v41 = v41 / (float)v24;
          }
LABEL_40:
          *(float *)(v31 + 4 * v35) = v41;
          goto LABEL_48;
        case 0xA:
        case 0xD:
        case 0x10:
        case 0x13:
          float v42 = 0.0;
          if ((v62 & 1) == 0)
          {
            float v42 = *(float *)&v12[4 * v36];
            if (v24 >= 2)
            {
              uint64_t v43 = v24 - 1;
              do
              {
                float v44 = *v34++;
                float v45 = v44;
                if (v44 >= v42) {
                  float v42 = v45;
                }
                --v43;
              }
              while (v43);
            }
          }
          goto LABEL_47;
        case 0x11:
          float v42 = 0.0;
          if ((v62 & 1) == 0)
          {
            float v42 = *(float *)&v12[4 * v36];
            if (v24 >= 2)
            {
              uint64_t v48 = v24 - 1;
              do
              {
                float v49 = *v34++;
                float v50 = v49;
                if (v49 <= v42) {
                  float v42 = v50;
                }
                --v48;
              }
              while (v48);
            }
          }
LABEL_47:
          *(float *)(v31 + 4 * v35) = v42;
LABEL_48:
          ++v29;
          v23 += v24;
          if (v29 != v25) {
            continue;
          }
          unsigned int v20 = HIDWORD(v64);
          int v23 = v58;
          unsigned int v28 = v56;
          break;
        default:
          uint64_t v51 = **(void **)a2;
          uint64_t v52 = "Unsupported POOLING Layer - %d";
          uint64_t v53 = *(unsigned int *)(a2 + 8);
          goto LABEL_55;
      }
      goto LABEL_50;
    }
    break;
  }
  uint64_t v51 = **(void **)a2;
  uint64_t v52 = "pool: want to swap in/out but shape mismatch!";
LABEL_55:
  log_OutText(v51, (uint64_t)"FastInfer", 0, 0, (uint64_t)v52, v14, v15, v16, v53);
  return 7;
}

uint64_t conv_layer_wanted_wb_len(uint64_t a1, int *a2, _DWORD *a3)
{
  int v6 = *(int **)(a1 + 120);
  uint64_t v26 = 0;
  HIDWORD(v25) = 0;
  BOOL is_enabled = fi_feat_is_enabled(*(void *)(a1 + 256), 7u, *(_DWORD *)(a1 + 264));
  if (is_enabled && (uint64_t v8 = *(void *)(a1 + 72)) != 0) {
    int v9 = (*(unsigned __int8 *)(v8 + 4) >> 3) & 1;
  }
  else {
    int v9 = 0;
  }
  if (fi_feat_is_enabled(*(void *)(a1 + 256), 8u, *(_DWORD *)(a1 + 264)) && (uint64_t v10 = *(void *)(a1 + 72)) != 0) {
    int v11 = (*(_DWORD *)(v10 + 4) >> 5) & 1;
  }
  else {
    int v11 = 0;
  }
  uint64_t conv_chw = fi_shape_get_conv_chw((_DWORD *)(a1 + 20), (_DWORD *)&v26 + 1, &v26, (_DWORD *)&v25 + 1);
  if (conv_chw)
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"fi_shape_get_conv_chw error!", v12, v13, v14, v25);
  }
  else
  {
    if (get_conv1d_impl(v6, (_DWORD *)(a1 + 20), v11) == 4)
    {
      if (v9) {
        unsigned int v16 = 32;
      }
      else {
        unsigned int v16 = 8;
      }
      int padded_len = get_padded_len((v6[4] * v6[1]), v16);
      uint64_t v18 = v6;
    }
    else
    {
      if (v9) {
        unsigned int v19 = 32;
      }
      else {
        unsigned int v19 = 8;
      }
      int padded_len = get_padded_len((*v6 * HIDWORD(v26) * v6[1]), v19);
      uint64_t v18 = v6 + 4;
    }
    int v20 = *v18;
    if (v9) {
      char v21 = 0;
    }
    else {
      char v21 = 2;
    }
    int v22 = (padded_len << v21) * v20;
    *a2 = v22;
    if (is_enabled)
    {
      int v23 = *(_DWORD **)(a1 + 72);
      if (v23) {
        LODWORD(v23) = 4 * *v23;
      }
      *a2 = v23 + v22;
    }
    if (v6[6] == 1) {
      *a3 = 4 * v6[4];
    }
    else {
      *a3 = 0;
    }
  }
  return conv_chw;
}

uint64_t get_conv1d_impl(_DWORD *a1, _DWORD *a2, int a3)
{
  if (*a2 != 2 || a1[5] != 1 || a1[3] != 1 || a1[12] || a1[13] || a1[9] != 1) {
    return 1;
  }
  if (a3 || a1[2] != 1)
  {
    if (a3 == 1)
    {
      unsigned int v8 = a1[1];
      if (v8 == get_padded_len(v8, 8u))
      {
        int v9 = a2 + 2;
        unsigned int v10 = 4;
        goto LABEL_17;
      }
    }
    return 1;
  }
  unsigned int v5 = a1[1];
  if (v5 == get_padded_len(v5, 8u))
  {
    unsigned int v6 = a2[2];
    if (v6 == get_padded_len(v6, 8u)) {
      return 2;
    }
  }
  if ((a2[2] & 3) != 2) {
    return 1;
  }
  int v9 = a1 + 4;
  unsigned int v10 = 3;
LABEL_17:
  int v11 = *v9;
  if (v11 == get_padded_len(*v9, 8u)) {
    return v10;
  }
  else {
    return 1;
  }
}

uint64_t conv_layer_request_glbBuf(uint64_t a1)
{
  char v2 = *(_DWORD **)(a1 + 120);
  uint64_t v14 = 0;
  HIDWORD(v13) = 0;
  if (fi_feat_is_enabled(*(void *)(a1 + 256), 8u, *(_DWORD *)(a1 + 264)) && (uint64_t v3 = *(void *)(a1 + 72)) != 0) {
    int v4 = (*(_DWORD *)(v3 + 4) >> 5) & 1;
  }
  else {
    int v4 = 0;
  }
  uint64_t conv_chw = fi_shape_get_conv_chw((_DWORD *)(a1 + 20), (_DWORD *)&v14 + 1, &v14, (_DWORD *)&v13 + 1);
  if (conv_chw)
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"fi_shape_get_conv_chw error!", v5, v6, v7, v13);
  }
  else
  {
    int conv1d_impl = get_conv1d_impl(v2, (_DWORD *)(a1 + 20), v4);
    if (conv1d_impl == 3)
    {
      int v11 = 8 * get_padded_len(((*v2 + v2[14] * v2[15] - 1) * v2[1]), 8u);
    }
    else
    {
      if (conv1d_impl == 2) {
        int v10 = v2[1] * (*v2 + v2[14] * v2[15] - 1);
      }
      else {
        int v10 = get_padded_len((*v2 * HIDWORD(v14) * v2[1]), 8u) * v2[15] * v2[14];
      }
      int v11 = 4 * v10;
    }
    *(_DWORD *)(a1 + 248) = v11;
  }
  return conv_chw;
}

uint64_t config_pooling_layer(int a1, int a2, int a3, int a4, int a5, int a6, _DWORD *a7)
{
  *a7 = a1;
  a7[1] = a2;
  a7[2] = a3;
  a7[3] = a4;
  a7[4] = 1;
  a7[5] = a5;
  a7[6] = 0;
  a7[7] = a6;
  a7[8] = 0;
  return 0;
}

uint64_t config_conv_layer(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, _DWORD *a10)
{
  *a10 = a2;
  a10[1] = a3;
  a10[2] = a4;
  a10[3] = a5;
  a10[4] = a1;
  a10[5] = a6;
  a10[6] = a7;
  a10[7] = a8;
  a10[8] = a9;
  return 0;
}

void *free_conv_buffer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      if (result[15])
      {
        (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        v1[15] = 0;
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v3 = *(void *)(v2 + 16);
      int v4 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v4(v3, v1);
    }
  }
  return result;
}

uint64_t forward_conv_layer(uint64_t a1, uint64_t *a2, const void *a3, float32x4_t *a4)
{
  uint64_t v6 = a2;
  uint64_t v7 = *a2;
  *(void *)uint64_t v108 = 0;
  int v107 = 0;
  BOOL is_enabled = fi_feat_is_enabled(a2[32], 7u, *((_DWORD *)a2 + 66));
  if (fi_feat_is_enabled(v6[32], 8u, *((_DWORD *)v6 + 66)) && (uint64_t v9 = v6[9]) != 0) {
    int v10 = (*(unsigned __int8 *)(v9 + 4) >> 5) & 1;
  }
  else {
    int v10 = 0;
  }
  long long v105 = 0u;
  long long v106 = 0u;
  if (!a3) {
    return 7;
  }
  uint64_t v11 = v6[15];
  uint64_t v12 = (_DWORD *)v6 + 5;
  uint64_t conv_chw = fi_shape_get_conv_chw((_DWORD *)v6 + 5, &v108[1], v108, &v107);
  if (conv_chw)
  {
    uint64_t v17 = conv_chw;
    log_OutText(*(void *)*v6, (uint64_t)"FastInfer", 0, 0, (uint64_t)"fi_shape_get_conv_chw error!", v14, v15, v16, v79);
    return v17;
  }
  uint64_t v18 = (unsigned int *)v6[9];
  if (!v18) {
    return 7;
  }
  uint64_t v91 = v7;
  unsigned int v100 = *(_DWORD *)(v11 + 4) * *(_DWORD *)v11 * v108[1];
  int v19 = *(_DWORD *)(v11 + 56) * *(_DWORD *)(v11 + 60);
  int v20 = (char *)v18 + (v6[12] & 0xFFFFFFFC);
  uint64_t v93 = *(unsigned int *)(v11 + 16);
  if (is_enabled)
  {
    LODWORD(v106) = (v18[1] >> 3) & 1;
    DWORD1(v106) = ((v18[1] >> 4) & 1) == 0;
    unsigned int v21 = v18[1];
    LODWORD(v105) = v21 & 1;
    DWORD2(v105) = ((v21 >> 1) & 1) == 0;
    uint64_t v22 = (uint64_t)&v18[*v18];
    if (v106)
    {
      int v23 = (_DWORD *)(*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)(v91 + 8) + 64))(*(void *)(v91 + 16), 2, 4);
      *((void *)&v106 + 1) = v23;
      *int v23 = v18[7];
      v23[1] = v18[8];
      int v20 = (char *)v18 + *((unsigned int *)v6 + 24);
    }
    uint64_t v90 = &v105;
  }
  else
  {
    uint64_t v90 = 0;
    uint64_t v22 = v6[9];
  }
  uint64_t v104 = (char *)v6[30];
  int conv1d_impl = get_conv1d_impl((_DWORD *)v11, (_DWORD *)v6 + 5, v10);
  unsigned int v92 = v19;
  uint64_t v89 = v22;
  if (conv1d_impl == 2)
  {
    int v34 = *(_DWORD *)(v11 + 4);
    int v35 = v19;
    unsigned int v36 = ((*(_DWORD *)v11 - 1) >> 1) * v34;
    unsigned int v95 = v34 * v35;
    int v85 = *(_DWORD *)v11 >> 1;
    bzero(v104, 4 * v36);
    unsigned int v37 = &v104[4 * v36];
    memcpy(v37, a3, 4 * v95);
    bzero(&v37[4 * v95], (4 * v34 * v85));
    if (*v12 != 3)
    {
      if (*(_DWORD *)(v11 + 24) == 1)
      {
        uint64_t v38 = (*(_DWORD *)(v11 + 56) * *(_DWORD *)(v11 + 60));
        if (v38)
        {
          int v39 = 0;
          uint64_t v40 = *(unsigned int *)(v11 + 16);
          do
          {
            memcpy(&a4->f32[v39], v20, 4 * v40);
            v39 += v40;
            --v38;
          }
          while (v38);
        }
      }
      LODWORD(v41) = v93;
      unsigned int v42 = v92;
      gemm_ex((uint64_t *)*v6, v92, v93, v100, (uint64_t)v104, *(unsigned int *)(v11 + 4), v22, v100, a4, v93, v90);
      goto LABEL_68;
    }
    goto LABEL_29;
  }
  int v25 = conv1d_impl;
  if (conv1d_impl == 4)
  {
    int v43 = *(_DWORD *)(v11 + 4);
    unsigned int v44 = v43 * v19;
    unsigned int v83 = v43 * v19;
    unsigned int v86 = (((*(_DWORD *)v11 - 1) * *(_DWORD *)(v11 + 8)) >> 1) * v43;
    uint64_t v96 = 4 * v86;
    bzero(v104, v96);
    memcpy(&v104[v96], a3, 4 * v44);
    bzero(&v104[4 * v83 + v96], v96);
  }
  else
  {
    if (conv1d_impl == 3)
    {
      int v26 = *(_DWORD *)(v11 + 4);
      unsigned int v94 = v26 * v19;
      unsigned int v27 = (*(_DWORD *)v11 >> 1) * v26;
      unsigned int v28 = ((*(_DWORD *)v11 - 1) >> 1) * v26;
      unsigned int v82 = v28;
      bzero(v104, 4 * v28);
      uint64_t v29 = &v104[4 * v28];
      memcpy(v29, a3, 4 * v94);
      bzero(&v29[4 * v94], 4 * v27);
      unsigned int v30 = v27 + v82;
      int v25 = 3;
      LODWORD(v29) = v30 + v94;
      uint64_t v31 = &v104[4 * get_padded_len(v30 + v94, 8u)];
      memcpy(v31, v104 + 8, 4 * (v29 - 2));
      uint64_t v32 = v104 + 16;
      uint64_t v33 = v31 + 16;
      goto LABEL_28;
    }
    im2row_pad((uint64_t)a3, v108[1], v108[0], v107, *(_DWORD *)v11, *(_DWORD *)(v11 + 4), *(_DWORD *)(v11 + 8), *(_DWORD *)(v11 + 12), *(_DWORD *)(v11 + 20), *(_DWORD *)(v11 + 20), *(_OWORD *)(v11 + 40), HIDWORD(*(void *)(v11 + 40)), *(void *)(v11 + 48), HIDWORD(*(_OWORD *)(v11 + 40)), (uint64_t)v104);
  }
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  uint64_t v33 = 0;
LABEL_28:
  if (*v12 != 3)
  {
    if (v25 == 4)
    {
      int v101 = *(_DWORD *)(v11 + 8);
      unsigned int v98 = *(_DWORD *)(v11 + 4);
      int padded_len = get_padded_len(v98, 8u);
      uint64_t v59 = *(unsigned int *)(v11 + 16);
      if (*(_DWORD *)(v11 + 24) == 1)
      {
        uint64_t v60 = (*(_DWORD *)(v11 + 56) * *(_DWORD *)(v11 + 60));
        if (v60)
        {
          int v61 = 0;
          do
          {
            memcpy(&a4->f32[v61], v20, 4 * v59);
            v61 += v59;
            --v60;
          }
          while (v60);
        }
      }
      uint64_t v41 = v93;
      unsigned int v42 = v92;
      char v62 = v90;
      int v63 = v104;
      if (*(_DWORD *)v11)
      {
        int v64 = 0;
        int v65 = 0;
        unsigned int v66 = 0;
        int v102 = v98 * v101;
        int v99 = v59 * padded_len;
        uint64_t v103 = a4;
        do
        {
          uint64_t v67 = (uint64_t *)*v6;
          int v81 = v41;
          uint64_t v80 = a4;
          uint64_t v68 = v41;
          uint64_t v69 = *(unsigned int *)(v11 + 4);
          uint64_t v70 = v62;
          uint64_t v71 = v11;
          uint64_t v72 = v6;
          uint64_t v73 = v41;
          uint64_t v74 = v63;
          gemm_ex(v67, v92, v68, v69, (uint64_t)&v63[4 * v64], v69, v89 + 4 * v65, v69, v80, v81, v62);
          int v63 = v74;
          uint64_t v41 = v73;
          uint64_t v6 = v72;
          uint64_t v11 = v71;
          a4 = v103;
          char v62 = v70;
          ++v66;
          v65 += v99;
          v64 += v102;
        }
        while (v66 < *(_DWORD *)v11);
      }
    }
    else if (v25 == 3)
    {
      uint64_t v84 = v32;
      uint64_t v87 = v31;
      size_t v97 = (size_t)v33;
      if (*(_DWORD *)(v11 + 24) == 1)
      {
        uint64_t v51 = (*(_DWORD *)(v11 + 56) * *(_DWORD *)(v11 + 60));
        if (v51)
        {
          int v52 = 0;
          uint64_t v53 = *(unsigned int *)(v11 + 16);
          do
          {
            memcpy(&a4->f32[v52], v20, 4 * v53);
            v52 += v53;
            --v51;
          }
          while (v51);
        }
      }
      int v54 = v92 + 6;
      if ((int)(v92 + 3) >= 0) {
        int v54 = v92 + 3;
      }
      LODWORD(v41) = v93;
      int v55 = 4 * v93;
      gemm_ex((uint64_t *)*v6, (v54 >> 2), v93, v100, (uint64_t)v104, (4 * *(_DWORD *)(v11 + 4)), v89, v100, a4, 4 * v93, v90);
      if ((int)(v92 + 1) >= 0) {
        int v56 = v92 + 1;
      }
      else {
        int v56 = v92 + 4;
      }
      gemm_ex((uint64_t *)*v6, (v56 >> 2), v93, v100, (uint64_t)&v84[8 * *(_DWORD *)(v11 + 4) - 16], (4 * *(_DWORD *)(v11 + 4)), v89, v100, (float32x4_t *)((char *)a4 + 4 * (2 * v93)), v55, v90);
      int v57 = v92 + 2;
      if ((int)(v92 + 2) < 0) {
        int v57 = v92 + 5;
      }
      gemm_ex((uint64_t *)*v6, (v57 >> 2), v93, v100, (uint64_t)&v87[4 * *(unsigned int *)(v11 + 4) - 8], (4 * *(_DWORD *)(v11 + 4)), v89, v100, (float32x4_t *)((char *)a4 + 4 * v93), v55, v90);
      if ((v92 & 0x80000000) == 0) {
        int v58 = v92;
      }
      else {
        int v58 = v92 + 3;
      }
      gemm_ex((uint64_t *)*v6, (v58 >> 2), v93, v100, v97 + 4 * (3 * *(_DWORD *)(v11 + 4)) - 24, (4 * *(_DWORD *)(v11 + 4)), v89, v100, (float32x4_t *)((char *)a4 + 4 * (3 * v93)), v55, v90);
      unsigned int v42 = v92;
    }
    else
    {
      LODWORD(v41) = v93;
      unsigned int v42 = v92;
      if (*v12 == 2)
      {
        if (*(_DWORD *)(v11 + 24) == 1)
        {
          uint64_t v75 = (*(_DWORD *)(v11 + 56) * *(_DWORD *)(v11 + 60));
          if (v75)
          {
            int v76 = 0;
            uint64_t v77 = *(unsigned int *)(v11 + 16);
            do
            {
              memcpy(&a4->f32[v76], v20, 4 * v77);
              v76 += v77;
              --v75;
            }
            while (v75);
          }
        }
        unsigned int v42 = v92;
        gemm((uint64_t *)*v6, v92, v93, v100, (uint64_t)v104, v89, a4, v90, v79);
      }
    }
    goto LABEL_68;
  }
LABEL_29:
  if (*(_DWORD *)(v11 + 24) == 1)
  {
    uint64_t v45 = *(unsigned int *)(v11 + 16);
    if (v45)
    {
      int v46 = 0;
      uint64_t v47 = 0;
      uint64_t v48 = (*(_DWORD *)(v11 + 56) * *(_DWORD *)(v11 + 60));
      do
      {
        if (v48)
        {
          int v49 = v46;
          uint64_t v50 = v48;
          do
          {
            a4->i32[v49++] = *(_DWORD *)&v20[4 * v47];
            --v50;
          }
          while (v50);
        }
        ++v47;
        v46 += v48;
      }
      while (v47 != v45);
    }
  }
  LODWORD(v41) = v93;
  gemm((uint64_t *)*v6, v93, v92, v100, (uint64_t)v18, (uint64_t)v104, a4, 0, v79);
  unsigned int v42 = v92;
LABEL_68:
  fi_activate_array(a4->f32, v42 * v41, *(_DWORD *)(v11 + 32));
  if (*((void *)&v106 + 1)) {
    (*(void (**)(void))(*(void *)(v91 + 8) + 80))(*(void *)(v91 + 16));
  }
  return 0;
}

uint64_t im2row_pad(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, uint64_t a15)
{
  uint64_t v22 = (a5 * a2 * a6);
  int v36 = (~((a5 - 1) * a7) + a3 + a11 + a12) / a10;
  uint64_t result = get_padded_len(v22, 8u);
  if ((v36 & 0x80000000) == 0)
  {
    uint64_t v24 = 0;
    int v26 = (~((a6 - 1) * a8) + a4 + a13 + a14) / a9;
    uint64_t v27 = (v26 + 1);
    uint64_t v28 = 4 * (int)result * (uint64_t)(int)v27;
    uint64_t v29 = 4 * (int)result;
    do
    {
      if ((v26 & 0x80000000) == 0)
      {
        uint64_t v30 = 0;
        uint64_t result = (v24 * a10 - a11);
        uint64_t v31 = a15;
        do
        {
          if ((int)v22 >= 1)
          {
            for (uint64_t i = 0; i != v22; ++i)
            {
              int v33 = result + (int)i / a6 % a5 * a7;
              int v34 = 0;
              if (v33 < a3 && (v33 & 0x80000000) == 0)
              {
                int v35 = v30 * a9 - a13 + (int)i % a6 * a8;
                if ((v35 & 0x80000000) == 0 && v35 < a4) {
                  int v34 = *(_DWORD *)(a1 + 4 * (v35 + (v33 + (int)i / a5 / a6 * a3) * a4));
                }
              }
              *(_DWORD *)(v31 + 4 * i) = v34;
            }
          }
          ++v30;
          v31 += v29;
        }
        while (v30 != v27);
      }
      ++v24;
      a15 += v28;
    }
    while (v24 != v36 + 1);
  }
  return result;
}

uint64_t get_padding_size(uint64_t *a1, int *a2, int a3, _DWORD *a4, unsigned int *a5, unsigned int *a6, _DWORD *a7)
{
  uint64_t v12 = a2[7];
  int v13 = a2[1];
  unsigned int v14 = a2[3];
  unsigned int v24 = a2[2];
  int v25 = *a2;
  unsigned int v15 = a2[5];
  uint64_t v28 = 0;
  int v27 = 0;
  uint64_t conv_chw = fi_shape_get_conv_chw(a4, (_DWORD *)&v28 + 1, &v28, &v27);
  if (!conv_chw)
  {
    *a7 = v12;
    uint64_t windows_output_size = get_windows_output_size(a1, v28, v25, v24, v15, v12, a6, a7 + 1, a7 + 2);
    if (windows_output_size) {
      return windows_output_size;
    }
    if (*a4 != 2)
    {
      if (*a4 == 3) {
        return get_windows_output_size(a1, v27, v13, v14, v15, v12, a5, a7 + 3, a7 + 4);
      }
      return 7;
    }
    a7[3] = 0;
    a7[4] = 0;
    if ((a3 - 10) >= 4)
    {
      if (!a3)
      {
        int v22 = 1;
        goto LABEL_10;
      }
      if (a3 != 8) {
        return 7;
      }
    }
    int v22 = v27;
LABEL_10:
    uint64_t windows_output_size = 0;
    *a5 = v22;
    return windows_output_size;
  }
  uint64_t windows_output_size = conv_chw;
  log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"fi_shape_get_conv_chw error!", v17, v18, v19, v23);
  return windows_output_size;
}

uint64_t get_windows_output_size(uint64_t *a1, int a2, int a3, uint64_t a4, unsigned int a5, uint64_t a6, unsigned int *a7, unsigned int *a8, _DWORD *a9)
{
  if (!a5)
  {
    uint64_t v11 = *a1;
    uint64_t v12 = "Stride must be > 0, but got %d";
    uint64_t v16 = 0;
LABEL_10:
    log_OutText(v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)v12, a6, (uint64_t)a7, (uint64_t)a8, v16);
    return 7;
  }
  if (a4)
  {
    int v9 = (a3 - 1) * a4;
    if (a6 == 1)
    {
      uint64_t result = 0;
      unsigned int v13 = (a2 + a5 - 1) / a5;
      *a7 = v13;
      int v14 = v9 + 1 - a2 + (v13 - 1) * a5;
      unsigned int v15 = v14 & ~(v14 >> 31);
      *a8 = v15 >> 1;
      *a9 = v15 - (v15 >> 1);
      return result;
    }
    if (!a6)
    {
      uint64_t result = 0;
      *a7 = (a5 + a2 + ~v9) / a5;
      *a9 = 0;
      *a8 = 0;
      return result;
    }
    uint64_t v11 = *a1;
    uint64_t v12 = "Supported padding: valid, same, but got: %d";
    uint64_t v16 = a6;
    goto LABEL_10;
  }
  log_OutText(*a1, (uint64_t)"FastInfer", 0, a4, (uint64_t)"Dilation rate must be > 1, but got %d", a6, (uint64_t)a7, (uint64_t)a8, 0);
  return 7;
}

uint64_t im2row(uint64_t result, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, uint64_t a15)
{
  int v15 = (a3 - a5 + a11 + a12) / a10;
  if ((v15 & 0x80000000) == 0)
  {
    uint64_t v16 = 0;
    uint64_t v18 = (a5 * a2 * a6);
    int v19 = (a4 - a6 + a13 + a14) / a9;
    uint64_t v20 = (v19 + 1);
    uint64_t v21 = (v15 + 1);
    do
    {
      if ((v19 & 0x80000000) == 0)
      {
        uint64_t v22 = 0;
        uint64_t v23 = a15;
        do
        {
          if ((int)v18 >= 1)
          {
            for (uint64_t i = 0; i != v18; ++i)
            {
              int v25 = v16 * a10 - a11 + (int)i / a6 % a5 * a7;
              int v26 = 0;
              if (v25 < a3 && (v25 & 0x80000000) == 0)
              {
                int v27 = v22 * a9 - a13 + (int)i % a6 * a8;
                if ((v27 & 0x80000000) == 0 && v27 < a4) {
                  int v26 = *(_DWORD *)(result + 4 * (v27 + (v25 + (int)i / a5 / a6 * a3) * a4));
                }
              }
              *(_DWORD *)(v23 + 4 * i) = v26;
            }
          }
          ++v22;
          v23 += 4 * (int)v18;
        }
        while (v22 != v20);
      }
      ++v16;
      a15 += 4 * (int)v18 * (uint64_t)(int)v20;
    }
    while (v16 != v21);
  }
  return result;
}

uint64_t im2row_2d_or_1d(int a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7)
{
  if (a1 == 2)
  {
    im2row(a2, a3, a4, a5, *(_DWORD *)a6, *(_DWORD *)(a6 + 4), *(_DWORD *)(a6 + 8), 1, 1, *(_DWORD *)(a6 + 20), *(_DWORD *)(a6 + 40), *(_DWORD *)(a6 + 44), 0, 0, a7);
    return 0;
  }
  if (a1 == 3)
  {
    im2row(a2, a3, a4, a5, *(_DWORD *)a6, *(_DWORD *)(a6 + 4), *(_DWORD *)(a6 + 8), *(_DWORD *)(a6 + 12), *(_DWORD *)(a6 + 20), *(_DWORD *)(a6 + 20), *(_OWORD *)(a6 + 40), HIDWORD(*(void *)(a6 + 40)), *(void *)(a6 + 48), HIDWORD(*(_OWORD *)(a6 + 40)), a7);
    return 0;
  }
  return 7;
}

uint64_t create_highway_layer(uint64_t *a1, uint64_t *a2, void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7 = 0;
  uint64_t result = 7;
  if (a1 && a2)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      int v15 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 24);
      int v19 = v15;
      if (!v15)
      {
        uint64_t v21 = *a1;
        uint64_t v22 = "out of memory!";
        goto LABEL_14;
      }
      uint64_t v20 = *a2;
      *int v15 = *a2;
      if ((v20 & 7) != 0)
      {
        uint64_t v21 = *a1;
        uint64_t v22 = "highway_feat must be multiple of 8!";
LABEL_14:
        log_OutText(v21, (uint64_t)"FastInfer", 0, 0, (uint64_t)v22, v16, v17, v18, v31);
        *(void *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"highway init param failed!", v28, v29, v30, v32);
        uint64_t result = 7;
        goto LABEL_15;
      }
      uint64_t v33 = 0x100000001;
      HIDWORD(v34) = *(_DWORD *)a2;
      int v35 = 0;
      LODWORD(v34) = 5;
      if (create_fc_layer(a1, &v34, &v33, a3, a4, v15 + 1))
      {
        int v26 = "create highway denseT dense layer failed!";
LABEL_13:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v23, v24, v25, v31);
        uint64_t v21 = *a1;
        uint64_t v22 = "highway network init failed!";
        goto LABEL_14;
      }
      unsigned int v27 = *((_DWORD *)a2 + 1);
      HIDWORD(v34) = *(_DWORD *)a2;
      int v35 = 0;
      LODWORD(v34) = 5;
      uint64_t v33 = v27 | 0x100000000;
      if (create_fc_layer(a1, &v34, &v33, a3, a4, v19 + 2))
      {
        int v26 = "create highway denseH dense layer failed!";
        goto LABEL_13;
      }
      *(void *)(v7 + 120) = v19;
      if (a3) {
        *(void *)(v7 + 60) = *a3;
      }
      *(void *)uint64_t v7 = a1;
      *(void *)(v7 + 8) = 53;
      *(void *)(v7 + 128) = forward_highway_layer;
      *(void *)(v7 + 136) = free_highway_layer;
      *(void *)(v7 + 144) = highway_layer_update_shape;
      *(void *)(v7 + 152) = highway_layer_wanted_wb_len;
      *(void *)(v7 + 160) = highway_request_glbBuf;
      *(void *)(v7 + 184) = highway_dispatch_weights;
      if (a4)
      {
        uint64_t result = 0;
        *(void *)(v7 + 256) = *(void *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, using default (0)", v23, v24, v25, v31);
        uint64_t result = 0;
        *(void *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v31);
      uint64_t result = 10;
    }
  }
LABEL_15:
  *a5 = v7;
  return result;
}

uint64_t forward_highway_layer(uint64_t a1, uint64_t a2, float *a3, void *a4)
{
  if (!a2) {
    return 0;
  }
  unsigned int v8 = *(uint64_t **)a2;
  uint64_t v9 = *(void *)(a2 + 120);
  uint64_t v10 = *(_DWORD *)v9 * fi_shape_get_step((_DWORD *)(a2 + 20));
  uint64_t v11 = *(void **)(a2 + 240);
  bzero(v11, 4 * v10);
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)(v9 + 8) + 128))(a1);
  if (!v12)
  {
    bzero(a4, 4 * v10);
    uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)(v9 + 16) + 128))(a1);
    if (v19)
    {
      uint64_t v16 = v19;
      uint64_t v17 = *v8;
      uint64_t v18 = "highway forward dense denseH layer failed!";
      goto LABEL_6;
    }
    xmy(v10, (float *)v11, 1, (float *)a4, 1);
    if (v10)
    {
      uint64_t v20 = v10;
      uint64_t v21 = (float *)v11;
      do
      {
        *uint64_t v21 = 1.0 - *v21;
        ++v21;
        --v20;
      }
      while (v20);
    }
    xmy(v10, a3, 1, (float *)v11, 1);
    axpy(v10, (float *)v11, 1, (float *)a4, 1, 1.0);
    return 0;
  }
  uint64_t v16 = v12;
  uint64_t v17 = *v8;
  uint64_t v18 = "highway forward dense denseT failed!";
LABEL_6:
  log_OutText(v17, (uint64_t)"FastInfer", 0, 0, (uint64_t)v18, v13, v14, v15, v23);
  return v16;
}

void *free_highway_layer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = result[15];
      if (v3)
      {
        fi_layer_free(*(void *)(v3 + 8));
        fi_layer_free(*(void *)(v3 + 16));
        (*(void (**)(void, uint64_t))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v4 = *(void *)(v2 + 16);
      uint64_t v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v5(v4, v1);
    }
  }
  return result;
}

__n128 highway_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 120);
  uint64_t v9 = *(uint64_t **)a1;
  int v10 = *(_DWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v10;
  if (*(_DWORD *)a2 >= 3u)
  {
    uint64_t v11 = *v9;
    uint64_t v12 = "Currently highway layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)v12, a6, a7, a8, v18);
    return result;
  }
  if (!(*(unsigned int (**)(void))(*(void *)(v8 + 8) + 144))()
    && !(*(unsigned int (**)(void))(*(void *)(v8 + 16) + 144))())
  {
    uint64_t v15 = *(void *)(v8 + 16);
    unsigned int v17 = *(_DWORD *)(v15 + 40);
    uint64_t v16 = (__n128 *)(v15 + 40);
    if (v17 >= 3)
    {
      uint64_t v11 = *v9;
      uint64_t v12 = "denseH output shape error: Currently highway layer only support 1D or 2D output";
      goto LABEL_3;
    }
    __n128 result = *v16;
    *(_DWORD *)(a1 + 56) = v16[1].n128_u32[0];
    *(__n128 *)(a1 + 40) = result;
  }
  return result;
}

uint64_t highway_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6 = *(unsigned int **)(a1 + 120);
  uint64_t result = (*(uint64_t (**)(void))(*((void *)v6 + 1) + 152))();
  if (!result)
  {
    padded_uint64_t bytes = get_padded_bytes(0, 8u);
    uint64_t result = (*(uint64_t (**)(void))(*((void *)v6 + 2) + 152))();
    if (!result)
    {
      *a2 = get_padded_bytes(padded_bytes, 8u);
      *a3 = 0;
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"highway feat size: %d\n", v9, v10, v11, *v6);
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v12, v13, v14, *(unsigned int *)(a1 + 96));
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v15, v16, v17, *a2);
      return 0;
    }
  }
  return result;
}

uint64_t highway_request_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(_DWORD **)(a1 + 120);
  uint64_t v3 = (int *)(a1 + 20);
  int step = fi_shape_get_step((_DWORD *)(a1 + 20));
  unsigned int v11 = 0;
  uint64_t result = fi_shape_get_input_dim(v3, (int *)&v11);
  if (!result)
  {
    if (v11 == *v2)
    {
      int padded_len = get_padded_len(v11, 8u);
      uint64_t result = 0;
      *(_DWORD *)(a1 + 248) = 4 * step * padded_len;
    }
    else
    {
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"highway: input sample dim mismatch!", v6, v7, v8, v10);
      return 7;
    }
  }
  return result;
}

uint64_t highway_dispatch_weights(uint64_t a1)
{
  padded_uint64_t bytes = 0;
  uint64_t v1 = *(void *)(a1 + 120);
  uint64_t v2 = *(void *)(a1 + 72);
  uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v1 + 16), v2, &padded_bytes);
  if (!result)
  {
    padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
    uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v1 + 8), v2, &padded_bytes);
    if (!result)
    {
      get_padded_bytes(padded_bytes, 8u);
      return 0;
    }
  }
  return result;
}

uint64_t ffn_dispatch_weights(uint64_t a1)
{
  padded_uint64_t bytes = 0;
  uint64_t v1 = *(uint64_t **)(a1 + 120);
  uint64_t v2 = *(void *)(a1 + 72);
  uint64_t result = fi_layer_find_weights_via_offset(v1[3], v2, &padded_bytes);
  if (!result)
  {
    padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
    uint64_t result = fi_layer_find_weights_via_offset(v1[4], v2, &padded_bytes);
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
      uint64_t result = fi_layer_find_weights_via_offset(v1[5], v2, &padded_bytes);
      if (!result)
      {
        get_padded_bytes(padded_bytes, 8u);
        return 0;
      }
    }
  }
  return result;
}

uint64_t create_ffn_layer(uint64_t *a1, long long *a2, void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7 = 0;
  uint64_t result = 7;
  if (a1 && a2)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 48);
      uint64_t v19 = v15;
      if (!v15)
      {
        uint64_t v26 = *a1;
        unsigned int v27 = "out of memory!";
LABEL_14:
        log_OutText(v26, (uint64_t)"FastInfer", 0, 0, (uint64_t)v27, v16, v17, v18, v31);
        *(void *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"ffn init param failed!", v28, v29, v30, v32);
        uint64_t result = 7;
        goto LABEL_15;
      }
      long long v20 = *a2;
      *(_DWORD *)(v15 + 16) = *((_DWORD *)a2 + 4);
      *(_OWORD *)uint64_t v15 = v20;
      int v21 = *((_DWORD *)a2 + 1);
      LODWORD(v34) = 40;
      HIDWORD(v34) = v21;
      int v35 = 0;
      if (create_norm_layer(a1, &v34, (uint64_t *)(v15 + 24)))
      {
        uint64_t v25 = "create ffn norm layer failed!";
LABEL_13:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v25, v22, v23, v24, v31);
        uint64_t v26 = *a1;
        unsigned int v27 = "ffn network init failed!";
        goto LABEL_14;
      }
      HIDWORD(v34) = *(_DWORD *)a2;
      int v35 = 0;
      LODWORD(v34) = 5;
      int32x2_t v33 = vrev64_s32(*(int32x2_t *)((char *)a2 + 8));
      if (create_fc_layer(a1, &v34, &v33, a3, a4, (uint64_t *)(v19 + 32)))
      {
        uint64_t v25 = "create ffn o1 dense layer failed!";
        goto LABEL_13;
      }
      HIDWORD(v34) = *((_DWORD *)a2 + 1);
      int v35 = 0;
      LODWORD(v34) = 5;
      v33.i32[0] = *((_DWORD *)a2 + 4);
      if (create_fc_layer(a1, &v34, &v33, a3, a4, (uint64_t *)(v19 + 40)))
      {
        uint64_t v25 = "create ffn o2 dense layer failed!";
        goto LABEL_13;
      }
      *(void *)(v7 + 120) = v19;
      if (a3) {
        *(void *)(v7 + 60) = *a3;
      }
      *(void *)uint64_t v7 = a1;
      *(void *)(v7 + 8) = 33;
      *(void *)(v7 + 128) = forward_ffn_layer;
      *(void *)(v7 + 136) = free_ffn_layer;
      *(void *)(v7 + 144) = ffn_layer_update_shape;
      *(void *)(v7 + 152) = ffn_layer_wanted_wb_len;
      *(void *)(v7 + 160) = ffn_request_glbBuf;
      *(void *)(v7 + 184) = ffn_dispatch_weights;
      if (a4)
      {
        uint64_t result = 0;
        *(void *)(v7 + 256) = *(void *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, using default (0)", v22, v23, v24, v31);
        uint64_t result = 0;
        *(void *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v31);
      uint64_t result = 10;
    }
  }
LABEL_15:
  *a5 = v7;
  return result;
}

uint64_t forward_ffn_layer(uint64_t a1, uint64_t a2, float *a3, void *a4)
{
  if (!a2) {
    return 0;
  }
  uint64_t v8 = *(uint64_t **)a2;
  uint64_t v9 = *(unsigned int **)(a2 + 120);
  int step = fi_shape_get_step((_DWORD *)(a2 + 20));
  uint64_t v11 = v9[1];
  uint64_t v12 = *(char **)(a2 + 240);
  int padded_len = get_padded_len(v11, 8u);
  int v14 = get_padded_len(v11, 8u);
  bzero(v12, 4 * (v14 * step));
  uint64_t v15 = (*(uint64_t (**)(uint64_t))(*((void *)v9 + 3) + 128))(a1);
  if (v15)
  {
    uint64_t v19 = v15;
    uint64_t v20 = *v8;
    int v21 = "ffn forward norm layer failed!";
  }
  else
  {
    int v22 = get_padded_len(*v9, 8u);
    bzero(&v12[4 * padded_len * step], 4 * (v22 * step));
    uint64_t v23 = (*(uint64_t (**)(uint64_t))(*((void *)v9 + 4) + 128))(a1);
    if (v23)
    {
      uint64_t v19 = v23;
      uint64_t v20 = *v8;
      int v21 = "ffn forward dense o1 failed!";
    }
    else
    {
      uint64_t v24 = (v11 * step);
      bzero(a4, 4 * v24);
      uint64_t v19 = (*(uint64_t (**)(uint64_t))(*((void *)v9 + 5) + 128))(a1);
      if (!v19)
      {
        axpy(v24, a3, 1, (float *)a4, 1, 1.0);
        return v19;
      }
      uint64_t v20 = *v8;
      int v21 = "ffn forward dense o2 layer failed!";
    }
  }
  log_OutText(v20, (uint64_t)"FastInfer", 0, 0, (uint64_t)v21, v16, v17, v18, v26);
  return v19;
}

void *free_ffn_layer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[3]);
        fi_layer_free(v3[4]);
        fi_layer_free(v3[5]);
        (*(void (**)(void, uint64_t *))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v4 = *(void *)(v2 + 16);
      uint64_t v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v5(v4, v1);
    }
  }
  return result;
}

__n128 ffn_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void **)(a1 + 120);
  int v10 = *(_DWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v10;
  if (*(_DWORD *)a2 >= 3u)
  {
    uint64_t v11 = **(void **)a1;
    uint64_t v12 = "Currently ffn layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)v12, a6, a7, a8, v17);
    return result;
  }
  if (!(*(unsigned int (**)(void))(v9[3] + 144))()
    && !(*(unsigned int (**)(void))(v9[4] + 144))()
    && !(*(unsigned int (**)(void))(v9[5] + 144))())
  {
    uint64_t v14 = v9[5];
    unsigned int v16 = *(_DWORD *)(v14 + 40);
    uint64_t v15 = (__n128 *)(v14 + 40);
    if (v16 >= 3)
    {
      uint64_t v11 = **(void **)a1;
      uint64_t v12 = "o2 output shape error: Currently ffn layer only support 1D or 2D output";
      goto LABEL_3;
    }
    __n128 result = *v15;
    *(_DWORD *)(a1 + 56) = v15[1].n128_u32[0];
    *(__n128 *)(a1 + 40) = result;
  }
  return result;
}

uint64_t ffn_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6 = *(void **)(a1 + 120);
  uint64_t result = (*(uint64_t (**)(void))(v6[3] + 152))();
  if (!result)
  {
    padded_uint64_t bytes = get_padded_bytes(0, 8u);
    uint64_t result = (*(uint64_t (**)(void))(v6[4] + 152))();
    if (!result)
    {
      unsigned int v9 = get_padded_bytes(padded_bytes, 8u);
      uint64_t result = (*(uint64_t (**)(void))(v6[5] + 152))();
      if (!result)
      {
        *a2 = get_padded_bytes(v9, 8u);
        *a3 = 0;
        log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"ffn filter size: %d\n", v10, v11, v12, *(unsigned int *)(v6[4] + 12));
        log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v13, v14, v15, *(unsigned int *)(a1 + 96));
        log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v16, v17, v18, *a2);
        return 0;
      }
    }
  }
  return result;
}

uint64_t ffn_request_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(unsigned int **)(a1 + 120);
  uint64_t v3 = (int *)(a1 + 20);
  int step = fi_shape_get_step((_DWORD *)(a1 + 20));
  unsigned int v13 = 0;
  uint64_t result = fi_shape_get_input_dim(v3, (int *)&v13);
  if (!result)
  {
    if (v13 == v2[1])
    {
      int padded_len = get_padded_len(v13, 8u);
      int v10 = get_padded_len(*v2, 8u);
      padded_uint64_t bytes = get_padded_bytes(4 * step * (v10 + padded_len), 8u);
      uint64_t result = 0;
      *(_DWORD *)(a1 + 248) = padded_bytes;
    }
    else
    {
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"ffn: input sample dim mismatch!", v6, v7, v8, v12);
      return 7;
    }
  }
  return result;
}

uint64_t create_softmax_layer(uint64_t *a1, uint64_t *a2, _DWORD *a3, void *a4, uint64_t *a5)
{
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v13
    && (uint64_t v14 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 4),
        (*(void *)(v13 + 120) = v14) != 0))
  {
    *uint64_t v14 = *a3;
    if (a4) {
      *(void *)(v13 + 60) = *a4;
    }
    uint64_t result = 0;
    uint64_t v16 = *a2;
    *(_DWORD *)(v13 + 16) = *((_DWORD *)a2 + 2);
    *(void *)uint64_t v13 = a1;
    *(void *)(v13 + 8) = v16;
    *(void *)(v13 + 128) = forward_softmax_layer;
    *(void *)(v13 + 136) = free_softmax_buffer;
    *(void *)(v13 + 144) = softmax_layer_update_shape;
    *a5 = v13;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v10, v11, v12, v17);
    *a5 = v13;
    free_softmax_buffer((void *)v13);
    return 10;
  }
  return result;
}

uint64_t forward_softmax_layer(uint64_t a1, uint64_t a2, float *a3, float *a4)
{
  unsigned int v12 = 0;
  uint64_t v7 = (int *)(a2 + 20);
  int step = fi_shape_get_step((_DWORD *)(a2 + 20));
  uint64_t input_dim = fi_shape_get_input_dim(v7, (int *)&v12);
  if (!input_dim)
  {
    if (*v7 == 1)
    {
      softmax(a3, v12, 1, a4, **(float **)(a2 + 120));
    }
    else if (step)
    {
      for (int i = 0; i != step; ++i)
        softmax(&a3[v12 * i], v12, 1, &a4[v12 * i], **(float **)(a2 + 120));
    }
  }
  return input_dim;
}

void *free_softmax_buffer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      if (result[15])
      {
        (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        v1[15] = 0;
      }
      uint64_t v3 = *(void *)(v2 + 16);
      uint64_t v4 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v4(v3, v1);
    }
  }
  return result;
}

uint64_t softmax_layer_update_shape(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *a2;
  if ((v9 - 1) >= 2)
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Softmax only supports 1D/2D operation, get %dD", a6, a7, a8, v9);
    return 7;
  }
  else
  {
    uint64_t result = 0;
    long long v11 = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = a2[4];
    *(_OWORD *)(a1 + 20) = v11;
    long long v12 = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 56) = a2[4];
    *(_OWORD *)(a1 + 40) = v12;
  }
  return result;
}

uint64_t create_trans_decoder(uint64_t *a1, unsigned int *a2, void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7 = 0;
  uint64_t result = 7;
  if (a1 && a2)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 104);
      uint64_t v19 = v15;
      if (!v15)
      {
        uint64_t v32 = *a1;
        int32x2_t v33 = "out of memory!";
LABEL_23:
        log_OutText(v32, (uint64_t)"FastInfer", 0, 0, (uint64_t)v33, v16, v17, v18, v38);
        *(void *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_decoder init param failed!", v35, v36, v37, v39);
        uint64_t result = 7;
        goto LABEL_24;
      }
      long long v20 = *(_OWORD *)a2;
      long long v21 = *((_OWORD *)a2 + 1);
      long long v22 = *((_OWORD *)a2 + 2);
      *(void *)(v15 + 48) = *((void *)a2 + 6);
      *(_OWORD *)(v15 + 16) = v21;
      *(_OWORD *)(v15 + 32) = v22;
      *(_OWORD *)uint64_t v15 = v20;
      uint64_t v23 = *a2;
      uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v23, 8);
      *(void *)(v19 + 56) = v24;
      if (!v24)
      {
        uint64_t v30 = *a1;
        uint64_t v31 = "out of memory!";
        goto LABEL_22;
      }
      if (v23)
      {
        uint64_t v28 = 0;
        uint64_t v29 = 8 * v23;
        while (!create_trans_dec_layer(a1, (long long *)(a2 + 1), a3, a4, (uint64_t *)(*(void *)(v19 + 56) + v28)))
        {
          v28 += 8;
          if (v29 == v28) {
            goto LABEL_10;
          }
        }
        uint64_t v30 = *a1;
        uint64_t v31 = "create trans_decoder trans_dec layer failed!";
        goto LABEL_22;
      }
LABEL_10:
      uint64_t v40 = 0;
      *(uint64_t *)((char *)v43 + 4) = 0;
      LODWORD(v43[0]) = 40;
      if (create_norm_layer(a1, v43, (uint64_t *)(v19 + 64)))
      {
        uint64_t v30 = *a1;
        uint64_t v31 = "create trans_decoder norm layer failed!";
LABEL_22:
        log_OutText(v30, (uint64_t)"FastInfer", 0, 0, (uint64_t)v31, v25, v26, v27, v38);
        uint64_t v32 = *a1;
        int32x2_t v33 = "trans_decoder network init failed!";
        goto LABEL_23;
      }
      unsigned int v34 = a2[12];
      LODWORD(v42) = a2[5];
      HIDWORD(v42) = v34;
      if (create_embedding_layer(a1, &v42, (uint64_t ***)(v19 + 72)))
      {
        uint64_t v30 = *a1;
        uint64_t v31 = "create trans_decoder emb layer failed!";
        goto LABEL_22;
      }
      HIDWORD(v43[0]) = a2[12];
      LODWORD(v43[1]) = 0;
      LODWORD(v43[0]) = 5;
      if (create_fc_layer(a1, v43, &v40, a3, a4, (uint64_t *)(v19 + 88)))
      {
        uint64_t v30 = *a1;
        uint64_t v31 = "create att q dense layer failed!";
        goto LABEL_22;
      }
      memset(v43, 0, 12);
      int v41 = 1065353216;
      if (create_softmax_layer(a1, v43, &v41, a3, (uint64_t *)(v19 + 80)))
      {
        uint64_t v30 = *a1;
        uint64_t v31 = "create att softmax layer failed!";
        goto LABEL_22;
      }
      *(void *)(v7 + 120) = v19;
      if (a3) {
        *(void *)(v7 + 60) = *a3;
      }
      *(void *)uint64_t v7 = a1;
      *(void *)(v7 + 8) = 38;
      *(void *)(v7 + 128) = transformer_decode;
      *(void *)(v7 + 136) = free_trans_decoder;
      *(void *)(v7 + 144) = trans_decoder_update_shape;
      *(void *)(v7 + 152) = trans_decoder_wanted_wb_len;
      *(void *)(v7 + 160) = trans_decoder_request_glbBuf;
      *(void *)(v7 + 184) = trans_decoder_dispatch_weights;
      *(void *)(v7 + 168) = trans_decoder_assign_glbBuf;
      *(void *)(v7 + 176) = trans_decoder_reset;
      if (a4)
      {
        uint64_t result = 0;
        *(void *)(v7 + 256) = *(void *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v25, v26, v27, v38);
        uint64_t result = 0;
        *(void *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v38);
      uint64_t result = 10;
    }
  }
LABEL_24:
  *a5 = v7;
  return result;
}

uint64_t transformer_decode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    return 0;
  }
  *(_DWORD *)(a5 + 20) = 1;
  uint64_t v9 = *(unsigned int **)(a2 + 120);
  if (v9)
  {
    trans_decoder_update_shape(a2, (long long *)(a2 + 20), a3, a4, a5, a6, a7, a8);
    unsigned int step = fi_shape_get_step((_DWORD *)(a2 + 20));
    uint64_t v12 = *v9;
    if (v12)
    {
      uint64_t v13 = (uint64_t *)*((void *)v9 + 7);
      do
      {
        uint64_t v14 = *v13++;
        uint64_t v15 = *(void *)(v14 + 120);
        uint64_t v17 = *(void *)(v15 + 56);
        uint64_t v16 = *(void *)(v15 + 64);
        uint64_t v18 = *(void *)(v17 + 120);
        *(_DWORD *)(v18 + 152) = 0;
        *(_DWORD *)(v18 + 112) = 0;
        uint64_t v19 = *(void *)(v16 + 120);
        *(_DWORD *)(v19 + 152) = 0;
        *(_DWORD *)(v19 + 112) = 0;
        --v12;
      }
      while (v12);
    }
    bzero(*(void **)(a2 + 240), *(unsigned int *)(a2 + 248));
    uint64_t v20 = a2;
    unsigned int v21 = v9[10];
    unsigned int padded_len = get_padded_len(v9[5], 8u);
    unsigned int v23 = padded_len;
    uint64_t v24 = *(uint64_t **)v20;
    __nel_4 = (uint64_t **)v20;
    if (v21 < 2)
    {
      int v53 = v9[8] * padded_len;
      int v54 = v9[7] * padded_len;
      unsigned int v55 = v9[12];
      if (padded_len > v55) {
        unsigned int v55 = padded_len;
      }
      padded_uint64_t bytes = get_padded_bytes(8 * v55, 8u);
      uint64_t v57 = *(void *)(v20 + 240);
      uint64_t v58 = *v9;
      uint64_t v59 = padded_bytes + 4 * v53 * v58;
      uint64_t v60 = (v59 + 4 * v53 * v58);
      int v61 = v54 * v58;
      uint64_t v62 = (v60 + 4 * v54 * v58);
      if (v58)
      {
        unsigned int v63 = 0;
        unsigned int v64 = 0;
        uint64_t v65 = v57 + v59;
        uint64_t v66 = v57 + v60;
        uint64_t v67 = (uint64_t *)*((void *)v9 + 7);
        uint64_t v68 = v57 + padded_bytes;
        do
        {
          uint64_t v69 = *v67++;
          uint64_t v70 = *(void *)(v69 + 120);
          uint64_t v72 = *(void *)(v70 + 56);
          uint64_t v71 = *(void *)(v70 + 64);
          uint64_t v73 = *(void *)(v72 + 120);
          *(void *)(v73 + 120) = v68 + 4 * v63;
          *(void *)(v73 + 128) = v65 + 4 * v63;
          uint64_t v74 = *(void *)(v71 + 120);
          *(void *)(v74 + 136) = v66 + 4 * v64;
          *(void *)(v74 + 144) = v57 + v62 + 4 * v64;
          v64 += v54;
          v63 += v53;
          --v58;
        }
        while (v58);
      }
      if (v9[13])
      {
        unint64_t v75 = 0;
        uint64_t v76 = v57 + (v62 + 4 * v61);
        float v77 = 0.0;
        while (v75 < v9[8])
        {
          uint64_t v78 = forward_trans_decoder(a1, __nel_4, a3, v75, 0, v76, v77);
          if (v78)
          {
            uint64_t v52 = v78;
            uint64_t v147 = *v24;
LABEL_103:
            log_OutText(v147, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Transformer decode  failed!", v79, v80, v81, (uint64_t)v150);
            return v52;
          }
          uint64_t v82 = v9[12];
          if (v82)
          {
            float v83 = -2147500000.0;
            uint64_t v84 = (unsigned int *)(v76 + 4);
            do
            {
              if (v83 < *((float *)v84 - 1))
              {
                float v77 = (float)*v84;
                float v83 = *((float *)v84 - 1);
              }
              v84 += 3;
              --v82;
            }
            while (v82);
          }
          *(float *)(a4 + 4 * v75++) = v77;
          if (v77 == (float)v9[13]) {
            break;
          }
        }
      }
      else
      {
        LODWORD(v75) = 0;
      }
      int v49 = __nel_4;
    }
    else
    {
      uint64_t v150 = *(uint64_t **)v20;
      char __dst = (void *)a4;
      float v25 = (float)step;
      unsigned int v26 = v9[7];
      unsigned int v27 = v9[8];
      unsigned int v28 = (float)((float)(v25 * (float)v27) / (float)v26);
      if (v27 < v28) {
        unsigned int v28 = v9[8];
      }
      unsigned int v171 = v28;
      int v29 = v27 * padded_len;
      int v30 = v26 * padded_len;
      int v31 = *v9;
      unsigned int v32 = v9[12];
      if (padded_len > v32) {
        unsigned int v32 = padded_len;
      }
      unsigned int v33 = get_padded_bytes(8 * v32, 8u);
      uint64_t v34 = *(void *)(v20 + 240);
      unsigned int v35 = v9[10];
      int v36 = v29 * *v9 * v35;
      uint64_t v37 = v33 + 4 * v36;
      uint64_t v38 = (v37 + 4 * v36);
      unsigned int v39 = v38 + 4 * v30 * *v9;
      unsigned int v40 = v9[12];
      uint64_t v41 = v39 + 4 * v30 * *v9 + 12 * v35 * v40 + 4 * (v40 + v35);
      uint64_t v167 = (unsigned int *)(v34 + v41);
      int v169 = v31;
      uint64_t v168 = v39 + 4 * v30 * *v9;
      uint64_t v153 = v41;
      uint64_t v163 = v39 + 4 * v30 * *v9 + 12 * v35 * v40;
      uint64_t v165 = v39;
      if (v35)
      {
        int v42 = 4 * v9[8];
        int v43 = 28 * v35;
        int v44 = v33 + v23 * *v9 * (8 * v27 * v35 + 8 * v26) + v40 * (12 * v35 + 4);
        uint64_t v45 = (void *)(v34 + v41);
        uint64_t v46 = v9[10];
        do
        {
          *uint64_t v45 = v34 + (v43 + v44);
          v45 += 3;
          v44 += v42;
          --v46;
        }
        while (v46);
        uint64_t v47 = (v43 + v44);
        __base = (_DWORD *)(v34 + v47);
        uint64_t v48 = 2 * v35;
        int v49 = (uint64_t **)v20;
        if (v48)
        {
          unsigned int v50 = v44 + 76 * v35;
          uint64_t v51 = (_DWORD *)(v34 + v47 + 16);
          do
          {
            *((void *)v51 - 2) = v34 + v50;
            *uint64_t v51 = -822083584;
            v51 += 6;
            v50 += v42;
            --v48;
          }
          while (v48);
        }
      }
      else
      {
        __base = (_DWORD *)(v34 + v41);
        int v49 = (uint64_t **)v20;
      }
      uint64_t v85 = v34 + v33;
      uint64_t v86 = v34 + v37;
      bzero(__dst, 4 * *((unsigned int *)v49 + 11));
      uint64_t v87 = *v9;
      if (v87)
      {
        unsigned int v88 = 0;
        unsigned int v89 = 0;
        uint64_t v90 = (uint64_t *)*((void *)v9 + 7);
        do
        {
          uint64_t v91 = *v90++;
          uint64_t v92 = *(void *)(v91 + 120);
          uint64_t v94 = *(void *)(v92 + 56);
          uint64_t v93 = *(void *)(v92 + 64);
          uint64_t v95 = *(void *)(v94 + 120);
          *(void *)(v95 + 120) = v85 + 4 * v88;
          *(void *)(v95 + 128) = v86 + 4 * v88;
          uint64_t v96 = *(void *)(v93 + 120);
          *(void *)(v96 + 136) = v34 + v38 + 4 * v89;
          *(void *)(v96 + 144) = v34 + v165 + 4 * v89;
          v89 += v30;
          v88 += v29;
          --v87;
        }
        while (v87);
      }
      uint64_t v160 = v86;
      uint64_t v166 = v85;
      float v97 = powf((float)(v171 + 5) / 6.0, *((float *)v9 + 11));
      unint64_t v155 = v171 - 1;
      if (v171 == 1)
      {
        size_t v139 = v9[10];
        unint64_t v75 = (unint64_t)v167;
LABEL_99:
        qsort((void *)v75, v139, 0x18uLL, (int (__cdecl *)(const void *, const void *))finishedpathcmp);
        uint64_t v146 = *(const void **)v75;
        uint64_t v148 = *(unsigned int *)(v75 + 8);
        *(_DWORD *)(*(void *)v75 + 4 * v148) = 1065353216;
        LODWORD(v75) = v148 + 1;
      }
      else
      {
        float v98 = v97;
        unint64_t v99 = 0;
        unsigned int __nel = 0;
        unsigned int v100 = (float *)(v34 + v168);
        uint64_t v172 = v34 + v163;
        uint64_t v164 = (v169 * v29);
        uint64_t __n = 4 * v164;
        int v170 = v23 * v27 * v169;
        uint64_t v151 = v153 + v34 + 8;
        uint64_t v154 = v153 + v34 + 16;
        float v101 = -2147500000.0;
        unint64_t v75 = (unint64_t)v167;
        do
        {
          float v102 = powf((float)(v99 + 6) / 6.0, *((float *)v9 + 11));
          if (v99)
          {
            unint64_t v103 = v9[10];
            if (v103)
            {
              unsigned int v104 = 0;
              unint64_t v105 = 0;
              long long v106 = (_DWORD *)(v34 + v168 + 8);
              do
              {
                *(float *)(v172 + 4 * v105) = (float)*(v106 - 1);
                uint64_t v107 = *v106;
                if (v105 != v107)
                {
                  memcpy((void *)(v166 + 4 * v104), (const void *)(v166 + 4 * (v107 * v164)), __n);
                  memcpy((void *)(v160 + 4 * v104), (const void *)(v160 + 4 * (*v106 * v164)), __n);
                  unint64_t v103 = v9[10];
                }
                ++v105;
                v104 += v170;
                v106 += 3;
              }
              while (v105 < v103);
              if (v103)
              {
                unint64_t v108 = 0;
                while (1)
                {
                  uint64_t v109 = *v9;
                  if (v109)
                  {
                    unsigned int v110 = 0;
                    uint64_t v111 = (uint64_t *)*((void *)v9 + 7);
                    do
                    {
                      uint64_t v112 = *v111++;
                      uint64_t v113 = *(void *)(*(void *)(*(void *)(v112 + 120) + 56) + 120);
                      *(void *)(v113 + 120) = v166 + 4 * (v164 * v108) + 4 * v110;
                      *(void *)(v113 + 128) = v160 + 4 * (v164 * v108) + 4 * v110;
                      v110 += v29;
                      --v109;
                    }
                    while (v109);
                  }
                  uint64_t v114 = forward_trans_decoder(a1, __nel_4, a3, v99, v108, (uint64_t)&v100[3 * v9[12] * v108], *(float *)(v172 + 4 * v108));
                  if (v114) {
                    break;
                  }
                  unint64_t v115 = v9[10];
                  if (v108 < (v115 - 1))
                  {
                    uint64_t v116 = *v9;
                    if (v116)
                    {
                      uint64_t v117 = (uint64_t *)*((void *)v9 + 7);
                      do
                      {
                        uint64_t v118 = *v117++;
                        uint64_t v119 = *(void *)(*(void *)(*(void *)(v118 + 120) + 56) + 120);
                        --*(_DWORD *)(v119 + 152);
                        --v116;
                      }
                      while (v116);
                    }
                  }
                  if (++v108 >= v115)
                  {
                    uint64_t v120 = v9[12];
                    if (v115)
                    {
                      int v121 = 0;
                      for (uint64_t i = 0; i != v115; ++i)
                      {
                        if (v120)
                        {
                          float v123 = *(float *)(v75 + 24 * i + 12);
                          int v124 = v121;
                          uint64_t v125 = v120;
                          do
                          {
                            v100[3 * v124] = v123 + v100[3 * v124];
                            ++v124;
                            --v125;
                          }
                          while (v125);
                        }
                        v121 += v120;
                      }
                    }
                    goto LABEL_67;
                  }
                }
LABEL_95:
                uint64_t v52 = v114;
                uint64_t v147 = *v150;
                goto LABEL_103;
              }
            }
            LODWORD(v115) = 0;
            LODWORD(v120) = v9[12];
LABEL_67:
            qsort(v100, (v115 * v120), 0xCuLL, (int (__cdecl *)(const void *, const void *))cmpvaluefunc);
            unint64_t v126 = v9[10];
            unsigned int v127 = __nel;
            if (__nel > v126)
            {
              unint64_t v128 = __nel - v126;
              uint64_t v129 = &__base[6 * v126 + 4];
              do
              {
                *uint64_t v129 = -822083584;
                v129 += 6;
                --v128;
              }
              while (v128);
              unsigned int v127 = v126;
            }
            if (v126)
            {
              unint64_t v130 = 0;
              float v132 = (unsigned int *)v151;
              uint64_t v131 = (unsigned int *)(v34 + v168 + 4);
              do
              {
                if (*v131 == 1)
                {
                  unsigned int v133 = v127 + 1;
                  uint64_t v134 = (float *)&__base[6 * v127];
                  memcpy(*(void **)v134, *(const void **)&v167[6 * v131[1]], 4 * *v132);
                  float v135 = *((float *)v131 - 1);
                  v134[3] = v135;
                  v134[4] = v135 / v102;
                  *(float *)(*(void *)v134 + 4 * v99) = (float)*v131;
                  *((_DWORD *)v134 + 2) = v99 + 1;
                  unint64_t v75 = (unint64_t)v167;
                  unint64_t v126 = (unint64_t)&v100[3 * v130 + 3 * v9[10]];
                  uint64_t v136 = *(void *)v126;
                  v131[1] = *(_DWORD *)(v126 + 8);
                  *(void *)(v131 - 1) = v136;
                  LODWORD(v126) = v9[10];
                  unsigned int v127 = v133;
                }
                ++v130;
                v131 += 3;
                v132 += 6;
              }
              while (v130 < v126);
            }
            uint64_t v137 = (int (__cdecl *)(const void *, const void *))cmpdecoderIndexfunc;
            if (v127)
            {
              unsigned int __nel = v127;
              qsort(__base, v127, 0x18uLL, (int (__cdecl *)(const void *, const void *))finishedpathcmp);
              LODWORD(v126) = v9[10];
              float v101 = *(float *)&__base[6 * (v126 - 1) + 4];
              uint64_t v137 = (int (__cdecl *)(const void *, const void *))cmpdecoderIndexfunc;
            }
            else
            {
              unsigned int __nel = 0;
            }
          }
          else
          {
            uint64_t v114 = forward_trans_decoder(a1, v49, a3, 0, 0, (uint64_t)v100, 0.0);
            if (v114) {
              goto LABEL_95;
            }
            LODWORD(v126) = v9[12];
            uint64_t v137 = (int (__cdecl *)(const void *, const void *))cmpvaluefunc;
          }
          qsort(v100, v126, 0xCuLL, v137);
          float v138 = *v100;
          size_t v139 = v9[10];
          if (v139)
          {
            size_t v140 = 0;
            uint64_t v142 = (float *)v154;
            uint64_t v141 = (float *)(v34 + v168 + 8);
            unint64_t v143 = v99 + 1;
            do
            {
              if (v99)
              {
                uint64_t v144 = *(unsigned int *)v141;
                if (v140 != v144)
                {
                  memcpy(*((void **)v142 - 2), *(const void **)(v75 + 24 * v144), 4 * v99);
                  unint64_t v143 = v99 + 1;
                  size_t v139 = v9[10];
                }
              }
              float v145 = *(v141 - 2);
              *(v142 - 1) = v145;
              *uint64_t v142 = v145 / v102;
              *(float *)(*((void *)v142 - 2) + 4 * v99) = (float)*((unsigned int *)v141 - 1);
              *((_DWORD *)v142 - 2) = v143;
              if (v138 < *(v142 - 1)) {
                float v138 = *(v142 - 1);
              }
              ++v140;
              v142 += 6;
              v141 += 3;
            }
            while (v140 < v139);
          }
          else
          {
            size_t v139 = 0;
            unint64_t v143 = v99 + 1;
          }
          int v49 = __nel_4;
          if (v143 >= v155) {
            break;
          }
          unint64_t v99 = v143;
        }
        while ((float)(v138 / v98) > v101);
        if (!__nel) {
          goto LABEL_99;
        }
        qsort(__base, __nel, 0x18uLL, (int (__cdecl *)(const void *, const void *))finishedpathcmp);
        uint64_t v146 = *(const void **)__base;
        LODWORD(v75) = __base[2];
      }
      memcpy(__dst, v146, 4 * v75);
    }
    uint64_t v52 = 0;
    *((_DWORD *)v49 + 11) = v75;
  }
  else
  {
    log_OutText(**(void **)a2, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, (uint64_t)v150);
    return 7;
  }
  return v52;
}

void *free_trans_decoder(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = (void *)result[15];
      if (v3)
      {
        uint64_t v4 = *(unsigned int *)v3;
        fi_layer_free(v3[8]);
        fi_layer_free(v3[9]);
        fi_layer_free(v3[10]);
        fi_layer_free(v3[11]);
        if (v4)
        {
          uint64_t v5 = 0;
          uint64_t v6 = 8 * v4;
          do
          {
            fi_layer_free(*(void *)(v3[7] + v5));
            v5 += 8;
          }
          while (v6 != v5);
        }
        if (v3[7])
        {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
          v3[7] = 0;
        }
        (*(void (**)(void, void *))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v7 = *(void *)(v2 + 16);
      uint64_t v8 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v8(v7, v1);
    }
  }
  return result;
}

uint64_t trans_decoder_update_shape(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned int **)(a1 + 120);
  uint64_t v9 = *(uint64_t **)a1;
  if (!v8)
  {
    uint64_t v13 = *v9;
    uint64_t v14 = "out of memory!";
    goto LABEL_5;
  }
  uint64_t v11 = *v8;
  long long v12 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v12;
  if (*(_DWORD *)a2 > 2u)
  {
    uint64_t v13 = *v9;
    uint64_t v14 = "Currently trans_decoder layer only support 1D or 2D input";
LABEL_5:
    log_OutText(v13, (uint64_t)"FastInfer", 0, 0, (uint64_t)v14, a6, a7, a8, v22);
    return 7;
  }
  uint64_t v16 = (long long *)(a1 + 20);
  if (v11)
  {
    uint64_t v17 = 0;
    uint64_t v18 = *((void *)v8 + 7);
    uint64_t v19 = 8 * v11;
    while (1)
    {
      uint64_t v20 = *(void *)(*(void *)(*(void *)(*(void *)(v18 + v17) + 120) + 64) + 120);
      long long v21 = *v16;
      *(_DWORD *)(v20 + 44) = *(_DWORD *)(a1 + 36);
      *(_OWORD *)(v20 + 28) = v21;
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(*((void *)v8 + 7) + v17) + 144))();
      if (result) {
        break;
      }
      uint64_t v18 = *((void *)v8 + 7);
      v17 += 8;
      if (v19 == v17) {
        goto LABEL_11;
      }
    }
  }
  else
  {
LABEL_11:
    uint64_t result = (*(uint64_t (**)(void))(*((void *)v8 + 8) + 144))();
    if (!result)
    {
      if ((*(_DWORD *)(*((void *)v8 + 8) + 40) - 1) >= 2)
      {
        uint64_t v13 = **(void **)a1;
        uint64_t v14 = "dense out: output shape error";
        goto LABEL_5;
      }
      uint64_t result = (*(uint64_t (**)(void))(*((void *)v8 + 11) + 144))();
      if (!result)
      {
        *(_DWORD *)(a1 + 40) = 1;
        *(_DWORD *)(a1 + 44) = v8[8];
        *(_DWORD *)(a1 + 56) = 4;
        uint64_t result = (*(uint64_t (**)(void))(*((void *)v8 + 9) + 144))();
        if (!result) {
          return (*(uint64_t (**)(void))(*((void *)v8 + 10) + 144))();
        }
      }
    }
  }
  return result;
}

uint64_t trans_decoder_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    uint64_t v12 = *v9;
    padded_uint64_t bytes = get_padded_bytes(4 * v9[5] * v9[8], 8u);
    if (v12)
    {
      uint64_t v14 = 0;
      uint64_t v15 = 8 * v12;
      while (1)
      {
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(*((void *)v9 + 7) + v14) + 152))();
        if (result) {
          break;
        }
        padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
        v14 += 8;
        if (v15 == v14) {
          goto LABEL_6;
        }
      }
    }
    else
    {
LABEL_6:
      uint64_t result = (*(uint64_t (**)(void))(*((void *)v9 + 8) + 152))();
      if (!result)
      {
        unsigned int v17 = get_padded_bytes(padded_bytes, 8u);
        uint64_t result = (*(uint64_t (**)(void))(*((void *)v9 + 9) + 152))();
        if (!result)
        {
          unsigned int v18 = get_padded_bytes(v17, 8u);
          uint64_t result = (*(uint64_t (**)(void))(*((void *)v9 + 11) + 152))();
          if (!result)
          {
            *a2 = get_padded_bytes(v18, 8u);
            *a3 = 0;
            log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v19, v20, v21, *(unsigned int *)(a1 + 96));
            log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v22, v23, v24, *a2);
            return 0;
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v25);
    return 7;
  }
  return result;
}

uint64_t trans_decoder_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    uint64_t v10 = *v9;
    if (v10)
    {
      uint64_t v11 = 0;
      unsigned int v12 = 0;
      unsigned int v13 = 0;
      uint64_t v14 = *((void *)v9 + 7);
      uint64_t v15 = 8 * v10;
      do
      {
        uint64_t v16 = *(uint64_t (**)(void))(*(void *)(v14 + v11) + 160);
        if (v16)
        {
          uint64_t result = v16();
          if (result) {
            return result;
          }
          uint64_t v14 = *((void *)v9 + 7);
          unsigned int v13 = *(_DWORD *)(*(void *)(v14 + v11) + 248);
          if (v13 > v12) {
            unsigned int v12 = *(_DWORD *)(*(void *)(v14 + v11) + 248);
          }
        }
        v11 += 8;
      }
      while (v15 != v11);
    }
    else
    {
      unsigned int v13 = 0;
      unsigned int v12 = 0;
    }
    unsigned int v19 = v13;
    trans_decoder_get_reserved_glbBuf_bytes(a1, &v19);
    uint64_t result = 0;
    *(_DWORD *)(a1 + 248) = v19 + v12;
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v18);
    return 7;
  }
  return result;
}

uint64_t trans_decoder_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned int **)(a1 + 120);
  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 72);
    uint64_t v10 = *v8;
    *((void *)v8 + 12) = v9;
    padded_uint64_t bytes = get_padded_bytes(4 * v8[5] * v8[8], 8u);
    if (v10)
    {
      uint64_t v11 = 0;
      uint64_t v12 = 8 * v10;
      while (1)
      {
        uint64_t v13 = *(void *)(*((void *)v8 + 7) + v11);
        if (!v13) {
          return 10;
        }
        uint64_t result = fi_layer_find_weights_via_offset(v13, v9, &padded_bytes);
        if (result) {
          return result;
        }
        padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
        v11 += 8;
        if (v12 == v11) {
          goto LABEL_7;
        }
      }
    }
    else
    {
LABEL_7:
      uint64_t result = fi_layer_find_weights_via_offset(*((void *)v8 + 8), v9, &padded_bytes);
      if (!result)
      {
        padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
        uint64_t result = fi_layer_find_weights_via_offset(*((void *)v8 + 9), v9, &padded_bytes);
        if (!result)
        {
          padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
          uint64_t result = fi_layer_find_weights_via_offset(*((void *)v8 + 11), v9, &padded_bytes);
          if (!result)
          {
            get_padded_bytes(padded_bytes, 8u);
            return 0;
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v15);
    return 7;
  }
  return result;
}

uint64_t trans_decoder_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(unsigned int **)(a1 + 120);
  unsigned int v18 = 0;
  if (v9)
  {
    uint64_t v10 = *v9;
    trans_decoder_get_reserved_glbBuf_bytes(a1, &v18);
    if (v10)
    {
      uint64_t v11 = 0;
      uint64_t v12 = v18;
      uint64_t v13 = 8 * v10;
      do
      {
        uint64_t v14 = *(void *)(*((void *)v9 + 7) + v11);
        *(void *)(v14 + 240) = *(void *)(a1 + 240) + v12;
        *(_DWORD *)(v14 + 248) = *(_DWORD *)(a1 + 248) - v12;
        uint64_t v15 = *(void (**)(void))(v14 + 168);
        if (v15) {
          v15();
        }
        v11 += 8;
      }
      while (v13 != v11);
    }
    return 0;
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
}

uint64_t trans_decoder_reset(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 120);
  uint64_t v2 = *v1;
  if (!v2) {
    return 0;
  }
  uint64_t v4 = 0;
  uint64_t v5 = 8 * v2;
  while (!(*(unsigned int (**)(void))(*(void *)(*((void *)v1 + 7) + v4) + 176))())
  {
    v4 += 8;
    if (v5 == v4) {
      return 0;
    }
  }
  log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_decoder network reset failed!", v6, v7, v8, v10);
  return 7;
}

uint64_t forward_trans_decoder(uint64_t a1, uint64_t **a2, uint64_t a3, int a4, int a5, uint64_t a6, float a7)
{
  if (!a2) {
    return 0;
  }
  unsigned int v55 = *a2;
  uint64_t v11 = a2[15];
  unsigned int padded_len = get_padded_len(*((unsigned int *)v11 + 5), 8u);
  unsigned int v16 = *((_DWORD *)v11 + 12);
  if (v16 <= padded_len) {
    size_t v17 = padded_len;
  }
  else {
    size_t v17 = v16;
  }
  unsigned int v18 = (float *)a2[30];
  unsigned int v19 = &v18[v17];
  uint64_t v20 = *(unsigned int *)v11;
  if (v20) {
    uint64_t v21 = &v18[v17];
  }
  else {
    uint64_t v21 = (float *)a2[30];
  }
  if (v20) {
    uint64_t v22 = (float *)a2[30];
  }
  else {
    uint64_t v22 = &v18[v17];
  }
  if (a7 > 0.0)
  {
    size_t v23 = v17;
    (*(void (**)(uint64_t))(v11[9] + 128))(a1);
    size_t v17 = v23;
  }
  uint64_t v24 = *((unsigned int *)v11 + 5);
  if (v24)
  {
    uint64_t v25 = v11[12];
    unsigned int v26 = v24 * a4;
    unsigned int v27 = v21;
    do
    {
      *unsigned int v27 = *(float *)(v25 + 4 * v26) + *v27;
      ++v27;
      ++v26;
      --v24;
    }
    while (v24);
  }
  uint64_t v56 = a1;
  if (v20)
  {
    unint64_t v28 = 0;
    uint64_t v29 = v20;
    unint64_t v30 = (v20 - 1);
    while (1)
    {
      size_t v31 = v17;
      bzero(v22, v17);
      uint64_t v32 = v11[7];
      *(void *)(*(void *)(*(void *)(*(void *)(*(void *)(v32 + 8 * v28) + 120) + 64) + 120) + 104) = a3;
      uint64_t v33 = (*(uint64_t (**)(uint64_t))(*(void *)(v32 + 8 * v28) + 128))(v56);
      if (v33) {
        break;
      }
      if (v22 == v18) {
        uint64_t v34 = v19;
      }
      else {
        uint64_t v34 = v18;
      }
      if (v28 < v30) {
        uint64_t v22 = v34;
      }
      ++v28;
      size_t v17 = v31;
      if (v29 == v28) {
        goto LABEL_25;
      }
    }
    uint64_t v35 = v33;
    uint64_t v37 = v55;
    int v36 = "trans_decoder forward trans_dec layer failed!";
    goto LABEL_33;
  }
LABEL_25:
  if (v22 != v18)
  {
    uint64_t v35 = 7;
    int v36 = "(Should not be here)trans_decoder buffer switching error";
LABEL_32:
    uint64_t v37 = v55;
LABEL_33:
    log_OutText(*v37, (uint64_t)"FastInfer", 0, 0, (uint64_t)v36, v13, v14, v15, a6);
    return v35;
  }
  size_t v38 = 4 * v17;
  unsigned int v39 = v19;
  unsigned int v40 = v19;
  size_t v41 = v17;
  bzero(v40, 4 * v17);
  uint64_t v42 = (*(uint64_t (**)(uint64_t))(v11[8] + 128))(v56);
  if (v42)
  {
    uint64_t v35 = v42;
    int v36 = "trans_decoder forward norm layer failed!";
    goto LABEL_32;
  }
  bzero(v18, v38);
  uint64_t v43 = (*(uint64_t (**)(uint64_t))(v11[11] + 128))(v56);
  if (v43)
  {
    uint64_t v35 = v43;
    int v36 = "att forward dense q failed!";
    goto LABEL_32;
  }
  bzero(v39, 4 * *((unsigned int *)v11 + 12));
  uint64_t v44 = *((unsigned int *)v11 + 12);
  if (!v44) {
    return 0;
  }
  float v45 = 0.0;
  uint64_t v46 = v18;
  uint64_t v47 = *((unsigned int *)v11 + 12);
  do
  {
    float v48 = *v46++;
    float v45 = v45 + expf(v48);
    --v47;
  }
  while (v47);
  float v49 = logf(v45);
  uint64_t v50 = v44;
  do
  {
    v18[v41] = *v18 - v49;
    ++v18;
    --v50;
  }
  while (v50);
  uint64_t v51 = (_DWORD *)(a6 + 8);
  do
  {
    uint64_t v35 = 0;
    *(v51 - 2) = LODWORD(v39[v50]);
    *(v51 - 1) = v50;
    *uint64_t v51 = a5;
    ++v50;
    v51 += 3;
  }
  while (v44 != v50);
  return v35;
}

uint64_t trans_decoder_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = *(_DWORD **)(a1 + 120);
  unsigned int padded_len = get_padded_len(v3[5], 8u);
  unsigned int v5 = padded_len;
  unsigned int v6 = v3[12];
  if (v6 <= padded_len) {
    unsigned int v6 = padded_len;
  }
  padded_uint64_t bytes = get_padded_bytes(8 * v6, 8u);
  unsigned int v8 = v3[10];
  int v9 = v3[8];
  int v10 = v3[12];
  int v11 = padded_bytes + 12 * v8 * v10 + 8 * v5 * (*v3 * v9 * v8 + v3[7] * *v3);
  BOOL v12 = v8 >= 2;
  unsigned int v13 = 72 * v8 + 8 * v8 * v9 + 4 * (v8 * v9 + v8 + v10) + v11;
  if (v12) {
    unsigned int v14 = v13;
  }
  else {
    unsigned int v14 = v11;
  }
  uint64_t result = get_padded_bytes(v14, 8u);
  *a2 = result;
  return result;
}

unint64_t cmpvaluefunc(float *a1, float *a2)
{
  return (__PAIR64__(*a1 < *a2, *a2) - COERCE_UNSIGNED_INT(*a1)) >> 32;
}

unint64_t finishedpathcmp(uint64_t a1, uint64_t a2)
{
  return (__PAIR64__(*(float *)(a1 + 16) < *(float *)(a2 + 16), *(_DWORD *)(a2 + 16)) - *(unsigned int *)(a1 + 16)) >> 32;
}

uint64_t cmpdecoderIndexfunc(uint64_t a1, uint64_t a2)
{
  return (*(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8));
}

uint64_t create_conv2d_layer(uint64_t *a1, long long *a2, uint64_t **a3, uint64_t ***a4)
{
  unsigned int v13 = 0;
  uint64_t v9 = create_conv_layer(a1, a2, a3, &v13);
  if (v9)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"create conv layer failed!", v6, v7, v8, v12);
    int v10 = v13;
  }
  else
  {
    int v10 = v13;
    v13[1] = (uint64_t *)1;
    v10[16] = (uint64_t *)forward_conv_layer;
    v10[17] = (uint64_t *)free_conv_buffer;
    v10[18] = (uint64_t *)conv2d_layer_update_shape;
    v10[19] = (uint64_t *)conv_layer_wanted_wb_len;
  }
  *a4 = v10;
  return v9;
}

uint64_t conv2d_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a2 == 3)
  {
    int v10 = *(_DWORD **)(a1 + 120);
    long long v11 = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = a2[4];
    *(_OWORD *)(a1 + 20) = v11;
    uint64_t result = get_padding_size(*(uint64_t **)a1, v10, *(_DWORD *)(a1 + 8), a2, v10 + 14, v10 + 15, v10 + 9);
    if (!result)
    {
      int v13 = v10[4];
      *(_DWORD *)(a1 + 40) = 3;
      *(_DWORD *)(a1 + 44) = v13;
      *(_DWORD *)(a1 + 48) = v10[15];
      *(_DWORD *)(a1 + 52) = v10[14];
      *(_DWORD *)(a1 + 56) = a2[4];
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"conv2d requires 3D input data", a6, a7, a8, v14);
    return 7;
  }
  return result;
}

uint64_t config_pooling1d_layer(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  return config_pooling_layer(a1, 1, a2, 1, a3, a4, a5);
}

uint64_t create_pooling1d_layer(uint64_t *a1, int a2, long long *a3, uint64_t **a4, uint64_t ***a5)
{
  uint64_t v14 = 0;
  uint64_t v10 = create_pooling_layer(a1, a2, a3, a4, &v14);
  if (v10)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"create pooling layer failed!", v7, v8, v9, v13);
    long long v11 = v14;
  }
  else
  {
    long long v11 = v14;
    v14[18] = (uint64_t *)pooling1d_layer_update_shape;
  }
  *a5 = v11;
  return v10;
}

uint64_t pooling1d_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a2 == 2)
  {
    uint64_t v10 = *(int **)(a1 + 120);
    int v11 = *(_DWORD *)(a1 + 8);
    long long v12 = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = a2[4];
    *(_OWORD *)(a1 + 20) = v12;
    if ((v11 & 0xFFFFFFFE) == 0xC) {
      *uint64_t v10 = a2[1];
    }
    uint64_t v13 = v10 + 14;
    uint64_t v14 = v10 + 15;
    uint64_t result = get_padding_size(*(uint64_t **)a1, v10, v11, a2, (unsigned int *)v10 + 14, (unsigned int *)v10 + 15, v10 + 9);
    if (!result)
    {
      int v16 = *v14;
      *(_DWORD *)(a1 + 40) = 2;
      *(_DWORD *)(a1 + 44) = v16;
      *(_DWORD *)(a1 + 48) = *v13;
      *(_DWORD *)(a1 + 56) = a2[4];
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Current conv layer only support input dim 2 or 3", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t create_reshape_layer(uint64_t *a1, long long *a2, uint64_t ***a3)
{
  uint64_t v6 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  uint64_t v10 = v6;
  if (v6
    && (*uint64_t v6 = a1,
        uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 44),
        (v10[15] = (uint64_t *)v11) != 0))
  {
    long long v12 = (_OWORD *)v11;
    uint64_t result = 0;
    long long v14 = *a2;
    long long v15 = a2[1];
    *(_OWORD *)((char *)v12 + 28) = *(long long *)((char *)a2 + 28);
    *long long v12 = v14;
    v12[1] = v15;
    *((_DWORD *)v10 + 2) = 72;
    v10[16] = (uint64_t *)forward_reshape_layer;
    v10[17] = (uint64_t *)free_reshape_buffer;
    v10[18] = (uint64_t *)reshape_layer_update_shape;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v16);
    free_reshape_buffer(v10);
    uint64_t result = 10;
  }
  *a3 = v10;
  return result;
}

uint64_t forward_reshape_layer(uint64_t a1, uint64_t a2, const void *a3, void *a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(a2 + 120);
  unsigned int v9 = 0;
  if (*(_DWORD *)(v5 + 16) == 1)
  {
    uint64_t result = 0;
    *(_DWORD *)(a5 + 16) = 0;
  }
  else
  {
    uint64_t result = fi_shape_get_size((int *)(a2 + 40), (int *)&v9);
    if (!result)
    {
      memcpy(a4, a3, 4 * v9);
      return 0;
    }
  }
  return result;
}

void *free_reshape_buffer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      if (result[15])
      {
        (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        v1[15] = 0;
      }
      uint64_t v3 = *(void *)(v2 + 16);
      uint64_t v4 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v4(v3, v1);
    }
  }
  return result;
}

uint64_t reshape_layer_update_shape(uint64_t a1, int *a2)
{
  uint64_t v15 = 0;
  uint64_t v3 = *(unsigned int **)(a1 + 120);
  int v4 = a2[4];
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v4;
  int v5 = a2[4];
  *(_OWORD *)(a1 + 40) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 56) = v5;
  uint64_t result = fi_shape_get_size(a2, (int *)&v15 + 1);
  if (!result)
  {
    unsigned int v7 = *v3;
    *(_DWORD *)(a1 + 40) = *v3;
    if (v7)
    {
      unsigned int v8 = v3[1];
      if (v8) {
        *(_DWORD *)(a1 + 44) = v8;
      }
      if (v7 >= 2)
      {
        unsigned int v9 = v3[2];
        if (v9) {
          *(_DWORD *)(a1 + 44) = v9;
        }
        if (v7 >= 3)
        {
          unsigned int v10 = v3[3];
          if (v10) {
            *(_DWORD *)(a1 + 44) = v10;
          }
        }
      }
    }
    uint64_t result = fi_shape_get_size((int *)(a1 + 40), (int *)&v15);
    if (!result)
    {
      if (v15 <= HIDWORD(v15))
      {
        return 0;
      }
      else
      {
        log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"invalid reshape operation!", v11, v12, v13, v14);
        return 7;
      }
    }
  }
  return result;
}

uint64_t lstm_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, int *a3)
{
  unsigned int v37 = 0;
  unsigned int v38 = 1;
  BOOL is_enabled = fi_feat_is_enabled(*(void *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  uint64_t v7 = *(unsigned int *)(a1 + 12);
  int padded_len = get_padded_len(v7, 8u);
  uint64_t input_dim = fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v37);
  if (input_dim) {
    return input_dim;
  }
  int v10 = get_padded_len(v37, 8u);
  uint64_t v11 = lstm_layer_impl_type(a1, &v38);
  if (v11)
  {
    uint64_t input_dim = v11;
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"get LSTM impl type failed!", v12, v13, v14, v36);
    return input_dim;
  }
  if (v38 >= 2 && v38 != 3)
  {
    if (v38 != 2)
    {
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"invalid LSTM type: %u", v12, v13, v14, v38);
      return 7;
    }
    uint64_t v15 = *(unsigned int *)(*(void *)(*(void *)(a1 + 120) + 8) + 16);
    int v16 = get_padded_len(v15, 8u);
    if ((v15 & 3) != 0)
    {
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"num of singulars must can be divided by 4, but got: %u", v17, v18, v19, v15);
      return 7;
    }
    uint64_t input_dim = 0;
    *a2 = 4 * (v15 * (v10 + padded_len) + 4 * v7 * v16);
    int v34 = 16 * v7;
LABEL_39:
    *a3 = v34;
    return input_dim;
  }
  uint64_t v20 = *(int **)(a1 + 72);
  if (!v20)
  {
    if (is_enabled)
    {
      int v28 = get_padded_len((4 * v7), 8u);
      int v29 = 0;
LABEL_31:
      uint64_t input_dim = 0;
      BOOL v30 = (v38 & 0xFFFFFFFD) == 1;
      if ((v38 & 0xFFFFFFFD) == 1) {
        char v31 = 3;
      }
      else {
        char v31 = 5;
      }
      int v32 = v29 << v31;
      int v33 = 4 * padded_len;
      if ((v38 & 0xFFFFFFFD) == 1) {
        int v33 = v28;
      }
      *a2 = v32 + 4 * (v37 + v7) * v33;
      int v34 = 4 * v28;
      if (!v30) {
        int v34 = 16 * padded_len;
      }
      goto LABEL_39;
    }
    goto LABEL_29;
  }
  if ((v20[1] & 2) == 0 || !is_enabled)
  {
    if (is_enabled) {
      goto LABEL_26;
    }
LABEL_29:
    uint64_t input_dim = 0;
    *a2 = 16 * v7 * (v10 + padded_len);
    *a3 = 16 * v7;
    return input_dim;
  }
  if (v20[2])
  {
LABEL_26:
    if (v20[2])
    {
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"BSR and BSC haven't been implemented in LSTM yet!", v12, v13, v14, v36);
      return 7;
    }
    int v28 = get_padded_len((4 * v7), 8u);
    int v29 = *v20;
    goto LABEL_31;
  }
  int v21 = get_padded_len((4 * v7), 8u);
  unsigned int v22 = v38;
  BOOL v23 = (v38 & 0xFFFFFFFD) == 1;
  if ((v38 & 0xFFFFFFFD) == 1) {
    char v24 = 3;
  }
  else {
    char v24 = 5;
  }
  int v25 = *v20 << v24;
  int v26 = 4 * padded_len;
  if ((v38 & 0xFFFFFFFD) == 1) {
    int v26 = v21;
  }
  *a2 = v25 + 4 * (v37 + v7) * v26;
  int v27 = 4 * v21;
  if (!v23) {
    int v27 = 16 * padded_len;
  }
  *a3 = v27;
  uint64_t input_dim = 0;
  if (v22 == 3) {
    *a2 += 12 * get_padded_len(v7, 8u);
  }
  return input_dim;
}

uint64_t get_lstm_glbBufBytes(uint64_t *a1, char a2, uint64_t a3, _DWORD *a4)
{
  int padded_len = get_padded_len(a3, 8u);
  int v11 = 16;
  switch(a2)
  {
    case 0:
      goto LABEL_3;
    case 1:
    case 2:
    case 3:
      padded_len *= 4;
      int v11 = 8;
LABEL_3:
      uint64_t v12 = 0;
      *a4 = v11 * padded_len;
      break;
    default:
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"not supported lstm impl!", v8, v9, v10, v14);
      uint64_t v12 = 7;
      break;
  }
  return v12;
}

uint64_t create_lstm_layer_f32(uint64_t *a1, uint64_t *a2, long long *a3, void *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v15) {
    goto LABEL_10;
  }
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16);
  if (!v16) {
    goto LABEL_10;
  }
  uint64_t v17 = (void *)v16;
  uint64_t v18 = (_OWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 40);
  if (!v18) {
    goto LABEL_10;
  }
  uint64_t v19 = v18;
  long long v20 = *a3;
  *(_OWORD *)((char *)v18 + 12) = *(long long *)((char *)a3 + 12);
  *uint64_t v18 = v20;
  uint64_t v21 = *a2;
  *(_DWORD *)(v15 + 16) = *((_DWORD *)a2 + 2);
  *(void *)(v15 + 8) = v21;
  uint64_t v22 = *((unsigned int *)a2 + 1);
  *(void *)uint64_t v15 = a1;
  if (a4) {
    *(void *)(v15 + 60) = *a4;
  }
  uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v22, 4);
  *uint64_t v17 = v23;
  if (v23
    && (v17[1] = v19,
        *(void *)(v15 + 160) = lstm_layer_request_glbBuf,
        uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v22, 4),
        (*((void *)v19 + 4) = v24) != 0))
  {
    *(void *)(v15 + 120) = v17;
    *(void *)(v15 + 128) = forward_lstm_layer;
    *(void *)(v15 + 136) = free_lstm_buffer;
    *(void *)(v15 + 200) = lstm_layer_load_state;
    *(void *)(v15 + 144) = lstm_layer_update_shape;
    *(void *)(v15 + 152) = lstm_layer_wanted_wb_len;
    if (a5)
    {
      uint64_t result = 0;
      *(void *)(v15 + 256) = *(void *)(a5 + 24);
      *(_DWORD *)(v15 + 264) = *(_DWORD *)(a5 + 16);
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, use v0.0.0", v12, v13, v14, v26);
      uint64_t result = 0;
      *(void *)(v15 + 256) = 0;
      *(_DWORD *)(v15 + 264) = 0;
    }
  }
  else
  {
LABEL_10:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v26);
    free_lstm_buffer((void *)v15);
    uint64_t result = 10;
  }
  *a6 = v15;
  return result;
}

uint64_t lstm_layer_request_glbBuf(uint64_t a1)
{
  uint64_t result = get_lstm_glbBufBytes(*(uint64_t **)a1, **(_DWORD **)(*(void *)(a1 + 120) + 8), *(unsigned int *)(a1 + 12), (_DWORD *)(a1 + 248));
  if (result)
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"get lstm gobal buffer bytes failed!", v3, v4, v5, v6);
    return 7;
  }
  return result;
}

uint64_t lstm_layer_load_state(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = **(void ***)(a1 + 120);
  if (v9)
  {
    memcpy(v9, a2, 4 * *(unsigned int *)(a1 + 12));
    int v11 = *(void **)(*(void *)(*(void *)(a1 + 120) + 8) + 32);
    if (v11)
    {
      memcpy(v11, &a2[4 * *(unsigned int *)(a1 + 12)], 4 * *(unsigned int *)(a1 + 12));
      return 0;
    }
    uint64_t v13 = **(void **)a1;
    uint64_t v14 = "lstm cell setting null pointer!";
  }
  else
  {
    uint64_t v13 = **(void **)a1;
    uint64_t v14 = "lstm state setting null pointer!";
  }
  log_OutText(v13, (uint64_t)"FastInfer", 0, 0, (uint64_t)v14, a6, a7, a8, v15);
  return 10;
}

uint64_t lstm_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)a2 == 2)
  {
    int v8 = *(_DWORD *)(*(void *)(*(void *)(a1 + 120) + 8) + 12);
    int v9 = *(_DWORD *)(a2 + 16);
    *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = v9;
    if (v8 == 1)
    {
      uint64_t v10 = 0;
      *(_DWORD *)(a1 + 40) = 2;
      int v11 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a1 + 48) = v11;
    }
    else
    {
      uint64_t v10 = 0;
      int v12 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 40) = 1;
      *(_DWORD *)(a1 + 44) = v12;
    }
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 16);
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently only supports 2D LSTM, BLSTM!", a6, a7, a8, vars0);
    return 7;
  }
  return v10;
}

uint64_t forward_lstm_layer_f32(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v55 = *(uint64_t **)a1;
  uint64_t v4 = *(void *)(*(void *)(a1 + 120) + 8);
  uint64_t v5 = *(void **)(a1 + 240);
  unsigned int v6 = *(_DWORD *)(v4 + 16);
  int v52 = *(_DWORD *)(v4 + 12);
  unsigned int v7 = *(_DWORD *)(a1 + 16) & 0xFFFFFFFD;
  BOOL is_enabled = fi_feat_is_enabled(*(void *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  BOOL v9 = is_enabled;
  uint64_t v10 = *(void *)(a1 + 72);
  if (v10) {
    int v11 = is_enabled & (*(unsigned __int8 *)(v10 + 4) >> 1);
  }
  else {
    int v11 = 0;
  }
  uint64_t v12 = *(unsigned int *)(a1 + 12);
  v61[0] = 1;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  uint64_t v56 = 0;
  uint64_t input_dim = lstm_layer_impl_type(a1, v61);
  if (!input_dim)
  {
    uint64_t lstm_step_f = get_lstm_step_f(&v56, v61[0]);
    if (lstm_step_f)
    {
      uint64_t input_dim = lstm_step_f;
      log_OutText(*v55, (uint64_t)"FastInfer", 0, 0, (uint64_t)"get lstm step forward function failed!", v15, v16, v17, v46);
      return input_dim;
    }
    int v19 = v11 ^ 1;
    int v20 = v61[0];
    if (LODWORD(v61[0]) == 2) {
      int v19 = 1;
    }
    if (!v5)
    {
      log_OutText(*v55, (uint64_t)"FastInfer", 0, 0, (uint64_t)"lstm buf is NULL, do you forget to set pNet->glbBuf?", v15, v16, v17, v46);
      return 7;
    }
    int v49 = v19;
    uint64_t input_dim = fi_shape_get_input_dim((int *)(a1 + 20), (int *)v61 + 1);
    if (!input_dim)
    {
      unsigned int padded_len = get_padded_len(HIDWORD(v61[0]), 8u);
      DWORD1(v59) = v7 == 1;
      int v21 = v61[0];
      if (v20 == 2 || !v9 || LODWORD(v61[0]) == 2)
      {
        LODWORD(v22) = 0;
      }
      else
      {
        uint64_t v22 = *(void *)(a1 + 72);
        if (v22)
        {
          LODWORD(v59) = *(_DWORD *)(v22 + 4) & 1;
          int v23 = v49;
          DWORD2(v59) = v49;
          DWORD1(v57) = 0;
          LODWORD(v22) = *(_DWORD *)(v22 + 4) & 1;
LABEL_20:
          LODWORD(v57) = v22;
          DWORD2(v57) = v23;
          get_padded_len(HIDWORD(v61[0]), 8u);
          BOOL v24 = fi_feat_is_enabled(*(void *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
          if (v21 == 2 || !v24)
          {
            uint64_t v30 = *(void *)(a1 + 72);
          }
          else
          {
            if (v7 == 1 && DWORD2(v59) == 1)
            {
              uint64_t v28 = *v55;
              int v29 = "onehot trick only supports row major";
LABEL_34:
              log_OutText(v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)v29, v25, v26, v27, v46);
              uint64_t v30 = 0;
              uint64_t v48 = 0;
              uint64_t v31 = padded_len;
              goto LABEL_35;
            }
            if (v21)
            {
              if (v21 != 3 && v21 != 1)
              {
                uint64_t v28 = *v55;
                int v29 = "SVD impl not supported by row major";
                goto LABEL_34;
              }
              get_padded_len((4 * v12), 8u);
            }
            else
            {
              get_padded_len(v12, 8u);
            }
            uint64_t v30 = *(void *)(a1 + 72);
          }
          uint64_t v48 = v30 + (*(_DWORD *)(a1 + 96) & 0xFFFFFFFC);
          uint64_t v31 = padded_len;
LABEL_35:
          int step = fi_shape_get_step((_DWORD *)(a1 + 20));
          if (HIDWORD(v61[0]) == v31)
          {
            uint64_t v32 = 0;
          }
          else
          {
            uint64_t v32 = (*(uint64_t (**)(uint64_t, void, uint64_t))(v55[1] + 16))(v55[2], v31, 4);
            if (!v32)
            {
              log_OutText(*v55, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v33, v34, v35, v46);
              return 10;
            }
          }
          if (step)
          {
            char __dst = (void *)v32;
            int v36 = 0;
            int v37 = 0;
            uint64_t v38 = v30;
            while (1)
            {
              unsigned int v39 = (void *)(a2 + 4 * (HIDWORD(v61[0]) * v37));
              if (HIDWORD(v61[0]) != v31)
              {
                memcpy(__dst, (const void *)(a2 + 4 * (HIDWORD(v61[0]) * v37)), 4 * HIDWORD(v61[0]));
                uint64_t v31 = HIDWORD(v61[0]);
                unsigned int v39 = __dst;
              }
              unsigned int v40 = v52 == 1 ? v36 : 0;
              uint64_t v41 = a3 + 4 * v40;
              bzero(v5, *(unsigned int *)(a1 + 248));
              uint64_t v42 = v56(*(void *)a1, v39, v41, v31, v12, v6, v5, v38);
              if (v42) {
                break;
              }
              ++v37;
              v36 += v12;
              uint64_t v31 = padded_len;
              if (step == v37)
              {
                uint64_t input_dim = 0;
                goto LABEL_50;
              }
            }
            uint64_t input_dim = v42;
            log_OutText(*v55, (uint64_t)"FastInfer", 0, 0, (uint64_t)"lstm step forward failed!", v43, v44, v45, v48);
LABEL_50:
            uint64_t v32 = (uint64_t)__dst;
          }
          else
          {
            uint64_t input_dim = 0;
          }
          if (v32) {
            (*(void (**)(uint64_t))(v55[1] + 48))(v55[2]);
          }
          return input_dim;
        }
      }
      LODWORD(v59) = 0;
      int v23 = v49;
      DWORD2(v59) = v49;
      DWORD1(v57) = 0;
      goto LABEL_20;
    }
  }
  return input_dim;
}

uint64_t albert_trans_encoder_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v9 = *(unsigned int **)(a1 + 120);
  unsigned int v18 = 0;
  if (v9)
  {
    uint64_t v10 = *v9;
    uint64_t result = albert_trans_encoder_get_reserved_glbBuf_bytes(a1, &v18);
    if (!result)
    {
      if (v10)
      {
        uint64_t v12 = 0;
        uint64_t v13 = v18;
        uint64_t v14 = 8 * v10;
        do
        {
          uint64_t v15 = *(void *)(*((void *)v9 + 12) + v12);
          *(void *)(v15 + 240) = *(void *)(a1 + 240) + v13;
          *(_DWORD *)(v15 + 248) = *(_DWORD *)(a1 + 248) - v13;
          uint64_t v16 = *(void (**)(void))(v15 + 168);
          if (v16) {
            v16();
          }
          v12 += 8;
        }
        while (v14 != v12);
      }
      return 0;
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t albert_trans_encoder_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = *(void *)(a1 + 120);
  unsigned int v9 = 0;
  uint64_t result = fi_shape_get_bytes((int *)(**(void **)(v3 + 96) + 40), &v9);
  if (!result)
  {
    padded_uint64_t bytes = get_padded_bytes(v9, 8u);
    uint64_t result = fi_shape_get_bytes((int *)(*(void *)(v3 + 128) + 40), &v9);
    if (!result)
    {
      int v6 = get_padded_bytes(v9, 8u);
      uint64_t result = fi_shape_get_bytes((int *)(*(void *)(v3 + 144) + 40), &v9);
      if (!result)
      {
        int v7 = get_padded_bytes(v9, 8u);
        int v8 = get_padded_bytes(v6 + 2 * padded_bytes + v7, 8u);
        uint64_t result = 0;
        *a2 = v8;
      }
    }
  }
  return result;
}

void *free_albert_trans_encoder(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = (void *)result[15];
      if (v3)
      {
        uint64_t v4 = *(unsigned int *)v3;
        fi_layer_free(v3[13]);
        fi_layer_free(v3[14]);
        fi_layer_free(v3[15]);
        fi_layer_free(v3[16]);
        fi_layer_free(v3[18]);
        if (v4)
        {
          uint64_t v5 = 0;
          uint64_t v6 = 8 * v4;
          do
          {
            fi_layer_free(*(void *)(v3[12] + v5));
            v5 += 8;
          }
          while (v6 != v5);
        }
        if (v3[12])
        {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
          v3[12] = 0;
        }
        (*(void (**)(void, void *))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v7 = *(void *)(v2 + 16);
      int v8 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v8(v7, v1);
    }
  }
  return result;
}

uint64_t create_albert_trans_encoder(uint64_t *a1, unsigned int *a2, void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7 = 0;
  uint64_t result = 7;
  if (a1 && a2)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      uint64_t v15 = (_OWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 152);
      int v19 = v15;
      if (!v15)
      {
        uint64_t v33 = *a1;
        uint64_t v34 = "out of memory!";
LABEL_24:
        log_OutText(v33, (uint64_t)"FastInfer", 0, 0, (uint64_t)v34, v16, v17, v18, v41);
        *(void *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"albert_trans_encoder init param failed!", v38, v39, v40, v41);
        uint64_t result = 7;
        goto LABEL_25;
      }
      long long v20 = *((_OWORD *)a2 + 1);
      *uint64_t v15 = *(_OWORD *)a2;
      v15[1] = v20;
      long long v21 = *((_OWORD *)a2 + 2);
      long long v22 = *((_OWORD *)a2 + 3);
      long long v23 = *((_OWORD *)a2 + 5);
      v15[4] = *((_OWORD *)a2 + 4);
      v15[5] = v23;
      v15[2] = v21;
      v15[3] = v22;
      uint64_t v24 = *a2;
      uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v24, 8);
      *((void *)v19 + 12) = v25;
      if (!v25)
      {
        uint64_t v31 = *a1;
        uint64_t v32 = "out of memory!";
        goto LABEL_23;
      }
      if (v24)
      {
        uint64_t v29 = 0;
        uint64_t v30 = 8 * v24;
        while (!create_albert_trans_enc_layer(a1, (uint64_t)(a2 + 12), a3, a4, (uint64_t *)(*((void *)v19 + 12) + v29)))
        {
          v29 += 8;
          if (v30 == v29) {
            goto LABEL_10;
          }
        }
        uint64_t v31 = *a1;
        uint64_t v32 = "create albert_trans_encoder albert_trans_enc layer failed!";
        goto LABEL_23;
      }
LABEL_10:
      uint64_t v44 = 0;
      uint64_t v41 = 0x100000000;
      int v43 = 40;
      if (create_norm_layer(a1, (uint64_t *)&v43, (uint64_t *)v19 + 13))
      {
        uint64_t v31 = *a1;
        uint64_t v32 = "create albert_trans_encoder norm layer failed!";
LABEL_23:
        log_OutText(v31, (uint64_t)"FastInfer", 0, 0, (uint64_t)v32, v26, v27, v28, v41);
        uint64_t v33 = *a1;
        uint64_t v34 = "albert_trans_encoder network init failed!";
        goto LABEL_24;
      }
      unsigned int v35 = a2[1];
      int v43 = 5;
      uint64_t v44 = v35;
      if (create_fc_layer(a1, (uint64_t *)&v43, &v41, a3, a4, (uint64_t *)v19 + 16))
      {
        uint64_t v31 = *a1;
        uint64_t v32 = "create fc layer failed!";
        goto LABEL_23;
      }
      unsigned int v36 = a2[2];
      int v43 = 5;
      uint64_t v44 = v36;
      uint64_t v41 = 0x100000000;
      if (create_fc_layer(a1, (uint64_t *)&v43, &v41, a3, a4, (uint64_t *)v19 + 18))
      {
        uint64_t v31 = *a1;
        uint64_t v32 = "create classifier layer failed!";
        goto LABEL_23;
      }
      unsigned int v37 = a2[22];
      LODWORD(v42) = a2[17];
      HIDWORD(v42) = v37;
      if (create_embedding_layer(a1, &v42, (uint64_t ***)v19 + 15)
        || (LODWORD(v42) = a2[17],
            HIDWORD(v42) = 32,
            create_embedding_layer(a1, &v42, (uint64_t ***)v19 + 14)))
      {
        uint64_t v31 = *a1;
        uint64_t v32 = "create albert_trans_encoder target_space_id emb layer failed!";
        goto LABEL_23;
      }
      *(void *)(v7 + 120) = v19;
      if (a3) {
        *(void *)(v7 + 60) = *a3;
      }
      *(void *)uint64_t v7 = a1;
      *(void *)(v7 + 8) = 43;
      *(void *)(v7 + 128) = forward_albert_trans_encoder;
      *(void *)(v7 + 136) = free_albert_trans_encoder;
      *(void *)(v7 + 144) = albert_trans_encoder_update_shape;
      *(void *)(v7 + 152) = albert_trans_encoder_wanted_wb_len;
      *(void *)(v7 + 160) = albert_trans_encoder_request_glbBuf;
      *(void *)(v7 + 184) = albert_trans_encoder_dispatch_weights;
      *(void *)(v7 + 168) = albert_trans_encoder_assign_glbBuf;
      *(void *)(v7 + 176) = albert_trans_encoder_reset;
      if (!a4) {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v26, v27, v28, v41);
      }
      uint64_t result = 0;
      *(void *)(v7 + 256) = 0;
      *(_DWORD *)(v7 + 264) = 0;
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v41);
      uint64_t result = 10;
    }
  }
LABEL_25:
  *a5 = v7;
  return result;
}

uint64_t forward_albert_trans_encoder(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(uint64_t **)a2;
  unsigned int v9 = *(int **)(a2 + 120);
  int v64 = 0;
  float v63 = 0.0;
  if (!a5)
  {
    uint64_t v15 = "No opts given to encoder forward.";
LABEL_10:
    log_OutText(*v8, (uint64_t)"FastInfer", 0, 0, (uint64_t)v15, a6, a7, a8, v50);
    uint64_t updated = 7;
LABEL_11:
    log_OutText(*v8, (uint64_t)"FastInfer", 0, 0, (uint64_t)"albert_trans_encoder failed!", v17, v18, v19, v50);
    return updated;
  }
  unsigned int v13 = 1;
  *(_DWORD *)(a5 + 20) = 1;
  unsigned int v14 = v9[19];
  uint64_t v15 = "albert_trans_encoder input too short!";
  while (v9[23] != *(float *)(a3 + 4 * (v13 - 1)))
  {
    if (v13++ > v14) {
      goto LABEL_10;
    }
  }
  if (v13 < 2)
  {
    uint64_t v15 = "albert_trans_encoder input too short!";
    goto LABEL_10;
  }
  long long v61 = *(_OWORD *)(a2 + 20);
  if (v13 < v14) {
    unsigned int v14 = v13;
  }
  int v62 = *(_DWORD *)(a2 + 36);
  DWORD1(v61) = v14;
  uint64_t updated = albert_trans_encoder_update_shape(a2, &v61, a3, (uint64_t)a4, (uint64_t)"albert_trans_encoder input too short!", a6, a7, a8);
  if (updated) {
    goto LABEL_11;
  }
  float v63 = (float)v9[21];
  uint64_t v22 = v9[1];
  int v58 = *v9;
  unsigned int v59 = v9[17];
  uint64_t updated = fi_shape_get_bytes((int *)(*((void *)v9 + 15) + 40), &v64);
  if (updated) {
    goto LABEL_11;
  }
  char __dst = *(float **)(a2 + 240);
  long long v23 = &__dst[get_padded_len(v22 * v13, 8u)];
  unsigned int v56 = v22 * v13;
  int padded_len = get_padded_len(v22 * v13, 8u);
  int v51 = get_padded_len(v59, 8u);
  unsigned int step = fi_shape_get_step((_DWORD *)(*((void *)v9 + 15) + 40));
  uint64_t updated = (*(uint64_t (**)(uint64_t))(*((void *)v9 + 15) + 128))(a1);
  if (updated) {
    goto LABEL_11;
  }
  uint64_t v50 = v22;
  axpy(step * v59, *((float **)v9 + 17), 1, v23, 1, 1.0);
  uint64_t v24 = v23;
  if (v63 > -1.0)
  {
    uint64_t updated = (*(uint64_t (**)(uint64_t, float))(*((void *)v9 + 14) + 128))(a1, v63);
    if (updated) {
      goto LABEL_11;
    }
    uint64_t v25 = __dst;
    uint64_t v24 = v23;
    if (step)
    {
      int v26 = 0;
      uint64_t v27 = step;
      do
      {
        uint64_t v28 = v25;
        axpy(v59, v25, 1, &v24[v26], 1, 1.0);
        uint64_t v25 = v28;
        v26 += v59;
        --v27;
      }
      while (v27);
    }
  }
  uint64_t v29 = &v24[padded_len];
  uint64_t v30 = v24;
  int v31 = get_padded_len(v59, 8u);
  bzero(v29, 4 * v31 * v13);
  uint64_t updated = (*(uint64_t (**)(uint64_t))(*((void *)v9 + 13) + 128))(a1);
  if (updated) {
    goto LABEL_11;
  }
  uint64_t v32 = (char *)&v29[v51 * v13];
  int v33 = get_padded_len(v9[1], 8u);
  bzero(v32, 4 * v33 * v13);
  uint64_t updated = (*(uint64_t (**)(uint64_t))(*((void *)v9 + 16) + 128))(a1);
  if (updated) {
    goto LABEL_11;
  }
  int v53 = v29;
  size_t v34 = 4 * get_padded_len(v56, 8u);
  long long v60 = v30;
  if (v58)
  {
    memcpy(v30, v32, v34);
    unsigned int v35 = __dst;
    int v36 = v58;
LABEL_29:
    unsigned int v37 = 0;
    unsigned int v55 = v36 - 1;
    while (1)
    {
      unsigned int v38 = get_padded_len(v56, 8u);
      bzero(v35, 4 * v38);
      uint64_t v39 = (*(uint64_t (**)(uint64_t))(**((void **)v9 + 12) + 128))(a1);
      if (v39) {
        break;
      }
      uint64_t v40 = __dst;
      if (v35 != v60) {
        uint64_t v40 = v60;
      }
      if (v37 >= v55) {
        uint64_t v30 = v35;
      }
      else {
        uint64_t v30 = v40;
      }
      ++v37;
      unsigned int v35 = v30;
      if (v58 == v37) {
        goto LABEL_37;
      }
    }
    uint64_t updated = v39;
    goto LABEL_11;
  }
  memcpy(__dst, v32, v34);
  unsigned int v35 = v30;
  int v36 = v58;
  if (v58) {
    goto LABEL_29;
  }
LABEL_37:
  if (v9[3])
  {
    bzero(v53, 4 * v50);
    int v41 = v9[3];
    if (v41 == 3)
    {
      int v48 = v50 * (v13 >> 1);
    }
    else
    {
      if (v41 != 2)
      {
        if (v41 == 1 && v50)
        {
          uint64_t v42 = 0;
          uint64_t v43 = v13;
          if (v13 <= 1uLL) {
            uint64_t v43 = 1;
          }
          do
          {
            float v44 = v53[v42];
            uint64_t v45 = v43;
            int v46 = v42;
            do
            {
              float v44 = v30[v46] + v44;
              v53[v42] = v44;
              v46 += v50;
              --v45;
            }
            while (v45);
            ++v42;
          }
          while (v42 != v50);
        }
LABEL_58:
        bzero(v60, 4 * v9[2]);
        uint64_t updated = (*(uint64_t (**)(uint64_t))(*((void *)v9 + 18) + 128))(a1);
        if (!updated)
        {
          bzero(__dst, 4 * v9[2]);
          softmax(v60, v9[2], 1, __dst, *((float *)v9 + 20));
          memcpy(a4, __dst, 4 * v9[2]);
          return updated;
        }
        goto LABEL_11;
      }
      unsigned int v49 = v9[4];
      if (v49 >= v13) {
        unsigned int v49 = v13 - 1;
      }
      int v48 = v49 * v50;
    }
    memcpy(v53, &v30[v48], 4 * v50);
    goto LABEL_58;
  }
  bzero(v60, 4 * v9[2] * v13);
  uint64_t updated = (*(uint64_t (**)(uint64_t))(*((void *)v9 + 18) + 128))(a1);
  if (updated) {
    goto LABEL_11;
  }
  bzero(__dst, 4 * v9[2] * v13);
  for (int i = 0; i != v13; ++i)
    softmax(&v60[v9[2] * i], v9[2], 1, &__dst[v9[2] * i], *((float *)v9 + 20));
  memcpy(a4, __dst, 4 * v9[2] * v13);
  return 0;
}

uint64_t albert_trans_encoder_update_shape(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(unsigned int **)(a1 + 120);
  long long v26 = 0uLL;
  int v27 = 0;
  unsigned int v9 = *(uint64_t **)a1;
  unsigned int v25 = 0;
  if (!v8)
  {
    uint64_t v13 = *v9;
    unsigned int v14 = "out of memory!";
    goto LABEL_7;
  }
  uint64_t v11 = *v8;
  long long v12 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v12;
  if (*(_DWORD *)a2 >= 2u)
  {
    uint64_t v13 = *v9;
    unsigned int v14 = "Currently albert_trans_encoder layer only support 1D input";
LABEL_7:
    log_OutText(v13, (uint64_t)"FastInfer", 0, 0, (uint64_t)v14, a6, a7, a8, v24);
    return 7;
  }
  fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v25);
  if (v25 > v8[19])
  {
    uint64_t v13 = *v9;
    unsigned int v14 = "Encoder input shape dimension must be maximum %d. Found %d";
    uint64_t v24 = v8[19];
    goto LABEL_7;
  }
  uint64_t result = (*(uint64_t (**)(void))(*((void *)v8 + 15) + 144))();
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(void))(*((void *)v8 + 13) + 144))();
    if (!result)
    {
      uint64_t result = (*(uint64_t (**)(void))(*((void *)v8 + 16) + 144))();
      if (!result)
      {
        uint64_t v16 = *((void *)v8 + 12);
        if (v11)
        {
          uint64_t v17 = 0;
          while (1)
          {
            uint64_t result = (*(uint64_t (**)(void))(*(void *)(v16 + v17) + 144))();
            if (result) {
              break;
            }
            uint64_t v16 = *((void *)v8 + 12);
            v17 += 8;
            if (8 * v11 == v17) {
              goto LABEL_16;
            }
          }
        }
        else
        {
LABEL_16:
          uint64_t v18 = *(void *)(v16 + 8 * (v11 - 1));
          int v20 = *(_DWORD *)(v18 + 40);
          uint64_t v19 = (long long *)(v18 + 40);
          if ((v20 - 1) >= 2)
          {
            uint64_t v13 = **(void **)a1;
            unsigned int v14 = "encoder out: output shape error";
            goto LABEL_7;
          }
          if (v8[3])
          {
            long long v26 = *v19;
            int v27 = *((_DWORD *)v19 + 4);
            DWORD1(v26) = 1;
          }
          uint64_t result = (*(uint64_t (**)(void))(*((void *)v8 + 18) + 144))();
          if (!result)
          {
            uint64_t v21 = *((void *)v8 + 18);
            long long v22 = *(_OWORD *)(v21 + 40);
            *(_DWORD *)(a1 + 56) = *(_DWORD *)(v21 + 56);
            *(_OWORD *)(a1 + 40) = v22;
            uint64_t v28 = 0x100000001;
            unsigned int v23 = v8[17];
            int v29 = 32;
            unsigned int v30 = v23;
            int v31 = 4;
            return (*(uint64_t (**)(void))(*((void *)v8 + 14) + 144))();
          }
        }
      }
    }
  }
  return result;
}

uint64_t albert_trans_encoder_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 120);
  if (v9)
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(v9 + 96) + 152))();
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(0, 8u);
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 104) + 152))();
      if (!result)
      {
        unsigned int v14 = get_padded_bytes(padded_bytes, 8u);
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 128) + 152))();
        if (!result)
        {
          unsigned int v15 = get_padded_bytes(v14, 8u);
          uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 120) + 152))();
          if (!result)
          {
            int v16 = get_padded_bytes(v15, 8u);
            unsigned int v17 = get_padded_bytes(v16 + 4 * *(_DWORD *)(v9 + 76) * *(_DWORD *)(v9 + 68), 8u);
            uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 144) + 152))();
            if (!result)
            {
              *a2 = get_padded_bytes(v17, 8u);
              *a3 = 0;
              log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v18, v19, v20, *(unsigned int *)(a1 + 96));
              log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v21, v22, v23, *a2);
              return 0;
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v24);
    return 7;
  }
  return result;
}

uint64_t albert_trans_encoder_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    uint64_t v10 = *v9;
    if (v10)
    {
      uint64_t v11 = 0;
      unsigned int v12 = 0;
      unsigned int v13 = 0;
      uint64_t v14 = *((void *)v9 + 12);
      uint64_t v15 = 8 * v10;
      do
      {
        int v16 = *(uint64_t (**)(void))(*(void *)(v14 + v11) + 160);
        if (v16)
        {
          uint64_t result = v16();
          if (result) {
            return result;
          }
          uint64_t v14 = *((void *)v9 + 12);
          unsigned int v13 = *(_DWORD *)(*(void *)(v14 + v11) + 248);
          if (v13 > v12) {
            unsigned int v12 = *(_DWORD *)(*(void *)(v14 + v11) + 248);
          }
        }
        v11 += 8;
      }
      while (v15 != v11);
    }
    else
    {
      unsigned int v13 = 0;
      unsigned int v12 = 0;
    }
    unsigned int v20 = v13;
    uint64_t result = albert_trans_encoder_get_reserved_glbBuf_bytes(a1, &v20);
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(v20 + v12, 8u);
      uint64_t result = 0;
      *(_DWORD *)(a1 + 248) = padded_bytes;
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v19);
    return 7;
  }
  return result;
}

uint64_t albert_trans_encoder_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 120);
  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 72);
    *(void *)(v8 + 136) = v9;
    padded_uint64_t bytes = get_padded_bytes(4 * *(_DWORD *)(v8 + 68) * *(_DWORD *)(v8 + 76), 8u);
    uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 120), v9, &padded_bytes);
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
      uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 104), v9, &padded_bytes);
      if (!result)
      {
        padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
        uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 128), v9, &padded_bytes);
        if (!result)
        {
          padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
          uint64_t v11 = **(void **)(v8 + 96);
          if (v11)
          {
            uint64_t result = fi_layer_find_weights_via_offset(v11, v9, &padded_bytes);
            if (!result)
            {
              padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
              uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 144), v9, &padded_bytes);
              if (!result)
              {
                get_padded_bytes(padded_bytes, 8u);
                return 0;
              }
            }
          }
          else
          {
            return 10;
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v12);
    return 7;
  }
  return result;
}

uint64_t albert_trans_encoder_reset(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 120);
  uint64_t v2 = *v1;
  if (!v2) {
    return 0;
  }
  uint64_t v4 = 0;
  uint64_t v5 = 8 * v2;
  while (!(*(unsigned int (**)(void))(*(void *)(*((void *)v1 + 12) + v4) + 176))())
  {
    v4 += 8;
    if (v5 == v4) {
      return 0;
    }
  }
  log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"albert_trans_encoder network reset failed!", v6, v7, v8, v10);
  return 7;
}

void *free_upsample_buffer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      if (result[15])
      {
        (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        v1[15] = 0;
      }
      uint64_t v3 = *(void *)(v2 + 16);
      uint64_t v4 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v4(v3, v1);
    }
  }
  return result;
}

uint64_t create_upsample_layer(uint64_t *a1, _OWORD *a2, uint64_t ***a3)
{
  uint64_t v6 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  uint64_t v10 = v6;
  if (v6
    && (*uint64_t v6 = a1, (v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 56)) != 0))
  {
    uint64_t v12 = (uint64_t *)v11;
    uint64_t result = 0;
    long long v14 = a2[1];
    *(_OWORD *)uint64_t v12 = *a2;
    *((_OWORD *)v12 + 1) = v14;
    v10[15] = v12;
    *((_DWORD *)v10 + 2) = 73;
    v10[16] = (uint64_t *)forward_upsample_layer;
    v10[17] = (uint64_t *)free_upsample_buffer;
    v10[18] = (uint64_t *)upsample_layer_update_shape;
    v10[28] = (uint64_t *)upsample_layer_update_param;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v15);
    free_upsample_buffer(v10);
    uint64_t result = 10;
  }
  *a3 = v10;
  return result;
}

uint64_t forward_upsample_layer(uint64_t a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = *(uint64_t **)a2;
  uint64_t v8 = *(void *)(a2 + 120);
  uint64_t v19 = 0;
  unsigned int v9 = *(_DWORD *)(v8 + 4);
  if (v9 == *(_DWORD *)v8)
  {
    uint64_t v10 = 0;
    *(_DWORD *)(a5 + 16) = 0;
  }
  else
  {
    unsigned int v12 = *(_DWORD *)(a2 + 44);
    uint64_t v10 = src_generate(v7, v9, *(_DWORD *)v8, (uint64_t *)&v19);
    if (!v10)
    {
      if (*(_DWORD *)(v8 + 32) == 1 && *(_DWORD *)(v8 + 44)) {
        memcpy((void *)v19[4], *(const void **)(v8 + 48), 4 * *((unsigned int *)v19 + 10));
      }
      src_filt(v19, a3, v12, a4);
      if (*(_DWORD *)(v8 + 32) == 1)
      {
        int v13 = *(_DWORD *)(v8 + 44);
        if (v13 != 2 && v13 != 5) {
          memcpy(*(void **)(v8 + 48), (const void *)v19[4], 4 * *((unsigned int *)v19 + 10));
        }
      }
      uint64_t v10 = 0;
    }
  }
  uint64_t v15 = v19;
  if (v19)
  {
    if (*v19)
    {
      (*(void (**)(uint64_t, void))(v7[1] + 48))(v7[2], *v19);
      *uint64_t v19 = 0;
      *uint64_t v19 = 0;
      uint64_t v15 = v19;
    }
    if (v15[4])
    {
      (*(void (**)(uint64_t, uint64_t))(v7[1] + 48))(v7[2], v15[4]);
      v19[4] = 0;
    }
    (*(void (**)(uint64_t))(v7[1] + 48))(v7[2]);
    uint64_t v19 = 0;
  }
  if (v10
    || *(_DWORD *)(v8 + 32) == 1 && ((int v16 = *(_DWORD *)(v8 + 44), v16 != 5) ? (v17 = v16 == 2) : (v17 = 1), v17))
  {
    if (*(void *)(v8 + 48))
    {
      (*(void (**)(uint64_t))(v7[1] + 80))(v7[2]);
      *(void *)(v8 + 48) = 0;
    }
  }
  return v10;
}

uint64_t upsample_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = a1 + 40;
  uint64_t v11 = *(_DWORD **)(a1 + 120);
  if (*a2 == 1)
  {
    uint64_t result = 0;
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"upsample layer only accepts 1-dimensional input!", a6, a7, a8, v16);
    uint64_t result = 7;
  }
  long long v13 = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = a2[4];
  *(_OWORD *)(a1 + 20) = v13;
  long long v14 = *(_OWORD *)a2;
  *(_DWORD *)(v10 + 16) = a2[4];
  *(_OWORD *)uint64_t v10 = v14;
  int v15 = v11[1];
  if (v15 != *v11) {
    *(_DWORD *)(a1 + 44) = a2[1] / *v11 * v15;
  }
  return result;
}

uint64_t upsample_layer_update_param(uint64_t a1, int *a2, int a3, int a4)
{
  if (*(_DWORD *)(a1 + 8) != a4) {
    return 0;
  }
  if (a3 != 16) {
    return 7;
  }
  uint64_t v4 = *(void *)(a1 + 120);
  int v5 = *a2;
  int v6 = a2[1];
  *(_DWORD *)(v4 + 32) = *a2;
  *(_DWORD *)(v4 + 44) = v6;
  if (v5 != 1 || v6 != 0) {
    return 0;
  }
  uint64_t result = 0;
  *(void *)(v4 + 48) = *((void *)a2 + 1);
  return result;
}

uint64_t create_fc_layer(uint64_t *a1, uint64_t *a2, void *a3, void *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v7 = 0;
  uint64_t v8 = 7;
  if (!a1 || !a2 || !a3) {
    goto LABEL_11;
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v7
    || (BOOL v17 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 8)) == 0)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v14, v15, v16, v22);
    uint64_t v8 = 10;
LABEL_11:
    free_fc_buffer((void *)v7);
    goto LABEL_12;
  }
  *BOOL v17 = *a3;
  *(void *)(v7 + 120) = v17;
  uint64_t v18 = *a2;
  *(_DWORD *)(v7 + 16) = *((_DWORD *)a2 + 2);
  *(void *)uint64_t v7 = a1;
  *(void *)(v7 + 8) = v18;
  if (a4) {
    *(void *)(v7 + 60) = *a4;
  }
  if (a5)
  {
    uint64_t v19 = *(void *)(a5 + 24);
    int v20 = *(_DWORD *)(a5 + 16);
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, use v0.0.0", v14, v15, v16, v22);
    uint64_t v19 = 0;
    int v20 = 0;
  }
  uint64_t v8 = 0;
  *(void *)(v7 + 256) = v19;
  *(_DWORD *)(v7 + 264) = v20;
  *(void *)(v7 + 128) = forward_fc_layer;
  *(void *)(v7 + 136) = free_fc_buffer;
  *(void *)(v7 + 144) = fc_layer_update_shape;
  *(void *)(v7 + 152) = fc_layer_wanted_wb_len;
LABEL_12:
  *a6 = v7;
  return v8;
}

uint64_t forward_fc_layer(uint64_t a1, uint64_t a2, float *a3, float32x4_t *a4)
{
  if (a1 && *(_DWORD *)(a1 + 8)) {
    return 0;
  }
  else {
    return forward_fc_layer_f32(a2, a3, a4);
  }
}

void *free_fc_buffer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      if (result[15]) {
        (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v3 = *(void *)(v2 + 16);
      uint64_t v4 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v4(v3, v1);
    }
  }
  return result;
}

uint64_t fc_layer_update_shape(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v8 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v8;
  if (*(_DWORD *)a2 == 2)
  {
    uint64_t v9 = 0;
    *(_DWORD *)(a1 + 40) = 2;
    int v11 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 44) = *((_DWORD *)a2 + 1);
    *(_DWORD *)(a1 + 48) = v11;
  }
  else
  {
    if (*(_DWORD *)a2 != 1)
    {
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently fc layer only support 1D or 2D input", a6, a7, a8, vars0);
      return 7;
    }
    uint64_t v9 = 0;
    int v10 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = v10;
  }
  *(_DWORD *)(a1 + 56) = *((_DWORD *)a2 + 4);
  return v9;
}

uint64_t fc_layer_wanted_wb_len(uint64_t a1, int *a2, int *a3)
{
  unsigned int v39 = 0;
  uint64_t v6 = *(void *)(a1 + 120);
  BOOL is_enabled = fi_feat_is_enabled(*(void *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  BOOL v8 = fi_feat_is_enabled(*(void *)(a1 + 256), 7u, *(_DWORD *)(a1 + 264));
  uint64_t result = fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v39);
  if (result) {
    return result;
  }
  uint64_t padded_len = get_padded_len(v39, 8u);
  uint64_t v11 = *(unsigned int *)(a1 + 12);
  int v12 = get_padded_len(v11, 8u);
  if (is_enabled || v8)
  {
    int v16 = v12;
    uint64_t v17 = *(void *)(a1 + 72);
    if (v17) {
      uint64_t v18 = *(unsigned int *)(v17 + 8);
    }
    else {
      uint64_t v18 = 0;
    }
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"get k : %d", v13, v14, v15, v18);
    uint64_t v23 = *(int **)(a1 + 72);
    if (v23)
    {
      int v24 = v23[1];
      if (v18)
      {
        if ((v24 & 8) != 0)
        {
          log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently not support quantization for block sparse!", v19, v20, v21, v38);
          return 7;
        }
        int v25 = *v23;
        if ((v24 & 2) != 0)
        {
          int bsc_data_len = get_bsc_data_len(v18, padded_len);
LABEL_14:
          int v22 = bsc_data_len + v25;
          goto LABEL_15;
        }
LABEL_13:
        int bsc_data_len = get_bsc_data_len(v18, v11);
        goto LABEL_14;
      }
      if ((v24 & 2) != 0)
      {
        unsigned int v35 = v39;
        if ((v24 & 8) == 0)
        {
          int v27 = 4 * (*v23 + v39 * v16);
          goto LABEL_16;
        }
        int v36 = get_padded_len(v11, 0x20u) * v35;
      }
      else
      {
        if ((v24 & 8) == 0)
        {
          LODWORD(v23) = 4 * *v23;
          goto LABEL_23;
        }
        int v36 = get_padded_len(v39, 0x20u) * v11;
      }
      unsigned int v37 = *(_DWORD **)(a1 + 72);
      if (v37) {
        LODWORD(v37) = 4 * *v37;
      }
      int v27 = v37 + v36;
      goto LABEL_16;
    }
    int v25 = 0;
    if (v18) {
      goto LABEL_13;
    }
LABEL_23:
    int v27 = v23 + 4 * v11 * padded_len;
    goto LABEL_16;
  }
  log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"get k : %d", v13, v14, v15, 0);
  int v22 = v11 * padded_len;
LABEL_15:
  int v27 = 4 * v22;
  int v16 = v11;
LABEL_16:
  *a2 = v27;
  int v28 = 4 * v16;
  *a3 = 4 * v16;
  if (!*(_DWORD *)(v6 + 4)) {
    int v28 = 0;
  }
  *a3 = v28;
  log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"hidden : %d\n", v19, v20, v21, v11);
  log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v29, v30, v31, *(unsigned int *)(a1 + 96));
  log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"x=%u, padded_x=%u, h=%u, wBytes=4*(h*padded_x)=%u, bBytes=4*h=%u, wBytes+bBytes=%u", v32, v33, v34, v39);
  return 0;
}

uint64_t create_highways(uint64_t *a1, unsigned int *a2, void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7 = 0;
  uint64_t result = 7;
  if (a1 && a2)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 24);
      uint64_t v19 = v15;
      if (!v15)
      {
        uint64_t v21 = "out of memory!";
        goto LABEL_22;
      }
      uint64_t v20 = *(void *)a2;
      *(_DWORD *)(v15 + 8) = a2[2];
      *(void *)uint64_t v15 = v20;
      if (v20 > 0xC8)
      {
        uint64_t v21 = "number of highways exploded!";
LABEL_22:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v21, v16, v17, v18, v34);
        *(void *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"highways init param failed!", v31, v32, v33, v35);
        uint64_t result = 7;
        goto LABEL_23;
      }
      if (!v20)
      {
        uint64_t v21 = "number of highways must be greater than zero!";
        goto LABEL_22;
      }
      uint64_t v22 = *a2;
      uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v22, 8);
      *(void *)(v19 + 16) = v23;
      if (!v23)
      {
        uint64_t v30 = "out of memory!";
LABEL_21:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v30, v24, v25, v26, v34);
        uint64_t v21 = "highways network init failed!";
        goto LABEL_22;
      }
      if (v22)
      {
        uint64_t v27 = 0;
        int v28 = (uint64_t *)(a2 + 1);
        uint64_t v29 = 8 * v22;
        uint64_t v30 = "create highways sub-highway layer failed!";
        while (!create_highway_layer(a1, v28, a3, a4, (uint64_t *)(*(void *)(v19 + 16) + v27)))
        {
          v27 += 8;
          if (v29 == v27) {
            goto LABEL_15;
          }
        }
        goto LABEL_21;
      }
LABEL_15:
      *(void *)(v7 + 120) = v19;
      if (a3) {
        *(void *)(v7 + 60) = *a3;
      }
      *(void *)uint64_t v7 = a1;
      *(void *)(v7 + 8) = 54;
      *(void *)(v7 + 128) = forward_highways;
      *(void *)(v7 + 136) = free_highways;
      *(void *)(v7 + 144) = highways_update_shape;
      *(void *)(v7 + 152) = highways_wanted_wb_len;
      *(void *)(v7 + 160) = highways_request_glbBuf;
      *(void *)(v7 + 184) = highways_dispatch_weights;
      *(void *)(v7 + 168) = highways_assign_glbBuf;
      if (a4)
      {
        uint64_t result = 0;
        *(void *)(v7 + 256) = *(void *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, using default (0)", v24, v25, v26, v34);
        uint64_t result = 0;
        *(void *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v34);
      uint64_t result = 10;
    }
  }
LABEL_23:
  *a5 = v7;
  return result;
}

uint64_t forward_highways(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  LODWORD(v23) = 0;
  if (!a2) {
    return 0;
  }
  BOOL v8 = *(uint64_t **)a2;
  uint64_t v9 = *(unsigned int **)(a2 + 120);
  if (!v9)
  {
    log_OutText(*v8, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v22);
    return 7;
  }
  uint64_t v12 = *(void *)(a2 + 240);
  uint64_t v13 = *v9;
  uint64_t bytes = fi_shape_get_bytes((int *)(a2 + 20), &v23);
  if (!bytes)
  {
    if (v13)
    {
      uint64_t v15 = 0;
      while (1)
      {
        uint64_t v16 = (void *)((((_BYTE)v13 + (_BYTE)v15) & 1) != 0 ? a4 : v12);
        bzero(v16, v23);
        uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)(*((void *)v9 + 2) + 8 * v15) + 128))(a1);
        if (v17) {
          break;
        }
        if (v13 == ++v15) {
          return 0;
        }
      }
      uint64_t bytes = v17;
      log_OutText(*v8, (uint64_t)"FastInfer", 0, 0, (uint64_t)"highways forward sub-highway layer failed!", v18, v19, v20, v22);
      return bytes;
    }
    return 0;
  }
  return bytes;
}

void *free_highways(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = (unsigned int *)result[15];
      if (v3)
      {
        uint64_t v4 = *v3;
        if (v4)
        {
          uint64_t v5 = 0;
          uint64_t v6 = 8 * v4;
          do
          {
            fi_layer_free(*(void *)(*((void *)v3 + 2) + v5));
            v5 += 8;
          }
          while (v6 != v5);
        }
        if (*((void *)v3 + 2))
        {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
          *((void *)v3 + 2) = 0;
        }
        (*(void (**)(void, unsigned int *))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v7 = *(void *)(v2 + 16);
      BOOL v8 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v8(v7, v1);
    }
  }
  return result;
}

__n128 highways_update_shape(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v8 = *(unsigned int **)(a1 + 120);
  uint64_t v9 = *(uint64_t **)a1;
  if (!v8)
  {
    uint64_t v13 = *v9;
    uint64_t v14 = "NULL param!";
    goto LABEL_11;
  }
  uint64_t v11 = *v8;
  long long v12 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v12;
  if (*(_DWORD *)a2 > 2u)
  {
    uint64_t v13 = *v9;
    uint64_t v14 = "Currently highway layer only support 1D or 2D input";
LABEL_11:
    log_OutText(v13, (uint64_t)"FastInfer", 0, 0, (uint64_t)v14, a6, a7, a8, v20);
    return result;
  }
  uint64_t v15 = (__n128 *)(a1 + 20);
  if (!v11)
  {
LABEL_9:
    if (v15->n128_u32[0] < 3)
    {
      __n128 result = *v15;
      *(_DWORD *)(a1 + 56) = v15[1].n128_u32[0];
      *(__n128 *)(a1 + 40) = result;
      return result;
    }
    uint64_t v13 = *v9;
    uint64_t v14 = "final output shape error: Currently highways only support 1D or 2D output";
    goto LABEL_11;
  }
  uint64_t v16 = 0;
  uint64_t v17 = *((void *)v8 + 2);
  uint64_t v18 = 8 * v11;
  while (!(*(unsigned int (**)(void))(*(void *)(v17 + v16) + 144))())
  {
    uint64_t v17 = *((void *)v8 + 2);
    uint64_t v15 = (__n128 *)(*(void *)(v17 + v16) + 40);
    v16 += 8;
    if (v18 == v16) {
      goto LABEL_9;
    }
  }
  return result;
}

uint64_t highways_wanted_wb_len(uint64_t a1, unsigned int *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    uint64_t v12 = *v9;
    if (v12)
    {
      uint64_t v13 = 0;
      padded_uint64_t bytes = 0;
      uint64_t v15 = 8 * v12;
      while (1)
      {
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(*((void *)v9 + 2) + v13) + 152))();
        if (result) {
          break;
        }
        padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
        v13 += 8;
        if (v15 == v13) {
          goto LABEL_9;
        }
      }
    }
    else
    {
      padded_uint64_t bytes = 0;
LABEL_9:
      *a2 = padded_bytes;
      *a3 = 0;
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"num_highways: %d\n", a6, a7, a8, *v9);
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v17, v18, v19, *(unsigned int *)(a1 + 96));
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v20, v21, v22, *a2);
      return 0;
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v23);
    return 7;
  }
  return result;
}

uint64_t highways_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    uint64_t v10 = *v9;
    if (v10)
    {
      uint64_t v11 = 0;
      unsigned int v12 = 0;
      uint64_t v13 = *((void *)v9 + 2);
      uint64_t v14 = 8 * v10;
      do
      {
        uint64_t v15 = *(uint64_t (**)(void))(*(void *)(v13 + v11) + 160);
        if (v15)
        {
          uint64_t result = v15();
          if (result) {
            return result;
          }
          uint64_t v13 = *((void *)v9 + 2);
          if (*(_DWORD *)(*(void *)(v13 + v11) + 248) > v12) {
            unsigned int v12 = *(_DWORD *)(*(void *)(v13 + v11) + 248);
          }
        }
        v11 += 8;
      }
      while (v14 != v11);
    }
    else
    {
      unsigned int v12 = 0;
    }
    int v18 = 0;
    uint64_t result = fi_shape_get_bytes((int *)(a1 + 20), &v18);
    if (!result) {
      *(_DWORD *)(a1 + 248) = v18 + v12;
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t highways_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  padded_uint64_t bytes = 0;
  BOOL v8 = *(unsigned int **)(a1 + 120);
  if (v8)
  {
    uint64_t v9 = *v8;
    if (v9)
    {
      uint64_t v10 = 0;
      uint64_t v11 = *(void *)(a1 + 72);
      uint64_t v12 = 8 * v9;
      while (1)
      {
        uint64_t v13 = *(void *)(*((void *)v8 + 2) + v10);
        if (!v13) {
          break;
        }
        uint64_t result = fi_layer_find_weights_via_offset(v13, v11, &padded_bytes);
        if (result) {
          return result;
        }
        padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
        v10 += 8;
        if (v12 == v10) {
          return 0;
        }
      }
      return 10;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v15);
    return 7;
  }
}

uint64_t highways_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    uint64_t v10 = *v9;
    unsigned int v18 = 0;
    uint64_t result = fi_shape_get_bytes((int *)(a1 + 20), &v18);
    if (!result)
    {
      if (v10)
      {
        uint64_t v12 = 0;
        uint64_t v13 = v18;
        uint64_t v14 = 8 * v10;
        do
        {
          uint64_t v15 = *(void *)(*((void *)v9 + 2) + v12);
          *(void *)(v15 + 240) = *(void *)(a1 + 240) + v13;
          *(_DWORD *)(v15 + 248) = *(_DWORD *)(a1 + 248) - v13;
          uint64_t v16 = *(void (**)(void))(v15 + 168);
          if (v16) {
            v16();
          }
          v12 += 8;
        }
        while (v14 != v12);
      }
      return 0;
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t config_highways_layer(int a1, int a2, int a3, _DWORD *a4)
{
  a4[1] = a2;
  a4[2] = a3;
  *a4 = a1;
  return 0;
}

uint64_t create_repeat_layer(uint64_t *a1, uint64_t *a2, _DWORD *a3, void *a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*a3)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Repeat count should be positive, got %d", a6, a7, a8, 0);
    uint64_t v17 = 0;
    uint64_t v20 = 7;
LABEL_9:
    free_repeat_buffer(v17);
    goto LABEL_10;
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  uint64_t v17 = (void *)v13;
  if (!v13) {
    goto LABEL_8;
  }
  *(void *)uint64_t v13 = a1;
  uint64_t v18 = *a2;
  *(_DWORD *)(v13 + 16) = *((_DWORD *)a2 + 2);
  *(void *)(v13 + 8) = v18;
  if (a4) {
    *(void *)(v13 + 60) = *a4;
  }
  uint64_t v19 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 4);
  v17[15] = v19;
  if (!v19)
  {
LABEL_8:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v14, v15, v16, v22);
    uint64_t v20 = 10;
    goto LABEL_9;
  }
  uint64_t v20 = 0;
  *uint64_t v19 = *a3;
  v17[16] = forward_repeat_layer;
  v17[17] = free_repeat_buffer;
  v17[18] = repeat_layer_update_shape;
LABEL_10:
  *a5 = v17;
  return v20;
}

uint64_t forward_repeat_layer(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4)
{
  uint64_t v6 = *(_DWORD **)(a2 + 120);
  unsigned int v13 = 0;
  uint64_t input_dim = fi_shape_get_input_dim((int *)(a2 + 20), (int *)&v13);
  if (!input_dim && *v6)
  {
    unsigned int v8 = 0;
    unint64_t v9 = 0;
    unsigned int v10 = v13;
    size_t v11 = 4 * v13;
    do
    {
      memcpy((void *)(a4 + 4 * v8), a3, v11);
      ++v9;
      v8 += v10;
    }
    while (v9 < *v6);
  }
  return input_dim;
}

void *free_repeat_buffer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      if (result[15]) {
        (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
      }
      uint64_t v3 = *(void *)(v2 + 16);
      uint64_t v4 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v4(v3, v1);
    }
  }
  return result;
}

uint64_t repeat_layer_update_shape(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD **)(a1 + 120);
  unsigned int v9 = a2[4];
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v9;
  uint64_t v10 = *a2;
  if (v10 != 1)
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Repeat layer only works on 1D data, got %d", a6, a7, a8, v10);
    return 7;
  }
  if (!a2[1])
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Repeat layer only works on data which dimension > 0", a6, a7, a8, v13);
    return 7;
  }
  uint64_t v11 = 0;
  *(_DWORD *)(a1 + 40) = 1;
  *(_DWORD *)(a1 + 44) = a2[1] * *v8;
  *(_DWORD *)(a1 + 56) = a2[4];
  return v11;
}

uint64_t create_blstm_layer(uint64_t *a1, uint64_t *a2, long long *a3, void *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v15) {
    goto LABEL_10;
  }
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16);
  if (!v16) {
    goto LABEL_10;
  }
  uint64_t v17 = (void *)v16;
  uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 40);
  if (!v18) {
    goto LABEL_10;
  }
  uint64_t v19 = v18;
  uint64_t v20 = *a2;
  *(_DWORD *)(v15 + 16) = *((_DWORD *)a2 + 2);
  *(void *)uint64_t v15 = a1;
  *(void *)(v15 + 8) = v20;
  if (a4) {
    *(void *)(v15 + 60) = *a4;
  }
  uint64_t v21 = 2 * get_padded_len(*((unsigned int *)a2 + 1), 8u);
  uint64_t v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v21, 4);
  *uint64_t v17 = v22;
  if (v22
    && (v17[1] = v19,
        uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v21, 4),
        (*(void *)(v19 + 32) = v23) != 0))
  {
    long long v24 = *a3;
    *(_OWORD *)(v19 + 12) = *(long long *)((char *)a3 + 12);
    *(_OWORD *)uint64_t v19 = v24;
    *(void *)(v15 + 120) = v17;
    *(void *)(v15 + 128) = forward_blstm_layer;
    *(void *)(v15 + 136) = free_blstm_buffer;
    *(void *)(v15 + 144) = blstm_layer_update_shape;
    *(void *)(v15 + 152) = blstm_layer_wanted_wb_len;
    *(void *)(v15 + 160) = blstm_layer_request_glbBuf;
    if (a5)
    {
      uint64_t result = 0;
      *(void *)(v15 + 256) = *(void *)(a5 + 24);
      *(_DWORD *)(v15 + 264) = *(_DWORD *)(a5 + 16);
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, use v0.0.0", v12, v13, v14, v26);
      uint64_t result = 0;
      *(void *)(v15 + 256) = 0;
      *(_DWORD *)(v15 + 264) = 0;
    }
  }
  else
  {
LABEL_10:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v26);
    free_blstm_buffer((void *)v15);
    uint64_t result = 10;
  }
  *a6 = v15;
  return result;
}

uint64_t forward_blstm_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = *(uint64_t **)a2;
  uint64_t v7 = *(void *)(*(void *)(a2 + 120) + 8);
  v105[0] = 0;
  uint64_t v8 = *(unsigned int *)(a2 + 12);
  int padded_len = get_padded_len(v8, 8u);
  unint64_t v68 = *(unsigned int *)(a2 + 248);
  uint64_t v69 = *(void *)(a2 + 240);
  uint64_t v71 = *(char **)(v7 + 32);
  unsigned int v9 = *(_DWORD *)(a2 + 16) & 0xFFFFFFFD;
  BOOL is_enabled = fi_feat_is_enabled(*(void *)(a2 + 256), 4u, *(_DWORD *)(a2 + 264));
  uint64_t v11 = **(char ***)(a2 + 120);
  uint64_t v103 = a3;
  uint64_t v104 = 0;
  unsigned int v102 = 1;
  uint64_t v101 = 0;
  memset(v100, 0, sizeof(v100));
  memset(v99, 0, sizeof(v99));
  uint64_t input_dim = fi_shape_get_input_dim((int *)(a2 + 20), (int *)v105);
  if (input_dim)
  {
    uint64_t v16 = input_dim;
    uint64_t v17 = *v6;
    uint64_t v18 = "get input dim function failed!";
LABEL_3:
    log_OutText(v17, (uint64_t)"FastInfer", 0, 0, (uint64_t)v18, v13, v14, v15, v58);
    goto LABEL_5;
  }
  uint64_t v66 = v7;
  uint64_t v16 = lstm_layer_impl_type(a2, &v102);
  if (!v16)
  {
    uint64_t lstm_step_f = get_lstm_step_f(&v101, v102);
    if (lstm_step_f)
    {
      uint64_t v16 = lstm_step_f;
      uint64_t v17 = *v6;
      uint64_t v18 = "get lstm step forward function failed!";
      goto LABEL_3;
    }
    int v21 = get_padded_len(v105[0], 8u);
    unsigned int v22 = v102;
    unsigned int v23 = v105[0];
    int v24 = get_padded_len(v105[0], 8u);
    int v28 = *(unsigned int **)(a2 + 72);
    if (v28)
    {
      int v29 = (*((unsigned __int8 *)v28 + 4) >> 1) & 1;
      if (!is_enabled) {
        int v29 = 0;
      }
      if ((v29 & 1) != 0 || v9 != 1)
      {
        if (v29)
        {
          if (!v22)
          {
            int v65 = v21;
            uint64_t v30 = v8;
            int v31 = 4 * get_padded_len(v8, 8u);
            int v32 = 4;
            goto LABEL_27;
          }
          if (v22 == 3 || v22 == 1)
          {
            int v65 = v21;
            uint64_t v30 = v8;
            int v31 = get_padded_len((4 * v8), 8u);
            int v32 = 1;
LABEL_27:
            int v28 = *(unsigned int **)(a2 + 72);
            if (v28) {
              unsigned int v42 = *v28;
            }
            else {
              unsigned int v42 = 0;
            }
            float v44 = v11;
            unsigned int v48 = v42 * v32;
            uint64_t v36 = (uint64_t)&v28[v31 * v23 + v48];
            unint64_t v49 = *(unsigned int *)(a2 + 96);
            uint64_t v38 = (uint64_t)v28 + ((v49 >> 1) & 0x7FFFFFFC);
            uint64_t v39 = v38 + 4 * v31 * v23 + 4 * v48;
            uint64_t v40 = (uint64_t)v28 + (v49 & 0xFFFFFFFC);
            uint64_t v41 = v40 + (((unint64_t)*(unsigned int *)(a2 + 112) >> 1) & 0x7FFFFFFC);
            DWORD1(v100[0]) = v9 == 1;
            uint64_t v43 = v71;
            goto LABEL_31;
          }
          uint64_t v33 = *v6;
          uint64_t v34 = "SVD impl not supported by row major";
LABEL_22:
          log_OutText(v33, (uint64_t)"FastInfer", 0, 0, (uint64_t)v34, v25, v26, v27, v58);
          uint64_t v16 = 7;
          goto LABEL_5;
        }
LABEL_23:
        int v65 = v21;
        uint64_t v30 = v8;
        unsigned int v35 = 4 * v8 * v24;
        uint64_t v36 = (uint64_t)&v28[v35];
        unint64_t v37 = *(unsigned int *)(a2 + 96);
        uint64_t v38 = (uint64_t)v28 + ((v37 >> 1) & 0x7FFFFFFC);
        uint64_t v39 = v38 + 4 * v35;
        uint64_t v40 = (uint64_t)v28 + (v37 & 0xFFFFFFFC);
        uint64_t v41 = v40 + (((unint64_t)*(unsigned int *)(a2 + 112) >> 1) & 0x7FFFFFFC);
        DWORD1(v100[0]) = v9 == 1;
        if (!is_enabled)
        {
          uint64_t v60 = v40;
          uint64_t v61 = v41;
          uint64_t v59 = (uint64_t)&v28[v35];
          uint64_t v63 = v38 + 4 * v35;
          uint64_t v64 = v38;
          uint64_t v67 = (int *)v28;
          unsigned int v62 = 0;
          BOOL v45 = 1;
          LODWORD(v100[0]) = 0;
          DWORD2(v100[0]) = 1;
          *(void *)&v99[0] = 0;
          uint64_t v43 = v71;
          float v44 = v11;
          uint64_t v46 = v66;
          int v47 = padded_len;
LABEL_38:
          int v53 = &v43[4 * v47];
          DWORD2(v99[0]) = v45;
          size_t v54 = 4 * v30;
          unsigned int v55 = &v44[4 * v47];
          if (!*(_DWORD *)(v46 + 24))
          {
            bzero(v44, v54);
            bzero(v55, v54);
          }
          bzero(v43, v54);
          bzero(v53, v54);
          int step = fi_shape_get_step((_DWORD *)(a2 + 20));
          uint64_t v16 = createAlignedInputs((uint64_t)v6, v105[0], v65, step, &v103, &v104);
          if (!v16)
          {
            v86[0] = a2;
            v86[1] = v101;
            v86[2] = v103;
            v86[3] = a4;
            unsigned int v87 = v105[0];
            int v88 = v8;
            uint64_t v89 = v62;
            uint64_t v90 = v69;
            uint64_t v91 = v68 >> 1;
            uint64_t v92 = v67;
            uint64_t v93 = v60;
            uint64_t v94 = v11;
            uint64_t v95 = v71;
            uint64_t v96 = v59;
            float v97 = v100;
            float v98 = v99;
            v73[2] = v103;
            v73[3] = a4;
            unsigned int v74 = v105[0];
            int v75 = v8;
            uint64_t v76 = v62;
            uint64_t v77 = v69 + ((v68 >> 1) & 0x7FFFFFFC);
            uint64_t v78 = v91;
            uint64_t v79 = v64;
            uint64_t v80 = v61;
            uint64_t v81 = v55;
            uint64_t v82 = v53;
            uint64_t v83 = v63;
            uint64_t v84 = v100;
            uint64_t v85 = v99;
            BOOL v57 = v6[3] != 0;
            v73[0] = a2;
            v73[1] = v101;
            uint64_t v16 = doPasses((uint64_t)v6, v57, v86, v73);
          }
          goto LABEL_5;
        }
        unsigned int v42 = 0;
        uint64_t v43 = v71;
        float v44 = v11;
LABEL_31:
        BOOL v50 = 1;
        unsigned int v62 = v42;
        uint64_t v60 = v40;
        uint64_t v61 = v41;
        if (v28)
        {
          int v51 = v28[1] & 1;
          BOOL v50 = ((v28[1] >> 1) & 1) == 0;
        }
        else
        {
          int v51 = 0;
        }
        int v47 = padded_len;
        LODWORD(v100[0]) = v51;
        DWORD2(v100[0]) = v50;
        DWORD1(v99[0]) = 0;
        uint64_t v67 = (int *)v28;
        uint64_t v63 = v39;
        uint64_t v64 = v38;
        if (v36)
        {
          uint64_t v59 = v36;
          unsigned int v52 = *(_DWORD *)(v36 + 4);
          LODWORD(v99[0]) = v52 & 1;
          BOOL v45 = ((v52 >> 1) & 1) == 0;
        }
        else
        {
          uint64_t v59 = 0;
          LODWORD(v99[0]) = 0;
          BOOL v45 = 1;
        }
        uint64_t v46 = v66;
        goto LABEL_38;
      }
    }
    else if (v9 != 1)
    {
      goto LABEL_23;
    }
    uint64_t v33 = *v6;
    uint64_t v34 = "onehot trick only supports row major";
    goto LABEL_22;
  }
LABEL_5:
  if (v104) {
    (*(void (**)(uint64_t))(v6[1] + 48))(v6[2]);
  }
  return v16;
}

void *free_blstm_buffer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = (void *)result[15];
      if (v3)
      {
        uint64_t v4 = v3[1];
        if (v4)
        {
          if (*(void *)(v4 + 32))
          {
            (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
            *(void *)(v4 + 32) = 0;
          }
          (*(void (**)(void, uint64_t))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v4);
        }
        if (*v3)
        {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
          *uint64_t v3 = 0;
        }
        (*(void (**)(void, void *))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v5 = *(void *)(v2 + 16);
      uint64_t v6 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v6(v5, v1);
    }
  }
  return result;
}

uint64_t blstm_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)a2 == 2)
  {
    int v8 = *(_DWORD *)(*(void *)(*(void *)(a1 + 120) + 8) + 12);
    int v9 = *(_DWORD *)(a2 + 16);
    *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = v9;
    if (v8 == 1)
    {
      uint64_t v10 = 0;
      *(_DWORD *)(a1 + 40) = 2;
      int v11 = 2 * *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a1 + 48) = v11;
    }
    else
    {
      uint64_t v10 = 0;
      int v12 = 2 * *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 40) = 1;
      *(_DWORD *)(a1 + 44) = v12;
    }
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 16);
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently only supports 2D LSTM, BLSTM!", a6, a7, a8, vars0);
    return 7;
  }
  return v10;
}

uint64_t blstm_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, int *a3)
{
  uint64_t result = lstm_layer_wanted_wb_len(a1, a2, a3);
  if (!result)
  {
    *a2 *= 2;
    *a3 *= 2;
  }
  return result;
}

uint64_t blstm_layer_request_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(_DWORD **)(*(void *)(a1 + 120) + 8);
  uint64_t v3 = *(unsigned int *)(a1 + 12);
  int v9 = 0;
  uint64_t result = get_lstm_glbBufBytes(*(uint64_t **)a1, *v2, v3, &v9);
  if (result)
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"get lstm gobal buffer bytes failed!", v5, v6, v7, v8);
    return 7;
  }
  else
  {
    *(_DWORD *)(a1 + 248) = 2 * v9;
  }
  return result;
}

uint64_t createAlignedInputs(uint64_t a1, unsigned int a2, int a3, int a4, uint64_t *a5, uint64_t *a6)
{
  if (a2 == a3) {
    return 0;
  }
  LODWORD(v10) = a4;
  uint64_t v14 = (**(uint64_t (***)(void, uint64_t))(a1 + 8))(*(void *)(a1 + 16), 4 * (a4 * a3));
  *a6 = v14;
  if (v14)
  {
    if (v10)
    {
      unsigned int v18 = 0;
      unsigned int v19 = 0;
      uint64_t v10 = v10;
      do
      {
        memcpy((void *)(*a6 + 4 * v18), (const void *)(*a5 + 4 * v19), 4 * a2);
        v19 += a2;
        v18 += a3;
        --v10;
      }
      while (v10);
      uint64_t v14 = *a6;
    }
    uint64_t v7 = 0;
    *a5 = v14;
  }
  else
  {
    log_OutText(*(void *)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v15, v16, v17, v6);
    return 10;
  }
  return v7;
}

uint64_t doForwardSteps(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)(*(void *)(*a2 + 120) + 8);
  int v6 = *(_DWORD *)(v5 + 12);
  int padded_len = get_padded_len(*((unsigned int *)a2 + 8), 8u);
  unsigned int step = fi_shape_get_step((_DWORD *)(v4 + 20));
  if (!step) {
    return 0;
  }
  uint64_t v25 = a1;
  unsigned int v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 2 * step;
  while (1)
  {
    uint64_t v12 = a2[3];
    uint64_t v13 = *((unsigned int *)a2 + 9);
    uint64_t v14 = v12 + 4 * (v10 * v13);
    if (v6 != 1) {
      uint64_t v14 = a2[3];
    }
    uint64_t v15 = v12 + 4 * v13;
    uint64_t v16 = v12 + 4 * (v13 + v13 * v10);
    if (v6 != 1) {
      uint64_t v16 = v15;
    }
    uint64_t v17 = *(_DWORD *)(v5 + 20) == 1 ? v16 : v14;
    long long v24 = *(_OWORD *)(a2 + 9);
    uint64_t v18 = ((uint64_t (*)(void, uint64_t, uint64_t, void))a2[1])(*(void *)v4, a2[2] + 4 * v9, v17, *((unsigned int *)a2 + 8));
    if (v18) {
      break;
    }
    v10 += 2;
    v9 += padded_len;
    if (v11 == v10) {
      return 0;
    }
  }
  uint64_t v22 = v18;
  log_OutText(*v25, (uint64_t)"FastInfer", 0, 0, (uint64_t)"lstm forward failed!", v19, v20, v21, v24);
  return v22;
}

uint64_t doBackwardSteps(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *(void *)(*(void *)(*a2 + 120) + 8);
  int v6 = *(_DWORD *)(v5 + 12);
  int padded_len = get_padded_len(*((unsigned int *)a2 + 8), 8u);
  unsigned int step = fi_shape_get_step((_DWORD *)(v4 + 20));
  if (!step) {
    return 0;
  }
  unsigned int v23 = a1;
  uint64_t v9 = step;
  int v10 = 2 * step - 2;
  unsigned int v11 = padded_len * (step - 1);
  while (1)
  {
    uint64_t v12 = a2[3];
    uint64_t v13 = *((unsigned int *)a2 + 9);
    uint64_t v14 = v12 + 4 * v13;
    if (v6 == 1)
    {
      uint64_t v14 = v12 + 4 * (v13 + v13 * v10);
      v12 += 4 * (v10 * v13);
    }
    uint64_t v15 = *(_DWORD *)(v5 + 20) == 1 ? v12 : v14;
    long long v22 = *(_OWORD *)(a2 + 9);
    uint64_t v16 = ((uint64_t (*)(void, uint64_t, uint64_t, void))a2[1])(*(void *)v4, a2[2] + 4 * v11, v15, *((unsigned int *)a2 + 8));
    if (v16) {
      break;
    }
    v10 -= 2;
    v11 -= padded_len;
    if (!--v9) {
      return 0;
    }
  }
  uint64_t v20 = v16;
  log_OutText(*v23, (uint64_t)"FastInfer", 0, 0, (uint64_t)"lstm backward failed!", v17, v18, v19, v22);
  return v20;
}

uint64_t doPasses(uint64_t a1, int a2, uint64_t *a3, uint64_t *a4)
{
  if (a2 == 1 && *(_DWORD *)(a1 + 96) >= 2u)
  {
    fi_rsc_checkCreateSecondThread(a1);
    BOOL v7 = fi_thread_checkQueueTask(a1 + 24, (uint64_t)a4, (uint64_t)blstmPass);
    if (v7)
    {
      if (!v7) {
        return 0;
      }
      uint64_t v8 = doForwardSteps((uint64_t *)a1, a3);
      uint64_t v9 = fi_thread_wait4Task(a1 + 24);
      if (!v8) {
        return v9;
      }
      return v8;
    }
  }
  uint64_t v8 = doForwardSteps((uint64_t *)a1, a3);
  if (v8) {
    return v8;
  }
  return doBackwardSteps((uint64_t *)a1, a4);
}

uint64_t create_invpreemph_layer(uint64_t *a1, uint64_t *a2, void *a3, uint64_t *a4)
{
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v11 && (uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 8)) != 0)
  {
    uint64_t v13 = (void *)v12;
    uint64_t result = 0;
    *uint64_t v13 = *a3;
    *(void *)(v11 + 120) = v13;
    uint64_t v15 = *a2;
    *(_DWORD *)(v11 + 16) = *((_DWORD *)a2 + 2);
    *(void *)uint64_t v11 = a1;
    *(void *)(v11 + 8) = v15;
    *(void *)(v11 + 128) = forward_invpreemph_layer;
    *(void *)(v11 + 136) = free_invpreemph_buffer;
    *(void *)(v11 + 144) = invpreemph_layer_update_shape;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v16);
    free_invpreemph_buffer((void *)v11);
    uint64_t result = 10;
  }
  *a4 = v11;
  return result;
}

uint64_t forward_invpreemph_layer(int a1, uint64_t a2, void *__src, void *__dst, uint64_t a5)
{
  uint64_t v8 = *(unsigned int *)(a2 + 44);
  uint64_t v9 = *(void *)(a2 + 120);
  float v10 = *(float *)v9;
  memcpy(__dst, __src, 4 * v8);
  if (v10 > 0.01) {
    _inv_preemphasis((float *)__dst, v8, v10);
  }
  if (*(_DWORD *)(v9 + 4) == 1)
  {
    if (v10 >= 0.01)
    {
      _scale_to_pcm16((float *)__dst, v8);
    }
    else if (v8)
    {
      for (uint64_t i = 0; i != v8; ++i)
      {
        float v12 = *((float *)__dst + i) * 32767.0;
        if (v12 > 32767.0) {
          float v12 = 32767.0;
        }
        if (v12 >= -32767.0) {
          float v13 = v12 + 0.5;
        }
        else {
          float v13 = -32766.0;
        }
        *((_WORD *)__dst + i) = (int)v13;
      }
    }
    *(_DWORD *)(a5 + 20) = 1;
    *(_DWORD *)(a2 + 56) = 2;
  }
  else
  {
    _scale_to_one((float *)__dst, v8);
  }
  return 0;
}

void *free_invpreemph_buffer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      if (result[15]) {
        (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
      }
      uint64_t v3 = *(void *)(v2 + 16);
      uint64_t v4 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v4(v3, v1);
    }
  }
  return result;
}

uint64_t invpreemph_layer_update_shape(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v8 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v8;
  if (*(_DWORD *)a2 == 1)
  {
    uint64_t v9 = 0;
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = *((_DWORD *)a2 + 1);
    *(_DWORD *)(a1 + 56) = *((_DWORD *)a2 + 4);
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently invpreemph layer only support 1D input", a6, a7, a8, vars0);
    return 7;
  }
  return v9;
}

uint64_t create_nest_layer(uint64_t *a1, int a2, int a3, uint64_t a4, uint64_t ***a5)
{
  float v10 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  uint64_t v14 = v10;
  if (v10
    && (*float v10 = a1,
        v10[1] = (uint64_t *)25,
        (uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16)) != 0))
  {
    uint64_t v16 = v15;
    uint64_t result = 0;
    *(_DWORD *)uint64_t v16 = a2;
    *(_DWORD *)(v16 + 4) = a3;
    *(void *)(v16 + 8) = a4;
    v14[15] = (uint64_t *)v16;
    v14[16] = (uint64_t *)forward_nest_layer;
    v14[17] = (uint64_t *)free_nest_layer;
    v14[18] = (uint64_t *)nest_layer_update_shape;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v11, v12, v13, v18);
    free_nest_layer(v14);
    uint64_t result = 10;
  }
  *a5 = v14;
  return result;
}

uint64_t forward_nest_layer(uint64_t a1, int *a2, const void *a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)a2;
  uint64_t v11 = (unsigned int *)*((void *)a2 + 15);
  if (v11[1])
  {
    unint64_t v13 = 0;
    uint64_t v14 = 0;
    while (1)
    {
      uint64_t v15 = *(void *)(*((void *)v11 + 1) + 8 * v13);
      unsigned int __n = 0;
      uint64_t bytes = fi_shape_get_bytes((int *)(v15 + 72), &__n);
      if (bytes) {
        break;
      }
      if (!__n)
      {
        log_OutText(*(void *)v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"error: nest layer get input length=0 bytes!", a6, a7, a8, v69);
        uint64_t v30 = 7;
        goto LABEL_34;
      }
      uint64_t v17 = (void *)(**(uint64_t (***)(void))(v10 + 8))(*(void *)(v10 + 16));
      if (v17)
      {
        uint64_t v21 = v17;
        memcpy(v17, a3, __n);
        uint64_t v14 = v21;
      }
      else
      {
        log_OutText(*(void *)v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v18, v19, v20, v69);
      }
      *(void *)(v15 + 160) = v14;
      uint64_t v22 = fi_net_forward((uint64_t **)v15);
      if (v22)
      {
        uint64_t v30 = v22;
        uint64_t v44 = *(void *)v10;
        BOOL v45 = "nest layer forward submodel failed!";
        goto LABEL_63;
      }
      ++v13;
      unint64_t v23 = v11[1];
      if (v13 >= v23) {
        goto LABEL_12;
      }
    }
    uint64_t v30 = bytes;
LABEL_34:
    uint64_t v44 = *(void *)v10;
    BOOL v45 = "nest layer get submodel input failed!";
    goto LABEL_63;
  }
  LODWORD(v23) = 0;
LABEL_12:
  uint64_t v24 = *v11;
  uint64_t v25 = (void *)*((void *)v11 + 1);
  if ((v24 - 1) < 3)
  {
    unsigned int v75 = 0;
    uint64_t size = fi_shape_get_size(a2 + 10, (int *)&v75);
    if (size)
    {
      uint64_t v30 = size;
      uint64_t v31 = *(void *)v10;
      int v32 = "nest layer mode %d submodel output failed!";
      uint64_t v69 = v24;
LABEL_15:
      log_OutText(v31, (uint64_t)"FastInfer", 0, 0, (uint64_t)v32, v27, v28, v29, v69);
      goto LABEL_62;
    }
    uint64_t v46 = v75;
    memcpy(a4, *(const void **)(*v25 + 144), 4 * v75);
    if (v46)
    {
      uint64_t v47 = 0;
      while (v23 < 2)
      {
LABEL_47:
        if (v24 == 3) {
          *(float *)&a4[4 * v47] = *(float *)&a4[4 * v47] / (float)v23;
        }
        if (++v47 == v46) {
          return 0;
        }
      }
      unsigned int v48 = v25 + 1;
      uint64_t v49 = v23 - 1;
      while (1)
      {
        float v50 = *(float *)(*(void *)(*v48 + 144) + 4 * v47);
        if (v24 == 3) {
          break;
        }
        if (v24 == 2)
        {
          float v51 = v50 * *(float *)&a4[4 * v47];
          goto LABEL_45;
        }
        if (v24 == 1) {
          break;
        }
LABEL_46:
        ++v48;
        if (!--v49) {
          goto LABEL_47;
        }
      }
      float v51 = v50 + *(float *)&a4[4 * v47];
LABEL_45:
      *(float *)&a4[4 * v47] = v51;
      goto LABEL_46;
    }
    return 0;
  }
  if (v24 == 4)
  {
    uint64_t v52 = *(void *)(*v25 + 144);
    uint64_t v53 = *(void *)(v25[1] + 144);
    int v54 = *(_DWORD *)(*v25 + 96);
    uint64_t v55 = *(unsigned int *)(*v25 + 100);
    bzero(a4, 4 * (v55 * v54));
    if (v54)
    {
      unsigned int v59 = 0;
      for (int i = 0; i != v54; ++i)
      {
        if (v55)
        {
          unsigned int v61 = 0;
          for (uint64_t j = 0; j != v55; ++j)
          {
            uint64_t v63 = (i * v55 + j);
            float v64 = *(float *)&a4[4 * v63];
            unsigned int v65 = v59;
            unsigned int v66 = v61;
            uint64_t v67 = v55;
            do
            {
              float v64 = v64 + (float)(*(float *)(v52 + 4 * v65) * *(float *)(v53 + 4 * v66));
              *(float *)&a4[4 * v63] = v64;
              ++v66;
              ++v65;
              --v67;
            }
            while (v67);
            v61 += v55;
          }
        }
        v59 += v55;
      }
    }
    log_OutText(*(void *)v10, (uint64_t)"FastInfer", 3, 0, (uint64_t)"nest dot output done!", v56, v57, v58, v69);
    return 0;
  }
  if (!v24)
  {
    unsigned int __n_4 = 0;
    if (v23)
    {
      uint64_t v33 = 0;
      int v34 = 0;
      unint64_t v23 = v23;
      unint64_t v70 = v23;
      uint64_t v71 = v25;
      while (1)
      {
        uint64_t v35 = v25[v33];
        uint64_t v36 = fi_shape_get_bytes((int *)(v35 + 92), &__n_4);
        if (v36)
        {
          uint64_t v30 = v36;
          goto LABEL_67;
        }
        unsigned int v37 = __n_4;
        if (!__n_4) {
          break;
        }
        int v38 = *(_DWORD *)(v35 + 92);
        if (v38 == 2)
        {
          int v39 = a2[11];
          if (v39)
          {
            int v72 = v34;
            int v40 = 0;
            int v41 = 0;
            int v42 = a2[14];
            int v43 = a2[12];
            do
            {
              memcpy(&a4[((v40 + v33 * *(_DWORD *)(v35 + 100)) * v42)], (const void *)(*(void *)(v35 + 144) + (*(_DWORD *)(v35 + 100) * v42 * v41++)), (*(_DWORD *)(v35 + 100) * v42));
              v40 += v43;
            }
            while (v39 != v41);
            unint64_t v23 = v70;
            uint64_t v25 = v71;
            int v34 = v72;
          }
        }
        else if (v38 == 1)
        {
          memcpy(&a4[v34], *(const void **)(v35 + 144), __n_4);
          v34 += v37;
        }
        else
        {
          log_OutText(*(void *)v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"nest layer now only support conat 1d, 2d data", v27, v28, v29, v69);
        }
        if (++v33 == v23) {
          return 0;
        }
      }
      log_OutText(*(void *)v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"nest layer submodel output length=0!", v27, v28, v29, v69);
      uint64_t v30 = 7;
LABEL_67:
      uint64_t v31 = *(void *)v10;
      int v32 = "nest layer concat submodel output failed!";
      goto LABEL_15;
    }
    return 0;
  }
  log_OutText(*(void *)v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"error: non supported nest mode: %d", a6, a7, a8, *v11);
  uint64_t v30 = 7;
LABEL_62:
  uint64_t v44 = *(void *)v10;
  BOOL v45 = "nest layer gen output failed!";
LABEL_63:
  log_OutText(v44, (uint64_t)"FastInfer", 0, 0, (uint64_t)v45, a6, a7, a8, v69);
  return v30;
}

void *free_nest_layer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    uint64_t v3 = result[15];
    if (*(_DWORD *)(v3 + 4))
    {
      unint64_t v4 = 0;
      do
        fi_net_destroy(*(void *)(*(void *)(v3 + 8) + 8 * v4++));
      while (v4 < *(unsigned int *)(v3 + 4));
    }
    if (*(void *)(v3 + 8))
    {
      (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
      *(void *)(v3 + 8) = 0;
    }
    (*(void (**)(void, uint64_t))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
    uint64_t v5 = *(void *)(v2 + 16);
    int v6 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
    return (void *)v6(v5, v1);
  }
  return result;
}

uint64_t nest_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(uint64_t **)a1;
  uint64_t v10 = *(unsigned int **)(a1 + 120);
  uint64_t v11 = v10[1];
  int v12 = a2[4];
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v12;
  if (v11)
  {
    uint64_t v14 = 0;
    uint64_t v15 = 8 * v11;
    while (1)
    {
      uint64_t v16 = *(void *)(*((void *)v10 + 1) + v14);
      if (!*(_DWORD *)(v16 + 72))
      {
        long long v17 = *(_OWORD *)a2;
        *(_DWORD *)(v16 + 88) = a2[4];
        *(_OWORD *)(v16 + 72) = v17;
      }
      int step = fi_shape_get_step(a2);
      uint64_t updated = fi_net_update_shape((uint64_t **)v16, step, v19, v20, v21, v22, v23, v24);
      if (updated) {
        break;
      }
      v14 += 8;
      if (v15 == v14) {
        goto LABEL_7;
      }
    }
    uint64_t v34 = updated;
    uint64_t v35 = *v9;
    uint64_t v36 = "submodels update shape failed!";
  }
  else
  {
LABEL_7:
    uint64_t v26 = *v10;
    uint64_t v27 = (void *)*((void *)v10 + 1);
    uint64_t v28 = v10[1];
    uint64_t v29 = (__n128 *)(a1 + 40);
    switch((int)v26)
    {
      case 0:
        if (!v28) {
          return 0;
        }
        unint64_t v42 = 0;
        uint64_t v43 = 8 * v28;
        do
        {
          uint64_t v44 = v27[v42 / 8];
          BOOL v45 = (__n128 *)(v44 + 92);
          if (v42)
          {
            uint64_t v46 = fi_shape_merge(v45, v29);
            if (v46)
            {
              uint64_t v34 = v46;
              log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"submodels outputs not able to nest!", v47, v48, v49, v80);
              fi_shape_dump(v9, v27[v42 / 8] + 92, (uint64_t)"shape to be nestd", v64, v65, v66, v67, v68);
              fi_shape_dump(v9, (uint64_t)v29, (uint64_t)"shape", v69, v70, v71, v72, v73);
              log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"concat submodels output shape failed!", v74, v75, v76, v81);
              goto LABEL_26;
            }
          }
          else
          {
            __n128 v50 = *v45;
            v29[1].n128_u32[0] = *(_DWORD *)(v44 + 108);
            *uint64_t v29 = v50;
          }
          v42 += 8;
        }
        while (v43 != v42);
        return 0;
      case 1:
      case 2:
      case 3:
      case 5:
        if (v28) {
          BOOL v30 = v9 == 0;
        }
        else {
          BOOL v30 = 1;
        }
        if (v30 || v27 == 0) {
          goto LABEL_16;
        }
        if (v28 < 2) {
          goto LABEL_22;
        }
        uint64_t v37 = v28 - 1;
        int v38 = v27;
        break;
      case 4:
        if (v28 == 2)
        {
          if (fi_shape_is_same((unsigned int *)(*v27 + 92), (_DWORD *)(v27[1] + 92)))
          {
            fi_shape_copy((__n128 *)(a1 + 40), (__n128 *)(*v27 + 92));
            uint64_t v34 = 0;
            *(_DWORD *)(a1 + 48) = *(_DWORD *)(a1 + 44);
            return v34;
          }
          uint64_t v62 = *v9;
          uint64_t v28 = 2;
          uint64_t v63 = "dot nest requires 2 submodels has the same shape, but , but got: %d";
        }
        else
        {
          uint64_t v62 = *v9;
          uint64_t v63 = "dot nest requires 2 submodels, but got: %d";
        }
        log_OutText(v62, (uint64_t)"FastInfer", 0, 0, (uint64_t)v63, a6, a7, a8, v28);
        log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"update submodels' shape failed for nest mode %d", v77, v78, v79, 4);
        goto LABEL_25;
      default:
        uint64_t v32 = *v9;
        uint64_t v33 = "error: non supported nest mode: %d";
        goto LABEL_24;
    }
    while (fi_shape_is_same((unsigned int *)(*v38 + 92), (_DWORD *)(v38[1] + 92)))
    {
      ++v38;
      if (!--v37)
      {
LABEL_22:
        fi_shape_copy(v29, (__n128 *)(*v27 + 92));
        return 0;
      }
    }
    log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Only shapes with same shape can be sum nestd!", v39, v40, v41, v80);
    fi_shape_dump(v9, *v38 + 92, (uint64_t)"previous shape", v52, v53, v54, v55, v56);
    fi_shape_dump(v9, *v38 + 92, (uint64_t)"shape", v57, v58, v59, v60, v61);
LABEL_16:
    uint64_t v32 = *v9;
    uint64_t v33 = "submodel outshape must be the same for nest mode %d";
LABEL_24:
    log_OutText(v32, (uint64_t)"FastInfer", 0, 0, (uint64_t)v33, a6, a7, a8, v26);
LABEL_25:
    uint64_t v34 = 7;
LABEL_26:
    uint64_t v35 = *v9;
    uint64_t v36 = "udpate nest layer output shape failed!";
  }
  log_OutText(v35, (uint64_t)"FastInfer", 0, 0, (uint64_t)v36, a6, a7, a8, v80);
  return v34;
}

uint64_t lstm_layer_impl_type(uint64_t a1, _DWORD *a2)
{
  if (!a1) {
    return 7;
  }
  uint64_t v2 = *(void *)(a1 + 120);
  if (!v2) {
    return 7;
  }
  uint64_t v3 = *(_DWORD **)(v2 + 8);
  if (!v3) {
    return 7;
  }
  uint64_t result = 0;
  *a2 = *v3;
  return result;
}

void *free_lstm_buffer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = (void *)result[15];
      if (v3)
      {
        uint64_t v4 = v3[1];
        if (v4)
        {
          if (*(void *)(v4 + 32))
          {
            (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
            *(void *)(v4 + 32) = 0;
          }
          (*(void (**)(void, uint64_t))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v4);
        }
        if (*v3)
        {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
          *uint64_t v3 = 0;
        }
        (*(void (**)(void, void *))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v5 = *(void *)(v2 + 16);
      int v6 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v6(v5, v1);
    }
  }
  return result;
}

uint64_t forward_lstm_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a2 + 120);
  uint64_t v9 = *(void *)(v8 + 8);
  if (*(_DWORD *)(v9 + 24))
  {
    if (!a1) {
      goto LABEL_7;
    }
  }
  else
  {
    bzero(*(void **)v8, 4 * *(unsigned int *)(a2 + 12));
    if (!a1) {
      goto LABEL_7;
    }
  }
  if (*(_DWORD *)(a1 + 8)) {
    return 0;
  }
LABEL_7:
  bzero(*(void **)(v9 + 32), 4 * *(unsigned int *)(a2 + 12));
  return forward_lstm_layer_f32(a2, a3, a4);
}

uint64_t reset_lstm_layer_hidden(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = **(void ***)(a1 + 120);
  if (v9)
  {
    bzero(v9, 4 * *(unsigned int *)(a1 + 12));
    uint64_t v10 = *(void **)(*(void *)(*(void *)(a1 + 120) + 8) + 32);
    if (v10)
    {
      bzero(v10, 4 * *(unsigned int *)(a1 + 12));
      return 0;
    }
    uint64_t v12 = **(void **)a1;
    unint64_t v13 = "lstm cell resetting null pointer!";
  }
  else
  {
    uint64_t v12 = **(void **)a1;
    unint64_t v13 = "lstm state resetting null pointer!";
  }
  log_OutText(v12, (uint64_t)"FastInfer", 0, 0, (uint64_t)v13, a6, a7, a8, v14);
  return 10;
}

uint64_t create_bgru_layer(uint64_t *a1, uint64_t *a2, long long *a3, void *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v15) {
    goto LABEL_9;
  }
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16);
  if (!v16) {
    goto LABEL_9;
  }
  long long v17 = (void *)v16;
  uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 20);
  if (!v18) {
    goto LABEL_9;
  }
  uint64_t v19 = v18;
  uint64_t v20 = *a2;
  *(_DWORD *)(v15 + 16) = *((_DWORD *)a2 + 2);
  *(void *)(v15 + 8) = v20;
  uint64_t v21 = (2 * *((_DWORD *)a2 + 1));
  *(void *)uint64_t v15 = a1;
  if (a4) {
    *(void *)(v15 + 60) = *a4;
  }
  uint64_t v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v21, 4);
  *long long v17 = v22;
  if (v22)
  {
    v17[1] = v19;
    long long v23 = *a3;
    *(_DWORD *)(v19 + 16) = *((_DWORD *)a3 + 4);
    *(_OWORD *)uint64_t v19 = v23;
    *(void *)(v15 + 120) = v17;
    *(void *)(v15 + 128) = forward_bgru_layer;
    *(void *)(v15 + 136) = free_bgru_buffer;
    if (a5)
    {
      uint64_t v24 = *(void *)(a5 + 24);
      int v25 = *(_DWORD *)(a5 + 16);
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, use v0.0.0", v12, v13, v14, v27);
      uint64_t v24 = 0;
      int v25 = 0;
    }
    uint64_t result = 0;
    *(void *)(v15 + 256) = v24;
    *(_DWORD *)(v15 + 264) = v25;
    *(void *)(v15 + 144) = bgru_layer_update_shape;
    *(void *)(v15 + 152) = bgru_layer_wanted_wb_len;
    *(void *)(v15 + 160) = bgru_layer_request_glbBuf;
  }
  else
  {
LABEL_9:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v27);
    free_bgru_buffer((void *)v15);
    uint64_t result = 10;
  }
  *a6 = v15;
  return result;
}

uint64_t forward_bgru_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v53 = *(uint64_t **)a2;
  int v6 = *(char ***)(a2 + 120);
  v59[0] = 0;
  uint64_t v7 = *(unsigned int *)(a2 + 12);
  uint64_t v56 = *(void **)(a2 + 240);
  size_t v8 = *(unsigned int *)(a2 + 248);
  uint64_t v10 = *v6;
  uint64_t v9 = v6[1];
  int v55 = *((_DWORD *)v9 + 3);
  uint64_t v58 = 0;
  int v57 = 1;
  uint64_t v52 = *(void *)(a2 + 72);
  padded_uint64_t bytes = get_padded_bytes(*(_DWORD *)(a2 + 96), 8u);
  int v47 = *(_DWORD *)(a2 + 96);
  uint64_t v48 = *(void *)(a2 + 72);
  unint64_t v45 = *(unsigned int *)(a2 + 112);
  if (!*((_DWORD *)v9 + 4))
  {
    bzero(v10, 4 * v7);
    bzero(&v10[4 * v7], 4 * v7);
    bzero(v10, 4 * (2 * v7));
  }
  uint64_t v50 = (uint64_t)&v10[4 * v7];
  uint64_t input_dim = fi_shape_get_input_dim((int *)(a2 + 20), (int *)v59);
  if (input_dim) {
    goto LABEL_52;
  }
  unsigned int padded_len = get_padded_len(v59[0], 8u);
  unsigned int step = fi_shape_get_step((_DWORD *)(a2 + 20));
  uint64_t input_dim = lstm_layer_impl_type(a2, &v57);
  if (input_dim) {
    goto LABEL_52;
  }
  int v15 = v57;
  if (v59[0] == padded_len)
  {
    uint64_t v16 = v53;
  }
  else
  {
    uint64_t v16 = v53;
    if (v57 != 4)
    {
      uint64_t v58 = (void *)(*(uint64_t (**)(uint64_t, void, uint64_t))(v53[1] + 16))(v53[2], padded_len, 4);
      if (!v58)
      {
LABEL_45:
        log_OutText(*v16, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v17, v18, v19, v40);
        uint64_t input_dim = 10;
        goto LABEL_52;
      }
      int v15 = v57;
    }
  }
  size_t v44 = v8;
  if (v15 == 4) {
    uint64_t v20 = step * padded_len;
  }
  else {
    uint64_t v20 = v59[0];
  }
  uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v16[1] + 16))(v16[2], v20, 4);
  if (!v21) {
    goto LABEL_45;
  }
  uint64_t v22 = (char *)v21;
  if (!step)
  {
    uint64_t input_dim = 0;
    goto LABEL_51;
  }
  unsigned int __src = 0;
  unsigned int v23 = step;
  int v24 = 0;
  uint64_t v42 = v52 + 4 * (padded_bytes >> 3);
  uint64_t v25 = (v45 >> 1) & 0x7FFFFFFC;
  uint64_t v46 = v48 + (v47 & 0xFFFFFFFC);
  uint64_t v41 = v46 + v25;
  unsigned int v49 = v23;
  uint64_t v43 = v23;
  while (1)
  {
    unsigned int v26 = v55 == 1 ? 2 * v7 * v24 : 0;
    if (v57 == 4) {
      break;
    }
    unsigned int __src = (void *)(a3 + 4 * v59[0] * v24);
    if (v59[0] != padded_len)
    {
      if (!v58)
      {
        uint64_t input_dim = 0;
        int v38 = "empty new input memory!";
        goto LABEL_50;
      }
      memcpy(v58, __src, 4 * v59[0]);
      unsigned int __src = v58;
    }
LABEL_30:
    unsigned int v30 = v57;
    if ((v57 - 5) <= 0xFFFFFFFD) {
      bzero(v56, v44);
    }
    uint64_t v31 = gru_step_f32((uint64_t **)a2, v30, (uint64_t)__src, a4 + 4 * v26, v59[0], v7, (uint64_t)v56, v52, v46, (uint64_t)v10);
    if (v31)
    {
      uint64_t input_dim = v31;
      int v38 = "gru step forward failed!";
LABEL_50:
      log_OutText(*v16, (uint64_t)"FastInfer", 0, 0, (uint64_t)v38, v17, v18, v19, v40);
      goto LABEL_51;
    }
    if (++v24 == v49)
    {
      uint64_t v32 = 0;
      unsigned int v33 = v7 * (2 * v49 - 1);
      unsigned int v34 = v49 - 1;
      while (1)
      {
        uint64_t v35 = v55 == 1 ? v33 : v7;
        if (v57 == 4)
        {
          unsigned int v36 = 4;
        }
        else
        {
          memcpy(v22, (const void *)(a3 + 4 * v59[0] * v34), 4 * v59[0]);
          unsigned int v36 = v57;
          if ((v57 - 5) <= 0xFFFFFFFD) {
            bzero(v56, v44);
          }
        }
        uint64_t v37 = gru_step_f32((uint64_t **)a2, v36, (uint64_t)v22, a4 + 4 * v35, v59[0], v7, (uint64_t)v56 + ((v44 >> 1) & 0x7FFFFFFC), v42, v41, v50);
        if (v37) {
          break;
        }
        ++v32;
        v33 -= 2 * v7;
        --v34;
        if (v43 == v32)
        {
          uint64_t input_dim = 0;
          uint64_t v16 = v53;
          goto LABEL_51;
        }
      }
      uint64_t input_dim = v37;
      uint64_t v16 = v53;
      int v38 = "gru backward failed!";
      goto LABEL_50;
    }
  }
  if (v24) {
    goto LABEL_30;
  }
  unsigned int __src = (void *)a3;
  if (v59[0] == padded_len)
  {
LABEL_24:
    int v28 = 0;
    uint64_t v29 = v43;
    do
    {
      memcpy(&v22[4 * v28], (const void *)(a3 + 4 * v59[0] * --v29), 4 * v59[0]);
      v28 += padded_len;
    }
    while (v29);
    uint64_t v16 = v53;
    goto LABEL_30;
  }
  uint64_t v27 = realign_inData(v16, v49, v59[0], (uint64_t *)&v58, a3);
  if (!v27)
  {
    unsigned int __src = v58;
    goto LABEL_24;
  }
  uint64_t input_dim = v27;
LABEL_51:
  (*(void (**)(uint64_t, char *))(v16[1] + 48))(v16[2], v22);
LABEL_52:
  if (v58) {
    (*(void (**)(uint64_t))(v53[1] + 48))(v53[2]);
  }
  return input_dim;
}

void *free_bgru_buffer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = (void *)result[15];
      if (v3)
      {
        if (v3[1]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        if (*v3)
        {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
          *uint64_t v3 = 0;
        }
        (*(void (**)(void, void *))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v4 = *(void *)(v2 + 16);
      uint64_t v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v5(v4, v1);
    }
  }
  return result;
}

uint64_t bgru_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)a2 == 2)
  {
    int v8 = *(_DWORD *)(*(void *)(*(void *)(a1 + 120) + 8) + 12);
    int v9 = *(_DWORD *)(a2 + 16);
    *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = v9;
    if (v8 == 1)
    {
      uint64_t v10 = 0;
      *(_DWORD *)(a1 + 40) = 2;
      int v11 = 2 * *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a1 + 48) = v11;
    }
    else
    {
      uint64_t v10 = 0;
      int v12 = 2 * *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 40) = 1;
      *(_DWORD *)(a1 + 44) = v12;
    }
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 16);
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently only supports 2D GRU, BGRU!", a6, a7, a8, vars0);
    return 7;
  }
  return v10;
}

uint64_t bgru_layer_wanted_wb_len(uint64_t **a1, unsigned int *a2, _DWORD *a3)
{
  uint64_t v5 = gru_layer_wanted_wb_len(a1, a2, a3);
  if (!v5)
  {
    *a2 += get_padded_bytes(*a2, 8u);
    *a3 *= 2;
  }
  return v5;
}

uint64_t bgru_layer_request_glbBuf(_DWORD *a1)
{
  uint64_t v2 = a1[3];
  uint64_t v7 = 0;
  int v6 = 0;
  uint64_t v3 = a1 + 5;
  uint64_t result = fi_shape_get_input_dim(a1 + 5, (int *)&v7 + 1);
  if (!result)
  {
    int step = fi_shape_get_step(v3);
    uint64_t result = lstm_layer_impl_type((uint64_t)a1, &v7);
    if (!result)
    {
      uint64_t result = get_gru_glbBufBytes(v7, HIDWORD(v7), step, v2, &v6);
      if (!result) {
        a1[62] = 2 * v6;
      }
    }
  }
  return result;
}

uint64_t create_pqmf_layer(uint64_t *a1, void *a2, uint64_t ***a3)
{
  int v6 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  uint64_t v10 = v6;
  if (v6
    && (*int v6 = a1,
        uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 8),
        (v10[15] = (uint64_t *)v11) != 0))
  {
    int v12 = (void *)v11;
    uint64_t result = 0;
    *int v12 = *a2;
    *((_DWORD *)v10 + 2) = 71;
    v10[16] = (uint64_t *)forward_pqmf_layer;
    v10[17] = (uint64_t *)free_pqmf_buffer;
    v10[18] = (uint64_t *)pqmf_layer_update_shape;
    v10[19] = (uint64_t *)pqmf_layer_wanted_wb_len;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v14);
    free_pqmf_buffer(v10);
    uint64_t result = 10;
  }
  *a3 = v10;
  return result;
}

uint64_t forward_pqmf_layer(uint64_t a1, uint64_t a2, uint64_t a3, float *a4)
{
  int v6 = *(unsigned int **)(a2 + 120);
  int v7 = *(_DWORD *)(a2 + 24);
  uint64_t v8 = *(void *)(a2 + 88);
  uint64_t v9 = v6[1];
  uint64_t padded_len = get_padded_len(*v6, 8u);
  uint64_t v17 = a4;
  bzero(a4, 4 * (v9 * v7));
  if (v7 != padded_len / v9)
  {
    unsigned int v11 = 0;
    uint64_t v12 = 0;
    do
    {
      if (v9)
      {
        unsigned int v13 = 0;
        uint64_t v14 = v9;
        unsigned int v15 = v11;
        do
        {
          axpy(padded_len, (float *)(v8 + 4 * v13), 1, &v17[(v9 * v12)], 1, *(float *)(a3 + 4 * v15));
          v13 += padded_len;
          ++v15;
          --v14;
        }
        while (v14);
      }
      ++v12;
      v11 += v9;
    }
    while (v12 != v7 - padded_len / v9);
  }
  return 0;
}

void *free_pqmf_buffer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      if (result[15])
      {
        (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        v1[15] = 0;
      }
      uint64_t v3 = *(void *)(v2 + 16);
      uint64_t v4 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v4(v3, v1);
    }
  }
  return result;
}

uint64_t pqmf_layer_update_shape(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v14 = 0;
  if (*a2 == 2 && a2[2] == *(_DWORD *)(*(void *)(a1 + 120) + 4))
  {
    long long v10 = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = a2[4];
    *(_OWORD *)(a1 + 20) = v10;
    uint64_t result = fi_shape_get_size(a2, &v14);
    if (!result)
    {
      int v12 = v14;
      *(_DWORD *)(a1 + 40) = 1;
      *(_DWORD *)(a1 + 44) = v12;
      *(_DWORD *)(a1 + 56) = a2[4];
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"pqmf input must be exactly 2 dimensional and matches the pqmf bands!", a6, a7, a8, v13);
    return 7;
  }
  return result;
}

uint64_t pqmf_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v5 = *(unsigned int **)(a1 + 120);
  *a2 = 4 * get_padded_len(*v5, 8u) * v5[1];
  *a3 = 0;
  log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"len : %d\n", v6, v7, v8, *v5);
  log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"bands : %d\n", v9, v10, v11, v5[1]);
  log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v12, v13, v14, *(unsigned int *)(a1 + 96));
  return 0;
}

uint64_t create_sampling_layer(uint64_t *a1, void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v11 && (uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16)) != 0)
  {
    uint64_t v13 = (void *)v12;
    uint64_t result = 0;
    *uint64_t v13 = *a2;
    v13[1] = a3;
    *(void *)(v11 + 120) = v13;
    *(void *)uint64_t v11 = a1;
    *(_DWORD *)(v11 + 8) = 28;
    *(void *)(v11 + 128) = forward_sampling_layer;
    *(void *)(v11 + 136) = free_sampling_buffer;
    *(void *)(v11 + 144) = sampling_layer_update_shape;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v15);
    free_sampling_buffer((void *)v11);
    uint64_t result = 10;
  }
  *a4 = v11;
  return result;
}

uint64_t forward_sampling_layer(uint64_t a1, uint64_t a2, char *a3, char *a4)
{
  *(void *)uint64_t v18 = 0;
  uint64_t v7 = *(int **)(a2 + 120);
  int v9 = *v7;
  int v8 = v7[1];
  uint64_t v10 = (unsigned int *)*((void *)v7 + 1);
  uint64_t v11 = (int *)(a2 + 20);
  int step = fi_shape_get_step((_DWORD *)(a2 + 20));
  uint64_t result = fi_shape_get_size((int *)(a2 + 40), &v18[1]);
  if (!result)
  {
    uint64_t result = fi_shape_get_input_dim(v11, v18);
    if (!result)
    {
      if (*v11 == 1)
      {
        if (v9)
        {
          if (v9 == 1) {
            gmm_type2(a3, v18[0], v10, a4, v8);
          }
        }
        else
        {
          multinomial((uint64_t)a3, v18[0], v10, (float *)a4, v8, v14);
        }
      }
      else if (step)
      {
        for (int i = 0; i != step; ++i)
        {
          uint64_t v16 = &a3[4 * v18[0] * i];
          uint64_t v17 = &a4[4 * *(_DWORD *)(a2 + 48) * i];
          if (v9)
          {
            if (v9 == 1) {
              gmm_type2(v16, v18[0], v10, v17, v8);
            }
          }
          else
          {
            float v14 = multinomial((uint64_t)v16, v18[0], v10, (float *)v17, v8, v14);
          }
        }
      }
      return 0;
    }
  }
  return result;
}

void *free_sampling_buffer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      if (result[15])
      {
        (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        v1[15] = 0;
      }
      uint64_t v3 = *(void *)(v2 + 16);
      uint64_t v4 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v4(v3, v1);
    }
  }
  return result;
}

uint64_t sampling_layer_update_shape(uint64_t a1, long long *a2)
{
  unsigned int v14 = 0;
  int v4 = **(_DWORD **)(a1 + 120);
  long long v5 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v5;
  uint64_t result = fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v14);
  if (result) {
    return result;
  }
  if (v4 == 1)
  {
    unsigned int v10 = v14 >> 2;
    goto LABEL_6;
  }
  if (!v4)
  {
    unsigned int v10 = 1;
LABEL_6:
    unsigned int v14 = v10;
  }
  if (*(_DWORD *)a2 == 2)
  {
    uint64_t result = 0;
    *(_DWORD *)(a1 + 40) = 2;
    unsigned int v12 = v14;
    *(_DWORD *)(a1 + 44) = *((_DWORD *)a2 + 1);
    *(_DWORD *)(a1 + 48) = v12;
    goto LABEL_11;
  }
  if (*(_DWORD *)a2 == 1)
  {
    uint64_t result = 0;
    unsigned int v11 = v14;
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = v11;
LABEL_11:
    *(_DWORD *)(a1 + 56) = *((_DWORD *)a2 + 4);
    return result;
  }
  log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently sampling layer only support 1D or 2D input", v7, v8, v9, v13);
  return 7;
}

void gmm_type2(void *__src, unsigned int a2, unsigned int *a3, char *__dst, int a5)
{
  uint64_t v10 = a2 >> 2;
  if (a2 < 4)
  {
LABEL_9:
    memcpy(__dst, __src, a2 & 0xFFFFFFFC);
    if (a5 != 4)
    {
      if (a5 == 3 && a2 >= 4)
      {
        uint64_t v19 = 0;
        if (v10 <= 1) {
          uint64_t v20 = 1;
        }
        else {
          uint64_t v20 = v10;
        }
        do
        {
          if (*((float *)__src + v10 + v19) <= fmaxf(*((float *)__src + v19), 0.0)) {
            int v21 = 2;
          }
          else {
            int v21 = 3;
          }
          *(_DWORD *)&__dst[4 * v19] = *((_DWORD *)__src + (v19 + v10 * v21));
          ++v19;
        }
        while (v20 != v19);
      }
      return;
    }
    if (a2 < 4) {
      return;
    }
    uint64_t v22 = (2 * v10);
    unsigned int v23 = *a3;
    if (v10 <= 1) {
      uint64_t v24 = 1;
    }
    else {
      uint64_t v24 = v10;
    }
    uint64_t v25 = (float *)__src;
    while (1)
    {
      unsigned int v23 = (1103515245 * v23 + 12345) & 0x7FFFFFFF;
      float v26 = (float)v23 * 4.6566e-10;
      float v27 = *v25 + 0.0;
      if (v27 > v26) {
        break;
      }
      unsigned int v28 = v10;
      if ((float)(v27 + v25[v10]) > v26) {
        goto LABEL_28;
      }
LABEL_29:
      ++v25;
      __dst += 4;
      ++v22;
      if (!--v24)
      {
        *a3 = v23;
        return;
      }
    }
    unsigned int v28 = 0;
LABEL_28:
    *(_DWORD *)char __dst = *((_DWORD *)__src + v22 + v28);
    goto LABEL_29;
  }
  uint64_t v11 = 0;
  if (v10 <= 1) {
    uint64_t v12 = 1;
  }
  else {
    uint64_t v12 = v10;
  }
  while (1)
  {
    uint64_t v13 = 0;
    float v14 = 0.0;
    char v15 = 1;
    do
    {
      char v16 = v15;
      uint64_t v17 = v11 + v13 * v10;
      double v18 = exp_fdlibm(*((float *)__src + v17));
      char v15 = 0;
      *(float *)&double v18 = v18;
      *((_DWORD *)__src + v17) = LODWORD(v18);
      float v14 = v14 + *(float *)&v18;
      uint64_t v13 = 1;
    }
    while ((v16 & 1) != 0);
    if (v14 == 0.0) {
      break;
    }
    *((float *)__src + v11) = *((float *)__src + v11) / v14;
    *((float *)__src + v11 + v10) = *((float *)__src + v11 + v10) / v14;
    if (++v11 == v12) {
      goto LABEL_9;
    }
  }
}

float multinomial(uint64_t a1, int a2, unsigned int *a3, float *a4, int a5, float result)
{
  if (a5 == 3)
  {
    LODWORD(v8) = fi_argmax(a1, a2);
LABEL_9:
    uint64_t result = (float)v8;
    *a4 = (float)v8;
    return result;
  }
  if (a5 == 4)
  {
    unsigned int v7 = (1103515245 * *a3 + 12345) & 0x7FFFFFFF;
    *a3 = v7;
    if (a2)
    {
      uint64_t v8 = 0;
      uint64_t result = (float)v7 * 4.6566e-10;
      float v9 = 0.0;
      while (1)
      {
        float v9 = v9 + *(float *)(a1 + 4 * v8);
        if (v9 > result) {
          break;
        }
        if (a2 == ++v8) {
          return result;
        }
      }
      goto LABEL_9;
    }
  }
  return result;
}

uint64_t trans_dec_dispatch_weights(uint64_t a1)
{
  padded_uint64_t bytes = 0;
  uint64_t v1 = *(uint64_t **)(a1 + 120);
  uint64_t v2 = *(void *)(a1 + 72);
  uint64_t result = fi_layer_find_weights_via_offset(v1[7], v2, &padded_bytes);
  if (!result)
  {
    padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
    uint64_t result = fi_layer_find_weights_via_offset(v1[8], v2, &padded_bytes);
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
      uint64_t result = fi_layer_find_weights_via_offset(v1[9], v2, &padded_bytes);
      if (!result)
      {
        get_padded_bytes(padded_bytes, 8u);
        return 0;
      }
    }
  }
  return result;
}

uint64_t create_trans_dec_layer(uint64_t *a1, long long *a2, void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7 = 0;
  uint64_t result = 7;
  if (a1 && a2)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 80);
      uint64_t v19 = v15;
      if (!v15)
      {
        uint64_t v28 = *a1;
        uint64_t v29 = "out of memory!";
        goto LABEL_11;
      }
      long long v20 = *a2;
      long long v21 = a2[1];
      long long v22 = a2[2];
      *(_DWORD *)(v15 + 48) = *((_DWORD *)a2 + 12);
      *(_OWORD *)(v15 + 16) = v21;
      *(_OWORD *)(v15 + 32) = v22;
      *(_OWORD *)uint64_t v15 = v20;
      long long v41 = 0u;
      long long v40 = 0u;
      memset(v35, 0, sizeof(v35));
      int v39 = 0;
      int v37 = 1;
      *(void *)&long long v21 = *((void *)a2 + 2);
      uint64_t v38 = *((void *)a2 + 3);
      uint64_t v36 = v21;
      *(float *)&long long v40 = (float)*((unsigned int *)a2 + 8);
      *((void *)&v41 + 1) = 0;
      uint64_t v42 = 1;
      if (create_att_layer(a1, (unsigned int *)&v36, a3, a4, (uint64_t *)(v15 + 56))) {
        goto LABEL_7;
      }
      int v39 = 1;
      int v37 = 1;
      uint64_t v26 = *((void *)a2 + 2);
      uint64_t v38 = *((void *)a2 + 3);
      uint64_t v36 = v26;
      *(float *)&long long v40 = (float)*((unsigned int *)a2 + 8);
      *((void *)&v41 + 1) = 0;
      LODWORD(v42) = 1;
      if (create_att_layer(a1, (unsigned int *)&v36, a3, a4, (uint64_t *)(v19 + 64)))
      {
LABEL_7:
        float v27 = "create trans_dec att layer failed!";
LABEL_8:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v27, v23, v24, v25, v33);
        uint64_t v28 = *a1;
        uint64_t v29 = "trans_dec network init failed!";
LABEL_11:
        log_OutText(v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)v29, v16, v17, v18, v33);
        *(void *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_dec init param failed!", v30, v31, v32, v34);
        uint64_t result = 7;
        goto LABEL_12;
      }
      *(_DWORD *)uint64_t v35 = *(_DWORD *)a2;
      *(int8x16_t *)&v35[4] = vextq_s8(*(int8x16_t *)((char *)a2 + 4), *(int8x16_t *)((char *)a2 + 4), 0xCuLL);
      if (create_ffn_layer(a1, (long long *)v35, a3, a4, (uint64_t *)(v19 + 72)))
      {
        float v27 = "create trans_dec ffn layer failed!";
        goto LABEL_8;
      }
      *(void *)(v7 + 120) = v19;
      if (a3) {
        *(void *)(v7 + 60) = *a3;
      }
      *(void *)uint64_t v7 = a1;
      *(void *)(v7 + 8) = 37;
      *(void *)(v7 + 128) = forward_trans_dec_layer;
      *(void *)(v7 + 136) = free_trans_dec_layer;
      *(void *)(v7 + 144) = trans_dec_layer_update_shape;
      *(void *)(v7 + 152) = trans_dec_layer_wanted_wb_len;
      *(void *)(v7 + 160) = trans_dec_request_glbBuf;
      *(void *)(v7 + 184) = trans_dec_dispatch_weights;
      *(void *)(v7 + 168) = trans_dec_assign_glbBuf;
      *(void *)(v7 + 176) = trans_dec_layer_reset;
      if (a4)
      {
        uint64_t result = 0;
        *(void *)(v7 + 256) = *(void *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v23, v24, v25, v33);
        uint64_t result = 0;
        *(void *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v33);
      uint64_t result = 10;
    }
  }
LABEL_12:
  *a5 = v7;
  return result;
}

uint64_t forward_trans_dec_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  LODWORD(v17) = 0;
  if (!a2) {
    return 0;
  }
  uint64_t v7 = *(uint64_t **)a2;
  uint64_t v8 = *(void **)(a2 + 120);
  uint64_t bytes = fi_shape_get_bytes((int *)(v8[7] + 40), &v17);
  if (!bytes)
  {
    bzero(*(void **)(a2 + 240), (2 * v17));
    uint64_t v10 = (*(uint64_t (**)(uint64_t))(v8[7] + 128))(a1);
    if (v10 || (uint64_t v10 = (*(uint64_t (**)(uint64_t))(v8[8] + 128))(a1), v10))
    {
      uint64_t bytes = v10;
      uint64_t v14 = "trans_dec forward att layer failed!";
LABEL_6:
      log_OutText(*v7, (uint64_t)"FastInfer", 0, 0, (uint64_t)v14, v11, v12, v13, v16);
      return bytes;
    }
    uint64_t bytes = fi_shape_get_bytes((int *)(v8[9] + 40), &v17);
    if (!bytes)
    {
      bzero(a4, v17);
      uint64_t bytes = (*(uint64_t (**)(uint64_t))(v8[9] + 128))(a1);
      if (bytes)
      {
        uint64_t v14 = "trans_dec forward ffn layer failed!";
        goto LABEL_6;
      }
    }
  }
  return bytes;
}

void *free_trans_dec_layer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[9]);
        fi_layer_free(v3[7]);
        fi_layer_free(v3[8]);
        (*(void (**)(void, uint64_t *))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v4 = *(void *)(v2 + 16);
      long long v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v5(v4, v1);
    }
  }
  return result;
}

__n128 trans_dec_layer_update_shape(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void **)(a1 + 120);
  float v9 = *(uint64_t **)a1;
  int v10 = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = *a2;
  *(_DWORD *)(a1 + 36) = v10;
  long long v20 = *a2;
  int v21 = *((_DWORD *)a2 + 4);
  DWORD1(v20) = 1;
  if (*(_DWORD *)a2 >= 3u)
  {
    uint64_t v11 = *v9;
    uint64_t v12 = "Currently trans_dec layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)v12, a6, a7, a8, v20);
    return result;
  }
  if (!(*(unsigned int (**)(void, long long *, uint64_t))(v8[7] + 144))(v8[7], &v20, a3)
    && !(*(unsigned int (**)(void, uint64_t, uint64_t))(v8[8] + 144))(v8[8], v8[7] + 40, v15)
    && !(*(unsigned int (**)(void, uint64_t, uint64_t))(v8[9] + 144))(v8[9], v8[8] + 40, v16))
  {
    uint64_t v17 = v8[9];
    int v19 = *(_DWORD *)(v17 + 40);
    uint64_t v18 = (__n128 *)(v17 + 40);
    if ((v19 - 1) >= 2)
    {
      uint64_t v11 = **(void **)a1;
      uint64_t v12 = "dense out: output shape error";
      goto LABEL_3;
    }
    __n128 result = *v18;
    *(_DWORD *)(a1 + 56) = v18[1].n128_u32[0];
    *(__n128 *)(a1 + 40) = result;
  }
  return result;
}

uint64_t trans_dec_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6 = *(void **)(a1 + 120);
  uint64_t result = (*(uint64_t (**)(void))(v6[7] + 152))();
  if (!result)
  {
    padded_uint64_t bytes = get_padded_bytes(0, 8u);
    uint64_t result = (*(uint64_t (**)(void))(v6[8] + 152))();
    if (!result)
    {
      unsigned int v9 = get_padded_bytes(padded_bytes, 8u);
      uint64_t result = (*(uint64_t (**)(void))(v6[9] + 152))();
      if (!result)
      {
        *a2 = get_padded_bytes(v9, 8u);
        *a3 = 0;
        log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v10, v11, v12, *(unsigned int *)(a1 + 96));
        log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v13, v14, v15, *a2);
        return 0;
      }
    }
  }
  return result;
}

uint64_t trans_dec_request_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 120);
  uint64_t result = (*(uint64_t (**)(void))(v2[7] + 160))();
  if (!result)
  {
    unsigned int v4 = *(_DWORD *)(v2[7] + 248);
    uint64_t result = (*(uint64_t (**)(void))(v2[8] + 160))();
    if (!result)
    {
      unsigned int v5 = *(_DWORD *)(v2[8] + 248);
      uint64_t result = (*(uint64_t (**)(void))(v2[9] + 160))();
      if (!result)
      {
        unsigned int v6 = *(_DWORD *)(v2[9] + 248);
        unsigned int v8 = v6;
        uint64_t result = trans_dec_get_reserved_glbBuf_bytes(a1, &v8);
        if (!result)
        {
          if (v5 <= v4) {
            unsigned int v7 = v4;
          }
          else {
            unsigned int v7 = v5;
          }
          if (v6 > v7) {
            unsigned int v7 = v6;
          }
          *(_DWORD *)(a1 + 248) = v8 + v7;
        }
      }
    }
  }
  return result;
}

uint64_t trans_dec_assign_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 120);
  unsigned int v8 = 0;
  uint64_t result = trans_dec_get_reserved_glbBuf_bytes(a1, &v8);
  if (!result)
  {
    uint64_t v4 = v8;
    uint64_t v5 = v2[7];
    uint64_t v6 = v2[8];
    *(void *)(v5 + 240) = *(void *)(a1 + 240) + v8;
    *(_DWORD *)(v5 + 248) = *(_DWORD *)(a1 + 248) - v4;
    *(void *)(v6 + 240) = *(void *)(a1 + 240) + v4;
    *(_DWORD *)(v6 + 248) = *(_DWORD *)(a1 + 248) - v4;
    uint64_t v7 = v2[9];
    *(void *)(v7 + 240) = *(void *)(a1 + 240) + v4;
    *(_DWORD *)(v7 + 248) = *(_DWORD *)(a1 + 248) - v4;
  }
  return result;
}

uint64_t trans_dec_layer_reset(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120);
  if ((*(unsigned int (**)(void))(*(void *)(v2 + 56) + 176))()
    || (uint64_t result = (*(uint64_t (**)(void))(*(void *)(v2 + 64) + 176))(), result))
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_dec network reset failed!", v3, v4, v5, v7);
    return 7;
  }
  return result;
}

uint64_t trans_dec_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = *(void *)(a1 + 120);
  int v6 = 0;
  uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v3 + 56) + 40), &v6);
  if (!bytes) {
    *a2 = get_padded_bytes(2 * v6, 8u);
  }
  return bytes;
}

uint64_t create_att_layer(uint64_t *a1, unsigned int *a2, void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7 = 0;
  uint64_t result = 7;
  if (a1 && a2)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 160);
      uint64_t v19 = v15;
      if (!v15)
      {
        uint64_t v28 = *a1;
        uint64_t v29 = "out of memory!";
        goto LABEL_9;
      }
      long long v20 = *(_OWORD *)a2;
      long long v21 = *((_OWORD *)a2 + 1);
      long long v22 = *((_OWORD *)a2 + 3);
      *(_OWORD *)(v15 + 32) = *((_OWORD *)a2 + 2);
      *(_OWORD *)(v15 + 48) = v22;
      *(_OWORD *)uint64_t v15 = v20;
      *(_OWORD *)(v15 + 16) = v21;
      int v36 = 0;
      *(_DWORD *)(v15 + 152) = 0;
      int padded_len = get_padded_len(*a2, 8u);
      int v24 = *a2;
      HIDWORD(v34) = 40;
      int v35 = v24;
      if (create_norm_layer(a1, (uint64_t *)((char *)&v34 + 4), (uint64_t *)(v19 + 64)))
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"create att norm layer failed!", v25, v26, v27, v34);
        uint64_t v28 = *a1;
        uint64_t v29 = "att network init failed!";
LABEL_9:
        log_OutText(v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)v29, v16, v17, v18, v34);
        *(void *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"att init param failed!", v30, v31, v32, v34);
        uint64_t result = 7;
        goto LABEL_10;
      }
      int v35 = padded_len;
      int v36 = 0;
      HIDWORD(v34) = 5;
      *(_OWORD *)(v19 + 120) = 0u;
      *(_OWORD *)(v19 + 136) = 0u;
      if (a2[2])
      {
        unsigned int v33 = a2[5];
        if (v33 == 1)
        {
          if (!a2[14])
          {
            *(void *)(v19 + 136) = (*(uint64_t (**)(uint64_t, void, uint64_t))(a1[1] + 16))(a1[2], a2[3] * padded_len, 4);
            *(void *)(v19 + 144) = (*(uint64_t (**)(uint64_t, void, uint64_t))(a1[1] + 16))(a1[2], a2[3] * padded_len, 4);
          }
        }
        else if (!v33 && !a2[14])
        {
          *(void *)(v19 + 120) = (*(uint64_t (**)(uint64_t, void, uint64_t))(a1[1] + 16))(a1[2], a2[4] * padded_len, 4);
          *(void *)(v19 + 128) = (*(uint64_t (**)(uint64_t, void, uint64_t))(a1[1] + 16))(a1[2], a2[4] * padded_len, 4);
        }
      }
      *(_DWORD *)(v19 + 112) = 0;
      if (!*((void *)a2 + 6)) {
        *(void *)(v19 + 104) = 0;
      }
      *(void *)(v7 + 120) = v19;
      if (a3) {
        *(void *)(v7 + 60) = *a3;
      }
      *(void *)uint64_t v7 = a1;
      *(void *)(v7 + 8) = 34;
      *(void *)(v7 + 128) = forward_att_layer;
      *(void *)(v7 + 136) = free_att_layer;
      *(void *)(v7 + 144) = att_layer_update_shape;
      *(void *)(v7 + 152) = att_layer_wanted_wb_len;
      *(void *)(v7 + 160) = att_request_glbBuf;
      *(void *)(v7 + 184) = att_dispatch_weights;
      *(void *)(v7 + 176) = att_layer_reset;
      if (a4)
      {
        uint64_t result = 0;
        *(void *)(v7 + 256) = *(void *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v25, v26, v27, v34);
        uint64_t result = 0;
        *(void *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v34);
      uint64_t result = 10;
    }
  }
LABEL_10:
  *a5 = v7;
  return result;
}

uint64_t forward_att_layer(uint64_t a1, uint64_t a2, void *a3, float32x4_t *a4)
{
  if (!a2) {
    return 0;
  }
  uint64_t v7 = *(uint64_t **)a2;
  unsigned int v8 = *(unsigned int **)(a2 + 120);
  uint64_t step = fi_shape_get_step((_DWORD *)(a2 + 20));
  unsigned int v10 = step;
  uint64_t padded_len = get_padded_len(step, 8u);
  unsigned int v12 = *v8;
  uint64_t v13 = get_padded_len(*v8, 8u);
  unsigned int v14 = v8[3];
  int v15 = get_padded_len(v14, 8u);
  unsigned int v19 = v8[5];
  unsigned int v20 = v8[2];
  if (v20) {
    BOOL v21 = 0;
  }
  else {
    BOOL v21 = v19 == 1;
  }
  if (v21)
  {
    log_OutText(*v7, (uint64_t)"FastInfer", 0, 0, (uint64_t)"encoder decoder attention is possible only if isDecoder option has been set to 1", v16, v17, v18, v60);
    return 7;
  }
  unsigned int v81 = v10;
  uint64_t v70 = v8[1];
  unsigned int __src = a3;
  uint64_t v82 = v7;
  unsigned int v69 = v8[5];
  unsigned int v67 = v12;
  int v76 = v15;
  if (v19 == 1)
  {
    unsigned int v22 = fi_shape_get_step(v8 + 7);
    uint64_t v23 = *(float32x4_t **)(a2 + 240);
    if (v8[2])
    {
      uint64_t v78 = (float32x4_t *)*((void *)v8 + 17);
      int v24 = (float32x4_t *)*((void *)v8 + 18);
LABEL_13:
      uint64_t v68 = v24;
      uint64_t v73 = v23;
      int v26 = v10;
      uint64_t v27 = v13;
      goto LABEL_15;
    }
  }
  else
  {
    unsigned int v22 = v10 + v10 * v8[38];
    uint64_t v23 = *(float32x4_t **)(a2 + 240);
    if (v20)
    {
      uint64_t v78 = (float32x4_t *)*((void *)v8 + 15);
      int v24 = (float32x4_t *)*((void *)v8 + 16);
      goto LABEL_13;
    }
  }
  uint64_t v27 = v13;
  int v26 = v10;
  bzero(&v23->f32[v13 * v10], 4 * v13 * v10);
  uint64_t v68 = 0;
  uint64_t v78 = (float32x4_t *)((char *)v23 + 4 * v13 * v10);
  uint64_t v73 = v78;
LABEL_15:
  bzero(v23, 4 * (v27 * v26));
  uint64_t v28 = (*(uint64_t (**)(uint64_t))(*((void *)v8 + 8) + 128))(a1);
  if (v28)
  {
    uint64_t v25 = v28;
    log_OutText(*v82, (uint64_t)"FastInfer", 0, 0, (uint64_t)"att forward norm layer failed!", v29, v30, v31, v60);
  }
  else
  {
    int v77 = v76 * v14;
    uint64_t v32 = &v73->f32[(v27 * v26)];
    bzero(a4, 4 * (v27 * v26));
    gemm_v2((uint64_t)v82, 0, v26, v27, v27, (uint64_t)v23, v27, *((void *)v8 + 10), v27, a4, v27);
    uint64_t __n = 4 * (v27 * v26);
    uint64_t v74 = v32;
    uint64_t v75 = v23;
    if (v69 == 1)
    {
      uint64_t v34 = (float32x4_t *)*((void *)v8 + 17);
      unsigned int v33 = (float32x4_t *)*((void *)v8 + 18);
      unsigned int v35 = v70;
      uint64_t v68 = v33;
      if (!v8[28])
      {
        bzero(v34, 4 * v22 * v27);
        bzero(v33, 4 * v22 * v27);
        gemm_v2((uint64_t)v82, 0, v22, v27, v27, *((void *)v8 + 13), v27, *((void *)v8 + 9), v27, v34, v27);
        gemm_v2((uint64_t)v82, 0, v22, v27, v27, *((void *)v8 + 13), v27, *((void *)v8 + 11), v27, v33, v27);
        v8[28] = 1;
      }
      unsigned int v36 = v77;
    }
    else
    {
      uint64_t v34 = v78;
      bzero(&v78->f32[v8[38] * v27], 4 * (v27 * v26));
      gemm_v2((uint64_t)v82, 0, v26, v27, v27, (uint64_t)v23, v27, *((void *)v8 + 9), v27, (float32x4_t *)((char *)v78 + 4 * v8[38] * v27), v27);
      unsigned int v35 = v70;
      unsigned int v36 = v77;
    }
    unsigned int v66 = v27;
    uint64_t v72 = (char *)&v32[v36];
    bzero(v32, 4 * (v36 + v36 * v35));
    uint64_t v37 = v67 / v35;
    if (v35)
    {
      int v38 = 0;
      int v39 = 0;
      uint64_t v79 = v34;
      uint64_t v40 = v70;
      do
      {
        gemm_v2((uint64_t)v82, 1, v81, v22, v37, (uint64_t)a4->i64 + 4 * (v37 * v39), v27, (uint64_t)v79->i64 + 4 * (v37 * v39), v27, (float32x4_t *)&v74[v38], padded_len);
        ++v39;
        v38 += v77;
        --v40;
      }
      while (v40);
      int v41 = v70 - 1;
      if ((int)v70 - 1 >= 0)
      {
        do
        {
          if (v81)
          {
            int v42 = 0;
            uint64_t v43 = v81;
            do
            {
              softmax(&v74[v41 * v77 + v42], v22, 1, (float *)&v72[4 * v41 * v77 + 4 * v42], *((float *)v8 + 6));
              v42 += padded_len;
              --v43;
            }
            while (v43);
          }
          BOOL v44 = __OFSUB__(v41--, 1);
        }
        while (v41 < 0 == v44);
      }
    }
    uint64_t v64 = v8;
    if (v69)
    {
      unint64_t v45 = v68;
      uint64_t v46 = v75;
      uint64_t v47 = v70;
      size_t v48 = __n;
    }
    else
    {
      unsigned int v49 = v68;
      if (!v8[2]) {
        unsigned int v49 = a4;
      }
      size_t v48 = __n;
      bzero(&v49->f32[v8[38] * v66], __n);
      unint64_t v45 = v49;
      uint64_t v46 = v75;
      gemm_v2((uint64_t)v82, 0, v81, v66, v66, (uint64_t)v75, v66, *((void *)v8 + 11), v66, (float32x4_t *)((char *)v49 + 4 * v8[38] * v66), v66);
      uint64_t v47 = v70;
    }
    bzero(v46, v48);
    uint64_t v50 = v66;
    float v51 = v72;
    if (v47)
    {
      int v52 = 0;
      int v53 = 0;
      do
      {
        uint64_t v54 = (uint64_t)v45->i64 + 4 * (v37 * v53);
        int v63 = v50;
        unsigned int v61 = v50;
        uint64_t v62 = (float32x4_t *)((char *)v75 + 4 * (v37 * v53));
        int v55 = v37;
        uint64_t v56 = v50;
        uint64_t v57 = v37;
        uint64_t v58 = v51;
        gemm_v2((uint64_t)v82, 0, v81, v55, v22, (uint64_t)&v51[4 * v52], padded_len, v54, v61, v62, v63);
        float v51 = v58;
        uint64_t v37 = v57;
        uint64_t v50 = v56;
        ++v53;
        v52 += v77;
        --v47;
      }
      while (v47);
    }
    memcpy(a4, __src, __n);
    gemm_v2((uint64_t)v82, 0, v81, v50, v50, (uint64_t)v75, v50, *((void *)v64 + 12), v50, a4, v50);
    uint64_t v25 = 0;
    ++v64[38];
  }
  return v25;
}

void *free_att_layer(void *result)
{
  if (!result) {
    return result;
  }
  uint64_t v1 = result;
  uint64_t v2 = *result;
  if (!*result) {
    return result;
  }
  uint64_t v3 = result[15];
  if (v3)
  {
    fi_layer_free(*(void *)(v3 + 64));
    if (*(void *)(v3 + 48))
    {
      if (!*(void *)(v3 + 104)) {
        goto LABEL_8;
      }
      (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
    }
    *(void *)(v3 + 104) = 0;
LABEL_8:
    if (*(_DWORD *)(v3 + 8))
    {
      int v4 = *(_DWORD *)(v3 + 20);
      if (v4 == 1)
      {
        if (*(_DWORD *)(v3 + 56)) {
          goto LABEL_22;
        }
        if (*(void *)(v3 + 136))
        {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
          *(void *)(v3 + 136) = 0;
        }
        uint64_t v5 = (void *)(v3 + 144);
        if (!*(void *)(v3 + 144)) {
          goto LABEL_22;
        }
      }
      else
      {
        if (v4 || *(_DWORD *)(v3 + 56)) {
          goto LABEL_22;
        }
        if (*(void *)(v3 + 120))
        {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
          *(void *)(v3 + 120) = 0;
        }
        uint64_t v5 = (void *)(v3 + 128);
        if (!*(void *)(v3 + 128)) {
          goto LABEL_22;
        }
      }
      (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
      *uint64_t v5 = 0;
    }
LABEL_22:
    (*(void (**)(void, uint64_t))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
  }
  if (*((_DWORD *)v1 + 29))
  {
    if (v1[9]) {
      (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
    }
    *(_OWORD *)(v1 + 11) = 0u;
    *(_OWORD *)(v1 + 13) = 0u;
    *(_OWORD *)(v1 + 9) = 0u;
  }
  uint64_t v6 = *(void *)(v2 + 16);
  uint64_t v7 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
  return (void *)v7(v6, v1);
}

__n128 att_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(uint64_t **)a1;
  if (*a2 >= 3u)
  {
    uint64_t v9 = *v8;
    unsigned int v10 = "Currently att layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)v10, a6, a7, a8, v16);
    return result;
  }
  uint64_t v13 = *(void *)(a1 + 120);
  long long v14 = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = a2[4];
  *(_OWORD *)(a1 + 20) = v14;
  if (!(*(unsigned int (**)(void))(*(void *)(v13 + 64) + 144))())
  {
    uint64_t v15 = *(void *)(v13 + 64);
    if (*(_DWORD *)(v13 + 20) == 1)
    {
      *(_DWORD *)(v13 + 28) = 2;
      if (!v15)
      {
        uint64_t v9 = *v8;
        unsigned int v10 = "Must set external pointers before shape update for enc_dec att.";
        goto LABEL_3;
      }
    }
    __n128 result = *(__n128 *)(v15 + 40);
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(v15 + 56);
    *(__n128 *)(a1 + 40) = result;
  }
  return result;
}

uint64_t att_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6 = *(unsigned int **)(a1 + 120);
  uint64_t v7 = (*(uint64_t (**)(void))(*((void *)v6 + 8) + 152))();
  if (!v7)
  {
    padded_uint64_t bytes = get_padded_bytes(0, 8u);
    uint64_t padded_len = get_padded_len(*v6, 8u);
    *a2 = padded_bytes + 16 * padded_len * padded_len;
    *a3 = 0;
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"att k kernel size: %d\n", v10, v11, v12, padded_len);
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v13, v14, v15, *(unsigned int *)(a1 + 96));
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v16, v17, v18, *a2);
  }
  return v7;
}

uint64_t att_request_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(_DWORD **)(a1 + 120);
  int v3 = v2[1];
  int v4 = (int *)(a1 + 20);
  unsigned int step = fi_shape_get_step((_DWORD *)(a1 + 20));
  uint64_t v6 = v2[3];
  unsigned int v18 = 0;
  uint64_t result = fi_shape_get_input_dim(v4, (int *)&v18);
  if (!result)
  {
    int padded_len = get_padded_len(v18, 8u);
    if (v18 != *v2)
    {
      uint64_t v12 = **(void **)a1;
      uint64_t v13 = "att input sample dim mismatch! inshape: %d, but config: %d";
      uint64_t v17 = v18;
      goto LABEL_6;
    }
    if (step > v6)
    {
      uint64_t v12 = **(void **)a1;
      uint64_t v13 = "att: input len longer than maximum!";
LABEL_6:
      log_OutText(v12, (uint64_t)"FastInfer", 0, 0, (uint64_t)v13, v9, v10, v11, v17);
      return 7;
    }
    int v14 = (padded_len * v6) << (v2[2] == 0);
    int v15 = get_padded_len(v6, 8u);
    padded_uint64_t bytes = get_padded_bytes(4 * (v14 + ((int)v6 + (int)v6 * v3) * v15), 8u);
    uint64_t result = 0;
    *(_DWORD *)(a1 + 248) = padded_bytes;
  }
  return result;
}

uint64_t att_dispatch_weights(uint64_t a1)
{
  unsigned int v12 = 0;
  uint64_t v2 = *(uint64_t **)(a1 + 120);
  int padded_len = get_padded_len(*(unsigned int *)v2, 8u);
  uint64_t v4 = *(void *)(a1 + 72);
  uint64_t weights_via_offset = fi_layer_find_weights_via_offset(v2[8], v4, &v12);
  if (!weights_via_offset)
  {
    padded_uint64_t bytes = get_padded_bytes(v12, 8u);
    v2[9] = v4 + padded_bytes;
    int v7 = padded_len * padded_len;
    unsigned int v12 = padded_bytes + 4 * v7;
    unsigned int v8 = get_padded_bytes(v12, 8u);
    v2[12] = v4 + v8;
    unsigned int v12 = v8 + 4 * v7;
    unsigned int v9 = get_padded_bytes(v12, 8u);
    v2[10] = v4 + v9;
    unsigned int v12 = v9 + 4 * v7;
    unsigned int v10 = get_padded_bytes(v12, 8u);
    v2[11] = v4 + v10;
    unsigned int v12 = v10 + 4 * v7;
    get_padded_bytes(v12, 8u);
  }
  return weights_via_offset;
}

uint64_t att_layer_reset(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 120);
    if (*(_DWORD *)(v1 + 20) == 1)
    {
      *(void *)(v1 + 104) = 0;
      *(_DWORD *)(v1 + 112) = 0;
      *(_OWORD *)(v1 + 120) = 0u;
      *(_OWORD *)(v1 + 136) = 0u;
    }
  }
  return 0;
}

uint64_t config_conv1d_layer(int a1, int a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8)
{
  return config_conv_layer(a1, a2, 0, a3, 0, a4, a5, a6, a7, a8);
}

uint64_t create_conv1d_layer(uint64_t *a1, long long *a2, uint64_t **a3, uint64_t a4, uint64_t ***a5)
{
  int v15 = 0;
  uint64_t v11 = create_conv_layer(a1, a2, a3, &v15);
  if (v11)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"create conv layer failed!", v8, v9, v10, v14);
    unsigned int v12 = v15;
  }
  else
  {
    unsigned int v12 = v15;
    v15[1] = 0;
    v12[16] = (uint64_t *)forward_conv_layer;
    v12[17] = (uint64_t *)free_conv_buffer;
    v12[18] = (uint64_t *)conv1d_layer_update_shape;
    v12[19] = (uint64_t *)conv_layer_wanted_wb_len;
    if (a4)
    {
      v12[32] = *(uint64_t **)(a4 + 24);
      *((_DWORD *)v12 + 66) = *(_DWORD *)(a4 + 16);
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, use v0.0.0", v8, v9, v10, v14);
      unsigned int v12 = v15;
      v15[32] = 0;
      *((_DWORD *)v12 + 66) = 0;
    }
  }
  *a5 = v12;
  return v11;
}

uint64_t conv1d_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a2 == 2)
  {
    uint64_t v10 = *(_DWORD **)(a1 + 120);
    int v11 = a2[4];
    *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = v11;
    v10[1] = a2[2];
    v10[3] = 1;
    uint64_t result = get_padding_size(*(uint64_t **)a1, v10, *(_DWORD *)(a1 + 8), a2, v10 + 14, v10 + 15, v10 + 9);
    int v13 = v10[14] * v10[15];
    *(_DWORD *)(a1 + 40) = 2;
    *(_DWORD *)(a1 + 44) = v13;
    *(_DWORD *)(a1 + 48) = v10[4];
    *(_DWORD *)(a1 + 56) = a2[4];
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"conv1d requires input 2D input data", a6, a7, a8, v14);
    return 7;
  }
  return result;
}

uint64_t create_pooling2d_layer(uint64_t *a1, int a2, long long *a3, uint64_t **a4, uint64_t ***a5)
{
  uint64_t v14 = 0;
  uint64_t v10 = create_pooling_layer(a1, a2, a3, a4, &v14);
  if (v10)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"create pooling layer failed!", v7, v8, v9, v13);
    int v11 = v14;
  }
  else
  {
    int v11 = v14;
    v14[18] = (uint64_t *)pooling2d_layer_update_shape;
  }
  *a5 = v11;
  return v10;
}

uint64_t pooling2d_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a2 == 3)
  {
    uint64_t v10 = *(int **)(a1 + 120);
    int v11 = *(_DWORD *)(a1 + 8);
    long long v12 = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = a2[4];
    *(_OWORD *)(a1 + 20) = v12;
    if ((v11 & 0xFFFFFFFE) == 0x12)
    {
      *uint64_t v10 = a2[2];
      v10[1] = a2[3];
    }
    uint64_t v13 = v10 + 14;
    uint64_t v14 = v10 + 15;
    uint64_t result = get_padding_size(*(uint64_t **)a1, v10, v11, a2, (unsigned int *)v10 + 14, (unsigned int *)v10 + 15, v10 + 9);
    if (!result)
    {
      *(_DWORD *)(a1 + 40) = 3;
      int channel = fi_shape_get_channel(a2);
      uint64_t result = 0;
      *(_DWORD *)(a1 + 44) = channel;
      *(_DWORD *)(a1 + 48) = *v14;
      *(_DWORD *)(a1 + 52) = *v13;
      *(_DWORD *)(a1 + 56) = a2[4];
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Current conv layer only support input dim 2 or 3", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t forward_mulaw_layer(uint64_t a1, uint64_t a2, float *a3, float *a4)
{
  unsigned int v16 = 0;
  uint64_t v7 = *(void *)(a2 + 72);
  uint64_t size = fi_shape_get_size((int *)(a2 + 40), (int *)&v16);
  if (size)
  {
    log_OutText(**(void **)a2, (uint64_t)"FastInfer", 0, 0, (uint64_t)"input shape of mulaw layer is illegal", v8, v9, v10, v15);
  }
  else
  {
    uint64_t v12 = v16;
    if (v16)
    {
      do
      {
        float v13 = *a3++;
        *a4++ = (float)*(int *)(v7 + 4 * v13);
        --v12;
      }
      while (v12);
    }
  }
  return size;
}

void *free_mulaw_buffer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      if (result[15]) {
        (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v3 = *(void *)(v2 + 16);
      uint64_t v4 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v4(v3, v1);
    }
  }
  return result;
}

uint64_t create_mulaw_layer(uint64_t *a1, _DWORD *a2, uint64_t *a3)
{
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 4);
  if (v6
    && (uint64_t v10 = (_DWORD *)v6,
        (uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272)) != 0))
  {
    uint64_t v12 = 0;
    *uint64_t v10 = *a2;
    *(void *)uint64_t v11 = a1;
    *(_DWORD *)(v11 + 8) = 32;
    *(void *)(v11 + 120) = v10;
    *(void *)(v11 + 128) = forward_mulaw_layer;
    *(void *)(v11 + 136) = free_mulaw_buffer;
    *(void *)(v11 + 144) = mulaw_layer_update_shape;
    *(void *)(v11 + 152) = mulaw_layer_wanted_wb_len;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v14);
    free_mulaw_buffer(0);
    uint64_t v11 = 0;
    uint64_t v12 = 10;
  }
  *a3 = v11;
  return v12;
}

uint64_t mulaw_layer_update_shape(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t result = 0;
    long long v10 = *a2;
    *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
    *(_OWORD *)(a1 + 20) = v10;
    long long v11 = *a2;
    *(_DWORD *)(a1 + 56) = *((_DWORD *)a2 + 4);
    *(_OWORD *)(a1 + 40) = v11;
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"mulaw layer cant accept this input shape", a6, a7, a8, vars0);
    return 7;
  }
  return result;
}

uint64_t mulaw_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = **(unsigned int **)(a1 + 120);
  if (v8 > 0x20) {
    return 7;
  }
  log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"mu-law bits: %d\n", a6, a7, a8, v8);
  log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v13, v14, v15, *(unsigned int *)(a1 + 96));
  *a2 = 4 << v8;
  *a3 = 0;
  log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbBytes bBytes: %d %d\n", v16, v17, v18, *a2);
  return 0;
}

uint64_t create_albert_ffn_layer(uint64_t *a1, long long *a2, void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7 = 0;
  uint64_t result = 7;
  if (a1 && a2)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 48);
      uint64_t v19 = v15;
      if (!v15)
      {
        uint64_t v26 = *a1;
        uint64_t v27 = "out of memory!";
LABEL_14:
        log_OutText(v26, (uint64_t)"FastInfer", 0, 0, (uint64_t)v27, v16, v17, v18, v31);
        *(void *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"albert_ffn init param failed!", v28, v29, v30, v32);
        uint64_t result = 7;
        goto LABEL_15;
      }
      long long v20 = *a2;
      *(_DWORD *)(v15 + 16) = *((_DWORD *)a2 + 4);
      *(_OWORD *)uint64_t v15 = v20;
      int v21 = *((_DWORD *)a2 + 1);
      LODWORD(v34) = 40;
      HIDWORD(v34) = v21;
      int v35 = 0;
      if (create_norm_layer(a1, &v34, (uint64_t *)(v15 + 24)))
      {
        uint64_t v25 = "create albert_ffn norm layer failed!";
LABEL_13:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v25, v22, v23, v24, v31);
        uint64_t v26 = *a1;
        uint64_t v27 = "albert_ffn network init failed!";
        goto LABEL_14;
      }
      HIDWORD(v34) = *(_DWORD *)a2;
      int v35 = 0;
      LODWORD(v34) = 5;
      int32x2_t v33 = vrev64_s32(*(int32x2_t *)((char *)a2 + 8));
      if (create_fc_layer(a1, &v34, &v33, a3, a4, (uint64_t *)(v19 + 32)))
      {
        uint64_t v25 = "create albert_ffn o1 dense layer failed!";
        goto LABEL_13;
      }
      HIDWORD(v34) = *((_DWORD *)a2 + 1);
      int v35 = 0;
      LODWORD(v34) = 5;
      v33.i32[0] = *((_DWORD *)a2 + 4);
      if (create_fc_layer(a1, &v34, &v33, a3, a4, (uint64_t *)(v19 + 40)))
      {
        uint64_t v25 = "create albert_ffn o2 dense layer failed!";
        goto LABEL_13;
      }
      *(void *)(v7 + 120) = v19;
      if (a3) {
        *(void *)(v7 + 60) = *a3;
      }
      *(void *)uint64_t v7 = a1;
      *(void *)(v7 + 8) = 44;
      *(void *)(v7 + 128) = forward_albert_ffn_layer;
      *(void *)(v7 + 136) = free_albert_ffn_layer;
      *(void *)(v7 + 144) = albert_ffn_layer_update_shape;
      *(void *)(v7 + 152) = albert_ffn_layer_wanted_wb_len;
      *(void *)(v7 + 160) = albert_ffn_request_glbBuf;
      *(void *)(v7 + 184) = albert_ffn_dispatch_weights;
      if (a4)
      {
        uint64_t result = 0;
        *(void *)(v7 + 256) = *(void *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, using default (0)", v22, v23, v24, v31);
        uint64_t result = 0;
        *(void *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v31);
      uint64_t result = 10;
    }
  }
LABEL_15:
  *a5 = v7;
  return result;
}

uint64_t forward_albert_ffn_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (!a2) {
    return 0;
  }
  uint64_t v7 = *(uint64_t **)a2;
  uint64_t v8 = *(unsigned int **)(a2 + 120);
  int step = fi_shape_get_step((_DWORD *)(a2 + 20));
  uint64_t v10 = v8[1];
  long long v11 = *(char **)(a2 + 240);
  int padded_len = get_padded_len(v10, 8u);
  int v13 = get_padded_len(v10, 8u);
  bzero(v11, 4 * (v13 * step));
  uint64_t v14 = (*(uint64_t (**)(uint64_t))(*((void *)v8 + 3) + 128))(a1);
  if (v14)
  {
    uint64_t v18 = v14;
    uint64_t v19 = *v7;
    long long v20 = "albert_ffn forward norm layer failed!";
  }
  else
  {
    int v21 = get_padded_len(*v8, 8u);
    bzero(&v11[4 * padded_len * step], 4 * (v21 * step));
    uint64_t v22 = (*(uint64_t (**)(uint64_t))(*((void *)v8 + 4) + 128))(a1);
    if (v22)
    {
      uint64_t v18 = v22;
      uint64_t v19 = *v7;
      long long v20 = "albert_ffn forward dense o1 failed!";
    }
    else
    {
      uint64_t v23 = (v10 * step);
      bzero(a4, 4 * v23);
      uint64_t v18 = (*(uint64_t (**)(uint64_t))(*((void *)v8 + 5) + 128))(a1);
      if (!v18)
      {
        axpy(v23, (float *)v11, 1, (float *)a4, 1, 1.0);
        return v18;
      }
      uint64_t v19 = *v7;
      long long v20 = "albert_ffn forward dense o2 layer failed!";
    }
  }
  log_OutText(v19, (uint64_t)"FastInfer", 0, 0, (uint64_t)v20, v15, v16, v17, v25);
  return v18;
}

void *free_albert_ffn_layer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[3]);
        fi_layer_free(v3[4]);
        fi_layer_free(v3[5]);
        (*(void (**)(void, uint64_t *))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v4 = *(void *)(v2 + 16);
      uint64_t v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v5(v4, v1);
    }
  }
  return result;
}

__n128 albert_ffn_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void **)(a1 + 120);
  int v10 = *(_DWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v10;
  if (*(_DWORD *)a2 >= 3u)
  {
    uint64_t v11 = **(void **)a1;
    uint64_t v12 = "Currently albert_ffn layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)v12, a6, a7, a8, v17);
    return result;
  }
  if (!(*(unsigned int (**)(void))(v9[3] + 144))()
    && !(*(unsigned int (**)(void))(v9[4] + 144))()
    && !(*(unsigned int (**)(void))(v9[5] + 144))())
  {
    uint64_t v14 = v9[5];
    unsigned int v16 = *(_DWORD *)(v14 + 40);
    uint64_t v15 = (__n128 *)(v14 + 40);
    if (v16 >= 3)
    {
      uint64_t v11 = **(void **)a1;
      uint64_t v12 = "o2 output shape error: Currently albert_ffn layer only support 1D or 2D output";
      goto LABEL_3;
    }
    __n128 result = *v15;
    *(_DWORD *)(a1 + 56) = v15[1].n128_u32[0];
    *(__n128 *)(a1 + 40) = result;
  }
  return result;
}

uint64_t albert_ffn_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6 = *(void **)(a1 + 120);
  uint64_t result = (*(uint64_t (**)(void))(v6[3] + 152))();
  if (!result)
  {
    padded_uint64_t bytes = get_padded_bytes(0, 8u);
    uint64_t result = (*(uint64_t (**)(void))(v6[4] + 152))();
    if (!result)
    {
      unsigned int v9 = get_padded_bytes(padded_bytes, 8u);
      uint64_t result = (*(uint64_t (**)(void))(v6[5] + 152))();
      if (!result)
      {
        *a2 = get_padded_bytes(v9, 8u);
        *a3 = 0;
        log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"albert_ffn filter size: %d\n", v10, v11, v12, *(unsigned int *)(v6[4] + 12));
        log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v13, v14, v15, *(unsigned int *)(a1 + 96));
        log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v16, v17, v18, *a2);
        return 0;
      }
    }
  }
  return result;
}

uint64_t albert_ffn_request_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(unsigned int **)(a1 + 120);
  uint64_t v3 = (int *)(a1 + 20);
  int step = fi_shape_get_step((_DWORD *)(a1 + 20));
  unsigned int v13 = 0;
  uint64_t result = fi_shape_get_input_dim(v3, (int *)&v13);
  if (!result)
  {
    if (v13 == v2[1])
    {
      int padded_len = get_padded_len(v13, 8u);
      int v10 = get_padded_len(*v2, 8u);
      padded_uint64_t bytes = get_padded_bytes(4 * step * (v10 + padded_len), 8u);
      uint64_t result = 0;
      *(_DWORD *)(a1 + 248) = padded_bytes;
    }
    else
    {
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"albert_ffn: input sample dim mismatch!", v6, v7, v8, v12);
      return 7;
    }
  }
  return result;
}

uint64_t albert_ffn_dispatch_weights(uint64_t a1)
{
  padded_uint64_t bytes = 0;
  uint64_t v1 = *(uint64_t **)(a1 + 120);
  uint64_t v2 = *(void *)(a1 + 72);
  uint64_t result = fi_layer_find_weights_via_offset(v1[3], v2, &padded_bytes);
  if (!result)
  {
    padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
    uint64_t result = fi_layer_find_weights_via_offset(v1[4], v2, &padded_bytes);
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
      uint64_t result = fi_layer_find_weights_via_offset(v1[5], v2, &padded_bytes);
      if (!result)
      {
        get_padded_bytes(padded_bytes, 8u);
        return 0;
      }
    }
  }
  return result;
}

uint64_t albert_trans_enc_dispatch_weights(uint64_t a1)
{
  padded_uint64_t bytes = 0;
  uint64_t v1 = *(uint64_t **)(a1 + 120);
  uint64_t v2 = *(void *)(a1 + 72);
  uint64_t result = fi_layer_find_weights_via_offset(v1[6], v2, &padded_bytes);
  if (!result)
  {
    padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
    uint64_t result = fi_layer_find_weights_via_offset(v1[7], v2, &padded_bytes);
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
      uint64_t result = fi_layer_find_weights_via_offset(v1[8], v2, &padded_bytes);
      if (!result)
      {
        get_padded_bytes(padded_bytes, 8u);
        return 0;
      }
    }
  }
  return result;
}

void *free_albert_trans_enc_layer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[7]);
        fi_layer_free(v3[6]);
        fi_layer_free(v3[8]);
        (*(void (**)(void, uint64_t *))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v4 = *(void *)(v2 + 16);
      uint64_t v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v5(v4, v1);
    }
  }
  return result;
}

uint64_t create_albert_trans_enc_layer(uint64_t *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7 = 0;
  uint64_t result = 7;
  if (a1 && a2)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 72);
      uint64_t v19 = v15;
      if (!v15)
      {
        uint64_t v29 = *a1;
        uint64_t v30 = "out of memory!";
LABEL_14:
        log_OutText(v29, (uint64_t)"FastInfer", 0, 0, (uint64_t)v30, v16, v17, v18, v36);
        *(void *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"albert trans_enc init param failed!", v33, v34, v35, v36);
        uint64_t result = 7;
        goto LABEL_15;
      }
      int32x4_t v20 = *(int32x4_t *)a2;
      long long v21 = *(_OWORD *)(a2 + 32);
      *(_OWORD *)(v15 + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(v15 + 32) = v21;
      *(int32x4_t *)uint64_t v15 = v20;
      long long v43 = 0u;
      long long v42 = 0u;
      long long v41 = 0u;
      int v37 = 0;
      uint64_t v36 = 0;
      unsigned int v23 = *(_DWORD *)(a2 + 24);
      unsigned int v22 = *(_DWORD *)(a2 + 28);
      v40[2] = 0;
      v40[3] = v22;
      v40[0] = *(_DWORD *)a2;
      v40[1] = v23;
      unsigned int v24 = *(_DWORD *)(a2 + 8);
      DWORD1(v41) = 0;
      *((void *)&v41 + 1) = v24;
      LODWORD(v42) = *(_DWORD *)(a2 + 32);
      *((void *)&v43 + 1) = 0;
      uint64_t v44 = 0;
      if (create_att_albert_layer(a1, v40, a3, a4, (uint64_t *)(v15 + 48)))
      {
        uint64_t v28 = "create albert trans_enc att layer failed!";
LABEL_13:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v28, v25, v26, v27, v36);
        uint64_t v29 = *a1;
        uint64_t v30 = "albert trans_enc network init failed!";
        goto LABEL_14;
      }
      int v39 = *(_DWORD *)(a2 + 16);
      *(void *)&long long v31 = vrev64q_s32(*(int32x4_t *)a2).u64[0];
      *((void *)&v31 + 1) = *(void *)(a2 + 8);
      long long v38 = v31;
      if (create_albert_ffn_layer(a1, &v38, a3, a4, (uint64_t *)(v19 + 56)))
      {
        uint64_t v28 = "create albert trans_enc ffn layer failed!";
        goto LABEL_13;
      }
      int v32 = *(_DWORD *)(a2 + 20);
      LODWORD(v36) = 40;
      HIDWORD(v36) = v32;
      if (create_norm_layer(a1, &v36, (uint64_t *)(v19 + 64)))
      {
        uint64_t v28 = "create albert trans_enc norm layer failed!";
        goto LABEL_13;
      }
      *(void *)(v7 + 120) = v19;
      if (a3) {
        *(void *)(v7 + 60) = *a3;
      }
      *(void *)uint64_t v7 = a1;
      *(void *)(v7 + 8) = 42;
      *(void *)(v7 + 128) = forward_albert_trans_enc_layer;
      *(void *)(v7 + 136) = free_albert_trans_enc_layer;
      *(void *)(v7 + 144) = albert_trans_enc_layer_update_shape;
      *(void *)(v7 + 152) = albert_trans_enc_layer_wanted_wb_len;
      *(void *)(v7 + 160) = albert_trans_enc_request_glbBuf;
      *(void *)(v7 + 184) = albert_trans_enc_dispatch_weights;
      *(void *)(v7 + 168) = albert_trans_enc_assign_glbBuf;
      *(void *)(v7 + 176) = albert_trans_enc_layer_reset;
      if (a4)
      {
        uint64_t result = 0;
        *(void *)(v7 + 256) = *(void *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v25, v26, v27, v36);
        uint64_t result = 0;
        *(void *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v36);
      uint64_t result = 10;
    }
  }
LABEL_15:
  *a5 = v7;
  return result;
}

uint64_t forward_albert_trans_enc_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  LODWORD(v20) = 0;
  if (!a2) {
    return 0;
  }
  uint64_t v6 = *(uint64_t **)a2;
  uint64_t v7 = *(void **)(a2 + 120);
  uint64_t v8 = *(char **)(a2 + 240);
  uint64_t v9 = v7[6];
  *(_DWORD *)(*(void *)(v9 + 120) + 192) = 0;
  uint64_t bytes = fi_shape_get_bytes((int *)(v9 + 40), &v20);
  if (!bytes)
  {
    bzero(v8, v20);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(v7[6] + 128))(a1);
    if (v11)
    {
      uint64_t bytes = v11;
      uint64_t v15 = "albert trans_enc forward att layer failed!";
    }
    else
    {
      padded_uint64_t bytes = get_padded_bytes(v20, 8u);
      uint64_t bytes = fi_shape_get_bytes((int *)(v7[7] + 40), &v20);
      if (bytes) {
        return bytes;
      }
      bzero(&v8[padded_bytes & 0xFFFFFFFC], v20);
      uint64_t v18 = (*(uint64_t (**)(uint64_t))(v7[7] + 128))(a1);
      if (v18)
      {
        uint64_t bytes = v18;
        uint64_t v15 = "albert trans_enc forward ffn layer failed!";
      }
      else
      {
        bzero(a4, v20);
        uint64_t bytes = (*(uint64_t (**)(uint64_t))(v7[8] + 128))(a1);
        if (!bytes) {
          return bytes;
        }
        uint64_t v15 = "albert trans_enc forward norm layer failed!";
      }
    }
    log_OutText(*v6, (uint64_t)"FastInfer", 0, 0, (uint64_t)v15, v12, v13, v14, v19);
  }
  return bytes;
}

__n128 albert_trans_enc_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void **)(a1 + 120);
  uint64_t v9 = *(uint64_t **)a1;
  int v10 = *(_DWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v10;
  if (*(_DWORD *)a2 >= 3u)
  {
    uint64_t v11 = *v9;
    uint64_t v12 = "Currently albert trans_enc layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)v12, a6, a7, a8, v16);
    return result;
  }
  if (!(*(unsigned int (**)(void))(v8[6] + 144))() && !(*(unsigned int (**)(void))(v8[7] + 144))())
  {
    if ((*(_DWORD *)(v8[7] + 40) - 1) >= 2)
    {
      uint64_t v11 = **(void **)a1;
      uint64_t v12 = "dense out: output shape error";
      goto LABEL_3;
    }
    if (!(*(unsigned int (**)(void))(v8[8] + 144))())
    {
      uint64_t v15 = v8[8];
      __n128 result = *(__n128 *)(v15 + 40);
      *(_DWORD *)(a1 + 56) = *(_DWORD *)(v15 + 56);
      *(__n128 *)(a1 + 40) = result;
    }
  }
  return result;
}

uint64_t albert_trans_enc_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6 = *(void **)(a1 + 120);
  uint64_t result = (*(uint64_t (**)(void))(v6[6] + 152))();
  if (!result)
  {
    padded_uint64_t bytes = get_padded_bytes(0, 8u);
    uint64_t result = (*(uint64_t (**)(void))(v6[7] + 152))();
    if (!result)
    {
      unsigned int v9 = get_padded_bytes(padded_bytes, 8u);
      uint64_t result = (*(uint64_t (**)(void))(v6[8] + 152))();
      if (!result)
      {
        *a2 = get_padded_bytes(v9, 8u);
        *a3 = 0;
        log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v10, v11, v12, *(unsigned int *)(a1 + 96));
        log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v13, v14, v15, *a2);
        return 0;
      }
    }
  }
  return result;
}

uint64_t albert_trans_enc_request_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120);
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(v2 + 48) + 160))();
  if (!result)
  {
    unsigned int v4 = *(_DWORD *)(*(void *)(v2 + 48) + 248);
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(v2 + 56) + 160))();
    if (!result)
    {
      unsigned int v5 = *(_DWORD *)(*(void *)(v2 + 56) + 248);
      unsigned int v7 = v5;
      uint64_t result = albert_trans_enc_get_reserved_glbBuf_bytes(a1, &v7);
      if (!result)
      {
        if (v5 <= v4) {
          unsigned int v6 = v4;
        }
        else {
          unsigned int v6 = v5;
        }
        *(_DWORD *)(a1 + 248) = v7 + v6;
      }
    }
  }
  return result;
}

uint64_t albert_trans_enc_assign_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120);
  unsigned int v7 = 0;
  uint64_t result = albert_trans_enc_get_reserved_glbBuf_bytes(a1, &v7);
  if (!result)
  {
    uint64_t v4 = v7;
    uint64_t v5 = *(void *)(v2 + 48);
    uint64_t v6 = *(void *)(v2 + 56);
    *(void *)(v5 + 240) = *(void *)(a1 + 240) + v7;
    *(_DWORD *)(v5 + 248) = *(_DWORD *)(a1 + 248) - v4;
    *(void *)(v6 + 240) = *(void *)(a1 + 240) + v4;
    *(_DWORD *)(v6 + 248) = *(_DWORD *)(a1 + 248) - v4;
  }
  return result;
}

uint64_t albert_trans_enc_layer_reset(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 120) + 48) + 176))();
  if (result)
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"albert trans_enc network reset failed!", v3, v4, v5, v6);
    return 7;
  }
  return result;
}

uint64_t albert_trans_enc_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = *(void *)(a1 + 120);
  unsigned int v7 = 0;
  uint64_t result = fi_shape_get_bytes((int *)(*(void *)(v3 + 48) + 40), &v7);
  if (!result)
  {
    padded_uint64_t bytes = get_padded_bytes(v7, 8u);
    uint64_t result = fi_shape_get_bytes((int *)(*(void *)(v3 + 56) + 40), &v7);
    if (!result)
    {
      int v6 = get_padded_bytes(v7, 8u);
      uint64_t result = 0;
      *a2 = v6 + padded_bytes;
    }
  }
  return result;
}

uint64_t tee_param_alloc_sources(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned int *)(a2 + 68);
  if (v3)
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[1] + 72))(a1[2], 24 * v3);
    *(void *)(a2 + 72) = v5;
    if (v5)
    {
      return 0;
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v6, v7, v8, v10);
      return 10;
    }
  }
  else
  {
    uint64_t result = 0;
    *(void *)(a2 + 72) = 0;
  }
  return result;
}

uint64_t tee_source_cfg_get_source_layer(uint64_t *a1, void *a2, char *__s1, uint64_t *a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *a2 = 0;
  if (a5)
  {
    uint64_t v12 = a5;
    while (1)
    {
      uint64_t v13 = *a4;
      if (*(_DWORD *)(*a4 + 8) == 26)
      {
        uint64_t result = strcmp(__s1, *(const char **)(v13 + 120));
        if (!result) {
          break;
        }
      }
      ++a4;
      if (!--v12) {
        goto LABEL_6;
      }
    }
    *a2 = v13;
  }
  else
  {
LABEL_6:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"source layer '%s' cannot be found!", a6, a7, a8, (uint64_t)__s1);
    return 7;
  }
  return result;
}

uint64_t create_tee_param(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 96);
  *a2 = v4;
  if (v4) {
    return 0;
  }
  log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v5, v6, v7, v9);
  return 10;
}

uint64_t free_tee_param(uint64_t result, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(void))(*(void *)(result + 8) + 48))(*(void *)(result + 16));
  }
  return result;
}

uint64_t create_tee_layer_take_param_ownership(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v9)
  {
    uint64_t result = 0;
    *(void *)uint64_t v9 = a1;
    uint64_t v11 = *a2;
    *(void *)(v9 + 120) = *a2;
    *a2 = 0;
    *(void *)(v11 + 80) = 0;
    *(_DWORD *)(v11 + 88) = 0;
    *(_DWORD *)(v9 + 8) = 26;
    *(void *)(v9 + 128) = forward_tee_layer;
    *(void *)(v9 + 136) = free_tee_buffer;
    *(void *)(v9 + 144) = tee_layer_update_shape;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v6, v7, v8, v12);
    free_tee_buffer(0);
    uint64_t result = 10;
  }
  *a3 = v9;
  return result;
}

uint64_t forward_tee_layer(uint64_t a1, uint64_t a2, float *a3, float *a4, uint64_t a5)
{
  uint64_t v5 = a2;
  uint64_t v6 = *(void *)(a2 + 120);
  float v51 = *(uint64_t **)a2;
  if (*(_DWORD *)(v6 + 68))
  {
    int v8 = *(_DWORD *)(a2 + 40);
    uint64_t v9 = (v8 - 1);
    if (v8 == 2)
    {
      int v62 = *(_DWORD *)(a2 + 48);
      int v54 = v62 * 4 * *(_DWORD *)(a2 + 44);
    }
    else
    {
      int v54 = 4 * *(_DWORD *)(a2 + 44);
      int v62 = 0;
    }
    unint64_t v14 = 0;
    int v15 = 0;
    uint64_t v52 = (v8 - 1);
    uint64_t v53 = *(void *)(a2 + 120);
    do
    {
      uint64_t v16 = *(void *)(v6 + 72);
      uint64_t v17 = (_DWORD *)(v16 + 24 * v14);
      uint64_t v18 = *(void *)v17;
      uint64_t v19 = *(void *)(*(void *)(*(void *)v17 + 120) + 80);
      unsigned int v20 = v17[3];
      if (v20 >= *(_DWORD *)(v18 + 4 * v9 + 44)) {
        unsigned int v21 = *(_DWORD *)(v18 + 4 * v9 + 44);
      }
      else {
        unsigned int v21 = v20;
      }
      unsigned int v61 = v21;
      if (*(_DWORD *)(v5 + 40) == 2)
      {
        unsigned int v22 = *(_DWORD *)(v5 + 44);
        if (v22)
        {
          int v23 = 0;
          int v24 = v15;
          unsigned int v25 = 0;
          int v26 = *(_DWORD *)(v18 + 48);
          unint64_t v56 = v14;
          uint64_t v57 = *(void *)(v6 + 72);
          uint64_t v27 = v16 + 24 * v14;
          uint64_t v28 = (_DWORD *)(v27 + 8);
          uint64_t v29 = (_DWORD *)(v27 + 16);
          int v55 = v24;
          int v30 = v24;
          int v60 = v26;
          uint64_t v59 = (_DWORD *)(v27 + 8);
          do
          {
            unsigned int v31 = v21 - *v28;
            if (v21 > *v28)
            {
              uint64_t v32 = v5;
              unsigned int v33 = *v28 + v23;
              int v34 = v30;
              do
              {
                float v35 = *(float *)(v19 + 4 * v33);
                if (*v29 == 1) {
                  float v35 = exp_fdlibm(v35);
                }
                a4[v34++] = v35;
                ++v33;
                --v31;
              }
              while (v31);
              uint64_t v5 = v32;
              unsigned int v22 = *(_DWORD *)(v32 + 44);
              int v26 = v60;
              unsigned int v21 = v61;
              uint64_t v28 = v59;
            }
            ++v25;
            v30 += v62;
            v23 += v26;
          }
          while (v25 < v22);
          uint64_t v9 = v52;
          uint64_t v6 = v53;
          unint64_t v14 = v56;
          uint64_t v16 = v57;
          int v15 = v55;
        }
      }
      else
      {
        int v54 = 4 * *(_DWORD *)(v5 + 44);
        uint64_t v36 = *(unsigned int *)(v16 + 24 * v14 + 8);
        if (v21 > v36)
        {
          uint64_t v58 = *(void *)(v6 + 72);
          int v37 = (_DWORD *)(v16 + 24 * v14 + 16);
          int v38 = v21 - v36;
          int v39 = (float *)(v19 + 4 * v36);
          unsigned int v40 = v15;
          do
          {
            float v41 = *v39;
            if (*v37 == 1) {
              float v41 = exp_fdlibm(v41);
            }
            a4[v40++] = v41;
            ++v39;
            --v38;
          }
          while (v38);
          uint64_t v16 = v58;
          unsigned int v21 = v61;
        }
      }
      int v15 = v21 + v15 - *(_DWORD *)(v16 + 24 * v14++ + 8);
    }
    while (v14 < *(unsigned int *)(v6 + 68));
    a3 = a4;
    unsigned int v13 = v54;
  }
  else
  {
    int v63 = 0;
    uint64_t result = fi_shape_get_size((int *)(a2 + 20), &v63);
    if (result) {
      return result;
    }
    *(_DWORD *)(a5 + 16) = 0;
    unsigned int v13 = 4 * v63;
  }
  long long v42 = *(void **)(v6 + 80);
  if (v42)
  {
    if (*(_DWORD *)(v6 + 88) >= v13)
    {
      size_t v44 = v13;
      goto LABEL_36;
    }
    unsigned int v43 = v13;
    (*(void (**)(uint64_t))(v51[1] + 48))(v51[2]);
    unsigned int v13 = v43;
    *(void *)(v6 + 80) = 0;
  }
  size_t v44 = v13;
  unsigned int v45 = v13;
  uint64_t v46 = (*(uint64_t (**)(uint64_t, void))v51[1])(v51[2], v13);
  *(void *)(v6 + 80) = v46;
  if (v46)
  {
    long long v42 = (void *)v46;
    *(_DWORD *)(v6 + 88) = v45;
LABEL_36:
    memcpy(v42, a3, v44);
    return 0;
  }
  log_OutText(*v51, (uint64_t)"FastInfer", 0, 0, (uint64_t)"tee layer allocation failed!", v47, v48, v49, v50);
  return 10;
}

void *free_tee_buffer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = result[15];
      if (v3)
      {
        if (*(void *)(v3 + 72))
        {
          (*(void (**)(void))(*(void *)(v2 + 8) + 80))(*(void *)(v2 + 16));
          *(void *)(v3 + 72) = 0;
        }
        if (*(void *)(v3 + 80))
        {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
          *(void *)(v3 + 80) = 0;
        }
        (*(void (**)(void, uint64_t))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      uint64_t v4 = *(void *)(v2 + 16);
      uint64_t v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v5(v4, v1);
    }
  }
  return result;
}

uint64_t tee_layer_update_shape(uint64_t a1, int *a2)
{
  uint64_t v4 = *(void *)(a1 + 120);
  int v27 = 0;
  int v5 = a2[4];
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v5;
  uint64_t result = fi_shape_get_size(a2, &v27);
  if (!result)
  {
    uint64_t v10 = (_OWORD *)(a1 + 40);
    if (*(_DWORD *)(v4 + 68))
    {
      uint64_t v11 = 0;
      unint64_t v12 = 0;
      unsigned int v13 = 0;
      unsigned int v14 = 0;
      int v15 = 0;
      while (1)
      {
        uint64_t v16 = *(void *)(v4 + 72);
        if (!v15)
        {
          uint64_t v17 = *(void *)(v16 + v11);
          int v15 = *(_DWORD *)(v17 + 40);
          long long v18 = *(_OWORD *)(v17 + 40);
          *(_DWORD *)(a1 + 56) = *(_DWORD *)(v17 + 56);
          *uint64_t v10 = v18;
          unsigned int v13 = v15 - 1;
        }
        uint64_t v19 = *(void *)(v16 + v11);
        if (*(_DWORD *)(v19 + 40) != v15) {
          break;
        }
        unsigned int v20 = *(_DWORD *)(v19 + 4 * v13 + 44);
        int v23 = (int *)(v16 + v11 + 8);
        int v21 = *v23;
        unsigned int v22 = v23[1];
        if (v22 < v20) {
          unsigned int v20 = v22;
        }
        unsigned int v14 = v14 - v21 + v20;
        ++v12;
        v11 += 24;
        if (v12 >= *(unsigned int *)(v4 + 68))
        {
          *(_DWORD *)(a1 + 4 * v13 + 44) = v14;
          goto LABEL_12;
        }
      }
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Soure layer %d has wrong number of dimensions!", v7, v8, v9, v12);
    }
    else
    {
      long long v24 = *(_OWORD *)a2;
      *(_DWORD *)(a1 + 56) = a2[4];
      *uint64_t v10 = v24;
      unsigned int v14 = *(_DWORD *)(a1 + 4 * (*a2 - 1) + 44);
LABEL_12:
      uint64_t v25 = *(unsigned int *)(v4 + 64);
      if (v25) {
        BOOL v26 = v14 == v25;
      }
      else {
        BOOL v26 = 1;
      }
      if (v26) {
        return 0;
      }
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Output dimension %d does not match calculated output dimension %d for layer %s!", v7, v8, v9, v25);
    }
    return 7;
  }
  return result;
}

uint64_t tee_layer_get_output_buffer(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 120) + 80);
}

uint64_t config_merge_layer_param(uint64_t *a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t *a5, unsigned int a6)
{
  *(_DWORD *)a2 = a3;
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[1] + 72))(a1[2], 8 * a3);
  *(void *)(a2 + 8) = v12;
  if (v12)
  {
    if (a3)
    {
      uint64_t v16 = v12;
      uint64_t v17 = 0;
      uint64_t v28 = a3;
      uint64_t v29 = a5;
      long long v18 = (const char *)a4;
      uint64_t v19 = a6;
      while (1)
      {
        size_t v20 = strlen(v18);
        *(void *)(v16 + 8 * v17) = 0;
        if (!a6) {
          break;
        }
        size_t v24 = v20;
        while (1)
        {
          uint64_t v25 = *a5;
          if (*(_DWORD *)(*a5 + 8) == 26)
          {
            uint64_t result = strcmp(v18, *(const char **)(v25 + 120));
            if (!result) {
              break;
            }
          }
          ++a5;
          if (!--v19)
          {
            a4 = (uint64_t)v18;
            goto LABEL_13;
          }
        }
        *(void *)(v16 + 8 * v17) = v25;
        v18 += v24 + 1;
        ++v17;
        a5 = v29;
        uint64_t v19 = a6;
        if (v17 == v28) {
          return result;
        }
      }
LABEL_13:
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"source layer '%s' cannot be found!", v21, v22, v23, a4);
      return 7;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v13, v14, v15, v27);
    return 10;
  }
}

uint64_t create_merge_layer(uint64_t *a1, _OWORD *a2, uint64_t ***a3)
{
  uint64_t v6 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  uint64_t v10 = v6;
  if (v6
    && (*uint64_t v6 = a1,
        uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16),
        (v10[15] = (uint64_t *)v11) != 0))
  {
    uint64_t v12 = (_OWORD *)v11;
    uint64_t result = 0;
    *uint64_t v12 = *a2;
    *((_DWORD *)v10 + 2) = 31;
    v10[16] = (uint64_t *)forward_merge_layer;
    v10[17] = (uint64_t *)free_merge_buffer;
    v10[18] = (uint64_t *)merge_layer_update_shape;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v14);
    free_merge_buffer(v10);
    uint64_t result = 10;
  }
  *a3 = v10;
  return result;
}

uint64_t forward_merge_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(unsigned int **)(a2 + 120);
  LODWORD(__n) = 0;
  int v11 = *(_DWORD *)(a2 + 40);
  if (v11 == 2)
  {
    int v21 = *(_DWORD *)(a2 + 44);
    if (v21)
    {
      int v22 = 0;
      int v23 = *(_DWORD *)(a2 + 48);
      LODWORD(v24) = *v10;
      do
      {
        if (v24)
        {
          unint64_t v25 = 0;
          int v26 = 0;
          do
          {
            uint64_t v27 = *(void *)(*((void *)v10 + 1) + 8 * v25);
            int v28 = *(_DWORD *)(v27 + 56);
            int v29 = *(_DWORD *)(v27 + 48);
            uint64_t output_buffer = tee_layer_get_output_buffer(v27);
            memcpy((void *)(a4 + (v28 * (v26 + v22 * v23))), (const void *)(output_buffer + (v29 * v28 * v22)), (v29 * v28));
            v26 += v29;
            ++v25;
            unint64_t v24 = *v10;
          }
          while (v25 < v24);
        }
        ++v22;
      }
      while (v22 != v21);
    }
    return 0;
  }
  if (v11 != 1)
  {
    log_OutText(**(void **)a2, (uint64_t)"FastInfer", 0, 0, (uint64_t)"merge layer only support concatenation of 1d and 2d data", a6, a7, a8, v31);
    return 0;
  }
  if (!*v10) {
    return 0;
  }
  uint64_t v12 = 0;
  unsigned int v13 = 0;
  while (1)
  {
    uint64_t v14 = *(void *)(*((void *)v10 + 1) + 8 * v12);
    uint64_t result = fi_shape_get_bytes((int *)(v14 + 40), &__n);
    if (result) {
      break;
    }
    if (!__n)
    {
      log_OutText(**(void **)a2, (uint64_t)"FastInfer", 0, 0, (uint64_t)"merge layer source layer output length=0!", v16, v17, v18, v31);
      return 7;
    }
    uint64_t v19 = (const void *)tee_layer_get_output_buffer(v14);
    int v20 = __n;
    memcpy((void *)(a4 + v13), v19, __n);
    v13 += v20;
    if (++v12 >= (unint64_t)*v10) {
      return 0;
    }
  }
  return result;
}

void *free_merge_buffer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = result[15];
      if (v3)
      {
        if (*(void *)(v3 + 8))
        {
          (*(void (**)(void))(*(void *)(v2 + 8) + 80))(*(void *)(v2 + 16));
          *(void *)(v3 + 8) = 0;
        }
        (*(void (**)(void, uint64_t))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      uint64_t v4 = *(void *)(v2 + 16);
      int v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v5(v4, v1);
    }
  }
  return result;
}

uint64_t merge_layer_update_shape(uint64_t a1, int *a2)
{
  uint64_t v3 = *(unsigned int **)(a1 + 120);
  int v30 = 0;
  int v4 = a2[4];
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v4;
  uint64_t size = fi_shape_get_size(a2, &v30);
  if (!size)
  {
    if (*v3)
    {
      uint64_t v6 = **((void **)v3 + 1);
      long long v7 = *(_OWORD *)(v6 + 40);
      *(_DWORD *)(a1 + 56) = *(_DWORD *)(v6 + 56);
      *(_OWORD *)(a1 + 40) = v7;
      uint64_t v8 = **((void **)v3 + 1);
      uint64_t v9 = (*(_DWORD *)(v8 + 40) - 1);
      int v10 = *(_DWORD *)(v8 + 40 + 4 * v9 + 4);
      if (*v3 < 2)
      {
LABEL_7:
        uint64_t size = 0;
        *(_DWORD *)(a1 + 4 * v9 + 44) = v10;
      }
      else
      {
        uint64_t v11 = 1;
        while (1)
        {
          uint64_t v12 = (_DWORD *)(*(void *)(*((void *)v3 + 1) + 8 * v11) + 40);
          int v13 = v12[v9 + 1];
          uint64_t v14 = fi_shape_merge(v12, (_DWORD *)(a1 + 40));
          if (v14) {
            break;
          }
          v10 += v13;
          if (++v11 >= (unint64_t)*v3) {
            goto LABEL_7;
          }
        }
        uint64_t size = v14;
        log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"source layer outputs cannot be merged!", v15, v16, v17, v29);
        fi_shape_dump(*(uint64_t **)a1, *(void *)(*((void *)v3 + 1) + 8 * v11) + 40, (uint64_t)"shape to be merged", v18, v19, v20, v21, v22);
        fi_shape_dump(*(uint64_t **)a1, a1 + 40, (uint64_t)"shape", v23, v24, v25, v26, v27);
      }
    }
    else
    {
      return 7;
    }
  }
  return size;
}

uint64_t create_label_layer(uint64_t *a1, unsigned int *a2, void *a3, uint64_t *a4)
{
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v11) {
    goto LABEL_10;
  }
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 64);
  if (!v12) {
    goto LABEL_10;
  }
  uint64_t v13 = v12;
  if (a3) {
    *(void *)(v11 + 60) = *a3;
  }
  long long v14 = *(_OWORD *)a2;
  long long v15 = *((_OWORD *)a2 + 1);
  long long v16 = *((_OWORD *)a2 + 2);
  *(void *)(v12 + 48) = *((void *)a2 + 6);
  *(_OWORD *)(v12 + 16) = v15;
  *(_OWORD *)(v12 + 32) = v16;
  *(_OWORD *)uint64_t v12 = v14;
  uint64_t v17 = *a2;
  uint64_t v18 = 8 * v17;
  uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t))a1[1])(a1[2], 8 * v17);
  *(void *)(v13 + 56) = v19;
  if (v19)
  {
    if (v17)
    {
      uint64_t v20 = v19;
      uint64_t v21 = 0;
      unsigned int v22 = 0;
      do
      {
        *(void *)(v20 + v21) = *((void *)a2 + 1) + v22;
        uint64_t v20 = *(void *)(v13 + 56);
        v22 += strlen(*(const char **)(v20 + v21)) + 1;
        v21 += 8;
      }
      while (v18 != v21);
    }
    uint64_t result = 0;
    *(_DWORD *)(v11 + 8) = 20;
    *(void *)uint64_t v11 = a1;
    *(void *)(v11 + 120) = v13;
    *(void *)(v11 + 128) = forward_label_layer;
    *(void *)(v11 + 136) = free_label_buffer;
    *(void *)(v11 + 144) = label_layer_update_shape;
  }
  else
  {
LABEL_10:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v24);
    free_label_buffer((void *)v11);
    uint64_t result = 10;
  }
  *a4 = v11;
  return result;
}

uint64_t forward_label_layer(uint64_t a1, uint64_t a2, float *a3, void *a4, uint64_t a5)
{
  uint64_t v9 = *(uint64_t **)a2;
  v97[0] = 0;
  uint64_t v10 = *(void *)(a2 + 120);
  uint64_t v11 = (int *)(a2 + 20);
  unsigned int step = fi_shape_get_step((_DWORD *)(a2 + 20));
  uint64_t input_dim = fi_shape_get_input_dim(v11, v97);
  if (input_dim) {
    return input_dim;
  }
  int v17 = *(_DWORD *)(v10 + 16);
  if (v17) {
    BOOL v18 = step >= 2;
  }
  else {
    BOOL v18 = 0;
  }
  if (v18)
  {
    uint64_t v89 = a3;
    int v28 = *(uint64_t **)a2;
    uint64_t v29 = *(unsigned int **)(a2 + 120);
    uint64_t v30 = *v29;
    uint64_t v31 = *((void *)v29 + 3);
    uint64_t v96 = *((void *)v29 + 5);
    uint64_t v35 = fi_shape_get_step(v11);
    if (v35 > 1)
    {
      uint64_t v88 = (v35 - 1);
      uint64_t v39 = ((v35 - 1) * v30);
      uint64_t v94 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v28[1] + 16))(v28[2], v39, 4);
      if (v94)
      {
        uint64_t v43 = (*(uint64_t (**)(uint64_t, void, uint64_t))(v28[1] + 16))(v28[2], (v35 * v30), 4);
        uint64_t v47 = (float *)v43;
        if (v43)
        {
          uint64_t v86 = v39;
          unsigned int v87 = v9;
          uint64_t v93 = v28;
          uint64_t v95 = (float *)v43;
          uint64_t v85 = v29;
          if (v30)
          {
            uint64_t v48 = v89;
            uint64_t v49 = v30;
            do
            {
              float v50 = *v48++;
              float v51 = log_fdlibm(v50);
              *v47++ = v51;
              --v49;
            }
            while (v49);
            uint64_t v52 = v30;
          }
          else
          {
            uint64_t v52 = 0;
          }
          unsigned int v92 = 0;
          int v84 = v35;
          uint64_t v90 = v35;
          for (uint64_t i = 1; i != v90; ++i)
          {
            if (v30)
            {
              uint64_t v54 = 0;
              BOOL v56 = i == 1 && v96 != 0;
              do
              {
                uint64_t v57 = 0;
                int v58 = -1;
                float v59 = -3.4028e38;
                unsigned int v60 = v54;
                do
                {
                  float v61 = *(float *)(v31 + 4 * v60);
                  double v62 = log_fdlibm(v89[(v30 * i) + v54]);
                  double v63 = v62;
                  float v64 = v95[v92 + v57];
                  *(float *)&double v62 = v61;
                  if (!almost_equal_floats(v62, 0.0))
                  {
                    if (!v56 || (LODWORD(v68) = *(_DWORD *)(v96 + 4 * v57), !almost_equal_floats(v68, 0.0)))
                    {
                      float v69 = v63;
                      float v70 = v64 + v69;
                      double v71 = v61;
                      float v72 = log_fdlibm(v71);
                      if ((float)(v70 + v72) > v59)
                      {
                        float v73 = log_fdlibm(v71);
                        float v59 = v70 + v73;
                        int v58 = v57;
                      }
                    }
                  }
                  ++v57;
                  v60 += v30;
                }
                while (v52 != v57);
                if (v58 == -1)
                {
                  log_OutText(*v93, (uint64_t)"FastInfer", 0, 0, (uint64_t)"No valid path for %d node at step %d", v65, v66, v67, v54);
                }
                else
                {
                  *(_DWORD *)(v94 + 4 * ((i - 1) * v30 + v54)) = v58;
                  v95[(v30 * i + v54)] = v59;
                }
                ++v54;
              }
              while (v54 != v52);
            }
            v92 += v30;
          }
          uint64_t v74 = v88;
          if ((v88 & 0x80000000) != 0)
          {
            char v53 = 0;
            uint64_t input_dim = 7;
            uint64_t v9 = v87;
            int v28 = v93;
            uint64_t v47 = v95;
          }
          else
          {
            uint64_t v47 = v95;
            int LargestIdx = getLargestIdx((uint64_t)&v95[v86], v30);
            if (LargestIdx == -1)
            {
              int v28 = v93;
              log_OutText(*v93, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Cannot find a valid value from output at %d", v76, v77, v78, v88);
              char v53 = 0;
              uint64_t input_dim = 7;
            }
            else
            {
              int v79 = LargestIdx;
              int v80 = v30 * (v84 - 2);
              int v28 = v93;
              if ((LargestIdx & 0x80000000) == 0) {
                goto LABEL_56;
              }
LABEL_55:
              log_OutText(*v93, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Best path broken at step %d", v76, v77, v78, v74);
LABEL_56:
              while (1)
              {
                uint64_t v81 = *(void *)(*((void *)v85 + 7) + 8 * v79);
                if (!v74) {
                  break;
                }
                a4[v74--] = v81;
                int v79 = *(_DWORD *)(v94 + 4 * (v79 + v80));
                v80 -= v30;
                if (v79 < 0) {
                  goto LABEL_55;
                }
              }
              uint64_t input_dim = 0;
              *a4 = v81;
              char v53 = 1;
            }
            uint64_t v9 = v87;
          }
        }
        else
        {
          log_OutText(*v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v44, v45, v46, v83);
          char v53 = 0;
          uint64_t input_dim = 10;
        }
        (*(void (**)(uint64_t, uint64_t))(v28[1] + 48))(v28[2], v94);
        if (v47) {
          (*(void (**)(uint64_t, float *))(v28[1] + 48))(v28[2], v47);
        }
        if (v53) {
          return 0;
        }
      }
      else
      {
        log_OutText(*v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v40, v41, v42, v83);
        uint64_t input_dim = 10;
      }
    }
    else
    {
      log_OutText(*v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)"forward label layer using viterbi with invalid unsigned int step = %d!", v32, v33, v34, v35);
      uint64_t input_dim = 7;
    }
    log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"forward label layer viterbi failed!", v36, v37, v38, v83);
    return input_dim;
  }
  if (v17) {
    BOOL v19 = step > 1;
  }
  else {
    BOOL v19 = 1;
  }
  if (!v19) {
    log_OutText(*v9, (uint64_t)"FastInfer", 1, 0, (uint64_t)"Disable viterbi when step < 2", v13, v14, v15, v83);
  }
  if (!step) {
    return 0;
  }
  uint64_t v20 = 0;
  while (1)
  {
    int v24 = getLargestIdx((uint64_t)&a3[(v97[0] * v20)], v97[0]);
    uint64_t v25 = *v9;
    if (v24 == -1) {
      break;
    }
    log_OutText(v25, (uint64_t)"FastInfer", 4, 0, (uint64_t)"Label score: %f", v21, v22, v23, COERCE__INT64(a3[(v24 + v97[0] * v20)]));
    float v26 = *(float *)(a5 + 24);
    if (v26 <= 0.0 || a3[(v24 + v97[0] * v20)] >= v26) {
      uint64_t v27 = *(void *)(*(void *)(v10 + 56) + 8 * v24);
    }
    else {
      uint64_t v27 = 0;
    }
    a4[v20++] = v27;
    if (step == v20) {
      return 0;
    }
  }
  log_OutText(v25, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Cannot find a valid value from output at %d", v21, v22, v23, v20);
  return 7;
}

void *free_label_buffer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = result[15];
      if (v3)
      {
        if (*(void *)(v3 + 56))
        {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
          *(void *)(v3 + 56) = 0;
        }
        if (*(_DWORD *)(v3 + 48))
        {
          if (*(void *)(v3 + 8))
          {
            (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
            *(void *)(v3 + 8) = 0;
          }
          if (*(void *)(v3 + 24))
          {
            (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
            *(void *)(v3 + 24) = 0;
          }
          if (*(void *)(v3 + 40))
          {
            (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
            *(void *)(v3 + 40) = 0;
          }
        }
        (*(void (**)(void, uint64_t))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      uint64_t v4 = *(void *)(v2 + 16);
      int v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v5(v4, v1);
    }
  }
  return result;
}

uint64_t label_layer_update_shape(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = **(unsigned int **)(a1 + 120);
  int v18 = 0;
  a2[4] = 8;
  *(_DWORD *)(a1 + 56) = 8;
  uint64_t v10 = *a2;
  if ((v10 - 1) >= 2)
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"label layer only supports 1D/2D input, got %d", a6, a7, a8, v10);
    return 7;
  }
  long long v12 = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = a2[4];
  *(_OWORD *)(a1 + 20) = v12;
  uint64_t result = fi_shape_get_input_dim((int *)(a1 + 20), &v18);
  if (result) {
    return result;
  }
  if (v18 != v9)
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"NUM of LABEL: %d not same with input data dim %d", v14, v15, v16, v9);
    return 7;
  }
  if (*a2 == 2)
  {
    *(_DWORD *)(a1 + 40) = 1;
    int step = fi_shape_get_step((_DWORD *)(a1 + 20));
    uint64_t result = 0;
    *(_DWORD *)(a1 + 44) = step;
    goto LABEL_12;
  }
  if (*a2 == 1)
  {
    uint64_t result = 0;
    *(void *)(a1 + 40) = 0x100000001;
LABEL_12:
    *(_DWORD *)(a1 + 56) = a2[4];
    return result;
  }
  return 0;
}

uint64_t create_embedding_layer(uint64_t *a1, uint64_t *a2, uint64_t ***a3)
{
  uint64_t v9 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v9 && (uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 8)) != 0)
  {
    uint64_t v11 = (uint64_t *)v10;
    uint64_t result = 0;
    *uint64_t v11 = *a2;
    v9[15] = v11;
    *uint64_t v9 = a1;
    v9[1] = (uint64_t *)39;
    v9[16] = (uint64_t *)forward_embedding_layer;
    v9[17] = (uint64_t *)free_embedding_buffer;
    v9[18] = (uint64_t *)embedding_layer_update_shape;
    v9[19] = (uint64_t *)embedding_layer_wanted_wb_len;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v6, v7, v8, v13);
    free_embedding_buffer(v9);
    uint64_t result = 10;
  }
  *a3 = v9;
  return result;
}

uint64_t forward_embedding_layer(uint64_t a1, uint64_t a2, float *a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a2 + 120);
  uint64_t v8 = (int *)(a2 + 40);
  int step = fi_shape_get_step((_DWORD *)(a2 + 40));
  unsigned int v25 = 0;
  if (v7)
  {
    LODWORD(v13) = step;
    uint64_t v14 = *(void *)(a2 + 88);
    uint64_t result = fi_shape_get_input_dim(v8, (int *)&v25);
    if (result) {
      return result;
    }
    int padded_len = get_padded_len(v25, 8u);
    if (!v13) {
      return 0;
    }
    int v17 = padded_len;
    unsigned int v18 = 0;
    unsigned int v19 = v25;
    size_t v20 = 4 * v25;
    uint64_t v13 = v13;
    while (1)
    {
      unsigned int v21 = *a3;
      if (*(_DWORD *)(v7 + 4) <= v21) {
        break;
      }
      memcpy((void *)(a4 + 4 * v18), (const void *)(v14 + 4 * v17 * v21), v20);
      v18 += v19;
      ++a3;
      if (!--v13) {
        return 0;
      }
    }
    uint64_t v22 = **(void **)a2;
    uint64_t v23 = "invalid key!";
  }
  else
  {
    uint64_t v22 = **(void **)a2;
    uint64_t v23 = "invalid param!";
  }
  log_OutText(v22, (uint64_t)"FastInfer", 0, 0, (uint64_t)v23, v10, v11, v12, v24);
  return 7;
}

void *free_embedding_buffer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      if (result[15]) {
        (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v3 = *(void *)(v2 + 16);
      uint64_t v4 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v4(v3, v1);
    }
  }
  return result;
}

uint64_t embedding_layer_update_shape(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(int **)(a1 + 120);
  if (!v8)
  {
    uint64_t v12 = **(void **)a1;
    uint64_t v13 = "invalid param!";
LABEL_7:
    log_OutText(v12, (uint64_t)"FastInfer", 0, 0, (uint64_t)v13, a6, a7, a8, vars0);
    return 7;
  }
  long long v9 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v9;
  if (*(_DWORD *)a2 != 1)
  {
    uint64_t v12 = **(void **)a1;
    uint64_t v13 = "Currently embedding layer only support 1D input";
    goto LABEL_7;
  }
  uint64_t v10 = 0;
  if (*((_DWORD *)a2 + 1) == 1)
  {
    int v11 = *v8;
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = v11;
  }
  else
  {
    *(_DWORD *)(a1 + 40) = 2;
    *(_DWORD *)(a1 + 44) = *((_DWORD *)a2 + 1);
    *(_DWORD *)(a1 + 48) = *v8;
  }
  *(_DWORD *)(a1 + 56) = 4;
  return v10;
}

uint64_t embedding_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned int **)(a1 + 120);
  if (v8 && (unsigned int v9 = v8[1]) != 0 && (v10 = *v8, v10))
  {
    int padded_len = get_padded_len(v10, 8u);
    uint64_t result = 0;
    *a2 = 4 * v9 * padded_len;
    *a3 = 0;
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"invalid param!", a6, a7, a8, v15);
    return 7;
  }
  return result;
}

uint64_t trans_enc_dispatch_weights(uint64_t a1)
{
  padded_uint64_t bytes = 0;
  uint64_t v1 = *(void *)(a1 + 120);
  uint64_t v2 = *(void *)(a1 + 72);
  uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v1 + 48), v2, &padded_bytes);
  if (!result)
  {
    padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
    uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v1 + 56), v2, &padded_bytes);
    if (!result)
    {
      get_padded_bytes(padded_bytes, 8u);
      return 0;
    }
  }
  return result;
}

uint64_t create_trans_enc_layer(uint64_t *a1, long long *a2, void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7 = 0;
  uint64_t result = 7;
  if (a1 && a2)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 64);
      uint64_t v19 = v15;
      if (!v15)
      {
        uint64_t v27 = *a1;
        int v28 = "out of memory!";
LABEL_12:
        log_OutText(v27, (uint64_t)"FastInfer", 0, 0, (uint64_t)v28, v16, v17, v18, v32);
        *(void *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_enc init param failed!", v29, v30, v31, v33);
        uint64_t result = 7;
        goto LABEL_13;
      }
      long long v20 = *a2;
      long long v21 = a2[1];
      *(_OWORD *)(v15 + 28) = *(long long *)((char *)a2 + 28);
      *(_OWORD *)uint64_t v15 = v20;
      *(_OWORD *)(v15 + 16) = v21;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v39 = 0u;
      DWORD1(v39) = 0;
      int v22 = *((_DWORD *)a2 + 6);
      int v37 = 0;
      int v38 = v22;
      uint64_t v36 = *((void *)a2 + 2);
      *((float *)&v39 + 2) = (float)*((unsigned int *)a2 + 7);
      *(void *)&long long v41 = 0;
      DWORD2(v41) = 0;
      if (create_att_layer(a1, (unsigned int *)&v36, a3, a4, (uint64_t *)(v15 + 48)))
      {
        float v26 = "create trans_enc att layer failed!";
LABEL_11:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v23, v24, v25, v32);
        uint64_t v27 = *a1;
        int v28 = "trans_enc network init failed!";
        goto LABEL_12;
      }
      int v34 = *(_DWORD *)a2;
      int8x16_t v35 = vextq_s8(*(int8x16_t *)((char *)a2 + 4), *(int8x16_t *)((char *)a2 + 4), 0xCuLL);
      if (create_ffn_layer(a1, (long long *)&v34, a3, a4, (uint64_t *)(v19 + 56)))
      {
        float v26 = "create trans_enc ffn layer failed!";
        goto LABEL_11;
      }
      *(void *)(v7 + 120) = v19;
      if (a3) {
        *(void *)(v7 + 60) = *a3;
      }
      *(void *)uint64_t v7 = a1;
      *(void *)(v7 + 8) = 35;
      *(void *)(v7 + 128) = forward_trans_enc_layer;
      *(void *)(v7 + 136) = free_trans_enc_layer;
      *(void *)(v7 + 144) = trans_enc_layer_update_shape;
      *(void *)(v7 + 152) = trans_enc_layer_wanted_wb_len;
      *(void *)(v7 + 160) = trans_enc_request_glbBuf;
      *(void *)(v7 + 184) = trans_enc_dispatch_weights;
      *(void *)(v7 + 168) = trans_enc_assign_glbBuf;
      *(void *)(v7 + 176) = trans_enc_layer_reset;
      if (a4)
      {
        uint64_t result = 0;
        *(void *)(v7 + 256) = *(void *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v23, v24, v25, v32);
        uint64_t result = 0;
        *(void *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v32);
      uint64_t result = 10;
    }
  }
LABEL_13:
  *a5 = v7;
  return result;
}

uint64_t forward_trans_enc_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  LODWORD(v18) = 0;
  if (!a2) {
    return 0;
  }
  uint64_t v6 = *(uint64_t **)a2;
  uint64_t v7 = *(void *)(a2 + 120);
  uint64_t v8 = *(void **)(a2 + 240);
  uint64_t v9 = *(void *)(v7 + 48);
  *(_DWORD *)(*(void *)(v9 + 120) + 152) = 0;
  uint64_t bytes = fi_shape_get_bytes((int *)(v9 + 40), &v18);
  if (!bytes)
  {
    bzero(v8, v18);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)(v7 + 48) + 128))(a1);
    if (v11)
    {
      uint64_t bytes = v11;
      uint64_t v15 = "trans_enc forward att layer failed!";
LABEL_5:
      log_OutText(*v6, (uint64_t)"FastInfer", 0, 0, (uint64_t)v15, v12, v13, v14, v17);
      return bytes;
    }
    uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v7 + 56) + 40), &v18);
    if (!bytes)
    {
      bzero(a4, v18);
      uint64_t bytes = (*(uint64_t (**)(uint64_t))(*(void *)(v7 + 56) + 128))(a1);
      if (bytes)
      {
        uint64_t v15 = "trans_enc forward ffn layer failed!";
        goto LABEL_5;
      }
    }
  }
  return bytes;
}

void *free_trans_enc_layer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = result[15];
      if (v3)
      {
        fi_layer_free(*(void *)(v3 + 56));
        fi_layer_free(*(void *)(v3 + 48));
        (*(void (**)(void, uint64_t))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v4 = *(void *)(v2 + 16);
      int v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v5(v4, v1);
    }
  }
  return result;
}

__n128 trans_enc_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 120);
  uint64_t v9 = *(uint64_t **)a1;
  int v10 = *(_DWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v10;
  if (*(_DWORD *)a2 >= 3u)
  {
    uint64_t v11 = *v9;
    uint64_t v12 = "Currently trans_enc layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)v12, a6, a7, a8, v18);
    return result;
  }
  if (!(*(unsigned int (**)(void))(*(void *)(v8 + 48) + 144))()
    && !(*(unsigned int (**)(void))(*(void *)(v8 + 56) + 144))())
  {
    uint64_t v15 = *(void *)(v8 + 56);
    int v17 = *(_DWORD *)(v15 + 40);
    uint64_t v16 = (__n128 *)(v15 + 40);
    if ((v17 - 1) >= 2)
    {
      uint64_t v11 = **(void **)a1;
      uint64_t v12 = "dense out: output shape error";
      goto LABEL_3;
    }
    __n128 result = *v16;
    *(_DWORD *)(a1 + 56) = v16[1].n128_u32[0];
    *(__n128 *)(a1 + 40) = result;
  }
  return result;
}

uint64_t trans_enc_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6 = *(void *)(a1 + 120);
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(v6 + 48) + 152))();
  if (!result)
  {
    padded_uint64_t bytes = get_padded_bytes(0, 8u);
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(v6 + 56) + 152))();
    if (!result)
    {
      *a2 = get_padded_bytes(padded_bytes, 8u);
      *a3 = 0;
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v9, v10, v11, *(unsigned int *)(a1 + 96));
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v12, v13, v14, *a2);
      return 0;
    }
  }
  return result;
}

uint64_t trans_enc_request_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120);
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(v2 + 48) + 160))();
  if (!result)
  {
    unsigned int v4 = *(_DWORD *)(*(void *)(v2 + 48) + 248);
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(v2 + 56) + 160))();
    if (!result)
    {
      unsigned int v5 = *(_DWORD *)(*(void *)(v2 + 56) + 248);
      unsigned int v7 = v5;
      uint64_t result = trans_enc_get_reserved_glbBuf_bytes(a1, &v7);
      if (!result)
      {
        if (v5 <= v4) {
          unsigned int v6 = v4;
        }
        else {
          unsigned int v6 = v5;
        }
        *(_DWORD *)(a1 + 248) = v7 + v6;
      }
    }
  }
  return result;
}

uint64_t trans_enc_assign_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120);
  unsigned int v7 = 0;
  uint64_t result = trans_enc_get_reserved_glbBuf_bytes(a1, &v7);
  if (!result)
  {
    uint64_t v4 = v7;
    uint64_t v5 = *(void *)(v2 + 48);
    uint64_t v6 = *(void *)(v2 + 56);
    *(void *)(v5 + 240) = *(void *)(a1 + 240) + v7;
    *(_DWORD *)(v5 + 248) = *(_DWORD *)(a1 + 248) - v4;
    *(void *)(v6 + 240) = *(void *)(a1 + 240) + v4;
    *(_DWORD *)(v6 + 248) = *(_DWORD *)(a1 + 248) - v4;
  }
  return result;
}

uint64_t trans_enc_layer_reset(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(*(void *)(a1 + 120) + 48) + 176))();
  if (result)
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_enc network reset failed!", v3, v4, v5, v6);
    return 7;
  }
  return result;
}

uint64_t trans_enc_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = *(void *)(a1 + 120);
  unsigned int v6 = 0;
  uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v3 + 48) + 40), &v6);
  if (!bytes) {
    *a2 = get_padded_bytes(v6, 8u);
  }
  return bytes;
}

void *free_att_albert_layer(void *result)
{
  if (!result) {
    return result;
  }
  uint64_t v1 = result;
  uint64_t v2 = *result;
  if (!*result) {
    return result;
  }
  uint64_t v3 = result[15];
  if (v3)
  {
    fi_layer_free(*(void *)(v3 + 72));
    if (*(void *)(v3 + 56))
    {
      if (!*(void *)(v3 + 144)) {
        goto LABEL_8;
      }
      (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
    }
    *(void *)(v3 + 144) = 0;
LABEL_8:
    if (*(_DWORD *)(v3 + 8))
    {
      int v4 = *(_DWORD *)(v3 + 20);
      if (v4 == 1)
      {
        if (*(_DWORD *)(v3 + 64)) {
          goto LABEL_22;
        }
        if (*(void *)(v3 + 176))
        {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
          *(void *)(v3 + 176) = 0;
        }
        uint64_t v5 = (void *)(v3 + 184);
        if (!*(void *)(v3 + 184)) {
          goto LABEL_22;
        }
      }
      else
      {
        if (v4 || *(_DWORD *)(v3 + 64)) {
          goto LABEL_22;
        }
        if (*(void *)(v3 + 160))
        {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
          *(void *)(v3 + 160) = 0;
        }
        uint64_t v5 = (void *)(v3 + 168);
        if (!*(void *)(v3 + 168)) {
          goto LABEL_22;
        }
      }
      (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
      *uint64_t v5 = 0;
    }
LABEL_22:
    (*(void (**)(void, uint64_t))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
  }
  if (*((_DWORD *)v1 + 29))
  {
    if (v1[9]) {
      (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
    }
    *(_OWORD *)(v1 + 11) = 0u;
    *(_OWORD *)(v1 + 13) = 0u;
    *(_OWORD *)(v1 + 9) = 0u;
  }
  uint64_t v6 = *(void *)(v2 + 16);
  unsigned int v7 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
  return (void *)v7(v6, v1);
}

uint64_t create_att_albert_layer(uint64_t *a1, unsigned int *a2, void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7 = 0;
  uint64_t result = 7;
  if (a1 && a2)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 200);
      uint64_t v19 = v15;
      if (!v15)
      {
        uint64_t v28 = *a1;
        uint64_t v29 = "out of memory!";
        goto LABEL_15;
      }
      *(_OWORD *)uint64_t v15 = *(_OWORD *)a2;
      long long v20 = *((_OWORD *)a2 + 1);
      long long v21 = *((_OWORD *)a2 + 2);
      long long v22 = *((_OWORD *)a2 + 3);
      *(void *)(v15 + 64) = *((void *)a2 + 8);
      *(_OWORD *)(v15 + 32) = v21;
      *(_OWORD *)(v15 + 48) = v22;
      *(_OWORD *)(v15 + 16) = v20;
      int v36 = 0;
      *(_DWORD *)(v15 + 192) = 0;
      int padded_len = get_padded_len(*a2, 8u);
      if (a2[7] == 1)
      {
        int v27 = *a2;
        HIDWORD(v34) = 40;
        int v35 = v27;
        if (create_norm_layer(a1, (uint64_t *)((char *)&v34 + 4), (uint64_t *)(v19 + 72)))
        {
          log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"create att norm layer failed!", v23, v24, v25, v34);
          uint64_t v28 = *a1;
          uint64_t v29 = "att network init failed!";
LABEL_15:
          log_OutText(v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)v29, v16, v17, v18, v34);
          *(void *)(v7 + 120) = v19;
          log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"att init param failed!", v31, v32, v33, v34);
          uint64_t result = 7;
          goto LABEL_25;
        }
      }
      int v35 = padded_len;
      int v36 = 0;
      HIDWORD(v34) = 5;
      *(_OWORD *)(v19 + 160) = 0u;
      *(_OWORD *)(v19 + 176) = 0u;
      if (a2[2])
      {
        unsigned int v30 = a2[5];
        if (v30 == 1)
        {
          if (!a2[16])
          {
            *(void *)(v19 + 176) = (*(uint64_t (**)(uint64_t, void, uint64_t))(a1[1] + 16))(a1[2], a2[3] * padded_len, 4);
            *(void *)(v19 + 184) = (*(uint64_t (**)(uint64_t, void, uint64_t))(a1[1] + 16))(a1[2], a2[3] * padded_len, 4);
          }
        }
        else if (!v30 && !a2[16])
        {
          *(void *)(v19 + 160) = (*(uint64_t (**)(uint64_t, void, uint64_t))(a1[1] + 16))(a1[2], a2[4] * padded_len, 4);
          *(void *)(v19 + 168) = (*(uint64_t (**)(uint64_t, void, uint64_t))(a1[1] + 16))(a1[2], a2[4] * padded_len, 4);
        }
      }
      *(_DWORD *)(v19 + 152) = 0;
      if (!*((void *)a2 + 7)) {
        *(void *)(v19 + 144) = 0;
      }
      *(void *)(v7 + 120) = v19;
      if (a3) {
        *(void *)(v7 + 60) = *a3;
      }
      *(void *)uint64_t v7 = a1;
      *(void *)(v7 + 8) = 41;
      *(void *)(v7 + 128) = forward_att_albert_layer;
      *(void *)(v7 + 136) = free_att_albert_layer;
      *(void *)(v7 + 144) = att_albert_layer_update_shape;
      *(void *)(v7 + 152) = att_albert_layer_wanted_wb_len;
      *(void *)(v7 + 160) = att_albert_request_glbBuf;
      *(void *)(v7 + 184) = att_albert_dispatch_weights;
      *(void *)(v7 + 176) = att_albert_layer_reset;
      if (a4)
      {
        uint64_t result = 0;
        *(void *)(v7 + 256) = *(void *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v23, v24, v25, v34);
        uint64_t result = 0;
        *(void *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v34);
      uint64_t result = 10;
    }
  }
LABEL_25:
  *a5 = v7;
  return result;
}

uint64_t forward_att_albert_layer(uint64_t a1, uint64_t a2, void *a3, float32x4_t *a4)
{
  if (!a2) {
    return 0;
  }
  uint64_t v7 = *(uint64_t **)a2;
  uint64_t v8 = *(unsigned int **)(a2 + 120);
  uint64_t step = fi_shape_get_step((_DWORD *)(a2 + 20));
  unsigned int v10 = step;
  uint64_t padded_len = get_padded_len(step, 8u);
  uint64_t v85 = *v8;
  uint64_t v12 = get_padded_len(v85, 8u);
  unsigned int v13 = v8[3];
  int v14 = get_padded_len(v13, 8u);
  unsigned int v18 = v8[5];
  unsigned int v19 = v8[2];
  if (v19) {
    BOOL v20 = 0;
  }
  else {
    BOOL v20 = v18 == 1;
  }
  if (v20)
  {
    log_OutText(*v7, (uint64_t)"FastInfer", 0, 0, (uint64_t)"encoder decoder attention is possible only if isDecoder option has been set to 1", v15, v16, v17, v75);
    return 7;
  }
  unsigned int v90 = v13;
  uint64_t v84 = v8[1];
  unsigned int v79 = v8[5];
  int v88 = v14;
  if (v18 == 1)
  {
    unsigned int v21 = fi_shape_get_step(v8 + 9);
    long long v22 = *(float32x4_t **)(a2 + 240);
    if (v8[2])
    {
      uint64_t v86 = (float32x4_t *)*((void *)v8 + 22);
      uint64_t v23 = (float32x4_t *)*((void *)v8 + 23);
LABEL_13:
      uint64_t v83 = v23;
      uint64_t v25 = v22;
      goto LABEL_15;
    }
  }
  else
  {
    unsigned int v21 = v10 + v10 * v8[48];
    long long v22 = *(float32x4_t **)(a2 + 240);
    if (v19)
    {
      uint64_t v86 = (float32x4_t *)*((void *)v8 + 20);
      uint64_t v23 = (float32x4_t *)*((void *)v8 + 21);
      goto LABEL_13;
    }
  }
  uint64_t v25 = (float32x4_t *)((char *)v22 + 4 * v12 * v10);
  bzero(v25, 4 * v12 * v10);
  uint64_t v83 = 0;
  uint64_t v86 = v25;
LABEL_15:
  uint64_t v80 = v12;
  uint64_t v78 = v12 * v10;
  size_t v26 = 4 * v78;
  bzero(v22, 4 * v78);
  unsigned int __src = a3;
  if (v8[7] == 1)
  {
    uint64_t v27 = (*(uint64_t (**)(uint64_t))(*((void *)v8 + 9) + 128))(a1);
    if (v27)
    {
      uint64_t v24 = v27;
      log_OutText(*v7, (uint64_t)"FastInfer", 0, 0, (uint64_t)"att forward norm layer failed!", v28, v29, v30, v75);
      return v24;
    }
  }
  else
  {
    memcpy(v22, a3, v26);
  }
  uint64_t v89 = v22;
  uint64_t v92 = (uint64_t)v7;
  uint64_t v82 = 4 * v78;
  bzero(a4, v26);
  uint64_t v31 = a4;
  if (v8[6] == 1 && v10)
  {
    int v32 = 0;
    uint64_t v33 = v10;
    do
    {
      memcpy(&v31->f32[v32], *((const void **)v8 + 14), 4 * v85);
      v32 += v80;
      --v33;
    }
    while (v33);
  }
  unsigned int v91 = v88 * v90;
  uint64_t v34 = &v25->i8[4 * v78];
  gemm_v2((uint64_t)v7, 0, v10, v80, v80, (uint64_t)v89, v80, *((void *)v8 + 11), v80, v31, v80);
  uint64_t v81 = v31;
  if (v79 == 1)
  {
    int v36 = (float32x4_t *)*((void *)v8 + 22);
    int v35 = (float32x4_t *)*((void *)v8 + 23);
    uint64_t v37 = v84;
    uint64_t v83 = v35;
    uint64_t v86 = v36;
    if (v8[38]) {
      goto LABEL_42;
    }
    bzero(v36, 4 * v21 * v80);
    bzero(v35, 4 * v21 * v80);
    if (v8[6] == 1 && v21)
    {
      int v38 = 0;
      uint64_t v39 = v21;
      do
      {
        memcpy(&v36->f32[v38], *((const void **)v8 + 13), 4 * v85);
        v38 += v80;
        --v39;
      }
      while (v39);
    }
    gemm_v2(v92, 0, v21, v80, v80, *((void *)v8 + 18), v80, *((void *)v8 + 10), v80, v36, v80);
    if (v8[6] == 1 && v21 != 0)
    {
      int v41 = 0;
      uint64_t v42 = v21;
      do
      {
        memcpy(&v83->f32[v41], *((const void **)v8 + 15), 4 * v85);
        v41 += v80;
        --v42;
      }
      while (v42);
    }
    gemm_v2(v92, 0, v21, v80, v80, *((void *)v8 + 18), v80, *((void *)v8 + 12), v80, v83, v80);
    v8[38] = 1;
  }
  else
  {
    bzero(&v86->f32[v8[48] * v80], v82);
    if (v8[6] == 1 && v10)
    {
      int v43 = 0;
      uint64_t v44 = v10;
      do
      {
        memcpy(&v86->f32[v43], *((const void **)v8 + 13), 4 * v85);
        v43 += v80;
        --v44;
      }
      while (v44);
    }
    gemm_v2((uint64_t)v7, 0, v10, v80, v80, (uint64_t)v89, v80, *((void *)v8 + 10), v80, (float32x4_t *)((char *)v86 + 4 * v8[48] * v80), v80);
  }
  uint64_t v37 = v84;
LABEL_42:
  uint64_t v45 = (v37 + 1);
  unsigned int v87 = &v34[4 * v91];
  if (v37 == -1)
  {
    uint64_t v46 = v80;
    unsigned int v47 = v85 == -1;
  }
  else
  {
    int v48 = 0;
    do
    {
      bzero(&v34[4 * v48], 4 * padded_len * v10);
      v48 += v91;
      --v45;
    }
    while (v45);
    unsigned int v47 = v85 / v37;
    uint64_t v46 = v80;
  }
  unsigned int v49 = 0;
  int v50 = 0;
  uint64_t v51 = v37;
  unsigned int v94 = v47;
  do
  {
    gemm_v2(v92, 1, v10, v21, v94, (uint64_t)v81->i64 + 4 * v49, v46, (uint64_t)v86->i64 + 4 * v49, v46, (float32x4_t *)&v34[4 * v50], padded_len);
    v50 += v91;
    v49 += v94;
    --v51;
  }
  while (v51);
  int v52 = 0;
  int v53 = 0;
  float v54 = 1.0 / sqrt((double)v94);
  uint64_t v55 = v84;
  do
  {
    if (padded_len)
    {
      int v56 = 0;
      int v57 = v52;
      do
      {
        if (v21)
        {
          uint64_t v58 = v21;
          int v59 = v57;
          do
          {
            *(float *)&v34[4 * v59] = *(float *)&v34[4 * v59] * v54;
            ++v59;
            --v58;
          }
          while (v58);
        }
        ++v56;
        v57 += v10;
      }
      while (v56 != padded_len);
    }
    ++v53;
    v52 += v91;
  }
  while (v53 != v84);
  int v60 = v84 - 1;
  if ((int)v84 - 1 >= 0)
  {
    do
    {
      if (v10)
      {
        int v61 = 0;
        uint64_t v62 = v10;
        do
        {
          softmax((float *)&v34[4 * v60 * v91 + 4 * v61], v21, 1, (float *)&v87[4 * v60 * v91 + 4 * v61], *((float *)v8 + 8));
          v61 += padded_len;
          --v62;
        }
        while (v62);
      }
      BOOL v63 = __OFSUB__(v60--, 1);
    }
    while (v60 < 0 == v63);
    uint64_t v46 = v80;
    uint64_t v55 = v84;
  }
  if (v79)
  {
    uint64_t v64 = v46;
    uint64_t v65 = v89;
  }
  else
  {
    uint64_t v66 = v83;
    if (!v8[2]) {
      uint64_t v66 = v81;
    }
    bzero(&v66->f32[v8[48] * v46], v82);
    if (v8[6] == 1 && v10)
    {
      int v67 = 0;
      uint64_t v68 = v10;
      do
      {
        memcpy(&v66->f32[v67], *((const void **)v8 + 15), 4 * v85);
        v67 += v46;
        --v68;
      }
      while (v68);
    }
    uint64_t v83 = v66;
    uint64_t v76 = (float32x4_t *)((char *)v66 + 4 * v8[48] * v46);
    uint64_t v65 = v89;
    uint64_t v64 = v46;
    gemm_v2(v92, 0, v10, v46, v46, (uint64_t)v89, v46, *((void *)v8 + 12), v46, v76, v46);
    uint64_t v55 = v84;
  }
  bzero(v65, v82);
  int v69 = v94;
  int v70 = 0;
  unsigned int v71 = 0;
  do
  {
    gemm_v2(v92, 0, v10, v69, v21, (uint64_t)&v87[4 * v70], padded_len, (uint64_t)v83->i64 + 4 * v71, v64, (float32x4_t *)((char *)v89 + 4 * v71), v64);
    int v69 = v94;
    v71 += v94;
    v70 += v91;
    --v55;
  }
  while (v55);
  memcpy(v81, __src, v82);
  gemm_v2(v92, 0, v10, v64, v64, (uint64_t)v89, v64, *((void *)v8 + 17), v64, v81, v64);
  bzero(v89, v82);
  if (v10)
  {
    int v72 = 0;
    uint64_t v73 = v10;
    do
    {
      memcpy(&v89->f32[v72], *((const void **)v8 + 16), 4 * v64);
      v72 += v64;
      --v73;
    }
    while (v73);
  }
  if (v8[6] == 1) {
    axpy(v78, v89->f32, 1, v81->f32, 1, 1.0);
  }
  uint64_t v24 = 0;
  ++v8[48];
  return v24;
}

__n128 att_albert_layer_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(uint64_t **)a1;
  if (*a2 >= 3u)
  {
    uint64_t v9 = *v8;
    unsigned int v10 = "Currently att layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)v10, a6, a7, a8, v18);
    return result;
  }
  uint64_t v13 = *(void *)(a1 + 120);
  int v14 = (__n128 *)(a1 + 20);
  long long v15 = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = a2[4];
  *(_OWORD *)(a1 + 20) = v15;
  if (*(_DWORD *)(v13 + 28) != 1 || !(*(unsigned int (**)(void))(*(void *)(v13 + 72) + 144))())
  {
    if (*(_DWORD *)(v13 + 20) == 1)
    {
      *(_DWORD *)(v13 + 36) = 2;
      int v16 = *(_DWORD *)(v13 + 28);
      if (!*(void *)(v13 + 72))
      {
        if (v16 == 1)
        {
          uint64_t v9 = *v8;
          unsigned int v10 = "Must set external pointers before shape update for enc_dec att.";
          goto LABEL_3;
        }
LABEL_13:
        __n128 result = *v14;
        *(__n128 *)(a1 + 40) = *v14;
        *(_DWORD *)(a1 + 56) = v14[1].n128_u32[0];
        return result;
      }
    }
    else
    {
      int v16 = *(_DWORD *)(v13 + 28);
    }
    if (v16 == 1)
    {
      uint64_t v17 = *(void *)(v13 + 72);
      __n128 result = *(__n128 *)(v17 + 40);
      *(_DWORD *)(a1 + 56) = *(_DWORD *)(v17 + 56);
      *(__n128 *)(a1 + 40) = result;
      return result;
    }
    goto LABEL_13;
  }
  return result;
}

uint64_t att_albert_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6 = *(unsigned int **)(a1 + 120);
  if (v6[7] != 1 || (uint64_t result = (*(uint64_t (**)(void))(*((void *)v6 + 9) + 152))(), !result))
  {
    padded_uint64_t bytes = get_padded_bytes(0, 8u);
    uint64_t padded_len = get_padded_len(*v6, 8u);
    *a2 = padded_bytes + 16 * (padded_len + padded_len * padded_len);
    *a3 = 0;
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"att k kernel size: %d\n", v10, v11, v12, padded_len);
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v13, v14, v15, *(unsigned int *)(a1 + 96));
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v16, v17, v18, *a2);
    return 0;
  }
  return result;
}

uint64_t att_albert_request_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(_DWORD **)(a1 + 120);
  int v3 = v2[1];
  int v4 = (int *)(a1 + 20);
  unsigned int step = fi_shape_get_step((_DWORD *)(a1 + 20));
  uint64_t v6 = v2[3];
  unsigned int v18 = 0;
  uint64_t result = fi_shape_get_input_dim(v4, (int *)&v18);
  if (!result)
  {
    int padded_len = get_padded_len(v18, 8u);
    if (v18 != *v2)
    {
      uint64_t v12 = **(void **)a1;
      uint64_t v13 = "att input sample dim mismatch! inshape: %d, but config: %d";
      uint64_t v17 = v18;
      goto LABEL_6;
    }
    if (step > v6)
    {
      uint64_t v12 = **(void **)a1;
      uint64_t v13 = "att: input len longer than maximum!";
LABEL_6:
      log_OutText(v12, (uint64_t)"FastInfer", 0, 0, (uint64_t)v13, v9, v10, v11, v17);
      return 7;
    }
    int v14 = (padded_len * v6) << (v2[2] == 0);
    int v15 = get_padded_len(v6, 8u);
    padded_uint64_t bytes = get_padded_bytes(4 * (v14 + ((int)v6 + (int)v6 * v3) * v15), 8u);
    uint64_t result = 0;
    *(_DWORD *)(a1 + 248) = padded_bytes;
  }
  return result;
}

uint64_t att_albert_dispatch_weights(uint64_t a1)
{
  unsigned int v15 = 0;
  uint64_t v2 = *(unsigned int **)(a1 + 120);
  int padded_len = get_padded_len(*v2, 8u);
  padded_uint64_t bytes = 0;
  uint64_t v5 = *(void *)(a1 + 72);
  if (v2[7] == 1)
  {
    uint64_t result = fi_layer_find_weights_via_offset(*((void *)v2 + 9), v5, &v15);
    if (result) {
      return result;
    }
    padded_uint64_t bytes = get_padded_bytes(v15, 8u);
  }
  *((void *)v2 + 11) = v5 + padded_bytes;
  int v7 = 4 * padded_len * padded_len;
  unsigned int v15 = padded_bytes + v7;
  unsigned int v8 = get_padded_bytes(padded_bytes + v7, 8u);
  *((void *)v2 + 14) = v5 + v8;
  unsigned int v15 = v8 + 4 * padded_len;
  unsigned int v9 = get_padded_bytes(v15, 8u);
  *((void *)v2 + 10) = v5 + v9;
  unsigned int v15 = v9 + v7;
  unsigned int v10 = get_padded_bytes(v9 + v7, 8u);
  *((void *)v2 + 13) = v5 + v10;
  unsigned int v15 = v10 + 4 * padded_len;
  unsigned int v11 = get_padded_bytes(v15, 8u);
  *((void *)v2 + 12) = v5 + v11;
  unsigned int v15 = v11 + v7;
  unsigned int v12 = get_padded_bytes(v11 + v7, 8u);
  *((void *)v2 + 15) = v5 + v12;
  unsigned int v15 = v12 + 4 * padded_len;
  unsigned int v13 = get_padded_bytes(v15, 8u);
  *((void *)v2 + 17) = v5 + v13;
  unsigned int v15 = v13 + v7;
  unsigned int v14 = get_padded_bytes(v13 + v7, 8u);
  *((void *)v2 + 16) = v5 + v14;
  get_padded_bytes(v14 + 4 * padded_len, 8u);
  return 0;
}

uint64_t att_albert_layer_reset(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 120);
    if (*(_DWORD *)(v1 + 20) == 1)
    {
      *(void *)(v1 + 144) = 0;
      *(_DWORD *)(v1 + 152) = 0;
      *(_OWORD *)(v1 + 160) = 0u;
      *(_OWORD *)(v1 + 176) = 0u;
    }
  }
  return 0;
}

uint64_t forward_convtrans1d_layer(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, uint64_t a5)
{
  uint64_t v39 = *(uint64_t **)a2;
  unsigned int v8 = *(_DWORD **)(a2 + 120);
  unsigned int v9 = *(unsigned int **)(a2 + 72);
  uint64_t v41 = 0;
  uint64_t v10 = v8[4];
  unsigned int v11 = v8[5];
  BOOL is_enabled = fi_feat_is_enabled(*(void *)(a2 + 256), 4u, *(_DWORD *)(a2 + 264));
  BOOL v13 = fi_feat_is_enabled(*(void *)(a2 + 256), 7u, *(_DWORD *)(a2 + 264));
  memset(v40, 0, sizeof(v40));
  uint64_t v17 = *(const void **)(a2 + 104);
  BOOL v18 = is_enabled || v13;
  if ((is_enabled || v13) && v9)
  {
    unsigned int v19 = &v9[*v9];
  }
  else
  {
    unsigned int v19 = v9;
    if (!v9)
    {
      uint64_t v28 = **(void **)a2;
      uint64_t v29 = "convtrans1d weight not found";
LABEL_18:
      log_OutText(v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)v29, v14, v15, v16, v33);
      return 7;
    }
  }
  uint64_t result = fi_shape_get_size((int *)(a2 + 40), (int *)&v41);
  if (result) {
    return result;
  }
  unsigned int v37 = v11;
  unsigned int step = fi_shape_get_step((_DWORD *)(a2 + 20));
  if (!step)
  {
    uint64_t v28 = **(void **)a2;
    uint64_t v29 = "steps must > 0, but it is: %d";
    uint64_t v33 = 0;
    goto LABEL_18;
  }
  unsigned int v36 = step;
  uint64_t result = fi_shape_get_input_dim((int *)(a2 + 20), (int *)&v41 + 1);
  if (result) {
    return result;
  }
  if (v36 >= 2)
  {
    int v22 = HIDWORD(v41);
    if (get_padded_len(HIDWORD(v41), 8u) != v22)
    {
      uint64_t v28 = *v39;
      uint64_t v29 = "If code reaches here, then there is possibility that GEMM in convtrans1d is incorrect!";
      goto LABEL_18;
    }
  }
  uint64_t v34 = (uint64_t)v19;
  uint64_t v35 = a5;
  if (v8[6] == 1)
  {
    uint64_t v23 = v37 + v37 * v36;
    if (v23)
    {
      int v24 = 0;
      do
      {
        memcpy(&a4->f32[v24], v17, 4 * v10);
        v24 += v10;
        --v23;
      }
      while (v23);
    }
  }
  if (v18)
  {
    uint64_t v25 = v35;
    unsigned int v26 = v37;
    DWORD2(v40[0]) = ((v9[1] >> 1) & 1) == 0;
    uint64_t v27 = v40;
  }
  else
  {
    uint64_t v27 = 0;
    uint64_t v25 = v35;
    unsigned int v26 = v37;
  }
  int v30 = HIDWORD(v41);
  if (v30 == get_padded_len(HIDWORD(v41), 8u)) {
    uint64_t v31 = a3;
  }
  else {
    uint64_t v31 = 0;
  }
  gemm_ex(v39, v36, (*v8 * v10), v8[1], v31, v8[1], v34, v8[1], a4, (*v8 * v10) >> 1, v27);
  uint64_t v32 = v41 - v26 * v10;
  memmove(a4, &a4->f32[(v26 >> 1) * v10], 4 * v32);
  fi_activate_array(a4->f32, v32, v8[8]);
  uint64_t result = 0;
  *(_DWORD *)(a2 + 44) = v36 * v26;
  *(_DWORD *)(v25 + 20) = 1;
  return result;
}

void *free_convtrans1d_layer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      if (result[15])
      {
        (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        v1[15] = 0;
      }
      uint64_t v3 = *(void *)(v2 + 16);
      int v4 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v4(v3, v1);
    }
  }
  return result;
}

uint64_t create_convtrans1d_layer(uint64_t *a1, long long *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v11 && (uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 64)) != 0)
  {
    *(void *)(v11 + 120) = v12;
    *(void *)uint64_t v11 = a1;
    long long v13 = *a2;
    long long v14 = a2[1];
    *(_DWORD *)(v12 + 32) = *((_DWORD *)a2 + 8);
    *(_OWORD *)uint64_t v12 = v13;
    *(_OWORD *)(v12 + 16) = v14;
    *(void *)(v11 + 8) = 69;
    *(void *)(v11 + 128) = forward_convtrans1d_layer;
    *(void *)(v11 + 144) = convtrans1d_layer_update_shape;
    *(void *)(v11 + 152) = conv_layer_wanted_wb_len;
    *(void *)(v11 + 136) = free_convtrans1d_layer;
    if (a3)
    {
      uint64_t result = 0;
      *(void *)(v11 + 256) = *(void *)(a3 + 24);
      *(_DWORD *)(v11 + 264) = *(_DWORD *)(a3 + 16);
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, use v0.0.0", v8, v9, v10, v16);
      uint64_t result = 0;
      *(void *)(v11 + 256) = 0;
      *(_DWORD *)(v11 + 264) = 0;
    }
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v16);
    free_convtrans1d_layer((void *)v11);
    uint64_t result = 10;
  }
  *a4 = v11;
  return result;
}

uint64_t convtrans1d_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)a2 == 2)
  {
    uint64_t result = 0;
    uint64_t v10 = *(_DWORD **)(a1 + 120);
    int v11 = *(_DWORD *)(a2 + 16);
    *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = v11;
    v10[1] = *(_DWORD *)(a2 + 8);
    v10[3] = 1;
    *(_DWORD *)(a1 + 40) = 2;
    *(_DWORD *)(a1 + 44) = *v10 - v10[5] + *(_DWORD *)(a2 + 4) * v10[5];
    *(_DWORD *)(a1 + 48) = v10[4];
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 16);
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"convtrans1d requires input 2D input data", a6, a7, a8, vars0);
    return 7;
  }
  return result;
}

uint64_t create_rnn_layer(uint64_t *a1, uint64_t *a2, uint64_t *a3, void *a4, uint64_t *a5)
{
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16);
  if (!v14) {
    goto LABEL_10;
  }
  uint64_t v15 = (void *)v14;
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 32);
  if (!v16) {
    goto LABEL_10;
  }
  uint64_t v17 = v16;
  *(void *)uint64_t v13 = a1;
  uint64_t v18 = *a2;
  uint64_t v19 = *((unsigned int *)a2 + 1);
  *(_DWORD *)(v13 + 16) = *((_DWORD *)a2 + 2);
  *(void *)(v13 + 8) = v18;
  if (a4) {
    *(void *)(v13 + 60) = *a4;
  }
  uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v19, 4);
  *uint64_t v15 = v20;
  if (v20
    && (v15[1] = v17,
        uint64_t v21 = (*(uint64_t (**)(uint64_t, void, uint64_t))(a1[1] + 16))(a1[2], *((unsigned int *)a2 + 1), 4),
        (*(void *)(v17 + 16) = v21) != 0)
    && (uint64_t v22 = (*(uint64_t (**)(uint64_t, void, uint64_t))(a1[1] + 16))(a1[2], *((unsigned int *)a2 + 1), 4),
        (*(void *)(v17 + 24) = v22) != 0))
  {
    uint64_t result = 0;
    uint64_t v24 = *a3;
    *(_DWORD *)(v17 + 8) = *((_DWORD *)a3 + 2);
    *(void *)uint64_t v17 = v24;
    *(void *)(v13 + 120) = v15;
    *(void *)(v13 + 128) = forward_rnn_layer;
    *(void *)(v13 + 136) = free_rnn_buffer;
    *(void *)(v13 + 144) = rnn_layer_update_shape;
    *(void *)(v13 + 152) = rnn_layer_wanted_wb_len;
    *a5 = v13;
  }
  else
  {
LABEL_10:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v10, v11, v12, v25);
    *a5 = v13;
    free_rnn_buffer((void *)v13);
    return 10;
  }
  return result;
}

uint64_t forward_rnn_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v7 = *(uint64_t **)a2;
  uint64_t v8 = *(void ***)(a2 + 120);
  uint64_t v10 = *v8;
  uint64_t v9 = v8[1];
  int v12 = *(_DWORD *)v9;
  int v11 = *((_DWORD *)v9 + 1);
  int v41 = *((_DWORD *)v9 + 2);
  uint64_t v13 = (float32x4_t *)*((void *)v9 + 2);
  uint64_t v14 = (float32x4_t *)*((void *)v9 + 3);
  unsigned int v43 = 0;
  uint64_t v15 = (_DWORD *)(a2 + 20);
  uint64_t result = fi_shape_get_input_dim((int *)(a2 + 20), (int *)&v43);
  if (!result)
  {
    uint64_t v31 = v7;
    int v37 = v12;
    int v38 = v11;
    uint64_t v39 = v10;
    uint64_t padded_len = get_padded_len(v43, 8u);
    uint64_t v18 = *(unsigned int *)(a2 + 12);
    int v19 = get_padded_len(v18, 8u);
    uint64_t v40 = *(void *)(a2 + 72);
    if (!v41) {
      bzero(v39, 4 * v18);
    }
    int step = fi_shape_get_step(v15);
    if (v43 == padded_len)
    {
      char __dst = 0;
    }
    else
    {
      char __dst = (void *)(*(uint64_t (**)(uint64_t, uint64_t))v7[1])(v7[2], 4 * padded_len);
      if (!__dst)
      {
        log_OutText(*v7, (uint64_t)"FastInfer", 0, 0, (uint64_t)"empty new input memory!", v20, v21, v22, v29);
        return 10;
      }
    }
    uint64_t v36 = a4;
    if (step)
    {
      unsigned int v23 = 0;
      int v24 = 0;
      uint64_t v33 = v40 + 4 * (v18 * padded_len);
      uint64_t v34 = padded_len;
      uint64_t v35 = a3;
      do
      {
        uint64_t v25 = (const void *)(a3 + 4 * v43 * v24);
        if (v43 == padded_len)
        {
          int v26 = v38;
        }
        else
        {
          int v26 = v38;
          if (!__dst)
          {
            log_OutText(*v31, (uint64_t)"FastInfer", 0, 0, (uint64_t)"empty new input memory!", v20, v21, v22, v29);
            return 0;
          }
          memcpy(__dst, v25, 4 * v43);
          uint64_t v25 = __dst;
          uint64_t padded_len = v43;
        }
        if (v26 == 1) {
          unsigned int v27 = v23;
        }
        else {
          unsigned int v27 = 0;
        }
        uint64_t v28 = (void *)(v36 + 4 * v27);
        bzero(v13, 4 * v18);
        bzero(v14, 4 * v18);
        gemm(*(uint64_t **)a2, 1, v18, padded_len, (uint64_t)v25, v40, v13, 0, v29);
        gemm(*(uint64_t **)a2, 1, v18, v18, (uint64_t)v39, v33, v14, 0, v30);
        axpy(v18, v13->f32, 1, v14->f32, 1, 1.0);
        axpy(v18, (float *)(v33 + 4 * (v19 * v18)), 1, v14->f32, 1, 1.0);
        fi_activate_array(v14->f32, v18, v37);
        memcpy(v39, v14, 4 * v18);
        memcpy(v28, v14, 4 * v18);
        ++v24;
        v23 += v18;
        uint64_t padded_len = v34;
        a3 = v35;
      }
      while (step != v24);
    }
    if (__dst) {
      (*(void (**)(uint64_t))(v31[1] + 48))(v31[2]);
    }
    return 0;
  }
  return result;
}

void *free_rnn_buffer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = (void *)result[15];
      if (v3)
      {
        uint64_t v4 = v3[1];
        if (v4)
        {
          if (*(void *)(v4 + 16))
          {
            (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
            *(void *)(v4 + 16) = 0;
          }
          if (*(void *)(v4 + 24))
          {
            (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
            *(void *)(v4 + 24) = 0;
          }
          (*(void (**)(void, uint64_t))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v4);
        }
        if (*v3)
        {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
          *uint64_t v3 = 0;
        }
        (*(void (**)(void, void *))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v5 = *(void *)(v2 + 16);
      uint64_t v6 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v6(v5, v1);
    }
  }
  return result;
}

uint64_t rnn_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)a2 == 2)
  {
    int v8 = *(_DWORD *)(*(void *)(*(void *)(a1 + 120) + 8) + 4);
    int v9 = *(_DWORD *)(a2 + 16);
    *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
    *(_DWORD *)(a1 + 36) = v9;
    if (v8 == 1)
    {
      uint64_t v10 = 0;
      *(_DWORD *)(a1 + 40) = *(_DWORD *)a2;
      int v11 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 4);
      *(_DWORD *)(a1 + 48) = v11;
    }
    else
    {
      uint64_t v10 = 0;
      int v12 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 40) = 1;
      *(_DWORD *)(a1 + 44) = v12;
    }
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 16);
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently only 2D RNN is supported", a6, a7, a8, vars0);
    return 7;
  }
  return v10;
}

uint64_t rnn_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int v10 = 0;
  uint64_t input_dim = fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v10);
  if (!input_dim)
  {
    int padded_len = get_padded_len(v10, 8u);
    uint64_t v8 = *(unsigned int *)(a1 + 12);
    *a2 = 4 * v8 * (get_padded_len(v8, 8u) + padded_len);
    *a3 = 4 * v8;
  }
  return input_dim;
}

uint64_t trans_encoder_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = *(unsigned int **)(a1 + 120);
  unsigned int v18 = 0;
  if (v9)
  {
    uint64_t v10 = *v9;
    uint64_t result = trans_dec_get_reserved_glbBuf_bytes(a1, &v18);
    if (!result)
    {
      if (v10)
      {
        uint64_t v12 = 0;
        uint64_t v13 = v18;
        uint64_t v14 = 8 * v10;
        do
        {
          uint64_t v15 = *(void *)(*((void *)v9 + 6) + v12);
          *(void *)(v15 + 240) = *(void *)(a1 + 240) + v13;
          *(_DWORD *)(v15 + 248) = *(_DWORD *)(a1 + 248) - v13;
          uint64_t v16 = *(void (**)(void))(v15 + 168);
          if (v16) {
            v16();
          }
          v12 += 8;
        }
        while (v14 != v12);
      }
      return 0;
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t create_trans_encoder(uint64_t *a1, unsigned int *a2, void *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7 = 0;
  uint64_t result = 7;
  if (a1 && a2)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      uint64_t v15 = (_OWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 88);
      int v19 = v15;
      if (!v15)
      {
        uint64_t v31 = *a1;
        uint64_t v32 = "out of memory!";
LABEL_20:
        log_OutText(v31, (uint64_t)"FastInfer", 0, 0, (uint64_t)v32, v16, v17, v18, v37);
        *(void *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_encoder init param failed!", v34, v35, v36, v38);
        uint64_t result = 7;
        goto LABEL_21;
      }
      long long v20 = *(_OWORD *)a2;
      long long v21 = *((_OWORD *)a2 + 2);
      v15[1] = *((_OWORD *)a2 + 1);
      v15[2] = v21;
      *uint64_t v15 = v20;
      uint64_t v22 = *a2;
      uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v22, 8);
      *((void *)v19 + 6) = v23;
      if (!v23)
      {
        uint64_t v29 = *a1;
        uint64_t v30 = "out of memory!";
        goto LABEL_19;
      }
      if (v22)
      {
        uint64_t v27 = 0;
        uint64_t v28 = 8 * v22;
        while (!create_trans_enc_layer(a1, (long long *)(a2 + 1), a3, a4, (uint64_t *)(*((void *)v19 + 6) + v27)))
        {
          v27 += 8;
          if (v28 == v27) {
            goto LABEL_10;
          }
        }
        uint64_t v29 = *a1;
        uint64_t v30 = "create trans_encoder trans_enc layer failed!";
        goto LABEL_19;
      }
LABEL_10:
      uint64_t v41 = 0;
      int v40 = 40;
      if (create_norm_layer(a1, (uint64_t *)&v40, (uint64_t *)v19 + 7))
      {
        uint64_t v29 = *a1;
        uint64_t v30 = "create trans_encoder norm layer failed!";
LABEL_19:
        log_OutText(v29, (uint64_t)"FastInfer", 0, 0, (uint64_t)v30, v24, v25, v26, v37);
        uint64_t v31 = *a1;
        uint64_t v32 = "trans_encoder network init failed!";
        goto LABEL_20;
      }
      unsigned int v33 = a2[10];
      LODWORD(v39) = a2[5];
      HIDWORD(v39) = v33;
      if (create_embedding_layer(a1, &v39, (uint64_t ***)v19 + 9)
        || (LODWORD(v39) = a2[5], HIDWORD(v39) = 32,
                                  create_embedding_layer(a1, &v39, (uint64_t ***)v19 + 8)))
      {
        uint64_t v29 = *a1;
        uint64_t v30 = "create trans_encoder target_space_id emb layer failed!";
        goto LABEL_19;
      }
      *(void *)(v7 + 120) = v19;
      if (a3) {
        *(void *)(v7 + 60) = *a3;
      }
      *(void *)uint64_t v7 = a1;
      *(void *)(v7 + 8) = 36;
      *(void *)(v7 + 128) = forward_trans_encoder;
      *(void *)(v7 + 136) = free_trans_encoder;
      *(void *)(v7 + 144) = trans_encoder_update_shape;
      *(void *)(v7 + 152) = trans_encoder_wanted_wb_len;
      *(void *)(v7 + 160) = trans_encoder_request_glbBuf;
      *(void *)(v7 + 184) = trans_encoder_dispatch_weights;
      *(void *)(v7 + 168) = trans_encoder_assign_glbBuf;
      *(void *)(v7 + 176) = trans_encoder_reset;
      if (a4)
      {
        uint64_t result = 0;
        *(void *)(v7 + 256) = *(void *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v24, v25, v26, v37);
        uint64_t result = 0;
        *(void *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v37);
      uint64_t result = 10;
    }
  }
LABEL_21:
  *a5 = v7;
  return result;
}

uint64_t forward_trans_encoder(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  LODWORD(v54) = 0;
  if (!a2) {
    return 0;
  }
  if (a5) {
    *(_DWORD *)(a5 + 20) = 1;
  }
  int v11 = *(uint64_t **)a2;
  uint64_t v12 = *(unsigned int **)(a2 + 120);
  if (!v12)
  {
    uint64_t v17 = *v11;
    uint64_t v18 = "config empty";
    goto LABEL_14;
  }
  unsigned int v13 = v12[7];
  unsigned int v14 = 1;
  while (v12[11] != *(float *)(a3 + 4 * (v14 - 1)))
  {
    if (v14++ > v13) {
      return 7;
    }
  }
  if (v14 <= 1)
  {
    uint64_t v17 = *v11;
    uint64_t v18 = "No input given to encoder.";
LABEL_14:
    log_OutText(v17, (uint64_t)"FastInfer", 0, 0, (uint64_t)v18, a6, a7, a8, v50);
    return 7;
  }
  long long v51 = *(_OWORD *)(a2 + 20);
  if (v14 < v13) {
    unsigned int v13 = v14;
  }
  int v52 = *(_DWORD *)(a2 + 36);
  DWORD1(v51) = v13;
  uint64_t updated = trans_encoder_update_shape(a2, &v51, a3, (uint64_t)a4, a5, a6, a7, a8);
  if (updated)
  {
    uint64_t bytes = updated;
    uint64_t v21 = *v11;
    uint64_t v22 = fi_layer_type_to_name(*(_DWORD *)(a2 + 8));
    uint64_t v26 = "update shape of %s layer failed!";
    uint64_t v50 = (uint64_t)v22;
    uint64_t v27 = v21;
  }
  else
  {
    int v28 = v12[9];
    float v53 = (float)v28;
    uint64_t v29 = *v12;
    uint64_t bytes = fi_shape_get_bytes((int *)(*((void *)v12 + 9) + 40), &v54);
    if (bytes) {
      return bytes;
    }
    uint64_t v30 = *(float **)(a2 + 240);
    uint64_t v31 = (char *)v30 + (v54 & 0xFFFFFFFC);
    int step = fi_shape_get_step((_DWORD *)(*((void *)v12 + 9) + 40));
    (*(void (**)(uint64_t))(*((void *)v12 + 9) + 128))(a1);
    if (step)
    {
      unsigned int v33 = 0;
      int v34 = 0;
      uint64_t v35 = v12[5];
      do
      {
        if (v35)
        {
          uint64_t v36 = *((void *)v12 + 10);
          uint64_t v37 = v35;
          unsigned int v38 = v33;
          do
          {
            *(float *)&v31[4 * v38] = *(float *)(v36 + 4 * v38) + *(float *)&v31[4 * v38];
            ++v38;
            --v37;
          }
          while (v37);
        }
        ++v34;
        v33 += v35;
      }
      while (v34 != step);
    }
    if ((v28 & 0x80000000) == 0)
    {
      (*(void (**)(uint64_t))(*((void *)v12 + 8) + 128))(a1);
      if (step)
      {
        int v39 = 0;
        int v40 = 0;
        uint64_t v41 = v12[5];
        do
        {
          if (v41)
          {
            uint64_t v42 = v41;
            unsigned int v43 = v30;
            int v44 = v39;
            do
            {
              float v45 = *v43++;
              *(float *)&v31[4 * v44] = v45 + *(float *)&v31[4 * v44];
              ++v44;
              --v42;
            }
            while (v42);
          }
          ++v40;
          v39 += v41;
        }
        while (v40 != step);
      }
    }
    if (v29)
    {
      unint64_t v46 = 0;
      if (v29) {
        unsigned int v47 = v30;
      }
      else {
        unsigned int v47 = a4;
      }
      while (1)
      {
        int v48 = v47;
        bzero(v47, v54);
        uint64_t v49 = (*(uint64_t (**)(uint64_t))(*(void *)(*((void *)v12 + 6) + 8 * v46) + 128))(a1);
        if (v49) {
          break;
        }
        if (v48 == a4) {
          unsigned int v47 = v30;
        }
        else {
          unsigned int v47 = a4;
        }
        if (v46 >= (v29 - 1)) {
          unsigned int v47 = v48;
        }
        if (v29 == ++v46) {
          goto LABEL_47;
        }
      }
      uint64_t bytes = v49;
      uint64_t v27 = *v11;
      uint64_t v26 = "trans_encoder forward trans_enc layer failed!";
    }
    else
    {
LABEL_47:
      bzero(a4, v54);
      uint64_t bytes = (*(uint64_t (**)(uint64_t))(*((void *)v12 + 7) + 128))(a1);
      if (!bytes) {
        return bytes;
      }
      uint64_t v27 = *v11;
      uint64_t v26 = "trans_encoder forward norm layer failed!";
    }
  }
  log_OutText(v27, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v23, v24, v25, v50);
  return bytes;
}

void *free_trans_encoder(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = (void *)result[15];
      if (v3)
      {
        uint64_t v4 = *(unsigned int *)v3;
        fi_layer_free(v3[7]);
        fi_layer_free(v3[8]);
        fi_layer_free(v3[9]);
        if (v4)
        {
          uint64_t v5 = 0;
          uint64_t v6 = 8 * v4;
          do
          {
            fi_layer_free(*(void *)(v3[6] + v5));
            v5 += 8;
          }
          while (v6 != v5);
        }
        if (v3[6])
        {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
          v3[6] = 0;
        }
        (*(void (**)(void, void *))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v7 = *(void *)(v2 + 16);
      uint64_t v8 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v8(v7, v1);
    }
  }
  return result;
}

uint64_t trans_encoder_update_shape(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned int **)(a1 + 120);
  int v9 = *(uint64_t **)a1;
  unsigned int v25 = 0;
  if (!v8)
  {
    uint64_t v13 = *v9;
    unsigned int v14 = "out of memory!";
    goto LABEL_7;
  }
  uint64_t v11 = *v8;
  long long v12 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v12;
  if (*(_DWORD *)a2 >= 2u)
  {
    uint64_t v13 = *v9;
    unsigned int v14 = "Currently trans_encoder layer only support 1D input";
LABEL_7:
    log_OutText(v13, (uint64_t)"FastInfer", 0, 0, (uint64_t)v14, a6, a7, a8, v24);
    return 7;
  }
  fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v25);
  if (v25 > v8[7])
  {
    uint64_t v13 = *v9;
    unsigned int v14 = "Encoder input shape dimension must be maximum %d. Found %d";
    uint64_t v24 = v8[7];
    goto LABEL_7;
  }
  uint64_t result = (*(uint64_t (**)(void))(*((void *)v8 + 9) + 144))();
  if (!result)
  {
    if (v11)
    {
      uint64_t v16 = 0;
      uint64_t v17 = *((void *)v8 + 6);
      uint64_t v18 = 8 * v11;
      while (1)
      {
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(v17 + v16) + 144))();
        if (result) {
          break;
        }
        uint64_t v17 = *((void *)v8 + 6);
        v16 += 8;
        if (v18 == v16) {
          goto LABEL_14;
        }
      }
    }
    else
    {
LABEL_14:
      uint64_t result = (*(uint64_t (**)(void))(*((void *)v8 + 7) + 144))();
      if (!result)
      {
        uint64_t v19 = *((void *)v8 + 7);
        int v21 = *(_DWORD *)(v19 + 40);
        long long v20 = (long long *)(v19 + 40);
        if ((v21 - 1) < 2)
        {
          long long v22 = *v20;
          *(_DWORD *)(a1 + 56) = *((_DWORD *)v20 + 4);
          *(_OWORD *)(a1 + 40) = v22;
          uint64_t v26 = 0x100000001;
          unsigned int v23 = v8[5];
          int v27 = 32;
          unsigned int v28 = v23;
          int v29 = 4;
          return (*(uint64_t (**)(void))(*((void *)v8 + 8) + 144))();
        }
        uint64_t v13 = **(void **)a1;
        unsigned int v14 = "dense out: output shape error";
        goto LABEL_7;
      }
    }
  }
  return result;
}

uint64_t trans_encoder_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v27 = 0;
  int v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    uint64_t v12 = *v9;
    if (v12)
    {
      uint64_t v13 = 0;
      padded_uint64_t bytes = 0;
      uint64_t v15 = 8 * v12;
      while (1)
      {
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(*((void *)v9 + 6) + v13) + 152))();
        if (result) {
          break;
        }
        padded_uint64_t bytes = get_padded_bytes(HIDWORD(v27) + padded_bytes + (int)v27, 8u);
        v13 += 8;
        if (v15 == v13) {
          goto LABEL_9;
        }
      }
    }
    else
    {
      padded_uint64_t bytes = 0;
LABEL_9:
      uint64_t result = (*(uint64_t (**)(void))(*((void *)v9 + 7) + 152))();
      if (!result)
      {
        int v17 = get_padded_bytes(HIDWORD(v27) + padded_bytes + (int)v27, 8u);
        uint64_t result = (*(uint64_t (**)(void))(*((void *)v9 + 8) + 152))();
        if (!result)
        {
          int v18 = get_padded_bytes(HIDWORD(v27) + (int)v27 + v17, 8u);
          uint64_t result = (*(uint64_t (**)(void, char *, uint64_t *))(*((void *)v9 + 8) + 152))(*((void *)v9 + 9), (char *)&v27 + 4, &v27);
          if (!result)
          {
            int v19 = get_padded_bytes(HIDWORD(v27) + (int)v27 + v18, 8u);
            *a2 = get_padded_bytes(v19 + 4 * v9[7] * v9[5], 8u);
            *a3 = 0;
            log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v20, v21, v22, *(unsigned int *)(a1 + 96));
            log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v23, v24, v25, *a2);
            return 0;
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v26);
    return 7;
  }
  return result;
}

uint64_t trans_encoder_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = *(unsigned int **)(a1 + 120);
  if (v9)
  {
    uint64_t v10 = *v9;
    if (v10)
    {
      uint64_t v11 = 0;
      unsigned int v12 = 0;
      unsigned int v13 = 0;
      uint64_t v14 = *((void *)v9 + 6);
      uint64_t v15 = 8 * v10;
      do
      {
        uint64_t v16 = *(uint64_t (**)(void))(*(void *)(v14 + v11) + 160);
        if (v16)
        {
          uint64_t result = v16();
          if (result) {
            return result;
          }
          uint64_t v14 = *((void *)v9 + 6);
          unsigned int v13 = *(_DWORD *)(*(void *)(v14 + v11) + 248);
          if (v13 > v12) {
            unsigned int v12 = *(_DWORD *)(*(void *)(v14 + v11) + 248);
          }
        }
        v11 += 8;
      }
      while (v15 != v11);
    }
    else
    {
      unsigned int v13 = 0;
      unsigned int v12 = 0;
    }
    unsigned int v20 = v13;
    uint64_t result = trans_dec_get_reserved_glbBuf_bytes(a1, &v20);
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(v20 + v12, 8u);
      uint64_t result = 0;
      *(_DWORD *)(a1 + 248) = padded_bytes;
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v19);
    return 7;
  }
  return result;
}

uint64_t trans_encoder_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned int **)(a1 + 120);
  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 72);
    *((void *)v8 + 10) = v9;
    padded_uint64_t bytes = get_padded_bytes(4 * v8[5] * v8[7], 8u);
    uint64_t result = fi_layer_find_weights_via_offset(*((void *)v8 + 9), v9, &padded_bytes);
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
      uint64_t v11 = *v8;
      if (v11)
      {
        uint64_t v12 = 0;
        uint64_t v13 = 8 * v11;
        while (1)
        {
          uint64_t v14 = *(void *)(*((void *)v8 + 6) + v12);
          if (!v14) {
            return 10;
          }
          uint64_t result = fi_layer_find_weights_via_offset(v14, v9, &padded_bytes);
          if (result) {
            return result;
          }
          padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
          v12 += 8;
          if (v13 == v12) {
            goto LABEL_8;
          }
        }
      }
      else
      {
LABEL_8:
        uint64_t result = fi_layer_find_weights_via_offset(*((void *)v8 + 7), v9, &padded_bytes);
        if (!result)
        {
          padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
          uint64_t result = fi_layer_find_weights_via_offset(*((void *)v8 + 8), v9, &padded_bytes);
          if (!result)
          {
            get_padded_bytes(padded_bytes, 8u);
            return 0;
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v15);
    return 7;
  }
  return result;
}

uint64_t trans_encoder_reset(uint64_t a1)
{
  uint64_t v1 = *(unsigned int **)(a1 + 120);
  uint64_t v2 = *v1;
  if (!v2) {
    return 0;
  }
  uint64_t v4 = 0;
  uint64_t v5 = 8 * v2;
  while (!(*(unsigned int (**)(void))(*(void *)(*((void *)v1 + 6) + v4) + 176))())
  {
    v4 += 8;
    if (v5 == v4) {
      return 0;
    }
  }
  log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"trans_encoder network reset failed!", v6, v7, v8, v10);
  return 7;
}

uint64_t get_lstm_step_f(void *a1, unsigned int a2)
{
  if (a2 > 3) {
    return 7;
  }
  uint64_t result = 0;
  *a1 = off_26C21F880[a2];
  return result;
}

uint64_t lstm_step_f32_4_small_matrix(uint64_t *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, float32x4_t *a7, uint64_t a8, float *a9, void *a10, float *a11, int a12, int a13, uint64_t a14, unsigned int a15, _DWORD *a16, _DWORD *a17)
{
  int padded_len = get_padded_len(a4, 8u);
  unsigned int v21 = get_padded_len(a5, 8u);
  unsigned int v22 = v21;
  if (a16[1] == 1 && !*a16) {
    unsigned int v23 = v21;
  }
  else {
    unsigned int v23 = a5;
  }
  uint64_t v24 = a14 + 4 * a15;
  uint64_t v25 = a8 + 4 * a15;
  if (a16[2]) {
    int v26 = padded_len * a5;
  }
  else {
    int v26 = v21 * a4;
  }
  unsigned int v27 = v26 + a15;
  size_t v43 = v25 + 4 * v27;
  unsigned int v28 = a15 + v21 * a5;
  uint64_t v49 = v25 + 12 * v27;
  uint64_t v44 = v24 + 4 * v28;
  uint64_t v46 = v25 + 8 * v27;
  uint64_t v47 = v24 + 8 * v28;
  float v45 = &a9[v23];
  int v48 = &a9[2 * v23];
  uint64_t v50 = &a9[3 * v23];
  uint64_t v52 = v24 + 12 * v28;
  bzero(a7, 16 * v21);
  int v29 = (float32x4_t *)((char *)a7 + 4 * v22);
  uint64_t v30 = (float32x4_t *)((char *)a7 + 8 * v22);
  uint64_t v31 = (float32x4_t *)((char *)a7 + 12 * v22);
  gemm(a1, 1, a5, a4, a2, v25, a7, a16, v34);
  gemm(a1, 1, a5, a5, (uint64_t)a10, v24, v30, a17, v35);
  axpy(a5, a9, 1, a7->f32, 1, 1.0);
  axpy(a5, v30->f32, 1, a7->f32, 1, 1.0);
  fi_activate_array(a7->f32, a5, a13);
  gemm(a1, 1, a5, a4, a2, v43, v31, a16, v36);
  bzero(v30, 4 * a5);
  gemm(a1, 1, a5, a5, (uint64_t)a10, v44, v30, a17, v37);
  axpy(a5, v45, 1, v31->f32, 1, 1.0);
  axpy(a5, v30->f32, 1, v31->f32, 1, 1.0);
  fi_activate_array(v31->f32, a5, a13);
  gemm(a1, 1, a5, a4, a2, v46, v29, a16, v38);
  size_t v32 = 4 * a5;
  bzero(v30, v32);
  gemm(a1, 1, a5, a5, (uint64_t)a10, v47, v30, a17, v39);
  axpy(a5, v48, 1, v29->f32, 1, 1.0);
  axpy(a5, v30->f32, 1, v29->f32, 1, 1.0);
  fi_activate_array(v29->f32, a5, a12);
  xmy(a5, a11, 1, v31->f32, 1);
  xmy(a5, a7->f32, 1, v29->f32, 1);
  axpy(a5, v31->f32, 1, v29->f32, 1, 1.0);
  bzero(v30, v32);
  gemm(a1, 1, a5, a4, a2, v49, v30, a16, v40);
  bzero(v31, v32);
  gemm(a1, 1, a5, a5, (uint64_t)a10, v52, v31, a17, v41);
  axpy(a5, v50, 1, v30->f32, 1, 1.0);
  axpy(a5, v31->f32, 1, v30->f32, 1, 1.0);
  fi_activate_array(v30->f32, a5, a13);
  memcpy(a11, v29, v32);
  fi_activate_array(v29->f32, a5, a12);
  xmy(a5, v30->f32, 1, v29->f32, 1);
  memcpy(a10, v29, v32);
  memcpy(a3, v29, v32);
  return 0;
}

uint64_t lstm_step_f32_1_big_matrix_x_4h(uint64_t *a1, uint64_t a2, void *a3, unsigned int a4, uint64_t a5, uint64_t a6, float32x4_t *a7, uint64_t a8, const void *a9, void *a10, float *a11, int a12, int a13, uint64_t a14, unsigned int a15, _DWORD *a16, _DWORD *a17)
{
  uint64_t v20 = a8 + 4 * a15;
  int padded_len = get_padded_len(a5, 8u);
  memcpy(a7, a9, 4 * (4 * a5));
  bzero(&a7->f32[4 * padded_len], 4 * (4 * padded_len));
  gemm(a1, 1, (4 * a5), a4, a2, v20, a7, a16, v26);
  gemm(a1, 1, (4 * a5), a5, (uint64_t)a10, a14 + 4 * a15, a7, a17, v27);
  unsigned int v22 = &a7->f32[padded_len];
  memmove(v22, &a7->f32[a5], 4 * (3 * a5));
  unsigned int v23 = &a7->f32[2 * padded_len];
  memmove(v23, &v22[a5], 4 * (2 * a5));
  uint64_t v24 = &a7->f32[3 * padded_len];
  memmove(v24, &v23[a5], 4 * a5);
  fi_activate_array(a7->f32, a5, a13);
  fi_activate_array(v22, a5, a13);
  fi_activate_array(v23, a5, a12);
  fi_activate_array(v24, a5, a13);
  xmy(a5, a11, 1, v22, 1);
  xmy(a5, a7->f32, 1, v23, 1);
  axpy(a5, v22, 1, v23, 1, 1.0);
  memcpy(a11, v23, 4 * a5);
  fi_activate_array(v23, a5, a12);
  xmy(a5, v24, 1, v23, 1);
  memcpy(a10, v23, 4 * a5);
  memcpy(a3, v23, 4 * a5);
  return 0;
}

uint64_t lstm_step_f32_svd(uint64_t *a1, uint64_t a2, float *a3, uint64_t a4, uint64_t a5, uint64_t a6, float32x4_t *a7, uint64_t a8, const void *a9, void *a10, float *a11, int a12, int a13, uint64_t a14, uint64_t a15, _DWORD *a16, _DWORD *a17)
{
  int padded_len = get_padded_len(a4, 8u);
  unsigned int v24 = get_padded_len(a5, 8u);
  uint64_t v25 = a8 + 4 * (padded_len * a6);
  bzero(a7, 32 * v24);
  uint64_t v26 = &a7[v24];
  gemm(a1, 1, a6, a4, a2, a8, a7, a16, v35);
  gemm(a1, 1, a6, a5, (uint64_t)a10, v25, v26, a17, v36);
  axpy(a6, v26->f32, 1, a7->f32, 1, 1.0);
  memcpy(v26, a9, 4 * (4 * a5));
  gemm(a1, 1, (4 * a5), a6, (uint64_t)a7, v25 + 4 * v24 * a6, v26, a17, v37);
  if (v24 == a5)
  {
    uint64_t v27 = v24;
    uint64_t v28 = 2 * v24;
    size_t v29 = 4 * a5;
    uint64_t v30 = 3 * v24;
  }
  else
  {
    uint64_t v30 = 3 * v24;
    size_t v29 = 4 * a5;
    memmove(&v26->f32[v30], &v26->f32[(3 * a5)], v29);
    uint64_t v28 = 2 * v24;
    memmove(&v26->f32[v28], &v26->f32[(2 * a5)], v29);
    uint64_t v27 = v24;
    memmove(&v26->f32[v24], (char *)v26 + v29, v29);
  }
  uint64_t v31 = &v26->f32[v27];
  size_t v32 = &v26->f32[v28];
  unsigned int v33 = &v26->f32[v30];
  fi_activate_array(v26->f32, a5, a13);
  fi_activate_array(v31, a5, a13);
  fi_activate_array(v32, a5, a12);
  fi_activate_array(v33, a5, a13);
  fi_multiply_multiply_add_ansic(a11, v31, v26->f32, v32, a3, a5);
  memcpy(a11, a3, v29);
  fi_activate_array(a3, a5, a12);
  xmy(a5, v33, 1, a3, 1);
  memcpy(a10, a3, v29);
  return 0;
}

uint64_t lstm_step_f32_1_big_matrix_x_4h_peephole(uint64_t *a1, uint64_t a2, float *a3, unsigned int a4, uint64_t a5, uint64_t a6, float32x4_t *a7, uint64_t a8, const void *a9, uint64_t a10, float *a11, int a12, int a13, uint64_t a14, unsigned int a15, _DWORD *a16, _DWORD *a17, int a18)
{
  uint64_t v19 = a5;
  unsigned int v21 = a11;
  unsigned int v22 = (float *)a10;
  uint64_t v38 = a8 + 4 * a15;
  uint64_t v41 = a14 + 4 * a15;
  unsigned int padded_len = get_padded_len(a5, 8u);
  int v40 = get_padded_len((4 * v19), 8u);
  unsigned int v24 = a1;
  memcpy(a7, a9, 16 * padded_len);
  bzero(&a7[padded_len], 16 * padded_len);
  gemm(a1, 1, (4 * v19), a4, a2, v38, a7, a16, (uint64_t)a1);
  if (a18 == 1) {
    gemm(v24, 1, (4 * v19), v19, a10, v41, a7, a17, v37);
  }
  uint64_t v25 = padded_len;
  if (padded_len == v19)
  {
    uint64_t v43 = 2 * padded_len;
    uint64_t v26 = 3 * padded_len;
  }
  else
  {
    memmove(&a7->f32[padded_len], &a7->f32[v19], 4 * (3 * v19));
    uint64_t v43 = 2 * padded_len;
    memmove(&a7->f32[v43], &a7->f32[padded_len + v19], 4 * (2 * v19));
    uint64_t v26 = 3 * padded_len;
    memmove(&a7->f32[v26], &a7->f32[v43 + v19], 4 * v19);
  }
  uint64_t v27 = (float *)(v41 + 4 * (v40 * v19));
  fi_multiply_add_ansic(a7->f32, a11, v27, v19);
  uint64_t v28 = &a7->f32[v25];
  fi_multiply_add_ansic(v28, a11, &v27[v25], v19);
  size_t v29 = &a7->f32[v43];
  uint64_t v30 = &a7->f32[v26];
  fi_activate_array(a7->f32, v19, a13);
  fi_activate_array(v28, v19, a13);
  fi_activate_array(v29, v19, a12);
  fi_multiply_multiply_add_ansic(a11, v28, a7->f32, v29, a11, v19);
  fi_multiply_add_ansic(v30, a11, &v27[v43], v19);
  fi_activate_array(v30, v19, a13);
  if (v19)
  {
    uint64_t v19 = v19;
    do
    {
      float v31 = *v30++;
      float v32 = v31;
      float v33 = *v21++;
      float v34 = v32 * tanhf(v33);
      *v22++ = v34;
      *a3++ = v34;
      --v19;
    }
    while (v19);
  }
  return 0;
}

uint64_t gru_layer_wanted_wb_len(uint64_t **a1, unsigned int *a2, _DWORD *a3)
{
  unsigned int v71 = 0;
  uint64_t is_enabled = fi_feat_is_enabled((uint64_t)a1[32], 4u, *((_DWORD *)a1 + 66));
  BOOL v7 = fi_feat_is_enabled((uint64_t)a1[32], 7u, *((_DWORD *)a1 + 66));
  BOOL v11 = (is_enabled | v7) != 0;
  if (is_enabled | v7) {
    BOOL v12 = (a1[2] & 0xFFFFFFFD) == 1;
  }
  else {
    BOOL v12 = 0;
  }
  if (!v12 || (uint64_t v13 = a1[9]) != 0 && (*((unsigned char *)v13 + 4) & 2) != 0)
  {
    uint64_t v16 = a1[15];
    if (!v16) {
      return 7;
    }
    int v17 = (int *)v16[1];
    if (!v17) {
      return 7;
    }
    int v18 = *v17;
    uint64_t result = fi_shape_get_input_dim((int *)a1 + 5, (int *)&v71);
    if (result) {
      return result;
    }
    uint64_t v20 = *((unsigned int *)a1 + 3);
    if (v18 == 2)
    {
      uint64_t v28 = a1[9];
      uint64_t v21 = v71;
      uint64_t v22 = **a1;
      if (v28 && (*((unsigned char *)v28 + 4) & 2) != 0)
      {
        int v51 = get_padded_len(*((unsigned int *)a1 + 3), 8u) * v21;
        *a2 = ((3 * (v51 + get_padded_len(v20, 8u) * v20)) << (~(*((_DWORD *)v28 + 1) >> 2) & 2))
            + 24 * *(_DWORD *)v28;
        *a3 = 12 * get_padded_len(v20, 8u);
        get_padded_len(v21, 8u);
        get_padded_len(v20, 8u);
        uint64_t v55 = "basic reset-after GRU impl (rowMajor): x=%u, padded_x=%u, h=%u, padded_h=%u, wBytes=(3 * padded_h * x + 3 "
              "* padded_h * h) * sizeof(f32) + GET_HEADER_LEN(cur_header)*sizeof(s32)*6=%u, bBytes=3 * padded_h * sizeof"
              "(f32)=%u, wBytes+bBytes=%u";
      }
      else
      {
        int padded_len = get_padded_len(v71, 8u);
        int v30 = 3 * v20 * (get_padded_len(v20, 8u) + padded_len);
        LOBYTE(v31) = 2;
        if (v28)
        {
          int v31 = ~(*((_DWORD *)v28 + 1) >> 2) & 2;
          int v32 = 24 * *(_DWORD *)v28;
        }
        else
        {
          int v32 = 0;
        }
        *a2 = (v30 << v31) + v32;
        *a3 = 24 * get_padded_len(v20, 8u);
        get_padded_len(v21, 8u);
        get_padded_len(v20, 8u);
        uint64_t v55 = "basic reset-after GRU impl (colMajor):x=%u, h=%u, padded_x=%u, padded_h=%u,wBytes=(3 * PAD(x) * h + 3 * PA"
              "D(h) * h) * sizeof(f32) + GET_HEADER_LEN(cur_header)*sizeof(s32)*6=%u, bBytes=3*PAD(h)*sizeof(f32)*2=%u, "
              "wBytes+bBytes=%u";
      }
      goto LABEL_49;
    }
    if (v18 != 1)
    {
      if (v18)
      {
        if ((v18 - 3) <= 1) {
          return calc_GRU_IMPL_FAST_RESETAFTER_weights_size(v11, (uint64_t)a1[9], v71, *((unsigned int *)a1 + 3), **a1, a2, a3, v10);
        }
        return 7;
      }
      uint64_t v21 = v71;
      uint64_t v22 = **a1;
      if (is_enabled)
      {
        unsigned int v23 = a1[9];
        if (v23 && (*((unsigned char *)v23 + 4) & 2) != 0)
        {
          int v56 = get_padded_len(*((unsigned int *)a1 + 3), 8u) * v21;
          *a2 = ((3 * (v56 + get_padded_len(v20, 8u) * v20)) << (~(*((_DWORD *)v23 + 1) >> 2) & 2))
              + 24 * *(_DWORD *)v23;
          *a3 = 12 * get_padded_len(v20, 8u);
          get_padded_len(v21, 8u);
          get_padded_len(v20, 8u);
          uint64_t v55 = "basic GRU impl: x=%u, padded_x=%u, h=%u, padded_h=%u, wBytes=4*(3*padded_h*x + 3*padded_h*h)=%u, bBytes="
                "4*3*padded_h=%u, wBytes+bBytes=%u";
LABEL_49:
          log_OutText(v22, (uint64_t)"FastInfer", 4, 0, (uint64_t)v55, v52, v53, v54, v21);
          return 0;
        }
        int v24 = get_padded_len(v71, 8u);
        int v25 = 3 * v20 * (get_padded_len(v20, 8u) + v24);
        LOBYTE(v26) = 2;
        if (v23)
        {
          int v26 = ~(*((_DWORD *)v23 + 1) >> 2) & 2;
          int v27 = 24 * *(_DWORD *)v23;
        }
        else
        {
          int v27 = 0;
        }
        int v50 = (v25 << v26) + v27;
      }
      else
      {
        int v49 = get_padded_len(v71, 8u);
        int v50 = 12 * v20 * (get_padded_len(v20, 8u) + v49);
      }
      *a2 = v50;
      *a3 = 12 * get_padded_len(v20, 8u);
      get_padded_len(v21, 8u);
      get_padded_len(v20, 8u);
      uint64_t v55 = "basic GRU impl: x=%u, padded_x=%u, h=%u, padded_h=%u, wBytes=4*(3*h*padded_x + 3*h*padded_h)=%u, bBytes=4*3*"
            "padded_h=%u, wBytes+bBytes=%u";
      goto LABEL_49;
    }
    float v33 = a1[9];
    uint64_t v34 = v71;
    uint64_t v35 = **a1;
    if (is_enabled && v33)
    {
      uint64_t is_enabled = *((unsigned int *)v33 + 2);
      if (is_enabled)
      {
        if ((*((unsigned char *)v33 + 4) & 8) != 0)
        {
          uint64_t v15 = "Currently not support quantization for block sparse!";
          uint64_t v14 = **a1;
          goto LABEL_9;
        }
        uint64_t mat_length = get_mat_length((int *)a1[9]);
        int v37 = get_padded_len(mat_length, 8u);
        uint64_t v38 = get_mat_length((int *)v33);
        uint64_t v39 = (int *)v33 + get_padded_len(v38, 8u);
        uint64_t v40 = v39[2];
        *a2 = 4 * (get_mat_length(v39) + v37);
        *a3 = 12 * get_padded_len(v20, 8u);
        uint64_t v44 = (v34 + v20);
        goto LABEL_55;
      }
    }
    else
    {
      if (!is_enabled)
      {
        uint64_t v44 = v71 + v20;
        int v59 = get_padded_len(v44, 8u);
        *a2 = 4 * v20 * (get_padded_len(v44, 8u) + 2 * v59);
        int v60 = get_padded_len(v20, 8u);
LABEL_54:
        uint64_t v40 = 0;
        *a3 = 12 * v60;
LABEL_55:
        log_OutText(v35, (uint64_t)"FastInfer", 4, 0, (uint64_t)"hidden : %d\n", v41, v42, v43, v20);
        log_OutText(v35, (uint64_t)"FastInfer", 4, 0, (uint64_t)"get k_1 : %d\n", v61, v62, v63, is_enabled);
        log_OutText(v35, (uint64_t)"FastInfer", 4, 0, (uint64_t)"get k_2 : %d\n", v64, v65, v66, v40);
        get_padded_len(v44, 8u);
        log_OutText(v35, (uint64_t)"FastInfer", 4, 0, (uint64_t)"fast GRU impl: x=%u, h=%u, padded_xh=%u, wBytes=(padded_xh*2h + padded_xh*h)=%u, bBytes=3*h=%u, wBytes+bBytes=%u", v67, v68, v69, v34);
        return 0;
      }
      if (!v33) {
        goto LABEL_37;
      }
    }
    if ((*((unsigned char *)v33 + 4) & 2) != 0)
    {
      uint64_t v44 = v71 + v20;
      int v57 = get_padded_len((2 * v20), 8u);
      unsigned int v58 = (((get_padded_len(v20, 8u) + v57) * v44) << (~(*((_DWORD *)v33 + 1) >> 2) & 2))
          + 8 * *(_DWORD *)v33;
LABEL_53:
      *a2 = v58;
      int v60 = get_padded_len(v20, 8u);
      uint64_t is_enabled = 0;
      goto LABEL_54;
    }
LABEL_37:
    uint64_t v44 = v71 + v20;
    int v45 = get_padded_len(v44, 8u);
    int v46 = (get_padded_len(v44, 8u) + 2 * v45) * v20;
    LOBYTE(v47) = 2;
    if (v33)
    {
      int v47 = ~(*((_DWORD *)v33 + 1) >> 2) & 2;
      int v48 = 8 * *(_DWORD *)v33;
    }
    else
    {
      int v48 = 0;
    }
    unsigned int v58 = (v46 << v47) + v48;
    goto LABEL_53;
  }
  uint64_t v14 = **a1;
  uint64_t v15 = "Model desired row-major weights, which mismatch with provided column-major weights";
LABEL_9:
  log_OutText(v14, (uint64_t)"FastInfer", 0, 0, (uint64_t)v15, v8, v9, v10, v70);
  return 7;
}

uint64_t calc_GRU_IMPL_FAST_RESETAFTER_weights_size(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, _DWORD *a7, uint64_t a8)
{
  if (a1 && a2)
  {
    uint64_t v14 = *(unsigned int *)(a2 + 8);
    if (v14)
    {
      if ((*(unsigned char *)(a2 + 4) & 8) != 0)
      {
        log_OutText(a5, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently not support quantization for block sparse!", (uint64_t)a6, (uint64_t)a7, a8, v50);
        return 7;
      }
      uint64_t mat_length = get_mat_length((int *)a2);
      int padded_len = get_padded_len(mat_length, 8u);
      uint64_t v17 = get_mat_length((int *)a2);
      uint64_t v18 = a2 + 4 * get_padded_len(v17, 8u);
      uint64_t v19 = *(unsigned int *)(v18 + 8);
      *a6 = 4 * (get_mat_length((int *)v18) + padded_len);
      int v20 = get_padded_len(a4, 8u);
      goto LABEL_15;
    }
LABEL_8:
    int v24 = *(_DWORD *)(a2 + 4);
    if ((v24 & 2) != 0)
    {
      uint64_t v28 = (3 * a4);
      if ((v24 & 8) != 0)
      {
        int v35 = get_padded_len(v28, 0x20u) * a3;
        int v30 = v35 + get_padded_len((3 * a4), 0x20u) * a4;
      }
      else
      {
        int v29 = get_padded_len(v28, 8u) * a3;
        int v30 = 4 * (v29 + get_padded_len((3 * a4), 8u) * a4);
      }
      *a6 = v30 + 8 * *(_DWORD *)a2;
      *a7 = 24 * get_padded_len(a4, 8u);
      get_padded_len(a3, 8u);
      get_padded_len(a4, 8u);
      uint64_t v39 = a3;
      uint64_t v40 = "fast resetafter GRU impl(rowMajor): x=%u, h=%u, padded_x=%u, padded_h=%u, wBytes=(x*PAD(3*h) + h*PAD(3*h))*s"
            "izeof(f32) + GET_HEADER_LEN(cur_header)*sizeof(s32)*2 = %u, bBytes=3*PAD(h)*sizeof(f32)*2 = %u, wBytes+bBytes=%u";
      goto LABEL_23;
    }
    if ((v24 & 8) != 0)
    {
      int v33 = get_padded_len(a3, 0x20u);
      int v34 = 3 * a4 * (get_padded_len(a4, 0x20u) + v33) + 8 * *(_DWORD *)a2;
LABEL_22:
      *a6 = v34;
      *a7 = 24 * get_padded_len(a4, 8u);
      get_padded_len(a3, 8u);
      get_padded_len(a4, 8u);
      uint64_t v39 = a3;
      uint64_t v40 = "fast resetafter GRU impl(colMajor): x=%u, h=%u, padded_x=%u, padded_h=%u, wBytes=(PAD(x) * (3*h) + PAD(h) * "
            "(3*h)) * sizeof(f32) + GET_HEADER_LEN(cur_header)*sizeof(s32)*2 = %u, bBytes=3*PAD(h)*sizeof(f32)*2 = %u, wBytes+bBytes=%u";
LABEL_23:
      log_OutText(a5, (uint64_t)"FastInfer", 4, 0, (uint64_t)v40, v36, v37, v38, v39);
      uint64_t v14 = 0;
      uint64_t v19 = 0;
      goto LABEL_24;
    }
LABEL_10:
    int v25 = get_padded_len(a3, 8u);
    int v26 = 12 * a4 * (get_padded_len(a4, 8u) + v25);
    if (a2) {
      int v27 = 8 * *(_DWORD *)a2;
    }
    else {
      int v27 = 0;
    }
    int v34 = v27 + v26;
    goto LABEL_22;
  }
  if (a1)
  {
    if (!a2) {
      goto LABEL_10;
    }
    goto LABEL_8;
  }
  int v31 = get_padded_len(a3, 8u);
  *a6 = 12 * a4 * (get_padded_len(a4, 8u) + v31);
  int v20 = get_padded_len(a4, 8u);
  uint64_t v14 = 0;
  uint64_t v19 = 0;
LABEL_15:
  *a7 = 24 * v20;
LABEL_24:
  log_OutText(a5, (uint64_t)"FastInfer", 4, 0, (uint64_t)"hidden : %d\n", v21, v22, v23, a4);
  log_OutText(a5, (uint64_t)"FastInfer", 4, 0, (uint64_t)"get k_1 : %d\n", v41, v42, v43, v14);
  log_OutText(a5, (uint64_t)"FastInfer", 4, 0, (uint64_t)"get k_2 : %d\n", v44, v45, v46, v19);
  get_padded_len(a3, 8u);
  get_padded_len(a4, 8u);
  log_OutText(a5, (uint64_t)"FastInfer", 4, 0, (uint64_t)"fast GRU impl: x=%u, h=%u, padded_x=%u, padded_h=%u,wBytes=(padded_x*3h + padded_h*3h)=%u, bBytes=3*padded_h*2=%u, wBytes+bBytes=%u", v47, v48, v49, a3);
  return 0;
}

uint64_t get_gru_glbBufBytes(int a1, uint64_t a2, int a3, uint64_t a4, _DWORD *a5)
{
  int padded_len = get_padded_len(a2, 8u);
  int v10 = get_padded_len(a4, 8u);
  if ((a1 & 0xFFFFFFFD) != 0)
  {
    switch(a1)
    {
      case 4:
        int v12 = get_padded_len((3 * a4), 8u);
        int padded_len = v12 + v12 * a3;
        int v10 = get_padded_len(a4, 8u);
        break;
      case 3:
        int v13 = padded_len + 2 * get_padded_len((3 * a4), 8u);
        int padded_len = 3 * get_padded_len(a4, 8u);
        goto LABEL_8;
      case 1:
        break;
      default:
        return 7;
    }
  }
  int v13 = 3 * v10;
LABEL_8:
  uint64_t result = 0;
  *a5 = 4 * (v13 + padded_len);
  return result;
}

uint64_t create_gru_layer(uint64_t *a1, uint64_t a2, long long *a3, uint64_t **a4, uint64_t a5, uint64_t ***a6)
{
  int v12 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  uint64_t v16 = v12;
  if (!v12) {
    goto LABEL_9;
  }
  *int v12 = a1;
  uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16);
  if (!v17) {
    goto LABEL_9;
  }
  uint64_t v18 = (uint64_t *)v17;
  uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 20);
  if (!v19) {
    goto LABEL_9;
  }
  uint64_t v20 = v19;
  long long v21 = *a3;
  *(_DWORD *)(v19 + 16) = *((_DWORD *)a3 + 4);
  *(_OWORD *)uint64_t v19 = v21;
  uint64_t v22 = *(uint64_t **)a2;
  *((_DWORD *)v16 + 4) = *(_DWORD *)(a2 + 8);
  v16[1] = v22;
  uint64_t v23 = *(unsigned int *)(a2 + 4);
  if (a4) {
    *(uint64_t **)((char *)v16 + 60) = *a4;
  }
  uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v23, 4);
  *uint64_t v18 = v24;
  if (v24)
  {
    v18[1] = v20;
    v16[20] = (uint64_t *)gru_layer_request_glbBuf;
    v16[15] = v18;
    v16[16] = (uint64_t *)forward_gru_layer;
    v16[17] = (uint64_t *)free_gru_buffer;
    if (a5)
    {
      int v25 = *(uint64_t **)(a5 + 24);
      int v26 = *(_DWORD *)(a5 + 16);
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, use v0.0.0", v13, v14, v15, v28);
      int v25 = 0;
      int v26 = 0;
    }
    uint64_t result = 0;
    _OWORD v16[32] = v25;
    *((_DWORD *)v16 + 66) = v26;
    v16[18] = (uint64_t *)gru_layer_update_shape;
    v16[19] = (uint64_t *)gru_layer_wanted_wb_len;
    v16[22] = (uint64_t *)gru_layer_reset;
  }
  else
  {
LABEL_9:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v13, v14, v15, v28);
    free_gru_buffer(v16);
    uint64_t result = 10;
  }
  *a6 = v16;
  return result;
}

uint64_t gru_layer_request_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 12);
  unsigned int v8 = 0;
  uint64_t v3 = (_DWORD *)(a1 + 20);
  uint64_t result = fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v8);
  if (!result)
  {
    int step = fi_shape_get_step(v3);
    uint64_t v6 = *(void *)(a1 + 120);
    if (v6 && (BOOL v7 = *(int **)(v6 + 8)) != 0) {
      return get_gru_glbBufBytes(*v7, v8, step, v2, (_DWORD *)(a1 + 248));
    }
    else {
      return 7;
    }
  }
  return result;
}

uint64_t forward_gru_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *(uint64_t **)a2;
  uint64_t v6 = *(void **)(a2 + 240);
  uint64_t v7 = *(void *)(*(void *)(a2 + 120) + 8);
  uint64_t v37 = **(void ***)(a2 + 120);
  int v34 = *(_DWORD *)(v7 + 12);
  BOOL is_enabled = fi_feat_is_enabled(*(void *)(a2 + 256), 7u, *(_DWORD *)(a2 + 264));
  unsigned int v38 = 0;
  if (!v6)
  {
    log_OutText(*v5, (uint64_t)"FastInfer", 0, 0, (uint64_t)"gru buf is NULL, do you forget to set pNet->glbBuf?", v9, v10, v11, v29);
    return 7;
  }
  uint64_t v12 = *(unsigned int *)(a2 + 12);
  uint64_t v13 = *(void *)(a2 + 72);
  if (is_enabled && v13 && (*(unsigned char *)(v13 + 4) & 8) != 0) {
    uint64_t v14 = *(unsigned int *)(a2 + 96);
  }
  else {
    uint64_t v14 = *(_DWORD *)(a2 + 96) & 0xFFFFFFFC;
  }
  uint64_t v33 = v13 + v14;
  int v31 = v5;
  if (!*(_DWORD *)(v7 + 16)) {
    bzero(v37, 4 * v12);
  }
  int step = fi_shape_get_step((_DWORD *)(a2 + 20));
  uint64_t input_dim = fi_shape_get_input_dim((int *)(a2 + 20), (int *)&v38);
  if (input_dim) {
    return input_dim;
  }
  uint64_t v18 = *(void *)(a2 + 120);
  if (!v18) {
    return 7;
  }
  uint64_t v19 = *(unsigned int **)(v18 + 8);
  if (!v19) {
    return 7;
  }
  if (!step) {
    return 0;
  }
  int v20 = 0;
  int v21 = 0;
  unsigned int v32 = *v19;
  while (1)
  {
    uint64_t v22 = v38;
    uint64_t v23 = a3 + 4 * v38 * v21;
    unsigned int v24 = v34 == 1 ? v20 : 0;
    uint64_t v25 = a4 + 4 * v24;
    bzero(v6, *(unsigned int *)(a2 + 248));
    uint64_t input_dim = gru_step_f32((uint64_t **)a2, v32, v23, v25, v22, v12, (uint64_t)v6, v13, v33, (uint64_t)v37);
    if (input_dim) {
      break;
    }
    ++v21;
    v20 += v12;
    if (step == v21) {
      return input_dim;
    }
  }
  log_OutText(*v31, (uint64_t)"FastInfer", 0, 0, (uint64_t)"gru step forward failed!", v26, v27, v28, v30);
  return input_dim;
}

void *free_gru_buffer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    uint64_t v3 = (void *)result[15];
    if (v3)
    {
      if (v3[1]) {
        (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
      }
      if (*v3)
      {
        (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        *uint64_t v3 = 0;
      }
      (*(void (**)(void, void *))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      v1[15] = 0;
    }
    uint64_t v4 = *(void *)(v2 + 16);
    uint64_t v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
    return (void *)v5(v4, v1);
  }
  return result;
}

uint64_t gru_layer_update_shape(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(*(void *)(*(void *)(a1 + 120) + 8) + 12);
  int v3 = *(_DWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v3;
  if (v2 == 1)
  {
    *(_DWORD *)(a1 + 40) = 2;
    int v4 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a1 + 48) = v4;
  }
  else
  {
    int v5 = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = v5;
  }
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 16);
  return 0;
}

uint64_t gru_layer_reset(uint64_t a1)
{
  return 0;
}

uint64_t realign_inData(uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (a2 < 2) {
    return 0;
  }
  if (get_padded_len(a3, 8u) == a3) {
    return 0;
  }
  uint64_t v11 = a1[2];
  uint64_t v12 = *(uint64_t (**)(uint64_t, void, uint64_t))(a1[1] + 16);
  int padded_len = get_padded_len(a3, 8u);
  uint64_t v14 = v12(v11, padded_len * a2, 4);
  *a4 = v14;
  if (v14)
  {
    unsigned int v18 = 0;
    uint64_t v19 = 0;
    do
    {
      uint64_t v20 = *a4;
      int v21 = get_padded_len(a3, 8u);
      memcpy((void *)(v20 + 4 * (v21 * v19++)), (const void *)(a5 + 4 * v18), 4 * a3);
      v18 += a3;
    }
    while (a2 != v19);
    return 0;
  }
  log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v15, v16, v17, v5);
  return 10;
}

uint64_t gru_step_f32(uint64_t **a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10 = *a1;
  if (a2 > 4)
  {
    uint64_t v11 = 7;
    uint64_t v12 = "get lstm step forward function failed!";
    goto LABEL_5;
  }
  uint64_t v14 = a10;
  uint64_t v11 = ((uint64_t (*)(void))off_26C21F8A0[a2])();
  if (v11)
  {
    uint64_t v12 = "gru step forward failed!";
LABEL_5:
    log_OutText(*v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)v12, a6, a7, a8, v14);
  }
  return v11;
}

uint64_t gru_step_f32_basic(uint64_t a1, const void *a2, void *a3, uint64_t a4, uint64_t a5, float32x4_t *a6, int *a7, float *a8, float *a9, int a10, int a11, int a12)
{
  uint64_t v68 = *(uint64_t **)a1;
  int padded_len = get_padded_len(a4, 8u);
  unsigned int v19 = get_padded_len(a5, 8u);
  BOOL is_enabled = fi_feat_is_enabled(*(void *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  BOOL v21 = (*(_DWORD *)(a1 + 16) & 0xFFFFFFFD) == 1;
  memset(v76, 0, 32);
  memset(v75, 0, sizeof(v75));
  memset(v74, 0, sizeof(v74));
  memset(v73, 0, sizeof(v73));
  memset(v72, 0, sizeof(v72));
  memset(v71, 0, sizeof(v71));
  char __dst = a3;
  if (is_enabled)
  {
    if (a7)
    {
      uint64_t v23 = *a7;
      unsigned int v22 = a7[1];
      DWORD1(v76[0]) = v21;
      DWORD2(v76[0]) = ((v22 >> 1) & 1) == 0;
      LODWORD(v76[0]) = v22 & 1;
      unsigned int v24 = &a7[v23];
      uint64_t mat_length = get_mat_length(a7);
      uint64_t v26 = &a7[get_padded_len(mat_length, 8u)];
      uint64_t v28 = *v26;
      unsigned int v27 = v26[1];
      DWORD1(v75[0]) = v21;
      DWORD2(v75[0]) = ((v27 >> 1) & 1) == 0;
      LODWORD(v75[0]) = v27 & 1;
      uint64_t v64 = (uint64_t)&v26[v28];
      uint64_t v29 = get_mat_length(v26);
      uint64_t v30 = &v26[get_padded_len(v29, 8u)];
      uint64_t v32 = *v30;
      unsigned int v31 = v30[1];
      DWORD1(v74[0]) = v21;
      DWORD2(v74[0]) = ((v31 >> 1) & 1) == 0;
      LODWORD(v74[0]) = v31 & 1;
      uint64_t v65 = (uint64_t)&v30[v32];
      uint64_t v33 = get_mat_length(v30);
      int v34 = &v30[get_padded_len(v33, 8u)];
      uint64_t v36 = *v34;
      unsigned int v35 = v34[1];
      DWORD1(v73[0]) = v21;
      DWORD2(v73[0]) = ((v35 >> 1) & 1) == 0;
      LODWORD(v73[0]) = v35 & 1;
      uint64_t v59 = (uint64_t)&v34[v36];
      uint64_t v37 = get_mat_length(v34);
      unsigned int v38 = &v34[get_padded_len(v37, 8u)];
      uint64_t v40 = *v38;
      unsigned int v39 = v38[1];
      DWORD1(v72[0]) = v21;
      DWORD2(v72[0]) = ((v39 >> 1) & 1) == 0;
      LODWORD(v72[0]) = v39 & 1;
      uint64_t v60 = (uint64_t)&v38[v40];
      uint64_t v41 = get_mat_length(v38);
      uint64_t v42 = &v38[get_padded_len(v41, 8u)];
      uint64_t v44 = *v42;
      unsigned int v43 = v42[1];
      DWORD1(v71[0]) = v21;
      DWORD2(v71[0]) = ((v43 >> 1) & 1) == 0;
      uint64_t v63 = (uint64_t)&v42[v44];
      uint64_t v45 = v76;
      int v56 = v73;
      int v57 = v75;
      LODWORD(v71[0]) = v43 & 1;
      unsigned int v58 = v72;
      uint64_t v61 = v74;
      uint64_t v62 = v71;
      a7 = v24;
    }
    else
    {
      a7 = 0;
      uint64_t v64 = 0;
      uint64_t v65 = 0;
      uint64_t v59 = 0;
      uint64_t v60 = 0;
      uint64_t v63 = 0;
      *(void *)((char *)v76 + 4) = v21 | 0x100000000;
      LODWORD(v76[0]) = 0;
      *(void *)((char *)v75 + 4) = *(void *)((char *)v76 + 4);
      LODWORD(v75[0]) = 0;
      *(void *)((char *)v74 + 4) = *(void *)((char *)v76 + 4);
      LODWORD(v74[0]) = 0;
      *(void *)((char *)v73 + 4) = *(void *)((char *)v76 + 4);
      LODWORD(v73[0]) = 0;
      *(void *)((char *)v72 + 4) = *(void *)((char *)v76 + 4);
      uint64_t v45 = v76;
      LODWORD(v72[0]) = 0;
      int v56 = v73;
      int v57 = v75;
      unsigned int v58 = v72;
      *(void *)((char *)v71 + 4) = *(void *)((char *)v76 + 4);
      uint64_t v61 = v74;
      uint64_t v62 = v71;
    }
  }
  else
  {
    uint64_t v61 = 0;
    uint64_t v62 = 0;
    int v57 = 0;
    unsigned int v58 = 0;
    int v56 = 0;
    uint64_t v45 = 0;
    uint64_t v64 = (uint64_t)&a7[(padded_len * a5)];
    uint64_t v65 = v64 + 4 * (padded_len * a5);
    uint64_t v59 = v65 + 4 * (padded_len * a5);
    uint64_t v60 = v59 + 4 * v19 * a5;
    uint64_t v63 = v60 + 4 * v19 * a5;
  }
  uint64_t v46 = (float32x4_t *)((char *)a6 + 4 * v19);
  uint64_t v47 = (float32x4_t *)((char *)v46 + 4 * v19);
  uint64_t v48 = &v47->f32[v19];
  uint64_t v66 = &a8[v19];
  memcpy(v48, a2, 4 * a4);
  bzero(a6, 4 * a5);
  gemm(v68, 1, a5, a4, (uint64_t)v48, (uint64_t)a7, a6, v45, v50);
  bzero(v46, 4 * a5);
  gemm(v68, 1, a5, a5, (uint64_t)a9, v59, v46, v56, v51);
  axpy(a5, a6->f32, 1, v46->f32, 1, 1.0);
  axpy(a5, a8, 1, v46->f32, 1, 1.0);
  fi_activate_array(v46->f32, a5, a12);
  bzero(a6, 4 * a5);
  gemm(v68, 1, a5, a4, (uint64_t)v48, v64, a6, v57, v52);
  bzero(v47, 4 * a5);
  gemm(v68, 1, a5, a5, (uint64_t)a9, v60, v47, v58, v53);
  axpy(a5, a6->f32, 1, v47->f32, 1, 1.0);
  axpy(a5, v66, 1, v47->f32, 1, 1.0);
  fi_activate_array(v47->f32, a5, a12);
  xmy(a5, a9, 1, v47->f32, 1);
  bzero(a6, 4 * a5);
  gemm(v68, 1, a5, a5, (uint64_t)v47, v63, a6, v61, v54);
  bzero(v47, 4 * a5);
  gemm(v68, 1, a5, a4, (uint64_t)v48, v65, v47, v62, v55);
  axpy(a5, a6->f32, 1, v47->f32, 1, 1.0);
  axpy(a5, &v66[v19], 1, v47->f32, 1, 1.0);
  fi_activate_array(v47->f32, a5, a11);
  fill_array_f32(a6->f32, a5, 1.0);
  axpy(a5, v46->f32, 1, a6->f32, 1, -1.0);
  xmy(a5, a6->f32, 1, v47->f32, 1);
  xmy(a5, a9, 1, v46->f32, 1);
  axpy(a5, v47->f32, 1, v46->f32, 1, 1.0);
  memcpy(a9, v46, 4 * a5);
  memcpy(__dst, v46, 4 * a5);
  return 0;
}

uint64_t gru_step_f32_fast(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5, char *a6, int *a7, char *a8, void *a9, int a10, int a11, int a12)
{
  unsigned int v14 = a4;
  unsigned int v18 = *(uint64_t **)a1;
  int padded_len = get_padded_len(a4, 8u);
  int v19 = get_padded_len(a5, 8u);
  uint64_t v20 = a5 + v14;
  int v21 = get_padded_len(v20, 8u);
  uint64_t v68 = 0;
  v69[0] = 0;
  BOOL is_enabled = fi_feat_is_enabled(*(void *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  memset(v67, 0, sizeof(v67));
  memset(v66, 0, sizeof(v66));
  uint64_t v64 = v18;
  if (!is_enabled)
  {
    unsigned int v58 = 2 * a5;
    unsigned int v59 = v20;
    unsigned int __src = a2;
    int v57 = 0;
    uint64_t v60 = a3;
    uint64_t v53 = 0;
    uint64_t v54 = &a7[(2 * a5 * v21)];
LABEL_11:
    BOOL v55 = 1;
    uint64_t v38 = a5;
    goto LABEL_12;
  }
  if (!a7)
  {
    unsigned int v58 = 2 * a5;
    unsigned int v59 = v20;
    unsigned int __src = a2;
    uint64_t v60 = a3;
    uint64_t v29 = 0;
    int v30 = 0;
    unsigned int v31 = 0;
    BOOL v32 = 1;
    unsigned int v33 = *(_DWORD *)(a1 + 16) & 0xFFFFFFFD;
    LODWORD(v67[0]) = 0;
    DWORD1(v67[0]) = v33 == 1;
    DWORD2(v67[0]) = 1;
LABEL_10:
    a7 = v29;
    DWORD2(v66[0]) = v32;
    LODWORD(v66[0]) = v30;
    DWORD1(v66[0]) = v33 == 1;
    uint64_t v53 = v67;
    uint64_t v54 = (int *)v31;
    int v57 = v66;
    goto LABEL_11;
  }
  int v23 = a7[2];
  if (!v23)
  {
    unsigned int v58 = 2 * a5;
    unsigned int v59 = v20;
    unsigned int __src = a2;
    uint64_t v60 = a3;
    unsigned int v34 = a7[1];
    uint64_t v29 = &a7[*a7];
    *(void *)&v67[0] = __PAIR64__((*(_DWORD *)(a1 + 16) & 0xFFFFFFFD) == 1, v34 & 1);
    DWORD2(v67[0]) = ((v34 >> 1) & 1) == 0;
    uint64_t mat_length = get_mat_length(a7);
    uint64_t v36 = &a7[get_padded_len(mat_length, 8u)];
    unsigned int v37 = v36[1];
    unsigned int v31 = (unsigned int *)&v36[*v36];
    int v30 = v37 & 1;
    BOOL v32 = ((v37 >> 1) & 1) == 0;
    unsigned int v33 = *(_DWORD *)(a1 + 16) & 0xFFFFFFFD;
    goto LABEL_10;
  }
  uint64_t v24 = (2 * a5);
  uint64_t v61 = a5;
  unsigned int v25 = a7[1];
  DWORD2(v67[0]) = ((v25 >> 1) & 1) == 0;
  *(void *)&v67[0] = v25 & 1;
  uint64_t v26 = get_padded_len(v20, 8u);
  uint64_t v27 = (uint64_t)&a7[*a7];
  if ((v25 & 2) != 0)
  {
    uint64_t result = pack_bsr_data((uint64_t)v64, v23, v26, v24, v27, v69);
    if (result) {
      return result;
    }
  }
  else
  {
    uint64_t result = pack_bsc_data((uint64_t)v64, v23, v26, v24, v27, v69);
    if (result) {
      return result;
    }
  }
  uint64_t v45 = get_mat_length(a7);
  uint64_t v46 = &a7[get_padded_len(v45, 8u)];
  unsigned int v47 = v46[1];
  int v48 = v46[2];
  DWORD2(v66[0]) = ((v47 >> 1) & 1) == 0;
  *(void *)&v66[0] = v47 & 1;
  uint64_t v49 = get_padded_len(v20, 8u);
  uint64_t v50 = (uint64_t)&v46[*v46];
  if ((v25 & 2) != 0)
  {
    uint64_t result = pack_bsr_data((uint64_t)v64, v48, v49, v61, v50, &v68);
    if (result) {
      return result;
    }
  }
  else
  {
    uint64_t result = pack_bsc_data((uint64_t)v64, v48, v49, v61, v50, &v68);
    if (result) {
      return result;
    }
  }
  unsigned int v58 = v24;
  unsigned int v59 = v20;
  uint64_t v60 = a3;
  a7 = (int *)v69[0];
  BOOL v55 = v48 == 0;
  uint64_t v53 = v67;
  uint64_t v54 = 0;
  unsigned int __src = a2;
  int v57 = v66;
  uint64_t v38 = v61;
LABEL_12:
  unsigned int v39 = &a8[4 * v19];
  uint64_t v40 = &a6[4 * padded_len];
  uint64_t v41 = (float32x4_t *)&v40[4 * v19];
  uint64_t v42 = &a6[4 * v14];
  memcpy(a6, __src, 4 * v14);
  memcpy(v42, a9, 4 * v38);
  memcpy(v41, a8, 4 * v38);
  memcpy(&v41->f32[v38], v39, 4 * v38);
  gemm(v64, 1, v58, v59, (uint64_t)a6, (uint64_t)a7, v41, v53, v51);
  fi_activate_array(v41->f32, v58, a12);
  memmove(v40, v42, 4 * v38);
  unsigned int v43 = &v41->f32[v19];
  memmove(v43, &v41->f32[v38], 4 * v38);
  xmy(v38, v41->f32, 1, (float *)v40, 1);
  memmove(v42, v40, 4 * v38);
  memcpy(v41, &v39[4 * v19], 4 * v38);
  if (v55) {
    uint64_t v44 = (uint64_t)v54;
  }
  else {
    uint64_t v44 = v68;
  }
  gemm(v64, 1, v38, v59, (uint64_t)a6, v44, v41, v57, v52);
  fi_activate_array(v41->f32, v38, a11);
  fill_array_f32((float *)a6, v38, 1.0);
  axpy(v38, v43, 1, (float *)a6, 1, -1.0);
  xmy(v38, (float *)a6, 1, v41->f32, 1);
  xmy(v38, (float *)a9, 1, v43, 1);
  axpy(v38, v41->f32, 1, v43, 1, 1.0);
  memcpy(a9, v43, 4 * v38);
  memcpy(v60, v43, 4 * v38);
  if (v69[0])
  {
    (*(void (**)(uint64_t))(v64[1] + 80))(v64[2]);
    v69[0] = 0;
  }
  if (v68) {
    (*(void (**)(uint64_t))(v64[1] + 80))(v64[2]);
  }
  return 0;
}

uint64_t gru_step_f32_basic_resetafter(uint64_t a1, const void *a2, void *a3, uint64_t a4, uint64_t a5, float32x4_t *a6, int *a7, float *a8, float *a9, int a10, int a11, int a12)
{
  uint64_t v52 = *(uint64_t **)a1;
  int padded_len = get_padded_len(a4, 8u);
  unsigned int v19 = get_padded_len(a5, 8u);
  uint64_t v53 = a4;
  if (fi_feat_is_enabled(*(void *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264)))
  {
    if (a7)
    {
      uint64_t v20 = &a7[*a7];
      uint64_t mat_length = get_mat_length(a7);
      unsigned int v22 = &a7[get_padded_len(mat_length, 8u)];
      uint64_t v44 = (uint64_t)&v22[*v22];
      uint64_t v23 = get_mat_length(v22);
      uint64_t v24 = &v22[get_padded_len(v23, 8u)];
      uint64_t v45 = (uint64_t)&v24[*v24];
      uint64_t v25 = get_mat_length(v24);
      uint64_t v26 = &v24[get_padded_len(v25, 8u)];
      uint64_t v36 = (uint64_t)&v26[*v26];
      uint64_t v27 = get_mat_length(v26);
      uint64_t v28 = &v26[get_padded_len(v27, 8u)];
      uint64_t v42 = (uint64_t)&v28[*v28];
      uint64_t v29 = get_mat_length(v28);
      int v30 = get_padded_len(v29, 8u);
      uint64_t v43 = (uint64_t)&v28[v30 + v28[v30]];
      a7 = v20;
    }
    else
    {
      uint64_t v44 = 0;
      uint64_t v45 = 0;
      uint64_t v36 = 0;
      uint64_t v42 = 0;
      uint64_t v43 = 0;
    }
  }
  else
  {
    uint64_t v44 = (uint64_t)&a7[(padded_len * a5)];
    uint64_t v45 = v44 + 4 * (padded_len * a5);
    uint64_t v36 = v45 + 4 * (padded_len * a5);
    uint64_t v42 = v36 + 4 * v19 * a5;
    uint64_t v43 = v42 + 4 * v19 * a5;
  }
  unsigned int v31 = a2;
  BOOL v32 = (float32x4_t *)((char *)a6 + 4 * v19);
  unsigned int v33 = (float32x4_t *)((char *)v32 + 4 * v19);
  unsigned int v34 = &v33->f32[v19];
  unsigned int v47 = &a8[v19];
  uint64_t v50 = &v47[v19];
  uint64_t v46 = &v50[v19];
  int v48 = &v46[v19];
  memcpy(v34, v31, 4 * v53);
  bzero(a6, 4 * a5);
  gemm(v52, 1, a5, v53, (uint64_t)v34, (uint64_t)a7, a6, 0, v36);
  bzero(v32, 4 * a5);
  gemm(v52, 1, a5, a5, (uint64_t)a9, v37, v32, 0, v37);
  axpy(a5, a6->f32, 1, v32->f32, 1, 1.0);
  axpy(a5, a8, 1, v32->f32, 1, 1.0);
  axpy(a5, v46, 1, v32->f32, 1, 1.0);
  fi_activate_array(v32->f32, a5, a12);
  bzero(a6, 4 * a5);
  gemm(v52, 1, a5, v53, (uint64_t)v34, v44, a6, 0, v38);
  bzero(v33, 4 * a5);
  gemm(v52, 1, a5, a5, (uint64_t)a9, v42, v33, 0, v39);
  axpy(a5, a6->f32, 1, v33->f32, 1, 1.0);
  axpy(a5, v47, 1, v33->f32, 1, 1.0);
  axpy(a5, v48, 1, v33->f32, 1, 1.0);
  fi_activate_array(v33->f32, a5, a12);
  bzero(a6, 4 * a5);
  gemm(v52, 1, a5, a5, (uint64_t)a9, v43, a6, 0, v40);
  xmy(a5, a6->f32, 1, v33->f32, 1);
  axpy(a5, &v48[v19], 1, v33->f32, 1, 1.0);
  bzero(a6, 4 * a5);
  gemm(v52, 1, a5, v53, (uint64_t)v34, v45, a6, 0, v41);
  axpy(a5, a6->f32, 1, v33->f32, 1, 1.0);
  axpy(a5, v50, 1, v33->f32, 1, 1.0);
  fi_activate_array(v33->f32, a5, a11);
  fill_array_f32(a6->f32, a5, 1.0);
  axpy(a5, v32->f32, 1, a6->f32, 1, -1.0);
  xmy(a5, a6->f32, 1, v33->f32, 1);
  xmy(a5, a9, 1, v32->f32, 1);
  axpy(a5, v33->f32, 1, v32->f32, 1, 1.0);
  memcpy(a9, v32, 4 * a5);
  memcpy(a3, v32, 4 * a5);
  return 0;
}

uint64_t gru_step_f32_fast_resetafter(uint64_t a1, const void *a2, float *a3, uint64_t a4, uint64_t a5, char *a6, int *a7, char *a8, uint64_t a9, int a10, int a11, int a12)
{
  uint64_t v112 = *(uint64_t **)a1;
  unsigned int padded_len = get_padded_len(a4, 8u);
  int v17 = get_padded_len(a5, 8u);
  uint64_t v18 = a2 & 0x1F;
  uint64_t v118 = 0;
  v119[0] = 0;
  BOOL is_enabled = fi_feat_is_enabled(*(void *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  BOOL v20 = fi_feat_is_enabled(*(void *)(a1 + 256), 7u, *(_DWORD *)(a1 + 264));
  int v100 = get_padded_len(a4, 8u);
  unsigned int v99 = get_padded_len((3 * a5), 8u);
  uint64_t __src = (3 * a5);
  int v21 = a2;
  int v104 = get_padded_len(__src, 8u);
  int v22 = get_padded_len(a5, 8u);
  int v98 = get_padded_len(a5, 8u);
  long long v116 = 0u;
  long long v117 = 0u;
  long long v114 = 0u;
  long long v115 = 0u;
  uint64_t v106 = v18;
  if (v18) {
    memcpy(a6, v21, 4 * a4);
  }
  uint64_t v110 = (uint64_t)a6;
  BOOL v111 = is_enabled || v20;
  if (!is_enabled && !v20)
  {
    int v95 = v22;
    uint64_t v96 = (uint64_t)v21;
    uint64_t v97 = a4;
    int v93 = 0;
    BOOL v32 = a8;
    unsigned int v94 = (unsigned int *)&a7[padded_len * __src];
    int v33 = 1;
    unsigned int v102 = (unsigned int *)a7;
LABEL_10:
    unsigned int v34 = a6;
    unsigned int v36 = v99;
    int v35 = v100;
LABEL_11:
    uint64_t v37 = &v32[4 * v17];
    uint64_t v38 = (float32x4_t *)&v34[4 * v35];
    uint64_t v39 = (float32x4_t *)((char *)v38 + 4 * v36);
    uint64_t v40 = &v37[4 * v17 + 4 * v17];
    unsigned int v41 = 2 * a5;
    __dsta = &v39->f32[v104];
    if (v17 == a5)
    {
      uint64_t v42 = (3 * a5);
      size_t v43 = 4 * v42;
      uint64_t v44 = (float32_t *)&v34[4 * v35];
    }
    else
    {
      memcpy(v38, v32, 4 * a5);
      memcpy(&v38->f32[a5], v37, 4 * a5);
      uint64_t v44 = &v38->f32[v41];
      BOOL v32 = &v37[4 * v17];
      size_t v43 = 4 * a5;
      uint64_t v42 = (3 * a5);
    }
    memcpy(v44, v32, v43);
    unint64_t v105 = &__dsta[v95];
    if (v33) {
      uint64_t v45 = (uint64_t)v102;
    }
    else {
      uint64_t v45 = v119[0];
    }
    if (v111) {
      uint64_t v46 = &v116;
    }
    else {
      uint64_t v46 = 0;
    }
    if (v106) {
      uint64_t v47 = v110;
    }
    else {
      uint64_t v47 = v96;
    }
    uint64_t v26 = v112;
    gemm(v112, 1, v42, v97, v47, v45, v38, v46, v91);
    if (v17 == a5)
    {
      memcpy(v39, v40, 4 * v42);
      uint64_t v48 = v42;
      int v49 = v17;
    }
    else
    {
      int v49 = v17;
      uint64_t v50 = &v40[4 * v17];
      memcpy(v39, v40, 4 * a5);
      memcpy(&v39->f32[a5], v50, 4 * a5);
      uint64_t v26 = v112;
      uint64_t v48 = (3 * a5);
      memcpy(&v39->f32[v41], &v50[4 * v49], 4 * a5);
    }
    if (v93) {
      uint64_t v51 = v118;
    }
    else {
      uint64_t v51 = (uint64_t)v94;
    }
    if (v111) {
      uint64_t v52 = &v114;
    }
    else {
      uint64_t v52 = 0;
    }
    gemm(v26, 1, v48, a5, a9, v51, v39, v52, v92);
    axpy((2 * a5), v38->f32, 1, v39->f32, 1, 1.0);
    fi_activate_array(v39->f32, (2 * a5), a12);
    uint64_t v53 = v41;
    uint64_t v54 = &v39->f32[v41];
    if (v49 == a5)
    {
      xmy(a5, v39->f32, 1, &v39->f32[v41], 1);
      axpy(a5, &v38->f32[v41], 1, &v39->f32[v41], 1, 1.0);
      fi_activate_array(&v39->f32[v41], a5, a11);
      fill_array_f32(v105, a5, 1.0);
      size_t v55 = 4 * a5;
      axpy(a5, &v39->f32[v55 / 4], 1, v105, 1, -1.0);
      int v56 = (void *)a9;
      int v57 = (float *)a9;
      unsigned int v58 = &v39->f32[v55 / 4];
      unsigned int v59 = &__dsta[v95];
      uint64_t v60 = v54;
    }
    else
    {
      uint64_t v61 = &v105[v98];
      size_t v55 = 4 * a5;
      memcpy(__dsta, v54, v55);
      xmy(a5, v39->f32, 1, __dsta, 1);
      memcpy(v105, &v38->f32[v53], v55);
      axpy(a5, v105, 1, __dsta, 1, 1.0);
      fi_activate_array(__dsta, a5, a11);
      memcpy(v61, (char *)v39 + v55, v55);
      fill_array_f32(v105, a5, 1.0);
      axpy(a5, v61, 1, v105, 1, -1.0);
      int v56 = (void *)a9;
      int v57 = (float *)a9;
      unsigned int v58 = v61;
      unsigned int v59 = &__dsta[v95];
      uint64_t v60 = __dsta;
    }
    fi_multiply_multiply_add_ansic(v57, v58, v59, v60, a3, a5);
    memcpy(v56, a3, v55);
    uint64_t v62 = 0;
    uint64_t v63 = 0;
    uint64_t v64 = (_DWORD *)*((void *)&v117 + 1);
    if (*((void *)&v117 + 1)) {
      goto LABEL_36;
    }
    goto LABEL_37;
  }
  uint64_t v26 = v112;
  if (!a7)
  {
    unsigned int v102 = 0;
    int v66 = 0;
    *(void *)&long long v116 = 0;
    DWORD2(v116) = 1;
    LODWORD(v117) = 0;
LABEL_46:
    DWORD1(v117) = v66 ^ 1;
    uint64_t v68 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v112[1] + 64))(v112[2], 2, 4);
    *((void *)&v117 + 1) = v68;
    if (!v68)
    {
      log_OutText(*v112, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v69, v70, v71, v91);
      uint64_t v63 = 10;
      goto LABEL_37;
    }
    uint64_t v64 = v68;
    if (a7)
    {
      *uint64_t v68 = a7[7];
      v68[1] = a7[8];
      int v72 = v17;
      if ((a7[1] & 8) != 0)
      {
        uint64_t v77 = *a7;
        uint64_t v74 = (unsigned int *)((char *)&a7[v77] + get_weight_length(a7));
      }
      else
      {
        uint64_t mat_length = get_mat_length(a7);
        uint64_t v74 = (unsigned int *)&a7[get_padded_len(mat_length, 8u)];
      }
      unsigned int v78 = v74[1];
      uint64_t v75 = &v74[*v74];
      *(void *)&long long v114 = v78 & 1;
      DWORD2(v114) = ((v78 >> 1) & 1) == 0;
      LODWORD(v115) = (v78 >> 3) & 1;
      BOOL v76 = ((v78 >> 4) & 1) == 0;
    }
    else
    {
      int v72 = v17;
      uint64_t v74 = 0;
      uint64_t v75 = 0;
      *(void *)uint64_t v68 = 0;
      BOOL v76 = 1;
      *(void *)&long long v114 = 0;
      DWORD2(v114) = 1;
      LODWORD(v115) = 0;
    }
    DWORD1(v115) = v76;
    unsigned int v79 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v112[1] + 64))(v112[2], 2, 4);
    *((void *)&v115 + 1) = v79;
    if (!v79)
    {
      log_OutText(*v112, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v80, v81, v82, v91);
      uint64_t v62 = 10;
LABEL_36:
      (*(void (**)(uint64_t, _DWORD *))(v26[1] + 80))(v26[2], v64);
      *((void *)&v117 + 1) = 0;
      uint64_t v63 = v62;
      goto LABEL_37;
    }
    uint64_t v96 = (uint64_t)v21;
    uint64_t v97 = a4;
    int v95 = v22;
    unsigned int v94 = v75;
    if (a7)
    {
      _DWORD *v79 = v74[7];
      unsigned int v83 = v74[8];
    }
    else
    {
      _DWORD *v79 = 0;
      unsigned int v83 = 0;
    }
    int v17 = v72;
    unsigned int v34 = a6;
    BOOL v32 = a8;
    unsigned int v36 = v99;
    int v35 = v100;
    int v93 = 0;
    v79[1] = v83;
    int v33 = 1;
    goto LABEL_11;
  }
  int v27 = a7[2];
  if (!v27)
  {
    unsigned int v67 = a7[1];
    unsigned int v102 = (unsigned int *)&a7[*a7];
    *(void *)&long long v116 = v67 & 1;
    DWORD2(v116) = ((v67 >> 1) & 1) == 0;
    LODWORD(v117) = (v67 >> 3) & 1;
    int v66 = (v67 >> 4) & 1;
    goto LABEL_46;
  }
  int v28 = v17;
  unsigned int v29 = a7[1];
  DWORD2(v116) = ((v29 >> 1) & 1) == 0;
  *(void *)&long long v116 = v29 & 1;
  if ((v29 & 8) != 0)
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently not support quantization for block sparse!", v23, v24, v25, v91);
    uint64_t v63 = 7;
    goto LABEL_37;
  }
  uint64_t v30 = (uint64_t)&a7[*a7];
  if ((v29 & 2) != 0) {
    uint64_t v31 = pack_bsr_data((uint64_t)v112, v27, padded_len, __src, v30, v119);
  }
  else {
    uint64_t v31 = pack_bsc_data((uint64_t)v112, v27, padded_len, __src, v30, v119);
  }
  uint64_t v63 = v31;
  if (!v31)
  {
    uint64_t v84 = get_mat_length(a7);
    uint64_t v85 = (unsigned int *)&a7[get_padded_len(v84, 8u)];
    unsigned int v86 = v85[1];
    int v87 = v85[2];
    uint64_t v88 = *v85;
    DWORD2(v114) = ((v86 >> 1) & 1) == 0;
    *(void *)&long long v114 = v86 & 1;
    uint64_t v89 = (uint64_t)&v85[v88];
    uint64_t v90 = (v29 & 2) != 0
        ? pack_bsr_data((uint64_t)v112, v87, padded_len, __src, v89, &v118)
        : pack_bsc_data((uint64_t)v112, v87, padded_len, __src, v89, &v118);
    uint64_t v63 = v90;
    BOOL v32 = a8;
    if (!v90)
    {
      int v93 = v87;
      int v95 = v22;
      uint64_t v96 = (uint64_t)v21;
      uint64_t v97 = a4;
      int v33 = 0;
      unsigned int v102 = 0;
      unsigned int v94 = 0;
      int v17 = v28;
      goto LABEL_10;
    }
  }
LABEL_37:
  if (*((void *)&v115 + 1))
  {
    (*(void (**)(uint64_t))(v26[1] + 80))(v26[2]);
    *((void *)&v115 + 1) = 0;
  }
  if (v119[0])
  {
    (*(void (**)(uint64_t))(v26[1] + 80))(v26[2]);
    v119[0] = 0;
  }
  if (v118) {
    (*(void (**)(uint64_t))(v26[1] + 80))(v26[2]);
  }
  return v63;
}

uint64_t gru_step_f32_fast_resetafter_precompute(uint64_t a1, uint64_t a2, float *a3, uint64_t a4, uint64_t a5, float32x4_t *a6, int *a7, char *a8, uint64_t a9, int a10, int a11, int a12)
{
  int v17 = *(uint64_t **)a1;
  unsigned int step = fi_shape_get_step((_DWORD *)(a1 + 20));
  unsigned int v85 = a4;
  uint64_t padded_len = get_padded_len(a4, 8u);
  int v19 = get_padded_len(a5, 8u);
  uint64_t v20 = (3 * a5);
  unsigned int v21 = get_padded_len(v20, 8u);
  uint64_t v101 = 0;
  v102[0] = 0;
  LODWORD(a4) = fi_feat_is_enabled(*(void *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  int v87 = (uint64_t **)a1;
  BOOL is_enabled = fi_feat_is_enabled(*(void *)(a1 + 256), 7u, *(_DWORD *)(a1 + 264));
  long long v99 = 0u;
  long long v100 = 0u;
  long long v97 = 0u;
  long long v98 = 0u;
  BOOL v91 = (a4 | is_enabled) != 0;
  if (!(a4 | is_enabled))
  {
    BOOL v32 = 0;
    int v90 = 0;
    uint64_t v89 = (unsigned int *)&a7[(padded_len * v20)];
    uint64_t v84 = (uint64_t)a7;
    int v33 = a8;
    goto LABEL_21;
  }
  if (!a7)
  {
    unsigned int v34 = 0;
    int v35 = 0;
    *(void *)&long long v99 = 0;
    DWORD2(v99) = 1;
    LODWORD(v100) = 0;
LABEL_10:
    DWORD1(v100) = v35 ^ 1;
    uint64_t v37 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v17[1] + 64))(v17[2], 2, 4);
    *((void *)&v100 + 1) = v37;
    uint64_t v84 = (uint64_t)v34;
    if (a7)
    {
      *uint64_t v37 = a7[7];
      v37[1] = a7[8];
      if ((a7[1] & 8) != 0)
      {
        uint64_t v42 = *a7;
        uint64_t v39 = (unsigned int *)((char *)&a7[v42] + get_weight_length(a7));
      }
      else
      {
        uint64_t mat_length = get_mat_length(a7);
        uint64_t v39 = (unsigned int *)&a7[get_padded_len(mat_length, 8u)];
      }
      unsigned int v43 = v39[1];
      uint64_t v89 = &v39[*v39];
      *(void *)&long long v97 = v43 & 1;
      DWORD2(v97) = ((v43 >> 1) & 1) == 0;
      LODWORD(v98) = (v43 >> 3) & 1;
      BOOL v40 = ((v43 >> 4) & 1) == 0;
    }
    else
    {
      uint64_t v39 = 0;
      uint64_t v89 = 0;
      *(void *)uint64_t v37 = 0;
      BOOL v40 = 1;
      *(void *)&long long v97 = 0;
      DWORD2(v97) = 1;
      LODWORD(v98) = 0;
    }
    DWORD1(v98) = v40;
    uint64_t v44 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v17[1] + 64))(v17[2], 2, 4);
    *((void *)&v98 + 1) = v44;
    if (a7)
    {
      *uint64_t v44 = v39[7];
      unsigned int v45 = v39[8];
    }
    else
    {
      *uint64_t v44 = 0;
      unsigned int v45 = 0;
    }
    int v33 = a8;
    int v90 = 0;
    v44[1] = v45;
    BOOL v32 = &v99;
    goto LABEL_21;
  }
  int v26 = a7[2];
  if (!v26)
  {
    unsigned int v36 = a7[1];
    unsigned int v34 = (unsigned int *)&a7[*a7];
    *(void *)&long long v99 = v36 & 1;
    DWORD2(v99) = ((v36 >> 1) & 1) == 0;
    LODWORD(v100) = (v36 >> 3) & 1;
    int v35 = (v36 >> 4) & 1;
    goto LABEL_10;
  }
  unsigned int v27 = a7[1];
  DWORD2(v99) = ((v27 >> 1) & 1) == 0;
  *(void *)&long long v99 = v27 & 1;
  if ((v27 & 8) != 0)
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently not support quantization for block sparse!", v23, v24, v25, v81);
    uint64_t v41 = 7;
    goto LABEL_51;
  }
  int v28 = v19;
  uint64_t v29 = (uint64_t)&a7[*a7];
  uint64_t v30 = (3 * a5);
  if ((v27 & 2) != 0) {
    uint64_t v31 = pack_bsr_data((uint64_t)v17, v26, padded_len, v30, v29, v102);
  }
  else {
    uint64_t v31 = pack_bsc_data((uint64_t)v17, v26, padded_len, v30, v29, v102);
  }
  uint64_t v41 = v31;
  if (v31) {
    goto LABEL_51;
  }
  uint64_t v72 = get_mat_length(a7);
  uint64_t v73 = (unsigned int *)&a7[get_padded_len(v72, 8u)];
  unsigned int v74 = v73[1];
  int v75 = v73[2];
  uint64_t v76 = *v73;
  DWORD2(v97) = ((v74 >> 1) & 1) == 0;
  *(void *)&long long v97 = v74 & 1;
  uint64_t v77 = (uint64_t)&v73[v76];
  uint64_t v78 = (3 * a5);
  uint64_t v79 = (v27 & 2) != 0
      ? pack_bsr_data((uint64_t)v17, v75, padded_len, v78, v77, &v101)
      : pack_bsc_data((uint64_t)v17, v75, padded_len, v78, v77, &v101);
  uint64_t v41 = v79;
  int v33 = a8;
  if (v79) {
    goto LABEL_51;
  }
  int v90 = v75;
  uint64_t v89 = 0;
  BOOL v32 = &v99;
  uint64_t v84 = v102[0];
  int v19 = v28;
LABEL_21:
  uint64_t v46 = &v33[4 * v19];
  uint64_t v47 = &v46[4 * v19];
  uint64_t v92 = v17;
  if (!a10)
  {
    uint64_t v82 = v32;
    int v83 = v19;
    if (step)
    {
      int v68 = 0;
      size_t v69 = 4 * a5;
      uint64_t v70 = step;
      do
      {
        uint64_t v71 = &a6->f32[v68];
        memcpy(v71, a8, v69);
        memcpy(&v71[a5], v46, v69);
        memcpy(&v71[(2 * a5)], v47, v69);
        v68 += v21;
        --v70;
      }
      while (v70);
    }
    if ((a2 & 0x1F) != 0)
    {
      log_OutText(**v87, (uint64_t)"FastInfer", 0, 0, (uint64_t)"gru input not aligned!", v23, v24, v25, v81);
      uint64_t v41 = 7;
      int v17 = v92;
      goto LABEL_51;
    }
    uint64_t v20 = (3 * a5);
    int v17 = v92;
    gemm_ex(v92, step, v20, v85, a2, v85, v84, v85, a6, v21, v82);
    int v19 = v83;
  }
  uint64_t v48 = &v47[4 * v19];
  int v49 = (float32x4_t *)((char *)a6 + 4 * v21 * step);
  uint64_t v50 = &v49->f32[v21];
  unsigned int v94 = &v50[v19];
  if (v19 == a5)
  {
    memcpy(v49, v48, 4 * v20);
    uint64_t v51 = (2 * a5);
    int v52 = v19;
  }
  else
  {
    uint64_t v53 = &v48[4 * v19];
    unsigned int v86 = a6;
    uint64_t v54 = &v53[4 * v19];
    int v52 = v19;
    memcpy(v49, v48, 4 * a5);
    memcpy(&v49->f32[a5], v53, 4 * a5);
    uint64_t v51 = (2 * a5);
    size_t v55 = v54;
    a6 = v86;
    memcpy(&v49->f32[v51], v55, 4 * a5);
  }
  if (v90) {
    uint64_t v56 = v101;
  }
  else {
    uint64_t v56 = (uint64_t)v89;
  }
  if (v91) {
    int v57 = &v97;
  }
  else {
    int v57 = 0;
  }
  uint64_t v58 = v20;
  unsigned int v59 = (void *)a9;
  gemm(v17, 1, v58, a5, a9, v56, v49, v57, v81);
  uint64_t v60 = &a6->f32[v21 * a10];
  axpy(v51, v60, 1, v49->f32, 1, 1.0);
  fi_activate_array(v49->f32, v51, a12);
  if (v52 == a5)
  {
    xmy(a5, v49->f32, 1, &v49->f32[v51], 1);
    axpy(a5, &v60[v51], 1, &v49->f32[v51], 1, 1.0);
    fi_activate_array(&v49->f32[v51], a5, a11);
    fill_array_f32(v94, a5, 1.0);
    size_t v61 = 4 * a5;
    axpy(a5, &v49->f32[v61 / 4], 1, v94, 1, -1.0);
    uint64_t v62 = (float *)a9;
    uint64_t v63 = &v49->f32[v61 / 4];
    uint64_t v64 = &v50[v19];
    uint64_t v65 = &v49->f32[v51];
    int v66 = a3;
  }
  else
  {
    unsigned int v67 = &v94[v52];
    size_t v61 = 4 * a5;
    memcpy(v50, &v49->f32[v51], v61);
    xmy(a5, v49->f32, 1, v50, 1);
    memcpy(v94, &v60[v51], v61);
    axpy(a5, v94, 1, v50, 1, 1.0);
    fi_activate_array(v50, a5, a11);
    memcpy(v67, (char *)v49 + v61, v61);
    fill_array_f32(v94, a5, 1.0);
    axpy(a5, v67, 1, v94, 1, -1.0);
    int v66 = a3;
    uint64_t v62 = (float *)a9;
    uint64_t v63 = v67;
    unsigned int v59 = (void *)a9;
    uint64_t v64 = &v50[v19];
    uint64_t v65 = &v49->f32[v21];
  }
  fi_multiply_multiply_add_ansic(v62, v63, v64, v65, v66, a5);
  memcpy(v59, a3, v61);
  int v17 = v92;
  if (v102[0])
  {
    (*(void (**)(uint64_t))(v92[1] + 80))(v92[2]);
    v102[0] = 0;
  }
  if (v101)
  {
    (*(void (**)(uint64_t))(v92[1] + 80))(v92[2]);
    uint64_t v41 = 0;
    uint64_t v101 = 0;
  }
  else
  {
    uint64_t v41 = 0;
  }
LABEL_51:
  if (*((void *)&v100 + 1))
  {
    (*(void (**)(uint64_t))(v17[1] + 80))(v17[2]);
    *((void *)&v100 + 1) = 0;
  }
  if (*((void *)&v98 + 1)) {
    (*(void (**)(uint64_t))(v17[1] + 80))(v17[2]);
  }
  return v41;
}

uint64_t forward_fc_layer_f32(uint64_t a1, float *a2, float32x4_t *a3)
{
  uint64_t v6 = *(unsigned int **)(a1 + 72);
  uint64_t v61 = 0;
  uint64_t v62 = 0;
  uint64_t v7 = *(unsigned int *)(a1 + 12);
  BOOL v8 = (*(_DWORD *)(a1 + 16) & 0xFFFFFFFD) == 1;
  uint64_t v9 = *(int **)(a1 + 120);
  uint64_t v10 = *(uint64_t **)a1;
  BOOL is_enabled = fi_feat_is_enabled(*(void *)(a1 + 256), 4u, *(_DWORD *)(a1 + 264));
  BOOL v12 = fi_feat_is_enabled(*(void *)(a1 + 256), 7u, *(_DWORD *)(a1 + 264));
  long long v59 = 0u;
  long long v60 = 0u;
  if (v12 && v6)
  {
    size_t v55 = a2;
    unsigned int v13 = v6[1];
    uint64_t v14 = *(void *)(a1 + 72);
    uint64_t v15 = *(unsigned int *)(a1 + 96);
    uint64_t v16 = (const void *)(v14 + v15);
    int v17 = (const void *)(v14 + (v15 & 0xFFFFFFFC));
    if ((v13 & 8) != 0) {
      uint64_t v18 = v16;
    }
    else {
      uint64_t v18 = v17;
    }
  }
  else
  {
    if (!v6)
    {
LABEL_46:
      uint64_t size = 0;
      goto LABEL_47;
    }
    size_t v55 = a2;
    uint64_t v18 = (const void *)(*(void *)(a1 + 72) + (*(_DWORD *)(a1 + 96) & 0xFFFFFFFC));
    unsigned int v13 = v6[1];
  }
  int v54 = v8;
  uint64_t v58 = v9;
  uint64_t v56 = a3;
  int v19 = v12 || is_enabled;
  BOOL v20 = !v12 && !is_enabled || v6 == 0;
  int v21 = !v20;
  int v22 = v6;
  if (!v20) {
    int v22 = &v6[*v6];
  }
  uint64_t v57 = (uint64_t)v22;
  uint64_t size = fi_shape_get_size((int *)(a1 + 40), (int *)&v61);
  if (!size)
  {
    unsigned int step = fi_shape_get_step((_DWORD *)(a1 + 20));
    if (!step)
    {
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"steps must > 0, but it is: %d", v25, v26, v27, 0);
      uint64_t size = 7;
      goto LABEL_47;
    }
    unsigned int v52 = step;
    uint64_t size = fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v61 + 1);
    if (!size)
    {
      if (!v21
        || (int v28 = v6[2]) == 0
        || ((uint64_t v29 = get_padded_len(HIDWORD(v61), 8u), (v13 & 3) != 3)
          ? (uint64_t v30 = pack_bsc_data((uint64_t)v10, v28, v29, v7, v57, &v62))
          : (uint64_t v30 = pack_bsr_data((uint64_t)v10, v28, v29, v7, v57, &v62)),
            uint64_t size = v30,
            !v30))
      {
        if (v52 < 2 || (uint64_t v31 = HIDWORD(v61), get_padded_len(HIDWORD(v61), 8u) == v31))
        {
          uint64_t v53 = 0;
        }
        else
        {
          uint64_t v39 = v10[2];
          BOOL v40 = *(uint64_t (**)(uint64_t, void, uint64_t))(v10[1] + 16);
          int padded_len = get_padded_len(v31, 8u);
          uint64_t v42 = v40(v39, padded_len * v52, 4);
          if (!v42)
          {
            log_OutText(*v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v43, v44, v45, v51);
LABEL_53:
            uint64_t size = 10;
            goto LABEL_47;
          }
          int v46 = 0;
          uint64_t v53 = v42;
          uint64_t v47 = 0;
          do
          {
            int v48 = get_padded_len(v31, 8u);
            memcpy((void *)(v53 + 4 * (v48 * v47++)), &v55[v46], 4 * v31);
            v46 += v31;
          }
          while (v52 != v47);
        }
        if (v58[1] == 1)
        {
          int v32 = 0;
          if (v52 <= 1) {
            uint64_t v33 = 1;
          }
          else {
            uint64_t v33 = v52;
          }
          do
          {
            memcpy(&v56->f32[v32], v18, 4 * v7);
            v32 += v7;
            --v33;
          }
          while (v33);
        }
        if (!v19)
        {
          uint64_t v38 = 0;
          uint64_t v36 = v57;
          unsigned int v34 = v58;
          uint64_t v37 = v57;
          int v49 = v55;
          uint64_t v35 = v52;
LABEL_45:
          fc_gemm_wrapper(a1, v35, HIDWORD(v61), v7, v37, (uint64_t)v49, v49, v53, v36, v56, v38);
          fi_activate_array(v56->f32, v61, *v34);
          goto LABEL_46;
        }
        if (pack_gemm_params((uint64_t)v10, v54, v6, (uint64_t)&v59))
        {
          unsigned int v34 = v58;
          uint64_t v35 = v52;
          uint64_t v36 = v57;
          if (v6[1]) {
            uint64_t v37 = v62;
          }
          else {
            uint64_t v37 = v57;
          }
          uint64_t v38 = &v59;
          int v49 = v55;
          goto LABEL_45;
        }
        goto LABEL_53;
      }
    }
  }
LABEL_47:
  if (v62)
  {
    (*(void (**)(uint64_t))(v10[1] + 80))(v10[2]);
    uint64_t v62 = 0;
  }
  if (*((void *)&v60 + 1)) {
    (*(void (**)(uint64_t))(v10[1] + 80))(v10[2]);
  }
  return size;
}

uint64_t pack_gemm_params(uint64_t a1, int a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v4 = a4;
  *(_DWORD *)(a4 + 4) = a2;
  if (!a3)
  {
    *(_DWORD *)a4 = 0;
    *(_DWORD *)(a4 + 8) = 1;
    *(void *)(a4 + 16) = 0x100000000;
    goto LABEL_6;
  }
  *(_DWORD *)a4 = a3[1] & 1;
  *(_DWORD *)(a4 + 8) = ((a3[1] >> 1) & 1) == 0;
  unsigned int v6 = a3[1];
  *(_DWORD *)(a4 + 16) = (v6 >> 3) & 1;
  *(_DWORD *)(a4 + 20) = ((a3[1] >> 4) & 1) == 0;
  if (((v6 >> 3) & 1) == 0)
  {
LABEL_6:
    *(void *)(a4 + 24) = 0;
    return v4;
  }
  uint64_t v7 = (_DWORD *)(*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)(a1 + 8) + 64))(*(void *)(a1 + 16), 2, 4);
  *(void *)(v4 + 24) = v7;
  if (!v7) {
    return 0;
  }
  *uint64_t v7 = a3[7];
  v7[1] = a3[8];
  return v4;
}

void fc_gemm_wrapper(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, float *a7, uint64_t a8, uint64_t a9, float32x4_t *a10, _DWORD *a11)
{
  uint64_t v18 = a10;
  int v17 = a11;
  if (a2 < 2) {
    goto LABEL_3;
  }
  int v28 = *(uint64_t **)a1;
  uint64_t v30 = a8;
  uint64_t v19 = a6;
  BOOL v20 = a7;
  int padded_len = get_padded_len(a3, 8u);
  a7 = v20;
  int v17 = a11;
  uint64_t v18 = a10;
  a6 = v19;
  if (padded_len == a3)
  {
LABEL_3:
    int v22 = *(_DWORD *)(a1 + 16);
    if (v22 == 2)
    {
      unsigned int v26 = a7[1];
      axpy(a4, (float *)(a9 + 4 * *a7 * a4), 1, v18->f32, 1, 1.0);
      unsigned int v23 = v26 * a4;
      goto LABEL_11;
    }
    if (v22 == 1)
    {
      unsigned int v23 = *a7 * a4;
LABEL_11:
      axpy(a4, (float *)(a9 + 4 * v23), 1, v18->f32, 1, 1.0);
      return;
    }
    uint64_t v27 = *(uint64_t **)a1;
    gemm(v27, a2, a4, a3, a6, a5, v18, v17, a9);
  }
  else
  {
    gemm(*(uint64_t **)a1, a2, a4, a3, v30, a5, a10, a11, (uint64_t)v28);
    if (v30)
    {
      uint64_t v24 = *(void *)(v29 + 16);
      uint64_t v25 = *(void (**)(uint64_t, uint64_t))(*(void *)(v29 + 8) + 48);
      v25(v24, v30);
    }
  }
}

uint64_t create_flatten_layer(uint64_t *a1, _DWORD *a2, uint64_t ***a3)
{
  unsigned int v6 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  uint64_t v10 = v6;
  if (v6
    && (*unsigned int v6 = a1,
        uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 4),
        (v10[15] = (uint64_t *)v11) != 0))
  {
    BOOL v12 = (_DWORD *)v11;
    uint64_t result = 0;
    *BOOL v12 = *a2;
    *((_DWORD *)v10 + 2) = 7;
    v10[16] = (uint64_t *)forward_flatten_layer;
    v10[17] = (uint64_t *)free_flatten_buffer;
    v10[18] = (uint64_t *)flatten_layer_update_shape;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v7, v8, v9, v14);
    free_flatten_buffer(v10);
    uint64_t result = 10;
  }
  *a3 = v10;
  return result;
}

uint64_t forward_flatten_layer(uint64_t a1, uint64_t a2, const void *a3, void *a4)
{
  unsigned int v8 = 0;
  uint64_t size = fi_shape_get_size((int *)(a2 + 40), (int *)&v8);
  if (!size) {
    memcpy(a4, a3, 4 * v8);
  }
  return size;
}

void *free_flatten_buffer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      if (result[15])
      {
        (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        v1[15] = 0;
      }
      uint64_t v3 = *(void *)(v2 + 16);
      uint64_t v4 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v4(v3, v1);
    }
  }
  return result;
}

uint64_t flatten_layer_update_shape(uint64_t a1, int *a2)
{
  int v7 = 0;
  int v4 = a2[4];
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v4;
  uint64_t result = fi_shape_get_size(a2, &v7);
  if (!result)
  {
    int v6 = v7;
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = v6;
    *(_DWORD *)(a1 + 56) = a2[4];
  }
  return result;
}

uint64_t create_norm_layer(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v9)
  {
    uint64_t result = 0;
    uint64_t v11 = *a2;
    *(_DWORD *)(v9 + 16) = *((_DWORD *)a2 + 2);
    *(void *)uint64_t v9 = a1;
    *(void *)(v9 + 8) = v11;
    *(void *)(v9 + 128) = forward_norm_layer;
    *(void *)(v9 + 136) = free_norm_buffer;
    *(void *)(v9 + 144) = norm_layer_update_shape;
    *(void *)(v9 + 152) = norm_layer_wanted_wb_len;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v6, v7, v8, v12);
    uint64_t result = 10;
  }
  *a3 = v9;
  return result;
}

uint64_t forward_norm_layer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(uint64_t **)a2;
  int v53 = 0;
  uint64_t v10 = (int *)(a2 + 40);
  int step = fi_shape_get_step((_DWORD *)(a2 + 40));
  unsigned int v52 = 0;
  uint64_t v12 = *(float **)(a2 + 88);
  unsigned int v13 = *(float **)(a2 + 104);
  uint64_t input_dim = fi_shape_get_input_dim(v10, (int *)&v52);
  if (!input_dim)
  {
    uint64_t v49 = a3;
    uint64_t v50 = a4;
    unsigned int padded_len = get_padded_len(v52, 8u);
    unsigned int v19 = padded_len;
    unsigned int v20 = v52;
    if (a5 && !*(_DWORD *)(a5 + 16) && v52 != padded_len)
    {
      log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Normalization layer cannot work with swapNeeded equal to 0 and an input dimension not multiple of the padding (%d).", v16, v17, v18, 8);
      unsigned int v20 = v52;
    }
    if (v20 == v19)
    {
      int v21 = 0;
    }
    else
    {
      int v21 = (void *)(*(uint64_t (**)(uint64_t, void, uint64_t))(v9[1] + 16))(v9[2], v19, 4);
      if (!v21)
      {
        log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory in normalization layer!", v22, v23, v24, v47);
        return 10;
      }
    }
    uint64_t input_dim = fi_shape_get_size(v10, &v53);
    if (!input_dim)
    {
      if (!step)
      {
        uint64_t input_dim = 0;
        if (!v21) {
          return input_dim;
        }
        goto LABEL_35;
      }
      uint64_t v51 = v12;
      int v48 = v9;
      int v25 = 0;
      uint64_t v26 = v50;
      do
      {
        uint64_t v27 = v52 * v25;
        int v28 = (void *)(v49 + 4 * v27);
        uint64_t v29 = v21;
        if (v52 == v19)
        {
          if (!a5 || (uint64_t v29 = (void *)(v49 + 4 * v27), *(_DWORD *)(a5 + 16))) {
            uint64_t v29 = (void *)(v26 + 4 * v27);
          }
        }
        memcpy(v29, (const void *)(v49 + 4 * v27), 4 * v52);
        int v30 = v52;
        if (*(_DWORD *)(a2 + 8) == 40 && v52 != 0)
        {
          double v32 = 0.0;
          uint64_t v33 = v52;
          unsigned int v34 = (float *)v29;
          do
          {
            float v35 = *v34++;
            double v32 = v32 + v35;
            --v33;
          }
          while (v33);
          float v36 = v32 / (double)v52;
          double v37 = 0.0;
          uint64_t v38 = v52;
          uint64_t v39 = (float *)v29;
          do
          {
            float v40 = *v39++;
            double v37 = v37 + (float)(v40 - v36) * (float)(v40 - v36);
            --v38;
          }
          while (v38);
          float v41 = sqrt(v37 / (double)v52) + 1.0e-30;
          uint64_t v42 = v52;
          uint64_t v43 = (float *)v29;
          do
          {
            *uint64_t v43 = (float)(*v43 - v36) / v41;
            ++v43;
            --v42;
          }
          while (v42);
        }
        xmy(v30, v51, 1, (float *)v29, 1);
        axpy(v52, v13, 1, (float *)v29, 1, 1.0);
        if (v52 != v19)
        {
          if (a5 && !*(_DWORD *)(a5 + 16))
          {
            size_t v45 = 4 * v52;
            uint64_t v44 = v28;
          }
          else
          {
            uint64_t v44 = (void *)(v26 + 4 * v52 * v25);
            size_t v45 = 4 * v52;
          }
          memcpy(v44, v29, v45);
          bzero(v21, v45);
          uint64_t v26 = v50;
        }
        ++v25;
      }
      while (v25 != step);
      uint64_t input_dim = 0;
      uint64_t v9 = v48;
    }
    if (v21) {
LABEL_35:
    }
      (*(void (**)(uint64_t, void *))(v9[1] + 48))(v9[2], v21);
  }
  return input_dim;
}

uint64_t free_norm_buffer(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void, uint64_t))(*(void *)(*(void *)result + 8) + 48))(*(void *)(*(void *)result + 16), result);
  }
  return result;
}

uint64_t norm_layer_update_shape(uint64_t a1, long long *a2)
{
  long long v2 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v2;
  long long v3 = *a2;
  *(_DWORD *)(a1 + 56) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 40) = v3;
  return 0;
}

uint64_t norm_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int v7 = 0;
  uint64_t input_dim = fi_shape_get_input_dim((int *)(a1 + 20), (int *)&v7);
  if (!input_dim)
  {
    *a2 = 4 * get_padded_len(v7, 8u);
    *a3 = 4 * v7;
  }
  return input_dim;
}

uint64_t create_gl_layer(uint64_t *a1, uint64_t *a2, long long *a3, uint64_t *a4)
{
  uint64_t v5 = 0;
  uint64_t v6 = 7;
  if (!a2 || !a3) {
    goto LABEL_7;
  }
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v5 || (uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 24)) == 0)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v10, v11, v12, v17);
    uint64_t v6 = 10;
LABEL_7:
    free_gl_layer((void *)v5);
    goto LABEL_8;
  }
  uint64_t v6 = 0;
  long long v14 = *a3;
  *(void *)(v13 + 16) = *((void *)a3 + 2);
  *(_OWORD *)uint64_t v13 = v14;
  *(void *)(v5 + 120) = v13;
  uint64_t v15 = *a2;
  *(_DWORD *)(v5 + 16) = *((_DWORD *)a2 + 2);
  *(void *)uint64_t v5 = a1;
  *(void *)(v5 + 8) = v15;
  *(void *)(v5 + 128) = forward_gl_layer;
  *(void *)(v5 + 136) = free_gl_layer;
  *(void *)(v5 + 144) = gl_layer_update_shape;
  *(void *)(v5 + 160) = gl_request_glbBuf;
LABEL_8:
  *a4 = v5;
  return v6;
}

uint64_t forward_gl_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = *(float **)(a2 + 120);
  unsigned int v13 = *((_DWORD *)v12 + 5);
  if (v13 != 1)
  {
    if (v13)
    {
      uint64_t v51 = **(void **)a2;
      unsigned int v52 = "must offer correct gl_type input!";
LABEL_53:
      log_OutText(v51, (uint64_t)"FastInfer", 0, 0, (uint64_t)v52, a6, a7, a8, v53);
      return 7;
    }
    unsigned int v72 = 0;
    long long v14 = *(uint64_t **)a2;
    unsigned int step = fi_shape_get_step((_DWORD *)(a2 + 20));
    uint64_t v15 = *(unsigned int *)v12;
    unsigned int v16 = *((_DWORD *)v12 + 1);
    fi_shape_get_size((int *)(a2 + 40), (int *)&v72);
    unsigned int v17 = v72 - v15;
    v72 -= v15;
    if (*(_DWORD *)(a2 + 36) == 4)
    {
      int v18 = *(_DWORD *)(a2 + 28);
      if (*(_DWORD *)v12 == 2 * v18 - 2)
      {
        unsigned int v63 = v16;
        uint64_t v64 = v14;
        uint64_t v58 = a2;
        unsigned int v19 = *(float32x2_t **)(a2 + 240);
        unsigned int v61 = v15 * step;
        int v66 = (float *)&v19[v15 * step];
        int v54 = &v66[v15 * step];
        uint64_t v56 = a5;
        unsigned int v20 = &v54[v17 + v15];
        bzero(v19, 8 * v15 * step);
        int v68 = v20;
        bzero(v20, 8 * v15 + 4 * (3 * v15));
        if (v18)
        {
          for (unsigned int i = 0; i != v18; ++i)
          {
            if (step)
            {
              float v22 = v12[2];
              unsigned int v23 = i;
              unsigned int v24 = i;
              uint64_t v25 = step;
              do
              {
                v19[v24].f32[0] = powf(*(float *)(a3 + 4 * v23), v22);
                v24 += v15;
                v23 += v18;
                --v25;
              }
              while (v25);
            }
          }
        }
        fi_istft(v64, v68, (uint64_t)v19, v54, step, *((unsigned int *)v12 + 4), v15, v63);
        get_amp((uint64_t)v19, v66, v61);
        if (*((_DWORD *)v12 + 3))
        {
          int v26 = 0;
          do
          {
            uint64_t result = fi_stft((uint64_t)v64, (uint64_t)v68, (uint64_t)v54, (uint64_t)v19, v72, *((unsigned int *)v12 + 4), v15, v63);
            if (result) {
              return result;
            }
            update_spec_inplace_c(v19, v66, v61);
            bzero(v54, 4 * (v72 + v15));
            uint64_t result = fi_istft(v64, v68, (uint64_t)v19, v54, step, *((unsigned int *)v12 + 4), v15, v63);
            if (result) {
              return result;
            }
          }
          while (++v26 < *((_DWORD *)v12 + 3));
        }
        unsigned int v28 = v72 + v63;
        memmove(a4, (char *)v54 + ((2 * v15) & 0x1FFFFFFFCLL), 4 * (v72 + v63));
        uint64_t result = 0;
        *(_DWORD *)(v58 + 44) = v28;
        uint64_t v29 = v56;
LABEL_17:
        *(_DWORD *)(v29 + 20) = 1;
        return result;
      }
      uint64_t v51 = *v14;
      goto LABEL_52;
    }
    uint64_t v51 = *v14;
LABEL_49:
    unsigned int v52 = "only support f32 input!";
    goto LABEL_53;
  }
  unsigned int v73 = 0;
  int v30 = *(uint64_t **)a2;
  unsigned int v71 = fi_shape_get_step((_DWORD *)(a2 + 20));
  uint64_t v32 = *(unsigned int *)v12;
  unsigned int v31 = *((_DWORD *)v12 + 1);
  fi_shape_get_size((int *)(a2 + 40), (int *)&v73);
  v73 -= v32;
  if (*(_DWORD *)(a2 + 36) != 4)
  {
    uint64_t v51 = *v30;
    goto LABEL_49;
  }
  uint64_t v62 = v30;
  uint64_t v33 = *(unsigned int *)(a2 + 28);
  if (*(_DWORD *)v12 != 2 * v33 - 2)
  {
    uint64_t v51 = *v62;
LABEL_52:
    unsigned int v52 = "wrong number of spec n_freqs!";
    goto LABEL_53;
  }
  unsigned int v55 = v31;
  uint64_t v59 = a2;
  char __dst = (float *)a4;
  uint64_t v57 = a5;
  unsigned int v34 = *(float32x2_t **)(a2 + 240);
  float v35 = &v34[v32 * v71];
  float v36 = (float *)&v35[v32 * v71];
  uint64_t v67 = v32 * v71;
  double v37 = &v36[v67];
  if (v32)
  {
    for (uint64_t j = 0; j != v32; ++j)
      v37[v32 + j] = window_function(*((_DWORD *)v12 + 4), (float)j, (float)v32);
    for (uint64_t k = 0; k != v32; ++k)
      v37[k] = (float)(v37[v32 + k] * v37[v32 + k]) * (float)v32;
  }
  uint64_t v65 = &v36[v32 * v71];
  uint64_t v69 = v32;
  bzero(v34, 4 * v67 + 8 * (2 * v67));
  if (v71)
  {
    int v40 = 0;
    for (int m = 0; m != v71; ++m)
    {
      if (v33)
      {
        uint64_t v42 = 0;
        int v43 = m * v69;
        do
        {
          float v44 = v12[2];
          if (v44 >= 1.751 || v44 <= 1.699)
          {
            float v46 = *(float *)(a3 + 4 * (v40 + v42));
            if (v44 >= 1.501 || v44 <= 1.499) {
              float v45 = powf(v46, v44);
            }
            else {
              float v45 = (float)(v46 * v46) * Q_rsqrt(v46);
            }
          }
          else
          {
            float v45 = Q_powf_1_75(*(float *)(a3 + 4 * (v40 + v42)));
          }
          uint64_t v47 = (v42 + v43);
          v34[v47].f32[0] = v45;
          v35[v47].f32[0] = v45;
          v36[(v42++ + v43)] = v45;
        }
        while (v33 != v42);
      }
      v40 += v33;
    }
  }
  if (!*((_DWORD *)v12 + 3))
  {
LABEL_43:
    uint64_t result = fi_istft(v62, v65, (uint64_t)v35, __dst, v71, *((unsigned int *)v12 + 4), v69, v55);
    if (result) {
      return result;
    }
    unsigned int v50 = v73 + v55;
    memmove(__dst, &__dst[v69 >> 1], 4 * (v73 + v55));
    uint64_t v29 = v57;
    *(_DWORD *)(v59 + 44) = v50;
    if (!v57) {
      return 0;
    }
    uint64_t result = 0;
    goto LABEL_17;
  }
  int v48 = 0;
  while (1)
  {
    uint64_t result = fi_istft(v62, v65, (uint64_t)v35, __dst, v71, *((unsigned int *)v12 + 4), v69, v55);
    if (result) {
      return result;
    }
    uint64_t result = fi_stft((uint64_t)v62, (uint64_t)v65, (uint64_t)__dst, (uint64_t)v34, v73, *((unsigned int *)v12 + 4), v69, v55);
    if (result) {
      return result;
    }
    LODWORD(v49) = 1063828014;
    update_admm_c(v67, v34, v35, v36, v49);
    if (++v48 >= *((_DWORD *)v12 + 3)) {
      goto LABEL_43;
    }
  }
}

void *free_gl_layer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      if (result[15]) {
        (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
      }
      uint64_t v3 = *(void *)(v2 + 16);
      int v4 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v4(v3, v1);
    }
  }
  return result;
}

uint64_t gl_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(_DWORD **)(a1 + 120);
  int v9 = *(_DWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v9;
  if (*(_DWORD *)a2 == 2)
  {
    uint64_t v10 = 0;
    *(_DWORD *)(a1 + 40) = 1;
    *(_DWORD *)(a1 + 44) = *v8 + (*(_DWORD *)(a2 + 4) - 1) * v8[1];
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 16);
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently gl layer only support 2D input", a6, a7, a8, vars0);
    return 7;
  }
  return v10;
}

uint64_t gl_request_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(int **)(a1 + 120);
  int v8 = 0;
  int step = fi_shape_get_step((_DWORD *)(a1 + 20));
  int v4 = *v2;
  uint64_t result = fi_shape_get_size((int *)(a1 + 40), &v8);
  if (!result)
  {
    int v6 = v4 * step;
    if (v2[5]) {
      int v7 = (4 * step + 20) * v4 + 16 * v6;
    }
    else {
      int v7 = 4 * (v8 + v4 * (step + 4)) + 8 * (3 * v6 + v4);
    }
    *(_DWORD *)(a1 + 248) = v7;
  }
  return result;
}

void update_spec_inplace_c(float32x2_t *a1, float *a2, unsigned int a3)
{
  if (a3)
  {
    uint64_t v5 = a3;
    do
    {
      float v6 = a1->f32[0];
      float v7 = a1->f32[1];
      if (v7 == 0.0)
      {
        BOOL v9 = v6 <= 0.0;
        if (v6 != 0.0)
        {
          float v10 = *a2;
          if (v9) {
            float v10 = -*a2;
          }
          a1->f32[0] = v10;
        }
      }
      else
      {
        float v8 = Q_rsqrt((float)(v7 * v7) + (float)(v6 * v6));
        if (v8 >= 10000000.0) {
          *a1 = 0;
        }
        else {
          *a1 = vmul_n_f32(*a1, v8 * *a2);
        }
      }
      ++a1;
      ++a2;
      --v5;
    }
    while (v5);
  }
}

void update_admm_c(int a1, float32x2_t *a2, float32x2_t *a3, float *a4, double a5)
{
  if (a1 >= 1)
  {
    *(float *)&a5 = *(float *)&a5 + *(float *)&a5;
    float v15 = 1.0 - *(float *)&a5;
    uint64_t v8 = a1;
    float32x2_t v9 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a5, 0);
    do
    {
      float32x2_t v10 = vmla_f32(vmul_n_f32(*a3, v15), *a2, v9);
      *a3 = vmul_f32(vsub_f32(*a3, v10), (float32x2_t)0x3F0000003F000000);
      if (v10.f32[1] == 0.0)
      {
        if (v10.f32[0] != 0.0)
        {
          float v13 = *a4;
          if (v10.f32[0] <= 0.0) {
            float v13 = -v13;
          }
          v10.f32[0] = v13;
        }
        float32x2_t v12 = v10;
      }
      else
      {
        float32x2_t v14 = v10;
        float v11 = Q_rsqrt(vmul_f32(v10, v10).f32[0] + (float)(v10.f32[1] * v10.f32[1]));
        float32x2_t v12 = 0;
        if (v11 < 10000000.0) {
          float32x2_t v12 = vmul_n_f32(v14, v11 * *a4);
        }
      }
      *a3 = vadd_f32(v12, *a3);
      ++a3;
      ++a2;
      ++a4;
      --v8;
    }
    while (v8);
  }
}

void *free_tacotron_stream(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[33]);
        fi_layer_free(v3[34]);
        fi_layer_free(v3[35]);
        fi_layer_free(v3[36]);
        fi_layer_free(v3[37]);
        fi_layer_free(v3[38]);
        fi_layer_free(v3[39]);
        fi_layer_free(v3[40]);
        (*(void (**)(void, uint64_t *))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v4 = *(void *)(v2 + 16);
      uint64_t v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v5(v4, v1);
    }
  }
  return result;
}

uint64_t create_tacotron_stream(uint64_t *a1, int32x2_t *a2, uint64_t **a3, uint64_t a4, int a5, uint64_t *a6)
{
  uint64_t v7 = 0;
  uint64_t v8 = 7;
  if (a1 && a2)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      unsigned int v17 = (char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 376);
      int v21 = v17;
      if (!v17)
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v18, v19, v20, v34);
        uint64_t v8 = 10;
        goto LABEL_12;
      }
      memcpy(v17, a2, 0x108uLL);
      *((void *)v21 + 41) = 0;
      *((_DWORD *)v21 + 90) = a2[28].i32[1];
      *((void *)v21 + 43) = 0;
      *((void *)v21 + 46) = 0;
      uint64_t v37 = 0;
      unsigned __int32 v22 = a2[1].u32[0];
      int v38 = 5;
      int32x2_t v39 = (int32x2_t)v22;
      if (create_fc_layer(a1, (uint64_t *)&v38, &v37, 0, a4, (uint64_t *)v21 + 33)
        || (v39.i32[0] = a2[1].i32[1],
            uint64_t v37 = 0x100000003,
            create_fc_layer(a1, (uint64_t *)&v38, &v37, 0, a4, (uint64_t *)v21 + 34))
        || (v39.i32[0] = a2[2].i32[0],
            create_fc_layer(a1, (uint64_t *)&v38, &v37, 0, a4, (uint64_t *)v21 + 35)))
      {
        int v26 = "create pre dense failed!";
LABEL_9:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v23, v24, v25, v34);
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Tacotron init failed!", v27, v28, v29, v35);
LABEL_12:
        *(void *)(v7 + 120) = v21;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"tacotron_stream init param failed!", v30, v31, v32, v36);
        goto LABEL_13;
      }
      v39.i32[0] = a2[26].i32[0];
      LODWORD(v37) = a2[10].i32[0] == 1;
      if (create_fc_layer(a1, (uint64_t *)&v38, &v37, 0, a4, (uint64_t *)v21 + 40))
      {
        int v26 = "create post dense failed!";
        goto LABEL_9;
      }
      if (create_cbhg_layer(a1, (uint64_t)&a2[2] + 4, a3, a4, (uint64_t ***)v21 + 36))
      {
        int v26 = "create encoder cbhg failed!";
        goto LABEL_9;
      }
      if (create_tacodecoder_layer(a1, (uint64_t)&a2[7], a4, (uint64_t *)v21 + 37))
      {
        int v26 = "create decoder failed!";
        goto LABEL_9;
      }
      int v38 = 3;
      int32x2_t v39 = vrev64_s32(a2[25]);
      if (create_lstm_layer(a1, &v38, &a2[18], a3, a4, v21 + 304))
      {
        int v26 = "create LSTM1 layer failed!";
        goto LABEL_9;
      }
      if (create_lstm_layer(a1, &v38, &a2[21].u8[4], a3, a4, v21 + 312))
      {
        int v26 = "create LSTM2 layer failed!";
        goto LABEL_9;
      }
      *(void *)(v7 + 120) = v21;
      if (a3) {
        *(void *)(v7 + 60) = *a3;
      }
      uint64_t v8 = 0;
      *(void *)uint64_t v7 = a1;
      *(_DWORD *)(v7 + 8) = a5;
      *(_DWORD *)(v7 + 12) = 0;
      *(void *)(v7 + 128) = forward_tacotron_stream;
      *(void *)(v7 + 136) = free_tacotron_stream;
      *(void *)(v7 + 144) = tacotron_stream_update_shape;
      *(void *)(v7 + 152) = tacotron_stream_wanted_wb_len;
      *(void *)(v7 + 160) = tacotron_stream_request_glbBuf;
      *(void *)(v7 + 184) = tacotron_stream_dispatch_weights;
      *(void *)(v7 + 168) = tacotron_stream_assign_glbBuf;
      *(void *)(v7 + 224) = tacotron_stream_update_param;
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v14, v15, v16, v34);
      uint64_t v8 = 10;
    }
  }
LABEL_13:
  *a6 = v7;
  return v8;
}

uint64_t forward_tacotron_stream(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5)
{
  uint64_t v163 = *MEMORY[0x263EF8340];
  uint64_t v10 = *(void *)(a2 + 120);
  float v11 = *(uint64_t **)a2;
  uint64_t v155 = 0;
  int v160 = 0;
  uint64_t v159 = 0;
  int v12 = *(_DWORD *)(a2 + 24);
  int v13 = *(_DWORD *)(v10 + 60);
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v11[1] + 16))(v11[2], 1, 64);
  if (!v14)
  {
    log_OutText(*v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v15, v16, v17, v139);
    return 10;
  }
  uint64_t v18 = v14;
  uint64_t v151 = a5;
  uint64_t v152 = a1;
  int v150 = v13;
  uint64_t v153 = v10;
  char __dst = a4;
  uint64_t v19 = *(uint64_t **)a2;
  uint64_t v20 = *(void *)(a2 + 120);
  LODWORD(v157[0]) = 0;
  uint64_t v21 = *(void *)(a2 + 240);
  *(void *)(v14 + 16) = v21;
  unsigned int v22 = *(_DWORD *)(v20 + 224) * get_padded_len(*(unsigned int *)(v20 + 68), 8u);
  *(void *)(v18 + 24) = v21 + 4 * v22;
  uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v20 + 296) + 40), v157);
  if (bytes) {
    goto LABEL_6;
  }
  unsigned int v27 = v22 + (get_padded_bytes(v157[0], 8u) >> 2);
  *(void *)(v18 + 32) = v21 + 4 * v27;
  unsigned int v28 = get_padded_len((*(_DWORD *)(v20 + 208) * *(_DWORD *)(v20 + 212)), 8u) + v27;
  *(void *)(v18 + 40) = v21 + 4 * v28;
  uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v20 + 304) + 40), v157);
  if (bytes
    || (unsigned int v29 = v28 + (get_padded_bytes(v157[0], 8u) >> 2),
        *(void *)(v18 + 48) = v21 + 4 * v29,
        uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v20 + 312) + 40), v157),
        bytes)
    || (*(void *)(v18 + 56) = v21 + 4 * (v29 + (get_padded_bytes(v157[0], 8u) >> 2)),
        uint64_t bytes = (*(uint64_t (**)(void))(*(void *)(v20 + 296) + 216))(),
        bytes))
  {
LABEL_6:
    uint64_t v30 = *v19;
    uint64_t v31 = "tacotron stream pack buf manager failed!";
LABEL_7:
    log_OutText(v30, (uint64_t)"FastInfer", 0, 0, (uint64_t)v31, v23, v24, v25, v139);
    goto LABEL_8;
  }
  *(void *)uint64_t v18 = a3;
  *(void *)(v18 + 8) = __dst;
  if (v12 == 3)
  {
    float v33 = *(float *)(a3 + 4 * (*(_DWORD *)(a2 + 28) + 1));
    float v34 = *(float *)(a3 + 4);
    if (v33 < (float)(v34 + 0.0001) && v33 > (float)(v34 + -0.0001))
    {
      **(_DWORD **)(v153 + 368) = 1;
      int v35 = *(_DWORD *)(v153 + 208);
      LODWORD(v159) = 1;
      HIDWORD(v159) = v35;
      *(_DWORD *)(v151 + 20) = 1;
      uint64_t bytes = fi_shape_set(2, (uint64_t)&v159, 4, a2 + 40);
      if (!bytes)
      {
        bzero(__dst, 4 * (HIDWORD(v159) * v159));
        **(void **)(v153 + 344) = 1;
        *(_DWORD *)(v153 + 356) = 10000;
      }
      goto LABEL_8;
    }
  }
  uint64_t v36 = v153;
  if (!*(_DWORD *)(v153 + 328))
  {
    uint64_t v44 = *(void *)(a2 + 120);
    *(_DWORD *)(v44 + 352) = *(_DWORD *)v44;
    *(_DWORD *)(v44 + 356) = 0;
    float v45 = *(_DWORD **)(v44 + 368);
    *float v45 = 0;
    if (!*(_DWORD *)(v44 + 332))
    {
      *(_DWORD *)(v44 + 360) = *(_DWORD *)(v44 + 228);
      *float v45 = 1;
    }
    float v46 = *(void **)(v18 + 24);
    uint64_t v47 = *(uint64_t **)a2;
    int v48 = *(void **)(a2 + 240);
    uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v44 + 264) + 40), (_DWORD *)&v155 + 1);
    if (bytes) {
      goto LABEL_8;
    }
    bzero(v48, HIDWORD(v155));
    uint64_t v49 = (*(uint64_t (**)(uint64_t))(*(void *)(v44 + 264) + 128))(v152);
    if (v49)
    {
      uint64_t bytes = v49;
      uint64_t v31 = "tacotron_stream pre dense o1 forward failed!";
    }
    else
    {
      uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v44 + 272) + 40), (_DWORD *)&v155 + 1);
      if (bytes) {
        goto LABEL_8;
      }
      bzero(v46, HIDWORD(v155));
      uint64_t v94 = (*(uint64_t (**)(uint64_t))(*(void *)(v44 + 272) + 128))(v152);
      if (v94)
      {
        uint64_t bytes = v94;
        uint64_t v31 = "tacotron_stream pre dense o2 forward failed!";
      }
      else
      {
        uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v44 + 280) + 40), (_DWORD *)&v155 + 1);
        if (bytes) {
          goto LABEL_8;
        }
        bzero(v48, HIDWORD(v155));
        uint64_t v110 = (*(uint64_t (**)(uint64_t))(*(void *)(v44 + 280) + 128))(v152);
        if (v110)
        {
          uint64_t bytes = v110;
          uint64_t v31 = "tacotron_stream pre dense o3 forward failed!";
        }
        else
        {
          uint64_t bytes = (*(uint64_t (**)(void))(*(void *)(v44 + 288) + 176))();
          if (bytes) {
            goto LABEL_8;
          }
          uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v44 + 288) + 40), (_DWORD *)&v155 + 1);
          if (bytes) {
            goto LABEL_8;
          }
          bzero(v46, HIDWORD(v155));
          uint64_t v111 = (*(uint64_t (**)(uint64_t))(*(void *)(v44 + 288) + 128))(v152);
          if (!v111)
          {
            uint64_t v36 = v153;
            if (v12)
            {
              int v120 = 0;
              int v121 = 0;
              uint64_t v122 = (const void *)(*(void *)(a2 + 72) + 4 * (*(_DWORD *)(v153 + 4) * *(_DWORD *)v153));
              do
              {
                memcpy((void *)(*(void *)(v18 + 16) + 4 * (*(_DWORD *)(v153 + 68) * v121)), (const void *)(*(void *)(v18 + 24) + 4 * (v120 * *(_DWORD *)(v153 + 48))), 4 * (2 * *(_DWORD *)(v153 + 48)));
                memcpy((void *)(*(void *)(v18 + 16)+ 4 * (*(_DWORD *)(v153 + 68) * v121++)+ 4 * (2 * *(_DWORD *)(v153 + 48))), v122, 4 * *(unsigned int *)(v153 + 4));
                v120 += 2;
              }
              while (v12 != v121);
            }
            goto LABEL_17;
          }
          uint64_t bytes = v111;
          uint64_t v31 = "tacotron_stream encoder cbhg forward failed!";
        }
      }
    }
    uint64_t v30 = *v47;
    goto LABEL_7;
  }
LABEL_17:
  uint64_t v37 = *(void *)(v36 + 344);
  uint64_t v38 = *(void *)(a2 + 120);
  LODWORD(v157[0]) = 0;
  int v39 = *(_DWORD *)(v38 + 244);
  unint64_t v147 = *(unsigned int *)(v38 + 240);
  unint64_t v40 = *(unsigned int *)(a2 + 24);
  int v41 = *(_DWORD *)(v38 + 56);
  uint64_t v149 = *(unsigned int *)(v38 + 60);
  size_t v42 = (4 * v41 * *(_DWORD *)(v38 + 212));
  uint64_t v43 = *(void *)(v38 + 296);
  if (*(_DWORD *)(v38 + 328))
  {
    uint64_t bytes = (*(uint64_t (**)(uint64_t, void))(v43 + 200))(v43, *(void *)(v18 + 56));
    if (bytes) {
      goto LABEL_8;
    }
  }
  else
  {
    uint64_t bytes = (*(uint64_t (**)(void))(v43 + 176))();
    if (bytes) {
      goto LABEL_8;
    }
    bzero(*(void **)(v18 + 32), v42);
  }
  memcpy(__dst, *(const void **)(v18 + 32), v42);
  unsigned int v50 = *(_DWORD *)(v38 + 356);
  LODWORD(v51) = *(_DWORD *)(v38 + 228);
  if (v50 < v51)
  {
    size_t v146 = (4 * v149 * v41);
    size_t __len = (v42 - v146);
    uint64_t v144 = &__dst[v42];
    unint64_t v143 = (v39 + v147);
    unint64_t v142 = (7 * v40);
    size_t v140 = (unsigned int *)(v37 + 8);
    uint64_t v139 = v149 - 1;
    int v148 = v149 * (v50 - v147);
    uint64_t v52 = v152;
    unint64_t v53 = *(unsigned int *)(v38 + 356);
    size_t v54 = v42;
    float v145 = (_DWORD *)(v37 + 4);
    while (1)
    {
      uint64_t v55 = (*(uint64_t (**)(uint64_t))(*(void *)(v38 + 296) + 128))(v52);
      if (v55) {
        goto LABEL_72;
      }
      unsigned int v56 = *(_DWORD *)(v38 + 212);
      if (v56)
      {
        unsigned int v57 = *(_DWORD *)(v38 + 60);
        uint64_t v58 = *(char **)(v18 + 32);
        if (v56 <= v57)
        {
          uint64_t v64 = *(void *)(v18 + 24);
          unsigned int v61 = (const void *)(v64
                             + 4 * get_padded_len(1, 8u)
                             + 4
                             * ((*(_DWORD *)(v38 + 60) - *(_DWORD *)(v38 + 212)) * *(_DWORD *)(v38 + 56)));
          uint64_t v62 = v58;
          size_t v63 = v54;
        }
        else
        {
          memmove(*(void **)(v18 + 32), &v58[4 * *(_DWORD *)(v38 + 56) * v57], __len);
          uint64_t v59 = *(void *)(v18 + 24);
          uint64_t v60 = *(void *)(v18 + 32)
              + 4 * ((*(_DWORD *)(v38 + 212) - *(_DWORD *)(v38 + 60)) * *(_DWORD *)(v38 + 56));
          unsigned int v61 = (const void *)(v59 + 4 * get_padded_len(1, 8u));
          uint64_t v62 = (void *)v60;
          size_t v63 = v146;
        }
        memcpy(v62, v61, v63);
      }
      uint64_t v65 = &v144[((v53 - *(_DWORD *)(v38 + 356)) * v146)];
      uint64_t v66 = *(void *)(v18 + 24);
      unsigned int padded_len = get_padded_len(1, 8u);
      memcpy(v65, (const void *)(v66 + 4 * padded_len), v146);
      uint64_t alignment = get_alignment(*(void *)(v38 + 296), v68, v69, v70, v71, v72, v73, v74);
      if (v40 < 2)
      {
        unsigned int v82 = 0;
        unint64_t v84 = v147;
        uint64_t v85 = v149;
        unsigned int v86 = v145;
      }
      else
      {
        unsigned int v82 = 0;
        uint64_t v83 = 1;
        unint64_t v84 = v147;
        uint64_t v85 = v149;
        unsigned int v86 = v145;
        do
        {
          if (*(float *)(alignment + 4 * v83) > *(float *)(alignment + 4 * v82)) {
            unsigned int v82 = v83;
          }
          ++v83;
        }
        while (v40 != v83);
      }
      if (v53 <= v84)
      {
        if (v53 == v84)
        {
          *unsigned int v86 = 0;
          if (v85 >= 2)
          {
            uint64_t v89 = v149 - 1;
            int v90 = v140;
            do
            {
              *v90++ = v82;
              --v89;
            }
            while (v89);
          }
        }
      }
      else
      {
        if (v82 <= v86[((v53 - v84) * v85 - 1)]) {
          unsigned int v82 = v86[((v53 - v84) * v85 - 1)];
        }
        if (v85)
        {
          uint64_t v87 = v85;
          int v88 = v148;
          do
          {
            v86[v88++] = v82;
            --v87;
          }
          while (v87);
        }
      }
      v91.n128_f32[0] = get_last_alignment(*(void *)(v38 + 296), (float *)v157, v76, v77, v78, v79, v80, v81);
      if (v55)
      {
LABEL_72:
        uint64_t bytes = v55;
        goto LABEL_8;
      }
      uint64_t v52 = v152;
      if (v53 > v40 >> 2)
      {
        if (**(float **)(v18 + 24) > *(float *)(v38 + 232)
          || (v91.n128_u32[0] = v157[0], *(float *)v157 > *(float *)(v38 + 236)))
        {
LABEL_73:
          LODWORD(v53) = v53 + 1;
          int v93 = __dst;
          bzero(&__dst[((v53 - *(_DWORD *)(v38 + 356)) * v146)], v146);
          **(_DWORD **)(v38 + 368) = 1;
LABEL_74:
          uint64_t v92 = v153;
          LODWORD(v51) = *(_DWORD *)(v38 + 228);
          goto LABEL_75;
        }
        if (v53 <= v143)
        {
          if (v53 > v142) {
            goto LABEL_73;
          }
        }
        else if (v53 > v142 || v86[((v53 - v143) * v149)] == v40 - 1)
        {
          goto LABEL_73;
        }
      }
      if (v53 >= *(unsigned int *)(v38 + 360)
        && v53 > ((int)v149 - 1 + *(_DWORD *)(v38 + 212)) / v149 + v84
        && v86[((v53 - v84) * v149)] > v86[((v53 - v84 - 1) * v149)])
      {
        break;
      }
      ++v53;
      unint64_t v51 = *(unsigned int *)(v38 + 228);
      v148 += v149;
      if (v53 >= v51)
      {
        uint64_t v92 = v153;
        int v93 = __dst;
        goto LABEL_75;
      }
    }
    uint64_t bytes = (*(uint64_t (**)(__n128))(*(void *)(v38 + 296) + 208))(v91);
    if (!bytes)
    {
      **(_DWORD **)(v38 + 368) = 0;
      LODWORD(v53) = v53 + 1;
      int v93 = __dst;
      goto LABEL_74;
    }
    goto LABEL_8;
  }
  int v93 = __dst;
  LODWORD(v53) = *(_DWORD *)(v38 + 356);
  uint64_t v92 = v153;
LABEL_75:
  if (v53 >= v51) {
    **(_DWORD **)(v38 + 368) = 1;
  }
  int v95 = v53 - *(_DWORD *)(v92 + 356);
  uint64_t v96 = *(void *)(a2 + 120);
  long long v97 = *(uint64_t **)a2;
  v157[0] = 0;
  v157[1] = 0;
  int v158 = 0;
  unsigned int v156 = 0;
  unsigned int v98 = *(_DWORD *)(v96 + 56);
  int v99 = *(_DWORD *)(v96 + 60) * v95;
  int v161 = v99;
  uint64_t v162 = v98;
  if ((*(_DWORD *)(v96 + 356) + v95) < *(_DWORD *)(v96 + 228) && **(_DWORD **)(v96 + 368) == 1)
  {
    bzero(&v93[4 * (*(_DWORD *)(v96 + 212) + v99) * v98], 4 * *(_DWORD *)(v96 + 212) * v98);
    int v161 = *(_DWORD *)(v96 + 212) + v99;
  }
  uint64_t bytes = fi_shape_set(2, (uint64_t)&v161, 4, (uint64_t)v157);
  if (!bytes)
  {
    uint64_t bytes = (*(uint64_t (**)(void))(*(void *)(v96 + 304) + 144))();
    if (!bytes)
    {
      uint64_t bytes = (*(uint64_t (**)(void))(*(void *)(v96 + 312) + 144))();
      if (!bytes)
      {
        long long v100 = *(uint64_t (**)(void))(*(void *)(v96 + 304) + 160);
        if (!v100 || (uint64_t bytes = v100(), !bytes))
        {
          uint64_t v101 = *(uint64_t (**)(void))(*(void *)(v96 + 312) + 160);
          if (!v101 || (uint64_t bytes = v101(), !bytes))
          {
            uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v96 + 304) + 40), &v156);
            if (!bytes)
            {
              bzero(*(void **)(v18 + 40), v156);
              uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v96 + 312) + 40), &v156);
              if (!bytes)
              {
                bzero(*(void **)(v18 + 48), v156);
                if (*(_DWORD *)(v96 + 328)
                  || (uint64_t bytes = reset_lstm_layer_hidden(*(void *)(v96 + 304), v102, v103, v104, v105, v106, v107, v108),
                      !bytes)
                  && (uint64_t bytes = reset_lstm_layer_hidden(*(void *)(v96 + 312), v112, v113, v114, v115, v116, v117, v118),
                      !bytes))
                {
                  uint64_t v109 = forward_lstm_layer_f32(*(void *)(v96 + 304), (uint64_t)&v93[4 * *(_DWORD *)(v96 + 212) * *(_DWORD *)(v96 + 56)], *(void *)(v18 + 40));
                  if (v109)
                  {
                    uint64_t bytes = v109;
                    uint64_t v31 = "tacotron_stream post lstm1 forward failed!";
LABEL_106:
                    uint64_t v30 = *v97;
                    goto LABEL_7;
                  }
                  uint64_t v119 = forward_lstm_layer_f32(*(void *)(v96 + 312), *(void *)(v18 + 40), *(void *)(v18 + 48));
                  if (v119)
                  {
                    uint64_t bytes = v119;
                    uint64_t v31 = "tacotron_stream post lstm2 forward failed!";
                    goto LABEL_106;
                  }
                  if (*(_DWORD *)(v96 + 216)) {
                    axpy(v156 >> 2, *(float **)(v18 + 40), 1, *(float **)(v18 + 48), 1, 1.0);
                  }
                  uint64_t bytes = (*(uint64_t (**)(void))(*(void *)(v96 + 320) + 144))();
                  if (bytes) {
                    goto LABEL_8;
                  }
                  uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v96 + 320) + 40), (_DWORD *)&v155 + 1);
                  if (bytes) {
                    goto LABEL_8;
                  }
                  if (*(_DWORD *)(v96 + 208) == *(_DWORD *)(v96 + 56))
                  {
                    uint64_t v123 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(v97[1] + 16))(v97[2], (unint64_t)HIDWORD(v155) >> 2, 4);
                    if (!v123)
                    {
                      uint64_t bytes = 10;
                      uint64_t v31 = "Memory allocation failed!";
                      goto LABEL_106;
                    }
                    int v124 = (float *)v123;
                    uint64_t v125 = (*(uint64_t (**)(uint64_t))(*(void *)(v96 + 320) + 128))(v152);
                    if (v125)
                    {
                      uint64_t bytes = v125;
                      log_OutText(*v97, (uint64_t)"FastInfer", 0, 0, (uint64_t)"tacotron_stream post dense forward failed!", v126, v127, v128, v139);
                      goto LABEL_129;
                    }
                    axpy(HIDWORD(v155) >> 2, v124, 1, (float *)__dst, 1, 1.0);
                  }
                  else
                  {
                    bzero(__dst, HIDWORD(v155));
                    uint64_t v129 = (*(uint64_t (**)(uint64_t))(*(void *)(v96 + 320) + 128))(v152);
                    if (v129)
                    {
                      uint64_t bytes = v129;
                      uint64_t v31 = "tacotron_stream post dense forward failed!";
                      goto LABEL_106;
                    }
                    int v124 = 0;
                  }
                  if (*(_DWORD *)(v96 + 80) == 2 && *(_DWORD *)(v96 + 220) != 1) {
                    relu_array_f32(HIDWORD(v155) >> 2, (float *)__dst);
                  }
                  if (!v124)
                  {
                    uint64_t v130 = v153;
                    goto LABEL_132;
                  }
                  uint64_t bytes = 0;
LABEL_129:
                  (*(void (**)(uint64_t, float *))(v97[1] + 48))(v97[2], v124);
                  uint64_t v130 = v153;
                  if (bytes) {
                    goto LABEL_8;
                  }
LABEL_132:
                  if (*(_DWORD *)(v130 + 328) && (*(_DWORD *)(v153 + 356) || **(_DWORD **)(v153 + 368)))
                  {
                    int v131 = 0;
                  }
                  else if (v95 * v150 >= (*(_DWORD *)(v153 + 212) + *(_DWORD *)(v153 + 240) * v150))
                  {
                    int v131 = *(_DWORD *)(v153 + 212) + *(_DWORD *)(v153 + 240) * v150;
                  }
                  else
                  {
                    int v131 = v95 * v150;
                  }
                  if (*(_DWORD *)(v153 + 220) == 1)
                  {
                    unsigned int v132 = HIDWORD(v155) >> 2;
                    if (HIDWORD(v155) >= 4)
                    {
                      if (v132 <= 1) {
                        uint64_t v133 = 1;
                      }
                      else {
                        uint64_t v133 = v132;
                      }
                      uint64_t v134 = (float *)__dst;
                      do
                      {
                        float v135 = *v134;
                        if (*v134 > 1.0) {
                          float v135 = 1.0;
                        }
                        if (v135 < 0.0) {
                          float v135 = 0.0;
                        }
                        *v134++ = (float)(v135 * 11.513) + -9.2103;
                        --v133;
                      }
                      while (v133);
                    }
                    fast_exp((float *)__dst, v132, (float *)__dst);
                  }
                  uint64_t v136 = (int *)(a2 + 40);
                  uint64_t bytes = fi_shape_get_bytes(v136, &v155);
                  if (!bytes)
                  {
                    if (v155 != HIDWORD(v155)) {
                      *(_DWORD *)(v151 + 20) = 1;
                    }
                    LODWORD(v159) = v95 * v150 - v131;
                    if (**(_DWORD **)(v153 + 368) == 1) {
                      LODWORD(v159) = *(_DWORD *)(v153 + 212) + v95 * v150 - v131;
                    }
                    HIDWORD(v159) = *(_DWORD *)(v153 + 208);
                    uint64_t bytes = fi_shape_set(2, (uint64_t)&v159, 4, (uint64_t)v136);
                    if (!bytes)
                    {
                      if (v131) {
                        memmove(__dst, &__dst[4 * HIDWORD(v159) * v131], 4 * (v159 * HIDWORD(v159)));
                      }
                      int v137 = (v53 - *(_DWORD *)(v153 + 240)) * v150;
                      float v138 = *(_DWORD **)(v153 + 344);
                      *float v138 = v137;
                      if (!**(_DWORD **)(v153 + 368)) {
                        *float v138 = v137 - *(_DWORD *)(v153 + 212);
                      }
                      uint64_t bytes = 0;
                      *(_DWORD *)(v153 + 356) = v53;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_8:
  (*(void (**)(uint64_t, uint64_t))(v11[1] + 48))(v11[2], v18);
  return bytes;
}

uint64_t tacotron_stream_update_shape(uint64_t a1, _DWORD *a2)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a1 + 120);
  int v34 = 0;
  int v5 = a2[4];
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v5;
  unsigned int v6 = *(_DWORD *)(v4 + 224);
  if (*(_DWORD *)(a1 + 24) > v6) {
    *(_DWORD *)(a1 + 24) = v6;
  }
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(v4 + 264) + 144))();
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(v4 + 272) + 144))();
    if (!result)
    {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(v4 + 280) + 144))();
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(v4 + 288) + 144))();
        if (!result)
        {
          v30[0] = 0;
          v30[1] = 0;
          int v31 = 0;
          v28[0] = 0;
          v28[1] = 0;
          int v29 = 0;
          int step = fi_shape_get_step(a2);
          int v9 = *(_DWORD *)(v4 + 4) + 2 * *(_DWORD *)(v4 + 48);
          int v32 = step;
          unsigned int v33 = v9;
          uint64_t result = fi_shape_set(2, (uint64_t)&v32, 4, (uint64_t)v28);
          if (!result)
          {
            uint64_t result = (*(uint64_t (**)(void, void *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 296) + 144))(*(void *)(v4 + 296), v28, v10, v11, v12, v13);
            if (!result)
            {
              unsigned int v14 = *(_DWORD *)(v4 + 56);
              int v32 = *(_DWORD *)(v4 + 60) + *(_DWORD *)(v4 + 60) * *(_DWORD *)(v4 + 228) + *(_DWORD *)(v4 + 212);
              unsigned int v33 = v14;
              uint64_t result = fi_shape_set(2, (uint64_t)&v32, 4, (uint64_t)v30);
              if (!result)
              {
                uint64_t result = (*(uint64_t (**)(void, void *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 304) + 144))(*(void *)(v4 + 304), v30, v15, v16, v17, v18);
                if (!result)
                {
                  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 312) + 144))(*(void *)(v4 + 312), *(void *)(v4 + 304) + 40, v19, v20, v21, v22);
                  if (!result)
                  {
                    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 320) + 144))(*(void *)(v4 + 320), *(void *)(v4 + 312) + 40, v23, v24, v25, v26);
                    if (!result)
                    {
                      unsigned int v27 = *(_DWORD *)(v4 + 208);
                      if (v27 <= 0x100) {
                        unsigned int v27 = 256;
                      }
                      unsigned int v33 = v27;
                      return fi_shape_set(2, (uint64_t)&v32, 4, a1 + 40);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t tacotron_stream_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 120);
  uint64_t v22 = 0;
  if (v8)
  {
    int padded_len = get_padded_len(*(unsigned int *)(v8 + 4), 8u);
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 264) + 152))();
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(HIDWORD(v22) + (padded_len << 9) + (int)v22, 8u);
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 272) + 152))();
      if (!result)
      {
        int v14 = get_padded_bytes(HIDWORD(v22) + (int)v22 + padded_bytes, 8u);
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 280) + 152))();
        if (!result)
        {
          int v15 = get_padded_bytes(HIDWORD(v22) + (int)v22 + v14, 8u);
          uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 288) + 152))();
          if (!result)
          {
            int v16 = get_padded_bytes(HIDWORD(v22) + (int)v22 + v15, 8u);
            uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 296) + 152))();
            if (!result)
            {
              int v17 = get_padded_bytes(HIDWORD(v22) + (int)v22 + v16, 8u);
              uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 304) + 152))();
              if (!result)
              {
                int v18 = get_padded_bytes(HIDWORD(v22) + (int)v22 + v17, 8u);
                uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 312) + 152))();
                if (!result)
                {
                  int v19 = get_padded_bytes(HIDWORD(v22) + (int)v22 + v18, 8u);
                  uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 320) + 152))();
                  if (!result)
                  {
                    int v20 = get_padded_bytes(HIDWORD(v22) + (int)v22 + v19, 8u);
                    uint64_t result = 0;
                    *a2 = v20;
                    *a3 = 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v21);
    return 7;
  }
  return result;
}

uint64_t tacotron_stream_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 120);
  int v18 = 0;
  if (v9)
  {
    uint64_t result = tacotron_stream_get_reserved_glbBuf_bytes(a1, &v18);
    if (!result)
    {
      uint64_t v11 = 0;
      unsigned int v12 = 0;
      uint64_t v13 = v9 + 264;
      do
      {
        int v14 = *(uint64_t (**)(void))(*(void *)(v13 + v11) + 160);
        if (v14)
        {
          uint64_t result = v14();
          if (result) {
            return result;
          }
          if (*(_DWORD *)(*(void *)(v13 + v11) + 248) > v12) {
            unsigned int v12 = *(_DWORD *)(*(void *)(v13 + v11) + 248);
          }
        }
        v11 += 8;
      }
      while (v11 != 64);
      int v15 = v18;
      padded_uint64_t bytes = get_padded_bytes(v12, 8u);
      uint64_t result = 0;
      *(_DWORD *)(a1 + 248) = padded_bytes + v15;
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t tacotron_stream_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 120);
  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 72);
    padded_uint64_t bytes = get_padded_len(*(unsigned int *)(v8 + 4), 8u) << 9;
    uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 264), v9, &padded_bytes);
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
      uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 272), v9, &padded_bytes);
      if (!result)
      {
        padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
        uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 280), v9, &padded_bytes);
        if (!result)
        {
          padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
          uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 288), v9, &padded_bytes);
          if (!result)
          {
            padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
            uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 296), v9, &padded_bytes);
            if (!result)
            {
              padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
              uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 304), v9, &padded_bytes);
              if (!result)
              {
                padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
                uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 312), v9, &padded_bytes);
                if (!result)
                {
                  padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
                  uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 320), v9, &padded_bytes);
                  if (!result)
                  {
                    get_padded_bytes(padded_bytes, 8u);
                    return 0;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v11);
    return 7;
  }
  return result;
}

uint64_t tacotron_stream_assign_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 120);
  unsigned int v22 = 0;
  reserved_glbBuf_uint64_t bytes = tacotron_stream_get_reserved_glbBuf_bytes(a1, &v22);
  if (!reserved_glbBuf_bytes)
  {
    uint64_t v4 = v2[33];
    uint64_t v5 = v22;
    *(void *)(v4 + 240) = *(void *)(a1 + 240) + v22;
    unsigned int v6 = *(void (**)(void))(v4 + 168);
    if (v6) {
      v6();
    }
    uint64_t v7 = v2[34];
    *(void *)(v7 + 240) = *(void *)(a1 + 240) + v5;
    uint64_t v8 = *(void (**)(void))(v7 + 168);
    if (v8) {
      v8();
    }
    uint64_t v9 = v2[35];
    *(void *)(v9 + 240) = *(void *)(a1 + 240) + v5;
    uint64_t v10 = *(void (**)(void))(v9 + 168);
    if (v10) {
      v10();
    }
    uint64_t v11 = v2[36];
    *(void *)(v11 + 240) = *(void *)(a1 + 240) + v5;
    unsigned int v12 = *(void (**)(void))(v11 + 168);
    if (v12) {
      v12();
    }
    uint64_t v13 = v2[37];
    *(void *)(v13 + 240) = *(void *)(a1 + 240) + v5;
    int v14 = *(void (**)(void))(v13 + 168);
    if (v14) {
      v14();
    }
    uint64_t v15 = v2[38];
    *(void *)(v15 + 240) = *(void *)(a1 + 240) + v5;
    int v16 = *(void (**)(void))(v15 + 168);
    if (v16) {
      v16();
    }
    uint64_t v17 = v2[39];
    *(void *)(v17 + 240) = *(void *)(a1 + 240) + v5;
    int v18 = *(void (**)(void))(v17 + 168);
    if (v18) {
      v18();
    }
    uint64_t v19 = v2[40];
    *(void *)(v19 + 240) = *(void *)(a1 + 240) + v5;
    int v20 = *(void (**)(void))(v19 + 168);
    if (v20) {
      v20();
    }
  }
  return reserved_glbBuf_bytes;
}

uint64_t tacotron_stream_update_param(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (*(_DWORD *)(a1 + 8) != a4) {
    return 0;
  }
  if (a3 != 40) {
    return 7;
  }
  uint64_t v4 = *(void *)(a1 + 120);
  int v5 = *(_DWORD *)(a2 + 20);
  if (v5 == 1)
  {
    int v6 = *(_DWORD *)(a2 + 24);
    *(_DWORD *)(v4 + 328) = v6 == 0;
    *(_DWORD *)(v4 + 332) = 1;
    if (!v6)
    {
      uint64_t result = 0;
      *(_DWORD *)(v4 + 360) = *(_DWORD *)(a2 + 28) / *(_DWORD *)(v4 + 60) + *(_DWORD *)(v4 + 356);
      int v8 = *(_DWORD *)(a2 + 16);
      *(_DWORD *)uint64_t v4 = v8;
      *(_DWORD *)(v4 + 352) = v8;
      return result;
    }
  }
  else
  {
    *(_DWORD *)(v4 + 328) = 0;
    *(_DWORD *)(v4 + 332) = v5;
  }
  *(_DWORD *)(v4 + 360) = *(_DWORD *)(a2 + 28) / *(_DWORD *)(v4 + 60);
  int v9 = *(_DWORD *)(a2 + 16);
  *(_DWORD *)uint64_t v4 = v9;
  *(_DWORD *)(v4 + 352) = v9;
  if (v5)
  {
    if (*(_DWORD *)(a2 + 24) != 1) {
      return 0;
    }
  }
  uint64_t result = 0;
  *(void *)(v4 + 344) = *(void *)a2;
  *(void *)(v4 + 368) = *(void *)(a2 + 32);
  return result;
}

uint64_t tacotron_stream_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = *(void *)(a1 + 120);
  unsigned int v7 = 0;
  int v4 = 4 * get_padded_len(*(unsigned int *)(v3 + 68), 8u) * *(_DWORD *)(v3 + 224);
  uint64_t result = fi_shape_get_bytes((int *)(*(void *)(v3 + 296) + 40), &v7);
  if (!result)
  {
    int v6 = get_padded_bytes(v7, 8u) + v4;
    int v4 = v6 + get_padded_bytes(4 * *(_DWORD *)(v3 + 212) * *(_DWORD *)(v3 + 208), 8u);
    uint64_t result = fi_shape_get_bytes((int *)(*(void *)(v3 + 304) + 40), &v7);
    if (!result)
    {
      v4 += get_padded_bytes(v7, 8u);
      uint64_t result = fi_shape_get_bytes((int *)(*(void *)(v3 + 312) + 40), &v7);
      if (!result)
      {
        v4 += get_padded_bytes(v7, 8u);
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(v3 + 296) + 216))();
        if (!result) {
          v4 += 4 * v7;
        }
      }
    }
  }
  *a2 = v4;
  return result;
}

uint64_t create_multiband_lpcnet_layer(uint64_t *a1, long long *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v11)
  {
    uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 416);
    uint64_t v16 = v12;
    if (v12)
    {
      long long v17 = *a2;
      long long v18 = a2[1];
      long long v19 = a2[3];
      *(_OWORD *)(v12 + 32) = a2[2];
      *(_OWORD *)(v12 + 48) = v19;
      *(_OWORD *)uint64_t v12 = v17;
      *(_OWORD *)(v12 + 16) = v18;
      long long v20 = a2[4];
      long long v21 = a2[5];
      long long v22 = a2[7];
      *(_OWORD *)(v12 + 96) = a2[6];
      *(_OWORD *)(v12 + 112) = v22;
      *(_OWORD *)(v12 + 64) = v20;
      *(_OWORD *)(v12 + 80) = v21;
      long long v23 = a2[8];
      long long v24 = a2[9];
      long long v25 = a2[11];
      *(_OWORD *)(v12 + 160) = a2[10];
      *(_OWORD *)(v12 + 176) = v25;
      *(_OWORD *)(v12 + 128) = v23;
      *(_OWORD *)(v12 + 144) = v24;
      long long v26 = a2[12];
      long long v27 = a2[13];
      long long v28 = a2[14];
      *(_DWORD *)(v12 + 240) = *((_DWORD *)a2 + 60);
      *(_OWORD *)(v12 + 208) = v27;
      *(_OWORD *)(v12 + 224) = v28;
      *(_OWORD *)(v12 + 192) = v26;
      int v58 = 0;
      long long v56 = 0u;
      long long v57 = 0u;
      if (a2)
      {
        int v29 = *((_DWORD *)a2 + 25);
        unsigned int v30 = *((_DWORD *)a2 + 26);
        LODWORD(v60) = 5;
        HIDWORD(v60) = v29;
        int v61 = 0;
        uint64_t v59 = v30 | 0x100000000;
        uint64_t v31 = create_fc_layer(a1, &v60, &v59, 0, a3, (uint64_t *)(v12 + 264));
        if (v31)
        {
          uint64_t v35 = v31;
          uint64_t v36 = *a1;
          uint64_t v37 = "create feature_dense1 failed!";
        }
        else
        {
          unsigned int v44 = *((_DWORD *)a2 + 28);
          HIDWORD(v60) = *((_DWORD *)a2 + 27);
          uint64_t v59 = v44 | 0x100000000;
          uint64_t v45 = create_fc_layer(a1, &v60, &v59, 0, a3, (uint64_t *)(v16 + 272));
          if (v45)
          {
            uint64_t v35 = v45;
            uint64_t v36 = *a1;
            uint64_t v37 = "create feature_dense2 failed!";
          }
          else
          {
            unsigned int v46 = *((_DWORD *)a2 + 30);
            HIDWORD(v60) = *((_DWORD *)a2 + 29);
            uint64_t v59 = v46 | 0x100000000;
            uint64_t v47 = create_fc_layer(a1, &v60, &v59, 0, a3, (uint64_t *)(v16 + 280));
            if (v47)
            {
              uint64_t v35 = v47;
              uint64_t v36 = *a1;
              uint64_t v37 = "create gru_a_dense failed!";
            }
            else
            {
              HIDWORD(v60) = 2 * *((_DWORD *)a2 + 44);
              LODWORD(v59) = *((_DWORD *)a2 + 46);
              HIDWORD(v59) = 1;
              uint64_t v48 = create_fc_layer(a1, &v60, &v59, 0, a3, (uint64_t *)(v16 + 288));
              if (v48)
              {
                uint64_t v35 = v48;
                uint64_t v36 = *a1;
                uint64_t v37 = "create dual_fc_a failed!";
              }
              else
              {
                uint64_t v49 = create_fc_layer(a1, &v60, &v59, 0, a3, (uint64_t *)(v16 + 296));
                if (v49)
                {
                  uint64_t v35 = v49;
                  uint64_t v36 = *a1;
                  uint64_t v37 = "create dual_fc_b failed!";
                }
                else
                {
                  uint64_t v50 = create_fc_layer(a1, &v60, &v59, 0, a3, (uint64_t *)(v16 + 304));
                  if (v50)
                  {
                    uint64_t v35 = v50;
                    uint64_t v36 = *a1;
                    uint64_t v37 = "create dual_fc_c failed!";
                  }
                  else
                  {
                    if (*((_DWORD *)a2 + 48) == 1)
                    {
                      HIDWORD(v60) = *((_DWORD *)a2 + 44);
                      LODWORD(v59) = *((_DWORD *)a2 + 47);
                      HIDWORD(v59) = 1;
                    }
                    uint64_t v51 = create_fc_layer(a1, &v60, &v59, 0, a3, (uint64_t *)(v16 + 312));
                    if (v51)
                    {
                      uint64_t v35 = v51;
                      uint64_t v36 = *a1;
                      uint64_t v37 = "create dual_fc_d failed!";
                    }
                    else
                    {
                      uint64_t v52 = config_conv1d_layer(*((_DWORD *)a2 + 20), *((_DWORD *)a2 + 19), 1, 1, 1, 1, *((_DWORD *)a2 + 21), &v56);
                      if (v52)
                      {
                        uint64_t v35 = v52;
                        uint64_t v36 = *a1;
                        uint64_t v37 = "create conv1d_proj sub-conv1d_norm1 cfg failed!";
                      }
                      else
                      {
                        uint64_t v53 = create_conv1d_layer(a1, &v56, 0, a3, (uint64_t ***)(v16 + 248));
                        if (v53)
                        {
                          uint64_t v35 = v53;
                          uint64_t v36 = *a1;
                          uint64_t v37 = "create feature_conv1 layer failed!";
                        }
                        else
                        {
                          int v54 = *((_DWORD *)a2 + 23);
                          int v58 = *((_DWORD *)a2 + 24);
                          LODWORD(v56) = *((_DWORD *)a2 + 22);
                          LODWORD(v57) = v54;
                          uint64_t v35 = create_conv1d_layer(a1, &v56, 0, a3, (uint64_t ***)(v16 + 256));
                          if (!v35)
                          {
                            *(void *)uint64_t v11 = a1;
                            *(void *)(v11 + 8) = 67;
                            *(_DWORD *)(v11 + 16) = 0;
                            *(void *)(v11 + 120) = v16;
                            *(void *)(v11 + 128) = forward_multiband_lpcnet_layer;
                            *(void *)(v11 + 144) = multiband_lpcnet_update_shape;
                            *(void *)(v11 + 136) = free_multiband_lpcnet;
                            *(void *)(v11 + 152) = multiband_lpcnet_wanted_wb_len;
                            *(void *)(v11 + 160) = multiband_lpcnet_request_glbBuf;
                            *(void *)(v11 + 184) = multiband_lpcnet_dispatch_weights;
                            *(void *)(v11 + 168) = multiband_lpcnet_assign_glbBuf;
                            *(void *)(v11 + 224) = multiband_lpcnet_update_param;
                            goto LABEL_32;
                          }
                          uint64_t v36 = *a1;
                          uint64_t v37 = "create feature_conv2 layer failed!";
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        log_OutText(v36, (uint64_t)"FastInfer", 0, 0, (uint64_t)v37, v32, v33, v34, v56);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", v13, v14, v15, v56);
        uint64_t v35 = 7;
      }
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"LPCNet init failed!", v41, v42, v43, v56);
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v13, v14, v15, v56);
      uint64_t v35 = 10;
    }
    *(void *)(v11 + 120) = v16;
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"multiband_lpcnet init param failed!", v38, v39, v40, v56);
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v56);
    uint64_t v35 = 10;
  }
LABEL_32:
  *a4 = v11;
  return v35;
}

uint64_t forward_multiband_lpcnet_layer(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, uint64_t a5)
{
  uint64_t v363 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(uint64_t **)a2;
  uint64_t v10 = *(void *)(a2 + 120);
  uint64_t v353 = 0;
  unsigned int v11 = *(_DWORD *)(a2 + 24);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v9[1] + 16))(v9[2], 1, 352);
  if (!v15)
  {
    log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v303);
    uint64_t weights_via_offset = 10;
    goto LABEL_33;
  }
  if (!*(_DWORD *)(v10 + 320)) {
    goto LABEL_9;
  }
  int v16 = *(_DWORD *)(v10 + 332);
  if ((v16 - 1) < 2) {
    goto LABEL_6;
  }
  if (v16)
  {
    if (v16 != 5)
    {
      uint64_t weights_via_offset = 7;
      goto LABEL_33;
    }
LABEL_6:
    if (v11 >= 2) {
      v11 -= 2;
    }
    else {
      unsigned int v11 = 0;
    }
  }
LABEL_9:
  uint64_t v345 = a3;
  uint64_t v347 = a4;
  unsigned int v343 = v11;
  uint64_t v344 = a5;
  uint64_t v351 = v9;
  uint64_t v352 = v10;
  uint64_t v348 = a2;
  uint64_t v349 = *(uint64_t **)a2;
  uint64_t v17 = *(void *)(a2 + 120);
  uint64_t v18 = *(void *)(a2 + 240);
  int v19 = *(_DWORD *)(v17 + 36);
  uint64_t v20 = *(void *)(a2 + 72);
  LODWORD(v354) = 0;
  int v21 = *(_DWORD *)(v17 + 204);
  int step = fi_shape_get_step((_DWORD *)(a2 + 20));
  *(void *)(v15 + 16) = v18;
  int padded_len = get_padded_len(*(unsigned int *)(v17 + 136), 8u);
  *(void *)(v15 + 24) = v18 + (4 * padded_len);
  int v24 = get_padded_len(*(unsigned int *)(v17 + 152), 8u) + padded_len;
  *(void *)(v15 + 32) = v18 + (4 * v24);
  int v25 = get_padded_len((3 * *(_DWORD *)(v17 + 172)), 8u) + v24;
  *(void *)(v15 + 40) = v18 + (4 * v25);
  int v26 = get_padded_len((3 * *(_DWORD *)(v17 + 172)), 8u) + v25;
  *(void *)(v15 + 48) = v18 + (4 * v26);
  int v27 = get_padded_len((3 * *(_DWORD *)(v17 + 136)), 8u) + v26;
  *(void *)(v15 + 56) = v18 + (4 * v27);
  int v28 = get_padded_len((3 * *(_DWORD *)(v17 + 136)), 8u) + v27;
  *(void *)(v15 + 64) = v18 + (4 * v28);
  int v29 = get_padded_len((3 * *(_DWORD *)(v17 + 136)), 8u) + v28;
  *(void *)(v15 + 72) = v18 + (4 * v29);
  uint64_t v30 = 12 * get_padded_len(*(unsigned int *)(v17 + 176), 8u) + 4 * v29;
  *(void *)(v15 + 80) = v18 + v30;
  int v31 = get_padded_len((3 * *(_DWORD *)(v17 + 152)), 8u);
  *(void *)(v15 + 88) = v18 + (v30 + 4 * v31);
  int v32 = get_padded_len((2 * *(_DWORD *)(v17 + 176)), 8u) + v31;
  *(void *)(v15 + 96) = v18 + (v30 + 4 * v32);
  int v33 = get_padded_len(*(unsigned int *)(v17 + 44), 8u) + v32;
  *(void *)(v15 + 104) = v18 + (v30 + 4 * v33);
  int v34 = get_padded_len(*(unsigned int *)(v17 + 44), 8u) + v33;
  *(void *)(v15 + 112) = v18 + (v30 + 4 * v34);
  int v35 = get_padded_len(*(unsigned int *)(v17 + 44), 8u) + v34;
  *(void *)(v15 + 120) = v18 + (v30 + 4 * v35);
  int v36 = get_padded_len(*(unsigned int *)(v17 + 44), 8u) + v35;
  *(void *)(v15 + 168) = v18 + (v30 + 4 * v36);
  int v37 = get_padded_len((*(_DWORD *)(v17 + 44) * step * *(_DWORD *)(v17 + 56)), 8u) + v36;
  *(void *)(v15 + 152) = v18 + (v30 + 4 * v37);
  int v38 = get_padded_len((*(_DWORD *)(v17 + 108) * step), 8u) + v37;
  uint64_t v39 = v18 + (v30 + 4 * v38);
  *(void *)(v15 + 160) = v39;
  *(void *)(v15 + 128) = v39;
  int v40 = get_padded_len((*(_DWORD *)(v17 + 80) * step), 8u) + v38;
  *(void *)(v15 + 136) = v18 + (v30 + 4 * v40);
  *(void *)(v15 + 144) = v18
                         + v30
                         + 4 * (get_padded_len((*(_DWORD *)(v17 + 92) * step), 8u) + v40);
  get_padded_len((*(_DWORD *)(v17 + 100) * step), 8u);
  unsigned int v41 = *(_DWORD *)(v17 + 116);
  if (v41 <= *(_DWORD *)(v17 + 92) + *(_DWORD *)(v17 + 80) + *(_DWORD *)(v17 + 100)) {
    unsigned int v41 = *(_DWORD *)(v17 + 92) + *(_DWORD *)(v17 + 80) + *(_DWORD *)(v17 + 100);
  }
  if (v41 <= 0x14A) {
    unsigned int v41 = 330;
  }
  *(void *)(v15 + 176) = v18 + v30 + 4 * (get_padded_len(v41 * step, 8u) + v38);
  get_padded_bytes((*(_DWORD *)(v17 + 24) & 0xFFFFFFF8)+ 8 * *(_DWORD *)(v17 + 44)+ (*(_DWORD *)(v17 + 24) & 0xFFFFFFFC)+ 4 * (*(_DWORD *)(v17 + 28) + v19)+ 2 * (*(_DWORD *)(v17 + 24) & 0xFFFFFFFC)+ 20, 8u);
  int v42 = v354;
  unint64_t v43 = (unint64_t)v354 >> 2;
  *(void *)(v15 + 184) = v20 + 4 * v43;
  int v44 = *(_DWORD *)(v17 + 124) * get_padded_len(*(unsigned int *)(v17 + 116), 8u);
  if (v21 == 1) {
    char v45 = 1;
  }
  else {
    char v45 = 2;
  }
  *(void *)(v15 + 192) = v20 + 4 * (((v44 << v45) + v43) & 0x3FFFFFFF);
  int v46 = v44 + *(_DWORD *)(v17 + 128) * get_padded_len(*(unsigned int *)(v17 + 116), 8u);
  *(void *)(v15 + 200) = v20 + 4 * (((v46 << v45) + v43) & 0x3FFFFFFF);
  LODWORD(v354) = v42
                + 4
                * ((v46 + *(_DWORD *)(v17 + 132) * get_padded_len(*(unsigned int *)(v17 + 116), 8u)) << v45);
  uint64_t weights_via_offset = fi_layer_find_weights_via_offset(*(void *)(v17 + 248), v20, &v354);
  if (weights_via_offset) {
    goto LABEL_30;
  }
  LODWORD(v354) = get_padded_bytes(v354, 8u);
  uint64_t weights_via_offset = fi_layer_find_weights_via_offset(*(void *)(v17 + 256), v20, &v354);
  if (weights_via_offset) {
    goto LABEL_30;
  }
  LODWORD(v354) = get_padded_bytes(v354, 8u);
  uint64_t weights_via_offset = fi_layer_find_weights_via_offset(*(void *)(v17 + 264), v20, &v354);
  if (weights_via_offset) {
    goto LABEL_30;
  }
  LODWORD(v354) = get_padded_bytes(v354, 8u);
  uint64_t weights_via_offset = fi_layer_find_weights_via_offset(*(void *)(v17 + 272), v20, &v354);
  if (weights_via_offset) {
    goto LABEL_30;
  }
  LODWORD(v354) = get_padded_bytes(v354, 8u);
  uint64_t weights_via_offset = fi_layer_find_weights_via_offset(*(void *)(v17 + 280), v20, &v354);
  if (weights_via_offset) {
    goto LABEL_30;
  }
  LODWORD(v354) = get_padded_bytes(v354, 8u);
  *(void *)(v15 + 208) = v20 + (v354 & 0xFFFFFFFC);
  int v51 = *(_DWORD *)(v17 + 140);
  LODWORD(v354) = v354 + 4 * (v51 + (get_padded_len((3 * *(_DWORD *)(v17 + 136)), 8u) >> 4));
  padded_uint64_t bytes = get_padded_bytes(v354, 8u);
  *(void *)(v15 + 216) = v20 + (padded_bytes & 0xFFFFFFFC);
  LODWORD(v354) = padded_bytes + 12 * *(_DWORD *)(v17 + 136);
  int v53 = get_padded_bytes(v354, 8u);
  *(void *)(v15 + 224) = v20 + (v53 & 0xFFFFFFFC);
  LODWORD(v354) = v53 + (*(_DWORD *)(v17 + 140) << 6);
  LODWORD(v354) = get_padded_bytes(v354, 8u);
  *(void *)(v15 + 232) = v20 + (v354 & 0xFFFFFFFC);
  LODWORD(v354) = v354 + 4 * get_padded_len((3 * *(_DWORD *)(v17 + 136)), 8u);
  int v54 = get_padded_bytes(v354, 8u);
  LODWORD(v354) = v54;
  int v55 = *(_DWORD *)(v17 + 160);
  *(void *)(v15 + 240) = v20 + (v54 & 0xFFFFFFFC);
  if (v55 == 1)
  {
    LODWORD(v354) = v54 + (*(_DWORD *)(v17 + 164) << 6);
    int v56 = get_padded_bytes(v354, 8u);
    *(void *)(v15 + 272) = v20 + (v56 & 0xFFFFFFFC);
    LODWORD(v354) = v56 + 4 * (*(_DWORD *)(v17 + 164) + ((3 * *(_DWORD *)(v17 + 152) + 15) >> 4));
    int v57 = get_padded_bytes(v354, 8u);
    *(void *)(v15 + 288) = v20 + (v57 & 0xFFFFFFFC);
    LODWORD(v354) = v57 + (*(_DWORD *)(v17 + 168) << 6);
    int v58 = get_padded_bytes(v354, 8u);
    *(void *)(v15 + 280) = v20 + (v58 & 0xFFFFFFFC);
    unsigned int v59 = v58 + 4 * (*(_DWORD *)(v17 + 168) + ((3 * *(_DWORD *)(v17 + 152) + 15) >> 4));
  }
  else
  {
    int v60 = *(_DWORD *)(v17 + 152);
    unsigned int v59 = v354 + 12 * v60 * get_padded_len((*(_DWORD *)(v17 + 136) + *(_DWORD *)(v17 + 108)), 8u);
  }
  LODWORD(v354) = v59;
  LODWORD(v354) = get_padded_bytes(v59, 8u);
  *(void *)(v15 + 248) = v20 + (v354 & 0xFFFFFFFC);
  LODWORD(v354) = v354 + 4 * get_padded_len((3 * *(_DWORD *)(v17 + 152)), 8u);
  LODWORD(v354) = get_padded_bytes(v354, 8u);
  *(void *)(v15 + 256) = v20 + (v354 & 0xFFFFFFFC);
  LODWORD(v354) = v354 + 12 * get_padded_len(*(unsigned int *)(v17 + 152), 8u) * *(_DWORD *)(v17 + 152);
  LODWORD(v354) = get_padded_bytes(v354, 8u);
  *(void *)(v15 + 264) = v20 + (v354 & 0xFFFFFFFC);
  LODWORD(v354) = v354 + 4 * get_padded_len((3 * *(_DWORD *)(v17 + 152)), 8u);
  LODWORD(v354) = get_padded_bytes(v354, 8u);
  uint64_t weights_via_offset = fi_layer_find_weights_via_offset(*(void *)(v17 + 288), v20, &v354);
  if (weights_via_offset) {
    goto LABEL_30;
  }
  LODWORD(v354) = get_padded_bytes(v354, 8u);
  *(void *)(v15 + 296) = v20 + (v354 & 0xFFFFFFFC);
  LODWORD(v354) = v354 + 4 * get_padded_len(*(unsigned int *)(v17 + 176), 8u) * *(_DWORD *)(v17 + 180);
  uint64_t weights_via_offset = fi_layer_find_weights_via_offset(*(void *)(v17 + 296), v20, &v354);
  if (weights_via_offset) {
    goto LABEL_30;
  }
  LODWORD(v354) = get_padded_bytes(v354, 8u);
  *(void *)(v15 + 304) = v20 + (v354 & 0xFFFFFFFC);
  LODWORD(v354) = v354 + 4 * get_padded_len(*(unsigned int *)(v17 + 176), 8u) * *(_DWORD *)(v17 + 180);
  uint64_t weights_via_offset = fi_layer_find_weights_via_offset(*(void *)(v17 + 304), v20, &v354);
  if (weights_via_offset
    || (LODWORD(v354) = get_padded_bytes(v354, 8u),
        *(void *)(v15 + 312) = v20 + (v354 & 0xFFFFFFFC),
        LODWORD(v354) = v354 + 4 * get_padded_len(*(unsigned int *)(v17 + 176), 8u) * *(_DWORD *)(v17 + 180),
        uint64_t weights_via_offset = fi_layer_find_weights_via_offset(*(void *)(v17 + 312), v20, &v354),
        weights_via_offset))
  {
LABEL_30:
    uint64_t v61 = *v349;
    uint64_t v62 = "multiband_lpcnet pack buf manager failed!";
LABEL_31:
    log_OutText(v61, (uint64_t)"FastInfer", 0, 0, (uint64_t)v62, v47, v48, v49, v303);
    goto LABEL_32;
  }
  int v67 = get_padded_bytes(v354, 8u);
  LODWORD(v354) = v67;
  if (*(_DWORD *)(v17 + 192))
  {
    *(void *)(v15 + 320) = 0;
  }
  else
  {
    *(void *)(v15 + 320) = v20 + (v67 & 0xFFFFFFFC);
    int v67 = v354 + 4 * get_padded_len(*(unsigned int *)(v17 + 176), 8u) * *(_DWORD *)(v17 + 180);
    LODWORD(v354) = v67;
  }
  *(void *)(v15 + 328) = v20 + (v67 & 0xFFFFFFFC);
  int v68 = get_padded_len(4096, 8u);
  LODWORD(v354) = v354 + 4 * v68;
  *(void *)(v15 + 336) = v20 + (v354 & 0xFFFFFFFC);
  LODWORD(v354) = v354 + 4 * get_padded_len(*(unsigned int *)(v17 + 60), 8u) * *(_DWORD *)(v17 + 56);
  *(void *)(v15 + 344) = v20 + (v354 & 0xFFFFFFFC);
  get_padded_len(*(unsigned int *)(v17 + 36), 8u);
  *(void *)uint64_t v15 = v345;
  *(void *)(v15 + 8) = v347;
  uint64_t v69 = *(void *)(v348 + 120);
  if (*(_DWORD *)(v352 + 320))
  {
    uint64_t v70 = *(const void **)(v69 + 336);
    if (v70) {
      memcpy(*(void **)(v15 + 96), v70, 4 * *(unsigned int *)(v69 + 44));
    }
    uint64_t v71 = *(const void **)(v69 + 344);
    if (v71) {
      memcpy(*(void **)(v15 + 104), v71, 4 * *(unsigned int *)(v69 + 44));
    }
    uint64_t v72 = *(const void **)(v69 + 352);
    if (v72) {
      memcpy(*(void **)(v15 + 112), v72, 4 * *(unsigned int *)(v69 + 44));
    }
    uint64_t v73 = *(const void **)(v69 + 360);
    if (v73) {
      memcpy(*(void **)(v15 + 120), v73, 4 * *(unsigned int *)(v69 + 44));
    }
    uint64_t v74 = *(const void **)(v69 + 368);
    if (v74) {
      memcpy(*(void **)(v15 + 16), v74, 4 * *(unsigned int *)(v69 + 136));
    }
    int v75 = *(const void **)(v69 + 376);
    if (v75) {
      memcpy(*(void **)(v15 + 24), v75, 4 * *(unsigned int *)(v69 + 152));
    }
  }
  else
  {
    bzero(*(void **)(v15 + 96), 4 * *(unsigned int *)(v69 + 44));
    bzero(*(void **)(v15 + 104), 4 * *(unsigned int *)(v69 + 44));
    bzero(*(void **)(v15 + 112), 4 * *(unsigned int *)(v69 + 44));
    bzero(*(void **)(v15 + 120), 4 * *(unsigned int *)(v69 + 44));
    bzero(*(void **)(v15 + 16), 4 * *(unsigned int *)(v69 + 136));
    bzero(*(void **)(v15 + 24), 4 * *(unsigned int *)(v69 + 152));
  }
  uint64_t v76 = *(uint64_t **)v348;
  uint64_t v77 = *(_DWORD **)(v348 + 120);
  int v310 = *(_DWORD *)(v348 + 24);
  v362[0] = 0;
  char __dst = v77;
  uint64_t weights_via_offset = opus_fft_alloc_twiddles(v76, v77[6] / v77[14], (uint64_t *)(*(void *)(v15 + 176) + 4 * v77[9]));
  if (weights_via_offset) {
    goto LABEL_164;
  }
  uint64_t v309 = v76;
  uint64_t v78 = v348;
  if (v310)
  {
    int v350 = 0;
    do
    {
      int v326 = __dst[11];
      int v314 = __dst[14];
      uint64_t v340 = *(void *)(v15 + 344);
      uint64_t v79 = *(float **)(v15 + 176);
      uint64_t v312 = *(void *)(v15 + 168);
      uint64_t v80 = *(void *)(v78 + 120);
      uint64_t v81 = *(unsigned int *)(v80 + 36);
      if (v81)
      {
        unsigned int v82 = (float *)(*(void *)v15 + 4 * (__dst[18] * v350));
        uint64_t v83 = *(float **)(v15 + 176);
        uint64_t v84 = *(unsigned int *)(v80 + 36);
        do
        {
          float v85 = *v82++;
          float v86 = v85;
          if (v85 > 1.0) {
            float v86 = 1.0;
          }
          if (v86 < 0.0) {
            float v86 = 0.0;
          }
          *v83++ = (float)(v86 * 11.513) + -9.2103;
          --v84;
        }
        while (v84);
      }
      fast_exp(v79, v81, v79);
      if (v81)
      {
        uint64_t v87 = v79;
        uint64_t v88 = v81;
        float v89 = 32768.0 / (float)*(unsigned int *)(v80 + 24);
        do
        {
          *uint64_t v87 = v89 * *v87;
          ++v87;
          --v88;
        }
        while (v88);
      }
      else
      {
        uint64_t v81 = 0;
      }
      uint64_t v337 = v81;
      int v90 = &v79[v81];
      __n128 v91 = *(_DWORD **)(v78 + 120);
      uint64_t v92 = v91[7];
      unsigned int v93 = v91[14];
      uint64_t v94 = v91[6] / v93;
      unsigned int v318 = ((int)v92 - 1) / v93;
      uint64_t v95 = v318 + 1;
      uint64_t v335 = v90 + 2;
      size_t v316 = v91[11];
      uint64_t v331 = (unsigned int **)v90;
      uint64_t v333 = &v90[v316 + 3];
      uint64_t v96 = (float32x4_t *)&v333[v316];
      uint64_t v329 = &v96->f32[v92];
      long long v97 = (float32x2_t *)&v329[v94];
      unint64_t v354 = 0;
      unsigned int v98 = &v97[v95];
      long long v355 = xmmword_20D6B3E40;
      uint64_t v356 = 0;
      bzero(v96, 4 * v92);
      uint64_t v320 = v91;
      uint64_t v339 = v79;
      gemm(*(uint64_t **)v348, 1, v92, v91[9], (uint64_t)v79, v340, v96, &v354, v303);
      uint64_t v322 = 8 * v95;
      bzero(v97, 8 * v95);
      if (v318 != -1)
      {
        uint64_t v99 = 0;
        do
        {
          v97[v99].f32[0] = v96->f32[v99] * v96->f32[v99];
          ++v99;
        }
        while (v95 != v99);
        uint64_t v100 = 0;
        uint64_t v101 = v318 + 1;
        do
        {
          v98[v100] = v97[v100];
          ++v100;
          --v101;
        }
        while (v101);
      }
      uint64_t v102 = v318 + 1;
      if (v95 < v94)
      {
        do
        {
          uint64_t v103 = &v98[(v94 - v102)];
          uint64_t v104 = &v98[v102];
          float32_t v105 = -v103->f32[1];
          v104->i32[0] = v103->i32[0];
          v104->f32[1] = v105;
          ++v102;
        }
        while (v102 != v94);
      }
      uint64_t v106 = (int8x16_t *)&v98[v94];
      opus_fft_c(*v331, &v97[v95], v106);
      *uint64_t v329 = *(float *)v106->i32;
      uint64_t v341 = 2 * v316;
      if (v94 >= 2)
      {
        uint64_t v107 = v94 - 1;
        uint64_t v108 = &v79[v92 + 4 + v337 + v341];
        uint64_t v109 = 1;
        do
        {
          *v108++ = *(float *)&v106->i32[2 * (v94 - v109++)];
          --v107;
        }
        while (v107);
      }
      uint64_t __src = (int8x16_t *)&v98[v94];
      uint64_t v110 = (v316 + 1);
      if (v316 != -1)
      {
        uint64_t v111 = (uint64_t)&v339[v337 + 3];
        uint64_t v112 = (v316 + 1);
        do
        {
          *(_DWORD *)(v111 - 4) = *(_DWORD *)(v111 + v341 * 4 + 4 * v92);
          v111 += 4;
          --v112;
        }
        while (v112);
      }
      uint64_t v327 = (char *)(v312 + 4 * (v326 * v350 * v314));
      celt_lpc(v327, v333, v335, v316);
      bzero(v97, v322);
      if (v95)
      {
        uint64_t v113 = 0;
        uint64_t v114 = v318 + 1;
        do
        {
          float v115 = v96->f32[2 * v318 - v113];
          v97[v113++].f32[0] = v115 * v115;
          --v114;
        }
        while (v114);
        uint64_t v116 = 0;
        uint64_t v117 = v318 + 1;
        do
        {
          v98[v116] = v97[v116];
          ++v116;
          --v117;
        }
        while (v117);
      }
      uint64_t v118 = v318 + 1;
      if (v95 < v94)
      {
        do
        {
          uint64_t v119 = &v98[(v94 - v118)];
          int v120 = &v98[v118];
          float32_t v121 = -v119->f32[1];
          v120->i32[0] = v119->i32[0];
          v120->f32[1] = v121;
          ++v118;
        }
        while (v118 != v94);
      }
      opus_fft_c(*v331, &v97[v95], __src);
      float v122 = (float)v94;
      *uint64_t v329 = *(float *)__src->i32 * (float)v94;
      if (v94 >= 2)
      {
        uint64_t v123 = v94 - 1;
        int v124 = &v339[v92 + 4 + v337 + v341];
        uint64_t v125 = 1;
        do
        {
          *v124++ = *(float *)&__src->i32[2 * (v94 - v125++)] * v122;
          --v123;
        }
        while (v123);
      }
      if (v316 != -1)
      {
        uint64_t v126 = (uint64_t)&v339[v337 + 3];
        uint64_t v127 = (v316 + 1);
        do
        {
          *(_DWORD *)(v126 - 4) = *(_DWORD *)(v126 + v341 * 4 + 4 * v92);
          v126 += 4;
          --v127;
        }
        while (v127);
      }
      celt_lpc(&v327[4 * v316], v333, v335, v316);
      uint64_t v128 = v320;
      if (v320[49] == 1)
      {
        bzero(v97, v322);
        int v129 = v350;
        if (v95)
        {
          uint64_t v130 = 0;
          uint64_t v131 = v318 + 1;
          do
          {
            float v132 = v96->f32[2 * v318 + v130];
            v97[v130++].f32[0] = v132 * v132;
            --v131;
          }
          while (v131);
          uint64_t v133 = 0;
          uint64_t v134 = v318 + 1;
          do
          {
            v98[v133] = v97[v133];
            ++v133;
            --v134;
          }
          while (v134);
        }
        uint64_t v135 = v318 + 1;
        if (v95 < v94)
        {
          do
          {
            uint64_t v136 = &v98[(v94 - v135)];
            int v137 = &v98[v135];
            float32_t v138 = -v136->f32[1];
            v137->i32[0] = v136->i32[0];
            v137->f32[1] = v138;
            ++v135;
          }
          while (v135 != v94);
        }
        opus_fft_c(*v331, &v97[v95], __src);
        *uint64_t v329 = *(float *)__src->i32 * v122;
        if (v94 >= 2)
        {
          uint64_t v139 = v94 - 1;
          size_t v140 = &v339[v92 + 4 + v337 + v341];
          uint64_t v141 = 1;
          do
          {
            *v140++ = *(float *)&__src->i32[2 * (v94 - v141++)] * v122;
            --v139;
          }
          while (v139);
        }
        if (v316 != -1)
        {
          uint64_t v142 = (uint64_t)&v339[v337 + 3];
          uint64_t v143 = (v316 + 1);
          do
          {
            *(_DWORD *)(v142 - 4) = *(_DWORD *)(v142 + v341 * 4 + 4 * v92);
            v142 += 4;
            --v143;
          }
          while (v143);
        }
        celt_lpc(&v327[4 * (2 * v316)], v333, v335, v316);
        uint64_t v128 = v320;
      }
      else
      {
        bzero(&v327[4 * (2 * v316)], v316);
        int v129 = v350;
      }
      if (v128[50] == 1)
      {
        bzero(v97, v322);
        if (v95)
        {
          uint64_t v144 = 0;
          uint64_t v145 = v318 + 1;
          do
          {
            float v146 = v96->f32[4 * v318 - v144];
            v97[v144++].f32[0] = v146 * v146;
            --v145;
          }
          while (v145);
          uint64_t v147 = 0;
          uint64_t v148 = v318 + 1;
          do
          {
            v98[v147] = v97[v147];
            ++v147;
            --v148;
          }
          while (v148);
        }
        if (v95 < v94)
        {
          do
          {
            uint64_t v149 = &v98[(v94 - v95)];
            int v150 = &v98[v95];
            float32_t v151 = -v149->f32[1];
            v150->i32[0] = v149->i32[0];
            v150->f32[1] = v151;
            ++v95;
          }
          while (v95 != v94);
        }
        opus_fft_c(*v331, v98, __src);
        *uint64_t v329 = *(float *)__src->i32 * v122;
        if (v94 >= 2)
        {
          uint64_t v152 = v94 - 1;
          uint64_t v153 = &v339[v92 + 4 + v337 + v341];
          uint64_t v154 = 1;
          do
          {
            *v153++ = *(float *)&__src->i32[2 * (v94 - v154++)] * v122;
            --v152;
          }
          while (v152);
        }
        uint64_t v78 = v348;
        if (v316 != -1)
        {
          uint64_t v155 = (uint64_t)&v339[v337 + 3];
          do
          {
            *(_DWORD *)(v155 - 4) = *(_DWORD *)(v155 + v341 * 4 + 4 * v92);
            v155 += 4;
            --v110;
          }
          while (v110);
        }
        celt_lpc(&v327[4 * (3 * v316)], v333, v335, v316);
      }
      else
      {
        bzero(&v327[4 * (3 * v316)], v316);
        uint64_t v78 = v348;
      }
      int v350 = v129 + 1;
    }
    while (v129 + 1 != v310);
  }
  unsigned int v156 = (uint64_t *)(*(void *)(v15 + 176) + 4 * __dst[9]);
  uint64_t v157 = *v156;
  if (*v156)
  {
    if (*(void *)(v157 + 48))
    {
      (*(void (**)(uint64_t))(v309[1] + 80))(v309[2]);
      *(void *)(v157 + 48) = 0;
    }
    if ((*(_DWORD *)(v157 + 8) & 0x80000000) != 0 && *(void *)(v157 + 56))
    {
      (*(void (**)(uint64_t))(v309[1] + 80))(v309[2]);
      *(void *)(v157 + 56) = 0;
    }
    (*(void (**)(uint64_t, uint64_t))(v309[1] + 80))(v309[2], v157);
    *unsigned int v156 = 0;
  }
  uint64_t weights_via_offset = fi_shape_get_bytes((int *)(*((void *)__dst + 31) + 40), v362);
  uint64_t v76 = v309;
  if (weights_via_offset) {
    goto LABEL_164;
  }
  bzero(*(void **)(v15 + 128), v362[0]);
  uint64_t weights_via_offset = (*(uint64_t (**)(void))(*((void *)__dst + 31) + 128))(0);
  if (weights_via_offset) {
    goto LABEL_164;
  }
  uint64_t weights_via_offset = fi_shape_get_bytes((int *)(*((void *)__dst + 32) + 40), v362);
  if (weights_via_offset) {
    goto LABEL_164;
  }
  bzero(*(void **)(v15 + 136), v362[0]);
  uint64_t weights_via_offset = (*(uint64_t (**)(void))(*((void *)__dst + 32) + 128))(0);
  if (weights_via_offset) {
    goto LABEL_164;
  }
  axpy((__dst[18] * v310), *(float **)v15, 1, *(float **)(v15 + 136), 1, 1.0);
  uint64_t weights_via_offset = fi_shape_get_bytes((int *)(*((void *)__dst + 33) + 40), v362);
  if (weights_via_offset) {
    goto LABEL_164;
  }
  bzero(*(void **)(v15 + 144), v362[0]);
  uint64_t weights_via_offset = (*(uint64_t (**)(void))(*((void *)__dst + 33) + 128))(0);
  if (weights_via_offset
    || (uint64_t weights_via_offset = fi_shape_get_bytes((int *)(*((void *)__dst + 34) + 40), v362),
        weights_via_offset)
    || (bzero(*(void **)(v15 + 152), v362[0]),
        uint64_t weights_via_offset = (*(uint64_t (**)(void))(*((void *)__dst + 34) + 128))(0),
        weights_via_offset)
    || (uint64_t weights_via_offset = fi_shape_get_bytes((int *)(*((void *)__dst + 35) + 40), v362),
        weights_via_offset)
    || (bzero(*(void **)(v15 + 160), v362[0]),
        uint64_t weights_via_offset = (*(uint64_t (**)(void))(*((void *)__dst + 35) + 128))(0),
        weights_via_offset))
  {
LABEL_164:
    uint64_t v61 = *v76;
    uint64_t v62 = "multiband_lpcnet forward frame network failed!";
    goto LABEL_31;
  }
  uint64_t v158 = *(void *)(v348 + 120);
  unsigned int v159 = *(_DWORD *)(v348 + 24);
  uint64_t v160 = *(void *)(v15 + 8);
  int v323 = *(float **)(v15 + 104);
  __srca = *(float **)(v15 + 96);
  uint64_t v319 = *(float **)(v15 + 120);
  uint64_t v321 = *(float **)(v15 + 112);
  int v161 = *(_DWORD *)(v158 + 124);
  uint64_t v162 = ulaw2lin7;
  if (v161 == 256) {
    uint64_t v162 = ulaw2lin8;
  }
  uint64_t v313 = v162;
  uint64_t v163 = lin2ulaw7;
  if (v161 == 256) {
    uint64_t v163 = lin2ulaw8;
  }
  uint64_t v342 = v163;
  unsigned int v164 = *(_DWORD *)(v158 + 320);
  if (v164)
  {
    uint64_t weights_via_offset = 7;
    unsigned int v334 = *(_DWORD *)(v158 + 392);
    unsigned int v336 = *(_DWORD *)(v158 + 396);
    unsigned int v330 = *(_DWORD *)(v158 + 400);
    unsigned int v332 = *(_DWORD *)(v158 + 404);
    float v165 = *(float *)(v158 + 408);
    uint64_t v9 = v351;
    uint64_t v10 = v352;
    switch(*(_DWORD *)(v158 + 332))
    {
      case 0:
        unsigned int v317 = 0;
        unsigned int v164 = v159 - 2;
        if (v159 < 2) {
          unsigned int v164 = 0;
        }
        goto LABEL_184;
      case 1:
        unsigned int v164 = v159 - 4;
        if (v159 < 4) {
          unsigned int v164 = 0;
        }
        BOOL v166 = v159 >= 2;
        v159 -= 2;
        if (!v166) {
          unsigned int v159 = 0;
        }
        unsigned int v317 = 2;
        goto LABEL_184;
      case 2:
      case 5:
        if (v159 >= 2) {
          v159 -= 2;
        }
        else {
          unsigned int v159 = 0;
        }
        unsigned int v317 = 2;
        unsigned int v164 = v159;
        goto LABEL_184;
      case 3:
      case 4:
        goto LABEL_33;
      default:
        goto LABEL_32;
    }
    goto LABEL_33;
  }
  unsigned int v317 = 0;
  float v165 = 0.0;
  unsigned int v330 = *(_DWORD *)(v158 + 132) >> 1;
  unsigned int v336 = v330;
  unsigned int v332 = v330;
  unsigned int v334 = v330;
LABEL_184:
  unsigned int v308 = v317 + v159;
  if (v317 >= v317 + v159)
  {
LABEL_261:
    unsigned int v300 = *(_DWORD *)(v352 + 12);
    if (v300 == 22050)
    {
      unsigned int v301 = *(_DWORD *)(v352 + 16) * v343;
    }
    else
    {
      uint64_t v9 = v351;
      uint64_t weights_via_offset = src_generate(v351, 0xBu, v300 / 0x7D0, (uint64_t *)&v353);
      uint64_t v10 = v352;
      if (weights_via_offset) {
        goto LABEL_33;
      }
      if (*(_DWORD *)(v352 + 320) == 1 && *(_DWORD *)(v352 + 332)) {
        memcpy((void *)v353[4], *(const void **)(v352 + 384), 4 * *((unsigned int *)v353 + 10));
      }
      unsigned int v301 = src_filt(v353, v347, *(_DWORD *)(v352 + 16) * v343, *(void *)(v15 + 160));
      memcpy(v347, *(const void **)(v15 + 160), 4 * v301);
      if (*(_DWORD *)(v352 + 320) == 1)
      {
        int v302 = *(_DWORD *)(v352 + 332);
        if (v302 != 2 && v302 != 5) {
          memcpy(*(void **)(v352 + 384), (const void *)v353[4], 4 * *((unsigned int *)v353 + 10));
        }
      }
    }
    uint64_t weights_via_offset = 0;
    *(_DWORD *)(v348 + 44) = v301;
    *(_DWORD *)(v344 + 20) = 1;
    goto LABEL_32;
  }
  int v167 = 0;
  int v307 = v317 + v164 - 1;
  while (1)
  {
    uint64_t v168 = *(void *)(v15 + 152) + 4 * *(_DWORD *)(v158 + 108) * v317;
    memcpy(*(void **)(v15 + 80), *(const void **)(v15 + 248), 4 * (3 * *(_DWORD *)(v158 + 152)));
    if (*(_DWORD *)(v158 + 160) == 1) {
      sparse_sgemv_accum16(*(void *)(v15 + 80), *(float **)(v15 + 288), 3 * *(_DWORD *)(v158 + 152), *(int **)(v15 + 280), v168);
    }
    else {
      gemm_ex(*(uint64_t **)v348, 1, (3 * *(_DWORD *)(v158 + 152)), *(unsigned int *)(v158 + 108), v168, *(unsigned int *)(v158 + 108), *(void *)(v15 + 240) + 4 * *(unsigned int *)(v158 + 136), *(unsigned int *)(v158 + 148), *(float32x4_t **)(v15 + 80), 3 * *(_DWORD *)(v158 + 152), 0);
    }
    if (*(_DWORD *)(v158 + 204) == 1) {
      break;
    }
LABEL_195:
    unint64_t v192 = *(unsigned int *)(v158 + 36);
    if (v192)
    {
      int v193 = *(_DWORD *)(v158 + 40);
      if (*(float *)(*(void *)v15 + 4 * v193 * v317) > 0.01)
      {
        BOOL v194 = 1;
LABEL_202:
        BOOL v346 = v194;
        goto LABEL_204;
      }
      unint64_t v195 = 0;
      int v196 = v193 * v317 + 1;
      while (v192 - 1 != v195)
      {
        float v197 = *(float *)(*(void *)v15 + 4 * (v196 + v195++));
        if (v197 > 0.01)
        {
          BOOL v194 = v195 < v192;
          goto LABEL_202;
        }
      }
    }
    bzero(*(void **)(v15 + 16), 4 * *(unsigned int *)(v158 + 136));
    bzero(*(void **)(v15 + 24), 4 * *(unsigned int *)(v158 + 152));
    BOOL v346 = 0;
LABEL_204:
    unsigned int v198 = *(_DWORD *)(v158 + 56);
    if (v198 <= *(_DWORD *)(v158 + 16))
    {
      unsigned int v328 = 0;
      do
      {
        int v338 = v167;
        unint64_t v354 = 0;
        *(void *)&long long v355 = 0;
        if (*(_DWORD *)(v158 + 208) == 1) {
          unsigned int v315 = *(_DWORD *)(v158 + 152) / v198;
        }
        else {
          unsigned int v315 = 0;
        }
        unsigned int v199 = *(_DWORD *)(v158 + 132) >> 1;
        int32x4_t v357 = vdupq_n_s32(v199);
        unsigned int v200 = v199;
        unsigned int v201 = v199;
        unsigned int v202 = v199;
        if (v346)
        {
          uint64_t v203 = *(unsigned int *)(v158 + 44);
          if (v203)
          {
            uint64_t v204 = *(void *)(v15 + 168);
            unsigned int v205 = v317 * v198 * v203;
            unsigned int v206 = v203 + v205;
            float v207 = 0.0;
            uint64_t v209 = v323;
            uint64_t v208 = __srca;
            uint64_t v210 = *(unsigned int *)(v158 + 44);
            float v211 = 0.0;
            do
            {
              float v212 = *v208++;
              float v211 = v211 - (float)(v212 * *(float *)(v204 + 4 * v205));
              float v213 = *v209++;
              float v207 = v207 - (float)(v213 * *(float *)(v204 + 4 * v206++));
              ++v205;
              --v210;
            }
            while (v210);
            unint64_t v354 = __PAIR64__(LODWORD(v207), LODWORD(v211));
            if (*(_DWORD *)(v158 + 196) == 1)
            {
              unsigned int v214 = v203 * (v317 * v198 + 2);
              float v215 = 0.0;
              uint64_t v216 = v321;
              uint64_t v217 = v203;
              do
              {
                float v218 = *v216++;
                float v215 = v215 - (float)(v218 * *(float *)(v204 + 4 * v214++));
                --v217;
              }
              while (v217);
              *(float *)&long long v355 = v215;
            }
            if (*(_DWORD *)(v158 + 200) == 1)
            {
              unsigned int v219 = v203 * (v317 * v198 + 3);
              float v220 = 0.0;
              uint64_t v221 = v319;
              do
              {
                float v222 = *v221++;
                float v220 = v220 - (float)(v222 * *(float *)(v204 + 4 * v219++));
                --v203;
              }
              while (v203);
              *((float *)&v355 + 1) = v220;
            }
          }
          else
          {
            LODWORD(v354) = 0;
          }
          for (uint64_t i = 0; i != 16; i += 4)
            *(int *)((char *)&v358 + i) = v342(*(float *)((char *)&v354 + i));
          int v224 = v342(*__srca);
          int v225 = v342(*v323);
          int v226 = v342(*v321);
          int v227 = v342(*v319);
          uint64_t v228 = *(float **)(v15 + 32);
          unsigned int v229 = *(_DWORD *)(v158 + 116);
          uint64_t v230 = *(void *)(v15 + 184);
          uint64_t v231 = (float *)(v230 + 4 * v229 * v224);
          int v232 = *(_DWORD *)(v158 + 124);
          uint64_t v233 = (float *)(v230 + 4 * (v232 + v225) * v229);
          if (*(_DWORD *)(v158 + 204) == 1)
          {
            accum4(v229, v231, v233, (float *)(*(void *)(v15 + 192) + 4 * v358 * v229), (float *)(*(void *)(v15 + 192) + 4 * (v359 + *(_DWORD *)(v158 + 128)) * v229), *(float **)(v15 + 48));
            accum4(*(_DWORD *)(v158 + 116), (float *)(*(void *)(v15 + 200) + 4 * *(_DWORD *)(v158 + 116) * v334), (float *)(*(void *)(v15 + 200) + 4 * (*(_DWORD *)(v158 + 132) + v336) * *(_DWORD *)(v158 + 116)), (float *)(*(void *)(v15 + 160) + 4 * *(_DWORD *)(v158 + 116) * v317), *(float **)(v15 + 48), v228);
            multiband_lpcnet_compute_sparse_gru_a(v348, v15);
            multiband_lpcnet_compute_gru_b(v348, v15);
            multiband_lpcnet_compute_dual_fc(*(void *)(v158 + 288), v15, *(float **)(v15 + 296), *(void *)(v15 + 24), v234, v235, v236, v237, v303);
            unsigned int v202 = sample_from_pdf(*(float **)(v15 + 72), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48), *(float *)(*(void *)(v15 + 328) + 4 * (v338 & 0xFFF)));
            v357.i32[0] = v202;
            multiband_lpcnet_compute_dual_fc(*(void *)(v158 + 296), v15, *(float **)(v15 + 304), *(void *)(v15 + 24) + 4 * ((2 * *(_DWORD *)(v158 + 152)) / *(_DWORD *)(v158 + 56)), v238, v239, v240, v241, v304);
            unsigned int v201 = sample_from_pdf(*(float **)(v15 + 72), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48), *(float *)(*(void *)(v15 + 328) + 4 * (((_WORD)v338 + 1) & 0xFFF)));
            v357.i32[1] = v201;
            uint64_t v242 = *(void *)(v15 + 72);
            unsigned int v243 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
            unsigned int v200 = sample_cdf(v242 + 4 * v243, *(_DWORD *)(v158 + 176), *(float *)(*(void *)(v15 + 328) + 4 * (((_WORD)v338 + 2) & 0xFFF)));
            v357.i32[2] = v200;
            uint64_t v244 = *(void *)(v15 + 72);
            int v245 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
            unsigned int v199 = sample_cdf(v244 + 4 * (2 * v245), *(_DWORD *)(v158 + 176), *(float *)(*(void *)(v15 + 328) + 4 * (((_WORD)v338 + 3) & 0xFFF)));
          }
          else
          {
            accum4(v229, v231, v233, (float *)(v230 + 4 * (v226 + 2 * v232) * v229), (float *)(v230 + 4 * (3 * v232 + v227) * v229), *(float **)(v15 + 48));
            unsigned int v246 = *(_DWORD *)(v158 + 116);
            uint64_t v247 = *(void *)(v15 + 192);
            accum4(v246, (float *)(v247 + 4 * v358 * v246), (float *)(v247 + 4 * (v359 + *(_DWORD *)(v158 + 128)) * v246), (float *)(v247 + 4 * (v360 + 2 * *(_DWORD *)(v158 + 128)) * v246), (float *)(v247 + 4 * (v361 + 3 * *(_DWORD *)(v158 + 128)) * v246), *(float **)(v15 + 56));
            unsigned int v248 = *(_DWORD *)(v158 + 116);
            uint64_t v249 = *(void *)(v15 + 200);
            accum4(v248, (float *)(v249 + 4 * v248 * v334), (float *)(v249 + 4 * (*(_DWORD *)(v158 + 132) + v336) * v248), (float *)(v249 + 4 * (v330 + 2 * *(_DWORD *)(v158 + 132)) * v248), (float *)(v249 + 4 * (3 * *(_DWORD *)(v158 + 132) + v332) * v248), *(float **)(v15 + 64));
            accum4(*(_DWORD *)(v158 + 116), (float *)(*(void *)(v15 + 160) + 4 * *(_DWORD *)(v158 + 116) * v317), *(float **)(v15 + 48), *(float **)(v15 + 56), *(float **)(v15 + 64), v228);
            multiband_lpcnet_compute_sparse_gru_a(v348, v15);
            multiband_lpcnet_compute_gru_b(v348, v15);
            multiband_lpcnet_compute_dual_fc(*(void *)(v158 + 288), v15, *(float **)(v15 + 296), *(void *)(v15 + 24), v250, v251, v252, v253, v303);
            unsigned int v202 = sample_from_pdf(*(float **)(v15 + 72), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48), *(float *)(*(void *)(v15 + 328) + 4 * (v338 & 0xFFF)));
            v357.i32[0] = v202;
            multiband_lpcnet_compute_dual_fc(*(void *)(v158 + 296), v15, *(float **)(v15 + 304), *(void *)(v15 + 24) + 4 * v315, v254, v255, v256, v257, v305);
            unsigned int v201 = sample_from_pdf(*(float **)(v15 + 72), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48), *(float *)(*(void *)(v15 + 328) + 4 * (((_WORD)v338 + 1) & 0xFFF)));
            v357.i32[1] = v201;
            multiband_lpcnet_compute_dual_fc(*(void *)(v158 + 304), v15, *(float **)(v15 + 312), *(void *)(v15 + 24) + 8 * v315, v258, v259, v260, v261, v306);
            unsigned int v200 = sample_from_pdf(*(float **)(v15 + 72), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48), *(float *)(*(void *)(v15 + 328) + 4 * (((_WORD)v338 + 2) & 0xFFF)));
            v357.i32[2] = v200;
            if (*(_DWORD *)(v158 + 192))
            {
              bzero(*(void **)(v15 + 72), 4 * *(unsigned int *)(v158 + 176));
              uint64_t v185 = (*(uint64_t (**)(void))(*(void *)(v158 + 312) + 128))(0);
              if (v185) {
                goto LABEL_264;
              }
            }
            else
            {
              multiband_lpcnet_compute_dual_fc(*(void *)(v158 + 312), v15, *(float **)(v15 + 320), *(void *)(v15 + 24) + 12 * v315, v262, v263, v264, v265, v303);
            }
            unsigned int v199 = sample_from_pdf(*(float **)(v15 + 72), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48), *(float *)(*(void *)(v15 + 328) + 4 * (((_WORD)v338 + 3) & 0xFFF)));
          }
          v357.i32[3] = v199;
        }
        unsigned int v266 = *(_DWORD *)(v158 + 124);
        unsigned int v332 = v199;
        unsigned int v267 = *(_DWORD *)(v158 + 176);
        unsigned int v330 = v200;
        unsigned int v336 = v201;
        unsigned int v334 = v202;
        if (v266 != v267)
        {
          uint64_t v268 = 0;
          unsigned int v269 = v266 / v267;
          uint64_t v270 = *(void *)(v15 + 328);
          do
          {
            int v271 = v357.i32[v268] * v269;
            v357.i32[v268] = v271;
            float v272 = *(float *)(v270 + 4 * (((_WORD)v338 + (_WORD)v268) & 0xFFF));
            BOOL v273 = v346;
            if (v272 >= 0.7) {
              BOOL v273 = 0;
            }
            if (v273)
            {
              unsigned int v274 = v271 + (float)(v272 * (float)v269);
              unsigned int v275 = *(_DWORD *)(v158 + 128);
              if (v274 >= v275) {
                unsigned int v274 = v275 - 1;
              }
              v357.i32[v268] = v274;
            }
            ++v268;
          }
          while (v268 != 4);
          unsigned int v336 = v357.u32[1];
          unsigned int v334 = v357.i32[0];
          unsigned int v332 = v357.u32[3];
          unsigned int v330 = v357.u32[2];
        }
        float v276 = *(float *)&v354;
        float v277 = *(float *)(v158 + 212);
        float v278 = v276 + (float)(v277 * v313((float)v334));
        *(float *)uint64_t v362 = v278;
        float v279 = *((float *)&v354 + 1);
        float v280 = *(float *)(v158 + 216);
        float v281 = v279 + (float)(v280 * v313((float)v336));
        *(float *)&v362[1] = v281;
        float v282 = *(float *)&v355;
        float v283 = *(float *)(v158 + 220);
        float v284 = v282 + (float)(v283 * v313((float)v330));
        *(float *)&v362[2] = v284;
        float v285 = *((float *)&v355 + 1);
        float v286 = *(float *)(v158 + 224);
        float v287 = v285 + (float)(v286 * v313((float)v332));
        *(float *)&v362[3] = v287;
        memmove(__srca + 1, __srca, 4 * (*(_DWORD *)(v158 + 44) - 1));
        memmove(v323 + 1, v323, 4 * (*(_DWORD *)(v158 + 44) - 1));
        memmove(v321 + 1, v321, 4 * (*(_DWORD *)(v158 + 44) - 1));
        memmove(v319 + 1, v319, 4 * (*(_DWORD *)(v158 + 44) - 1));
        uint64_t v288 = 0;
        unint64_t v289 = 0;
        float *__srca = v278;
        *int v323 = v281;
        *uint64_t v321 = v284;
        *uint64_t v319 = v287;
        unint64_t v290 = *(unsigned int *)(v158 + 60);
        do
        {
          int v291 = get_padded_len(v290, 8u);
          v362[v289] = 0;
          unint64_t v290 = *(unsigned int *)(v158 + 60);
          if (v289 < v290)
          {
            uint64_t v292 = 0;
            int v294 = v291 + v289;
            int v295 = v291 + v289 + 2 * v291;
            int v296 = v289 + 2 * v291;
            float v297 = 0.0;
            do
            {
              uint64_t v293 = *(void *)(v15 + 336);
              float v297 = (float)((float)((float)(v297
                                           + (float)(*(float *)(v293 + v288 + 4 * v292)
                                                   * *(float *)(*(void *)(v15 + 96) + v292)))
                                   + (float)(*(float *)(v293 + 4 * (v294 + v292))
                                           * *(float *)(*(void *)(v15 + 104) + v292)))
                           + (float)(*(float *)(v293 + 4 * (v296 + v292))
                                   * *(float *)(*(void *)(v15 + 112) + v292)))
                   + (float)(*(float *)(v293 + 4 * (v295 + v292))
                           * *(float *)(*(void *)(v15 + 120) + v292));
              v292 += 4;
            }
            while (v289 + v292 < v290);
            *(float *)&v362[v289] = v297;
          }
          ++v289;
          v288 += 4;
        }
        while (v289 != 4);
        for (uint64_t j = 0; j != 4; ++j)
        {
          float v165 = *(float *)&v362[j] + (float)(*(float *)(v158 + 52) * v165);
          if (v165 >= -32767.0) {
            float v299 = v165;
          }
          else {
            float v299 = -32767.0;
          }
          if (v299 > 32767.0) {
            float v299 = 32767.0;
          }
          *(float *)&v362[j] = v299;
          *(float *)(v160 + 4 * (v338 + j)) = v299 * 0.000030518;
        }
        unsigned int v198 = *(_DWORD *)(v158 + 56);
        int v167 = v338 + 4;
        ++v328;
      }
      while (v328 < *(_DWORD *)(v158 + 16) / v198);
      int v167 = v338 + 4;
    }
    if (v317 == v307 && *(_DWORD *)(v158 + 320))
    {
      *(_DWORD *)(v158 + 392) = v334;
      *(_DWORD *)(v158 + 396) = v336;
      *(_DWORD *)(v158 + 400) = v330;
      *(_DWORD *)(v158 + 404) = v332;
      *(float *)(v158 + 408) = v165;
      memcpy(*(void **)(v158 + 336), __srca, 4 * *(unsigned int *)(v158 + 44));
      memcpy(*(void **)(v158 + 344), v323, 4 * *(unsigned int *)(v158 + 44));
      memcpy(*(void **)(v158 + 352), v321, 4 * *(unsigned int *)(v158 + 44));
      memcpy(*(void **)(v158 + 360), v319, 4 * *(unsigned int *)(v158 + 44));
      memcpy(*(void **)(v158 + 368), *(const void **)(v15 + 16), 4 * *(unsigned int *)(v158 + 136));
      memcpy(*(void **)(v158 + 376), *(const void **)(v15 + 24), 4 * *(unsigned int *)(v158 + 152));
    }
    if (++v317 == v308) {
      goto LABEL_261;
    }
  }
  multiband_lpcnet_compute_dual_fc(*(void *)(v158 + 304), v15, *(float **)(v15 + 312), v168, v169, v170, v171, v172, v303);
  uint64_t v173 = *(void *)(v15 + 72);
  unsigned int v174 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
  memcpy((void *)(v173 + 4 * v174), *(const void **)(v15 + 72), 4 * *(unsigned int *)(v158 + 176));
  if (!*(_DWORD *)(v158 + 192))
  {
    multiband_lpcnet_compute_dual_fc(*(void *)(v158 + 312), v15, *(float **)(v15 + 320), v168, v175, v176, v177, v178, v303);
    uint64_t v186 = *(void *)(v15 + 72);
    int v187 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
    memcpy((void *)(v186 + 4 * (2 * v187)), *(const void **)(v15 + 72), 4 * *(unsigned int *)(v158 + 176));
    goto LABEL_194;
  }
  uint64_t v179 = *(void *)(v15 + 72);
  int v180 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
  bzero((void *)(v179 + 4 * (2 * v180)), 4 * *(unsigned int *)(v158 + 176));
  uint64_t v181 = *(void *)(v158 + 312);
  uint64_t v182 = *(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, void))(v181 + 128);
  uint64_t v183 = *(void *)(v15 + 72);
  int v184 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
  uint64_t v185 = v182(0, v181, v168, v183 + 4 * (2 * v184), 0);
  if (!v185)
  {
LABEL_194:
    uint64_t v188 = *(void *)(v15 + 72);
    unsigned int v189 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
    prepare_cdf((float *)(v188 + 4 * v189), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48));
    uint64_t v190 = *(void *)(v15 + 72);
    int v191 = get_padded_len(*(unsigned int *)(v158 + 176), 8u);
    prepare_cdf((float *)(v190 + 4 * (2 * v191)), *(_DWORD *)(v158 + 176), 0.0, *(float *)(v158 + 48));
    goto LABEL_195;
  }
LABEL_264:
  uint64_t weights_via_offset = v185;
LABEL_32:
  uint64_t v9 = v351;
  uint64_t v10 = v352;
LABEL_33:
  size_t v63 = v353;
  if (v353)
  {
    if (*v353)
    {
      (*(void (**)(uint64_t, void))(v9[1] + 48))(v9[2], *v353);
      *uint64_t v353 = 0;
      *uint64_t v353 = 0;
      size_t v63 = v353;
    }
    if (v63[4])
    {
      (*(void (**)(uint64_t, uint64_t))(v9[1] + 48))(v9[2], v63[4]);
      v353[4] = 0;
    }
    (*(void (**)(uint64_t))(v9[1] + 48))(v9[2]);
    uint64_t v353 = 0;
  }
  if (v15) {
    (*(void (**)(uint64_t, uint64_t))(v9[1] + 48))(v9[2], v15);
  }
  if (weights_via_offset
    || *(_DWORD *)(v10 + 320) == 1 && ((int v64 = *(_DWORD *)(v10 + 332), v64 != 5) ? (v65 = v64 == 2) : (v65 = 1), v65))
  {
    if (*(void *)(v10 + 336))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(void *)(v10 + 336) = 0;
    }
    if (*(void *)(v10 + 368))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(void *)(v10 + 368) = 0;
    }
    if (*(void *)(v10 + 376))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(void *)(v10 + 376) = 0;
    }
    if (*(void *)(v10 + 384))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(void *)(v10 + 384) = 0;
    }
  }
  return weights_via_offset;
}

uint64_t multiband_lpcnet_update_shape(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a1 + 120);
  v17[0] = 0;
  v17[1] = 0;
  int v18 = 0;
  int v21 = 0;
  if (*a2 != 2)
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently multiband_lpcnet layer only support 2D input", a6, a7, a8, v16);
    return 7;
  }
  long long v11 = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = a2[4];
  *(_OWORD *)(a1 + 20) = v11;
  unsigned int v12 = *(_DWORD *)(v9 + 72);
  int v19 = a2[1];
  unsigned int v20 = v12;
  fi_shape_set(2, (uint64_t)&v19, 4, (uint64_t)v17);
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 248) + 144))();
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 256) + 144))();
    if (!result)
    {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 264) + 144))();
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 272) + 144))();
        if (!result)
        {
          uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 280) + 144))();
          if (!result)
          {
            int v19 = 1;
            int v14 = *(_DWORD *)(v9 + 208);
            unsigned int v15 = *(_DWORD *)(v9 + 152);
            if (*(_DWORD *)(v9 + 204) == 1)
            {
              if (v14 == 1) {
                unsigned int v15 = 2 * v15 / *(_DWORD *)(v9 + 56);
              }
              unsigned int v20 = v15;
              uint64_t result = fi_shape_set(2, (uint64_t)&v19, 4, (uint64_t)v17);
              if (!result)
              {
                uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 288) + 144))();
                if (!result)
                {
                  uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 296) + 144))();
                  if (!result)
                  {
                    unsigned int v20 = *(_DWORD *)(*(void *)(v9 + 272) + 48);
                    uint64_t result = fi_shape_set(2, (uint64_t)&v19, 4, (uint64_t)v17);
                    if (!result)
                    {
LABEL_21:
                      uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 304) + 144))();
                      if (!result)
                      {
                        uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 312) + 144))();
                        if (!result)
                        {
                          uint64_t result = 0;
                          *(_DWORD *)(a1 + 40) = 1;
                          *(_DWORD *)(a1 + 44) = 330 * a2[1];
                          *(_DWORD *)(a1 + 56) = 4;
                        }
                      }
                    }
                  }
                }
              }
            }
            else
            {
              if (v14 == 1) {
                v15 /= *(_DWORD *)(v9 + 56);
              }
              unsigned int v20 = v15;
              fi_shape_set(2, (uint64_t)&v19, 4, (uint64_t)v17);
              uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 288) + 144))();
              if (!result)
              {
                uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 296) + 144))();
                if (!result) {
                  goto LABEL_21;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void *free_multiband_lpcnet(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[31]);
        fi_layer_free(v3[32]);
        fi_layer_free(v3[33]);
        fi_layer_free(v3[34]);
        fi_layer_free(v3[35]);
        fi_layer_free(v3[36]);
        fi_layer_free(v3[37]);
        fi_layer_free(v3[38]);
        fi_layer_free(v3[39]);
        (*(void (**)(void, uint64_t *))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v4 = *(void *)(v2 + 16);
      int v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v5(v4, v1);
    }
  }
  return result;
}

uint64_t multiband_lpcnet_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 120);
  if (v8)
  {
    int v11 = *(_DWORD *)(v8 + 204);
    int padded_len = get_padded_len(*(unsigned int *)(v8 + 116), 8u);
    int v13 = *(_DWORD *)(v8 + 124);
    int v14 = get_padded_len(*(unsigned int *)(v8 + 116), 8u);
    int v15 = *(_DWORD *)(v8 + 128);
    int v16 = get_padded_len(*(unsigned int *)(v8 + 116), 8u);
    int v17 = *(_DWORD *)(v8 + 132);
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 248) + 152))();
    if (!result)
    {
      char v19 = v11 == 1 ? 1 : 2;
      padded_uint64_t bytes = get_padded_bytes(4 * ((v13 * padded_len + v15 * v14 + v17 * v16) << v19), 8u);
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 256) + 152))();
      if (!result)
      {
        unsigned int v21 = get_padded_bytes(padded_bytes, 8u);
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 264) + 152))();
        if (!result)
        {
          unsigned int v22 = get_padded_bytes(v21, 8u);
          uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 272) + 152))();
          if (!result)
          {
            unsigned int v23 = get_padded_bytes(v22, 8u);
            uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 280) + 152))();
            if (!result)
            {
              int v24 = get_padded_bytes(v23, 8u);
              int v25 = *(_DWORD *)(v8 + 140);
              unsigned int v26 = get_padded_len((3 * *(_DWORD *)(v8 + 136)), 8u);
              int v27 = get_padded_bytes(v24 + 4 * (v25 + (v26 >> 4)), 8u);
              int v28 = get_padded_bytes(v27 + 12 * *(_DWORD *)(v8 + 136), 8u);
              int v29 = get_padded_bytes(v28 + (*(_DWORD *)(v8 + 140) << 6), 8u);
              int v30 = get_padded_len((3 * *(_DWORD *)(v8 + 136)), 8u);
              if (*(_DWORD *)(v8 + 160) == 1)
              {
                int v31 = get_padded_bytes(v29 + 4 * v30 + (*(_DWORD *)(v8 + 164) << 6), 8u);
                int v32 = get_padded_bytes(v31 + 4 * (*(_DWORD *)(v8 + 164) + ((3 * *(_DWORD *)(v8 + 152) + 15) >> 4)), 8u);
                int v29 = get_padded_bytes(v32 + (*(_DWORD *)(v8 + 168) << 6), 8u);
                unsigned int v33 = *(_DWORD *)(v8 + 168) + ((3 * *(_DWORD *)(v8 + 152) + 15) >> 4);
              }
              else
              {
                int v34 = *(_DWORD *)(v8 + 152);
                unsigned int v33 = 3 * v34 * get_padded_len((*(_DWORD *)(v8 + 136) + *(_DWORD *)(v8 + 108)), 8u) + v30;
              }
              int v35 = get_padded_bytes(v29 + 4 * v33, 8u);
              int v36 = get_padded_len((3 * *(_DWORD *)(v8 + 152)), 8u);
              int v37 = get_padded_len(*(unsigned int *)(v8 + 152), 8u);
              unsigned int v38 = 3 * *(_DWORD *)(v8 + 152);
              int v39 = get_padded_len(v38, 8u);
              uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 288) + 152))();
              if (!result)
              {
                int v40 = get_padded_bytes(v35 + 4 * (v36 + v38 * v37 + v39), 8u);
                int v41 = get_padded_len(*(unsigned int *)(v8 + 176), 8u);
                int v42 = *(_DWORD *)(v8 + 180);
                uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 296) + 152))();
                if (!result)
                {
                  int v43 = get_padded_bytes(v40 + 4 * v41 * v42, 8u);
                  int v44 = get_padded_len(*(unsigned int *)(v8 + 176), 8u);
                  int v45 = *(_DWORD *)(v8 + 180);
                  uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 304) + 152))();
                  if (!result)
                  {
                    int v46 = get_padded_bytes(v43 + 4 * v44 * v45, 8u);
                    int v47 = get_padded_len(*(unsigned int *)(v8 + 176), 8u);
                    int v48 = *(_DWORD *)(v8 + 180);
                    uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 312) + 152))();
                    if (!result)
                    {
                      int v49 = get_padded_bytes(v46 + 4 * v47 * v48, 8u);
                      if (!*(_DWORD *)(v8 + 192)) {
                        v49 += 4 * get_padded_len(*(unsigned int *)(v8 + 176), 8u) * *(_DWORD *)(v8 + 180);
                      }
                      int v50 = get_padded_len(4096, 8u);
                      int v51 = v50 + *(_DWORD *)(v8 + 56) * get_padded_len(*(unsigned int *)(v8 + 60), 8u);
                      int v52 = get_padded_len(*(unsigned int *)(v8 + 36), 8u);
                      uint64_t result = 0;
                      *a2 = v49 + 4 * (v51 + *(_DWORD *)(v8 + 28) * v52);
                      *a3 = 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"ERROR: param is NULL in wanted_wb_len(multiband_lpcnet)!", a6, a7, a8, v53);
    return 7;
  }
  return result;
}

uint64_t multiband_lpcnet_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 120);
  int v18 = 0;
  if (v9)
  {
    uint64_t v10 = v9 + 248;
    multiband_lpcnet_get_reserved_glbBuf_bytes(a1, &v18);
    uint64_t v11 = 0;
    unsigned int v12 = 0;
    do
    {
      int v13 = *(uint64_t (**)(void))(*(void *)(v10 + v11) + 160);
      if (v13)
      {
        uint64_t result = v13();
        if (result) {
          return result;
        }
        if (*(_DWORD *)(*(void *)(v10 + v11) + 248) > v12) {
          unsigned int v12 = *(_DWORD *)(*(void *)(v10 + v11) + 248);
        }
      }
      v11 += 8;
    }
    while (v11 != 72);
    int v15 = v18;
    padded_uint64_t bytes = get_padded_bytes(v12, 8u);
    uint64_t result = 0;
    *(_DWORD *)(a1 + 248) = padded_bytes + v15;
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t multiband_lpcnet_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 120);
  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 72);
    int v10 = *(_DWORD *)(v8 + 204);
    int v11 = *(_DWORD *)(v8 + 124) * get_padded_len(*(unsigned int *)(v8 + 116), 8u);
    if (v10 == 1) {
      char v12 = 1;
    }
    else {
      char v12 = 2;
    }
    int v13 = v11 + *(_DWORD *)(v8 + 128) * get_padded_len(*(unsigned int *)(v8 + 116), 8u);
    padded_uint64_t bytes = 4
                 * ((v13 + *(_DWORD *)(v8 + 132) * get_padded_len(*(unsigned int *)(v8 + 116), 8u)) << v12);
    uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 248), v9, &padded_bytes);
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
      uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 256), v9, &padded_bytes);
      if (!result)
      {
        padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
        uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 264), v9, &padded_bytes);
        if (!result)
        {
          padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
          uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 272), v9, &padded_bytes);
          if (!result)
          {
            padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
            uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 280), v9, &padded_bytes);
            if (!result)
            {
              padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
              int v15 = *(_DWORD *)(v8 + 140);
              padded_bytes += 4
                            * (v15 + (get_padded_len((3 * *(_DWORD *)(v8 + 136)), 8u) >> 4));
              padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u) + 12 * *(_DWORD *)(v8 + 136);
              padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u) + (*(_DWORD *)(v8 + 140) << 6);
              padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
              padded_bytes += 4 * get_padded_len((3 * *(_DWORD *)(v8 + 136)), 8u);
              unsigned int v16 = get_padded_bytes(padded_bytes, 8u);
              padded_uint64_t bytes = v16;
              if (*(_DWORD *)(v8 + 160) == 1)
              {
                padded_uint64_t bytes = v16 + (*(_DWORD *)(v8 + 164) << 6);
                padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u)
                             + 4 * (*(_DWORD *)(v8 + 164) + ((3 * *(_DWORD *)(v8 + 152) + 15) >> 4));
                padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u) + (*(_DWORD *)(v8 + 168) << 6);
                unsigned int v17 = get_padded_bytes(padded_bytes, 8u)
                    + 4 * (*(_DWORD *)(v8 + 168) + ((3 * *(_DWORD *)(v8 + 152) + 15) >> 4));
              }
              else
              {
                int v18 = *(_DWORD *)(v8 + 152);
                unsigned int v17 = padded_bytes
                    + 12 * v18 * get_padded_len((*(_DWORD *)(v8 + 136) + *(_DWORD *)(v8 + 108)), 8u);
              }
              padded_uint64_t bytes = v17;
              padded_uint64_t bytes = get_padded_bytes(v17, 8u);
              padded_bytes += 4 * get_padded_len((3 * *(_DWORD *)(v8 + 152)), 8u);
              padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
              padded_bytes += 12 * get_padded_len(*(unsigned int *)(v8 + 152), 8u) * *(_DWORD *)(v8 + 152);
              padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
              padded_bytes += 4 * get_padded_len((3 * *(_DWORD *)(v8 + 152)), 8u);
              padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
              uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 288), v9, &padded_bytes);
              if (!result)
              {
                padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
                padded_bytes += 4 * get_padded_len(*(unsigned int *)(v8 + 176), 8u) * *(_DWORD *)(v8 + 180);
                uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 296), v9, &padded_bytes);
                if (!result)
                {
                  padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
                  padded_bytes += 4 * get_padded_len(*(unsigned int *)(v8 + 176), 8u) * *(_DWORD *)(v8 + 180);
                  uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 304), v9, &padded_bytes);
                  if (!result)
                  {
                    padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
                    padded_bytes += 4 * get_padded_len(*(unsigned int *)(v8 + 176), 8u) * *(_DWORD *)(v8 + 180);
                    uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 312), v9, &padded_bytes);
                    if (!result)
                    {
                      padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
                      padded_bytes += 4 * get_padded_len(*(unsigned int *)(v8 + 176), 8u) * *(_DWORD *)(v8 + 180);
                      int padded_len = get_padded_len(4096, 8u);
                      padded_bytes += 4 * padded_len;
                      padded_bytes += 4 * get_padded_len(*(unsigned int *)(v8 + 60), 8u) * *(_DWORD *)(v8 + 56);
                      get_padded_len(*(unsigned int *)(v8 + 36), 8u);
                      return 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v20);
    return 7;
  }
  return result;
}

uint64_t multiband_lpcnet_assign_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120) + 248;
  unsigned int v12 = 0;
  multiband_lpcnet_get_reserved_glbBuf_bytes(a1, &v12);
  uint64_t v6 = 0;
  uint64_t v7 = v12;
  while (1)
  {
    uint64_t v8 = *(void *)(v2 + v6);
    if (!v8) {
      break;
    }
    *(void *)(v8 + 240) = *(void *)(a1 + 240) + v7;
    uint64_t v9 = *(uint64_t (**)(void))(v8 + 168);
    if (v9)
    {
      uint64_t result = v9();
      if (result) {
        return result;
      }
    }
    v6 += 8;
    if (v6 == 72) {
      return 0;
    }
  }
  log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v3, v4, v5, v11);
  return 10;
}

float multiband_lpcnet_update_param(uint64_t a1, int *a2, int a3, int a4)
{
  if (*(_DWORD *)(a1 + 8) == a4 && a3 == 88)
  {
    uint64_t v4 = *(void *)(a1 + 120);
    int v5 = *a2;
    int v6 = a2[1];
    *(_DWORD *)(v4 + 320) = *a2;
    *(_DWORD *)(v4 + 332) = v6;
    if (v5 == 1 && v6 == 0)
    {
      *(_OWORD *)(v4 + 336) = *(_OWORD *)(a2 + 2);
      *(_OWORD *)(v4 + 352) = *(_OWORD *)(a2 + 6);
      *(_OWORD *)(v4 + 368) = *(_OWORD *)(a2 + 10);
      *(void *)(v4 + 384) = *((void *)a2 + 7);
      *(int32x4_t *)(v4 + 392) = vdupq_n_s32(*(_DWORD *)(v4 + 132) >> 1);
      float result = *((float *)a2 + 20);
      *(float *)(v4 + 408) = result;
    }
  }
  return result;
}

uint64_t multiband_lpcnet_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = *(_DWORD **)(a1 + 120);
  int v22 = v2[9];
  int step = fi_shape_get_step((_DWORD *)(a1 + 20));
  int padded_len = get_padded_len(v2[34], 8u);
  int v20 = get_padded_len(v2[38], 8u);
  int v19 = get_padded_len((3 * v2[43]), 8u);
  int v18 = get_padded_len((3 * v2[34]), 8u);
  int v17 = get_padded_len((3 * v2[34]), 8u);
  int v16 = get_padded_len((3 * v2[34]), 8u);
  int v15 = get_padded_len((3 * v2[43]), 8u);
  int v4 = get_padded_len(v2[44], 8u);
  int v5 = get_padded_len((3 * v2[38]), 8u);
  int v6 = get_padded_len((2 * v2[44]), 8u);
  int v7 = get_padded_len(v2[11], 8u);
  int v8 = v2[14];
  int v9 = get_padded_len((v8 * step * v2[11]), 8u);
  int v10 = get_padded_len((v2[27] * step), 8u);
  unsigned int v11 = v2[29];
  if (v11 <= v2[23] + v2[20] + v2[25]) {
    unsigned int v11 = v2[23] + v2[20] + v2[25];
  }
  if (v11 <= 0x14A) {
    unsigned int v11 = 330;
  }
  int v12 = 12 * v4;
  int v13 = get_padded_len(v11 * step, 8u);
  uint64_t result = get_padded_bytes((v2[6] & 0xFFFFFFF8)+ 8 * v2[11]+ (v2[6] & 0xFFFFFFFC)+ 4 * (v2[7] + v22)+ 2 * (v2[6] & 0xFFFFFFFC)+ 20, 8u);
  *a2 = v12 + 4 * (v20 + padded_len + v19 + v18 + v17 + v16 + v15 + v5 + v6 + v8 * v7 + v9 + v10 + v13) + result;
  return result;
}

float multiband_lpcnet_compute_dual_fc(uint64_t a1, uint64_t a2, float *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v12 = *(uint64_t **)a1;
  unint64_t v13 = *(unsigned int *)(a1 + 12);
  int v14 = *(void **)(a2 + 88);
  int v15 = *(void **)(a2 + 72);
  bzero(v14, 4 * (v13 & 0xFFFFFFFE));
  if ((*(unsigned int (**)(void, uint64_t, uint64_t, void *, void))(a1 + 128))(0, a1, a4, v14, 0))
  {
    uint64_t v19 = *v12;
    log_OutText(v19, (uint64_t)"FastInfer", 0, 0, (uint64_t)"multiband_lpcnet forward dual_fc failed!", v16, v17, v18, a9);
  }
  else
  {
    bzero(v15, 4 * (v13 >> 1));
    return fi_multiply_multiply_add_ansic((float *)v14, a3, (float *)v14 + (v13 >> 1), &a3[v13 >> 1], (float *)v15, v13 >> 1);
  }
  return result;
}

float multiband_lpcnet_compute_sparse_gru_a(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 120);
  int v4 = *(float **)(a2 + 16);
  int v5 = *(float **)(a2 + 32);
  int v6 = *(void **)(a2 + 40);
  uint64_t v7 = *(unsigned int *)(v3 + 136);
  memcpy(v6, *(const void **)(a2 + 232), 4 * (3 * v7));
  unsigned int v8 = 0;
  uint64_t v9 = 3;
  do
  {
    fi_multiply_add_ansic((float *)v6 + v8, (float *)(*(void *)(a2 + 216) + 4 * v8), v4, v7);
    v8 += v7;
    --v9;
  }
  while (v9);
  int v10 = &v5[v7];
  sparse_sgemv_accum16((uint64_t)v6, *(float **)(a2 + 224), 3 * v7, *(int **)(a2 + 208), (uint64_t)v4);
  axpy((2 * v7), (float *)v6, 1, v5, 1, 1.0);
  fi_activate_array(v5, (2 * v7), 11);
  fi_multiply_add_ansic(&v10[v7], (float *)v6 + (2 * v7), v10, v7);
  fi_activate_array(&v10[v7], v7, *(_DWORD *)(v3 + 144));
  fill_array_f32(v10, v7, 1.0);
  axpy(v7, v5, 1, v10, 1, -1.0);
  return fi_multiply_multiply_add_ansic(v4, v5, &v10[v7], &v5[v7], v4, v7);
}

float multiband_lpcnet_compute_gru_b(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(uint64_t **)a1;
  int v4 = *(_DWORD **)(a1 + 120);
  int v5 = *(float **)(a2 + 240);
  int v6 = *(float32x4_t **)(a2 + 32);
  unint64_t v13 = *(float **)(a2 + 24);
  uint64_t v7 = *(float32x4_t **)(a2 + 40);
  uint64_t v8 = v4[38];
  memcpy(v6, *(const void **)(a2 + 80), 4 * (3 * v8));
  uint64_t v9 = *(void *)(a2 + 16);
  if (v4[40] == 1) {
    sparse_sgemv_accum16((uint64_t)v6, v5, 3 * v8, *(int **)(a2 + 272), v9);
  }
  else {
    gemm_ex(v3, 1, (3 * v8), v4[34], v9, v4[34], (uint64_t)v5, v4[37], v6, 3 * v8, 0);
  }
  int v10 = &v6->f32[v8];
  memcpy(v7, *(const void **)(a2 + 264), 4 * (3 * v8));
  gemm(v3, 1, (3 * v8), v8, (uint64_t)v13, *(void *)(a2 + 256), v7, 0, v12);
  axpy((2 * v8), v7->f32, 1, v6->f32, 1, 1.0);
  fi_activate_array(v6->f32, (2 * v8), 11);
  fi_multiply_add_ansic(&v10[v8], &v7->f32[(2 * v8)], v10, v8);
  fi_activate_array(&v10[v8], v8, v4[39]);
  fill_array_f32(v10, v8, 1.0);
  axpy(v8, v6->f32, 1, v10, 1, -1.0);
  return fi_multiply_multiply_add_ansic(v13, v6->f32, &v10[v8], &v6->f32[v8], v13, v8);
}

void *free_tacotron(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[24]);
        fi_layer_free(v3[25]);
        fi_layer_free(v3[26]);
        fi_layer_free(v3[27]);
        fi_layer_free(v3[28]);
        fi_layer_free(v3[29]);
        fi_layer_free(v3[30]);
        (*(void (**)(void, uint64_t *))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v4 = *(void *)(v2 + 16);
      int v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v5(v4, v1);
    }
  }
  return result;
}

uint64_t create_tacotron(uint64_t *a1, long long *a2, uint64_t **a3, uint64_t a4, int a5, uint64_t *a6)
{
  uint64_t v7 = 0;
  uint64_t v8 = 7;
  if (a1 && a2)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 264);
      uint64_t v21 = v17;
      if (!v17)
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v18, v19, v20, v43);
        uint64_t v8 = 10;
        goto LABEL_12;
      }
      long long v22 = *a2;
      long long v23 = a2[1];
      long long v24 = a2[3];
      *(_OWORD *)(v17 + 32) = a2[2];
      *(_OWORD *)(v17 + 48) = v24;
      *(_OWORD *)uint64_t v17 = v22;
      *(_OWORD *)(v17 + 16) = v23;
      long long v25 = a2[4];
      long long v26 = a2[5];
      long long v27 = a2[7];
      *(_OWORD *)(v17 + 96) = a2[6];
      *(_OWORD *)(v17 + 112) = v27;
      *(_OWORD *)(v17 + 64) = v25;
      *(_OWORD *)(v17 + 80) = v26;
      long long v28 = a2[8];
      long long v29 = a2[9];
      long long v30 = a2[10];
      *(_OWORD *)(v17 + 172) = *(long long *)((char *)a2 + 172);
      *(_OWORD *)(v17 + 144) = v29;
      *(_OWORD *)(v17 + 160) = v30;
      *(_OWORD *)(v17 + 128) = v28;
      uint64_t v46 = 0;
      int v31 = *((_DWORD *)a2 + 2);
      LODWORD(v47) = 5;
      HIDWORD(v47) = v31;
      int v48 = 0;
      if (create_fc_layer(a1, &v47, &v46, 0, a4, (uint64_t *)(v17 + 192))
        || (HIDWORD(v47) = *((_DWORD *)a2 + 3),
            uint64_t v46 = 0x100000003,
            create_fc_layer(a1, &v47, &v46, 0, a4, (uint64_t *)(v21 + 200)))
        || (HIDWORD(v47) = *((_DWORD *)a2 + 4),
            create_fc_layer(a1, &v47, &v46, 0, a4, (uint64_t *)(v21 + 208))))
      {
        int v35 = "create pre dense failed!";
LABEL_9:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v35, v32, v33, v34, v43);
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Tacotron init failed!", v36, v37, v38, v44);
LABEL_12:
        *(void *)(v7 + 120) = v21;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"tacotron init param failed!", v39, v40, v41, v45);
        goto LABEL_13;
      }
      HIDWORD(v47) = *((_DWORD *)a2 + 45);
      LODWORD(v46) = *((_DWORD *)a2 + 20) == 1;
      if (create_fc_layer(a1, &v47, &v46, 0, a4, (uint64_t *)(v21 + 240)))
      {
        int v35 = "create post dense failed!";
        goto LABEL_9;
      }
      if (create_cbhg_layer(a1, (uint64_t)a2 + 20, a3, a4, (uint64_t ***)(v21 + 216)))
      {
        int v35 = "create encoder cbhg failed!";
        goto LABEL_9;
      }
      if (create_tacodecoder_layer(a1, (uint64_t)a2 + 56, a4, (uint64_t *)(v21 + 224)))
      {
        int v35 = "create decoder failed!";
        goto LABEL_9;
      }
      if (create_cbhg_layer(a1, (uint64_t)(a2 + 9), a3, a4, (uint64_t ***)(v21 + 232)))
      {
        int v35 = "create post cbhg failed!";
        goto LABEL_9;
      }
      *(void *)(v7 + 120) = v21;
      if (a3) {
        *(void *)(v7 + 60) = *a3;
      }
      uint64_t v8 = 0;
      *(void *)uint64_t v7 = a1;
      *(_DWORD *)(v7 + 8) = a5;
      *(_DWORD *)(v7 + 12) = 0;
      *(void *)(v7 + 128) = forward_tacotron;
      *(void *)(v7 + 136) = free_tacotron;
      *(void *)(v7 + 144) = tacotron_update_shape;
      *(void *)(v7 + 152) = tacotron_wanted_wb_len;
      *(void *)(v7 + 160) = tacotron_request_glbBuf;
      *(void *)(v7 + 184) = tacotron_dispatch_weights;
      *(void *)(v7 + 168) = tacotron_assign_glbBuf;
      *(void *)(v7 + 224) = tacotron_update_param;
      *(void *)(v7 + 232) = tacotron_set_align_address;
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v14, v15, v16, v43);
      uint64_t v8 = 10;
    }
  }
LABEL_13:
  *a6 = v7;
  return v8;
}

uint64_t forward_tacotron(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, uint64_t a5)
{
  uint64_t v98 = *MEMORY[0x263EF8340];
  int v10 = *(int **)(a2 + 120);
  unsigned int v11 = *(uint64_t **)a2;
  size_t v95 = 0;
  uint64_t v96 = 0;
  int v94 = 0;
  int v97 = 0;
  uint64_t v12 = *(unsigned int *)(a2 + 24);
  int v13 = v10[15];
  uint64_t v14 = (*(uint64_t (**)(uint64_t, void, uint64_t))(v11[1] + 16))(v11[2], (v13 * v12 * v10[46]), 4);
  if (v14)
  {
    uint64_t v18 = (_DWORD *)v14;
    char __dst = a4;
    if (v12 == 3)
    {
      float v19 = *(float *)(a3 + 4 * (*(_DWORD *)(a2 + 28) + 1));
      float v20 = *(float *)(a3 + 4);
      float v21 = v20 + 0.0001;
      float v22 = v20 + -0.0001;
      if (v19 < v21 && v19 > v22)
      {
        int v31 = v10[45];
        LODWORD(v96) = 1;
        HIDWORD(v96) = v31;
        *(_DWORD *)(a5 + 20) = 1;
        uint64_t v32 = fi_shape_set(2, (uint64_t)&v96, 4, a2 + 40);
        uint64_t bytes = v32;
        if (v32) {
          goto LABEL_19;
        }
        int v33 = v96;
        bzero(a4, 4 * (HIDWORD(v96) * v96));
        *uint64_t v18 = 1065353216;
        uint64_t v34 = (uint64_t **)a2;
        int v35 = v33;
        int v36 = 3;
        uint64_t v37 = (uint64_t)v18;
        int v38 = 0;
        goto LABEL_16;
      }
    }
    uint64_t v89 = a5;
    uint64_t v90 = *(void *)(a2 + 240);
    uint64_t bytes = fi_shape_get_bytes((int *)(*((void *)v10 + 29) + 40), (_DWORD *)&v95 + 1);
    if (bytes) {
      goto LABEL_19;
    }
    padded_uint64_t bytes = get_padded_bytes(HIDWORD(v95), 8u);
    uint64_t __src = *(uint64_t **)a2;
    uint64_t v87 = *(void **)(a2 + 120);
    long long v25 = *(void **)(a2 + 240);
    uint64_t bytes = fi_shape_get_bytes((int *)(v87[24] + 40), &v95);
    if (bytes) {
      goto LABEL_19;
    }
    bzero(v25, v95);
    uint64_t v26 = (*(uint64_t (**)(uint64_t))(v87[24] + 128))(a1);
    if (v26)
    {
      uint64_t bytes = v26;
      long long v30 = "tacotron pre dense o1 forward failed!";
    }
    else
    {
      uint64_t bytes = fi_shape_get_bytes((int *)(v87[25] + 40), &v95);
      if (bytes) {
        goto LABEL_19;
      }
      bzero(__dst, v95);
      uint64_t v41 = (*(uint64_t (**)(uint64_t))(v87[25] + 128))(a1);
      if (v41)
      {
        uint64_t bytes = v41;
        long long v30 = "tacotron pre dense o2 forward failed!";
      }
      else
      {
        uint64_t bytes = fi_shape_get_bytes((int *)(v87[26] + 40), &v95);
        if (bytes) {
          goto LABEL_19;
        }
        bzero(v25, v95);
        uint64_t v42 = (*(uint64_t (**)(uint64_t))(v87[26] + 128))(a1);
        if (v42)
        {
          uint64_t bytes = v42;
          long long v30 = "tacotron pre dense o3 forward failed!";
        }
        else
        {
          uint64_t bytes = (*(uint64_t (**)(void))(v87[27] + 176))();
          if (bytes) {
            goto LABEL_19;
          }
          uint64_t bytes = fi_shape_get_bytes((int *)(v87[27] + 40), &v95);
          if (bytes) {
            goto LABEL_19;
          }
          bzero(__dst, v95);
          uint64_t v43 = (*(uint64_t (**)(uint64_t))(v87[27] + 128))(a1);
          if (!v43)
          {
            uint64_t v88 = *(void *)(a2 + 72);
            int v44 = v10[1];
            int __srca = *v10;
            uint64_t bytes = fi_shape_get_bytes((int *)(*((void *)v10 + 28) + 20), &v95);
            if (bytes) {
              goto LABEL_19;
            }
            uint64_t v83 = (float *)(v90 + 4 * padded_bytes);
            if (v12)
            {
              int v45 = 0;
              int v46 = 0;
              __srcb = (void *)(v88 + 4 * (v44 * __srca));
              do
              {
                memcpy((void *)(v90 + 4 * ((v10[1] + 2 * v10[12]) * v46)), &__dst[v45 * v10[12]], 4 * (2 * v10[12]));
                v45 += 2;
                memcpy((void *)(v90 + 4 * (v45 * v10[12]) + 4 * (v10[1] * v46++)), __srcb, 4 * v10[1]);
              }
              while (v12 != v46);
            }
            int v93 = v12;
            forward_tacotron_decoder(a1, a2, (char *)__dst, &v95, (uint64_t)v18, v83, (unsigned int *)&v93);
            uint64_t bytes = v47;
            if (v47) {
              goto LABEL_19;
            }
            int v48 = *(_DWORD *)(a2 + 8);
            if (v48 == 66)
            {
              uint64_t v54 = v93;
              if (v93)
              {
                int v55 = 0;
                uint64_t v56 = 0;
                do
                {
                  __dst[v56] = 0.0;
                  if (v12)
                  {
                    uint64_t v57 = 0;
                    float v58 = 0.0;
                    do
                    {
                      uint64_t v59 = (v55 + v57);
                      if (*(float *)&v18[v59] > v58)
                      {
                        __dst[v56] = (float)v57;
                        float v58 = *(float *)&v18[v59];
                      }
                      ++v57;
                    }
                    while (v12 != v57);
                  }
                  ++v56;
                  v55 += v12;
                }
                while (v56 != v54);
                if (v54 >= 2)
                {
                  int v60 = __dst + 1;
                  float v61 = *__dst;
                  uint64_t v62 = v54 - 1;
                  do
                  {
                    float v63 = *v60;
                    if (*v60 < v61)
                    {
                      *int v60 = v61;
                      float v63 = v61;
                    }
                    ++v60;
                    float v61 = v63;
                    --v62;
                  }
                  while (v62);
                }
                uint64_t v64 = 0;
                do
                {
                  __dst[v64] = __dst[v64] + 1.0;
                  ++v64;
                }
                while (v54 != v64);
                float v65 = *__dst;
                float *__dst = 1.0;
                if (v54 >= 2)
                {
                  for (uint64_t i = 1; i != v54; ++i)
                  {
                    if (__dst[i] <= v65)
                    {
                      uint64_t v67 = (float)(v65 + -0.99);
                    }
                    else
                    {
                      do
                      {
                        float v65 = v65 + 1.0;
                        uint64_t v67 = (float)(v65 + -0.99);
                        __dst[v67] = 0.0;
                      }
                      while (__dst[i] > v65);
                    }
                    __dst[v67] = __dst[v67] + 1.0;
                  }
                }
              }
              else
              {
                float v65 = *__dst;
                float *__dst = 1.0;
              }
              for (float j = (float)v12 + -0.1; j > v65; __dst[(float)(v65 + -0.99)] = 0.0)
                float v65 = v65 + 1.0;
              if (v12)
              {
                uint64_t v69 = v12;
                do
                {
                  if (*__dst < 0.5) {
                    float *__dst = 1.0;
                  }
                  ++__dst;
                  --v69;
                }
                while (v69);
              }
              *(_DWORD *)(v89 + 20) = 1;
              LODWORD(v96) = v12;
              uint64_t v39 = fi_shape_set(1, (uint64_t)&v96, 4, a2 + 40);
              goto LABEL_17;
            }
            if (v48 != 63)
            {
              uint64_t bytes = 0;
              goto LABEL_19;
            }
            int v49 = v93;
            uint64_t bytes = forward_tacotron_postnet(a1, a2, __dst, &v95, v93);
            if (bytes) {
              goto LABEL_19;
            }
            if (v10[45] == 20)
            {
              unsigned int v50 = v49 * v13;
              if ((v49 * v13) < 0xB)
              {
                LODWORD(v52) = 0;
              }
              else
              {
                uint64_t v51 = 0;
                uint64_t v52 = v50 - 10;
                unsigned int v53 = 19;
                while (__dst[v53] <= 0.3)
                {
                  ++v51;
                  v53 += 20;
                  if (v52 == v51) {
                    goto LABEL_92;
                  }
                }
                LODWORD(v52) = v51;
              }
LABEL_92:
              if ((int)v52 + 5 >= v50)
              {
                unsigned int v75 = 0;
              }
              else
              {
                unsigned int v75 = 0;
                unsigned int v76 = v50 - v52 - 5;
                unsigned int v77 = 20 * v13 * v49 - 1;
                while (__dst[v77] <= 0.3)
                {
                  ++v75;
                  v77 -= 20;
                  if (v76 == v75)
                  {
                    unsigned int v75 = v76;
                    break;
                  }
                }
              }
              BOOL v78 = v52 >= 7;
              int v79 = v52 - 7;
              if (!v78) {
                int v79 = 0;
              }
              int v91 = v79;
              int v74 = v75 >= 5 ? v75 - 5 : 0;
            }
            else
            {
              if (v10[20] == 1)
              {
                unsigned int v70 = v95 >> 2;
                if (v95 >= 4)
                {
                  if (v70 <= 1) {
                    uint64_t v71 = 1;
                  }
                  else {
                    uint64_t v71 = v70;
                  }
                  uint64_t v72 = __dst;
                  do
                  {
                    float v73 = *v72;
                    if (*v72 > 1.0) {
                      float v73 = 1.0;
                    }
                    if (v73 < 0.0) {
                      float v73 = 0.0;
                    }
                    *v72++ = (float)(v73 * 11.513) + -9.2103;
                    --v71;
                  }
                  while (v71);
                }
                fast_exp(__dst, v70, __dst);
              }
              int v91 = 0;
              int v74 = 0;
            }
            uint64_t bytes = fi_shape_get_bytes((int *)(a2 + 40), &v94);
            if (bytes) {
              goto LABEL_19;
            }
            if (v94 != v95) {
              *(_DWORD *)(v89 + 20) = 1;
            }
            int v80 = v10[45];
            LODWORD(v96) = v49 * v13 - (v91 + v74);
            HIDWORD(v96) = v80;
            uint64_t bytes = fi_shape_set(2, (uint64_t)&v96, 4, a2 + 40);
            if (bytes) {
              goto LABEL_19;
            }
            if (v91) {
              memmove(__dst, &__dst[HIDWORD(v96) * v91], 4 * (v96 * HIDWORD(v96)));
            }
            int v35 = v96;
            uint64_t v34 = (uint64_t **)a2;
            int v36 = v12;
            uint64_t v37 = (uint64_t)v18;
            int v38 = v91;
LABEL_16:
            uint64_t v39 = send_alignment_out(v34, v35, v36, v37, v38);
LABEL_17:
            uint64_t bytes = v39;
            goto LABEL_19;
          }
          uint64_t bytes = v43;
          long long v30 = "tacotron encoder cbhg forward failed!";
        }
      }
    }
    log_OutText(*__src, (uint64_t)"FastInfer", 0, 0, (uint64_t)v30, v27, v28, v29, v81);
LABEL_19:
    (*(void (**)(uint64_t, _DWORD *))(v11[1] + 48))(v11[2], v18);
    return bytes;
  }
  log_OutText(*v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Memory allocation failed!", v15, v16, v17, v81);
  return 10;
}

uint64_t tacotron_update_shape(uint64_t a1, _DWORD *a2)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a1 + 120);
  int v30 = 0;
  int v5 = a2[4];
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v5;
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(v4 + 192) + 144))();
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(v4 + 200) + 144))();
    if (!result)
    {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(v4 + 208) + 144))();
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(v4 + 216) + 144))();
        if (!result)
        {
          v26[0] = 0;
          v26[1] = 0;
          int v27 = 0;
          v24[0] = 0;
          v24[1] = 0;
          int v25 = 0;
          int step = fi_shape_get_step(a2);
          int v8 = *(_DWORD *)(v4 + 4) + 2 * *(_DWORD *)(v4 + 48);
          int v28 = step;
          unsigned int v29 = v8;
          uint64_t result = fi_shape_set(2, (uint64_t)&v28, 4, (uint64_t)v24);
          if (!result)
          {
            uint64_t result = (*(uint64_t (**)(void, void *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 224) + 144))(*(void *)(v4 + 224), v24, v9, v10, v11, v12);
            if (!result)
            {
              unsigned int v13 = *(_DWORD *)(v4 + 56);
              int v28 = *(_DWORD *)(v4 + 60) * *(_DWORD *)(v4 + 184);
              unsigned int v29 = v13;
              uint64_t result = fi_shape_set(2, (uint64_t)&v28, 4, (uint64_t)v26);
              if (!result)
              {
                (*(void (**)(void, void *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 232)
                                                                                             + 144))(*(void *)(v4 + 232), v26, v14, v15, v16, v17);
                int v18 = 2 * *(_DWORD *)(v4 + 172);
                int v28 = *(_DWORD *)(v4 + 60) * *(_DWORD *)(v4 + 184);
                unsigned int v29 = v18;
                uint64_t result = fi_shape_set(2, (uint64_t)&v28, 4, (uint64_t)v26);
                if (!result)
                {
                  (*(void (**)(void, void *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 240)
                                                                                               + 144))(*(void *)(v4 + 240), v26, v19, v20, v21, v22);
                  unsigned int v23 = *(_DWORD *)(v4 + 180);
                  if (v23 <= 0x100) {
                    unsigned int v23 = 256;
                  }
                  unsigned int v29 = v23;
                  return fi_shape_set(2, (uint64_t)&v28, 4, a1 + 40);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t tacotron_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 120);
  uint64_t v21 = 0;
  if (v8)
  {
    int padded_len = get_padded_len(*(unsigned int *)(v8 + 4), 8u);
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 192) + 152))();
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(HIDWORD(v21) + (padded_len << 9) + (int)v21, 8u);
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 200) + 152))();
      if (!result)
      {
        int v14 = get_padded_bytes(HIDWORD(v21) + (int)v21 + padded_bytes, 8u);
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 208) + 152))();
        if (!result)
        {
          int v15 = get_padded_bytes(HIDWORD(v21) + (int)v21 + v14, 8u);
          uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 216) + 152))();
          if (!result)
          {
            int v16 = get_padded_bytes(HIDWORD(v21) + (int)v21 + v15, 8u);
            uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 224) + 152))();
            if (!result)
            {
              int v17 = get_padded_bytes(HIDWORD(v21) + (int)v21 + v16, 8u);
              uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 232) + 152))();
              if (!result)
              {
                int v18 = get_padded_bytes(HIDWORD(v21) + (int)v21 + v17, 8u);
                uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 240) + 152))();
                if (!result)
                {
                  int v19 = get_padded_bytes(HIDWORD(v21) + (int)v21 + v18, 8u);
                  uint64_t result = 0;
                  *a2 = v19;
                  *a3 = 0;
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v20);
    return 7;
  }
  return result;
}

uint64_t tacotron_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 120);
  int v18 = 0;
  if (v9)
  {
    uint64_t result = tacotron_get_reserved_glbBuf_bytes(a1, &v18);
    if (!result)
    {
      uint64_t v11 = 0;
      unsigned int v12 = 0;
      uint64_t v13 = v9 + 192;
      do
      {
        int v14 = *(uint64_t (**)(void))(*(void *)(v13 + v11) + 160);
        if (v14)
        {
          uint64_t result = v14();
          if (result) {
            return result;
          }
          if (*(_DWORD *)(*(void *)(v13 + v11) + 248) > v12) {
            unsigned int v12 = *(_DWORD *)(*(void *)(v13 + v11) + 248);
          }
        }
        v11 += 8;
      }
      while (v11 != 56);
      int v15 = v18;
      padded_uint64_t bytes = get_padded_bytes(v12, 8u);
      uint64_t result = 0;
      *(_DWORD *)(a1 + 248) = padded_bytes + v15;
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t tacotron_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 120);
  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 72);
    padded_uint64_t bytes = get_padded_len(*(unsigned int *)(v8 + 4), 8u) << 9;
    uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 192), v9, &padded_bytes);
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
      uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 200), v9, &padded_bytes);
      if (!result)
      {
        padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
        uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 208), v9, &padded_bytes);
        if (!result)
        {
          padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
          uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 216), v9, &padded_bytes);
          if (!result)
          {
            padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
            uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 224), v9, &padded_bytes);
            if (!result)
            {
              padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
              uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 232), v9, &padded_bytes);
              if (!result)
              {
                padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
                uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 240), v9, &padded_bytes);
                if (!result)
                {
                  get_padded_bytes(padded_bytes, 8u);
                  return 0;
                }
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v11);
    return 7;
  }
  return result;
}

uint64_t tacotron_assign_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 120);
  unsigned int v20 = 0;
  reserved_glbBuf_uint64_t bytes = tacotron_get_reserved_glbBuf_bytes(a1, &v20);
  if (!reserved_glbBuf_bytes)
  {
    uint64_t v4 = v2[24];
    uint64_t v5 = v20;
    *(void *)(v4 + 240) = *(void *)(a1 + 240) + v20;
    int v6 = *(void (**)(void))(v4 + 168);
    if (v6) {
      v6();
    }
    uint64_t v7 = v2[25];
    *(void *)(v7 + 240) = *(void *)(a1 + 240) + v5;
    uint64_t v8 = *(void (**)(void))(v7 + 168);
    if (v8) {
      v8();
    }
    uint64_t v9 = v2[26];
    *(void *)(v9 + 240) = *(void *)(a1 + 240) + v5;
    uint64_t v10 = *(void (**)(void))(v9 + 168);
    if (v10) {
      v10();
    }
    uint64_t v11 = v2[27];
    *(void *)(v11 + 240) = *(void *)(a1 + 240) + v5;
    unsigned int v12 = *(void (**)(void))(v11 + 168);
    if (v12) {
      v12();
    }
    uint64_t v13 = v2[28];
    *(void *)(v13 + 240) = *(void *)(a1 + 240) + v5;
    int v14 = *(void (**)(void))(v13 + 168);
    if (v14) {
      v14();
    }
    uint64_t v15 = v2[29];
    *(void *)(v15 + 240) = *(void *)(a1 + 240) + v5;
    int v16 = *(void (**)(void))(v15 + 168);
    if (v16) {
      v16();
    }
    uint64_t v17 = v2[30];
    *(void *)(v17 + 240) = *(void *)(a1 + 240) + v5;
    int v18 = *(void (**)(void))(v17 + 168);
    if (v18) {
      v18();
    }
  }
  return reserved_glbBuf_bytes;
}

uint64_t tacotron_update_param(uint64_t a1, _DWORD *a2, int a3, int a4)
{
  if (*(_DWORD *)(a1 + 8) != a4) {
    return 0;
  }
  uint64_t result = 7;
  if (a3 == 4)
  {
    int v6 = *(_DWORD **)(a1 + 120);
    if (v6)
    {
      uint64_t result = 0;
      *int v6 = *a2;
    }
  }
  return result;
}

uint64_t tacotron_set_align_address(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 120);
  if (!v2) {
    return 7;
  }
  uint64_t result = 0;
  *(void *)(v2 + 248) = a2;
  *(_DWORD *)(v2 + 256) = *(_DWORD *)(a2 + 8);
  return result;
}

uint64_t send_alignment_out(uint64_t **a1, int a2, int a3, uint64_t a4, int a5)
{
  uint64_t v9 = a1[15];
  if (*((_DWORD *)v9 + 64) >= (a3 * a2 + 2))
  {
    size_t v11 = 4 * (a3 * a2);
    bzero(*(void **)v9[31], v11 + 8);
    uint64_t v15 = *(_DWORD **)v9[31];
  }
  else
  {
    uint64_t v10 = *a1;
    size_t v11 = 4 * (a3 * a2);
    *(void *)v9[31] = heap_Realloc((uint64_t *)(*a1)[2], *(void *)v9[31], v11 + 8);
    uint64_t v15 = *(_DWORD **)v9[31];
    if (!v15)
    {
      log_OutText(*v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Memory allocation failed!", v12, v13, v14, v17);
      return 10;
    }
  }
  *uint64_t v15 = a3;
  v15[1] = a2;
  memcpy(v15 + 2, (const void *)(a4 + 4 * (a5 * a3)), v11);
  return 0;
}

void forward_tacotron_decoder(uint64_t a1, uint64_t a2, char *a3, _DWORD *a4, uint64_t a5, float *a6, unsigned int *a7)
{
  uint64_t v12 = *(void *)(a2 + 120);
  float v44 = 0.0;
  uint64_t v13 = *(unsigned int *)(a2 + 24);
  int v15 = *(_DWORD *)(v12 + 56);
  int v14 = *(_DWORD *)(v12 + 60);
  if (!(*(unsigned int (**)(void))(*(void *)(v12 + 224) + 176))()
    && !fi_shape_get_bytes((int *)(a2 + 40), a4))
  {
    bzero(a3, *a4);
    *a7 = 0;
    if (*(_DWORD *)(v12 + 184))
    {
      int v43 = 0;
      size_t v16 = (4 * v14 * v15);
      unsigned int v40 = 10 * v13;
      do
      {
        if ((*(unsigned int (**)(uint64_t))(*(void *)(v12 + 224) + 128))(a1)) {
          break;
        }
        uint64_t v17 = a6;
        int v18 = &a6[get_padded_len(1, 8u)];
        size_t v19 = v16;
        memcpy(&a3[v43], v18, v16);
        uint64_t alignment = get_alignment(*(void *)(v12 + 224), v20, v21, v22, v23, v24, v25, v26);
        if (v14)
        {
          uint64_t v34 = (const void *)alignment;
          for (int i = 0; i != v14; ++i)
            memcpy((void *)(a5 + 4 * (i + *a7 * v14) * v13), v34, 4 * v13);
        }
        get_last_alignment(*(void *)(v12 + 224), &v44, v28, v29, v30, v31, v32, v33);
        if (v36) {
          break;
        }
        size_t v16 = v19;
        v43 += v19;
        unsigned int v37 = *a7;
        a6 = v17;
        if (*a7 > v13 >> 2)
        {
          if (*v17 > 0.8 || v44 > 0.8) {
            goto LABEL_25;
          }
          if (v37 < 7)
          {
            if (v37 > v40) {
              goto LABEL_25;
            }
          }
          else if (*(float *)(a5 + 4 * (v37 - 6) * v14) == (float)(v13 - 1) || v37 > v40)
          {
LABEL_25:
            bzero(&a3[v43 - (v16 >> 1)], v16 >> 1);
            ++*a7;
            return;
          }
        }
        unsigned int v39 = v37 + 1;
        *a7 = v39;
      }
      while (v39 < *(_DWORD *)(v12 + 184));
    }
  }
}

uint64_t forward_tacotron_postnet(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4, int a5)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a2 + 120);
  uint64_t v10 = *(uint64_t **)a2;
  size_t v11 = *(void **)(a2 + 240);
  v35[0] = 0;
  v35[1] = 0;
  int v12 = *(_DWORD *)(v9 + 56);
  int v13 = *(_DWORD *)(v9 + 60) * a5;
  int v36 = 0;
  int v37 = v13;
  int v38 = v12;
  int v39 = 0;
  uint64_t bytes = fi_shape_set(2, (uint64_t)&v37, 4, (uint64_t)v35);
  if (!bytes)
  {
    (*(void (**)(void))(*(void *)(v9 + 232) + 144))();
    uint64_t v16 = *(void *)(v9 + 232);
    uint64_t v17 = *(uint64_t (**)(void))(v16 + 160);
    if (v17)
    {
      uint64_t bytes = v17();
      if (bytes) {
        return bytes;
      }
      uint64_t v16 = *(void *)(v9 + 232);
    }
    int v18 = *(uint64_t (**)(void))(v16 + 168);
    if (v18)
    {
      uint64_t bytes = v18();
      if (bytes) {
        return bytes;
      }
      uint64_t v16 = *(void *)(v9 + 232);
    }
    uint64_t bytes = fi_shape_get_bytes((int *)(v16 + 40), a4);
    if (!bytes)
    {
      bzero(v11, *a4);
      uint64_t bytes = (*(uint64_t (**)(void))(*(void *)(v9 + 232) + 176))();
      if (!bytes)
      {
        uint64_t v19 = (*(uint64_t (**)(uint64_t))(*(void *)(v9 + 232) + 128))(a1);
        if (v19)
        {
          uint64_t bytes = v19;
          uint64_t v23 = *v10;
          uint64_t v24 = "tacotron post cbhg forward failed!";
LABEL_13:
          log_OutText(v23, (uint64_t)"FastInfer", 0, 0, (uint64_t)v24, v20, v21, v22, v34);
          return bytes;
        }
        int v25 = 2 * *(_DWORD *)(v9 + 172);
        int v37 = *(_DWORD *)(v9 + 60) * a5;
        int v38 = v25;
        uint64_t bytes = fi_shape_set(2, (uint64_t)&v37, 4, (uint64_t)v35);
        if (!bytes)
        {
          (*(void (**)(void))(*(void *)(v9 + 240) + 144))();
          uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v9 + 240) + 40), a4);
          if (!bytes)
          {
            if (*(_DWORD *)(v9 + 180) != *(_DWORD *)(v9 + 56))
            {
              bzero(a3, *a4);
              uint64_t bytes = (*(uint64_t (**)(uint64_t))(*(void *)(v9 + 240) + 128))(a1);
              if (!bytes) {
                return bytes;
              }
              uint64_t v23 = *v10;
              uint64_t v24 = "tacotron post dense forward failed!";
              goto LABEL_13;
            }
            uint64_t v26 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(v10[1] + 16))(v10[2], (unint64_t)*a4 >> 2, 4);
            if (v26)
            {
              uint64_t v30 = (float *)v26;
              uint64_t bytes = (*(uint64_t (**)(uint64_t))(*(void *)(v9 + 240) + 128))(a1);
              if (bytes)
              {
                log_OutText(*v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"tacotron post dense forward failed!", v31, v32, v33, v34);
              }
              else
              {
                axpy(*a4 >> 2, v30, 1, (float *)a3, 1, 1.0);
                if (*(_DWORD *)(v9 + 80) == 2) {
                  relu_array_f32(*a4 >> 2, (float *)a3);
                }
              }
              (*(void (**)(uint64_t, float *))(v10[1] + 48))(v10[2], v30);
            }
            else
            {
              log_OutText(*v10, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Memory allocation failed!", v27, v28, v29, v34);
              return 10;
            }
          }
        }
      }
    }
  }
  return bytes;
}

uint64_t tacotron_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v3 = *(void *)(a1 + 120);
  unsigned int v7 = 0;
  uint64_t result = fi_shape_get_bytes((int *)(*(void *)(v3 + 232) + 40), &v7);
  if (result)
  {
    padded_uint64_t bytes = 0;
  }
  else
  {
    padded_uint64_t bytes = get_padded_bytes(v7, 8u);
    uint64_t result = fi_shape_get_bytes((int *)(*(void *)(v3 + 224) + 40), &v7);
    if (!result)
    {
      int v6 = get_padded_bytes(v7, 8u);
      uint64_t result = 0;
      padded_bytes += v6;
    }
  }
  *a2 = padded_bytes;
  return result;
}

uint64_t create_lpcnet_layer(uint64_t *a1, long long *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v11)
  {
    uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 288);
    uint64_t v16 = v12;
    if (v12)
    {
      long long v17 = *a2;
      long long v18 = a2[1];
      long long v19 = a2[3];
      *(_OWORD *)(v12 + 32) = a2[2];
      *(_OWORD *)(v12 + 48) = v19;
      *(_OWORD *)uint64_t v12 = v17;
      *(_OWORD *)(v12 + 16) = v18;
      long long v20 = a2[4];
      long long v21 = a2[5];
      long long v22 = a2[7];
      *(_OWORD *)(v12 + 96) = a2[6];
      *(_OWORD *)(v12 + 112) = v22;
      *(_OWORD *)(v12 + 64) = v20;
      *(_OWORD *)(v12 + 80) = v21;
      long long v23 = a2[8];
      long long v24 = a2[9];
      long long v25 = a2[10];
      *(_DWORD *)(v12 + 176) = *((_DWORD *)a2 + 44);
      *(_OWORD *)(v12 + 144) = v24;
      *(_OWORD *)(v12 + 160) = v25;
      *(_OWORD *)(v12 + 128) = v23;
      int v43 = 0;
      long long v41 = 0u;
      long long v42 = 0u;
      if (a2)
      {
        int v26 = *((_DWORD *)a2 + 22);
        unsigned int v27 = *((_DWORD *)a2 + 23);
        LODWORD(v45) = 5;
        HIDWORD(v45) = v26;
        int v46 = 0;
        uint64_t v44 = v27 | 0x100000000;
        if (create_fc_layer(a1, &v45, &v44, 0, a3, (uint64_t *)(v12 + 200)))
        {
          uint64_t v28 = *a1;
          uint64_t v29 = "create feature_dense1 failed!";
        }
        else
        {
          unsigned int v34 = *((_DWORD *)a2 + 25);
          HIDWORD(v45) = *((_DWORD *)a2 + 24);
          uint64_t v44 = v34 | 0x100000000;
          if (create_fc_layer(a1, &v45, &v44, 0, a3, (uint64_t *)(v16 + 208)))
          {
            uint64_t v28 = *a1;
            uint64_t v29 = "create feature_dense2 failed!";
          }
          else
          {
            unsigned int v35 = *((_DWORD *)a2 + 27);
            HIDWORD(v45) = *((_DWORD *)a2 + 26);
            uint64_t v44 = v35 | 0x100000000;
            if (create_fc_layer(a1, &v45, &v44, 0, a3, (uint64_t *)(v16 + 216)))
            {
              uint64_t v28 = *a1;
              uint64_t v29 = "create gru_a_dense failed!";
            }
            else
            {
              HIDWORD(v45) = 2 * *((_DWORD *)a2 + 41);
              LODWORD(v44) = *((_DWORD *)a2 + 43);
              HIDWORD(v44) = 1;
              if (create_fc_layer(a1, &v45, &v44, 0, a3, (uint64_t *)(v16 + 224)))
              {
                uint64_t v28 = *a1;
                uint64_t v29 = "create dual_fc1 failed!";
              }
              else if (config_conv1d_layer(*((_DWORD *)a2 + 17), *((_DWORD *)a2 + 16), 1, 1, 1, 1, *((_DWORD *)a2 + 18), &v41))
              {
                uint64_t v28 = *a1;
                uint64_t v29 = "create conv1d_proj sub-conv1d_norm1 cfg failed!";
              }
              else if (create_conv1d_layer(a1, &v41, 0, a3, (uint64_t ***)(v16 + 184)))
              {
                uint64_t v28 = *a1;
                uint64_t v29 = "create feature_conv1 layer failed!";
              }
              else
              {
                int v36 = *((_DWORD *)a2 + 20);
                int v43 = *((_DWORD *)a2 + 21);
                LODWORD(v41) = *((_DWORD *)a2 + 19);
                LODWORD(v42) = v36;
                if (!create_conv1d_layer(a1, &v41, 0, a3, (uint64_t ***)(v16 + 192)))
                {
                  uint64_t v30 = 0;
                  *(void *)uint64_t v11 = a1;
                  *(void *)(v11 + 8) = 65;
                  *(_DWORD *)(v11 + 16) = 0;
                  *(void *)(v11 + 120) = v16;
                  *(void *)(v11 + 128) = forward_lpcnet_layer;
                  *(void *)(v11 + 144) = lpcnet_update_shape;
                  *(void *)(v11 + 136) = free_lpcnet;
                  *(void *)(v11 + 152) = lpcnet_wanted_wb_len;
                  *(void *)(v11 + 160) = lpcnet_request_glbBuf;
                  *(void *)(v11 + 184) = lpcnet_dispatch_weights;
                  *(void *)(v11 + 168) = lpcnet_assign_glbBuf;
                  *(void *)(v11 + 224) = lpcnet_update_param;
                  goto LABEL_23;
                }
                uint64_t v28 = *a1;
                uint64_t v29 = "create feature_conv2 layer failed!";
              }
            }
          }
        }
      }
      else
      {
        uint64_t v28 = *a1;
        uint64_t v29 = "config empty";
      }
      log_OutText(v28, (uint64_t)"FastInfer", 0, 0, (uint64_t)v29, v13, v14, v15, v41);
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"LPCNet init failed!", v37, v38, v39, v41);
      uint64_t v30 = 7;
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v13, v14, v15, v41);
      uint64_t v30 = 10;
    }
    *(void *)(v11 + 120) = v16;
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"lpcnet init param failed!", v31, v32, v33, v41);
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, v41);
    uint64_t v30 = 10;
  }
LABEL_23:
  *a4 = v11;
  return v30;
}

uint64_t forward_lpcnet_layer(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, uint64_t a5)
{
  uint64_t v9 = *(uint64_t **)a2;
  uint64_t v10 = *(void *)(a2 + 120);
  unsigned int v301 = 0;
  unsigned int v11 = *(_DWORD *)(a2 + 24);
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v9[1] + 16))(v9[2], 1, 280);
  if (!v15)
  {
    uint64_t v19 = *v9;
LABEL_6:
    log_OutText(v19, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v249);
    uint64_t weights_via_offset = 10;
    goto LABEL_27;
  }
  uint64_t v300 = v10;
  uint64_t v291 = a5;
  uint64_t v292 = a4;
  if (*(_DWORD *)(v10 + 232))
  {
    uint64_t weights_via_offset = 7;
    switch(*(_DWORD *)(v10 + 244))
    {
      case 0:
      case 2:
      case 5:
        uint64_t v285 = a3;
        BOOL v17 = v11 >= 2;
        unsigned int v18 = v11 - 2;
        goto LABEL_9;
      case 1:
        uint64_t v285 = a3;
        BOOL v17 = v11 >= 4;
        unsigned int v18 = v11 - 4;
LABEL_9:
        if (!v17) {
          unsigned int v18 = 0;
        }
        unsigned int v293 = v18;
        goto LABEL_12;
      default:
        goto LABEL_27;
    }
  }
  uint64_t v285 = a3;
  unsigned int v293 = v11;
LABEL_12:
  long long v20 = *(uint64_t **)a2;
  uint64_t v21 = *(void *)(a2 + 120);
  uint64_t v22 = a2;
  uint64_t v23 = *(void *)(a2 + 240);
  int v24 = *(_DWORD *)(v21 + 32);
  int v25 = *(_DWORD *)(v21 + 16);
  uint64_t v26 = *(void *)(v22 + 72);
  v302[0] = 0;
  uint64_t v294 = v22;
  int v295 = v20;
  int step = fi_shape_get_step((_DWORD *)(v22 + 20));
  *(void *)(v15 + 16) = v23;
  int padded_len = get_padded_len(*(unsigned int *)(v21 + 124), 8u);
  *(void *)(v15 + 24) = v23 + (4 * padded_len);
  int v29 = get_padded_len(*(unsigned int *)(v21 + 140), 8u) + padded_len;
  *(void *)(v15 + 32) = v23 + (4 * v29);
  int v30 = get_padded_len((3 * *(_DWORD *)(v21 + 160)), 8u) + v29;
  *(void *)(v15 + 40) = v23 + (4 * v30);
  int v31 = get_padded_len((3 * *(_DWORD *)(v21 + 160)), 8u) + v30;
  *(void *)(v15 + 48) = v23 + (4 * v31);
  int v32 = get_padded_len(*(unsigned int *)(v21 + 164), 8u) + v31;
  *(void *)(v15 + 56) = v23 + (4 * v32);
  int v33 = get_padded_len((3 * *(_DWORD *)(v21 + 140)), 8u) + v32;
  *(void *)(v15 + 64) = v23 + (4 * v33);
  int v34 = get_padded_len((2 * *(_DWORD *)(v21 + 164)), 8u) + v33;
  *(void *)(v15 + 72) = v23 + (4 * v34);
  int v35 = get_padded_len(*(unsigned int *)(v21 + 40), 8u) + v34;
  *(void *)(v15 + 128) = v23 + (4 * v35);
  int v36 = get_padded_len((*(_DWORD *)(v21 + 40) * step), 8u) + v35;
  *(void *)(v15 + 112) = v23 + (4 * v36);
  int v37 = get_padded_len((*(_DWORD *)(v21 + 96) * step), 8u) + v36;
  uint64_t v38 = v23 + (4 * v37);
  *(void *)(v15 + 120) = v38;
  *(void *)(v15 + 80) = v38;
  int v39 = get_padded_len((*(_DWORD *)(v21 + 60) * step), 8u) + v37;
  *(void *)(v15 + 88) = v23 + (4 * v39);
  int v40 = get_padded_len((*(_DWORD *)(v21 + 68) * step), 8u) + v39;
  *(void *)(v15 + 96) = v23 + (4 * v40);
  *(void *)(v15 + 104) = v23
                         + 4 * (get_padded_len((*(_DWORD *)(v21 + 80) * step), 8u) + v40);
  get_padded_len((*(_DWORD *)(v21 + 88) * step), 8u);
  unsigned int v41 = *(_DWORD *)(v21 + 104);
  if (v41 <= *(_DWORD *)(v21 + 68) + *(_DWORD *)(v21 + 60) + *(_DWORD *)(v21 + 80) + *(_DWORD *)(v21 + 88)) {
    unsigned int v41 = *(_DWORD *)(v21 + 68) + *(_DWORD *)(v21 + 60) + *(_DWORD *)(v21 + 80) + *(_DWORD *)(v21 + 88);
  }
  if (v41 <= 0x14A) {
    unsigned int v41 = 330;
  }
  *(void *)(v15 + 136) = v23 + 4 * (get_padded_len(v41 * step, 8u) + v37);
  get_padded_bytes(8 * v24 + 4 * (v25 + v24 * v24) + 8, 8u);
  unsigned int v42 = v302[0];
  *(void *)(v15 + 144) = v26 + (v302[0] & 0xFFFFFFFC);
  int v43 = v42 + 4 * get_padded_len(*(unsigned int *)(v21 + 56), 8u) * *(_DWORD *)(v21 + 52);
  *(void *)(v15 + 152) = v26 + (v43 & 0xFFFFFFFC);
  int v44 = v43 + 4 * get_padded_len(*(unsigned int *)(v21 + 104), 8u) * *(_DWORD *)(v21 + 112);
  *(void *)(v15 + 160) = v26 + (v44 & 0xFFFFFFFC);
  int v45 = v44 + 4 * get_padded_len(*(unsigned int *)(v21 + 104), 8u) * *(_DWORD *)(v21 + 116);
  *(void *)(v15 + 168) = v26 + (v45 & 0xFFFFFFFC);
  v302[0] = v45 + 4 * get_padded_len(*(unsigned int *)(v21 + 104), 8u) * *(_DWORD *)(v21 + 120);
  uint64_t weights_via_offset = fi_layer_find_weights_via_offset(*(void *)(v21 + 184), v26, v302);
  uint64_t v10 = v300;
  if (weights_via_offset) {
    goto LABEL_25;
  }
  v302[0] = get_padded_bytes(v302[0], 8u);
  uint64_t weights_via_offset = fi_layer_find_weights_via_offset(*(void *)(v21 + 192), v26, v302);
  if (weights_via_offset) {
    goto LABEL_25;
  }
  v302[0] = get_padded_bytes(v302[0], 8u);
  uint64_t weights_via_offset = fi_layer_find_weights_via_offset(*(void *)(v21 + 200), v26, v302);
  if (weights_via_offset) {
    goto LABEL_25;
  }
  v302[0] = get_padded_bytes(v302[0], 8u);
  uint64_t weights_via_offset = fi_layer_find_weights_via_offset(*(void *)(v21 + 208), v26, v302);
  if (weights_via_offset) {
    goto LABEL_25;
  }
  v302[0] = get_padded_bytes(v302[0], 8u);
  uint64_t weights_via_offset = fi_layer_find_weights_via_offset(*(void *)(v21 + 216), v26, v302);
  if (weights_via_offset) {
    goto LABEL_25;
  }
  v302[0] = get_padded_bytes(v302[0], 8u);
  *(void *)(v15 + 176) = v26 + (v302[0] & 0xFFFFFFFC);
  int v49 = *(_DWORD *)(v21 + 128);
  v302[0] += 4 * (v49 + (get_padded_len((3 * *(_DWORD *)(v21 + 124)), 8u) >> 4));
  padded_uint64_t bytes = get_padded_bytes(v302[0], 8u);
  *(void *)(v15 + 184) = v26 + (padded_bytes & 0xFFFFFFFC);
  v302[0] = padded_bytes + 12 * *(_DWORD *)(v21 + 124);
  int v51 = get_padded_bytes(v302[0], 8u);
  *(void *)(v15 + 192) = v26 + (v51 & 0xFFFFFFFC);
  v302[0] = v51 + (*(_DWORD *)(v21 + 128) << 6);
  v302[0] = get_padded_bytes(v302[0], 8u);
  *(void *)(v15 + 200) = v26 + (v302[0] & 0xFFFFFFFC);
  v302[0] += 4 * get_padded_len((3 * *(_DWORD *)(v21 + 124)), 8u);
  unsigned int v52 = get_padded_bytes(v302[0], 8u);
  v302[0] = v52;
  int v53 = *(_DWORD *)(v21 + 148);
  *(void *)(v15 + 208) = v26 + (v52 & 0xFFFFFFFC);
  if (v53 == 1)
  {
    v302[0] = v52 + (*(_DWORD *)(v21 + 152) << 6);
    int v54 = get_padded_bytes(v302[0], 8u);
    *(void *)(v15 + 240) = v26 + (v54 & 0xFFFFFFFC);
    v302[0] = v54 + 4 * (*(_DWORD *)(v21 + 152) + ((3 * *(_DWORD *)(v21 + 140) + 15) >> 4));
    int v55 = get_padded_bytes(v302[0], 8u);
    *(void *)(v15 + 256) = v26 + (v55 & 0xFFFFFFFC);
    v302[0] = v55 + (*(_DWORD *)(v21 + 156) << 6);
    int v56 = get_padded_bytes(v302[0], 8u);
    *(void *)(v15 + 248) = v26 + (v56 & 0xFFFFFFFC);
    unsigned int v57 = v56 + 4 * (*(_DWORD *)(v21 + 156) + ((3 * *(_DWORD *)(v21 + 140) + 15) >> 4));
  }
  else
  {
    int v58 = *(_DWORD *)(v21 + 140);
    int v59 = v58 * get_padded_len((*(_DWORD *)(v21 + 124) + *(_DWORD *)(v21 + 96)), 8u);
    uint64_t v10 = v300;
    unsigned int v57 = v302[0] + 12 * v59;
  }
  v302[0] = v57;
  v302[0] = get_padded_bytes(v57, 8u);
  *(void *)(v15 + 216) = v26 + (v302[0] & 0xFFFFFFFC);
  v302[0] += 4 * get_padded_len((3 * *(_DWORD *)(v21 + 140)), 8u);
  v302[0] = get_padded_bytes(v302[0], 8u);
  *(void *)(v15 + 224) = v26 + (v302[0] & 0xFFFFFFFC);
  v302[0] += 12 * get_padded_len(*(unsigned int *)(v21 + 140), 8u) * *(_DWORD *)(v21 + 140);
  v302[0] = get_padded_bytes(v302[0], 8u);
  *(void *)(v15 + 232) = v26 + (v302[0] & 0xFFFFFFFC);
  v302[0] += 4 * get_padded_len((3 * *(_DWORD *)(v21 + 140)), 8u);
  v302[0] = get_padded_bytes(v302[0], 8u);
  uint64_t weights_via_offset = fi_layer_find_weights_via_offset(*(void *)(v21 + 224), v26, v302);
  if (weights_via_offset)
  {
LABEL_25:
    uint64_t v60 = *v295;
    float v61 = "lpcnet pack buf manager failed!";
LABEL_26:
    log_OutText(v60, (uint64_t)"FastInfer", 0, 0, (uint64_t)v61, v46, v47, v48, v249);
    goto LABEL_27;
  }
  v302[0] = get_padded_bytes(v302[0], 8u);
  *(void *)(v15 + 264) = v26 + (v302[0] & 0xFFFFFFFC);
  v302[0] += 4 * get_padded_len(*(unsigned int *)(v21 + 164), 8u) * *(_DWORD *)(v21 + 168);
  *(void *)(v15 + 272) = v26 + (v302[0] & 0xFFFFFFFC);
  get_padded_len(1024, 8u);
  *(void *)uint64_t v15 = v285;
  *(void *)(v15 + 8) = v292;
  uint64_t v66 = v294;
  uint64_t v67 = *(void *)(v294 + 120);
  if (*(_DWORD *)(v10 + 232))
  {
    int v68 = *(const void **)(v67 + 248);
    if (v68) {
      memcpy(*(void **)(v15 + 72), v68, 4 * *(unsigned int *)(v67 + 40));
    }
    uint64_t v69 = *(const void **)(v67 + 256);
    if (v69) {
      memcpy(*(void **)(v15 + 16), v69, 4 * *(unsigned int *)(v67 + 124));
    }
    unsigned int v70 = *(const void **)(v67 + 264);
    if (v70) {
      memcpy(*(void **)(v15 + 24), v70, 4 * *(unsigned int *)(v67 + 140));
    }
  }
  else
  {
    bzero(*(void **)(v15 + 72), 4 * *(unsigned int *)(v67 + 40));
    bzero(*(void **)(v15 + 16), 4 * *(unsigned int *)(v67 + 124));
    bzero(*(void **)(v15 + 24), 4 * *(unsigned int *)(v67 + 140));
  }
  uint64_t v71 = *(unsigned int **)(v294 + 120);
  int v72 = *(_DWORD *)(v294 + 24);
  uint64_t v280 = *(unsigned int *)(v294 + 28);
  uint64_t v296 = v71[8];
  uint64_t v73 = v71[15];
  bzero(*(void **)(v15 + 80), 4 * (v73 * v72));
  int v286 = v72;
  if (v72)
  {
    int v75 = 0;
    unsigned int v76 = *(float **)(v15 + 80);
    unsigned int v77 = *(float **)v15;
    size_t v78 = 4 * v296;
    uint64_t v276 = 4 * v73;
    do
    {
      memcpy(v76, v77, v78);
      float v79 = *v76 * *v76;
      if (v296 < 2)
      {
        float v81 = *v76 * *v76;
      }
      else
      {
        uint64_t v80 = 4;
        float v81 = *v76 * *v76;
        do
        {
          float v82 = v76[(unint64_t)v80 / 4];
          float v81 = v81 + (float)(v82 * v82);
          float v83 = v82 * 1.4;
          v76[(unint64_t)v80 / 4] = v83;
          float v79 = v79 + (float)(v83 * v83);
          v80 += 4;
        }
        while (v78 != v80);
      }
      float v84 = Q_rsqrt(v79 / v81);
      if (v296)
      {
        unint64_t v85 = 0;
        do
        {
          v76[v85 / 4] = v84 * v76[v85 / 4];
          v85 += 4;
        }
        while (v78 != v85);
      }
      float v86 = v77[18];
      v76[36] = v86;
      v76[37] = v77[19];
      float v87 = floorf((float)((float)(v86 * 50.0) + 0.1) + 100.0);
      if (v87 <= 0.0) {
        float v87 = 0.0;
      }
      unsigned int v88 = v71[13];
      if (v88 <= v87) {
        unsigned int v89 = v88 - 1;
      }
      else {
        unsigned int v89 = v87;
      }
      uint64_t v90 = &v76[v71[9]];
      uint64_t v91 = *(void *)(v15 + 144);
      int v92 = get_padded_len(v71[14], 8u);
      memcpy(v90, (const void *)(v91 + 4 * v92 * v89), 4 * v71[14]);
      v77 += v280;
      unsigned int v76 = (float *)((char *)v76 + v276);
      ++v75;
      uint64_t v66 = v294;
    }
    while (v75 != v286);
  }
  uint64_t v256 = *(uint64_t **)v66;
  int v93 = *(unsigned int **)(v66 + 120);
  int v258 = *(_DWORD *)(v66 + 24);
  v302[0] = 0;
  uint64_t v94 = *(void *)(v15 + 136);
  uint64_t v95 = v93[8];
  uint64_t v96 = v93[4];
  unsigned int v97 = v93[5];
  uint64_t v260 = v93;
  uint64_t v98 = (v95 * v95);
  if (v96)
  {
    *(float *)v74.i32 = (float)v96;
    uint64_t v99 = (v96 + 1) & 0x1FFFFFFFELL;
    uint64x2_t v273 = (uint64x2_t)vdupq_n_s64(v96 - 1);
    float32x2_t v100 = (float32x2_t)vdup_lane_s32(v74, 0);
    uint64_t v101 = (float *)(v94 + 4 * v98 + 4);
    int32x2_t v102 = (int32x2_t)0x100000000;
    uint64x2_t v103 = (uint64x2_t)xmmword_20D6072C0;
    float32x2_t v104 = (float32x2_t)vdup_n_s32(0x3FC90FDBu);
    int64x2_t v270 = vdupq_n_s64(2uLL);
    do
    {
      int64x2_t v297 = (int64x2_t)v103;
      int32x2_t v287 = vmovn_s64((int64x2_t)vcgeq_u64(v273, v103));
      float32x2_t v105 = vdiv_f32(vmul_f32(vadd_f32(vcvt_f32_u32((uint32x2_t)v102), (float32x2_t)0x3F0000003F000000), v104), v100);
      float v277 = v105.f32[0];
      float v281 = sinf(v105.f32[1]);
      v106.f32[0] = sinf(v277);
      v106.f32[1] = v281;
      float32x2_t v107 = vmul_f32(v106, vmul_f32(v106, v104));
      float v278 = v107.f32[0];
      float v282 = sinf(v107.f32[1]);
      float v108 = sinf(v278);
      if (v287.i8[0]) {
        *(v101 - 1) = v108;
      }
      if (v287.i8[4]) {
        float *v101 = v282;
      }
      uint64x2_t v103 = (uint64x2_t)vaddq_s64(v297, v270);
      int32x2_t v102 = vadd_s32(v102, (int32x2_t)0x200000002);
      v101 += 2;
      v99 -= 2;
    }
    while (v99);
  }
  uint64_t v109 = v94 + 4 * v98;
  if (v95)
  {
    int v110 = 0;
    unsigned int v111 = 0;
    do
    {
      for (uint64_t i = 0; i != v95; ++i)
      {
        float v113 = cosf((float)((float)((float)((float)v111 + 0.5) * (float)i) * 3.1416)/ (float)v95);
        if (!i) {
          float v113 = v113 * 0.70711;
        }
        *(float *)(v94 + 4 * (v110 + i)) = v113;
      }
      ++v111;
      v110 += v95;
    }
    while (v111 != v95);
    uint64_t v66 = v294;
  }
  else
  {
    uint64_t v95 = 0;
  }
  uint64_t weights_via_offset = opus_fft_alloc_twiddles(v256, v97, (uint64_t *)(v109 + 4 * v96 + 4 * v95 + 4 * v95));
  uint64_t v10 = v300;
  unsigned int v114 = v293;
  if (!weights_via_offset)
  {
    if (v258)
    {
      for (int j = 0; j != v258; int j = v161 + 1)
      {
        unsigned int v279 = v260[10];
        int v283 = j;
        uint64_t v116 = (const void *)(*(void *)(v15 + 80) + 4 * v260[15] * j);
        uint64_t v117 = *(void *)(v15 + 136);
        uint64_t v274 = *(void *)(v15 + 128);
        uint64_t v118 = *(void *)(v66 + 120);
        uint64_t v119 = *(unsigned int *)(v118 + 32);
        uint64_t v271 = (v119 * v119);
        uint64_t v298 = *(unsigned int *)(v118 + 16);
        uint64_t v120 = v117 + 4 * v271 + 4 * v298;
        float32_t v121 = (float *)(v120 + 4 * v119);
        memcpy(v121, v116, 4 * v119);
        *float32_t v121 = *v121 + 4.0;
        if (v119)
        {
          unsigned int v122 = 0;
          for (uint64_t k = 0; k != v119; ++k)
          {
            float v124 = 0.0;
            uint64_t v125 = (float *)(v120 + 4 * v119);
            unsigned int v126 = v122;
            uint64_t v127 = v119;
            do
            {
              float v128 = *v125++;
              float v124 = v124 + (float)(v128 * *(float *)(v117 + 4 * v126++));
              --v127;
            }
            while (v127);
            *(float *)(v120 + 4 * k) = v124 * Q_rsqrt((float)v119 * 0.5);
            v122 += v119;
          }
          int v129 = (float *)(v117 + 4 * v271 + 4 * v298);
          uint64_t v130 = v119;
          do
          {
            *int v129 = expf(*v129 * 2.3026);
            ++v129;
            --v130;
          }
          while (v130);
        }
        uint64_t v131 = *(unsigned int **)(v66 + 120);
        uint64_t v132 = v131[10];
        uint64_t v133 = v131[5];
        size_t v134 = v131[6];
        uint64_t v264 = (unsigned int **)&v121[v119];
        uint64_t v268 = (float *)(v264 + 1);
        uint64_t v288 = v132;
        unsigned int v266 = (char *)v264 + 4 * v132 + 12;
        uint64_t v135 = &v266[4 * v132];
        unsigned int v136 = v131[8];
        bzero(v135, v134);
        if (v136 != 1)
        {
          int v137 = 0;
          uint64_t v138 = 0;
          unsigned int v139 = v133 / 0x50;
          do
          {
            uint64_t v140 = v138++;
            int v141 = eband5ms_0[v138];
            uint64_t v142 = (v141 - v137) * v139;
            if (v142)
            {
              uint64_t v143 = 0;
              int v144 = v139 * v137;
              do
              {
                *(float *)&v135[4 * (v144 + v143)] = (float)(*(float *)(v120 + 4 * v138)
                                                                         * (float)((float)v143
                                                                                 / (float)v142))
                                                                 + (float)((float)(1.0
                                                                                 - (float)((float)v143
                                                                                         / (float)v142))
                                                                         * *(float *)(v120 + 4 * v140));
                ++v143;
              }
              while (v142 != v143);
            }
            int v137 = v141;
          }
          while (v138 != v136 - 1);
        }
        uint64_t v262 = (float *)&v135[4 * v134];
        uint64_t v145 = &v262[v133];
        float v146 = (float32x2_t *)&v145[2 * v134];
        *(_DWORD *)&v135[4 * (v134 - 1)] = 0;
        bzero(v145, 8 * v134);
        if (v134)
        {
          uint64_t v147 = &v262[v133];
          size_t v148 = v134;
          do
          {
            int v149 = *(_DWORD *)v135;
            v135 += 4;
            *(_DWORD *)uint64_t v147 = v149;
            v147 += 2;
            --v148;
          }
          while (v148);
          int v150 = &v145[2 * v134];
          size_t v151 = v134;
          do
          {
            uint64_t v152 = *(void *)v145;
            v145 += 2;
            *(void *)int v150 = v152;
            v150 += 2;
            --v151;
          }
          while (v151);
        }
        if (v134 < v133)
        {
          size_t v153 = v133 - v134;
          uint64_t v154 = (float *)(v117 + 8 * (v119 + v288) + 20 * v134 + 4 * (v298 + v133 + v271) + 16);
          do
          {
            uint64_t v155 = &v146[v153];
            *(v154 - 1) = v155->f32[0];
            *uint64_t v154 = -v155->f32[1];
            v154 += 2;
            --v153;
          }
          while (v153);
        }
        unsigned int v156 = (int8x16_t *)&v146[v133];
        opus_fft_c(*v264, v146, v156);
        float v157 = (float)v133;
        *uint64_t v262 = *(float *)v156->i32 * (float)v133;
        uint64_t v158 = 8 * v288;
        if (v133 >= 2)
        {
          unsigned int v159 = (float *)(v117 + v158 + 8 * v119 + 4 * v134 + 4 * v298 + 4 * v271 + 16);
          do
            *v159++ = *(float *)&v156->i32[2 * --v133] * v157;
          while (v133 != 1);
        }
        uint64_t v160 = (v288 + 1);
        if (v288 == -1)
        {
          *uint64_t v268 = *v268 + (float)((float)(*v268 * 0.0001) + 0.70175);
          uint64_t v66 = v294;
          unsigned int v114 = v293;
          int v161 = v283;
        }
        else
        {
          size_t v163 = v158 + 4 * v134;
          uint64_t v164 = v117 + 8 * v119 + 4 * v298 + 4 * v271 + 12;
          uint64_t v165 = (v288 + 1);
          unsigned int v114 = v293;
          int v161 = v283;
          do
          {
            *(_DWORD *)(v164 - 4) = *(_DWORD *)(v164 + v163);
            v164 += 4;
            --v165;
          }
          while (v165);
          *uint64_t v268 = *v268 + (float)((float)(*v268 * 0.0001) + 0.70175);
          uint64_t v66 = v294;
          if (v160 >= 2)
          {
            uint64_t v166 = 0;
            do
            {
              uint64_t v162 = v117 + 8 * v119 + 4 * v298 + 4 * v271 + 12;
              *(float *)(v162 + 4 * v166) = *(float *)(v162 + 4 * v166)
                                          * (float)((float)((float)((float)(v166 + 1) * -0.00006)
                                                          * (float)(v166 + 1))
                                                  + 1.0);
              ++v166;
            }
            while (v160 - 1 != v166);
          }
        }
        celt_lpc((void *)(v274 + 4 * v279 * v161), v266, v268, v288);
      }
    }
    uint64_t weights_via_offset = fi_shape_get_bytes((int *)(*((void *)v260 + 23) + 40), v302);
    uint64_t v10 = v300;
    if (!weights_via_offset)
    {
      bzero(*(void **)(v15 + 88), v302[0]);
      uint64_t weights_via_offset = (*(uint64_t (**)(void))(*((void *)v260 + 23) + 128))(0);
      if (!weights_via_offset)
      {
        uint64_t weights_via_offset = fi_shape_get_bytes((int *)(*((void *)v260 + 24) + 40), v302);
        if (!weights_via_offset)
        {
          bzero(*(void **)(v15 + 96), v302[0]);
          uint64_t weights_via_offset = (*(uint64_t (**)(void))(*((void *)v260 + 24) + 128))(0);
          if (!weights_via_offset)
          {
            axpy(v260[15] * v258, *(float **)(v15 + 80), 1, *(float **)(v15 + 96), 1, 1.0);
            uint64_t weights_via_offset = fi_shape_get_bytes((int *)(*((void *)v260 + 25) + 40), v302);
            if (!weights_via_offset)
            {
              bzero(*(void **)(v15 + 104), v302[0]);
              uint64_t weights_via_offset = (*(uint64_t (**)(void))(*((void *)v260 + 25) + 128))(0);
              if (!weights_via_offset)
              {
                uint64_t weights_via_offset = fi_shape_get_bytes((int *)(*((void *)v260 + 26) + 40), v302);
                if (!weights_via_offset)
                {
                  bzero(*(void **)(v15 + 112), v302[0]);
                  uint64_t weights_via_offset = (*(uint64_t (**)(void))(*((void *)v260 + 26) + 128))(0);
                  if (!weights_via_offset)
                  {
                    uint64_t weights_via_offset = fi_shape_get_bytes((int *)(*((void *)v260 + 27) + 40), v302);
                    if (!weights_via_offset)
                    {
                      bzero(*(void **)(v15 + 120), v302[0]);
                      uint64_t weights_via_offset = (*(uint64_t (**)(void))(*((void *)v260 + 27) + 128))(0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  int v167 = (uint64_t *)(*(void *)(v15 + 136) + 4 * v260[8] * v260[8] + 4 * v260[4] + 4 * v260[8] + 4 * v260[8]);
  uint64_t v168 = *v167;
  if (*v167)
  {
    if (*(void *)(v168 + 48))
    {
      (*(void (**)(uint64_t))(v256[1] + 80))(v256[2]);
      *(void *)(v168 + 48) = 0;
    }
    if ((*(_DWORD *)(v168 + 8) & 0x80000000) != 0 && *(void *)(v168 + 56))
    {
      (*(void (**)(uint64_t))(v256[1] + 80))(v256[2]);
      *(void *)(v168 + 56) = 0;
    }
    (*(void (**)(uint64_t, uint64_t))(v256[1] + 80))(v256[2], v168);
    *int v167 = 0;
  }
  if (weights_via_offset)
  {
    uint64_t v60 = *v256;
    float v61 = "lpcnet forward frame network failed!";
    goto LABEL_26;
  }
  uint64_t v169 = *(void *)(v66 + 120);
  unsigned int v253 = *(_DWORD *)(v66 + 24);
  uint64_t v170 = *(float **)(v15 + 72);
  int v171 = *(_DWORD *)(v169 + 112);
  uint64_t v172 = ulaw2lin7;
  if (v171 == 256) {
    uint64_t v172 = ulaw2lin8;
  }
  uint64_t v265 = v172;
  uint64_t v267 = *(void *)(v15 + 8);
  uint64_t v173 = lin2ulaw7;
  if (v171 == 256) {
    uint64_t v173 = lin2ulaw8;
  }
  uint64_t v263 = v173;
  unsigned int v269 = *(float **)(v15 + 72);
  if (*(_DWORD *)(v169 + 232))
  {
    uint64_t weights_via_offset = 7;
    unsigned int v174 = *(_DWORD *)(v169 + 280);
    float v175 = *(float *)(v169 + 284);
    switch(*(_DWORD *)(v169 + 244))
    {
      case 0:
        unsigned int v178 = v253 - 2;
        if (v253 < 2) {
          unsigned int v178 = 0;
        }
        unsigned int v252 = 0;
        unsigned int v253 = v178;
        goto LABEL_160;
      case 1:
        BOOL v176 = v253 >= 4;
        unsigned int v177 = v253 - 4;
        goto LABEL_156;
      case 2:
      case 5:
        BOOL v176 = v253 >= 2;
        unsigned int v177 = v253 - 2;
LABEL_156:
        if (v176) {
          unsigned int v179 = v177;
        }
        else {
          unsigned int v179 = 0;
        }
        unsigned int v252 = 2;
        unsigned int v253 = v179;
LABEL_160:
        uint64_t v170 = *(float **)(v15 + 72);
        goto LABEL_161;
      default:
        goto LABEL_27;
    }
  }
  unsigned int v252 = 0;
  float v175 = 0.0;
  unsigned int v174 = 128;
LABEL_161:
  uint64_t v250 = *(uint64_t **)v66;
  char __dst = (void *)(*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)(*(void *)v66 + 8) + 16))(*(void *)(*(void *)v66 + 16), 1, 4 * *(unsigned int *)(v169 + 104));
  if (!__dst)
  {
    uint64_t v19 = *v250;
    goto LABEL_6;
  }
  unsigned int v251 = v252 + v253;
  if (v252 < v252 + v253)
  {
    unsigned int v180 = 0;
    unsigned int v181 = 0;
    uint64_t v259 = v170 + 1;
    uint64_t v182 = v252;
    uint64_t v261 = v169;
    do
    {
      unsigned int v289 = v181;
      unsigned int v254 = v180;
      if (v180 <= 5) {
        int v183 = 5;
      }
      else {
        int v183 = v180;
      }
      uint64_t v275 = v182;
      uint64_t v184 = *(void *)(v15 + 112) + 4 * (*(_DWORD *)(v169 + 96) * v182);
      memcpy(*(void **)(v15 + 56), *(const void **)(v15 + 216), 4 * (3 * *(_DWORD *)(v169 + 140)));
      if (*(_DWORD *)(v169 + 148) == 1) {
        uint64_t v185 = sparse_sgemv_accum16(*(void *)(v15 + 56), *(float **)(v15 + 256), 3 * *(_DWORD *)(v169 + 140), *(int **)(v15 + 248), v184);
      }
      else {
        gemm_ex(*(uint64_t **)v66, 1, (3 * *(_DWORD *)(v169 + 140)), *(unsigned int *)(v169 + 96), v184, *(unsigned int *)(v169 + 96), *(void *)(v15 + 208) + 4 * *(unsigned int *)(v169 + 124), *(unsigned int *)(v169 + 136), *(float32x4_t **)(v15 + 56), 3 * *(_DWORD *)(v169 + 140), 0);
      }
      if (v275 - (unint64_t)v252 <= 5) {
        unsigned int v186 = v252;
      }
      else {
        unsigned int v186 = v275 - 5;
      }
      if (v251 >= (int)v275 + 7) {
        unint64_t v187 = (v275 + 7);
      }
      else {
        unint64_t v187 = v251;
      }
      uint64_t v188 = *(float **)v15;
      if (v186 >= v187)
      {
        BOOL v194 = 0;
      }
      else
      {
        uint64_t v189 = v252 - 5 + v183;
        unint64_t v190 = v189 + 1;
        int v191 = *(_DWORD *)(v66 + 28);
        int v192 = v191 * v189 + 19;
        do
        {
          float v193 = v188[v192];
          BOOL v194 = v193 > 0.3;
          BOOL v195 = v193 > 0.3 || v190++ >= v187;
          v192 += v191;
        }
        while (!v195);
      }
      unsigned int v181 = v289;
      if (*(_DWORD *)(v169 + 12))
      {
        BOOL v257 = v194;
        int v272 = 0;
        int v196 = 0;
        float v197 = fmaxf((float)(v188[(20 * v275 + 19)] * 1.5) + -0.5, 0.0);
        do
        {
          uint64_t v198 = *(unsigned int *)(v169 + 40);
          unsigned int v290 = v181;
          int v284 = v196;
          if (v198)
          {
            int v199 = v275;
            unsigned int v200 = v275 * v198;
            float v201 = 0.0;
            unsigned int v202 = v170;
            do
            {
              float v203 = *v202++;
              float v201 = v201 - (float)(v203 * *(float *)(*(void *)(v15 + 128) + 4 * v200++));
              --v198;
            }
            while (v198);
          }
          else
          {
            float v201 = 0.0;
            int v199 = v275;
          }
          int v204 = ((uint64_t (*)(uint64_t, float))v263)(v185, v201);
          int v205 = v263(*v170);
          unsigned int v206 = *(const void **)(v15 + 32);
          if (v204 == 128 && v205 == 128 && v174 == 128)
          {
            uint64_t v207 = *(unsigned int *)(v169 + 104);
            if (v272 == 1)
            {
              size_t v208 = 4 * v207;
              uint64_t v209 = *(void **)(v15 + 32);
              uint64_t v210 = __dst;
            }
            else
            {
              accum4(v207, (float *)(*(void *)(v15 + 120) + 4 * (v207 * v199)), (float *)(*(void *)(v15 + 152) + 4 * (v207 << 7)), (float *)(*(void *)(v15 + 160) + 4 * (v207 << 7)), (float *)(*(void *)(v15 + 168) + 4 * (v207 << 7)), *(float **)(v15 + 32));
              size_t v208 = 4 * *(unsigned int *)(v169 + 104);
              uint64_t v209 = __dst;
              uint64_t v210 = v206;
            }
            memcpy(v209, v210, v208);
            int v272 = 1;
          }
          else
          {
            unsigned int v211 = *(_DWORD *)(v169 + 104);
            accum4(v211, (float *)(*(void *)(v15 + 120) + 4 * v211 * v199), (float *)(*(void *)(v15 + 152) + 4 * v211 * v205), (float *)(*(void *)(v15 + 160) + 4 * v211 * v204), (float *)(*(void *)(v15 + 168) + 4 * v211 * v174), *(float **)(v15 + 32));
          }
          uint64_t v212 = *(void *)(v66 + 120);
          float v213 = *(float **)(v15 + 16);
          float v215 = *(float **)(v15 + 32);
          unsigned int v214 = *(void **)(v15 + 40);
          uint64_t v216 = *(unsigned int *)(v212 + 124);
          memcpy(v214, *(const void **)(v15 + 200), 4 * (3 * v216));
          unsigned int v217 = 0;
          uint64_t v218 = 3;
          do
          {
            fi_multiply_add_ansic((float *)v214 + v217, (float *)(*(void *)(v15 + 184) + 4 * v217), v213, v216);
            v217 += v216;
            --v218;
          }
          while (v218);
          unsigned int v219 = &v215[v216];
          sparse_sgemv_accum16((uint64_t)v214, *(float **)(v15 + 192), 3 * v216, *(int **)(v15 + 176), (uint64_t)v213);
          axpy((2 * v216), (float *)v214, 1, v215, 1, 1.0);
          fi_activate_array(v215, (2 * v216), 11);
          fi_multiply_add_ansic(&v219[v216], (float *)v214 + (2 * v216), v219, v216);
          fi_activate_array(&v219[v216], v216, *(_DWORD *)(v212 + 132));
          fill_array_f32(v219, v216, 1.0);
          axpy(v216, v215, 1, v219, 1, -1.0);
          fi_multiply_multiply_add_ansic(v213, v215, &v219[v216], v219, v213, v216);
          float v299 = *(uint64_t **)v294;
          float v220 = *(_DWORD **)(v294 + 120);
          uint64_t v221 = *(float **)(v15 + 208);
          float v222 = *(float **)(v15 + 24);
          uint64_t v223 = *(float32x4_t **)(v15 + 32);
          int v224 = *(float32x4_t **)(v15 + 40);
          uint64_t v225 = v220[35];
          memcpy(v223, *(const void **)(v15 + 56), 4 * (3 * v225));
          uint64_t v226 = *(void *)(v15 + 16);
          if (v220[37] == 1) {
            sparse_sgemv_accum16((uint64_t)v223, v221, 3 * v225, *(int **)(v15 + 240), v226);
          }
          else {
            gemm_ex(v299, 1, (3 * v225), v220[31], v226, v220[31], (uint64_t)v221, v220[34], v223, 3 * v225, 0);
          }
          int v227 = &v223->f32[v225];
          memcpy(v224, *(const void **)(v15 + 232), 4 * (3 * v225));
          gemm(v299, 1, (3 * v225), v225, (uint64_t)v222, *(void *)(v15 + 224), v224, 0, v249);
          axpy((2 * v225), v224->f32, 1, v223->f32, 1, 1.0);
          fi_activate_array(v223->f32, (2 * v225), 11);
          fi_multiply_add_ansic(&v227[v225], &v224->f32[(2 * v225)], v227, v225);
          fi_activate_array(&v227[v225], v225, v220[36]);
          fill_array_f32(v227, v225, 1.0);
          axpy(v225, v223->f32, 1, v227, 1, -1.0);
          float v228 = fi_multiply_multiply_add_ansic(v222, v223->f32, &v227[v225], v227, v222, v225);
          uint64_t v66 = v294;
          unsigned int v229 = *(uint64_t **)v294;
          uint64_t v230 = *(void *)(v294 + 120);
          uint64_t v231 = *(float **)(v15 + 64);
          int v232 = *(float **)(v15 + 264);
          uint64_t v233 = *(float **)(v15 + 48);
          uint64_t v234 = *(unsigned int *)(v230 + 164);
          if ((*(unsigned int (**)(void, float))(*(void *)(v230 + 224) + 128))(0, v228)) {
            log_OutText(*v229, (uint64_t)"FastInfer", 0, 0, (uint64_t)"lpcnet forward dual_fc failed!", v235, v236, v237, v249);
          }
          else {
            fi_multiply_multiply_add_ansic(v231, v232, &v231[v234], &v232[v234], v233, v234);
          }
          uint64_t v10 = v300;
          unsigned int v114 = v293;
          uint64_t v170 = v269;
          uint64_t v169 = v261;
          unsigned int v238 = sample_from_pdf(*(float **)(v15 + 48), *(_DWORD *)(v261 + 164), v197, *(float *)(v261 + 44), *(float *)(*(void *)(v15 + 272) + 4 * (v290 & 0x3FF)));
          unsigned int v174 = v238;
          if (*(_DWORD *)(v261 + 164) <= 0xFFu)
          {
            unsigned int v239 = 0x100u / (unsigned __int16)*(_DWORD *)(v261 + 164);
            float v240 = *(float *)(*(void *)(v15 + 272) + 4 * (v290 & 0x3FF));
            unsigned int v174 = v238 * v239;
            BOOL v241 = v257;
            if (v240 >= 0.5) {
              BOOL v241 = 0;
            }
            if (v241) {
              v174 += (float)((float)((float)(v240 * 2.16) * (float)v239) * 0.5);
            }
          }
          float v242 = v201 + v265((float)v174);
          uint64_t v185 = (uint64_t)memmove(v259, v269, 4 * (*(_DWORD *)(v261 + 40) - 1));
          *unsigned int v269 = v242;
          float v175 = v242 + (float)(*(float *)(v261 + 48) * v175);
          if (v175 >= -32767.0) {
            float v243 = v175;
          }
          else {
            float v243 = -32767.0;
          }
          if (v243 <= 32767.0) {
            float v244 = v243 * 0.000030518;
          }
          else {
            float v244 = 1.0;
          }
          *(float *)(v267 + 4 * v290) = v244;
          unsigned int v181 = v290 + 1;
          int v196 = v284 + 1;
        }
        while ((v284 + 1) < *(_DWORD *)(v261 + 12));
      }
      uint64_t v182 = v275 + 1;
      unsigned int v180 = v254 + 1;
    }
    while (v254 + 1 != v253);
  }
  if (*(_DWORD *)(v169 + 232))
  {
    *(_DWORD *)(v169 + 280) = v174;
    *(float *)(v169 + 284) = v175;
    memcpy(*(void **)(v169 + 248), v170, 4 * *(unsigned int *)(v169 + 40));
    memcpy(*(void **)(v169 + 256), *(const void **)(v15 + 16), 4 * *(unsigned int *)(v169 + 124));
    memcpy(*(void **)(v169 + 264), *(const void **)(v15 + 24), 4 * *(unsigned int *)(v169 + 140));
  }
  (*(void (**)(uint64_t, void *))(v250[1] + 48))(v250[2], __dst);
  unsigned int v245 = *(_DWORD *)(v10 + 8);
  if (v245 == 22000)
  {
    unsigned int v246 = *(_DWORD *)(v10 + 12) * v114;
    uint64_t v247 = v291;
  }
  else
  {
    uint64_t weights_via_offset = src_generate(v9, 0xBu, v245 / 0x7D0, (uint64_t *)&v301);
    if (weights_via_offset) {
      goto LABEL_27;
    }
    if (*(_DWORD *)(v10 + 232) == 1 && *(_DWORD *)(v10 + 244)) {
      memcpy((void *)v301[4], *(const void **)(v10 + 272), 4 * *((unsigned int *)v301 + 10));
    }
    unsigned int v246 = src_filt(v301, v292, *(_DWORD *)(v10 + 12) * v293, *(void *)(v15 + 120));
    memcpy(v292, *(const void **)(v15 + 120), 4 * v246);
    if (*(_DWORD *)(v10 + 232) != 1 || (int v248 = *(_DWORD *)(v300 + 244), v248 == 2) || v248 == 5)
    {
      uint64_t v10 = v300;
    }
    else
    {
      uint64_t v10 = v300;
      memcpy(*(void **)(v300 + 272), (const void *)v301[4], 4 * *((unsigned int *)v301 + 10));
    }
    uint64_t v247 = v291;
    uint64_t v66 = v294;
  }
  uint64_t weights_via_offset = 0;
  *(_DWORD *)(v66 + 44) = v246;
  *(_DWORD *)(v247 + 20) = 1;
LABEL_27:
  uint64_t v62 = v301;
  if (v301)
  {
    if (*v301)
    {
      (*(void (**)(uint64_t, void))(v9[1] + 48))(v9[2], *v301);
      *unsigned int v301 = 0;
      *unsigned int v301 = 0;
      uint64_t v62 = v301;
    }
    if (v62[4])
    {
      (*(void (**)(uint64_t, uint64_t))(v9[1] + 48))(v9[2], v62[4]);
      v301[4] = 0;
    }
    (*(void (**)(uint64_t))(v9[1] + 48))(v9[2]);
    unsigned int v301 = 0;
  }
  if (v15) {
    (*(void (**)(uint64_t, uint64_t))(v9[1] + 48))(v9[2], v15);
  }
  if (weights_via_offset
    || *(_DWORD *)(v10 + 232) == 1 && ((int v63 = *(_DWORD *)(v10 + 244), v63 != 5) ? (v64 = v63 == 2) : (v64 = 1), v64))
  {
    if (*(void *)(v10 + 248))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(void *)(v10 + 248) = 0;
    }
    if (*(void *)(v10 + 256))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(void *)(v10 + 256) = 0;
    }
    if (*(void *)(v10 + 264))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(void *)(v10 + 264) = 0;
    }
    if (*(void *)(v10 + 272))
    {
      (*(void (**)(uint64_t))(v9[1] + 80))(v9[2]);
      *(void *)(v10 + 272) = 0;
    }
  }
  return weights_via_offset;
}

uint64_t lpcnet_update_shape(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a1 + 120);
  v16[0] = 0;
  v16[1] = 0;
  int v17 = 0;
  int v20 = 0;
  if (*(_DWORD *)a2 == 2)
  {
    long long v11 = *a2;
    *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
    *(_OWORD *)(a1 + 20) = v11;
    int v12 = *(_DWORD *)(v9 + 56) + *(_DWORD *)(v9 + 32) + 20;
    int v18 = *((_DWORD *)a2 + 1);
    int v19 = v12;
    fi_shape_set(2, (uint64_t)&v18, 4, (uint64_t)v16);
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 184) + 144))();
    if (!result)
    {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 192) + 144))();
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 200) + 144))();
        if (!result)
        {
          uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 208) + 144))();
          if (!result)
          {
            uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 216) + 144))();
            if (!result)
            {
              int v14 = *(_DWORD *)(v9 + 140);
              int v18 = 1;
              int v19 = v14;
              fi_shape_set(2, (uint64_t)&v18, 4, (uint64_t)v16);
              uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 224) + 144))();
              if (!result)
              {
                *(_DWORD *)(a1 + 40) = 1;
                *(_DWORD *)(a1 + 44) = 330 * *((_DWORD *)a2 + 1);
                *(_DWORD *)(a1 + 56) = 4;
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently lpcnet layer only support 2D input", a6, a7, a8, v15);
    return 7;
  }
  return result;
}

void *free_lpcnet(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[23]);
        fi_layer_free(v3[24]);
        fi_layer_free(v3[25]);
        fi_layer_free(v3[26]);
        fi_layer_free(v3[27]);
        fi_layer_free(v3[28]);
        (*(void (**)(void, uint64_t *))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v4 = *(void *)(v2 + 16);
      uint64_t v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v5(v4, v1);
    }
  }
  return result;
}

uint64_t lpcnet_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 120);
  if (v8)
  {
    int padded_len = get_padded_len(*(unsigned int *)(v8 + 56), 8u);
    int v11 = *(_DWORD *)(v8 + 52);
    int v12 = get_padded_len(*(unsigned int *)(v8 + 104), 8u);
    int v13 = *(_DWORD *)(v8 + 112);
    int v14 = get_padded_len(*(unsigned int *)(v8 + 104), 8u);
    int v15 = *(_DWORD *)(v8 + 116);
    int v16 = get_padded_len(*(unsigned int *)(v8 + 104), 8u);
    int v17 = *(_DWORD *)(v8 + 120);
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 184) + 152))();
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(4 * (v11 * padded_len + v13 * v12 + v15 * v14 + v17 * v16), 8u);
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 192) + 152))();
      if (!result)
      {
        unsigned int v20 = get_padded_bytes(padded_bytes, 8u);
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 200) + 152))();
        if (!result)
        {
          unsigned int v21 = get_padded_bytes(v20, 8u);
          uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 208) + 152))();
          if (!result)
          {
            unsigned int v22 = get_padded_bytes(v21, 8u);
            uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 216) + 152))();
            if (!result)
            {
              int v23 = get_padded_bytes(v22, 8u);
              int v24 = *(_DWORD *)(v8 + 128);
              unsigned int v25 = get_padded_len((3 * *(_DWORD *)(v8 + 124)), 8u);
              int v26 = get_padded_bytes(v23 + 4 * (v24 + (v25 >> 4)), 8u);
              int v27 = get_padded_bytes(v26 + 12 * *(_DWORD *)(v8 + 124), 8u);
              int v28 = get_padded_bytes(v27 + (*(_DWORD *)(v8 + 128) << 6), 8u);
              int v29 = get_padded_len((3 * *(_DWORD *)(v8 + 124)), 8u);
              if (*(_DWORD *)(v8 + 148) == 1)
              {
                int v30 = get_padded_bytes(v28 + 4 * v29 + (*(_DWORD *)(v8 + 152) << 6), 8u);
                int v31 = get_padded_bytes(v30 + 4 * (*(_DWORD *)(v8 + 152) + ((3 * *(_DWORD *)(v8 + 140) + 15) >> 4)), 8u);
                int v28 = get_padded_bytes(v31 + (*(_DWORD *)(v8 + 156) << 6), 8u);
                unsigned int v32 = *(_DWORD *)(v8 + 156) + ((3 * *(_DWORD *)(v8 + 140) + 15) >> 4);
              }
              else
              {
                int v33 = *(_DWORD *)(v8 + 140);
                unsigned int v32 = 3 * v33 * get_padded_len((*(_DWORD *)(v8 + 124) + *(_DWORD *)(v8 + 96)), 8u) + v29;
              }
              int v34 = get_padded_bytes(v28 + 4 * v32, 8u);
              int v35 = get_padded_len((3 * *(_DWORD *)(v8 + 140)), 8u);
              int v36 = get_padded_len(*(unsigned int *)(v8 + 140), 8u);
              unsigned int v37 = 3 * *(_DWORD *)(v8 + 140);
              int v38 = get_padded_len(v37, 8u);
              uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 224) + 152))();
              if (!result)
              {
                int v39 = get_padded_bytes(v34 + 4 * (v35 + v37 * v36 + v38), 8u);
                int v40 = get_padded_len(*(unsigned int *)(v8 + 164), 8u);
                int v41 = *(_DWORD *)(v8 + 168);
                int v42 = get_padded_len(1024, 8u);
                uint64_t result = 0;
                *a2 = v39 + 4 * (v42 + v41 * v40);
                *a3 = 0;
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"ERROR: param is NULL in wanted_wb_len(lpcnet)!", a6, a7, a8, v43);
    return 7;
  }
  return result;
}

uint64_t lpcnet_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 120);
  int v18 = 0;
  if (v9)
  {
    uint64_t v10 = v9 + 184;
    lpcnet_get_reserved_glbBuf_bytes(a1, &v18);
    uint64_t v11 = 0;
    unsigned int v12 = 0;
    do
    {
      int v13 = *(uint64_t (**)(void))(*(void *)(v10 + v11) + 160);
      if (v13)
      {
        uint64_t result = v13();
        if (result) {
          return result;
        }
        if (*(_DWORD *)(*(void *)(v10 + v11) + 248) > v12) {
          unsigned int v12 = *(_DWORD *)(*(void *)(v10 + v11) + 248);
        }
      }
      v11 += 8;
    }
    while (v11 != 48);
    int v15 = v18;
    padded_uint64_t bytes = get_padded_bytes(v12, 8u);
    uint64_t result = 0;
    *(_DWORD *)(a1 + 248) = padded_bytes + v15;
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v17);
    return 7;
  }
  return result;
}

uint64_t lpcnet_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 120);
  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 72);
    int v10 = get_padded_len(*(unsigned int *)(v8 + 56), 8u) * *(_DWORD *)(v8 + 52);
    int v11 = 4 * get_padded_len(*(unsigned int *)(v8 + 104), 8u) * *(_DWORD *)(v8 + 112) + 4 * v10;
    int v12 = v11 + 4 * get_padded_len(*(unsigned int *)(v8 + 104), 8u) * *(_DWORD *)(v8 + 116);
    padded_uint64_t bytes = v12 + 4 * get_padded_len(*(unsigned int *)(v8 + 104), 8u) * *(_DWORD *)(v8 + 120);
    uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 184), v9, &padded_bytes);
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
      uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 192), v9, &padded_bytes);
      if (!result)
      {
        padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
        uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 200), v9, &padded_bytes);
        if (!result)
        {
          padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
          uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 208), v9, &padded_bytes);
          if (!result)
          {
            padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
            uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 216), v9, &padded_bytes);
            if (!result)
            {
              padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
              int v14 = *(_DWORD *)(v8 + 128);
              padded_bytes += 4
                            * (v14 + (get_padded_len((3 * *(_DWORD *)(v8 + 124)), 8u) >> 4));
              padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u) + 12 * *(_DWORD *)(v8 + 124);
              padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u) + (*(_DWORD *)(v8 + 128) << 6);
              padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
              padded_bytes += 4 * get_padded_len((3 * *(_DWORD *)(v8 + 124)), 8u);
              unsigned int v15 = get_padded_bytes(padded_bytes, 8u);
              padded_uint64_t bytes = v15;
              if (*(_DWORD *)(v8 + 148) == 1)
              {
                padded_uint64_t bytes = v15 + (*(_DWORD *)(v8 + 152) << 6);
                padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u)
                             + 4 * (*(_DWORD *)(v8 + 152) + ((3 * *(_DWORD *)(v8 + 140) + 15) >> 4));
                padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u) + (*(_DWORD *)(v8 + 156) << 6);
                unsigned int v16 = get_padded_bytes(padded_bytes, 8u)
                    + 4 * (*(_DWORD *)(v8 + 156) + ((3 * *(_DWORD *)(v8 + 140) + 15) >> 4));
              }
              else
              {
                int v17 = *(_DWORD *)(v8 + 140);
                unsigned int v16 = padded_bytes
                    + 12 * v17 * get_padded_len((*(_DWORD *)(v8 + 124) + *(_DWORD *)(v8 + 96)), 8u);
              }
              padded_uint64_t bytes = v16;
              padded_uint64_t bytes = get_padded_bytes(v16, 8u);
              padded_bytes += 4 * get_padded_len((3 * *(_DWORD *)(v8 + 140)), 8u);
              padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
              padded_bytes += 12 * get_padded_len(*(unsigned int *)(v8 + 140), 8u) * *(_DWORD *)(v8 + 140);
              padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
              padded_bytes += 4 * get_padded_len((3 * *(_DWORD *)(v8 + 140)), 8u);
              padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
              uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 224), v9, &padded_bytes);
              if (!result)
              {
                padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
                padded_bytes += 4 * get_padded_len(*(unsigned int *)(v8 + 164), 8u) * *(_DWORD *)(v8 + 168);
                get_padded_len(1024, 8u);
                return 0;
              }
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v18);
    return 7;
  }
  return result;
}

uint64_t lpcnet_assign_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120) + 184;
  unsigned int v12 = 0;
  lpcnet_get_reserved_glbBuf_bytes(a1, &v12);
  uint64_t v6 = 0;
  uint64_t v7 = v12;
  while (1)
  {
    uint64_t v8 = *(void *)(v2 + v6);
    if (!v8) {
      break;
    }
    *(void *)(v8 + 240) = *(void *)(a1 + 240) + v7;
    uint64_t v9 = *(uint64_t (**)(void))(v8 + 168);
    if (v9)
    {
      uint64_t result = v9();
      if (result) {
        return result;
      }
    }
    v6 += 8;
    if (v6 == 48) {
      return 0;
    }
  }
  log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v3, v4, v5, v11);
  return 10;
}

float lpcnet_update_param(uint64_t a1, int *a2, int a3, int a4)
{
  if (*(_DWORD *)(a1 + 8) == a4 && a3 == 48)
  {
    uint64_t v4 = *(void *)(a1 + 120);
    float v5 = *(float *)a2;
    int v6 = a2[1];
    *(_DWORD *)(v4 + 232) = *a2;
    *(_DWORD *)(v4 + 244) = v6;
    if (LODWORD(v5) == 1 && v6 == 0)
    {
      *(_OWORD *)(v4 + 248) = *(_OWORD *)(a2 + 2);
      *(_OWORD *)(v4 + 264) = *(_OWORD *)(a2 + 6);
      *(_DWORD *)(v4 + 280) = a2[10];
      float result = *((float *)a2 + 11);
      *(float *)(v4 + 284) = result;
    }
  }
  return result;
}

uint64_t lpcnet_get_reserved_glbBuf_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = *(_DWORD **)(a1 + 120);
  int v3 = v2[8];
  int v18 = v2[4];
  int step = fi_shape_get_step((_DWORD *)(a1 + 20));
  int padded_len = get_padded_len(v2[31], 8u);
  int v16 = get_padded_len(v2[35], 8u);
  int v5 = get_padded_len((3 * v2[40]), 8u);
  int v6 = get_padded_len((3 * v2[40]), 8u);
  int v7 = get_padded_len(v2[41], 8u);
  int v8 = get_padded_len((3 * v2[35]), 8u);
  int v9 = get_padded_len((2 * v2[41]), 8u);
  int v10 = get_padded_len(v2[10], 8u);
  int v11 = get_padded_len((v2[10] * step), 8u);
  int v12 = get_padded_len((v2[24] * step), 8u);
  unsigned int v13 = v2[26];
  if (v13 <= v2[17] + v2[15] + v2[20] + v2[22]) {
    unsigned int v13 = v2[17] + v2[15] + v2[20] + v2[22];
  }
  if (v13 <= 0x14A) {
    unsigned int v13 = 330;
  }
  int v14 = v16 + padded_len + v5 + v6 + v7 + v8 + v9 + v10 + v11 + v12 + get_padded_len(v13 * step, 8u);
  uint64_t result = get_padded_bytes(8 * v3 + 4 * (v18 + v3 * v3) + 8, 8u);
  *a2 = result + 4 * v14;
  return result;
}

uint64_t create_wavernn_layer(uint64_t *a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v13)
  {
    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 128);
    uint64_t v18 = v14;
    if (!v14)
    {
      uint64_t v27 = *a1;
      int v28 = "out of memory!";
LABEL_11:
      log_OutText(v27, (uint64_t)"FastInfer", 0, 0, (uint64_t)v28, v15, v16, v17, v46);
      *(void *)(v13 + 120) = v18;
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"wavernn init param failed!", v29, v30, v31, v47);
      uint64_t result = 7;
      goto LABEL_12;
    }
    long long v19 = *a2;
    long long v20 = a2[1];
    long long v21 = a2[3];
    *(_OWORD *)(v14 + 32) = a2[2];
    *(_OWORD *)(v14 + 48) = v21;
    *(_OWORD *)uint64_t v14 = v19;
    *(_OWORD *)(v14 + 16) = v20;
    int v22 = *((_DWORD *)a2 + 4);
    LODWORD(v54) = 5;
    HIDWORD(v54) = v22;
    if ((*((_DWORD *)a2 + 7) - 1) >= 2)
    {
      uint64_t v24 = *a1;
      unsigned int v25 = "wavernn only support n_samples=1, 2, but got: %d!";
      uint64_t v46 = *((unsigned int *)a2 + 7);
      goto LABEL_10;
    }
    int v55 = *((_DWORD *)a2 + 7);
    uint64_t v53 = 0x100000003;
    uint64_t v49 = 0;
    if (create_fc_layer(a1, &v54, &v53, 0, a3, (uint64_t *)(v14 + 64))
      || (int v23 = *((_DWORD *)a2 + 3),
          LODWORD(v54) = 5,
          HIDWORD(v54) = v23,
          int v55 = 0,
          LODWORD(v53) = 3,
          create_fc_layer(a1, &v54, &v53, 0, a3, (uint64_t *)(v18 + 72))))
    {
      uint64_t v24 = *a1;
      unsigned int v25 = "create wavernn pre input dense layer failed!";
LABEL_10:
      log_OutText(v24, (uint64_t)"FastInfer", 0, 0, (uint64_t)v25, v15, v16, v17, v46);
      uint64_t v27 = *a1;
      int v28 = "wavernn network init failed!";
      goto LABEL_11;
    }
    int v32 = *((_DWORD *)a2 + 2);
    LODWORD(v54) = 23;
    HIDWORD(v54) = v32;
    int v55 = *((_DWORD *)a2 + 14);
    fi_get_activation("tanh");
    fi_get_activation("hardsigmoid");
    int v50 = *((_DWORD *)a2 + 15);
    uint64_t v51 = *((void *)a2 + 5);
    uint64_t v52 = 0x100000001;
    if (create_gru_layer(a1, (uint64_t)&v54, (long long *)&v50, 0, a3, (uint64_t ***)(v18 + 80)))
    {
      uint64_t v24 = *a1;
      unsigned int v25 = "create wavernn GRU layer failed!";
      goto LABEL_10;
    }
    int v33 = *((_DWORD *)a2 + 5);
    LODWORD(v54) = 5;
    HIDWORD(v54) = v33;
    int v55 = 0;
    LODWORD(v53) = 3;
    if (create_fc_layer(a1, &v54, &v53, 0, a3, (uint64_t *)(v18 + 88)))
    {
      uint64_t v24 = *a1;
      unsigned int v25 = "create wavernn post dense layer 0 failed!";
      goto LABEL_10;
    }
    int v34 = *((_DWORD *)a2 + 7) * *((_DWORD *)a2 + 6);
    LODWORD(v54) = 5;
    HIDWORD(v54) = v34;
    int v55 = *((_DWORD *)a2 + 14);
    LODWORD(v53) = 0;
    if (create_fc_layer(a1, &v54, &v53, 0, a3, (uint64_t *)(v18 + 96)))
    {
      uint64_t v24 = *a1;
      unsigned int v25 = "create wavernn post dense layer 1 failed!";
      goto LABEL_10;
    }
    int v35 = *((_DWORD *)a2 + 13);
    LODWORD(v49) = 0;
    HIDWORD(v49) = v35;
    if (create_sampling_layer(a1, &v49, a4, (uint64_t *)(v18 + 104)))
    {
      uint64_t v24 = *a1;
      unsigned int v25 = "create wavernn sampling layer failed!";
      goto LABEL_10;
    }
    int v48 = *((_DWORD *)a2 + 9);
    if (create_mulaw_layer(a1, &v48, (uint64_t *)(v18 + 112)))
    {
      uint64_t v24 = *a1;
      unsigned int v25 = "create wavernn mulaw layer failed!";
      goto LABEL_10;
    }
    uint64_t v36 = (*(uint64_t (**)(uint64_t, void, uint64_t))(a1[1] + 16))(a1[2], *((unsigned int *)a2 + 7), 4);
    *(void *)(v18 + 120) = v36;
    if (!v36)
    {
      uint64_t v24 = *a1;
      unsigned int v25 = "out of memory!";
      goto LABEL_10;
    }
    uint64_t v37 = *((unsigned int *)a2 + 7);
    if (v37)
    {
      unsigned int v38 = *((_DWORD *)a2 + 8);
      int v39 = *((_DWORD *)a2 + 6);
      uint64_t v40 = (v37 + 1) & 0x1FFFFFFFELL;
      uint64x2_t v41 = (uint64x2_t)vdupq_n_s64(v37 - 1);
      int v42 = (float *)(v36 + 4);
      int64x2_t v43 = (int64x2_t)xmmword_20D6072C0;
      int64x2_t v44 = vdupq_n_s64(2uLL);
      do
      {
        int32x2_t v45 = vmovn_s64((int64x2_t)vcgeq_u64(v41, (uint64x2_t)v43));
        if (v45.i8[0]) {
          *(v42 - 1) = (float)v38;
        }
        if (v45.i8[4]) {
          *int v42 = (float)(v39 + v38);
        }
        int64x2_t v43 = vaddq_s64(v43, v44);
        v42 += 2;
        v38 += 2 * v39;
        v40 -= 2;
      }
      while (v40);
    }
    uint64_t result = 0;
    *(void *)uint64_t v13 = a1;
    *(void *)(v13 + 8) = 27;
    *(void *)(v13 + 120) = v18;
    *(void *)(v13 + 128) = forward_wavernn_layer;
    *(void *)(v13 + 136) = free_wavernn_layer;
    *(void *)(v13 + 144) = wavernn_layer_update_shape;
    *(void *)(v13 + 152) = wavernn_layer_wanted_wb_len;
    *(void *)(v13 + 160) = wavernn_request_glbBuf;
    *(void *)(v13 + 256) = *(void *)(a3 + 24);
    *(_DWORD *)(v13 + 264) = *(_DWORD *)(a3 + 16);
    *(void *)(v13 + 176) = wavernn_layer_reset;
    *(void *)(v13 + 224) = wavernn_update_param;
    *(void *)(v13 + 184) = wavernn_dispatch_weights;
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v10, v11, v12, v46);
    uint64_t result = 10;
  }
LABEL_12:
  *a5 = v13;
  return result;
}

uint64_t forward_wavernn_layer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v53 = 0;
  if (!a2) {
    return 0;
  }
  int v3 = (int *)a2;
  uint64_t v46 = *(uint64_t **)a2;
  uint64_t v4 = *(void *)(a2 + 120);
  int v6 = *(_DWORD *)(v4 + 24);
  uint64_t v5 = *(unsigned int *)(v4 + 28);
  char __dst = *(char **)(a2 + 240);
  uint64_t v52 = &__dst[4 * get_padded_len(v5, 8u)];
  int v7 = &v52[4 * get_padded_len(*(unsigned int *)(v4 + 16), 8u)];
  int v8 = &v7[4 * get_padded_len(*(unsigned int *)(v4 + 12), 8u)];
  int v9 = &v8[4 * get_padded_len(*(unsigned int *)(v4 + 8), 8u)];
  uint64_t v10 = &v9[4 * get_padded_len(*(unsigned int *)(v4 + 20), 8u)];
  *(void *)(*(void *)(v4 + 80) + 240) = &v10[4
                                                 * get_padded_len((*(_DWORD *)(v4 + 28)* *(_DWORD *)(v4 + 24)), 8u)];
  v3 += 5;
  int step = fi_shape_get_step(v3);
  uint64_t input_dim = fi_shape_get_input_dim(v3, (int *)&v53);
  if (!input_dim)
  {
    int v48 = v8;
    int64x2_t v44 = v7;
    size_t v13 = 4 * v5;
    memcpy(__dst, *(const void **)(v4 + 120), 4 * v5);
    unsigned int v50 = *(_DWORD *)(v4 + 4);
    unsigned int v49 = v50 * step;
    if (!(v50 * step))
    {
      uint64_t input_dim = 0;
      uint64_t v17 = __dst;
LABEL_26:
      if (*(_DWORD *)(v4 + 48))
      {
        memcpy(*(void **)(v4 + 120), v17, v13);
      }
      else if (v5)
      {
        unsigned int v33 = *(_DWORD *)(v4 + 32);
        uint64_t v34 = (v5 + 1) & 0x1FFFFFFFELL;
        uint64x2_t v35 = (uint64x2_t)vdupq_n_s64(v5 - 1);
        uint64_t v36 = (float *)(*(void *)(v4 + 120) + 4);
        int64x2_t v37 = (int64x2_t)xmmword_20D6072C0;
        int64x2_t v38 = vdupq_n_s64(2uLL);
        do
        {
          int32x2_t v39 = vmovn_s64((int64x2_t)vcgeq_u64(v35, (uint64x2_t)v37));
          if (v39.i8[0]) {
            *(v36 - 1) = (float)v33;
          }
          if (v39.i8[4]) {
            *uint64_t v36 = (float)(v6 + v33);
          }
          int64x2_t v37 = vaddq_s64(v37, v38);
          v36 += 2;
          v33 += 2 * v6;
          v34 -= 2;
        }
        while (v34);
      }
      return input_dim;
    }
    int v45 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = v44;
    uint64_t v16 = v9;
    uint64_t v17 = __dst;
    while (1)
    {
      if (v14 % v50)
      {
        uint64_t v18 = v52;
      }
      else
      {
        bzero(v15, 4 * *(unsigned int *)(v4 + 12));
        uint64_t v19 = (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 128))(0);
        if (v19)
        {
          uint64_t input_dim = v19;
          uint64_t v40 = *v46;
          uint64x2_t v41 = "wavernn forward local-condition dense failed!";
LABEL_42:
          log_OutText(v40, (uint64_t)"FastInfer", 0, 0, (uint64_t)v41, v20, v21, v22, v43);
          return input_dim;
        }
        a3 += 4 * v53;
        HIDWORD(v23) = -1030792151 * (v45 + 1);
        LODWORD(v23) = HIDWORD(v23);
        uint64_t v18 = v52;
        ++v45;
        if ((v23 >> 2) <= 0x28F5C28) {
          log_OutText(*v46, (uint64_t)"FastInfer", 4, 0, (uint64_t)"step: %d/%d, frame: %d/%d", v20, v21, v22, v14);
        }
        uint64_t v15 = v44;
      }
      bzero(v18, 4 * *(unsigned int *)(v4 + 16));
      uint64_t v24 = (*(uint64_t (**)(void))(*(void *)(v4 + 64) + 128))(0);
      if (v24)
      {
        uint64_t input_dim = v24;
        uint64_t v40 = *v46;
        uint64x2_t v41 = "wavernn forward input dense failed!";
        goto LABEL_42;
      }
      bzero(v48, 4 * *(unsigned int *)(v4 + 8));
      uint64_t v25 = (*(uint64_t (**)(void))(*(void *)(v4 + 80) + 128))(0);
      if (v25)
      {
        uint64_t input_dim = v25;
        uint64_t v40 = *v46;
        uint64x2_t v41 = "wavernn forward rnn layer failed!";
        goto LABEL_42;
      }
      bzero(v16, 4 * *(unsigned int *)(v4 + 20));
      uint64_t v26 = (*(uint64_t (**)(void))(*(void *)(v4 + 88) + 128))(0);
      if (v26)
      {
        uint64_t input_dim = v26;
        uint64_t v40 = *v46;
        uint64x2_t v41 = "wavernn forward first output dense failed!";
        goto LABEL_42;
      }
      bzero(v10, 4 * (*(_DWORD *)(v4 + 28) * *(_DWORD *)(v4 + 24)));
      uint64_t v27 = (*(uint64_t (**)(void))(*(void *)(v4 + 96) + 128))(0);
      if (v27)
      {
        uint64_t input_dim = v27;
        uint64_t v40 = *v46;
        uint64x2_t v41 = "wavernn forward second dense failed!";
        goto LABEL_42;
      }
      if (v5)
      {
        int v28 = 0;
        do
          fi_activate_array((float *)&v10[4 * *(_DWORD *)(v4 + 24) * v28++], *(unsigned int *)(v4 + 24), 9);
        while (v5 != v28);
      }
      bzero(__dst, 4 * *(unsigned int *)(v4 + 28));
      uint64_t v29 = (*(uint64_t (**)(void))(*(void *)(v4 + 104) + 128))(0);
      if (v29)
      {
        uint64_t input_dim = v29;
        uint64_t v40 = *v46;
        uint64x2_t v41 = "wavernn forward sampling failed!";
        goto LABEL_42;
      }
      uint64_t input_dim = (*(uint64_t (**)(void))(*(void *)(v4 + 112) + 128))(0);
      if (v5)
      {
        int v30 = 0;
        uint64_t v31 = v5;
        int v32 = (float *)__dst;
        do
        {
          *int v32 = (float)(v30 + *v32);
          ++v32;
          v30 += v6;
          --v31;
        }
        while (v31);
      }
      uint64_t v14 = (v14 + v5);
      if (v14 >= v49)
      {
        size_t v13 = 4 * v5;
        goto LABEL_26;
      }
    }
  }
  return input_dim;
}

void *free_wavernn_layer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      int v3 = (uint64_t *)result[15];
      if (v3)
      {
        fi_layer_free(v3[8]);
        fi_layer_free(v3[9]);
        fi_layer_free(v3[10]);
        fi_layer_free(v3[11]);
        fi_layer_free(v3[12]);
        fi_layer_free(v3[13]);
        fi_layer_free(v3[14]);
        if (v3[15])
        {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
          v3[15] = 0;
        }
        (*(void (**)(void, uint64_t *))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v4 = *(void *)(v2 + 16);
      uint64_t v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v5(v4, v1);
    }
  }
  return result;
}

uint64_t wavernn_layer_update_shape(uint64_t a1, long long *a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a1 + 120);
  v10[0] = 0;
  v10[1] = 0;
  int v11 = 0;
  unsigned int v9 = 0;
  int v5 = *(_DWORD *)(v4 + 28) * *(_DWORD *)(v4 + 24);
  unsigned int v14 = 1;
  unsigned int v15 = v5;
  int v16 = 0;
  int v6 = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = *a2;
  *(_DWORD *)(a1 + 36) = v6;
  uint64_t result = fi_shape_set(2, (uint64_t)&v14, 4, (uint64_t)v10);
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(v4 + 64) + 144))();
    if (!result)
    {
      long long v12 = *a2;
      int v13 = *((_DWORD *)a2 + 4);
      DWORD1(v12) = 1;
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 144))();
      if (!result)
      {
        int v8 = *(_DWORD *)(v4 + 12) + *(_DWORD *)(v4 + 16);
        unsigned int v14 = 1;
        unsigned int v15 = v8;
        fi_shape_set(2, (uint64_t)&v14, 4, (uint64_t)v10);
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(v4 + 80) + 144))();
        if (!result)
        {
          uint64_t result = (*(uint64_t (**)(void))(*(void *)(v4 + 88) + 144))();
          if (!result)
          {
            uint64_t result = (*(uint64_t (**)(void))(*(void *)(v4 + 96) + 144))();
            if (!result)
            {
              uint64_t result = fi_shape_get_size((int *)(*(void *)(v4 + 96) + 40), (int *)&v9);
              if (!result)
              {
                unsigned int v14 = *(_DWORD *)(v4 + 28);
                unsigned int v15 = v9 / v14;
                fi_shape_set(2, (uint64_t)&v14, 4, (uint64_t)v10);
                uint64_t result = (*(uint64_t (**)(void))(*(void *)(v4 + 104) + 144))();
                if (!result)
                {
                  (*(void (**)(void))(*(void *)(v4 + 112) + 144))();
                  unsigned int v14 = *(_DWORD *)(v4 + 4) * *(_DWORD *)(a1 + 24);
                  unsigned int v15 = 1;
                  return fi_shape_set(2, (uint64_t)&v14, 4, a1 + 40);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t wavernn_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v13 = 0;
  int v5 = *(void **)(a1 + 120);
  uint64_t result = (*(uint64_t (**)(void))(v5[8] + 152))();
  if (!result)
  {
    padded_uint64_t bytes = get_padded_bytes((int)v13 + HIDWORD(v13), 8u);
    uint64_t result = (*(uint64_t (**)(void))(v5[9] + 152))();
    if (!result)
    {
      int v8 = get_padded_bytes(HIDWORD(v13) + (int)v13 + padded_bytes, 8u);
      uint64_t result = (*(uint64_t (**)(void))(v5[10] + 152))();
      if (!result)
      {
        int v9 = get_padded_bytes(HIDWORD(v13) + (int)v13 + v8, 8u);
        uint64_t result = (*(uint64_t (**)(void))(v5[11] + 152))();
        if (!result)
        {
          int v10 = get_padded_bytes(HIDWORD(v13) + (int)v13 + v9, 8u);
          uint64_t result = (*(uint64_t (**)(void))(v5[12] + 152))();
          if (!result)
          {
            int v11 = get_padded_bytes(HIDWORD(v13) + (int)v13 + v10, 8u);
            uint64_t result = (*(uint64_t (**)(void))(v5[14] + 152))();
            if (!result)
            {
              int v12 = get_padded_bytes(HIDWORD(v13) + (int)v13 + v11, 8u);
              uint64_t result = 0;
              *a2 = v12;
              *a3 = 0;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t wavernn_request_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120);
  uint64_t v3 = *(void *)(v2 + 80);
  int padded_len = get_padded_len(*(unsigned int *)(v2 + 28), 8u);
  int v5 = get_padded_len(*(unsigned int *)(v2 + 16), 8u) + padded_len;
  int v6 = get_padded_len(*(unsigned int *)(v2 + 12), 8u);
  int v7 = v5 + v6 + get_padded_len(*(unsigned int *)(v2 + 8), 8u);
  int v8 = v7 + get_padded_len(*(unsigned int *)(v2 + 20), 8u);
  *(_DWORD *)(a1 + 248) = 4 * (v8 + get_padded_len((*(_DWORD *)(v2 + 28) * *(_DWORD *)(v2 + 24)), 8u));
  int v9 = *(uint64_t (**)(uint64_t))(v3 + 160);
  if (!v9 || (uint64_t result = v9(v3), !result))
  {
    padded_uint64_t bytes = get_padded_bytes(*(_DWORD *)(v3 + 248), 8u);
    uint64_t result = 0;
    *(_DWORD *)(a1 + 248) += padded_bytes;
  }
  return result;
}

uint64_t wavernn_layer_reset(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 120);
  uint64_t v2 = *(void *)(v1 + 80);
  if (!v2 || (uint64_t v3 = *(uint64_t (**)(void))(v2 + 176)) == 0 || (result = v3(), !result))
  {
    uint64_t v5 = *(unsigned int *)(v1 + 28);
    if (v5)
    {
      unsigned int v6 = *(_DWORD *)(v1 + 32);
      int v7 = *(_DWORD *)(v1 + 24);
      uint64_t v8 = (v5 + 1) & 0x1FFFFFFFELL;
      uint64x2_t v9 = (uint64x2_t)vdupq_n_s64(v5 - 1);
      int v10 = (float *)(*(void *)(v1 + 120) + 4);
      int64x2_t v11 = (int64x2_t)xmmword_20D6072C0;
      int64x2_t v12 = vdupq_n_s64(2uLL);
      do
      {
        int32x2_t v13 = vmovn_s64((int64x2_t)vcgeq_u64(v9, (uint64x2_t)v11));
        if (v13.i8[0]) {
          *(v10 - 1) = (float)v6;
        }
        if (v13.i8[4]) {
          *int v10 = (float)(v7 + v6);
        }
        int64x2_t v11 = vaddq_s64(v11, v12);
        v10 += 2;
        v6 += 2 * v7;
        v8 -= 2;
      }
      while (v8);
    }
    return 0;
  }
  return result;
}

uint64_t wavernn_update_param(uint64_t a1, _DWORD *a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 8) != a4) {
    return 0;
  }
  if (a3 == 4)
  {
    uint64_t result = 0;
    *(_DWORD *)(*(void *)(a1 + 120) + 4) = *a2;
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"wavernn update param incorrect nbytes (need 4bytes)", a6, a7, a8, vars0);
    return 7;
  }
  return result;
}

uint64_t wavernn_dispatch_weights(uint64_t a1)
{
  padded_uint64_t bytes = 0;
  uint64_t v1 = *(uint64_t **)a1;
  uint64_t v2 = *(uint64_t **)(a1 + 120);
  uint64_t v3 = *(void *)(a1 + 72);
  int v4 = *(_DWORD *)(a1 + 80);
  uint64_t result = fi_layer_find_weights_via_offset(v2[8], v3, &padded_bytes);
  if (!result)
  {
    padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
    uint64_t result = fi_layer_find_weights_via_offset(v2[9], v3, &padded_bytes);
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
      uint64_t result = fi_layer_find_weights_via_offset(v2[10], v3, &padded_bytes);
      if (!result)
      {
        padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
        uint64_t result = fi_layer_find_weights_via_offset(v2[11], v3, &padded_bytes);
        if (!result)
        {
          padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
          uint64_t result = fi_layer_find_weights_via_offset(v2[12], v3, &padded_bytes);
          if (!result)
          {
            padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
            uint64_t result = fi_layer_find_weights_via_offset(v2[14], v3, &padded_bytes);
            if (!result)
            {
              uint64_t v6 = get_padded_bytes(padded_bytes, 8u);
              padded_uint64_t bytes = v6;
              if (v6 == v4)
              {
                return 0;
              }
              else
              {
                log_OutText(*v1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"wavernn weights lentgh error, wanted: %d bytes, but weights file: %d bytes", v7, v8, v9, v6);
                return 7;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t create_conv1d_proj_layer(uint64_t *a1, unsigned int *a2, uint64_t **a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7 = 0;
  uint64_t result = 7;
  if (!a1 || !a2) {
    goto LABEL_19;
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (!v7)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v30);
    uint64_t result = 10;
    goto LABEL_19;
  }
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 32);
  uint64_t v19 = v15;
  if (!v15)
  {
    uint64_t v24 = *a1;
    uint64_t v25 = "out of memory!";
LABEL_18:
    log_OutText(v24, (uint64_t)"FastInfer", 0, 0, (uint64_t)v25, v16, v17, v18, v30);
    *(void *)(v7 + 120) = v19;
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"conv1d_proj init param failed!", v27, v28, v29, v30);
    uint64_t result = 7;
    goto LABEL_19;
  }
  *(_OWORD *)uint64_t v15 = *(_OWORD *)a2;
  if (!*(_DWORD *)(v15 + 4))
  {
    uint64_t v24 = *a1;
    uint64_t v25 = "# projection feature1 must be greater than zero!";
    goto LABEL_18;
  }
  if (!*(_DWORD *)(v15 + 8))
  {
    uint64_t v24 = *a1;
    uint64_t v25 = "# projection feature2 must be greater than zero!";
    goto LABEL_18;
  }
  int v32 = 0;
  long long v30 = 0u;
  long long v31 = 0u;
  if (config_conv1d_norm_layer(a2[1], *a2, 1, 1, 0, 1, a2[3], &v30))
  {
    unint64_t v23 = "create conv1d_proj sub-conv1d_norm1 cfg failed!";
LABEL_17:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v23, v20, v21, v22, v30);
    uint64_t v24 = *a1;
    uint64_t v25 = "conv1d_proj network init failed!";
    goto LABEL_18;
  }
  if (create_conv1d_norm_layer(a1, (uint64_t)&v30, a3, a4, (uint64_t *)(v19 + 16)))
  {
    unint64_t v23 = "create conv1d_proj sub-conv1d_norm1 layer failed!";
    goto LABEL_17;
  }
  unsigned int v26 = a2[2];
  int v32 = 0;
  LODWORD(v31) = v26;
  if (create_conv1d_norm_layer(a1, (uint64_t)&v30, a3, a4, (uint64_t *)(v19 + 24)))
  {
    unint64_t v23 = "create conv1d_proj sub-conv1d_norm2 layer failed!";
    goto LABEL_17;
  }
  *(void *)(v7 + 120) = v19;
  if (a3) {
    *(void *)(v7 + 60) = *a3;
  }
  *(void *)uint64_t v7 = a1;
  *(void *)(v7 + 8) = 52;
  *(void *)(v7 + 128) = forward_conv1d_proj_layer;
  *(void *)(v7 + 136) = free_conv1d_proj_layer;
  *(void *)(v7 + 144) = conv1d_proj_update_shape;
  *(void *)(v7 + 152) = conv1d_proj_wanted_wb_len;
  *(void *)(v7 + 160) = conv1d_proj_request_glbBuf;
  *(void *)(v7 + 184) = conv1d_proj_dispatch_weights;
  *(void *)(v7 + 168) = conv1d_proj_assign_glbBuf;
  if (a4)
  {
    uint64_t result = 0;
    *(void *)(v7 + 256) = *(void *)(a4 + 24);
    *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
  }
  else
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, using default (0)", v20, v21, v22, v30);
    uint64_t result = 0;
    *(void *)(v7 + 256) = 0;
    *(_DWORD *)(v7 + 264) = 0;
  }
LABEL_19:
  *a5 = v7;
  return result;
}

uint64_t forward_conv1d_proj_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  LODWORD(v22) = 0;
  if (!a2) {
    return 0;
  }
  uint64_t v8 = *(uint64_t **)a2;
  uint64_t v9 = *(void *)(a2 + 120);
  if (!v9)
  {
    log_OutText(*v8, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v21);
    return 7;
  }
  uint64_t v12 = *(void **)(a2 + 240);
  uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v9 + 16) + 40), &v22);
  if (!bytes)
  {
    bzero(v12, v22);
    uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)(v9 + 16) + 128))(a1);
    if (v14)
    {
      uint64_t bytes = v14;
      uint64_t v18 = *v8;
      uint64_t v19 = "conv1d_proj forward sub-conv1d_proj layer 1 failed!";
LABEL_6:
      log_OutText(v18, (uint64_t)"FastInfer", 0, 0, (uint64_t)v19, v15, v16, v17, v21);
      return bytes;
    }
    uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v9 + 24) + 40), &v22);
    if (!bytes)
    {
      bzero(a4, v22);
      uint64_t bytes = (*(uint64_t (**)(uint64_t))(*(void *)(v9 + 24) + 128))(a1);
      if (bytes)
      {
        uint64_t v18 = *v8;
        uint64_t v19 = "conv1d_proj forward sub-conv1d_proj layer 2 failed!";
        goto LABEL_6;
      }
    }
  }
  return bytes;
}

void *free_conv1d_proj_layer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = result[15];
      if (v3)
      {
        fi_layer_free(*(void *)(v3 + 16));
        fi_layer_free(*(void *)(v3 + 24));
        (*(void (**)(void, uint64_t))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v4 = *(void *)(v2 + 16);
      uint64_t v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v5(v4, v1);
    }
  }
  return result;
}

__n128 conv1d_proj_update_shape(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 120);
  uint64_t v9 = *(uint64_t **)a1;
  if (!v8)
  {
    uint64_t v12 = *v9;
    uint64_t v13 = "NULL param!";
    goto LABEL_5;
  }
  long long v11 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v11;
  if (*(_DWORD *)a2 >= 3u)
  {
    uint64_t v12 = *v9;
    uint64_t v13 = "Currently conv1d_proj layer only support 1D or 2D input";
LABEL_5:
    log_OutText(v12, (uint64_t)"FastInfer", 0, 0, (uint64_t)v13, a6, a7, a8, v18);
    return result;
  }
  if (!(*(unsigned int (**)(void))(*(void *)(v8 + 16) + 144))()
    && !(*(unsigned int (**)(void))(*(void *)(v8 + 24) + 144))())
  {
    uint64_t v15 = *(void *)(v8 + 24);
    unsigned int v17 = *(_DWORD *)(v15 + 40);
    uint64_t v16 = (__n128 *)(v15 + 40);
    if (v17 >= 3)
    {
      uint64_t v12 = *v9;
      uint64_t v13 = "final output shape error: Currently conv1d_proj only support 1D or 2D output";
      goto LABEL_5;
    }
    __n128 result = *v16;
    *(_DWORD *)(a1 + 56) = v16[1].n128_u32[0];
    *(__n128 *)(a1 + 40) = result;
  }
  return result;
}

uint64_t conv1d_proj_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 120);
  if (v9)
  {
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 16) + 152))();
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(0, 8u);
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 24) + 152))();
      if (!result)
      {
        *a2 = get_padded_bytes(padded_bytes, 8u);
        *a3 = 0;
        log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"out_feats1: %d\n", v14, v15, v16, *(unsigned int *)(v9 + 4));
        log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"out_feats2: %d\n", v17, v18, v19, *(unsigned int *)(v9 + 8));
        log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v20, v21, v22, *(unsigned int *)(a1 + 96));
        log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v23, v24, v25, *a2);
        return 0;
      }
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v26);
    return 7;
  }
  return result;
}

uint64_t conv1d_proj_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 120);
  if (!v9)
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v15);
    return 7;
  }
  int v10 = *(uint64_t (**)(void))(*(void *)(v9 + 16) + 160);
  if (v10)
  {
    uint64_t result = v10();
    if (result) {
      return result;
    }
    unsigned int v12 = *(_DWORD *)(*(void *)(v9 + 16) + 248);
  }
  else
  {
    unsigned int v12 = 0;
  }
  uint64_t v13 = *(uint64_t (**)(void))(*(void *)(v9 + 24) + 160);
  if (v13)
  {
    uint64_t result = v13();
    if (result) {
      return result;
    }
    if (*(_DWORD *)(*(void *)(v9 + 24) + 248) > v12) {
      unsigned int v12 = *(_DWORD *)(*(void *)(v9 + 24) + 248);
    }
  }
  uint64_t v14 = *(void *)(a1 + 120);
  int v16 = 0;
  uint64_t result = fi_shape_get_bytes((int *)(*(void *)(v14 + 16) + 40), &v16);
  if (!result) {
    *(_DWORD *)(a1 + 248) = v16 + v12;
  }
  return result;
}

uint64_t conv1d_proj_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  padded_uint64_t bytes = 0;
  uint64_t v8 = *(void *)(a1 + 120);
  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 72);
    uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 16), v9, &padded_bytes);
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
      uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 24), v9, &padded_bytes);
      if (!result)
      {
        get_padded_bytes(padded_bytes, 8u);
        return 0;
      }
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v11);
    return 7;
  }
  return result;
}

uint64_t conv1d_proj_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 120);
  if (v9)
  {
    unsigned int v17 = 0;
    uint64_t result = fi_shape_get_bytes((int *)(*(void *)(v9 + 16) + 40), &v17);
    if (!result)
    {
      uint64_t v11 = v17;
      uint64_t v12 = *(void *)(v9 + 16);
      *(void *)(v12 + 240) = *(void *)(a1 + 240) + v17;
      uint64_t v13 = *(void (**)(void))(v12 + 168);
      if (v13) {
        v13();
      }
      uint64_t v14 = *(void *)(v9 + 24);
      *(void *)(v14 + 240) = *(void *)(a1 + 240) + v11;
      uint64_t v15 = *(void (**)(void))(v14 + 168);
      if (v15) {
        v15();
      }
      return 0;
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v16);
    return 7;
  }
  return result;
}

uint64_t config_conv1d_proj_layer(int a1, int a2, int a3, int a4, _DWORD *a5)
{
  *a5 = a1;
  a5[1] = a2;
  a5[2] = a3;
  a5[3] = a4;
  return 0;
}

uint64_t create_mrf_layer(uint64_t *a1, unsigned int *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v6 = 0;
  uint64_t result = 7;
  if (a1 && a2)
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v6)
    {
      uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 144);
      unsigned int v17 = (void *)v13;
      if (!v13)
      {
        uint64_t v43 = *a1;
        int64x2_t v44 = "out of memory!";
LABEL_37:
        log_OutText(v43, (uint64_t)"FastInfer", 0, 0, (uint64_t)v44, v14, v15, v16, v48);
        *(void *)(v6 + 120) = v17;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"MRF init param failed!", v45, v46, v47, v49);
        uint64_t result = 7;
        goto LABEL_38;
      }
      long long v18 = *(_OWORD *)a2;
      long long v19 = *((_OWORD *)a2 + 1);
      long long v20 = *((_OWORD *)a2 + 3);
      *(_OWORD *)(v13 + 32) = *((_OWORD *)a2 + 2);
      *(_OWORD *)(v13 + 48) = v20;
      *(_OWORD *)uint64_t v13 = v18;
      *(_OWORD *)(v13 + 16) = v19;
      long long v21 = *((_OWORD *)a2 + 4);
      long long v22 = *((_OWORD *)a2 + 5);
      long long v23 = *((_OWORD *)a2 + 6);
      *(void *)(v13 + 112) = *((void *)a2 + 14);
      *(_OWORD *)(v13 + 80) = v22;
      *(_OWORD *)(v13 + 96) = v23;
      *(_OWORD *)(v13 + 64) = v21;
      unsigned int v59 = 0;
      memset(v58, 0, sizeof(v58));
      uint64_t v24 = *a2;
      uint64_t v25 = a2[4];
      unsigned int v26 = a2[17];
      LODWORD(v56) = 5;
      HIDWORD(v56) = v26;
      int v57 = 0;
      uint64_t v55 = 0x100000000;
      uint64_t v27 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 12, 8);
      v17[15] = v27;
      if (!v27
        || (uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 12, 8),
            (v17[16] = v31) == 0))
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v28, v29, v30, v48);
LABEL_36:
        uint64_t v43 = *a1;
        int64x2_t v44 = "MRF network init failed!";
        goto LABEL_37;
      }
      uint64_t v51 = a4;
      config_conv1d_layer(a2[17], 1, 1, 1, 1, 1, a2[18], v58);
      if (v24)
      {
        uint64_t v53 = 0;
        uint64_t v54 = 0;
        uint64_t v50 = (v25 - 1);
        uint64_t v52 = v25;
        while (!v25)
        {
LABEL_27:
          ++v53;
          v54 += 4;
          LODWORD(v25) = v52;
          if (v53 == v24) {
            goto LABEL_28;
          }
        }
        uint64_t v32 = v54;
        uint64_t v33 = v52;
        uint64_t v34 = v50;
        while (1)
        {
          unsigned int v35 = a2[v32 + 5];
          LODWORD(v58[0]) = a2[v53 + 1];
          DWORD2(v58[0]) = v35;
          if (a2[20] != 1)
          {
            if (v34 || (unsigned int v36 = a2[21]) != 0)
            {
              if (a2[22] == 1) {
                unsigned int v36 = 0;
              }
              else {
                unsigned int v36 = a2[18];
              }
            }
            unsigned int v59 = v36;
          }
          if (create_conv1d_layer(a1, v58, 0, a3, (uint64_t ***)(v17[15] + 8 * v32)))
          {
            uint64_t v41 = *a1;
            int v42 = "create MRF sub-conv1d layer failed!";
            goto LABEL_35;
          }
          if (a2[20] == 1)
          {
            if (v34 || (unsigned int v40 = a2[21]) != 0)
            {
              if (a2[22] == 1) {
                unsigned int v40 = 0;
              }
              else {
                unsigned int v40 = a2[18];
              }
            }
            LODWORD(v55) = v40;
            if (create_fc_layer(a1, &v56, &v55, 0, a3, (uint64_t *)(v17[16] + 8 * v32))) {
              break;
            }
          }
          --v34;
          ++v32;
          if (!--v33) {
            goto LABEL_27;
          }
        }
        uint64_t v41 = *a1;
        int v42 = "create MRF sub-fc layer failed!";
        goto LABEL_35;
      }
LABEL_28:
      LODWORD(v55) = 0;
      if (create_fc_layer(a1, &v56, &v55, 0, a3, v17 + 17))
      {
        uint64_t v41 = *a1;
        int v42 = "create MRF sub-residual fc layer failed!";
LABEL_35:
        log_OutText(v41, (uint64_t)"FastInfer", 0, 0, (uint64_t)v42, v37, v38, v39, v48);
        a4 = v51;
        goto LABEL_36;
      }
      *(void *)uint64_t v6 = a1;
      *(void *)(v6 + 8) = 70;
      *(void *)(v6 + 120) = v17;
      *(void *)(v6 + 128) = forward_mrf_layer;
      *(void *)(v6 + 136) = free_mrf_layer;
      *(void *)(v6 + 144) = mrf_layer_update_shape;
      *(void *)(v6 + 152) = mrf_layer_wanted_wb_len;
      *(void *)(v6 + 160) = mrf_layer_request_glbBuf;
      *(void *)(v6 + 184) = mrf_layer_dispatch_weights;
      *(void *)(v6 + 168) = mrf_layer_assign_glbBuf;
      a4 = v51;
      if (a3)
      {
        uint64_t result = 0;
        *(void *)(v6 + 256) = *(void *)(a3 + 24);
        *(_DWORD *)(v6 + 264) = *(_DWORD *)(a3 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v37, v38, v39, v48);
        uint64_t result = 0;
        *(void *)(v6 + 256) = 0;
        *(_DWORD *)(v6 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v10, v11, v12, v48);
      uint64_t result = 10;
    }
  }
LABEL_38:
  *a4 = v6;
  return result;
}

uint64_t forward_mrf_layer(uint64_t a1, uint64_t a2, void *a3, float *a4)
{
  uint64_t v7 = *(int **)(a2 + 120);
  uint64_t v8 = *(uint64_t **)a2;
  uint64_t v9 = (int *)(a2 + 40);
  if (v7[22] != 1)
  {
    unsigned int __n_4 = 0;
    int v33 = *v7;
    uint64_t v34 = v7[4];
    uint64_t bytes = fi_shape_get_bytes(v9, &__n_4);
    if (bytes) {
      return bytes;
    }
    size_t v35 = __n_4;
    bzero(a4, __n_4);
    unsigned int v36 = *(float **)(a2 + 240);
    if (v7[19] == 1)
    {
      memcpy(v36, a3, v35);
      fi_activate_array(v36, __n_4 >> 2, 14);
    }
    uint64_t v15 = (*(uint64_t (**)(void))(*((void *)v7 + 17) + 128))(0);
    if (v15) {
      goto LABEL_34;
    }
    uint64_t v63 = v34;
    uint64_t v55 = v8;
    int v52 = v33;
    if (!v33)
    {
LABEL_58:
      unsigned int v32 = __n_4;
      goto LABEL_59;
    }
    unsigned int v59 = 0;
    int v54 = 0;
    size_t v40 = v35 >> 2;
    uint64_t v41 = &v36[v35 >> 2];
    int v57 = a4;
    float v61 = a3;
    while (1)
    {
      int v42 = (float *)a3;
      if (v63) {
        break;
      }
LABEL_57:
      a4 = v57;
      axpy(__n_4 >> 2, v42, 1, v57, 1, 1.0);
      v59 += 4;
      ++v54;
      a3 = v61;
      if (v54 == v52) {
        goto LABEL_58;
      }
    }
    unsigned int v43 = v59;
    uint64_t v44 = v63;
    uint64_t v45 = (float *)v61;
    uint64_t v46 = v36;
    while (1)
    {
      uint64_t v29 = (*(uint64_t (**)(void))(*(void *)(*((void *)v7 + 15) + 8 * v43) + 128))(0);
      if (v29) {
        goto LABEL_60;
      }
      if (v7[20] != 1) {
        break;
      }
      if (v45 == v41) {
        size_t v47 = v40;
      }
      else {
        size_t v47 = 0;
      }
      uint64_t v48 = &v41[v47];
      uint64_t v30 = (*(uint64_t (**)(void))(*(void *)(*((void *)v7 + 16) + 8 * v43) + 128))(0);
      if (v30)
      {
LABEL_61:
        uint64_t bytes = v30;
        uint64_t v37 = *v55;
        uint64_t v38 = "MRF forward sub-fc layer failed!";
        goto LABEL_35;
      }
      if (!v7[23])
      {
        uint64_t v46 = v48;
        uint64_t v49 = v36;
LABEL_55:
        uint64_t v48 = v45;
        goto LABEL_56;
      }
      axpy(__n_4 >> 2, v45, 1, v48, 1, 1.0);
      uint64_t v46 = v48;
      uint64_t v49 = v36;
LABEL_56:
      int v42 = v46;
      ++v43;
      uint64_t v45 = v48;
      uint64_t v46 = v49;
      if (!--v44) {
        goto LABEL_57;
      }
    }
    if (v7[23])
    {
      axpy(__n_4 >> 2, v45, 1, v46, 1, 1.0);
      uint64_t v45 = v46;
    }
    if (v46 == v36) {
      uint64_t v49 = v41;
    }
    else {
      uint64_t v49 = v36;
    }
    goto LABEL_55;
  }
  unsigned int __n = 0;
  int v10 = *v7;
  uint64_t v11 = v7[4];
  uint64_t bytes = fi_shape_get_bytes(v9, &__n);
  if (!bytes)
  {
    size_t v13 = __n;
    bzero(a4, __n);
    uint64_t v14 = *(float **)(a2 + 240);
    memcpy(v14, a3, v13);
    fi_activate_array(v14, __n >> 2, v7[18]);
    uint64_t v15 = (*(uint64_t (**)(void))(*((void *)v7 + 17) + 128))(0);
    if (!v15)
    {
      uint64_t v60 = (float *)a3;
      uint64_t v55 = v8;
      if (v10)
      {
        int v19 = 0;
        int v51 = v10;
        int v53 = 0;
        uint64_t v20 = v13 & 0xFFFFFFFC;
        long long v21 = (float *)((char *)v14 + v20);
        long long v22 = (float *)((char *)v14 + v20 + v20);
        uint64_t v62 = (char *)v22 + v20;
        uint64_t v56 = a4;
        int v58 = v14;
        while (1)
        {
          long long v23 = v14;
          if (v11) {
            break;
          }
LABEL_28:
          a4 = v56;
          axpy(__n >> 2, v23, 1, v56, 1, 1.0);
          v19 += 4;
          ++v53;
          uint64_t v14 = v58;
          if (v53 == v51) {
            goto LABEL_29;
          }
        }
        uint64_t v24 = 0;
        uint64_t v25 = v21;
        long long v23 = v58;
        unsigned int v26 = v60;
        while (1)
        {
          if (v24)
          {
            if (v26 == v22) {
              uint64_t v27 = v62;
            }
            else {
              uint64_t v27 = v22;
            }
            memcpy(v27, v23, __n);
            fi_activate_array((float *)v27, __n >> 2, v7[18]);
          }
          uint64_t v28 = (v19 + v24);
          uint64_t v29 = (*(uint64_t (**)(void))(*(void *)(*((void *)v7 + 15) + 8 * v28) + 128))(0);
          if (v29) {
            break;
          }
          if (v7[20] == 1)
          {
            if (v26 == v22) {
              uint64_t v25 = (float *)v62;
            }
            else {
              uint64_t v25 = v22;
            }
            uint64_t v30 = (*(uint64_t (**)(void))(*(void *)(*((void *)v7 + 16) + 8 * v28) + 128))(0);
            if (v30) {
              goto LABEL_61;
            }
            if (v7[23])
            {
              axpy(__n >> 2, v26, 1, v25, 1, 1.0);
              unsigned int v26 = v25;
            }
            uint64_t v31 = v21;
          }
          else
          {
            if (v7[23])
            {
              axpy(__n >> 2, v26, 1, v25, 1, 1.0);
              unsigned int v26 = v25;
            }
            if (v25 == v21) {
              uint64_t v31 = v22;
            }
            else {
              uint64_t v31 = v21;
            }
          }
          long long v23 = v25;
          ++v24;
          uint64_t v25 = v31;
          if (v11 == v24) {
            goto LABEL_28;
          }
        }
LABEL_60:
        uint64_t bytes = v29;
        uint64_t v37 = *v55;
        uint64_t v38 = "MRF forward sub-conv layer failed!";
        goto LABEL_35;
      }
LABEL_29:
      unsigned int v32 = __n;
LABEL_59:
      fi_activate_array(a4, v32 >> 2, v7[18]);
      return 0;
    }
LABEL_34:
    uint64_t bytes = v15;
    uint64_t v37 = *v8;
    uint64_t v38 = "MRF forward residual fc layer failed!";
LABEL_35:
    log_OutText(v37, (uint64_t)"FastInfer", 0, 0, (uint64_t)v38, v16, v17, v18, v50);
  }
  return bytes;
}

void *free_mrf_layer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = (int *)result[15];
      if (v3)
      {
        unsigned int v4 = *v3;
        if (*v3)
        {
          int v5 = 0;
          unsigned int v6 = 0;
          LODWORD(v7) = v3[4];
          do
          {
            if (v7)
            {
              unint64_t v8 = 0;
              do
              {
                fi_layer_free(*(void *)(*((void *)v3 + 15) + 8 * (v5 + v8)));
                fi_layer_free(*(void *)(*((void *)v3 + 16) + 8 * (v5 + v8++)));
                unint64_t v7 = v3[4];
              }
              while (v8 < v7);
              unsigned int v4 = *v3;
            }
            ++v6;
            v5 += 4;
          }
          while (v6 < v4);
        }
        fi_layer_free(*((void *)v3 + 17));
        if (*((void *)v3 + 15))
        {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
          *((void *)v3 + 15) = 0;
        }
        if (*((void *)v3 + 16))
        {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
          *((void *)v3 + 16) = 0;
        }
        (*(void (**)(void, int *))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v9 = *(void *)(v2 + 16);
      int v10 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v10(v9, v1);
    }
  }
  return result;
}

uint64_t mrf_layer_update_shape(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)a2 == 2)
  {
    int v10 = *(int **)(a1 + 120);
    int v11 = *v10;
    uint64_t v12 = v10[4];
    long long v13 = *a2;
    *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
    *(_OWORD *)(a1 + 20) = v13;
    if (v11)
    {
      unsigned int v14 = 0;
      int v15 = 0;
      while (!v12)
      {
LABEL_10:
        ++v15;
        v14 += 4;
        if (v15 == v11) {
          goto LABEL_11;
        }
      }
      uint64_t v16 = v12;
      unsigned int v17 = v14;
      while (1)
      {
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(*((void *)v10 + 15) + 8 * v17) + 144))();
        if (result) {
          break;
        }
        if (v10[20] == 1)
        {
          uint64_t result = (*(uint64_t (**)(void))(*(void *)(*((void *)v10 + 16) + 8 * v17) + 144))();
          if (result) {
            break;
          }
        }
        ++v17;
        if (!--v16) {
          goto LABEL_10;
        }
      }
    }
    else
    {
LABEL_11:
      uint64_t result = (*(uint64_t (**)(void))(*((void *)v10 + 17) + 144))();
      if (!result)
      {
        long long v19 = *a2;
        *(_DWORD *)(a1 + 56) = *((_DWORD *)a2 + 4);
        *(_OWORD *)(a1 + 40) = v19;
      }
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Currently MRF layer only support 2D input", a6, a7, a8, v20);
    return 7;
  }
  return result;
}

uint64_t mrf_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  unsigned int v4 = *(int **)(a1 + 120);
  int v5 = *v4;
  if (*v4)
  {
    unsigned int v7 = 0;
    int v8 = 0;
    padded_uint64_t bytes = 0;
    uint64_t v10 = v4[4];
    while (!v10)
    {
LABEL_10:
      ++v8;
      v7 += 4;
      if (v8 == v5) {
        goto LABEL_13;
      }
    }
    uint64_t v11 = v10;
    unsigned int v12 = v7;
    while (1)
    {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(*((void *)v4 + 15) + 8 * v12) + 152))();
      if (result) {
        break;
      }
      padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
      if (v4[20] == 1)
      {
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(*((void *)v4 + 16) + 8 * v12) + 152))();
        if (result) {
          return result;
        }
        padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
      }
      ++v12;
      if (!--v11) {
        goto LABEL_10;
      }
    }
  }
  else
  {
    padded_uint64_t bytes = 0;
LABEL_13:
    uint64_t result = (*(uint64_t (**)(void))(*((void *)v4 + 17) + 152))();
    if (!result)
    {
      *a2 = get_padded_bytes(padded_bytes, 8u);
      *a3 = 0;
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"num_kernels: %d\n", v14, v15, v16, *v4 % 0x64u);
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v17, v18, v19, *(unsigned int *)(a1 + 96));
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v20, v21, v22, *a2);
      return 0;
    }
  }
  return result;
}

uint64_t mrf_layer_request_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(int **)(a1 + 120);
  int v16 = 0;
  int v3 = *v2;
  uint64_t v4 = v2[4];
  uint64_t result = mrf_layer_get_reserved_glbBuf_bytes(a1, &v16);
  if (!result)
  {
    int v6 = v16;
    if (v3)
    {
      unsigned int v7 = 0;
      int v8 = 0;
      unsigned int v9 = 0;
      do
      {
        if (v4)
        {
          uint64_t v10 = v4;
          unsigned int v11 = v7;
          do
          {
            uint64_t v12 = v11;
            long long v13 = *(uint64_t (**)(void))(*(void *)(*((void *)v2 + 15) + 8 * v11) + 160);
            if (v13)
            {
              uint64_t result = v13();
              if (result) {
                return result;
              }
              if (*(_DWORD *)(*(void *)(*((void *)v2 + 15) + 8 * v12) + 248) > v9) {
                unsigned int v9 = *(_DWORD *)(*(void *)(*((void *)v2 + 15) + 8 * v12) + 248);
              }
            }
            if (v2[20] == 1)
            {
              uint64_t v14 = *(uint64_t (**)(void))(*(void *)(*((void *)v2 + 16) + 8 * v12) + 160);
              if (v14)
              {
                uint64_t result = v14();
                if (result) {
                  return result;
                }
                if (*(_DWORD *)(*(void *)(*((void *)v2 + 16) + 8 * v12) + 248) > v9) {
                  unsigned int v9 = *(_DWORD *)(*(void *)(*((void *)v2 + 16) + 8 * v12) + 248);
                }
              }
            }
            unsigned int v11 = v12 + 1;
            --v10;
          }
          while (v10);
        }
        ++v8;
        v7 += 4;
      }
      while (v8 != v3);
    }
    else
    {
      unsigned int v9 = 0;
    }
    uint64_t v15 = *(uint64_t (**)(void))(*((void *)v2 + 17) + 160);
    if (v15)
    {
      uint64_t result = v15();
      if (result) {
        return result;
      }
      if (*(_DWORD *)(*((void *)v2 + 17) + 248) > v9) {
        unsigned int v9 = *(_DWORD *)(*((void *)v2 + 17) + 248);
      }
    }
    uint64_t result = 0;
    *(_DWORD *)(a1 + 248) = v9 + v6;
  }
  return result;
}

uint64_t mrf_layer_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(int **)(a1 + 120);
  unsigned int v9 = *(uint64_t **)a1;
  uint64_t v10 = *(void *)(a1 + 72);
  padded_uint64_t bytes = 0;
  int v11 = *v8;
  if (*v8)
  {
    unsigned int v12 = 0;
    int v13 = 0;
    uint64_t v14 = v8[4];
    while (!v14)
    {
LABEL_12:
      ++v13;
      v12 += 4;
      if (v13 == v11) {
        goto LABEL_13;
      }
    }
    uint64_t v15 = v14;
    unsigned int v16 = v12;
    while (1)
    {
      uint64_t v17 = *(void *)(*((void *)v8 + 15) + 8 * v16);
      if (!v17) {
        goto LABEL_16;
      }
      uint64_t result = fi_layer_find_weights_via_offset(v17, v10, &padded_bytes);
      if (result) {
        return result;
      }
      padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
      if (v8[20] == 1)
      {
        uint64_t v19 = *(void *)(*((void *)v8 + 16) + 8 * v16);
        if (!v19) {
          goto LABEL_16;
        }
        uint64_t result = fi_layer_find_weights_via_offset(v19, v10, &padded_bytes);
        if (result) {
          return result;
        }
        padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
      }
      ++v16;
      if (!--v15) {
        goto LABEL_12;
      }
    }
  }
LABEL_13:
  uint64_t v20 = *((void *)v8 + 17);
  if (!v20)
  {
LABEL_16:
    log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"mrf: a sublayer is not initialized!", a6, a7, a8, v21);
    return 10;
  }
  uint64_t result = fi_layer_find_weights_via_offset(v20, v10, &padded_bytes);
  if (!result)
  {
    get_padded_bytes(padded_bytes, 8u);
    return 0;
  }
  return result;
}

uint64_t mrf_layer_assign_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(int **)(a1 + 120);
  unsigned int v18 = 0;
  int v3 = *v2;
  uint64_t v4 = v2[4];
  reserved_glbBuf_uint64_t bytes = mrf_layer_get_reserved_glbBuf_bytes(a1, (int *)&v18);
  if (!reserved_glbBuf_bytes)
  {
    uint64_t v6 = v18;
    if (v3)
    {
      unsigned int v7 = 0;
      for (int i = 0; i != v3; ++i)
      {
        if (v4)
        {
          uint64_t v9 = v4;
          unsigned int v10 = v7;
          do
          {
            uint64_t v11 = *(void *)(*((void *)v2 + 15) + 8 * v10);
            *(void *)(v11 + 240) = *(void *)(a1 + 240) + v6;
            unsigned int v12 = *(void (**)(void))(v11 + 168);
            if (v12) {
              v12();
            }
            if (v2[20] == 1)
            {
              uint64_t v13 = *(void *)(*((void *)v2 + 16) + 8 * v10);
              *(void *)(v13 + 240) = *(void *)(a1 + 240) + v6;
              uint64_t v14 = *(void (**)(void))(v13 + 168);
              if (v14) {
                v14();
              }
            }
            ++v10;
            --v9;
          }
          while (v9);
        }
        v7 += 4;
      }
    }
    uint64_t v15 = *((void *)v2 + 17);
    *(void *)(v15 + 240) = *(void *)(a1 + 240) + v6;
    unsigned int v16 = *(void (**)(void))(v15 + 168);
    if (v16) {
      v16();
    }
  }
  return reserved_glbBuf_bytes;
}

uint64_t mrf_layer_get_reserved_glbBuf_bytes(uint64_t a1, int *a2)
{
  uint64_t v3 = *(void *)(a1 + 120);
  int v6 = 0;
  uint64_t result = fi_shape_get_bytes((int *)(*(void *)(v3 + 136) + 40), &v6);
  if (!result)
  {
    int v5 = 4 * v6;
    if (*(_DWORD *)(v3 + 88) != 1) {
      int v5 = 3 * v6;
    }
    *a2 = v5;
  }
  return result;
}

uint64_t create_cbhg_layer(uint64_t *a1, uint64_t a2, uint64_t **a3, uint64_t a4, uint64_t ***a5)
{
  unsigned int v7 = 0;
  uint64_t result = 7;
  if (a1 && a2)
  {
    unsigned int v7 = (uint64_t **)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 88);
      uint64_t v19 = v15;
      if (!v15)
      {
        uint64_t v25 = "out of memory!";
        goto LABEL_27;
      }
      int v20 = *(_DWORD *)(a2 + 32);
      long long v21 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)uint64_t v15 = *(_OWORD *)a2;
      *(_OWORD *)(v15 + 16) = v21;
      *(_DWORD *)(v15 + 32) = v20;
      int v22 = *(_DWORD *)(v15 + 24);
      int v23 = *(_DWORD *)(v15 + 12);
      int v24 = *(_DWORD *)(v15 + 16);
      if (v23 == v22)
      {
        if (v24)
        {
LABEL_7:
          uint64_t v25 = "usage of pre-highway layer mismatch!";
LABEL_27:
          log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v25, v16, v17, v18, v29);
          v7[15] = (uint64_t *)v19;
          log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"cbhg init param failed!", v26, v27, v28, v30);
          uint64_t result = 7;
          goto LABEL_28;
        }
      }
      else if (!v24)
      {
        goto LABEL_7;
      }
      if (!*(_DWORD *)(v15 + 4))
      {
        uint64_t v25 = "cb_feats must be greater than zero!";
        goto LABEL_27;
      }
      if (!*(_DWORD *)(v15 + 8))
      {
        uint64_t v25 = "cp_feats1 must be greater than zero!";
        goto LABEL_27;
      }
      if (!v23)
      {
        uint64_t v25 = "cp_feats2 must be greater than zero!";
        goto LABEL_27;
      }
      if (!*(_DWORD *)(v15 + 28))
      {
        uint64_t v25 = "gru_feats must be greater than zero!";
        goto LABEL_27;
      }
      if (!v22)
      {
        uint64_t v25 = "hw_feats must be greater than zero!";
        goto LABEL_27;
      }
      if (!*(_DWORD *)v15)
      {
        uint64_t v25 = "num_cb must be greater than zero!";
        goto LABEL_27;
      }
      if (!*(_DWORD *)(v15 + 20))
      {
        uint64_t v25 = "num_hw must be greater than zero!";
        goto LABEL_27;
      }
      if (init_network(a1, v15 + 40, (int *)a2, a3, a4))
      {
        uint64_t v25 = "cbhg network init failed!";
        goto LABEL_27;
      }
      v7[15] = (uint64_t *)v19;
      if (a3) {
        *(uint64_t **)((char *)v7 + 60) = *a3;
      }
      uint64_t result = 0;
      *unsigned int v7 = a1;
      v7[1] = (uint64_t *)55;
      v7[16] = (uint64_t *)forward_cbhg_layer;
      v7[17] = (uint64_t *)free_cbhg_layer;
      v7[18] = (uint64_t *)cbhg_update_shape;
      v7[19] = (uint64_t *)cbhg_wanted_wb_len;
      v7[20] = (uint64_t *)cbhg_request_glbBuf;
      v7[23] = (uint64_t *)cbhg_dispatch_weights;
      v7[21] = (uint64_t *)cbhg_assign_glbBuf;
      v7[22] = (uint64_t *)cbhg_reset;
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, v29);
      uint64_t result = 10;
    }
  }
LABEL_28:
  *a5 = v7;
  return result;
}

uint64_t forward_cbhg_layer(uint64_t a1, uint64_t a2, float *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v30 = 0;
  HIDWORD(v29) = 0;
  if (!a2) {
    return 0;
  }
  uint64_t v9 = *(uint64_t **)a2;
  uint64_t v10 = *(void *)(a2 + 120);
  if (!v10)
  {
    uint64_t v22 = *v9;
    int v23 = "config empty";
LABEL_9:
    log_OutText(v22, (uint64_t)"FastInfer", 0, 0, (uint64_t)v23, a6, a7, a8, v29);
    return 7;
  }
  uint64_t v14 = *(char **)(a2 + 240);
  uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v10 + 40) + 40), (_DWORD *)&v30 + 1);
  if (bytes) {
    return bytes;
  }
  bzero(v14, HIDWORD(v30));
  uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)(v10 + 40) + 128))(a1);
  if (v16)
  {
    uint64_t bytes = v16;
    uint64_t v20 = *v9;
    long long v21 = "cbhg forward conv1d bank failed!";
LABEL_6:
    log_OutText(v20, (uint64_t)"FastInfer", 0, 0, (uint64_t)v21, v17, v18, v19, v29);
    return bytes;
  }
  max_array_f32(((*(_DWORD *)(*(void *)(v10 + 48) + 24) - 1) * *(_DWORD *)(*(void *)(v10 + 48) + 28)), (float *)v14, (float *)&v14[4 * *(unsigned int *)(*(void *)(v10 + 48) + 28)]);
  uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v10 + 56) + 40), (_DWORD *)&v30 + 1);
  if (bytes) {
    return bytes;
  }
  bzero(a4, HIDWORD(v30));
  uint64_t v25 = (*(uint64_t (**)(uint64_t))(*(void *)(v10 + 56) + 128))(a1);
  if (v25)
  {
    uint64_t bytes = v25;
    uint64_t v20 = *v9;
    long long v21 = "cbhg forward conv1d projection failed!";
    goto LABEL_6;
  }
  if (fi_shape_is_same((unsigned int *)(a2 + 20), (_DWORD *)(*(void *)(v10 + 56) + 40)) != 1)
  {
    uint64_t v22 = *v9;
    int v23 = "cbhg residual add size mismatch!";
    goto LABEL_9;
  }
  uint64_t bytes = fi_shape_get_size((int *)(a2 + 20), (int *)&v29 + 1);
  if (!bytes)
  {
    axpy(HIDWORD(v29), a3, 1, (float *)a4, 1, 1.0);
    uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v10 + 72) + 40), &v30);
    if (!bytes)
    {
      if (*(_DWORD *)(v10 + 16) == 1)
      {
        int v26 = v30;
        uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v10 + 64) + 40), (_DWORD *)&v30 + 1);
        if (bytes) {
          return bytes;
        }
        bzero(&v14[v26 & 0xFFFFFFFC], HIDWORD(v30));
        uint64_t v27 = (*(uint64_t (**)(uint64_t))(*(void *)(v10 + 64) + 128))(a1);
        if (v27)
        {
          uint64_t bytes = v27;
          uint64_t v20 = *v9;
          long long v21 = "cbhg forward pre-highway failed!";
          goto LABEL_6;
        }
      }
      bzero(v14, v30);
      uint64_t v28 = (*(uint64_t (**)(uint64_t))(*(void *)(v10 + 72) + 128))(a1);
      if (v28)
      {
        uint64_t bytes = v28;
        uint64_t v20 = *v9;
        long long v21 = "cbhg forward highway failed!";
        goto LABEL_6;
      }
      uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v10 + 80) + 40), (_DWORD *)&v30 + 1);
      if (!bytes)
      {
        bzero(a4, HIDWORD(v30));
        uint64_t bytes = (*(uint64_t (**)(uint64_t))(*(void *)(v10 + 80) + 128))(a1);
        if (bytes)
        {
          uint64_t v20 = *v9;
          long long v21 = "cbhg forward bgru failed!";
          goto LABEL_6;
        }
      }
    }
  }
  return bytes;
}

void *free_cbhg_layer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = result[15];
      if (v3)
      {
        fi_layer_free(*(void *)(v3 + 40));
        fi_layer_free(*(void *)(v3 + 48));
        fi_layer_free(*(void *)(v3 + 56));
        if (*(_DWORD *)(v3 + 16) == 1) {
          fi_layer_free(*(void *)(v3 + 64));
        }
        fi_layer_free(*(void *)(v3 + 72));
        fi_layer_free(*(void *)(v3 + 80));
        (*(void (**)(void, uint64_t))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v4 = *(void *)(v2 + 16);
      int v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v5(v4, v1);
    }
  }
  return result;
}

__n128 cbhg_update_shape(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 120);
  uint64_t v9 = *(uint64_t **)a1;
  if (!v8)
  {
    uint64_t v12 = *v9;
    uint64_t v13 = "NULL param!";
    goto LABEL_5;
  }
  long long v11 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v11;
  if (*(_DWORD *)a2 >= 3u)
  {
    uint64_t v12 = *v9;
    uint64_t v13 = "Currently cbhg layer only support 1D or 2D input";
LABEL_5:
    log_OutText(v12, (uint64_t)"FastInfer", 0, 0, (uint64_t)v13, a6, a7, a8, v18);
    return result;
  }
  if (!(*(unsigned int (**)(void))(*(void *)(v8 + 40) + 144))()
    && !(*(unsigned int (**)(void))(*(void *)(v8 + 48) + 144))()
    && !(*(unsigned int (**)(void))(*(void *)(v8 + 56) + 144))()
    && (*(_DWORD *)(v8 + 16) != 1 || !(*(unsigned int (**)(void))(*(void *)(v8 + 64) + 144))())
    && !(*(unsigned int (**)(void))(*(void *)(v8 + 72) + 144))()
    && !(*(unsigned int (**)(void))(*(void *)(v8 + 80) + 144))())
  {
    uint64_t v15 = *(void *)(v8 + 80);
    unsigned int v17 = *(_DWORD *)(v15 + 40);
    uint64_t v16 = (__n128 *)(v15 + 40);
    if (v17 >= 3)
    {
      uint64_t v12 = *v9;
      uint64_t v13 = "final output shape error: Currently cbhg only support 1D or 2D output";
      goto LABEL_5;
    }
    __n128 result = *v16;
    *(_DWORD *)(a1 + 56) = v16[1].n128_u32[0];
    *(__n128 *)(a1 + 40) = result;
  }
  return result;
}

uint64_t cbhg_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 120);
  if (v9)
  {
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 40) + 152))();
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(0, 8u);
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 56) + 152))();
      if (!result)
      {
        unsigned int v14 = get_padded_bytes(padded_bytes, 8u);
        if (*(_DWORD *)(v9 + 16) == 1)
        {
          uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 64) + 152))();
          if (result) {
            return result;
          }
          unsigned int v14 = get_padded_bytes(v14, 8u);
        }
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 72) + 152))();
        if (!result)
        {
          unsigned int v15 = get_padded_bytes(v14, 8u);
          uint64_t result = (*(uint64_t (**)(void))(*(void *)(v9 + 80) + 152))();
          if (!result)
          {
            *a2 = get_padded_bytes(v15, 8u);
            *a3 = 0;
            log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"cb_feats: %d\n", v16, v17, v18, *(unsigned int *)(v9 + 4));
            log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"cp_feats2: %d\n", v19, v20, v21, *(unsigned int *)(v9 + 12));
            log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v22, v23, v24, *(unsigned int *)(a1 + 96));
            log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v25, v26, v27, *a2);
            return 0;
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", a6, a7, a8, v28);
    return 7;
  }
  return result;
}

uint64_t cbhg_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 120);
  if (!v9)
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v18);
    return 7;
  }
  uint64_t v10 = *(uint64_t (**)(void))(*(void *)(v9 + 40) + 160);
  if (v10)
  {
    uint64_t result = v10();
    if (result) {
      return result;
    }
    unsigned int v12 = *(_DWORD *)(*(void *)(v9 + 40) + 248);
  }
  else
  {
    unsigned int v12 = 0;
  }
  uint64_t v13 = *(uint64_t (**)(void))(*(void *)(v9 + 56) + 160);
  if (v13)
  {
    uint64_t result = v13();
    if (result) {
      return result;
    }
    if (*(_DWORD *)(*(void *)(v9 + 56) + 248) > v12) {
      unsigned int v12 = *(_DWORD *)(*(void *)(v9 + 56) + 248);
    }
  }
  if (*(_DWORD *)(v9 + 16) == 1)
  {
    unsigned int v14 = *(uint64_t (**)(void))(*(void *)(v9 + 64) + 160);
    if (v14)
    {
      uint64_t result = v14();
      if (result) {
        return result;
      }
      if (*(_DWORD *)(*(void *)(v9 + 64) + 248) > v12) {
        unsigned int v12 = *(_DWORD *)(*(void *)(v9 + 64) + 248);
      }
    }
  }
  unsigned int v15 = *(uint64_t (**)(void))(*(void *)(v9 + 72) + 160);
  if (v15)
  {
    uint64_t result = v15();
    if (result) {
      return result;
    }
    if (*(_DWORD *)(*(void *)(v9 + 72) + 248) > v12) {
      unsigned int v12 = *(_DWORD *)(*(void *)(v9 + 72) + 248);
    }
  }
  uint64_t v16 = *(uint64_t (**)(void))(*(void *)(v9 + 80) + 160);
  if (v16)
  {
    uint64_t result = v16();
    if (result) {
      return result;
    }
    if (*(_DWORD *)(*(void *)(v9 + 80) + 248) > v12) {
      unsigned int v12 = *(_DWORD *)(*(void *)(v9 + 80) + 248);
    }
  }
  uint64_t v17 = *(void *)(a1 + 120);
  int v19 = 0;
  uint64_t result = fi_shape_get_bytes((int *)(*(void *)(v17 + 40) + 40), &v19);
  if (!result) {
    *(_DWORD *)(a1 + 248) = v19 + v12;
  }
  return result;
}

uint64_t cbhg_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  padded_uint64_t bytes = 0;
  uint64_t v8 = *(void *)(a1 + 120);
  if (v8)
  {
    uint64_t v9 = *(void *)(a1 + 72);
    uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 40), v9, &padded_bytes);
    if (!result)
    {
      padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
      uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 56), v9, &padded_bytes);
      if (!result)
      {
        padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
        if (*(_DWORD *)(v8 + 16) == 1)
        {
          uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 64), v9, &padded_bytes);
          if (result) {
            return result;
          }
          padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
        }
        uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 72), v9, &padded_bytes);
        if (!result)
        {
          padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
          uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v8 + 80), v9, &padded_bytes);
          if (!result)
          {
            get_padded_bytes(padded_bytes, 8u);
            return 0;
          }
        }
      }
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v11);
    return 7;
  }
  return result;
}

uint64_t cbhg_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 120);
  if (v9)
  {
    unsigned int v23 = 0;
    uint64_t result = fi_shape_get_bytes((int *)(*(void *)(v9 + 40) + 40), &v23);
    if (!result)
    {
      uint64_t v11 = v23;
      uint64_t v12 = *(void *)(v9 + 40);
      *(void *)(v12 + 240) = *(void *)(a1 + 240) + v23;
      uint64_t v13 = *(void (**)(void))(v12 + 168);
      if (v13) {
        v13();
      }
      uint64_t v14 = *(void *)(v9 + 56);
      *(void *)(v14 + 240) = *(void *)(a1 + 240) + v11;
      unsigned int v15 = *(void (**)(void))(v14 + 168);
      if (v15) {
        v15();
      }
      if (*(_DWORD *)(v9 + 16) == 1)
      {
        uint64_t v16 = *(void *)(v9 + 64);
        *(void *)(v16 + 240) = *(void *)(a1 + 240) + v11;
        uint64_t v17 = *(void (**)(void))(v16 + 168);
        if (v17) {
          v17();
        }
      }
      uint64_t v18 = *(void *)(v9 + 72);
      *(void *)(v18 + 240) = *(void *)(a1 + 240) + v11;
      int v19 = *(void (**)(void))(v18 + 168);
      if (v19) {
        v19();
      }
      uint64_t v20 = *(void *)(v9 + 80);
      *(void *)(v20 + 240) = *(void *)(a1 + 240) + v11;
      uint64_t v21 = *(void (**)(void))(v20 + 168);
      if (v21) {
        v21();
      }
      return 0;
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v22);
    return 7;
  }
  return result;
}

uint64_t cbhg_reset(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 120) + 80);
  if (v1 && (uint64_t v2 = *(uint64_t (**)(void))(v1 + 176)) != 0) {
    return v2();
  }
  else {
    return 0;
  }
}

uint64_t init_network(uint64_t *a1, uint64_t a2, int *a3, uint64_t **a4, uint64_t a5)
{
  int v47 = 0;
  uint64_t v46 = 0;
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 8);
  if (!v10)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v11, v12, v13, v45);
    return 10;
  }
  uint64_t v14 = (uint64_t *)v10;
  int v50 = 0;
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  uint64_t v18 = (unsigned int *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16);
  if (!v18)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v15, v16, v17, v45);
    uint64_t v22 = 0;
LABEL_10:
    uint64_t v26 = 0;
LABEL_11:
    uint64_t v31 = 10;
    goto LABEL_33;
  }
  uint64_t v22 = (long long *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 36);
  if (!v22)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v19, v20, v21, v45);
    goto LABEL_10;
  }
  uint64_t v26 = (long long *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 20);
  if (!v26)
  {
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v23, v24, v25, v45);
    goto LABEL_11;
  }
  uint64_t v27 = config_conv1d_bank_layer(*a3, a3[1], v14);
  if (v27)
  {
    uint64_t v31 = v27;
    uint64_t v32 = *a1;
    int v33 = "create cbhg: conv1d_bank cfg failed!";
LABEL_32:
    log_OutText(v32, (uint64_t)"FastInfer", 0, 0, (uint64_t)v33, v28, v29, v30, v45);
    goto LABEL_33;
  }
  conv1d_banuint64_t k = create_conv1d_bank(a1, v14, a4, a5, (uint64_t *)a2);
  if (conv1d_bank)
  {
    uint64_t v31 = conv1d_bank;
    uint64_t v32 = *a1;
    int v33 = "create cbhg: conv1d_bank layer failed!";
    goto LABEL_32;
  }
  uint64_t v35 = config_pooling1d_layer(2, 1, 1, 1, v22);
  if (v35)
  {
    uint64_t v31 = v35;
    uint64_t v32 = *a1;
    int v33 = "create cbhg: maxpooling cfg failed!";
    goto LABEL_32;
  }
  uint64_t pooling1d_layer = create_pooling1d_layer(a1, 10, v22, a4, (uint64_t ***)(a2 + 8));
  if (pooling1d_layer)
  {
    uint64_t v31 = pooling1d_layer;
    uint64_t v32 = *a1;
    int v33 = "create cbhg: maxpooling layer failed!";
    goto LABEL_32;
  }
  uint64_t v37 = config_conv1d_proj_layer(3, a3[2], a3[3], 3, v18);
  if (v37)
  {
    uint64_t v31 = v37;
    uint64_t v32 = *a1;
    int v33 = "create cbhg: conv1d_proj cfg failed!";
    goto LABEL_32;
  }
  uint64_t conv1d_proj_layer = create_conv1d_proj_layer(a1, v18, a4, a5, (uint64_t *)(a2 + 16));
  if (conv1d_proj_layer)
  {
    uint64_t v31 = conv1d_proj_layer;
    uint64_t v32 = *a1;
    int v33 = "create cbhg: conv1d_proj layer failed!";
    goto LABEL_32;
  }
  if (a3[4] == 1)
  {
    int v39 = a3[6];
    LODWORD(v49) = 5;
    HIDWORD(v49) = v39;
    int v50 = 0;
    uint64_t v48 = 0;
    uint64_t v40 = create_fc_layer(a1, &v49, &v48, a4, a5, (uint64_t *)(a2 + 24));
    if (v40)
    {
      uint64_t v31 = v40;
      uint64_t v32 = *a1;
      int v33 = "create cbhg: pre highway layer failed!";
      goto LABEL_32;
    }
  }
  uint64_t v41 = config_highways_layer(a3[5], a3[6], 3, &v46);
  if (v41)
  {
    uint64_t v31 = v41;
    uint64_t v32 = *a1;
    int v33 = "create cbhg: highways cfg failed!";
    goto LABEL_32;
  }
  uint64_t highways = create_highways(a1, (unsigned int *)&v46, a4, a5, (uint64_t *)(a2 + 32));
  if (highways)
  {
    uint64_t v31 = highways;
    uint64_t v32 = *a1;
    int v33 = "create cbhg: highways layer failed!";
    goto LABEL_32;
  }
  int v43 = a3[7];
  LODWORD(v49) = 24;
  HIDWORD(v49) = v43;
  int v50 = 0;
  *(long long *)((char *)v26 + 4) = xmmword_20D6B4060;
  *(_DWORD *)uint64_t v26 = a3[8];
  uint64_t v31 = create_bgru_layer(a1, &v49, v26, a4, a5, (uint64_t *)(a2 + 40));
  if (v31)
  {
    uint64_t v32 = *a1;
    int v33 = "create cbhg: bgru layer failed!";
    goto LABEL_32;
  }
LABEL_33:
  (*(void (**)(uint64_t, uint64_t *))(a1[1] + 48))(a1[2], v14);
  if (v18) {
    (*(void (**)(uint64_t, unsigned int *))(a1[1] + 48))(a1[2], v18);
  }
  if (v22) {
    (*(void (**)(uint64_t, long long *))(a1[1] + 48))(a1[2], v22);
  }
  if (v26) {
    (*(void (**)(uint64_t, long long *))(a1[1] + 48))(a1[2], v26);
  }
  return v31;
}

uint64_t config_conv1d_bank_layer(int a1, int a2, _DWORD *a3)
{
  *a3 = a1;
  a3[1] = a2;
  return 0;
}

uint64_t create_conv1d_bank(uint64_t *a1, uint64_t *a2, uint64_t **a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7 = 0;
  uint64_t result = 7;
  if (a1 && a2)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      uint64_t v15 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 16);
      uint64_t v19 = v15;
      if (!v15)
      {
        uint64_t v21 = *a1;
        uint64_t v22 = "out of memory!";
        goto LABEL_44;
      }
      uint64_t v20 = *a2;
      *uint64_t v15 = *a2;
      if (v20 >= 0xC9)
      {
        uint64_t v21 = *a1;
        uint64_t v22 = "number of conv1d_norm exploded!";
LABEL_44:
        log_OutText(v21, (uint64_t)"FastInfer", 0, 0, (uint64_t)v22, v16, v17, v18, *(uint64_t *)&v45[0]);
        *(void *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"conv1d_bank init param failed!", v42, v43, v44, *(uint64_t *)&v45[0]);
        uint64_t result = 7;
        goto LABEL_45;
      }
      if (!v20)
      {
        uint64_t v21 = *a1;
        uint64_t v22 = "number of conv1d_norm must be greater than zero!";
        goto LABEL_44;
      }
      int v46 = 0;
      memset(v45, 0, sizeof(v45));
      uint64_t v23 = *(_DWORD *)a2 % 0x64u;
      uint64_t v24 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], v23, 8);
      v19[1] = v24;
      if (!v24)
      {
        uint64_t v26 = *a1;
        uint64_t v27 = "out of memory!";
LABEL_42:
        log_OutText(v26, (uint64_t)"FastInfer", 0, 0, (uint64_t)v27, v16, v17, v18, *(uint64_t *)&v45[0]);
LABEL_43:
        uint64_t v21 = *a1;
        uint64_t v22 = "conv1d_bank network init failed!";
        goto LABEL_44;
      }
      int v25 = config_conv1d_norm_layer(*((unsigned int *)a2 + 1), 1, 1, 1, 0, 1, 3, v45);
      switch((int)v23)
      {
        case 0:
          if (v25) {
            goto LABEL_43;
          }
          goto LABEL_37;
        case 1:
        case 3:
        case 4:
        case 6:
        case 7:
          goto LABEL_34;
        case 2:
          uint64_t v34 = 0;
          char v35 = 1;
          while (1)
          {
            char v36 = v35;
            LODWORD(v45[0]) = dword_20D6B40C0[v34];
            if (create_conv1d_norm_layer(a1, (uint64_t)v45, a3, a4, (uint64_t *)(v19[1] + 8 * v34))) {
              goto LABEL_41;
            }
            char v35 = 0;
            uint64_t v34 = 1;
            if ((v36 & 1) == 0) {
              goto LABEL_37;
            }
          }
        case 5:
          uint64_t v31 = 0;
          uint64_t v32 = &dword_20D6B410C;
          while (1)
          {
            int v33 = *v32++;
            LODWORD(v45[0]) = v33;
            if (create_conv1d_norm_layer(a1, (uint64_t)v45, a3, a4, (uint64_t *)(v19[1] + v31))) {
              goto LABEL_41;
            }
            v31 += 8;
            if (v31 == 40) {
              goto LABEL_37;
            }
          }
        case 8:
          if (*(_DWORD *)a2 != 108) {
            goto LABEL_34;
          }
          uint64_t v37 = 0;
          uint64_t v38 = &dword_20D6B4150;
          break;
        default:
          if (v23 == 12)
          {
            uint64_t v28 = 0;
            uint64_t v29 = &dword_20D6B4120;
            do
            {
              int v30 = *v29++;
              LODWORD(v45[0]) = v30;
              if (create_conv1d_norm_layer(a1, (uint64_t)v45, a3, a4, (uint64_t *)(v19[1] + v28))) {
                goto LABEL_41;
              }
              v28 += 8;
            }
            while (v28 != 96);
          }
          else
          {
LABEL_34:
            uint64_t v40 = 0;
            uint64_t v41 = 0;
            do
            {
              LODWORD(v45[0]) = ++v41;
              if (create_conv1d_norm_layer(a1, (uint64_t)v45, a3, a4, (uint64_t *)(v19[1] + v40))) {
                goto LABEL_41;
              }
              v40 += 8;
            }
            while (v23 != v41);
          }
          goto LABEL_37;
      }
      do
      {
        int v39 = *v38++;
        LODWORD(v45[0]) = v39;
        if (create_conv1d_norm_layer(a1, (uint64_t)v45, a3, a4, (uint64_t *)(v19[1] + v37)))
        {
LABEL_41:
          uint64_t v26 = *a1;
          uint64_t v27 = "create conv1d_bank sub-conv1d_norm layer failed!";
          goto LABEL_42;
        }
        v37 += 8;
      }
      while (v37 != 64);
LABEL_37:
      *(void *)(v7 + 120) = v19;
      if (a3) {
        *(void *)(v7 + 60) = *a3;
      }
      *(void *)uint64_t v7 = a1;
      *(void *)(v7 + 8) = 51;
      *(void *)(v7 + 128) = forward_conv1d_bank;
      *(void *)(v7 + 136) = free_conv1d_bank;
      *(void *)(v7 + 144) = conv1d_bank_update_shape;
      *(void *)(v7 + 152) = conv1d_bank_wanted_wb_len;
      *(void *)(v7 + 160) = conv1d_bank_request_glbBuf;
      *(void *)(v7 + 184) = conv1d_bank_dispatch_weights;
      *(void *)(v7 + 168) = conv1d_bank_assign_glbBuf;
      if (a4)
      {
        uint64_t result = 0;
        *(void *)(v7 + 256) = *(void *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"netCfg not given!", v16, v17, v18, *(uint64_t *)&v45[0]);
        uint64_t result = 0;
        *(void *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, *(uint64_t *)&v45[0]);
      uint64_t result = 10;
    }
  }
LABEL_45:
  *a5 = v7;
  return result;
}

uint64_t forward_conv1d_bank(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  LODWORD(v29) = 0;
  if (!a2) {
    return 0;
  }
  uint64_t v8 = *(uint64_t **)a2;
  uint64_t v9 = *(int **)(a2 + 120);
  if (!v9)
  {
    log_OutText(*v8, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v25);
    return 7;
  }
  uint64_t v11 = *(void *)(a2 + 240);
  unsigned int v12 = *v9;
  uint64_t bytes = fi_shape_get_bytes((int *)(a2 + 40), &v29);
  if (!bytes)
  {
    bzero(a4, v29);
    uint64_t v27 = v12 % 0x64;
    if (v27)
    {
      uint64_t v26 = a4;
      uint64_t v14 = 0;
      while (1)
      {
        uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)(*((void *)v9 + 1) + 8 * v14) + 128))(a1);
        if (v15) {
          break;
        }
        uint64_t v19 = *(void *)(*((void *)v9 + 1) + 8 * v14);
        uint64_t v20 = *(unsigned int *)(v19 + 44);
        if (v20)
        {
          int v21 = 0;
          unsigned int v22 = 0;
          uint64_t v23 = *(unsigned int *)(v19 + 48);
          do
          {
            memcpy(&v26[4 * (v23 * v14) + 4 * v21], (const void *)(v11 + 4 * v22), 4 * v23);
            v22 += v23;
            v21 += v27 * v23;
            --v20;
          }
          while (v20);
        }
        if (++v14 == v27) {
          return 0;
        }
      }
      uint64_t bytes = v15;
      log_OutText(*v8, (uint64_t)"FastInfer", 0, 0, (uint64_t)"conv1d_bank forward sub-conv1d_bank layer failed!", v16, v17, v18, (uint64_t)v8);
      return bytes;
    }
    return 0;
  }
  return bytes;
}

void *free_conv1d_bank(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = result[15];
      if (v3)
      {
        uint64_t v4 = *(_DWORD *)v3 % 0x64u;
        if (v4)
        {
          for (uint64_t i = 0; i != v4; ++i)
            fi_layer_free(*(void *)(*(void *)(v3 + 8) + 8 * i));
        }
        if (*(void *)(v3 + 8))
        {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
          *(void *)(v3 + 8) = 0;
        }
        (*(void (**)(void, uint64_t))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v6 = *(void *)(v2 + 16);
      uint64_t v7 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v7(v6, v1);
    }
  }
  return result;
}

__n128 conv1d_bank_update_shape(uint64_t a1, long long *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(int **)(a1 + 120);
  uint64_t v9 = *(uint64_t **)a1;
  if (!v8)
  {
    uint64_t v13 = *v9;
    uint64_t v14 = "NULL param!";
    goto LABEL_11;
  }
  unsigned int v11 = *v8;
  long long v12 = *a2;
  *(_DWORD *)(a1 + 36) = *((_DWORD *)a2 + 4);
  *(_OWORD *)(a1 + 20) = v12;
  if (*(_DWORD *)a2 > 2u)
  {
    uint64_t v13 = *v9;
    uint64_t v14 = "Currently conv1d_bank layer only support 1D or 2D input";
LABEL_11:
    log_OutText(v13, (uint64_t)"FastInfer", 0, 0, (uint64_t)v14, a6, a7, a8, v22);
    return result;
  }
  uint64_t v15 = v11 % 0x64;
  if (!v15)
  {
LABEL_9:
    uint64_t v18 = **((void **)v8 + 1);
    unsigned int v21 = *(_DWORD *)(v18 + 40);
    uint64_t v20 = (__n128 *)(v18 + 40);
    unsigned int v19 = v21;
    if (v21 < 3)
    {
      __n128 result = *v20;
      *(_DWORD *)(a1 + 56) = v20[1].n128_u32[0];
      *(__n128 *)(a1 + 40) = result;
      *(_DWORD *)(a1 + 4 * (v19 - 1) + 44) *= v15;
      return result;
    }
    uint64_t v13 = *v9;
    uint64_t v14 = "final output shape error: Currently conv1d_bank only support 1D or 2D output";
    goto LABEL_11;
  }
  uint64_t v16 = 0;
  while (!(*(unsigned int (**)(void))(*(void *)(*((void *)v8 + 1) + 8 * v16) + 144))())
  {
    if (v15 == ++v16) {
      goto LABEL_9;
    }
  }
  return result;
}

uint64_t conv1d_bank_wanted_wb_len(uint64_t a1, unsigned int *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 120);
  if (v9)
  {
    uint64_t v12 = *(_DWORD *)v9 % 0x64u;
    if (v12)
    {
      uint64_t v13 = 0;
      padded_uint64_t bytes = 0;
      while (1)
      {
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(*(void *)(v9 + 8) + 8 * v13) + 152))();
        if (result) {
          break;
        }
        padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
        if (v12 == ++v13) {
          goto LABEL_9;
        }
      }
    }
    else
    {
      padded_uint64_t bytes = 0;
LABEL_9:
      *a2 = padded_bytes;
      *a3 = 0;
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"num_conv1d_norm: %d\n", a6, a7, a8, *(_DWORD *)v9 % 0x64u);
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v16, v17, v18, *(unsigned int *)(a1 + 96));
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v19, v20, v21, *a2);
      return 0;
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param is NULL!", a6, a7, a8, v22);
    return 7;
  }
  return result;
}

uint64_t conv1d_bank_request_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(int **)(a1 + 120);
  if (v9)
  {
    unsigned int v10 = *v9;
    int v19 = 0;
    uint64_t result = fi_shape_get_bytes((int *)(**((void **)v9 + 1) + 40), &v19);
    if (!result)
    {
      uint64_t v12 = v10 % 0x64;
      int v13 = v19;
      if (v12)
      {
        uint64_t v14 = 0;
        unsigned int v15 = 0;
        uint64_t v16 = *((void *)v9 + 1);
        do
        {
          uint64_t v17 = *(uint64_t (**)(void))(*(void *)(v16 + 8 * v14) + 160);
          if (v17)
          {
            uint64_t result = v17();
            if (result) {
              return result;
            }
            uint64_t v16 = *((void *)v9 + 1);
            if (*(_DWORD *)(*(void *)(v16 + 8 * v14) + 248) > v15) {
              unsigned int v15 = *(_DWORD *)(*(void *)(v16 + 8 * v14) + 248);
            }
          }
          ++v14;
        }
        while (v12 != v14);
      }
      else
      {
        unsigned int v15 = 0;
      }
      uint64_t result = 0;
      *(_DWORD *)(a1 + 248) = v15 + v13;
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v18);
    return 7;
  }
  return result;
}

uint64_t conv1d_bank_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  padded_uint64_t bytes = 0;
  uint64_t v8 = *(void *)(a1 + 120);
  if (v8)
  {
    uint64_t v9 = *(_DWORD *)v8 % 0x64u;
    if (v9)
    {
      uint64_t v10 = 0;
      uint64_t v11 = *(void *)(a1 + 72);
      while (1)
      {
        uint64_t v12 = *(void *)(*(void *)(v8 + 8) + 8 * v10);
        if (!v12) {
          break;
        }
        uint64_t result = fi_layer_find_weights_via_offset(v12, v11, &padded_bytes);
        if (result) {
          return result;
        }
        padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
        if (v9 == ++v10) {
          return 0;
        }
      }
      return 10;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v14);
    return 7;
  }
}

uint64_t conv1d_bank_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 120);
  if (v9)
  {
    unsigned int v17 = 0;
    uint64_t result = fi_shape_get_bytes((int *)(**(void **)(v9 + 8) + 40), &v17);
    if (!result)
    {
      uint64_t v11 = *(_DWORD *)v9 % 0x64u;
      if (v11)
      {
        uint64_t v12 = 0;
        uint64_t v13 = v17;
        do
        {
          uint64_t v14 = *(void *)(*(void *)(v9 + 8) + 8 * v12);
          *(void *)(v14 + 240) = *(void *)(a1 + 240) + v13;
          unsigned int v15 = *(void (**)(void))(v14 + 168);
          if (v15) {
            v15();
          }
          ++v12;
        }
        while (v11 != v12);
      }
      return 0;
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v16);
    return 7;
  }
  return result;
}

uint64_t conv1d_norm_dispatch_weights(uint64_t a1)
{
  padded_uint64_t bytes = 0;
  uint64_t v1 = *(void *)(a1 + 120);
  uint64_t v2 = *(void *)(a1 + 72);
  uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v1 + 40), v2, &padded_bytes);
  if (!result)
  {
    padded_uint64_t bytes = get_padded_bytes(padded_bytes, 8u);
    uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v1 + 48), v2, &padded_bytes);
    if (!result)
    {
      get_padded_bytes(padded_bytes, 8u);
      return 0;
    }
  }
  return result;
}

void *free_conv1d_norm_layer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = result[15];
      if (v3)
      {
        fi_layer_free(*(void *)(v3 + 40));
        fi_layer_free(*(void *)(v3 + 48));
        (*(void (**)(void, uint64_t))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v4 = *(void *)(v2 + 16);
      int v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v5(v4, v1);
    }
  }
  return result;
}

uint64_t create_conv1d_norm_layer(uint64_t *a1, uint64_t a2, uint64_t **a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v7 = 0;
  uint64_t result = 7;
  if (a1 && a2)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
    if (v7)
    {
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 56);
      uint64_t v19 = v15;
      if (!v15)
      {
        uint64_t v27 = *a1;
        uint64_t v28 = "out of memory!";
LABEL_12:
        log_OutText(v27, (uint64_t)"FastInfer", 0, 0, (uint64_t)v28, v16, v17, v18, *(uint64_t *)&v32[0]);
        *(void *)(v7 + 120) = v19;
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"conv1d_norm init param failed!", v29, v30, v31, *(uint64_t *)&v32[0]);
        uint64_t result = 7;
        goto LABEL_13;
      }
      long long v20 = *(_OWORD *)a2;
      long long v21 = *(_OWORD *)(a2 + 16);
      *(_DWORD *)(v15 + 32) = *(_DWORD *)(a2 + 32);
      *(_OWORD *)uint64_t v15 = v20;
      *(_OWORD *)(v15 + 16) = v21;
      uint64_t v35 = 0;
      long long v22 = *(_OWORD *)(a2 + 16);
      v32[0] = *(_OWORD *)a2;
      v32[1] = v22;
      int v33 = 0;
      if (create_conv1d_layer(a1, v32, a3, a4, (uint64_t ***)(v15 + 40)))
      {
        uint64_t v26 = "create conv1d_norm conv1d layer failed!";
LABEL_11:
        log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v23, v24, v25, *(uint64_t *)&v32[0]);
        uint64_t v27 = *a1;
        uint64_t v28 = "conv1d_norm network init failed!";
        goto LABEL_12;
      }
      int v34 = 22;
      if (create_norm_layer(a1, (uint64_t *)&v34, (uint64_t *)(v19 + 48)))
      {
        uint64_t v26 = "create conv1d_norm norm layer failed!";
        goto LABEL_11;
      }
      *(void *)(v7 + 120) = v19;
      if (a3) {
        *(void *)(v7 + 60) = *a3;
      }
      *(void *)uint64_t v7 = a1;
      *(void *)(v7 + 8) = 50;
      *(void *)(v7 + 128) = forward_conv1d_norm_layer;
      *(void *)(v7 + 136) = free_conv1d_norm_layer;
      *(void *)(v7 + 144) = conv1d_norm_layer_update_shape;
      *(void *)(v7 + 152) = conv1d_norm_layer_wanted_wb_len;
      *(void *)(v7 + 160) = conv1d_norm_request_glbBuf;
      *(void *)(v7 + 184) = conv1d_norm_dispatch_weights;
      *(void *)(v7 + 168) = conv1d_norm_assign_glbBuf;
      if (a4)
      {
        uint64_t result = 0;
        *(void *)(v7 + 256) = *(void *)(a4 + 24);
        *(_DWORD *)(v7 + 264) = *(_DWORD *)(a4 + 16);
      }
      else
      {
        log_OutText(*a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"netCfg not given, using default (0)", v23, v24, v25, *(uint64_t *)&v32[0]);
        uint64_t result = 0;
        *(void *)(v7 + 256) = 0;
        *(_DWORD *)(v7 + 264) = 0;
      }
    }
    else
    {
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v12, v13, v14, *(uint64_t *)&v32[0]);
      uint64_t result = 10;
    }
  }
LABEL_13:
  *a5 = v7;
  return result;
}

uint64_t forward_conv1d_norm_layer(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  LODWORD(v21) = 0;
  if (!a2) {
    return 0;
  }
  unsigned int v20 = 0;
  uint64_t v7 = *(uint64_t **)a2;
  uint64_t v8 = *(void *)(a2 + 120);
  uint64_t v9 = *(void **)(a2 + 240);
  uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v8 + 40) + 40), &v21);
  if (!bytes)
  {
    bzero(v9, v21);
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)(v8 + 40) + 128))(a1);
    if (v11)
    {
      uint64_t bytes = v11;
      uint64_t v15 = *v7;
      uint64_t v16 = "conv1d_norm forward conv1d layer failed!";
LABEL_5:
      log_OutText(v15, (uint64_t)"FastInfer", 0, 0, (uint64_t)v16, v12, v13, v14, v19);
      return bytes;
    }
    uint64_t bytes = fi_shape_get_bytes((int *)(*(void *)(v8 + 48) + 40), &v21);
    if (bytes) {
      return bytes;
    }
    bzero(a4, v21);
    uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)(v8 + 48) + 128))(a1);
    if (v18)
    {
      uint64_t bytes = v18;
      uint64_t v15 = *v7;
      uint64_t v16 = "conv1d_norm forward norm layer failed!";
      goto LABEL_5;
    }
    uint64_t bytes = fi_shape_get_size((int *)(a2 + 40), (int *)&v20);
    if (!bytes) {
      fi_activate_array((float *)a4, v20, *(_DWORD *)(v8 + 32));
    }
  }
  return bytes;
}

__n128 conv1d_norm_layer_update_shape(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 120);
  uint64_t v9 = *(uint64_t **)a1;
  int v10 = *(_DWORD *)(a2 + 16);
  *(_OWORD *)(a1 + 20) = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = v10;
  if (*(_DWORD *)a2 >= 3u)
  {
    uint64_t v11 = *v9;
    uint64_t v12 = "Currently conv1d_norm layer only support 1D or 2D input";
LABEL_3:
    log_OutText(v11, (uint64_t)"FastInfer", 0, 0, (uint64_t)v12, a6, a7, a8, v18);
    return result;
  }
  if (!(*(unsigned int (**)(void))(*(void *)(v8 + 40) + 144))()
    && !(*(unsigned int (**)(void))(*(void *)(v8 + 48) + 144))())
  {
    uint64_t v15 = *(void *)(v8 + 48);
    int v17 = *(_DWORD *)(v15 + 40);
    uint64_t v16 = (__n128 *)(v15 + 40);
    if ((v17 - 1) >= 2)
    {
      uint64_t v11 = **(void **)a1;
      uint64_t v12 = "dense out: output shape error";
      goto LABEL_3;
    }
    __n128 result = *v16;
    *(_DWORD *)(a1 + 56) = v16[1].n128_u32[0];
    *(__n128 *)(a1 + 40) = result;
  }
  return result;
}

uint64_t conv1d_norm_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6 = *(void *)(a1 + 120);
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(v6 + 40) + 152))();
  if (!result)
  {
    padded_uint64_t bytes = get_padded_bytes(0, 8u);
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(v6 + 48) + 152))();
    if (!result)
    {
      *a2 = get_padded_bytes(padded_bytes, 8u);
      *a3 = 0;
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wbytes nbytes: %d %d\n", v9, v10, v11, *(unsigned int *)(a1 + 96));
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 4, 0, (uint64_t)"wBytes_wanted=%u, bBytes_wanted=%u, wBytes+bBytes=%u", v12, v13, v14, *a2);
      return 0;
    }
  }
  return result;
}

uint64_t conv1d_norm_request_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120);
  int v6 = 0;
  uint64_t result = fi_shape_get_bytes((int *)(*(void *)(v2 + 40) + 40), &v6);
  if (!result)
  {
    int v4 = v6;
    int v5 = *(uint64_t (**)(void))(*(void *)(v2 + 40) + 160);
    if (v5)
    {
      uint64_t result = v5();
      if (result) {
        return result;
      }
      v4 += *(_DWORD *)(*(void *)(v2 + 40) + 248);
    }
    uint64_t result = 0;
    *(_DWORD *)(a1 + 248) = v4;
  }
  return result;
}

uint64_t conv1d_norm_assign_glbBuf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 120);
  if (v9)
  {
    unsigned int v14 = 0;
    uint64_t result = fi_shape_get_bytes((int *)(*(void *)(v9 + 40) + 40), &v14);
    if (!result)
    {
      uint64_t v11 = *(void *)(v9 + 40);
      *(void *)(v11 + 240) = *(void *)(a1 + 240) + v14;
      uint64_t v12 = *(void (**)(void))(v11 + 168);
      if (v12) {
        v12();
      }
      return 0;
    }
  }
  else
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"config empty", a6, a7, a8, v13);
    return 7;
  }
  return result;
}

void *free_tacodecoder_layer(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = *result;
    if (*result)
    {
      uint64_t v3 = result[15];
      if (v3)
      {
        fi_layer_free(*(void *)(v3 + 88));
        fi_layer_free(*(void *)(v3 + 96));
        fi_layer_free(*(void *)(v3 + 104));
        fi_layer_free(*(void *)(v3 + 120));
        fi_layer_free(*(void *)(v3 + 184));
        if (!*(_DWORD *)(v3 + 28))
        {
          fi_layer_free(*(void *)(v3 + 112));
          if (*(_DWORD *)(v3 + 16))
          {
            fi_layer_free(*(void *)(v3 + 168));
            fi_layer_free(*(void *)(v3 + 176));
          }
          if (*(_DWORD *)(v3 + 20)) {
            fi_layer_free(*(void *)(v3 + 192));
          }
        }
        fi_layer_free(*(void *)(v3 + 128));
        fi_layer_free(*(void *)(v3 + 136));
        fi_layer_free(*(void *)(v3 + 144));
        fi_layer_free(*(void *)(v3 + 152));
        fi_layer_free(*(void *)(v3 + 160));
        (*(void (**)(void, uint64_t))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16), v3);
      }
      if (*((_DWORD *)v1 + 29))
      {
        if (v1[9]) {
          (*(void (**)(void))(*(void *)(v2 + 8) + 48))(*(void *)(v2 + 16));
        }
        *(_OWORD *)(v1 + 11) = 0u;
        *(_OWORD *)(v1 + 13) = 0u;
        *(_OWORD *)(v1 + 9) = 0u;
      }
      uint64_t v4 = *(void *)(v2 + 16);
      int v5 = *(uint64_t (**)(uint64_t, void *))(*(void *)(v2 + 8) + 48);
      return (void *)v5(v4, v1);
    }
  }
  return result;
}

uint64_t create_tacodecoder_layer(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 272);
  if (v11)
  {
    uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1[2], 1, 200);
    uint64_t v16 = v12;
    if (!v12)
    {
      uint64_t v27 = *a1;
      uint64_t v28 = "out of memory!";
LABEL_18:
      log_OutText(v27, (uint64_t)"FastInfer", 0, 0, (uint64_t)v28, v13, v14, v15, *(uint64_t *)v42);
      *(void *)(v11 + 120) = v16;
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Taoctron decoder layer param init failed!", v30, v31, v32, *(uint64_t *)v42);
      uint64_t result = 7;
      goto LABEL_19;
    }
    long long v17 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)uint64_t v12 = *(_OWORD *)a2;
    *(_OWORD *)(v12 + 16) = v17;
    long long v18 = *(_OWORD *)(a2 + 32);
    long long v19 = *(_OWORD *)(a2 + 48);
    long long v20 = *(_OWORD *)(a2 + 64);
    *(void *)(v12 + 80) = *(void *)(a2 + 80);
    *(_OWORD *)(v12 + 48) = v19;
    *(_OWORD *)(v12 + 64) = v20;
    *(_OWORD *)(v12 + 32) = v18;
    uint64_t v43 = 0x100000003;
    memset(v42, 0, sizeof(v42));
    int v21 = *(_DWORD *)(a2 + 48);
    LODWORD(v44) = 5;
    HIDWORD(v44) = v21;
    int v45 = 0;
    if (create_fc_layer(a1, &v44, &v43, 0, a3, (uint64_t *)(v12 + 88)))
    {
      uint64_t v25 = "create tacoDecoder preNet o1 layer failed!";
LABEL_17:
      log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v25, v22, v23, v24, *(uint64_t *)v42);
      uint64_t v27 = *a1;
      uint64_t v28 = "Tacotron decoder layer init failed!";
      goto LABEL_18;
    }
    HIDWORD(v44) = *(_DWORD *)(a2 + 52);
    uint64_t v43 = 0x100000003;
    if (create_fc_layer(a1, &v44, &v43, 0, a3, (uint64_t *)(v16 + 96)))
    {
      uint64_t v25 = "create tacoDecoder preNet o2 layer failed!";
      goto LABEL_17;
    }
    HIDWORD(v44) = *(_DWORD *)(a2 + 64);
    uint64_t v43 = 0x100000000;
    if (create_fc_layer(a1, &v44, &v43, 0, a3, (uint64_t *)(v16 + 128)))
    {
LABEL_16:
      uint64_t v25 = "create tacoDecoder Decoder pre-dense layer failed!";
      goto LABEL_17;
    }
    HIDWORD(v44) = *(_DWORD *)a2 * *(_DWORD *)(a2 + 4);
    int v29 = *(_DWORD *)(a2 + 24);
    if (v29 == 2)
    {
      int v29 = 3;
    }
    else if (v29 != 1)
    {
LABEL_15:
      HIDWORD(v43) = 1;
      if (create_fc_layer(a1, &v44, &v43, 0, a3, (uint64_t *)(v16 + 136))) {
        goto LABEL_16;
      }
      int v33 = *(_DWORD *)(a2 + 56);
      LODWORD(v44) = 23;
      HIDWORD(v44) = v33;
      int v45 = 0;
      *(_DWORD *)uint64_t v42 = *(_DWORD *)(a2 + 84);
      *(void *)&v42[4] = *(void *)(a2 + 68);
      *(void *)&v42[12] = 0x100000001;
      if (create_gru_layer(a1, (uint64_t)&v44, (long long *)v42, 0, a3, (uint64_t ***)(v16 + 144)))
      {
        uint64_t v25 = "create tacodecoder attention-GRU layer failed!";
        goto LABEL_17;
      }
      int v34 = *(_DWORD *)(a2 + 60);
      LODWORD(v44) = 23;
      HIDWORD(v44) = v34;
      *(void *)&v42[4] = *(void *)(a2 + 76);
      if (create_gru_layer(a1, (uint64_t)&v44, (long long *)v42, 0, a3, (uint64_t ***)(v16 + 152)))
      {
        uint64_t v25 = "create tacodecoder deocder-GRU-1 layer failed!";
        goto LABEL_17;
      }
      int v35 = *(_DWORD *)(a2 + 60);
      LODWORD(v44) = 23;
      HIDWORD(v44) = v35;
      *(void *)&v42[4] = *(void *)(a2 + 76);
      if (create_gru_layer(a1, (uint64_t)&v44, (long long *)v42, 0, a3, (uint64_t ***)(v16 + 160)))
      {
        uint64_t v25 = "create tacodecoder deocder-GRU-2 layer failed!";
        goto LABEL_17;
      }
      int v50 = 0;
      uint64_t v48 = 0;
      uint64_t v49 = 0;
      int v47 = 0;
      memset(v46, 0, sizeof(v46));
      int v36 = *(_DWORD *)(a2 + 28);
      if (v36)
      {
        HIDWORD(v49) = 3 * v36;
        int v50 = 0;
        LODWORD(v49) = 5;
        uint64_t v48 = 0x100000000;
        if (!create_fc_layer(a1, &v49, &v48, 0, a3, (uint64_t *)(v16 + 104)))
        {
          HIDWORD(v49) = *(_DWORD *)(a2 + 8);
          int v50 = 0;
          LODWORD(v49) = 5;
          uint64_t v48 = 0x100000002;
          if (create_fc_layer(a1, &v49, &v48, 0, a3, (uint64_t *)(v16 + 120)))
          {
LABEL_29:
            uint64_t v40 = "create tacodecoder Attention query dense layer failed!";
LABEL_32:
            log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v40, v37, v38, v39, *(uint64_t *)v42);
            uint64_t v25 = "init attention network failed!";
            goto LABEL_17;
          }
          *(void *)(v16 + 112) = 0;
          *(void *)(v16 + 192) = 0;
          *(void *)(v16 + 168) = 0;
          *(void *)(v16 + 176) = 0;
LABEL_36:
          uint64_t v43 = 0x100000001;
          uint64_t v44 = 0x100000005;
          uint64_t result = create_fc_layer(a1, &v44, &v43, 0, a3, (uint64_t *)(v16 + 184));
          if (!result)
          {
            *(void *)uint64_t v11 = a1;
            *(void *)(v11 + 8) = 62;
            *(void *)(v11 + 120) = v16;
            *(void *)(v11 + 128) = forward_tacodecoder_layer;
            *(void *)(v11 + 136) = free_tacodecoder_layer;
            *(void *)(v11 + 144) = tacodecoder_layer_update_shape;
            *(void *)(v11 + 152) = tacodecoder_layer_wanted_wb_len;
            *(void *)(v11 + 160) = tacodecoder_request_glbBuf;
            *(void *)(v11 + 256) = *(void *)(a3 + 24);
            *(_DWORD *)(v11 + 264) = *(_DWORD *)(a3 + 16);
            *(void *)(v11 + 176) = tacodecoder_layer_reset;
            *(void *)(v11 + 168) = tacodecoder_assign_glbBuf;
            *(void *)(v11 + 184) = tacodecoder_dispatch_weights;
            *(void *)(v11 + 200) = tacodecoder_layer_load_state;
            *(void *)(v11 + 208) = tacodecoder_layer_save_state;
            *(void *)(v11 + 216) = tacodecoder_layer_sizeof_state;
            goto LABEL_19;
          }
          uint64_t v25 = "create tacoDecoder stop dense layer failed!";
          goto LABEL_17;
        }
      }
      else
      {
        uint64_t v48 = 0x100000000;
        uint64_t v49 = 0x100000005;
        int v50 = 0;
        if (!create_fc_layer(a1, &v49, &v48, 0, a3, (uint64_t *)(v16 + 104)))
        {
          HIDWORD(v49) = *(_DWORD *)(a2 + 8);
          int v50 = 0;
          LODWORD(v49) = 5;
          uint64_t v48 = 0;
          if (create_fc_layer(a1, &v49, &v48, 0, a3, (uint64_t *)(v16 + 112)))
          {
            uint64_t v40 = "create tacodecoder Attention key dense layer failed!";
            goto LABEL_32;
          }
          HIDWORD(v49) = *(_DWORD *)(a2 + 8);
          int v50 = 0;
          LODWORD(v49) = 5;
          uint64_t v48 = 0;
          if (create_fc_layer(a1, &v49, &v48, 0, a3, (uint64_t *)(v16 + 120))) {
            goto LABEL_29;
          }
          if (*(_DWORD *)(a2 + 16))
          {
            int v41 = *(_DWORD *)(a2 + 8);
            LODWORD(v49) = 5;
            HIDWORD(v49) = v41;
            int v50 = 0;
            uint64_t v48 = 0;
            if (create_fc_layer(a1, &v49, &v48, 0, a3, (uint64_t *)(v16 + 176)))
            {
              uint64_t v40 = "create tacodecoder Attention location module dense layer failed!";
              goto LABEL_32;
            }
            if (config_conv1d_layer(*(_DWORD *)(a2 + 32), *(_DWORD *)(a2 + 36), 1, *(_DWORD *)(a2 + 40), 0, 1, 0, v46)|| create_conv1d_layer(a1, v46, 0, a3, (uint64_t ***)(v16 + 168)))
            {
              uint64_t v40 = "create tacodecoder Attention location module conv1d config failed!";
              goto LABEL_32;
            }
          }
          else
          {
            *(void *)(v16 + 168) = 0;
            *(void *)(v16 + 176) = 0;
          }
          if (*(_DWORD *)(a2 + 20))
          {
            int v50 = 0;
            uint64_t v48 = 0x100000001;
            uint64_t v49 = 0x100000005;
            if (create_fc_layer(a1, &v49, &v48, 0, a3, (uint64_t *)(v16 + 192)))
            {
              uint64_t v40 = "create tacodecoder Forward Attention agent dense layer failed!";
              goto LABEL_32;
            }
          }
          goto LABEL_36;
        }
      }
      uint64_t v40 = "create tacodecoder Attention v dense layer failed!";
      goto LABEL_32;
    }
    LODWORD(v43) = v29;
    goto LABEL_15;
  }
  log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"out of memory!", v8, v9, v10, *(uint64_t *)v42);
  uint64_t result = 10;
LABEL_19:
  *a4 = v11;
  return result;
}

uint64_t forward_tacodecoder_layer(uint64_t a1, uint64_t a2, uint64_t a3, char *a4)
{
  long long v103 = 0u;
  long long v102 = 0u;
  long long v101 = 0u;
  long long v100 = 0u;
  long long __dst = 0u;
  long long v98 = 0u;
  long long v97 = 0u;
  *(_OWORD *)uint64_t v96 = 0u;
  long long v95 = 0u;
  long long v94 = 0u;
  long long v93 = 0u;
  long long v92 = 0u;
  long long v91 = 0u;
  uint64_t step = fi_shape_get_step((_DWORD *)(a2 + 20));
  uint64_t v8 = *(unsigned int **)(a2 + 120);
  uint64_t v9 = *(uint64_t **)a2;
  pack_tacodecoder_internal_buffer(a2, &v90);
  uint64_t v90 = a3;
  uint64_t v10 = (void *)v94;
  unsigned int padded_len = get_padded_len(v8[12], 8u);
  bzero(v10, 4 * padded_len);
  if (v8[7] && !v8[5])
  {
    unsigned int v12 = v8[1];
    BOOL v13 = v12 != 0;
    unsigned int v14 = v12 - 1;
    if (v13) {
      unsigned int v15 = v14;
    }
    else {
      unsigned int v15 = 0;
    }
    if (v8[6] == 3) {
      relu_array_f32(*v8, (float *)(*((void *)&v91 + 1) + 4 * *v8 * v15));
    }
  }
  else if (v8[6] == 3)
  {
    relu_array_f32(*v8 * v8[1], *((float **)&v91 + 1));
  }
  uint64_t v19 = (*(uint64_t (**)(void))(*((void *)v8 + 11) + 128))(0);
  if (v19)
  {
    uint64_t v20 = *v9;
    int v21 = "Tacotron decoder PreNet o1 dense forward failed!";
    goto LABEL_35;
  }
  uint64_t v22 = (void *)*((void *)&v94 + 1);
  unsigned int v23 = get_padded_len(v8[13], 8u);
  bzero(v22, 4 * v23);
  uint64_t v24 = (*(uint64_t (**)(void))(*((void *)v8 + 12) + 128))(0);
  if (v24)
  {
    uint64_t v19 = v24;
    uint64_t v20 = *v9;
    int v21 = "Tacotron decoder PreNet o2 dense forward failed!";
    goto LABEL_35;
  }
  uint64_t v25 = v8[7];
  if (!v25)
  {
    if (v9)
    {
      if (*(float *)v91 != 0.0) {
        goto LABEL_28;
      }
      if (v8[5]) {
        *(_DWORD *)long long v101 = 1056964608;
      }
      uint64_t v38 = (void *)*((void *)&v103 + 1);
      unsigned int v39 = get_padded_len(v8[2] * step, 8u);
      bzero(v38, 4 * v39);
      uint64_t v40 = (*(uint64_t (**)(void))(*((void *)v8 + 14) + 128))(0);
      if (!v40)
      {
LABEL_28:
        uint64_t v45 = additive_attention(v9, (void *)v8 + 11, step, v8, (uint64_t)&v90);
        if (v45)
        {
          uint64_t v19 = v45;
          uint64_t v20 = *v9;
          int v21 = "Tacotron Forward Attention Module forward failed!";
          goto LABEL_35;
        }
        uint64_t v31 = (void *)*((void *)&v95 + 1);
        int v29 = (void *)v92;
        goto LABEL_44;
      }
      uint64_t v19 = v40;
      log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Tacotron decoder Key dense forward failed!", v41, v42, v43, __n);
    }
    else
    {
      uint64_t v19 = 7;
    }
    uint64_t v20 = *v9;
    int v21 = "Tacotron decoder first timestep key forward failed!";
    goto LABEL_35;
  }
  float v86 = (float *)*((void *)&v102 + 1);
  float v87 = (void *)v103;
  uint64_t __src = (char *)v102;
  if (*(float *)v91 == 0.0) {
    bzero(*((void **)&v101 + 1), 4 * v25);
  }
  uint64_t v26 = (char *)v95;
  unsigned int v27 = get_padded_len(v8[13], 8u);
  memcpy(v26, v22, 4 * v27);
  uint64_t v28 = &v26[4 * v8[13]];
  int v29 = (void *)v92;
  unsigned int v30 = get_padded_len(v8[3], 8u);
  memcpy(v28, v29, 4 * v30);
  uint64_t v31 = (void *)*((void *)&v95 + 1);
  unsigned int v32 = get_padded_len(v8[14], 8u);
  bzero(v31, 4 * v32);
  uint64_t v33 = (*(uint64_t (**)(void))(*((void *)v8 + 18) + 128))(0);
  if (v33)
  {
    uint64_t v19 = v33;
    uint64_t v37 = "Tacotron attention rnn forward failed!";
LABEL_34:
    log_OutText(*v9, (uint64_t)"FastInfer", 0, 0, (uint64_t)v37, v34, v35, v36, __n);
    uint64_t v20 = *v9;
    int v21 = "Tacotron GMM Attention Module forward failed!";
    goto LABEL_35;
  }
  bzero(v96[1], 4 * v8[2]);
  uint64_t v44 = (*(uint64_t (**)(void))(*((void *)v8 + 15) + 128))(0);
  if (v44)
  {
    uint64_t v19 = v44;
    uint64_t v37 = "Tacotron decoder query dense forward failed!";
    goto LABEL_34;
  }
  unsigned int v46 = get_padded_len(3 * v8[7], 8u);
  bzero(__src, 4 * v46);
  uint64_t v47 = (*(uint64_t (**)(void))(*((void *)v8 + 13) + 128))(0);
  if (v47)
  {
    uint64_t v19 = v47;
    uint64_t v37 = "Tacotron attention vec_v dense forward failed!";
    goto LABEL_34;
  }
  if (v25 == get_padded_len(v25, 8u))
  {
    int v50 = v87;
    uint64_t v49 = (float *)__src;
  }
  else
  {
    int v51 = get_padded_len(v8[7], 8u);
    uint64_t v49 = v86;
    bzero(v86, 4 * (3 * v51));
    size_t __n = 4 * v25;
    memcpy(v86, __src, 4 * v25);
    int v52 = get_padded_len(v25, 8u);
    memcpy(&v86[v52], &__src[4 * v25], 4 * v25);
    int v53 = get_padded_len(v25, 8u);
    memcpy(&v86[2 * v53], &__src[4 * (2 * v25)], 4 * v25);
    int v50 = v87;
  }
  fi_activate_array(v49, v25, 9);
  int v54 = get_padded_len(v25, 8u);
  fi_activate_array(&v49[v54], v25, 8);
  int v55 = get_padded_len(v25, 8u);
  fi_activate_array(&v49[2 * v55], v25, 8);
  int v56 = get_padded_len(v25, 8u);
  int __srca = (void *)*((void *)&v101 + 1);
  axpy(v25, &v49[v56], 1, *((float **)&v101 + 1), 1, 1.0);
  unsigned int v57 = get_padded_len(step, 8u);
  bzero(v50, 4 * v57);
  int v58 = get_padded_len(v25, 8u);
  gmm_c(step, v25, (uint64_t)v49, (uint64_t)__srca, (uint64_t)&v49[2 * v58], (uint64_t)v50);
  unsigned int v59 = get_padded_len(v8[3], 8u);
  bzero(v29, 4 * v59);
  if (step)
  {
    uint64_t v60 = 0;
    do
    {
      axpy(v8[3], (float *)(a3 + 4 * v8[3] * v60), 1, (float *)v29, 1, *((float *)v50 + v60));
      ++v60;
    }
    while (step != v60);
  }
LABEL_44:
  float v61 = (char *)v97;
  unsigned int v62 = get_padded_len(v8[14], 8u);
  memcpy(v61, v31, 4 * v62);
  uint64_t v63 = &v61[4 * v8[14]];
  unsigned int v64 = get_padded_len(v8[3], 8u);
  memcpy(v63, v29, 4 * v64);
  float v65 = (void *)*((void *)&v98 + 1);
  unsigned int v66 = get_padded_len(v8[16], 8u);
  bzero(v65, 4 * v66);
  uint64_t v67 = (*(uint64_t (**)(void))(*((void *)v8 + 16) + 128))(0);
  if (v67)
  {
    uint64_t v19 = v67;
    uint64_t v20 = *v9;
    int v21 = "Tacotron decoder pre dense forward failed!";
  }
  else
  {
    int v68 = (void *)*((void *)&v97 + 1);
    unsigned int v69 = get_padded_len(v8[15], 8u);
    bzero(v68, 4 * v69);
    uint64_t v70 = (*(uint64_t (**)(void))(*((void *)v8 + 19) + 128))(0);
    if (v70)
    {
      uint64_t v19 = v70;
      uint64_t v20 = *v9;
      int v21 = "Tacotron decoder rnn1 forward failed!";
    }
    else
    {
      uint64_t v71 = get_padded_len(v8[15], 8u);
      axpy(v71, (float *)v68, 1, (float *)v65, 1, 1.0);
      int v72 = (void *)v98;
      unsigned int v73 = get_padded_len(v8[15], 8u);
      bzero(v72, 4 * v73);
      uint64_t v74 = (*(uint64_t (**)(void))(*((void *)v8 + 20) + 128))(0);
      if (v74)
      {
        uint64_t v19 = v74;
        uint64_t v20 = *v9;
        int v21 = "Tacotron decoder rnn2 forward failed!";
      }
      else
      {
        uint64_t v75 = get_padded_len(v8[15], 8u);
        axpy(v75, (float *)v72, 1, (float *)v65, 1, 1.0);
        unsigned int v76 = (void *)*((void *)&v91 + 1);
        unsigned int v77 = get_padded_len(*v8 * v8[1], 8u);
        bzero(v76, 4 * v77);
        uint64_t v78 = (*(uint64_t (**)(void))(*((void *)v8 + 17) + 128))(0);
        if (v78)
        {
          uint64_t v19 = v78;
          uint64_t v20 = *v9;
          int v21 = "Tacotron decoder post dense forward failed!";
        }
        else
        {
          uint64_t v79 = __dst;
          memcpy((void *)__dst, v65, 4 * v8[16]);
          unsigned int v80 = get_padded_len(v8[16], 8u);
          memcpy((void *)(v79 + 4 * v80), v76, 4 * v8[1] * *v8);
          float v81 = (void *)v91;
          unsigned int v82 = get_padded_len(1, 8u);
          bzero(v81, 4 * v82);
          uint64_t v19 = (*(uint64_t (**)(void))(*((void *)v8 + 23) + 128))(0);
          if (!v19)
          {
            unsigned int v83 = get_padded_len(1, 8u);
            memcpy(a4, v81, 4 * v83);
            int v84 = get_padded_len(1, 8u);
            memcpy(&a4[4 * v84], v76, 4 * v8[1] * *v8);
            return v19;
          }
          uint64_t v20 = *v9;
          int v21 = "Tacotron stop dense forward failed!";
        }
      }
    }
  }
LABEL_35:
  log_OutText(v20, (uint64_t)"FastInfer", 0, 0, (uint64_t)v21, v16, v17, v18, __n);
  return v19;
}

uint64_t tacodecoder_layer_update_shape(uint64_t a1, _DWORD *a2)
{
  uint64_t v90 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(void *)(a1 + 120);
  uint64_t v86 = 0;
  v79[0] = 0;
  v79[1] = 0;
  int v80 = 0;
  v77[0] = 0;
  v77[1] = 0;
  int v78 = 0;
  long long v5 = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 36) = a2[4];
  *(_OWORD *)(a1 + 20) = v5;
  int v85 = 1;
  if (*(_DWORD *)(v4 + 28) && !*(_DWORD *)(v4 + 20)) {
    int v6 = *(_DWORD *)v4;
  }
  else {
    int v6 = *(_DWORD *)v4 * *(_DWORD *)(v4 + 4);
  }
  LODWORD(v86) = v6;
  uint64_t result = fi_shape_set(2, (uint64_t)&v85, 4, (uint64_t)v77);
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(void, void *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 88)
                                                                                             + 144))(*(void *)(v4 + 88), v77, v8, v9, v10, v11);
    if (!result)
    {
      uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 96)
                                                                                              + 144))(*(void *)(v4 + 96), *(void *)(v4 + 88) + 40, v12, v13, v14, v15);
      if (!result)
      {
        uint64_t v16 = *(void *)(a1 + 120);
        int v89 = 0;
        v83[0] = 0;
        v83[1] = 0;
        int v84 = 0;
        v81[0] = 0;
        v81[1] = 0;
        int v82 = 0;
        int step = fi_shape_get_step(a2);
        int v18 = *(_DWORD *)(v16 + 12) + *(_DWORD *)(v16 + 52);
        int v87 = 1;
        int v88 = v18;
        uint64_t result = fi_shape_set(2, (uint64_t)&v87, 4, (uint64_t)v83);
        if (!result)
        {
          uint64_t result = (*(uint64_t (**)(void, void *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v16 + 144) + 144))(*(void *)(v16 + 144), v83, v19, v20, v21, v22);
          if (!result)
          {
            uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v16 + 120) + 144))(*(void *)(v16 + 120), *(void *)(v16 + 144) + 40, v23, v24, v25, v26);
            if (!result)
            {
              if (*(_DWORD *)(v16 + 28))
              {
                uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v16 + 104) + 144))(*(void *)(v16 + 104), *(void *)(v16 + 120) + 40, v27, v28, v29, v30);
                if (result) {
                  return result;
                }
              }
              else
              {
                int v55 = *(_DWORD *)(v16 + 12);
                int v87 = step;
                int v88 = v55;
                uint64_t result = fi_shape_set(2, (uint64_t)&v87, 4, (uint64_t)v83);
                if (result) {
                  return result;
                }
                uint64_t result = (*(uint64_t (**)(void, void *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v16 + 112) + 144))(*(void *)(v16 + 112), v83, v56, v57, v58, v59);
                if (result) {
                  return result;
                }
                uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v16 + 104) + 144))(*(void *)(v16 + 104), *(void *)(v16 + 112) + 40, v60, v61, v62, v63);
                if (result) {
                  return result;
                }
              }
              if (*(_DWORD *)(v16 + 28)) {
                goto LABEL_15;
              }
              if (!*(_DWORD *)(v16 + 16)
                || (v87 = step, v88 = 2, uint64_t result = fi_shape_set(2, (uint64_t)&v87, 4, (uint64_t)v81), !result)
                && (uint64_t result = (*(uint64_t (**)(void, void *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v16 + 168) + 144))(*(void *)(v16 + 168), v81, v64, v65, v66, v67), !result)&& (uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v16 + 176) + 144))(*(void *)(v16 + 176), *(void *)(v16 + 168) + 40, v68, v69, v70, v71), !result))
              {
                if (!*(_DWORD *)(v16 + 20)
                  || (int v72 = *(_DWORD *)(v16 + 56) + *(_DWORD *)(v16 + 12),
                      int v87 = 1,
                      int v88 = v72,
                      uint64_t result = fi_shape_set(2, (uint64_t)&v87, 4, (uint64_t)v83),
                      !result)
                  && (uint64_t result = (*(uint64_t (**)(void, void *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v16 + 192) + 144))(*(void *)(v16 + 192), v83, v73, v74, v75, v76), !result))
                {
LABEL_15:
                  int v31 = *(_DWORD *)(v4 + 12) + *(_DWORD *)(v4 + 56);
                  int v85 = 1;
                  LODWORD(v86) = v31;
                  uint64_t result = fi_shape_set(2, (uint64_t)&v85, 4, (uint64_t)v79);
                  if (!result)
                  {
                    (*(void (**)(void, void *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 128)
                                                                                                 + 144))(*(void *)(v4 + 128), v79, v32, v33, v34, v35);
                    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 152) + 144))(*(void *)(v4 + 152), *(void *)(v4 + 128) + 40, v36, v37, v38, v39);
                    if (!result)
                    {
                      uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 160) + 144))(*(void *)(v4 + 160), *(void *)(v4 + 128) + 40, v40, v41, v42, v43);
                      if (!result)
                      {
                        uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 136) + 144))(*(void *)(v4 + 136), *(void *)(v4 + 160) + 40, v44, v45, v46, v47);
                        if (!result)
                        {
                          int v85 = 1;
                          LODWORD(v86) = *(_DWORD *)(v4 + 60) + *(_DWORD *)v4 * *(_DWORD *)(v4 + 4);
                          uint64_t result = fi_shape_set(2, (uint64_t)&v85, 4, (uint64_t)v79);
                          if (!result)
                          {
                            uint64_t result = (*(uint64_t (**)(void, void *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(v4 + 184) + 144))(*(void *)(v4 + 184), v79, v48, v49, v50, v51);
                            if (!result)
                            {
                              int v85 = 1;
                              uint64_t v54 = v4;
                              int v53 = *(_DWORD *)v4;
                              int v52 = *(_DWORD *)(v54 + 4);
                              LODWORD(v86) = get_padded_len(1, 8u) + v53 * v52;
                              return fi_shape_set(2, (uint64_t)&v85, 4, a1 + 40);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t tacodecoder_layer_wanted_wb_len(uint64_t a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v27 = 0;
  uint64_t v8 = *(void *)(a1 + 120);
  if (!v8)
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Null pointer input!", a6, a7, a8, v26);
    return 7;
  }
  padded_uint64_t bytes = get_padded_bytes(4 * *(_DWORD *)v8 * *(_DWORD *)(v8 + 4), 8u);
  int v12 = get_padded_bytes(padded_bytes + 4 * *(_DWORD *)(v8 + 56), 8u);
  int v28 = 8 * *(_DWORD *)(v8 + 60);
  int v13 = get_padded_bytes(v12 + v28, 8u);
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 88) + 152))();
  if (!result)
  {
    int v15 = get_padded_bytes(v28 + v27 + v13, 8u);
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 96) + 152))();
    if (!result)
    {
      int v16 = get_padded_bytes(v28 + v27 + v15, 8u);
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 104) + 152))();
      if (!result)
      {
        int v17 = get_padded_bytes(v28 + v27 + v16, 8u);
        uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 120) + 152))();
        if (!result)
        {
          int v18 = get_padded_bytes(v28 + v27 + v17, 8u);
          uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 128) + 152))();
          if (!result)
          {
            int v19 = get_padded_bytes(v28 + v27 + v18, 8u);
            uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 136) + 152))();
            if (!result)
            {
              int v20 = get_padded_bytes(v28 + v27 + v19, 8u);
              uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 144) + 152))();
              if (!result)
              {
                int v21 = get_padded_bytes(v28 + v27 + v20, 8u);
                uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 152) + 152))();
                if (!result)
                {
                  int v22 = get_padded_bytes(v28 + v27 + v21, 8u);
                  uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 160) + 152))();
                  if (!result)
                  {
                    int v23 = get_padded_bytes(v28 + v27 + v22, 8u);
                    uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 184) + 152))();
                    if (!result)
                    {
                      int v24 = get_padded_bytes(v28 + v27 + v23, 8u);
                      if (*(_DWORD *)(v8 + 28))
                      {
LABEL_13:
                        uint64_t result = 0;
                        *a2 = v24;
                        *a3 = 0;
                        return result;
                      }
                      uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 112) + 152))();
                      if (!result)
                      {
                        int v24 = get_padded_bytes(v28 + v27 + v24, 8u);
                        if (*(_DWORD *)(v8 + 16))
                        {
                          uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 168) + 152))();
                          if (result) {
                            return result;
                          }
                          int v25 = get_padded_bytes(v28 + v27 + v24, 8u);
                          uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 176) + 152))();
                          if (result) {
                            return result;
                          }
                          int v24 = get_padded_bytes(v28 + v27 + v25, 8u);
                        }
                        if (!*(_DWORD *)(v8 + 20)) {
                          goto LABEL_13;
                        }
                        uint64_t result = (*(uint64_t (**)(void))(*(void *)(v8 + 192) + 152))();
                        if (!result)
                        {
                          int v24 = get_padded_bytes(v28 + v24 + v27, 8u);
                          goto LABEL_13;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t tacodecoder_request_glbBuf(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120);
  uint64_t v4 = *(void *)(v2 + 144);
  uint64_t v3 = *(void *)(v2 + 152);
  uint64_t v5 = *(void *)(v2 + 160);
  uint64_t step = fi_shape_get_step((_DWORD *)(a1 + 20));
  int padded_len = get_padded_len(1, 8u);
  int v8 = get_padded_len((*(_DWORD *)v2 * *(_DWORD *)(v2 + 4)), 8u);
  int v9 = padded_len + get_padded_len(*(unsigned int *)(v2 + 12), 8u);
  int v10 = v9 + get_padded_len(*(unsigned int *)(v2 + 48), 8u);
  int v11 = v10 + get_padded_len(*(unsigned int *)(v2 + 52), 8u);
  int v12 = v8 + v11 + get_padded_len((*(_DWORD *)(v2 + 52) + *(_DWORD *)(v2 + 12)), 8u);
  int v13 = v12 + get_padded_len(*(unsigned int *)(v2 + 56), 8u);
  uint64_t v14 = *(unsigned int *)(v2 + 28);
  if (v14)
  {
    int v15 = get_padded_len(v14, 8u);
    int v16 = v15 + get_padded_len((3 * *(_DWORD *)(v2 + 28)), 8u);
    int v17 = v16 + 3 * get_padded_len(*(unsigned int *)(v2 + 28), 8u) + v13;
    uint64_t v18 = step;
  }
  else
  {
    int v19 = get_padded_len((*(_DWORD *)(v2 + 8) * step), 8u);
    int v20 = v19 + get_padded_len(step, 8u);
    int v17 = v20 + get_padded_len(step, 8u) + v13;
    uint64_t v18 = (2 * step);
  }
  int v21 = get_padded_len(v18, 8u);
  int v22 = get_padded_len(*(unsigned int *)(v2 + 8), 8u) + v21;
  int v23 = v17 + get_padded_len((*(_DWORD *)(v2 + 12) + *(_DWORD *)(v2 + 56)), 8u);
  int v24 = v22 + get_padded_len(*(unsigned int *)(v2 + 64), 8u);
  int v25 = v24 + get_padded_len(*(unsigned int *)(v2 + 60), 8u);
  int v26 = v25 + get_padded_len(*(unsigned int *)(v2 + 60), 8u);
  *(_DWORD *)(a1 + 248) = 4
                        * (v26
                         + get_padded_len((*(_DWORD *)(v2 + 60) + *(_DWORD *)v2 * *(_DWORD *)(v2 + 4)), 8u)+ v23);
  int v27 = *(uint64_t (**)(uint64_t))(v4 + 160);
  if (!v27 || (uint64_t result = v27(v4), !result))
  {
    uint64_t v29 = *(uint64_t (**)(uint64_t))(v3 + 160);
    if (!v29 || (uint64_t result = v29(v3), !result))
    {
      uint64_t v30 = *(uint64_t (**)(uint64_t))(v5 + 160);
      if (!v30 || (uint64_t result = v30(v5), !result))
      {
        int v31 = *(_DWORD *)(a1 + 248);
        int v32 = get_padded_bytes(*(_DWORD *)(v4 + 248), 8u) + v31;
        padded_uint64_t bytes = get_padded_bytes(*(_DWORD *)(v3 + 248), 8u);
        *(_DWORD *)(a1 + 248) = v32 + padded_bytes + get_padded_bytes(*(_DWORD *)(v5 + 248), 8u);
        if (*(_DWORD *)(v2 + 28)) {
          return 0;
        }
        if (*(_DWORD *)(v2 + 16)) {
          get_padded_len((*(_DWORD *)(v2 + 32) * step), 8u);
        }
        if (*(_DWORD *)(v2 + 20))
        {
          get_padded_len(step, 8u);
          get_padded_len((*(_DWORD *)(v2 + 56) + *(_DWORD *)(v2 + 12)), 8u);
          get_padded_len(1, 8u);
        }
        if (*(_DWORD *)(v2 + 16))
        {
          uint64_t v34 = *(uint64_t (**)(void))(*(void *)(v2 + 168) + 160);
          if (!v34) {
            goto LABEL_20;
          }
          uint64_t result = v34();
          if (result) {
            return result;
          }
          if (*(_DWORD *)(v2 + 16)) {
LABEL_20:
          }
            *(_DWORD *)(a1 + 248) += get_padded_bytes(*(_DWORD *)(*(void *)(v2 + 168) + 248), 8u);
        }
        int v35 = get_padded_len((*(_DWORD *)(v2 + 8) * step), 8u);
        uint64_t result = 0;
        *(_DWORD *)(a1 + 248) += v35;
      }
    }
  }
  return result;
}

uint64_t tacodecoder_layer_reset(uint64_t a1)
{
  uint64_t v40 = 0;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  *(_OWORD *)long long __dst = 0u;
  long long v29 = 0u;
  long long v27 = 0u;
  pack_tacodecoder_internal_buffer(a1, &v27);
  uint64_t v2 = *(void *)(a1 + 120);
  uint64_t step = fi_shape_get_step((_DWORD *)(a1 + 20));
  uint64_t v4 = *(void *)(v2 + 144);
  if (!v4 || (uint64_t v5 = *(uint64_t (**)(void))(v4 + 176)) == 0 || (result = v5(), !result))
  {
    uint64_t v7 = *(void *)(v2 + 152);
    if (!v7 || (int v8 = *(uint64_t (**)(void))(v7 + 176)) == 0 || (result = v8(), !result))
    {
      uint64_t v9 = *(void *)(v2 + 160);
      if (!v9 || (int v10 = *(uint64_t (**)(void))(v9 + 176)) == 0 || (result = v10(), !result))
      {
        int v11 = *(const void **)(a1 + 72);
        if (v11)
        {
          int v12 = *(_DWORD *)(v2 + 4) * *(_DWORD *)v2;
          memcpy(__dst[0], v11, (4 * v12));
          memcpy(**(void ***)(*(void *)(v2 + 144) + 120), (const void *)(*(void *)(a1 + 72) + (4 * v12)), 4 * *(unsigned int *)(v2 + 56));
          int v13 = *(_DWORD *)(v2 + 56) + v12;
          memcpy(**(void ***)(*(void *)(v2 + 152) + 120), (const void *)(*(void *)(a1 + 72) + (4 * v13)), 4 * *(unsigned int *)(v2 + 60));
          memcpy(**(void ***)(*(void *)(v2 + 160) + 120), (const void *)(*(void *)(a1 + 72) + (4 * *(_DWORD *)(v2 + 60) + 4 * v13)), 4 * *(unsigned int *)(v2 + 60));
          uint64_t v14 = __dst[1];
          unsigned int padded_len = get_padded_len(*(unsigned int *)(v2 + 12), 8u);
          bzero(v14, 4 * padded_len);
          int v16 = (void *)*((void *)&v27 + 1);
          unsigned int v17 = get_padded_len(1, 8u);
          bzero(v16, 4 * v17);
          uint64_t v18 = *(unsigned int *)(v2 + 28);
          if (v18)
          {
            int v19 = (void *)v38;
            unsigned int v20 = get_padded_len(v18, 8u);
            bzero(v19, 4 * v20);
          }
          else
          {
            int v21 = (void *)v29;
            unsigned int v22 = get_padded_len(step, 8u);
            bzero(v21, 4 * v22);
            int v23 = (void *)*((void *)&v29 + 1);
            unsigned int v24 = get_padded_len(step, 8u);
            bzero(v23, 4 * v24);
            if (*(_DWORD *)(v2 + 20))
            {
              int v25 = (_DWORD *)*((void *)&v36 + 1);
              unsigned int v26 = get_padded_len(step, 8u);
              bzero(v25, 4 * v26);
              if (step < 2)
              {
                if (!step) {
                  return 0;
                }
              }
              else
              {
                memset_pattern16(v25 + 1, &unk_20D6B4220, 4 * (step - 2) + 4);
              }
              uint64_t result = 0;
              *int v25 = 1065353216;
              return result;
            }
          }
        }
        return 0;
      }
    }
  }
  return result;
}

uint64_t tacodecoder_assign_glbBuf()
{
  return 0;
}

uint64_t tacodecoder_dispatch_weights(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 120);
  if (!v9)
  {
    log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"param empty", a6, a7, a8, v17);
    return 7;
  }
  uint64_t v10 = *(void *)(a1 + 72);
  padded_uint64_t bytes = get_padded_bytes(4 * *(_DWORD *)v9 * *(_DWORD *)(v9 + 4), 8u);
  int v12 = get_padded_bytes(padded_bytes + 4 * *(_DWORD *)(v9 + 56), 8u);
  unsigned int v18 = get_padded_bytes(v12 + 8 * *(_DWORD *)(v9 + 60), 8u);
  uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v9 + 88), v10, &v18);
  if (!result)
  {
    unsigned int v18 = get_padded_bytes(v18, 8u);
    uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v9 + 96), v10, &v18);
    if (!result)
    {
      unsigned int v18 = get_padded_bytes(v18, 8u);
      unsigned int v19 = v18;
      uint64_t v14 = *(void *)(a1 + 120);
      uint64_t v15 = *(void *)(a1 + 72);
      if (*(_DWORD *)(v14 + 28))
      {
        uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v14 + 104), v15, &v19);
        if (result) {
          return result;
        }
        unsigned int v19 = get_padded_bytes(v19, 8u);
        uint64_t v16 = *(void *)(v14 + 120);
      }
      else
      {
        uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v14 + 112), v15, &v19);
        if (result) {
          return result;
        }
        unsigned int v19 = get_padded_bytes(v19, 8u);
        uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v14 + 104), v15, &v19);
        if (result) {
          return result;
        }
        unsigned int v19 = get_padded_bytes(v19, 8u);
        if (*(_DWORD *)(v14 + 16))
        {
          uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v14 + 168), v15, &v19);
          if (result) {
            return result;
          }
          unsigned int v19 = get_padded_bytes(v19, 8u);
          uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v14 + 176), v15, &v19);
          if (result) {
            return result;
          }
          unsigned int v19 = get_padded_bytes(v19, 8u);
        }
        uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v14 + 120), v15, &v19);
        if (result) {
          return result;
        }
        unsigned int v19 = get_padded_bytes(v19, 8u);
        if (!*(_DWORD *)(v14 + 20)) {
          goto LABEL_9;
        }
        uint64_t v16 = *(void *)(v14 + 192);
      }
      uint64_t result = fi_layer_find_weights_via_offset(v16, v15, &v19);
      if (result) {
        return result;
      }
      unsigned int v19 = get_padded_bytes(v19, 8u);
LABEL_9:
      uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v14 + 144), v15, &v19);
      if (!result)
      {
        unsigned int v18 = get_padded_bytes(v19, 8u);
        unsigned int v18 = get_padded_bytes(v18, 8u);
        uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v9 + 128), v10, &v18);
        if (!result)
        {
          unsigned int v18 = get_padded_bytes(v18, 8u);
          uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v9 + 136), v10, &v18);
          if (!result)
          {
            unsigned int v18 = get_padded_bytes(v18, 8u);
            uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v9 + 152), v10, &v18);
            if (!result)
            {
              unsigned int v18 = get_padded_bytes(v18, 8u);
              uint64_t result = fi_layer_find_weights_via_offset(*(void *)(v9 + 160), v10, &v18);
              if (!result)
              {
                unsigned int v18 = get_padded_bytes(v18, 8u);
                return fi_layer_find_weights_via_offset(*(void *)(v9 + 184), v10, &v18);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t tacodecoder_layer_load_state(uint64_t a1, float *a2)
{
  uint64_t v4 = *(uint64_t **)a1;
  uint64_t v45 = 0;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v40 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  *(_OWORD *)long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  *(_OWORD *)long long __dst = 0u;
  int v31 = 0;
  pack_tacodecoder_internal_buffer(a1, &v32);
  uint64_t v5 = *(void *)(a1 + 120);
  uint64_t step = fi_shape_get_step((_DWORD *)(a1 + 20));
  if (!a2) {
    return 0;
  }
  uint64_t v10 = step;
  if (step != (float)(*a2 + 0.00001))
  {
    uint64_t v25 = *v4;
    unsigned int v26 = "input step mismatch with stored value!";
LABEL_8:
    log_OutText(v25, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v7, v8, v9, v30);
    return 7;
  }
  tacodecoder_layer_sizeof_state(a1, &v31);
  if (v31 != (float)(a2[1] + 0.00001))
  {
    uint64_t v25 = *v4;
    unsigned int v26 = "state size mismatch with stored value!";
    goto LABEL_8;
  }
  int v11 = &a2[get_padded_len(2, 8u)];
  uint64_t v12 = (*(_DWORD *)(v5 + 4) * *(_DWORD *)v5);
  memcpy(__dst[0], v11, 4 * v12);
  int v13 = &v11[get_padded_len(v12, 8u)];
  uint64_t v14 = *(unsigned int *)(v5 + 56);
  memcpy(**(void ***)(*(void *)(v5 + 144) + 120), v13, 4 * v14);
  uint64_t v15 = (char *)&v13[get_padded_len(v14, 8u)];
  uint64_t v16 = *(unsigned int *)(v5 + 60);
  memcpy(**(void ***)(*(void *)(v5 + 152) + 120), v15, 4 * v16);
  uint64_t v17 = &v15[4 * get_padded_len(v16, 8u)];
  uint64_t v18 = *(unsigned int *)(v5 + 60);
  memcpy(**(void ***)(*(void *)(v5 + 160) + 120), v17, 4 * v18);
  unsigned int v19 = &v17[4 * get_padded_len(v18, 8u)];
  uint64_t v20 = *(unsigned int *)(v5 + 12);
  memcpy(__dst[1], v19, 4 * v20);
  int v21 = &v19[4 * get_padded_len(v20, 8u)];
  **((_DWORD **)&v32 + 1) = *(_DWORD *)v21;
  unsigned int v22 = &v21[4 * get_padded_len(1, 8u)];
  uint64_t v23 = *(unsigned int *)(v5 + 28);
  if (v23)
  {
    memcpy((void *)v43, v22, 4 * v23);
    uint64_t v24 = v23;
LABEL_11:
    get_padded_len(v24, 8u);
    return 0;
  }
  memcpy(v34[0], v22, 4 * v10);
  int v28 = &v22[4 * get_padded_len(v10, 8u)];
  memcpy(v34[1], v28, 4 * v10);
  int padded_len = get_padded_len(v10, 8u);
  if (*(_DWORD *)(v5 + 20))
  {
    memcpy(*((void **)&v41 + 1), &v28[4 * padded_len], 4 * v10);
    uint64_t v24 = v10;
    goto LABEL_11;
  }
  return 0;
}

uint64_t tacodecoder_layer_save_state(uint64_t a1, float *a2)
{
  uint64_t v37 = 0;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v32 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  *(_OWORD *)unsigned int v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  *(_OWORD *)uint64_t __src = 0u;
  unsigned int v23 = 0;
  pack_tacodecoder_internal_buffer(a1, &v24);
  uint64_t v4 = *(void *)(a1 + 120);
  uint64_t step = fi_shape_get_step((_DWORD *)(a1 + 20));
  if (a2)
  {
    uint64_t v6 = step;
    *a2 = (float)step;
    tacodecoder_layer_sizeof_state(a1, &v23);
    a2[1] = (float)v23;
    uint64_t v7 = &a2[get_padded_len(2, 8u)];
    uint64_t v8 = (*(_DWORD *)(v4 + 4) * *(_DWORD *)v4);
    memcpy(v7, __src[0], 4 * v8);
    uint64_t v9 = &v7[get_padded_len(v8, 8u)];
    uint64_t v10 = *(unsigned int *)(v4 + 56);
    memcpy(v9, **(const void ***)(*(void *)(v4 + 144) + 120), 4 * v10);
    int v11 = (char *)&v9[get_padded_len(v10, 8u)];
    uint64_t v12 = *(unsigned int *)(v4 + 60);
    memcpy(v11, **(const void ***)(*(void *)(v4 + 152) + 120), 4 * v12);
    int v13 = &v11[4 * get_padded_len(v12, 8u)];
    uint64_t v14 = *(unsigned int *)(v4 + 60);
    memcpy(v13, **(const void ***)(*(void *)(v4 + 160) + 120), 4 * v14);
    uint64_t v15 = &v13[4 * get_padded_len(v14, 8u)];
    uint64_t v16 = *(unsigned int *)(v4 + 12);
    memcpy(v15, __src[1], 4 * v16);
    uint64_t v17 = &v15[4 * get_padded_len(v16, 8u)];
    *(_DWORD *)uint64_t v17 = **((_DWORD **)&v24 + 1);
    uint64_t v18 = &v17[4 * get_padded_len(1, 8u)];
    uint64_t v19 = *(unsigned int *)(v4 + 28);
    if (v19)
    {
      memcpy(v18, (const void *)v35, 4 * v19);
      uint64_t v6 = v19;
LABEL_6:
      get_padded_len(v6, 8u);
      return 0;
    }
    memcpy(v18, v26[0], 4 * v6);
    uint64_t v20 = &v18[4 * get_padded_len(v6, 8u)];
    memcpy(v20, v26[1], 4 * v6);
    int padded_len = get_padded_len(v6, 8u);
    if (*(_DWORD *)(v4 + 20))
    {
      memcpy(&v20[4 * padded_len], *((const void **)&v33 + 1), 4 * v6);
      goto LABEL_6;
    }
  }
  return 0;
}

uint64_t tacodecoder_layer_sizeof_state(uint64_t a1, _DWORD *a2)
{
  pack_tacodecoder_internal_buffer(a1, v17);
  uint64_t v4 = *(_DWORD **)(a1 + 120);
  uint64_t step = fi_shape_get_step((_DWORD *)(a1 + 20));
  int padded_len = get_padded_len(2, 8u);
  int v7 = get_padded_len((v4[1] * *v4), 8u);
  int v8 = padded_len + get_padded_len(v4[14], 8u);
  int v9 = v8 + get_padded_len(v4[15], 8u);
  int v10 = v9 + get_padded_len(v4[15], 8u);
  int v11 = v7 + v10 + get_padded_len(v4[3], 8u);
  int v12 = v11 + get_padded_len(1, 8u);
  uint64_t v13 = v4[7];
  if (v13)
  {
    int v14 = get_padded_len(v13, 8u);
  }
  else
  {
    int v15 = get_padded_len(step, 8u);
    int v14 = v15 + get_padded_len(step, 8u) + v12;
    int v12 = get_padded_len(step, 8u);
  }
  *a2 = v14 + v12;
  return 0;
}

float get_last_alignment(uint64_t a1, float *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v17 = 0;
  float result = 0.0;
  long long v16 = 0u;
  memset(v15, 0, sizeof(v15));
  memset(v14, 0, sizeof(v14));
  if (a1)
  {
    if (*(void *)(a1 + 240))
    {
      pack_tacodecoder_internal_buffer(a1, v14);
      uint64_t v11 = *(void *)(a1 + 120);
      if (*(_DWORD *)(v11 + 28))
      {
        uint64_t v12 = *((void *)&v16 + 1);
      }
      else
      {
        if (*(_DWORD *)(v11 + 20)) {
          uint64_t v13 = (uint64_t *)&v15[7] + 1;
        }
        else {
          uint64_t v13 = (uint64_t *)v15;
        }
        uint64_t v12 = *v13;
      }
      float result = *(float *)(v12 + 4 * (*(_DWORD *)(a1 + 24) - 1));
      *a2 = result;
    }
    else
    {
      log_OutText(**(void **)a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Tacotron stop dense forward failed!", a6, a7, a8, *(uint64_t *)&v14[0]);
    }
  }
  return result;
}

uint64_t pack_tacodecoder_internal_buffer(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 120);
  uint64_t v4 = *(void *)(a1 + 240);
  uint64_t v6 = *(void *)(v3 + 144);
  uint64_t v5 = *(void *)(v3 + 152);
  uint64_t v7 = *(void *)(v3 + 160);
  uint64_t step = fi_shape_get_step((_DWORD *)(a1 + 20));
  *a2 = 0;
  a2[1] = v4;
  int padded_len = get_padded_len(1, 8u);
  a2[2] = v4 + (4 * padded_len);
  int v10 = get_padded_len((*(_DWORD *)v3 * *(_DWORD *)(v3 + 4)), 8u) + padded_len;
  a2[3] = v4 + (4 * v10);
  int v11 = get_padded_len(*(unsigned int *)(v3 + 12), 8u) + v10;
  LODWORD(v12) = 4 * v11;
  if (!*(_DWORD *)(v3 + 28))
  {
    a2[4] = v4 + v12;
    int v13 = get_padded_len(step, 8u) + v11;
    a2[5] = v4 + (4 * v13);
    int v14 = get_padded_len(step, 8u) + v13;
    a2[6] = v4 + (4 * v14);
    LODWORD(v12) = 4 * (get_padded_len((2 * step), 8u) + v14);
  }
  a2[7] = v4 + v12;
  int v15 = get_padded_len(*(unsigned int *)(v3 + 48), 8u);
  a2[8] = v4 + (v12 + 4 * v15);
  int v16 = get_padded_len(*(unsigned int *)(v3 + 52), 8u) + v15;
  a2[9] = v4 + (v12 + 4 * v16);
  int v17 = get_padded_len((*(_DWORD *)(v3 + 52) + *(_DWORD *)(v3 + 12)), 8u) + v16;
  a2[10] = v4 + (v12 + 4 * v17);
  int v18 = get_padded_len(*(unsigned int *)(v3 + 56), 8u) + v17;
  uint64_t v19 = *(unsigned int *)(v3 + 28);
  uint64_t v20 = v4 + (v12 + 4 * v18);
  if (v19)
  {
    a2[22] = v20;
    int v21 = get_padded_len(v19, 8u) + v18;
    a2[23] = v4 + (v12 + 4 * v21);
    uint64_t v22 = v12 + 4 * (get_padded_len((3 * *(_DWORD *)(v3 + 28)), 8u) + v21);
    a2[24] = v4 + v22;
    uint64_t v12 = v22 + 12 * get_padded_len(*(unsigned int *)(v3 + 28), 8u);
    a2[25] = v4 + v12;
    int v23 = get_padded_len(step, 8u);
  }
  else
  {
    a2[11] = v20;
    int v23 = get_padded_len((*(_DWORD *)(v3 + 8) * step), 8u) + v18;
  }
  a2[12] = v4 + (v12 + 4 * v23);
  int v24 = get_padded_len(*(unsigned int *)(v3 + 8), 8u);
  a2[13] = v4 + (v12 + 4 * (v23 + v24));
  int v25 = get_padded_len((*(_DWORD *)(v3 + 12) + *(_DWORD *)(v3 + 56)), 8u) + v24;
  a2[16] = v4 + (v12 + 4 * (v23 + v25));
  int v26 = get_padded_len(*(unsigned int *)(v3 + 64), 8u) + v25;
  a2[14] = v4 + (v12 + 4 * (v23 + v26));
  int v27 = get_padded_len(*(unsigned int *)(v3 + 60), 8u) + v26;
  a2[15] = v4 + (v12 + 4 * (v23 + v27));
  int v28 = get_padded_len(*(unsigned int *)(v3 + 60), 8u) + v27;
  a2[17] = v4 + (v12 + 4 * (v23 + v28));
  uint64_t v29 = v12
      + 4
      * (v23
       + get_padded_len((*(_DWORD *)(v3 + 60) + *(_DWORD *)v3 * *(_DWORD *)(v3 + 4)), 8u)
       + v28);
  *(void *)(v6 + 240) = v4 + v29;
  uint64_t v30 = v29 + get_padded_bytes(*(_DWORD *)(v6 + 248), 8u);
  *(void *)(v5 + 240) = v4 + v30;
  uint64_t v31 = get_padded_bytes(*(_DWORD *)(v5 + 248), 8u) + v30;
  *(void *)(v7 + 240) = v4 + v31;
  uint64_t result = get_padded_bytes(*(_DWORD *)(v7 + 248), 8u);
  if (!*(_DWORD *)(v3 + 28))
  {
    unsigned int v33 = result + v31;
    if (*(_DWORD *)(v3 + 16))
    {
      a2[18] = v4 + v33;
      uint64_t v34 = v33 + 4 * get_padded_len((*(_DWORD *)(v3 + 32) * step), 8u);
      uint64_t v35 = *(void *)(v3 + 168);
      *(void *)(v35 + 240) = v4 + v34;
      unsigned int v33 = get_padded_bytes(*(_DWORD *)(v35 + 248), 8u) + v34;
    }
    if (*(_DWORD *)(v3 + 20))
    {
      a2[19] = v4 + v33;
      int v36 = get_padded_len(step, 8u);
      a2[20] = v4 + v33 + 4 * v36;
      int v37 = get_padded_len((*(_DWORD *)(v3 + 56) + *(_DWORD *)(v3 + 12)), 8u) + v36;
      a2[21] = v4 + v33 + 4 * v37;
      v33 += 4 * (get_padded_len(1, 8u) + v37);
    }
    a2[26] = v4 + v33;
    uint64_t v38 = (*(_DWORD *)(v3 + 8) * step);
    return get_padded_len(v38, 8u);
  }
  return result;
}

uint64_t get_alignment(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = 0;
  long long v13 = 0u;
  memset(v12, 0, sizeof(v12));
  memset(v11, 0, sizeof(v11));
  if (result)
  {
    uint64_t v8 = result;
    if (!*(void *)(result + 240)) {
      log_OutText(**(void **)result, (uint64_t)"FastInfer", 0, 0, (uint64_t)"Decoder get buf failed!", a6, a7, a8, *(uint64_t *)&v11[0]);
    }
    pack_tacodecoder_internal_buffer(v8, v11);
    uint64_t v9 = *(void *)(v8 + 120);
    if (*(_DWORD *)(v9 + 28))
    {
      return *((void *)&v13 + 1);
    }
    else
    {
      if (*(_DWORD *)(v9 + 20)) {
        int v10 = (char *)&v12[7] + 8;
      }
      else {
        int v10 = (char *)v12;
      }
      return *(void *)v10;
    }
  }
  return result;
}

uint64_t additive_attention(uint64_t *a1, void *a2, uint64_t a3, unsigned int *a4, uint64_t a5)
{
  int v10 = *(float **)(a5 + 152);
  int v11 = *(float **)(a5 + 88);
  uint64_t v12 = *(float **)(a5 + 32);
  uint64_t v14 = *(const void **)(a5 + 64);
  long long v13 = *(void **)(a5 + 72);
  unsigned int padded_len = get_padded_len(a4[13], 8u);
  memcpy(v13, v14, 4 * padded_len);
  int v16 = (void *)(*(void *)(a5 + 72) + 4 * a4[13]);
  int v17 = *(const void **)(a5 + 24);
  unsigned int v18 = get_padded_len(a4[3], 8u);
  memcpy(v16, v17, 4 * v18);
  uint64_t v19 = *(void **)(a5 + 80);
  unsigned int v20 = get_padded_len(a4[14], 8u);
  bzero(v19, 4 * v20);
  uint64_t v21 = (*(uint64_t (**)(void))(a2[7] + 128))(0);
  if (v21)
  {
    uint64_t v25 = v21;
    int v26 = "Tacotron attention rnn forward failed!";
LABEL_5:
    log_OutText(*a1, (uint64_t)"FastInfer", 0, 0, (uint64_t)v26, v22, v23, v24, v61);
    return v25;
  }
  bzero(*(void **)(a5 + 96), 4 * a4[2]);
  uint64_t v27 = (*(uint64_t (**)(void))(a2[4] + 128))(0);
  if (v27)
  {
    uint64_t v25 = v27;
    int v26 = "Tacotron decoder Key dense forward failed!";
    goto LABEL_5;
  }
  if (a4[4])
  {
    interleave(a3, *(int **)(a5 + 32), *(float **)(a5 + 40), *(void *)(a5 + 48));
    uint64_t v29 = *(void **)(a5 + 144);
    unsigned int v30 = get_padded_len(a4[8] * a3, 8u);
    bzero(v29, 4 * v30);
    uint64_t v31 = (*(uint64_t (**)(void))(a2[10] + 128))(0);
    if (v31)
    {
      uint64_t v25 = v31;
      int v26 = "Tacotron location layer conv forward failed!";
      goto LABEL_5;
    }
    uint64_t v38 = *(void **)(a5 + 88);
    long long v39 = *(const void **)(a5 + 208);
    unsigned int v40 = get_padded_len(a4[2] * a3, 8u);
    memcpy(v38, v39, 4 * v40);
    uint64_t v41 = (*(uint64_t (**)(void))(a2[11] + 128))(0);
    if (v41)
    {
      uint64_t v25 = v41;
      int v26 = "Tacotron location layer dense forward failed!";
      goto LABEL_5;
    }
  }
  else
  {
    long long v32 = *(void **)(a5 + 88);
    unsigned int v33 = *(const void **)(a5 + 208);
    unsigned int v34 = get_padded_len(a4[2] * a3, 8u);
    memcpy(v32, v33, 4 * v34);
  }
  if (a3)
  {
    int v35 = 0;
    do
      axpy(a4[2], *(float **)(a5 + 96), 1, (float *)(*(void *)(a5 + 88) + 4 * a4[2] * v35++), 1, 1.0);
    while (a3 != v35);
  }
  fi_activate_array(v11, a4[2] * a3, 2);
  unsigned int v36 = get_padded_len(a3, 8u);
  bzero(v12, 4 * v36);
  uint64_t v37 = (*(uint64_t (**)(void))(a2[2] + 128))(0);
  if (v37)
  {
    uint64_t v25 = v37;
    int v26 = "Tacotron attention vec_v dense forward failed!";
    goto LABEL_5;
  }
  fi_activate_array(v12, a3, 1);
  oneNorm((uint64_t)v12, a3, 1, (uint64_t)v12);
  axpy(a3, *(float **)(a5 + 32), 1, *(float **)(a5 + 40), 1, 1.0);
  if (a4[5])
  {
    if (!a3) {
      goto LABEL_23;
    }
    float v42 = **(float **)(a5 + 168);
    uint64_t v43 = a3;
    float v44 = 0.0;
    uint64_t v45 = a3;
    uint64_t v46 = v10;
    float v47 = 0.0;
    do
    {
      float v48 = *v46;
      float v49 = *v12++;
      float v50 = v49 * (float)((float)((float)(v42 * v47) + (float)(*v46 * (float)(1.0 - v42))) + 0.0000001);
      *v46++ = v50;
      float v44 = v44 + v50;
      float v47 = v48;
      --v45;
    }
    while (v45);
    if (v44 == 0.0)
    {
LABEL_23:
      uint64_t v25 = 7;
      int v26 = "Alpha sum equals zero!";
      goto LABEL_5;
    }
    do
    {
      *int v10 = *v10 / v44;
      ++v10;
      --v43;
    }
    while (v43);
  }
  uint64_t v51 = *(void **)(a5 + 24);
  unsigned int v52 = get_padded_len(a4[3], 8u);
  bzero(v51, 4 * v52);
  unsigned int v53 = a4[5];
  uint64_t v54 = 152;
  if (!v53) {
    uint64_t v54 = 32;
  }
  if (a3)
  {
    uint64_t v55 = 0;
    uint64_t v56 = *(void *)(a5 + v54);
    do
    {
      axpy(a4[3], (float *)(*(void *)a5 + 4 * a4[3] * v55), 1, *(float **)(a5 + 24), 1, *(float *)(v56 + 4 * v55));
      ++v55;
    }
    while (a3 != v55);
    unsigned int v53 = a4[5];
  }
  if (!v53) {
    return 0;
  }
  uint64_t v57 = *(void **)(a5 + 160);
  unsigned int v58 = get_padded_len(a4[14] + a4[3], 8u);
  bzero(v57, 4 * v58);
  memcpy(*(void **)(a5 + 160), *(const void **)(a5 + 24), 4 * a4[3]);
  memcpy((void *)(*(void *)(a5 + 160) + 4 * a4[3]), *(const void **)(a5 + 80), 4 * a4[14]);
  uint64_t v59 = *(void **)(a5 + 168);
  unsigned int v60 = get_padded_len(1, 8u);
  bzero(v59, 4 * v60);
  uint64_t v25 = (*(uint64_t (**)(void))(a2[13] + 128))(0);
  if (v25)
  {
    int v26 = "Tacotron forward attention trans agent dense forward failed!";
    goto LABEL_5;
  }
  return v25;
}

float *Stream_ComputeStats(float *result, int a2, uint64_t a3)
{
  *(void *)a3 = 0;
  *(float *)(a3 + 8) = (float)a2;
  float v3 = 1.0 / (float)a2;
  if (a2 <= 0)
  {
    float v10 = 0.0;
    *(float *)a3 = v3 * 0.0;
  }
  else
  {
    uint64_t v4 = a2;
    float v5 = 0.0;
    uint64_t v6 = a2;
    uint64_t v7 = result;
    do
    {
      float v8 = *v7++;
      float v5 = v8 + v5;
      *(float *)a3 = v5;
      --v6;
    }
    while (v6);
    float v9 = v3 * v5;
    *(float *)a3 = v3 * v5;
    float v10 = 0.0;
    do
    {
      float v11 = *result++;
      float v10 = v10 + (float)((float)(v11 - v9) * (float)(v11 - v9));
      *(float *)(a3 + 4) = v10;
      --v4;
    }
    while (v4);
  }
  *(float *)(a3 + 4) = v3 * v10;
  return result;
}

void mlpg_gv(uint64_t a1)
{
  float v3 = *(float *)(a1 + 720);
  uint64_t v2 = 10;
  MFS__mlpg2(a1, 0);
  if (v3 != 0.0 && *(int *)(a1 + 20) >= 2) {
    mlpgGradHessian((uint64_t)&v2, (int *)a1, 0);
  }
}

float *mlpgGradHessian(uint64_t a1, int *a2, int a3)
{
  uint64_t result = (float *)heap_Calloc(*(void **)(*(void *)a2 + 8), 4, (2 * a2[5]));
  if (result)
  {
    uint64_t v6 = result;
    uint64_t v7 = a2;
    if (a2[4] >= 1)
    {
      uint64_t v8 = 0;
      LODWORD(v9) = a2[5];
      uint64_t v10 = (int)v9;
      float v11 = 1.0e10;
      float v12 = 1.0;
      uint64_t v90 = a2;
      do
      {
        if ((int)v9 >= 1)
        {
          long long v13 = (uint64_t *)*((void *)v7 + 5);
          uint64_t v14 = v9;
          int v15 = v6;
          do
          {
            uint64_t v16 = *v13++;
            *v15++ = *(float *)(v16 + 4 * v8);
            --v14;
          }
          while (v14);
        }
        int v17 = &v7[v8];
        float v18 = *((float *)v17 + 80);
        float v91 = *((float *)v17 + 30);
        VarianceNormalize(v6, v9, *(_DWORD *)(a1 + 4), v91);
        calc_R_and_r_opt(v90, v8);
        uint64_t v7 = v90;
        unint64_t v9 = v90[5];
        int v89 = *(_DWORD *)a1;
        if (*(int *)a1 >= 1)
        {
          int v19 = 0;
          float v20 = 1.0 / (float)((int)v9 * **((_DWORD **)v90 + 4));
          uint64_t v21 = (float *)*((void *)v90 + 11);
          uint64_t v22 = (float **)*((void *)v90 + 12);
          uint64_t v23 = (float *)*((void *)v90 + 13);
          float v86 = v18 * -2.0;
          float v84 = v18 + v18;
          float v85 = v18 * (float)((int)v9 - 1);
          float v24 = -v20;
          if (a3) {
            BOOL v25 = (int)v9 < 1;
          }
          else {
            BOOL v25 = 1;
          }
          char v26 = v25;
          char v88 = v26;
          float v27 = v11;
          float v87 = v18;
          do
          {
            int v93 = 0;
            uint64_t v92 = 0;
            Stream_ComputeStats(v6, v9, (uint64_t)&v92);
            float v29 = v28;
            int v30 = *(_DWORD *)(a1 + 4);
            float v31 = *((float *)&v92 + 1);
            float v32 = *((float *)&v92 + 1);
            if (v30) {
              float v32 = log(*((float *)&v92 + 1));
            }
            uint64_t v7 = v90;
            if ((int)v9 < 1)
            {
              float v42 = (unsigned char *)*((void *)v90 + 14);
              BOOL v54 = v42 == 0;
              float v47 = 0.0;
              float v48 = v87;
            }
            else
            {
              unint64_t v33 = 0;
              uint64_t v34 = v90[6];
              int v35 = v22;
              unsigned int v36 = v6;
              do
              {
                uint64_t v37 = v22[v33];
                float v38 = *v37 * v6[v33];
                v21[v33] = v38;
                if ((int)v34 >= 2)
                {
                  uint64_t v39 = -1;
                  for (unint64_t i = 1; i != v34; ++i)
                  {
                    if (v33 + i < v9)
                    {
                      float v38 = v38 + (float)(v37[i] * v36[i]);
                      v21[v33] = v38;
                    }
                    if (v33 >= i)
                    {
                      float v38 = v38 + (float)(v35[v39][i] * v36[v39]);
                      v21[v33] = v38;
                    }
                    --v39;
                  }
                }
                ++v33;
                ++v36;
                ++v35;
              }
              while (v33 != v9);
              float v41 = (float)(2.0 / (float)((int)v9 * (int)v9)) * (float)(v84 + (float)(v85 * (float)(v32 - v91)));
              float v42 = (unsigned char *)*((void *)v90 + 14);
              if (v42)
              {
                uint64_t v43 = 0;
                float v44 = 1.0 / v31;
                if (v30 != 1) {
                  float v44 = 1.0;
                }
                float v45 = *(float *)&v92;
                float v46 = -v41;
                float v47 = 0.0;
                float v48 = v87;
                do
                {
                  float v49 = v6[v43];
                  float v50 = v23[v43];
                  float v51 = v21[v43];
                  float v52 = *v22[v43];
                  float v53 = v20 * (float)(v50 - v51);
                  v21[v43] = v53;
                  if (v42[v43]) {
                    float v53 = v53
                  }
                        + (float)((float)((float)(v29 * (float)(v86 * (float)(v32 - v91))) * (float)(v6[v43] - v45))
                                * v44);
                  float v47 = v47 + (float)((float)(v20 * v49) * (float)(v50 + (float)(v51 * -0.5)));
                  v21[v43++] = (float)(1.0
                                     / (float)((float)((float)((float)(v49 - v45) * (float)(v49 - v45)) * v46)
                                             + (float)(v24 * v52)))
                             * v53;
                }
                while (v9 != v43);
                BOOL v54 = 0;
              }
              else
              {
                float v55 = *(float *)&v92;
                float v56 = -v41;
                uint64_t v57 = v6;
                float v47 = 0.0;
                unsigned int v58 = v23;
                uint64_t v59 = v21;
                unsigned int v60 = v22;
                unint64_t v61 = v9;
                float v48 = v87;
                do
                {
                  float v62 = *v57++;
                  float v63 = v62;
                  float v64 = v20 * v62;
                  float v65 = *v58++;
                  float v66 = v65;
                  float v67 = v65 + (float)(*v59 * -0.5);
                  uint64_t v68 = *v60++;
                  float v47 = v47 + (float)(v64 * v67);
                  *uint64_t v59 = (float)(v20 * (float)(v66 - *v59))
                       / (float)((float)((float)((float)(v63 - v55) * (float)(v63 - v55)) * v56) + (float)(v24 * *v68));
                  ++v59;
                  --v61;
                }
                while (v61);
                float v42 = 0;
                BOOL v54 = 1;
              }
            }
            if ((v88 & 1) == 0)
            {
              unint64_t v69 = v9;
              uint64_t v70 = v21;
              do
              {
                if (!v54 && *v42 == 1) {
                  *uint64_t v70 = 0.0;
                }
                ++v70;
                ++v42;
                --v69;
              }
              while (v69);
            }
            float v71 = v47 + (float)((float)(v32 + (float)(v91 * -2.0)) * (float)(v48 * (float)(v32 * -0.5)));
            float v11 = -v71;
            if (v19)
            {
              if (fabsf(v27 + v71) < 0.000001)
              {
                float v11 = v27;
                break;
              }
              if (v27 < v11) {
                float v12 = v12 * 0.5;
              }
              if (v27 > v11) {
                float v12 = v12 * 1.2;
              }
            }
            if ((int)v9 >= 1)
            {
              unint64_t v72 = v9;
              uint64_t v73 = v21;
              uint64_t v74 = v6;
              do
              {
                *uint64_t v74 = *v74 + (float)(v12 * *v73);
                float v75 = *v73++;
                v74[v10] = v75;
                ++v74;
                --v72;
              }
              while (v72);
            }
            ++v19;
            float v27 = -v71;
          }
          while (v19 != v89);
        }
        if ((int)v9 >= 1)
        {
          uint64_t v76 = (uint64_t *)*((void *)v7 + 5);
          unint64_t v77 = v9;
          int v78 = v6;
          do
          {
            float v79 = *v78++;
            float v80 = v79;
            uint64_t v81 = *v76++;
            *(float *)(v81 + 4 * v8) = *(float *)(v81 + 4 * v8)
                                     + (float)(*(float *)(a1 + 8) * (float)(v80 - *(float *)(v81 + 4 * v8)));
            --v77;
          }
          while (v77);
        }
        ++v8;
      }
      while (v8 < v7[4]);
    }
    int v82 = *(void **)(*(void *)v7 + 8);
    return (float *)heap_Free(v82, (uint64_t)v6);
  }
  return result;
}

void mlpg_gvc(uint64_t a1)
{
  float v3 = *(float *)(a1 + 720);
  uint64_t v2 = 10;
  mlpg_c(a1, 0);
  if (v3 != 0.0) {
    mlpgGradHessian((uint64_t)&v2, (int *)a1, 1);
  }
}

void mlpg_gvnorm(uint64_t a1)
{
  float v2 = *(float *)(a1 + 720);
  MFS__mlpg2(a1, 0);
  if (v2 != 0.0)
  {
    float v3 = (float *)heap_Calloc(*(void **)(*(void *)a1 + 8), 4, *(unsigned int *)(a1 + 20));
    if (v3)
    {
      uint64_t v4 = (uint64_t)v3;
      int v5 = *(_DWORD *)(a1 + 20);
      if (v5 >= 1)
      {
        uint64_t v6 = *(float ***)(a1 + 40);
        uint64_t v7 = *(unsigned int *)(a1 + 20);
        uint64_t v8 = v3;
        do
        {
          unint64_t v9 = *v6++;
          *v8++ = *v9;
          --v7;
        }
        while (v7);
      }
      VarianceNormalize(v3, v5, 0, *(float *)(a1 + 120));
      uint64_t v10 = *(unsigned int *)(a1 + 20);
      if ((int)v10 >= 1)
      {
        float v11 = *(float ***)(a1 + 40);
        float v12 = (float *)v4;
        do
        {
          float v13 = *v12++;
          float v14 = v13;
          int v15 = *v11++;
          *int v15 = *v15 + (float)(v2 * (float)(v14 - *v15));
          --v10;
        }
        while (v10);
      }
      uint64_t v16 = *(void **)(*(void *)a1 + 8);
      heap_Free(v16, v4);
    }
  }
}

void VarianceNormalize(float *a1, int a2, int a3, float a4)
{
  uint64_t v7 = a1;
  int v12 = 0;
  uint64_t v11 = 0;
  Stream_ComputeStats(a1, a2, (uint64_t)&v11);
  if (a3 == 1) {
    a4 = exp(a4);
  }
  if (a2 >= 1)
  {
    float v8 = *(float *)&v11;
    float v9 = sqrtf(a4 / *((float *)&v11 + 1));
    uint64_t v10 = a2;
    do
    {
      *uint64_t v7 = v8 + (float)((float)(*v7 - v8) * v9);
      ++v7;
      --v10;
    }
    while (v10);
  }
}

uint64_t ForcedEEController_TimeGet(uint64_t a1, _DWORD *a2)
{
  uint64_t v2 = 0;
  if (a1 && a2)
  {
    uint64_t v4 = *(void *)(a1 + 16);
    if (v4 && (uint64_t v5 = heap_Calloc(*(void **)(v4 + 8), 1, 12)) != 0)
    {
      uint64_t v6 = (_DWORD *)v5;
      if (((**(uint64_t (***)(void, uint64_t))(v4 + 384))(*(void *)(v4 + 392), v5) & 0x80000000) != 0)
      {
        uint64_t v2 = 0;
      }
      else
      {
        *a2 = *v6;
        uint64_t v2 = 1;
      }
      heap_Free(*(void **)(v4 + 8), (uint64_t)v6);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t ForcedEEController_Clear(uint64_t result)
{
  if (result)
  {
    *(_DWORD *)(result + 8) = 0;
    *(void *)uint64_t result = 0;
    *(void *)(result + 24) = 0;
    *(void *)(result + 32) = 0;
    *(void *)(result + 16) = 0;
    *(_DWORD *)(result + 40) = 0;
  }
  return result;
}

uint64_t ForcedEEController_SetProcessStart(uint64_t *a1, uint64_t a2)
{
  uint64_t result = 1;
  if (!a1 || !a2) {
    return result;
  }
  __s1 = 0;
  *(_DWORD *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 0;
  if ((paramc_ParamGetStr(a1[5], (uint64_t)"bet4earlyemissionmode", &__s1) & 0x80000000) == 0)
  {
    uint64_t v5 = __s1;
    if (!strcmp(__s1, "forced"))
    {
      int v6 = 1;
    }
    else
    {
      if (strcmp(v5, "forced-deterministic"))
      {
LABEL_9:
        paramc_ParamRelease(a1[5]);
        goto LABEL_10;
      }
      int v6 = 2;
    }
    *(_DWORD *)a2 = v6;
    goto LABEL_9;
  }
LABEL_10:
  if (!*(_DWORD *)a2) {
    return 1;
  }
  if (!a1[48] || !a1[49]) {
    return 0;
  }
  if ((paramc_ParamGetUInt(a1[5], (uint64_t)"bet4earlyemissionforcedoutputlead", (unsigned int *)(a2 + 28)) & 0x80000000) != 0) {
    *(_DWORD *)(a2 + 28) = 0;
  }
  *(void *)(a2 + 16) = a1;
  uint64_t result = ForcedEEController_TimeGet(a2, (_DWORD *)(a2 + 4));
  if (result)
  {
    *(void *)(a2 + 32) = 0;
    *(_DWORD *)(a2 + 40) = 0;
    if (*(_DWORD *)a2 == 2)
    {
      *(_DWORD *)(a2 + 24) = 100;
      uint64_t v7 = (unsigned int *)(a2 + 24);
      if ((paramc_ParamGetUInt(a1[5], (uint64_t)"bet4earlyemissionforceddeterministicrtf", v7) & 0x80000000) != 0) {
        *uint64_t v7 = 100;
      }
    }
    return 1;
  }
  *(_DWORD *)(a2 + 8) = 0;
  *(void *)a2 = 0;
  *(void *)(a2 + 24) = 0;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 40) = 0;
  return result;
}

uint64_t ForcedEEController_SetStartedPlayback(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  if (!*(_DWORD *)a1) {
    return 1;
  }
  uint64_t result = ForcedEEController_TimeGet(a1, (_DWORD *)(a1 + 8));
  if (result) {
    return 1;
  }
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)a1 = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  return result;
}

BOOL ForcedEEController_HasStartedPlayback(BOOL result)
{
  if (result) {
    return *(_DWORD *)(result + 8) != 0;
  }
  return result;
}

BOOL ForcedEEController_CheckRiskForBufferUnderrun(BOOL result)
{
  if (result)
  {
    uint64_t v1 = (_DWORD *)result;
    if (!*(_DWORD *)result || !*(_DWORD *)(result + 8)) {
      return 0;
    }
    uint64_t v2 = (_DWORD *)(result + 40);
    if ((paramc_ParamGetUInt(*(void *)(*(void *)(result + 16) + 40), (uint64_t)"feedback-amount-of-output-msecs-for-this-speakrequest", (unsigned int *)(result + 40)) & 0x80000000) != 0)*uint64_t v2 = 0; {
    if (*v1 == 1)
    }
    {
      unsigned int v8 = 0;
      if (ForcedEEController_TimeGet((uint64_t)v1, &v8))
      {
        unsigned int v3 = v1[2];
        BOOL v4 = v8 >= v3;
        unsigned int v5 = v8 - v3;
        if (v5 != 0 && v4)
        {
          v1[8] = v8 - v1[1];
          v1[9] = v5;
        }
      }
    }
    else
    {
      unsigned int v6 = v1[10];
      int v7 = v1[7];
      if (v6 >= v7 - 1)
      {
        if (-1431655765 * v6 <= 0x55555555) {
          unsigned int v6 = v6 - v7 + 1;
        }
        else {
          v6 += ~v7;
        }
      }
      v1[9] = v6;
    }
    return *v2 && (v1[7] + v1[9]) >= *v2;
  }
  return result;
}

uint64_t mfs_symData_Init(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t v6 = a1 + 16432;
  uint64_t v7 = *(void *)(a1 + 17144);
  *((void *)a2 + 306) = v7;
  *((void *)a2 + 307) = *(void *)(a1 + 16424);
  uint64_t v8 = *(unsigned int *)(a1 + 16432);
  a2[610] = v8;
  float v9 = *(unsigned __int8 **)(a1 + 16664);
  *((void *)a2 + 302) = v9;
  if (v9)
  {
    int v10 = a2[606];
    if (v8)
    {
      do
      {
        int v11 = *v9++;
        v10 += v11;
        --v8;
      }
      while (v8);
    }
    a2[606] = v10;
  }
  if ((*(_DWORD *)(a1 + 8360) - 1) < 2)
  {
    MFS__log_select_Diag(a3, 1, (uint64_t)"%s, Decompression compressed symdata.dat\n");
    uint64_t v12 = *(void *)(a1 + 16904);
    unsigned int v13 = bswap32(*(_DWORD *)(v12 + 8));
    int v14 = *(_DWORD *)(v6 + 480);
    uint64_t v15 = heap_Calloc(*(void **)(a3 + 8), (104 * v13 + 50) / 0x64 + 384, 1);
    if (!v15)
    {
      MFS__log_select_Error(a3, 1, (uint64_t)"%s, Error, out of memory!\n", v16, v17, v18, v19, v20);
      return 0;
    }
    uint64_t v21 = v15;
    uint64_t v22 = (unsigned __int8 *)(v12 + 12);
    int v23 = *(_DWORD *)(a1 + 8360);
    if (v23 == 2)
    {
      LZ_Uncompress(v22, v21, v14 - 12);
      float v24 = "After lz_77 decoding on symdata.dat, size: %d\n";
      BOOL v25 = "Before lz_77 decoding on symdata.dat, size: %d\n";
    }
    else
    {
      if (v23 != 1)
      {
LABEL_14:
        *(void *)(a1 + 16904) = v21;
        *(_DWORD *)(v6 + 480) = v13;
        *((void *)a2 + 1556) = v21;
        uint64_t v7 = *((void *)a2 + 306);
        goto LABEL_15;
      }
      Huffman_Uncompress((uint64_t)v22);
      float v24 = "After huffman decoding on symdata.dat, size: %d\n";
      BOOL v25 = "Before huffman decoding on symdata.dat, size: %d\n";
    }
    MFS__log_select_Diag(a3, 1, (uint64_t)v25);
    MFS__log_select_Diag(a3, 1, (uint64_t)v24);
    goto LABEL_14;
  }
  uint64_t v21 = *(void *)(a1 + 16904);
LABEL_15:
  *((void *)a2 + 304) = v21;
  if (v7 && *((void *)a2 + 307) && v21)
  {
    uint64_t v27 = 0;
    *((void *)a2 + 301) = a3;
    a2[619] = 0;
    do
    {
      float v28 = *(float *)(a1 + 8040 + v27 * 4);
      *(float *)&a2[v27 + 616] = v28;
      float v29 = v28 + *((float *)a2 + 619);
      *((float *)a2 + 619) = v29;
      ++v27;
    }
    while (v27 != 3);
    *((float *)a2 + 619) = BET3FLT__bet3_finv(v29);
  }
  else
  {
    *((void *)a2 + 301) = 0;
    MFS__log_select_Diag(a3, 1, (uint64_t)"%s, Warning, has loaded no SYM data\n");
  }
  int v30 = *(_DWORD *)(a1 + 8956);
  if (v30 < 1)
  {
    *((void *)a2 + 1516) = 0;
    MFS__log_select_Diag(a3, 1, (uint64_t)"%s, Warning, has loaded no STYLE data\n");
LABEL_37:
    LODWORD(v48) = *a2;
    if (*a2 < 1)
    {
      int v55 = v48 + 2;
    }
    else
    {
      float v49 = (float *)(a2 + 622);
      float v50 = (float **)(a2 + 660);
      uint64_t v51 = 2;
      do
      {
        uint64_t v52 = 0;
        float v53 = v50;
        BOOL v54 = v49;
        do
        {
          mfs_symData_PreInstallStreamWeights((uint64_t)a2, v52++, *a2, v51, v54, v53);
          v54 += 9;
          v53 += 9;
        }
        while (v52 != 3);
        ++v51;
        uint64_t v48 = *a2;
        int v55 = v48 + 2;
        ++v49;
        ++v50;
      }
      while (v51 < v48 + 2);
    }
    if (*(_DWORD *)(a1 + 8328))
    {
      uint64_t v56 = a2[610];
      if ((int)v56 >= 1)
      {
        for (uint64_t i = 0; i != v56; ++i)
        {
          if (v55 >= 3)
          {
            unsigned int v58 = a2 + 622;
            uint64_t v59 = a2 + 660;
            for (uint64_t j = 2; j != v55; ++j)
            {
              uint64_t v61 = 0;
              float v62 = (float *)&a2[256 * j + 728 + i];
              float *v62 = 0.0;
              float v63 = 0.0;
              float v64 = v59;
              do
              {
                uint64_t v65 = *(void *)v64;
                v64 += 18;
                float v63 = v63 + (float)(*(float *)(v65 + 4 * i) * *(float *)&v58[v61]);
                float *v62 = v63;
                v61 += 9;
              }
              while (v61 != 27);
              v59 += 2;
              ++v58;
            }
          }
        }
      }
    }
    if (*(_DWORD *)(*((void *)a2 + 134) + 8372)) {
      return 1;
    }
    int v66 = a2[610];
    a2[3108] = 0;
    uint64_t result = 1;
    if (v66 > 47)
    {
      if (v66 == 48)
      {
        if (v48 != 3) {
          return result;
        }
        int v67 = 16;
      }
      else if (v66 == 51)
      {
        if (v48 != 3) {
          return result;
        }
        int v67 = 17;
      }
      else
      {
        if (v66 != 54 || v48 != 3) {
          return result;
        }
        int v67 = 18;
      }
LABEL_74:
      a2[3108] = v67;
      return result;
    }
    switch(v66)
    {
      case '$':
        if (v48 == 3)
        {
          int v67 = 12;
          goto LABEL_74;
        }
        break;
      case '\'':
        if (v48 == 3)
        {
          int v67 = 13;
          goto LABEL_74;
        }
        break;
      case '*':
        if (v48 == 3)
        {
          int v67 = 14;
          goto LABEL_74;
        }
        break;
      case '-':
        if (v48 == 3)
        {
          int v67 = 15;
          goto LABEL_74;
        }
        break;
      default:
        return result;
    }
  }
  else
  {
    uint64_t v31 = 0;
    *((void *)a2 + 1518) = *(void *)(a1 + 17384);
    *((unsigned char *)a2 + 12136) = v30;
    *((void *)a2 + 1516) = a3;
    a2[3047] = 0;
    int v32 = ((v30 - 1) * v30) >> 1;
    LODWORD(v33) = *a2;
    uint64_t v34 = 4 * v32;
    while (1)
    {
      uint64_t result = heap_Calloc(*(void **)(*((void *)a2 + 1516) + 8), (int)v33, 8);
      uint64_t v35 = (uint64_t)&a2[2 * v31 + 3032];
      *(void *)(v35 + 24) = result;
      unsigned int v36 = (uint64_t *)(v35 + 24);
      if (!result) {
        break;
      }
      *unsigned int v36 = result - 16;
      LODWORD(v33) = *a2;
      if (*a2 >= 1)
      {
        uint64_t v37 = *(void *)(a1 + 24 * v31 + 17624);
        uint64_t v38 = *(void *)(a1 + 24 * v31 + 17864);
        uint64_t v39 = 2;
        while (1)
        {
          *(void *)(*v36 + 8 * v39) = heap_Calloc(*(void **)(*((void *)a2 + 1516) + 8), *(unsigned int *)(v37 + 4 * (v39 - 2)), 8);
          uint64_t v40 = *v36;
          uint64_t v41 = *(void *)(*v36 + 8 * v39);
          if (!v41) {
            break;
          }
          *(void *)(v40 + 8 * v39) = v41 - 8;
          uint64_t v42 = *(unsigned int *)(v37 + 4 * (v39 - 2));
          if ((int)v42 >= 1)
          {
            uint64_t v43 = 8 * v42 + 8;
            uint64_t v44 = 8;
            do
            {
              *(void *)(*(void *)(*v36 + 8 * v39) + v44) = v38;
              v44 += 8;
              v38 += v34;
            }
            while (v43 != v44);
          }
          uint64_t v33 = *a2;
          if (v39++ > v33) {
            goto LABEL_32;
          }
        }
        heap_Free(*(void **)(*((void *)a2 + 1516) + 8), v40);
        uint64_t result = 0;
        break;
      }
LABEL_32:
      float v46 = *(float *)(a1 + 4 * v31 + 8080);
      *(float *)&a2[v31 + 3044] = v46;
      float v47 = v46 + *((float *)a2 + 3047);
      *((float *)a2 + 3047) = v47;
      if (++v31 == 3)
      {
        *((float *)a2 + 3047) = BET3FLT__bet3_finv(v47);
        goto LABEL_37;
      }
    }
    *((void *)a2 + 1516) = 0;
  }
  return result;
}

float mfs_symData_PreInstallStreamWeights(uint64_t a1, unsigned int a2, int a3, int a4, float *a5, float **a6)
{
  uint64_t v7 = *(unsigned int *)(a1 + 2440);
  uint64_t v8 = (float *)(*(void *)(a1 + 2448) + 4 * v7 * (a4 + a3 * a2 - 2));
  *a6 = v8;
  *a5 = 0.0;
  float v9 = 0.0;
  if (v7)
  {
    do
    {
      float v10 = *v8++;
      float v9 = v10 + v9;
      *a5 = v9;
      --v7;
    }
    while (v7);
  }
  float result = (float)(BET3FLT__bet3_finv(v9) * *(float *)(a1 + 4 * a2 + 2464)) * *(float *)(a1 + 2476);
  *a5 = result;
  return result;
}

void *mfs_symData_DeInit(void *result)
{
  uint64_t v1 = result;
  result[304] = 0;
  result[307] = 0;
  result[306] = 0;
  if (result[1516])
  {
    for (uint64_t i = 0; i != 3; ++i)
    {
      int v3 = *(_DWORD *)v1;
      if (*(int *)v1 < 1)
      {
        unsigned int v7 = 2;
      }
      else
      {
        BOOL v4 = &v1[i + 1519];
        uint64_t v5 = 2;
        do
        {
          *(void *)(*v4 + 8 * v5) += 8;
          uint64_t v6 = *(void *)(*v4 + 8 * v5);
          if (v6)
          {
            float result = heap_Free(*(void **)(v1[1516] + 8), v6);
            int v3 = *(_DWORD *)v1;
          }
          unsigned int v7 = v5 + 1;
        }
        while (v5++ <= v3);
      }
      float v9 = &v1[i];
      uint64_t v10 = v9[1519] + 16;
      v9[1519] = v10;
      uint64_t v11 = *(void *)(v10 + 8 * v7);
      if (v11) {
        float result = heap_Free(*(void **)(v1[1516] + 8), v11);
      }
    }
  }
  v1[1516] = 0;
  v1[301] = 0;
  return result;
}

uint64_t mfs_symData_GetTargetVector(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  unint64_t v4 = *(unsigned int *)(result + 2440);
  if (v4)
  {
    uint64_t v5 = 0;
    uint64_t v6 = a4 + 2;
    uint64_t v7 = a4 + 1;
    while (2)
    {
      uint64_t v8 = *(unsigned __int8 *)(*(void *)(result + 2456) + v5);
      switch(*(unsigned char *)(*(void *)(result + 2456) + v5))
      {
        case 0xFC:
          if (a4 < 2) {
            goto LABEL_17;
          }
          LOBYTE(v9) = *(unsigned char *)(*(void *)(a3 + 32) + (a4 - 2));
          goto LABEL_25;
        case 0xFD:
          if (a4 < 1) {
            goto LABEL_17;
          }
          LOBYTE(v9) = *(unsigned char *)(*(void *)(a3 + 32) + (a4 - 1));
          goto LABEL_25;
        case 0xFE:
          if ((int)v7 >= *(__int16 *)(a3 + 10)) {
            goto LABEL_17;
          }
          LOBYTE(v9) = *(unsigned char *)(*(void *)(a3 + 32) + v7);
          goto LABEL_25;
        case 0xFF:
          if ((int)v6 >= *(__int16 *)(a3 + 10)) {
LABEL_17:
          }
            LOBYTE(v9) = 0;
          else {
            LOBYTE(v9) = *(unsigned char *)(*(void *)(a3 + 32) + v6);
          }
          goto LABEL_25;
        default:
          if (v8 == 22)
          {
            int v9 = *(unsigned __int8 *)(*(void *)(a3 + 32) + a4);
            if (v9 != 1)
            {
              int v9 = *(char *)(*(void *)(a3 + 192) + a4);
              if (v9 < 0) {
                LOBYTE(v9) = -1;
              }
              else {
                LOBYTE(v9) = 2 * v9;
              }
            }
          }
          else if (v8 == 29)
          {
            uint64_t v10 = *(void *)(a3 + 248);
            if (v10)
            {
              int v9 = *(unsigned __int8 *)(v10 + a4);
              if (!v9) {
                LOBYTE(v9) = -1;
              }
            }
            else
            {
              LOBYTE(v9) = -1;
            }
          }
          else
          {
            uint64_t v11 = *(void *)(a3 + 8 * v8 + 16);
            if (!v11) {
              goto LABEL_26;
            }
            LOBYTE(v9) = *(unsigned char *)(v11 + a4);
          }
LABEL_25:
          *(unsigned char *)(a2 + 4 + v5) = v9;
          unint64_t v4 = *(unsigned int *)(result + 2440);
LABEL_26:
          if (++v5 >= v4) {
            return result;
          }
          continue;
      }
    }
  }
  return result;
}

uint64_t mfs_symData_GetCandVector(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, int a6, uint64_t *a7)
{
  int v7 = *(_DWORD *)(a2 + 12432);
  if (v7) {
    unsigned int v8 = a5 - a6 + 2;
  }
  else {
    unsigned int v8 = (a5 - a6 + 2) / a4;
  }
  if (*(_DWORD *)(*(void *)(a2 + 1072) + 8372) == 1)
  {
    mfs_symData_recoverCompactFeatVect(a1, a2, a3, v8, a7);
  }
  else
  {
    if (!v7) {
      int v7 = *(_DWORD *)(a2 + 2440);
    }
    *a7 = *(void *)(a2 + 2432) + v7 * v8;
  }
  return 0;
}

uint64_t mfs_symData_recoverCompactFeatVect(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t *a5)
{
  uint64_t v5 = *(unsigned int *)(a2 + 2440);
  if (v5)
  {
    uint64_t v6 = 0;
    uint64_t v7 = *a5;
    unsigned int v8 = *(_DWORD *)(a2 + 2424) * a4;
    uint64_t v9 = *(void *)(a2 + 2432) + (v8 >> 3);
    unsigned int v10 = v8 & 7;
    do
    {
      int v11 = v8 & 7;
      int v12 = *(unsigned __int8 *)(*(void *)(a2 + 2416) + v6);
      unint64_t v13 = (unint64_t)v10 >> 3;
      if ((v11 + v12) < 9) {
        int v14 = 0;
      }
      else {
        int v14 = *(unsigned __int8 *)(v9 + v13 + 1);
      }
      *(unsigned char *)(v7 + v6) = (unsigned __int16)((v14 | (*(unsigned __int8 *)(v9 + v13) << 8)) << v11) >> (16 - v12);
      unsigned int v8 = v10 + v12;
      ++v6;
      unsigned int v10 = v8;
    }
    while (v5 != v6);
  }
  return 0;
}

uint64_t mfs_symData_DistanceOnUid_PreCalc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  uint64_t v14 = *(void *)(a2 + 2400);
  int v22 = 0;
  memset(v21, 0, sizeof(v21));
  uint64_t v20 = v21;
  uint64_t result = mfs_symData_GetCandVector(a1, a2, a3, *(_DWORD *)a2, a6, a7, (uint64_t *)&v20);
  unsigned int v16 = *(_DWORD *)(a2 + 2440);
  if (v16)
  {
    unint64_t v17 = 0;
    uint64_t v18 = (uint64_t)v20;
    uint64_t v19 = a4 + 4;
    do
    {
      *(_DWORD *)(a9 + 4 * v17) = 0;
      if (*(_DWORD *)(a10 + 4 * v17))
      {
        uint64_t result = *(unsigned __int8 *)(v19 + v17);
        if (result != *(unsigned __int8 *)(v18 + v17)) {
          *(_DWORD *)(a9 + 4 * v17) = 1065353216;
        }
      }
      else if (v14 {
             && ((uint64_t result = *(void *)(v14 + 8 * (v17 + (a7 - 1 - a8 + 8 * a8) * v16))) != 0
      }
              || (uint64_t result = *(void *)(v14 + 8 * (v17 + v16 * (a7 - 1)))) != 0
              || (uint64_t result = *(void *)(v14 + 8 * v17)) != 0))
      {
        *(_DWORD *)(a9 + 4 * v17) = *(_DWORD *)(result
                                              + 4
                                              * (*(unsigned __int8 *)(v18 + v17)
                                               + ((unint64_t)*(unsigned __int8 *)(v19 + v17) << 7)));
      }
      else
      {
        uint64_t result = *(unsigned __int8 *)(v19 + v17);
        if (result != *(unsigned __int8 *)(v18 + v17))
        {
          *(_DWORD *)(a9 + 4 * v17) = 1065353216;
          *(_DWORD *)(a10 + 4 * v17) = 1;
          unsigned int v16 = *(_DWORD *)(a2 + 2440);
        }
      }
      ++v17;
    }
    while (v17 < v16);
  }
  return result;
}

float mfs_symData_DistanceOnUid_Tahoe(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float *a9)
{
  uint64_t v9 = *(unsigned int *)(a2 + 2440);
  if (v9)
  {
    int v11 = *(float **)(a4 + 184);
    float v12 = 0.0;
    do
    {
      float v13 = *a9++;
      float v14 = v13;
      float v15 = *v11++;
      float v12 = v12 + (float)(v14 * v15);
      --v9;
    }
    while (v9);
  }
  else
  {
    float v12 = 0.0;
  }
  return v12 * *(float *)a4;
}

float mfs_symData_DistanceOnUid(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  int v21 = 0;
  memset(v20, 0, sizeof(v20));
  uint64_t v19 = v20;
  uint64_t v12 = *(void *)(a2 + 2400);
  mfs_symData_GetCandVector(a1, a2, a3, *(_DWORD *)a2, a6, a7, (uint64_t *)&v19);
  if (!*(void *)(a2 + 2408)) {
    return 0.0;
  }
  uint64_t v13 = *(unsigned int *)(a2 + 2440);
  if (v13)
  {
    uint64_t v14 = 0;
    uint64_t v15 = a4 + 4;
    float v16 = 0.0;
    do
    {
      if (v12
        && ((uint64_t v17 = *(void *)(v12 + 8 * (v13 * (a7 - 1 - a8 + 8 * a8) + v14))) != 0
         || (uint64_t v17 = *(void *)(v12 + 8 * (v13 * (a7 - 1) + v14))) != 0
         || (uint64_t v17 = *(void *)(v12 + 8 * v14)) != 0))
      {
        float v16 = v16
            + (float)(*(float *)(v17
                               + 4
                               * (*((unsigned __int8 *)v19 + v14)
                                + ((unint64_t)*(unsigned __int8 *)(v15 + v14) << 7)))
                    * *(float *)(*(void *)(a4 + 184) + 4 * v14));
      }
      else if (*(unsigned __int8 *)(v15 + v14) != *((unsigned __int8 *)v19 + v14))
      {
        float v16 = v16 + *(float *)(*(void *)(a4 + 184) + 4 * v14);
      }
      ++v14;
    }
    while (v13 != v14);
  }
  else
  {
    float v16 = 0.0;
  }
  return v16 * *(float *)a4;
}

float mfs_symData_Distance(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(void *)(a1 + 2408)) {
    return 0.0;
  }
  uint64_t v3 = *(unsigned int *)(a1 + 2440);
  if (v3)
  {
    uint64_t v4 = 0;
    float v5 = 0.0;
    do
    {
      if (*(unsigned __int8 *)(a2 + 4 + v4) != *(unsigned __int8 *)(a3 + v4)) {
        float v5 = v5 + *(float *)(*(void *)(a2 + 184) + 4 * v4);
      }
      ++v4;
    }
    while (v3 != v4);
  }
  else
  {
    float v5 = 0.0;
  }
  return v5 * *(float *)a2;
}

double mfs_symData_GenreDivergence(uint64_t a1, unsigned int a2, unsigned int a3, int a4, unsigned int a5, unsigned int a6)
{
  if (!*(void *)(a1 + 12128)) {
    return 0.0;
  }
  unsigned int v6 = *(unsigned __int8 *)(*(void *)(a1 + 12144) + a6);
  double result = 0.0;
  if (v6 != a5)
  {
    if (a5 <= v6) {
      unsigned int v8 = *(unsigned __int8 *)(*(void *)(a1 + 12144) + a6);
    }
    else {
      unsigned int v8 = a5;
    }
    if (a5 < v6) {
      unsigned int v6 = a5;
    }
    LODWORD(result) = *(_DWORD *)(*(void *)(*(void *)(*(void *)(a1 + 8 * a2 + 12152) + 8 * a3) + 8 * a4)
                                + 4 * (int)(v6 + ((int)((v8 - 1) * v8) >> 1)));
  }
  *(float *)&double result = (float)(*(float *)&result * *(float *)(a1 + 4 * a2 + 12176)) * *(float *)(a1 + 12188);
  return result;
}

void mfs_InitParam(uint64_t a1)
{
  uint64_t v2 = a1 + 24116;
  uint64_t v3 = (_OWORD *)(a1 + 8292);
  bzero((void *)a1, 0x62D0uLL);
  *(void *)(v2 + 1064) = 20;
  *(_DWORD *)(v2 + 1080) = 40;
  *(void *)(v2 + 1072) = 0x2800000000;
  *(void *)(a1 + 25216) = 100000;
  *(void *)(a1 + 25208) = 0;
  *(_DWORD *)(v2 + 1024) = 0;
  *(_DWORD *)(a1 + 7624) = 0;
  *(_DWORD *)(a1 + 8388) = 0;
  *(void *)(a1 + 8224) = -4294965296;
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)(a1 + 8232) = _D0;
  *(int32x2_t *)(a1 + 8240) = vdup_n_s32(0x7D0u);
  *(void *)(a1 + 8876) = 0x3C00000001;
  *(void *)(a1 + 8884) = 0x142480000;
  *(void *)(a1 + 8892) = 0;
  *(_OWORD *)(a1 + 8160) = xmmword_20D6AEDE0;
  *(_DWORD *)(a1 + 8900) = 50;
  *(_DWORD *)(a1 + 8912) = -1;
  *(void *)(a1 + 8904) = 0xBF80000040600000;
  *(_DWORD *)(a1 + 8928) = 3;
  *(void *)(a1 + 8932) = 1056964608;
  *(_DWORD *)(a1 + 8248) = 1084227584;
  *(_OWORD *)(a1 + 8256) = xmmword_20D6AB850;
  *(void *)(a1 + 8284) = 0x3F8000003F000000;
  *(void *)(a1 + 8272) = 0x100000001;
  *uint64_t v3 = xmmword_20D6B4260;
  *(void *)(a1 + 8308) = 0x3F80000040000000;
  *(_OWORD *)((char *)v3 + 24) = xmmword_20D6B4270;
  *(_DWORD *)(a1 + 8332) = 0;
  *(_OWORD *)((char *)v3 + 52) = xmmword_20D6B4280;
  *(void *)(a1 + 8376) = 1148846080;
  *(_OWORD *)(a1 + 25144) = xmmword_20D6AEE20;
  *(_DWORD *)(a1 + 8384) = 1092616192;
  *(int32x2_t *)(a1 + 25160) = vdup_n_s32(0xFA0u);
  *(_DWORD *)(v2 + 1052) = 2000;
  *(_DWORD *)(a1 + 8952) = 0;
  *(_OWORD *)(a1 + 8560) = xmmword_20D6B4290;
  *(_DWORD *)(a1 + 8576) = 12;
  MFS__InitVParam((_DWORD *)a1);
  unint64_t v9 = 0;
  *(_DWORD *)(a1 + 7672) = 7562861;
  *(_DWORD *)(a1 + 8180) = 1056964608;
  *(_DWORD *)uint64_t v2 = 1065353216;
  unsigned int v10 = (float *)(a1 + 24124);
  v11.i64[0] = 255;
  v11.i64[1] = 255;
  do
  {
    int32x2_t v12 = vmovn_s64((int64x2_t)vcgtq_u64(v11, (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v9), (int8x16_t)xmmword_20D6072C0)));
    if (v12.i8[0]) {
      *(v10 - 1) = 1.0 / (float)(v9 + 1);
    }
    if (v12.i8[4]) {
      *unsigned int v10 = 1.0 / (float)(v9 + 2);
    }
    v9 += 2;
    v10 += 2;
  }
  while (v9 != 256);
}

void mfs_DeInitParam(uint64_t a1, _DWORD *a2)
{
  if (*((void *)a2 + 1453))
  {
    if (*((void *)a2 + 1483))
    {
      int v4 = a2[33];
      if (v4 >= 1)
      {
        uint64_t v5 = 0;
        unsigned int v6 = (char *)(a2 + 2846);
        do
        {
          if (a2[v5 + 56] && *(void *)v6)
          {
            heap_Free(*(void **)(a1 + 8), *(void *)v6);
            *(void *)unsigned int v6 = 0;
            *((_DWORD *)v6 + 2) = 0;
            int v4 = a2[33];
          }
          ++v5;
          v6 += 24;
        }
        while (v5 < v4);
      }
    }
  }
  MFS__DeInitVParam(a1, a2);
  uint64_t v7 = *((void *)a2 + 999);
  if (v7)
  {
    heap_Free(*(void **)(a1 + 8), v7);
    *((void *)a2 + 999) = 0;
  }
  uint64_t v8 = *((void *)a2 + 3012);
  if (v8)
  {
    heap_Free(*(void **)(a1 + 8), v8);
    *((void *)a2 + 3012) = 0;
  }
  uint64_t v9 = *((void *)a2 + 3013);
  if (v9) {
    heap_Free(*(void **)(a1 + 8), v9);
  }
  bzero(a2, 0x62D0uLL);
}

uint64_t mfs_kld_lookup(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, float *a6, uint64_t a7, uint64_t a8)
{
  float v9 = 0.0;
  if (a3 != a4)
  {
    int v12 = *(_DWORD *)(a1 + 12256);
    if (v12 == 2)
    {
      __int16 v39 = 0;
      uint64_t v13 = *(unsigned __int8 **)(a1 + 12264);
      int v14 = *(_DWORD *)&v13[8 * (int)a5 - 4];
      uint64_t v15 = (v14 + a4);
      uint64_t v16 = *(unsigned __int16 *)&v13[4 * v15 + 32];
      if (v16 == 0xFFFF)
      {
        MFS__log_select_Error(a2, 0, (uint64_t)"Error in KLD partitioning - Target MCP index belongs to a removed partition", a4, a5, (uint64_t)a6, a7, a8);
        return 2229280783;
      }
      uint64_t v24 = v14 + a3;
      int v25 = *(unsigned __int16 *)&v13[4 * v24 + 32];
      if (v25 == 0xFFFF)
      {
        MFS__log_select_Diag(a2, 0, (uint64_t)"Warning: Suspicious KLD partitioning - Candidate MCP index belongs to a removed partition");
        float v9 = 1.0e10;
      }
      else
      {
        if (v25 == v16)
        {
          unsigned int v28 = *v13;
          uint64_t v27 = v13 + 32;
          uint64_t v26 = v28;
          unsigned int v29 = *(unsigned __int16 *)&v27[4 * v15 + 2];
          unsigned int v30 = *(unsigned __int16 *)&v27[4 * v24 + 2];
          if (v29 >= v30) {
            unsigned int v31 = v30;
          }
          else {
            unsigned int v31 = v29;
          }
          if (v29 > v30) {
            unsigned int v30 = v29;
          }
          uint64_t v32 = *(void *)(a1 + 12272) + 16 * v16;
          mfs_calcKLDIdx(v26, *(void *)(a1 + 12280) + *(unsigned int *)(v32 + 12), v30 + ~*(_DWORD *)(v32 + 8) + *(_DWORD *)(v32 + 8) * v31 - ((v31 + v31 * v31) >> 1), &v39);
          float v33 = *(float *)v32;
          float v34 = *(float *)(v32 + 4);
          LOWORD(v35) = v39;
          float v36 = (float)v35;
        }
        else
        {
          MFS__log_select_Diag(a2, 0, (uint64_t)"Warning: Suspicious KLD partitioning - Candidate and target MCP index do not belong to the same partition");
          uint64_t v37 = (float *)(*(void *)(a1 + 12272) + 16 * v16);
          float v33 = *v37;
          float v34 = v37[1];
          float v36 = (float)~(-1 << **(_DWORD **)(a1 + 12264));
        }
        float v9 = v33 + (float)(v34 * v36);
      }
    }
    else
    {
      uint64_t v17 = (int)a5;
      if (a3 >= a4) {
        int v19 = a4;
      }
      else {
        int v19 = a3;
      }
      if (a3 <= a4) {
        int v20 = a4;
      }
      else {
        int v20 = a3;
      }
      int v18 = *(_DWORD *)(*(void *)(a1 + 56) + 4 * (int)a5);
      unsigned int v21 = v20 + ~v18 + v18 * v19 - ((v19 + v19 * v19) >> 1);
      if (v12 == 1)
      {
        __int16 v38 = 0;
        uint64_t v22 = a1 + 12264;
        mfs_calcKLDIdx(*(unsigned __int8 *)(a1 + 12264), *(void *)(a1 + 12264 + 8 * (int)a5 + 8), v21, &v38);
        LOWORD(v23) = v38;
        float v9 = *(float *)(v22 + 4 * v17 + 88) + (float)(*(float *)(v22 + 4 * v17 + 128) * (float)v23);
      }
      else
      {
        float v9 = *(float *)(*(void *)(a1 + 8 * (int)a5 + 12264) + 4 * v21);
      }
    }
  }
  uint64_t result = 0;
  if (a6) {
    *a6 = v9;
  }
  return result;
}

uint64_t mfs_calcKLDIdx(uint64_t result, uint64_t a2, unsigned int a3, _WORD *a4)
{
  if (result)
  {
    if (result == 16)
    {
      unsigned int v4 = bswap32(*(unsigned __int16 *)(a2 + 2 * a3)) >> 16;
    }
    else if (result == 8)
    {
      LOWORD(v4) = *(unsigned __int8 *)(a2 + a3);
    }
    else
    {
      int v5 = 0;
      unsigned int v4 = 0;
      unint64_t v6 = (unint64_t)(result * a3) >> 3;
      uint64_t v7 = *(unsigned __int8 *)(a2 + v6);
      int v8 = ((_BYTE)result * (_BYTE)a3) & 7;
      do
      {
        if ((++v5 & 7) != 0)
        {
          int v9 = v8 + 1;
          uint64_t v10 = v7;
        }
        else
        {
          int v9 = 0;
          LODWORD(v6) = v6 + 1;
          uint64_t v10 = *(unsigned __int8 *)(a2 + v6);
        }
        unsigned int v4 = (2 * v4) | (v7 << v8 >> 7) & 1;
        uint64_t v7 = v10;
        int v8 = v9;
      }
      while (result != v5);
    }
  }
  else
  {
    LOWORD(v4) = 0;
  }
  *a4 = v4;
  return result;
}

uint64_t mfs_GetLeafIndex(uint64_t a1, int a2, int a3)
{
  if (a2) {
    uint64_t v3 = (unsigned int *)(*(void *)(a1 + 8 * a2 + 72) + 4 * a3);
  }
  else {
    uint64_t v3 = (unsigned int *)(a1 + 8);
  }
  return *v3;
}

BOOL mfs_IsPerceptualInvariantState(uint64_t a1, uint64_t a2, int *a3)
{
  int v6 = *a3;
  if (v6 + 1 < *(_DWORD *)(a2 + 608))
  {
    mfs_Ling_IsInvariantPhoneme(a1, *(void *)(a2 + 8), *(_DWORD *)(*(void *)(a2 + 600) + 528 * (v6 + 1)));
    int v6 = *a3;
  }
  if (v6 >= 2)
  {
    mfs_Ling_IsInvariantPhoneme(a1, *(void *)(a2 + 8), *(_DWORD *)(*(void *)(a2 + 600) + 528 * (v6 - 1)));
    int v6 = *a3;
  }
  uint64_t v7 = *(void *)(a2 + 8);
  return mfs_Ling_IsInvariantPhoneme(a1, v7, v6);
}

float mfs_ProbSynthNoDegradation(uint64_t a1, int a2)
{
  if (a2 < 1)
  {
    int v5 = 1;
  }
  else
  {
    uint64_t v2 = *(void *)(a1 + 24);
    int v3 = *(_DWORD *)(v2 + 3056);
    unsigned int v4 = (char *)(*(void *)(a1 + 48) + *(int *)(v2 + 1528));
    int v5 = 1;
    int v6 = a2;
    do
    {
      char v8 = *v4++;
      char v7 = v8;
      if ((v8 & 4) != 0 && **(float **)(*(void *)(v2 + 3120) + 8 * v3) > 4.7) {
        ++v5;
      }
      v3 += (v7 & 4) >> 2;
      --v6;
    }
    while (v6);
  }
  return (float)(a2 - v5) / (float)a2;
}

float mfs_PhoneticContextCost(unsigned __int8 *a1, unsigned __int8 *a2, float a3)
{
  int v3 = a2[1];
  float v4 = 5000.5;
  if (v3 != 1) {
    float v4 = 0.5;
  }
  if (a1[1] != v3) {
    float v4 = v4 + 100.0;
  }
  if (*a1 != *a2) {
    float v4 = v4 + 20.0;
  }
  if (a1[2] != a2[2]) {
    float v4 = v4 + 20.0;
  }
  return v4 * a3;
}

uint64_t mfs_CleanUpTgtVect(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a3 + 24) = 0;
  return 0;
}

uint64_t mfs_loc_AddMainCandidates(uint64_t a1, uint64_t a2, _DWORD *a3, void *a4, int a5, void *a6, signed int a7, unsigned int a8, float a9, int a10, int a11, unsigned __int8 *a12, void *a13, uint64_t a14, int a15)
{
  UNICORN__mfs_S32Vect_Clear((void *)a14);
  if (a13)
  {
    uint64_t Ids = mfs_Harch_GetIds(a13, (void *)a14);
    if ((Ids & 0x80000000) != 0) {
      return Ids;
    }
  }
  else
  {
    uint64_t Ids = 0;
  }
  if (*(_DWORD *)(a14 + 16))
  {
    uint64_t v22 = 0;
    while (1)
    {
      uint64_t Ids = mfs_loc_AddCandidate(a2, a6, a7, *(_DWORD *)(*(void *)(a14 + 8) + 4 * v22), a12, a15, a9, 1.0);
      if ((Ids & 0x80000000) != 0) {
        break;
      }
      if (++v22 >= (unint64_t)*(unsigned int *)(a14 + 16)) {
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    UNICORN__mfs_S32Vect_Clear((void *)a14);
    int v28 = *(_DWORD *)(a6[1] + 32 * a7 + 16);
    if (!a10
      || a3[2197]
      || (uint64_t Ids = mfs_IbAddtoVect(a1, a2, (uint64_t)a3, 0, 1, a5, *(_DWORD *)(a4[10] + 4 * a5), v28, a9, 1.0, 0.25, a8, a6, a7, a12, a15), (Ids & 0x80000000) == 0))
    {
      if (a3[2198]
        && ((unsigned int v23 = *(_DWORD *)(a6[1] + 32 * a7 + 16) - v28, v23 <= 0xC7) ? (v24 = v23 >= a8) : (v24 = 1),
            !v24 && *(_DWORD *)(a4[45] + 4 * a5)))
      {
        uint64_t v25 = 0;
        while (1)
        {
          uint64_t Ids = mfs_IbAddtoVect(a1, a2, (uint64_t)a3, 0, 1, a5, *(_DWORD *)(*(void *)(a4[44] + 8 * a5) + 4 * v25), v28, a9, 1.0, 0.25, a8, a6, a7, a12, a15);
          if ((Ids & 0x80000000) != 0) {
            break;
          }
          if (++v25 >= (unint64_t)*(unsigned int *)(a4[45] + 4 * a5)) {
            goto LABEL_21;
          }
        }
      }
      else
      {
LABEL_21:
        if (!a11 && a5 >= 3)
        {
          if (a3[2196])
          {
            UNICORN__mfs_S32Vect_Clear((void *)a14);
            uint64_t Ids = mfs_StateNGram_GetAlternatives(a2 + 2280, *(_DWORD *)(a4[10] + 4 * (a5 - 1)), -1, a5, (void *)a14);
            if ((Ids & 0x80000000) == 0)
            {
              if (*(_DWORD *)(a14 + 16))
              {
                uint64_t v26 = 0;
                while (1)
                {
                  uint64_t Ids = mfs_IbAddtoVect(a1, a2, (uint64_t)a3, 0, 1, a5, *(_DWORD *)(*(void *)(a14 + 8) + 4 * v26), v28, a9, 1.0, 0.25, a8, a6, a7, a12, a15);
                  if ((Ids & 0x80000000) != 0) {
                    break;
                  }
                  if (++v26 >= (unint64_t)*(unsigned int *)(a14 + 16)) {
                    goto LABEL_29;
                  }
                }
              }
              else
              {
LABEL_29:
                UNICORN__mfs_S32Vect_Clear((void *)a14);
              }
            }
          }
        }
      }
    }
  }
  return Ids;
}

uint64_t mfs_loc_AddCandidate(uint64_t a1, void *a2, signed int a3, unsigned int a4, unsigned __int8 *a5, int a6, float a7, float a8)
{
  unsigned int v25 = 0;
  v24[0] = 0;
  v24[1] = 0;
  unsigned int v23 = (float *)v24;
  mfs_getUnitDataFromMfsData((unsigned __int8 *)a1, a4, (uint64_t *)&v23);
  uint64_t result = 0;
  int v17 = a5[1];
  float v18 = 5000.5;
  if (v17 != 1) {
    float v18 = 0.5;
  }
  if (*((unsigned __int8 *)v23 + 13) != v17) {
    float v18 = v18 + 100.0;
  }
  if (*((unsigned __int8 *)v23 + 12) != *a5) {
    float v18 = v18 + 20.0;
  }
  if (*((unsigned __int8 *)v23 + 14) != a5[2]) {
    float v18 = v18 + 20.0;
  }
  float v19 = v18 * 0.0071174;
  if ((float)(1.0 / (float)(v19 / 0.0071174)) > a7)
  {
    float v20 = 1.0 - v19;
    uint64_t result = mfs_CostList_Add(a1, a2, a3, a4, *(void *)(a1 + 2384), *(_DWORD *)(a1 + 2392), &v25, (float)((float)-(float)(*v23 * a8) * (float)(1.0 - v19)) + 1000.0);
    if ((result & 0x80001FFF) == 0x80000002)
    {
      float v21 = *(float *)(*(void *)(a2[1] + 32 * a3) + 8 * v25 + 4);
      if (a6) {
        float v22 = v21 * 0.5;
      }
      else {
        float v22 = v21 + (float)((float)-(float)(*v23 * a8) * v20);
      }
      mfs_CostList_UpdateCost((uint64_t)a2, a3, v25, v22);
      return 0;
    }
  }
  return result;
}

uint64_t mfs_IbAddtoVect(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, float a9, float a10, float a11, unsigned int a12, void *a13, signed int a14, unsigned __int8 *a15, int a16)
{
  unint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v46 = a2 + 1552;
  float v22 = (uint64_t *)(a2 + 1552 + 8 * a5);
  uint64_t v24 = *v22;
  unsigned int v23 = v22 + 10;
  int v44 = *(_DWORD *)(*(void *)(v24 + 8 * a6) + 8 * a7);
  unsigned int v43 = *(_DWORD *)(a2 + 1096) - 1;
  int v52 = 0;
  uint64_t v45 = a5;
  uint64_t v25 = a6;
  uint64_t v26 = a7;
  memset(v51, 0, sizeof(v51));
  v49[1] = 0;
  float v50 = v51;
  uint64_t v48 = (float *)v49;
  v49[0] = 0;
  do
  {
    unsigned int v27 = *(_DWORD *)(a13[1] + 32 * a14 + 16);
    if (v20 >= *(unsigned int *)(*(void *)(*(void *)(v46 + 8 * v45) + 8 * v25) + 8 * v26 + 4) || v27 - a8 >= a12) {
      break;
    }
    unsigned int v29 = *(_DWORD *)(*v23 + 4 * (v44 + v20));
    mfs_getUnitDataFromMfsData((unsigned __int8 *)a2, v29, (uint64_t *)&v48);
    if (v29 >= v43) {
      goto LABEL_22;
    }
    uint64_t v30 = a3;
    if (*(_DWORD *)(a3 + 8888) && v27 >= 0xA && *v48 != -999.0 && *v48 <= *(float *)(a3 + 8884)) {
      goto LABEL_22;
    }
    if (!a4 || (int v32 = *(_DWORD *)(a3 + 8968)) == 0)
    {
      uint64_t v21 = mfs_loc_AddCandidate(a2, a13, a14, v29, a15, a16, a9, a10);
      goto LABEL_22;
    }
    if (v32 == 2)
    {
      if (a15[1] != *((unsigned __int8 *)v48 + 13)) {
        goto LABEL_22;
      }
      unsigned int v33 = *(_DWORD *)a2;
      uint64_t v34 = a1;
      uint64_t v35 = a2;
      uint64_t v30 = a3;
    }
    else
    {
      unsigned int v33 = *(_DWORD *)a2;
      uint64_t v34 = a1;
      uint64_t v35 = a2;
    }
    uint64_t CandVector = mfs_symData_GetCandVector(v34, v35, v30, v33, v29, a6, (uint64_t *)&v50);
    if ((CandVector & 0x80000000) != 0) {
      return CandVector;
    }
    float v37 = mfs_symData_Distance(a2, a4, (uint64_t)v50);
    mfs_loc_AddCandidate_f2(a2, a13, a14, v29, v37, a11);
    uint64_t v21 = 0;
LABEL_22:
    ++v20;
  }
  while ((v21 & 0x80000000) == 0);
  return v21;
}

uint64_t mfs_VennDiaGrams_Tahoe(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6, int a7, int a8, float a9, unsigned int a10, void *a11, signed int a12, unsigned __int8 a13, int a14)
{
  unint64_t v17 = 0;
  uint64_t CandVector = 0;
  uint64_t v47 = *MEMORY[0x263EF8340];
  unsigned int v44 = 0;
  unsigned int v36 = *(_DWORD *)(a2 + 1096) - 1;
  uint64_t v19 = a2 + 1552;
  unint64_t v20 = (uint64_t *)(a2 + 1552 + 8 * a4);
  uint64_t v22 = *v20;
  uint64_t v21 = v20 + 10;
  uint64_t v39 = a4;
  uint64_t v38 = a5;
  uint64_t v37 = a7;
  int v35 = *(_DWORD *)(*(void *)(v22 + 8 * a5) + 8 * a7);
  v43[0] = 0;
  v43[1] = 0;
  uint64_t v41 = v45;
  uint64_t v42 = (float *)v43;
  int v46 = 0;
  memset(v45, 0, sizeof(v45));
  int v23 = *(_DWORD *)(a11[1] + 32 * a12 + 16);
  do
  {
    if (v17 >= *(unsigned int *)(*(void *)(*(void *)(v19 + 8 * v39) + 8 * v38) + 8 * v37 + 4) || v23 - a8 >= a10) {
      break;
    }
    unsigned int v25 = *(_DWORD *)(*v21 + 4 * (v35 + v17));
    if (*(_DWORD *)(a3 + 8356) == 1)
    {
      uint64_t CandVector = mfs_symData_GetCandVector(a1, a2, a3, *(_DWORD *)a2, *(_DWORD *)(*v21 + 4 * (v35 + v17)), a5, (uint64_t *)&v41);
      BOOL v26 = *((unsigned __int8 *)v41 + a14) == a13;
    }
    else
    {
      BOOL v26 = 1;
    }
    mfs_getUnitDataFromMfsData((unsigned __int8 *)a2, v25, (uint64_t *)&v42);
    BOOL v27 = v25 >= v36 || !v26;
    if (v27 || *v42 != -999.0 && *(_DWORD *)(a3 + 8888) && *v42 <= *(float *)(a3 + 8884)) {
      goto LABEL_21;
    }
    unsigned int v44 = 0;
    float v28 = a9;
    if (*((unsigned __int8 *)v42 + 13) == *(unsigned __int8 *)(a6 + 1)) {
      goto LABEL_18;
    }
    if (a4 == 1)
    {
      int v29 = *(_DWORD *)(a3 + 8260);
      if ((v29 & 0x80000000) == 0)
      {
        float v28 = (float)v29 + a9;
LABEL_18:
        if ((mfs_CostList_Add(a2, a11, a12, v25, *(void *)(a2 + 2384), *(_DWORD *)(a2 + 2392), &v44, v28) & 0x80001FFF) == 0x80000002) {
          mfs_CostList_UpdateCost((uint64_t)a11, a12, v44, *(float *)(*(void *)(a11[1] + 32 * a12) + 8 * v44 + 4) + -1.0);
        }
      }
    }
    int v23 = *(_DWORD *)(a11[1] + 32 * a12 + 16);
LABEL_21:
    ++v17;
  }
  while ((CandVector & 0x80000000) == 0);
  return CandVector;
}

uint64_t mfs_loc_AddCandidate_f2(uint64_t a1, void *a2, signed int a3, unsigned int a4, float a5, float a6)
{
  unsigned int v11 = 0;
  uint64_t result = mfs_CostList_Add(a1, a2, a3, a4, *(void *)(a1 + 2384), *(_DWORD *)(a1 + 2392), &v11, a5);
  if ((result & 0x80001FFF) == 0x80000002) {
    return mfs_CostList_UpdateCost((uint64_t)a2, a3, v11, (float)(*(float *)(*(void *)(a2[1] + 32 * a3) + 8 * v11 + 4) + a5) * a6);
  }
  return result;
}

uint64_t mfs_IbAddtoVect_MCP(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, unsigned int a8, void *a9, signed int a10, uint64_t a11)
{
  uint64_t v11 = 0;
  int v36 = 0;
  int v12 = (int *)(*(void *)(*((void *)a2 + 195) + 8 * a5) + 8 * a6);
  int v13 = *v12;
  unint64_t v14 = v12[1];
  v35[0] = 0;
  v35[1] = 0;
  int v33 = v13;
  uint64_t v34 = (float *)v35;
  unsigned int v15 = *(_DWORD *)(a9[1] + 32 * a10 + 16);
  if (v14) {
    BOOL v16 = v15 - a7 >= a8;
  }
  else {
    BOOL v16 = 1;
  }
  if (!v16)
  {
    uint64_t v11 = 0;
    unsigned int v20 = a2[274] - 1;
    uint64_t v21 = *((void *)a2 + 205);
    unint64_t v22 = 1;
    do
    {
      unsigned int v23 = *(_DWORD *)(v21 + 4 * (v33 + v22 - 1));
      mfs_getUnitDataFromMfsData((unsigned __int8 *)a2, v23, (uint64_t *)&v34);
      if (v23 < v20)
      {
        BOOL v24 = *(_DWORD *)(a3 + 8888) && v15 >= 0xA;
        if (!v24 || (*v34 != -999.0 ? (BOOL v25 = *v34 <= *(float *)(a3 + 8884)) : (BOOL v25 = 0), !v25))
        {
          int v26 = *(unsigned __int8 *)(a11 + 1);
          if (v26 == *((unsigned __int8 *)v34 + 13))
          {
            float v27 = mfs_symData_DistanceOnUid(a1, (uint64_t)a2, a3, a4, *a2, v23, a5, v26);
            uint64_t v11 = mfs_CostList_Pad((uint64_t)a2, a9, a10, v23, *((void *)a2 + 298), a2[598], &v36, v27);
          }
          unsigned int v15 = *(_DWORD *)(a9[1] + 32 * a10 + 16);
        }
      }
      if ((v11 & 0x80000000) != 0) {
        break;
      }
      if (v22 >= v14) {
        break;
      }
      ++v22;
    }
    while (v15 - a7 < a8);
  }
  return v11;
}

uint64_t mfs_IbAddtoVect_LF0(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, unsigned int a8, uint64_t a9, signed int a10, uint64_t a11, void *a12, unsigned int a13)
{
  uint64_t v13 = 0;
  unint64_t v14 = (int *)(*(void *)(*((void *)a2 + 196) + 8 * a5) + 8 * a6);
  unint64_t v15 = v14[1];
  int v37 = *v14;
  uint64_t v16 = *(void *)(a9 + 8) + 32 * a10;
  uint64_t v31 = *(void *)v16;
  v41[0] = 0;
  v40[0] = 0;
  v40[1] = 0;
  uint64_t v39 = (float *)v40;
  unsigned int v17 = *(_DWORD *)(v16 + 16);
  if (v15) {
    BOOL v18 = v17 - a7 >= a8;
  }
  else {
    BOOL v18 = 1;
  }
  if (!v18)
  {
    uint64_t v13 = 0;
    int v35 = 0;
    unsigned int v22 = a2[274] - 1;
    uint64_t v23 = *((void *)a2 + 206);
    unint64_t v24 = 1;
    do
    {
      unsigned int v25 = *(_DWORD *)(v23 + 4 * (v37 + v24 - 1));
      mfs_getUnitDataFromMfsData((unsigned __int8 *)a2, v25, (uint64_t *)&v39);
      if (v25 < v22)
      {
        BOOL v26 = *(_DWORD *)(a3 + 8888) && v17 >= 0xA;
        if (!v26 || (*v39 != -999.0 ? (BOOL v27 = *v39 <= *(float *)(a3 + 8884)) : (BOOL v27 = 0), !v27))
        {
          if (*(unsigned __int8 *)(a11 + 1) == *((unsigned __int8 *)v39 + 13))
          {
            unsigned int v38 = 0;
            int IsNodeInList = mfs_CostList_IsNodeInList(a9, a10, v25, (uint64_t)a2, &v38);
            float v29 = mfs_symData_DistanceOnUid(a1, (uint64_t)a2, a3, a4, *a2, v25, a5, *(unsigned __int8 *)(a11 + 1));
            if (IsNodeInList)
            {
              *(float *)(v31 + 8 * v38 + 4) = (float)(v29 + *(float *)(v31 + 8 * v38 + 4)) * 0.025;
            }
            else
            {
              uint64_t v13 = mfs_CostList_Pad((uint64_t)a2, a12, a13, v25, *((void *)a2 + 298), a2[598], v41, v29);
              ++v35;
            }
          }
          unsigned int v17 = *(_DWORD *)(*(void *)(a9 + 8) + 32 * a10 + 16) + v35;
        }
      }
      if ((v13 & 0x80000000) != 0) {
        break;
      }
      if (v24 >= v15) {
        break;
      }
      ++v24;
    }
    while (v17 - a7 < a8);
  }
  mfs_CostList_UpdateCostEnd_inlined(a9, a10);
  return v13;
}

uint64_t mfs_IbAddtoVect_DUR(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, unsigned int a8, uint64_t a9, signed int a10, uint64_t a11, void *a12, signed int a13, unsigned int a14)
{
  uint64_t v14 = 0;
  unint64_t v15 = (int *)(*(void *)(*((void *)a2 + 194) + 8 * a5) + 8 * a6);
  unint64_t v16 = v15[1];
  int v44 = *v15;
  uint64_t v17 = *(void *)(a9 + 8) + 32 * a10;
  uint64_t v38 = *(void *)v17;
  uint64_t v18 = a12[1] + 32 * a13;
  uint64_t v36 = *(void *)v18;
  int v46 = (float *)v47;
  v47[0] = 0;
  unsigned int v19 = a2[274];
  v48[0] = 0;
  v47[1] = 0;
  unsigned int v20 = *(_DWORD *)(v18 + 16) + *(_DWORD *)(v17 + 16);
  if (v16) {
    BOOL v21 = v20 - a7 >= a8;
  }
  else {
    BOOL v21 = 1;
  }
  if (!v21)
  {
    uint64_t v14 = 0;
    int v42 = 0;
    unsigned int v26 = v19 - 1;
    uint64_t v27 = *((void *)a2 + 204);
    unint64_t v28 = 1;
    while (1)
    {
      unsigned int v29 = *(_DWORD *)(v27 + 4 * (v44 + v28 - 1));
      mfs_getUnitDataFromMfsData((unsigned __int8 *)a2, v29, (uint64_t *)&v46);
      if (v29 >= v26) {
        goto LABEL_25;
      }
      if (*(_DWORD *)(a3 + 8888) && v20 >= 0xA && *v46 != -999.0 && *v46 <= *(float *)(a3 + 8884)) {
        goto LABEL_25;
      }
      if (*(unsigned __int8 *)(a11 + 1) == *((unsigned __int8 *)v46 + 13))
      {
        unsigned int v45 = 0;
        int v32 = a12;
        if (mfs_CostList_IsNodeInList(a9, a10, v29, (uint64_t)a2, &v45))
        {
          float v33 = mfs_symData_DistanceOnUid(a1, (uint64_t)a2, a3, a4, *a2, v29, a5, *(unsigned __int8 *)(a11 + 1));
          uint64_t v34 = v45;
          uint64_t v35 = v38;
        }
        else
        {
          int IsNodeInList = mfs_CostList_IsNodeInList((uint64_t)a12, a13, v29, (uint64_t)a2, &v45);
          float v33 = mfs_symData_DistanceOnUid(a1, (uint64_t)a2, a3, a4, *a2, v29, a5, *(unsigned __int8 *)(a11 + 1));
          if (!IsNodeInList)
          {
            uint64_t v14 = mfs_CostList_Pad((uint64_t)a2, a12, a14, v29, *((void *)a2 + 298), a2[598], v48, v33);
            ++v42;
            goto LABEL_24;
          }
          uint64_t v34 = v45;
          uint64_t v35 = v36;
        }
        *(float *)(v35 + 8 * v34 + 4) = (float)(v33 + *(float *)(v35 + 8 * v34 + 4)) * 0.025;
      }
      else
      {
        int v32 = a12;
      }
LABEL_24:
      unsigned int v20 = *(_DWORD *)(*(void *)(a9 + 8) + 32 * a10 + 16) + v42 + *(_DWORD *)(v32[1] + 32 * a13 + 16);
LABEL_25:
      if ((v14 & 0x80000000) == 0 && v28 < v16)
      {
        ++v28;
        if (v20 - a7 < a8) {
          continue;
        }
      }
      break;
    }
  }
  mfs_CostList_UpdateCostEnd_inlined(a9, a10);
  return v14;
}

double mfs_JCostProb(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5)
{
  uint64_t v8 = *(void *)(a1 + 2152);
  uint64_t v9 = *(void *)(a1 + 2136);
  int v10 = *(_DWORD *)(a2 + 2064);
  if (v10 == 1)
  {
    uint64_t v18 = *(void *)(a2 + 2048);
    uint64_t v19 = *(void *)(v18 + 8 * (int)a3);
    if (v19)
    {
      uint64_t v20 = *(void *)(v18 + 8 * (int)a4);
      if (v20)
      {
        double result = 0.0;
        if (!*(unsigned char *)(v19 + 1) && !*(unsigned char *)v20) {
          *(float *)&double result = *(float *)(*(void *)(*(void *)(a2 + 2072) + 8 * a5) + 8)
        }
                            * *(float *)(v8
                                       + ((4 * *(unsigned __int8 *)(v19 + 3)) | ((unint64_t)*(unsigned __int8 *)(v20 + 2) << 10)));
        float v16 = *(float *)(*(void *)(*(void *)(a2 + 2072) + 8 * a5) + 4);
        unint64_t v17 = *(unsigned __int16 *)(v19 + 6) + ((unint64_t)*(unsigned __int16 *)(v20 + 4) << 9);
        goto LABEL_13;
      }
      uint64_t v27 = *(void *)(a2 + 1928);
    }
    else
    {
      uint64_t v27 = *(void *)(a2 + 1928);
    }
    MFS__log_select_Diag(v27, 3, (uint64_t)"Unexpected NULL JoinElem for UID %d");
    return 0.0;
  }
  else
  {
    if (v10 == 2)
    {
      uint64_t v12 = *(void *)(a1 + 12224);
      unsigned int v13 = *(_DWORD *)(v12 + 12 * (int)a3);
      double result = 0.0;
      if (v13 <= 0xFF)
      {
        unsigned int v15 = *(unsigned __int16 *)(v12 + 12 * (int)a4 + 6);
        if (v15 <= 0xFF) {
          *(float *)&double result = *(float *)(*(void *)(*(void *)(a2 + 2072) + 8 * a5) + 8)
        }
                            * *(float *)(v8 + 4 * (v13 + (v15 << 8)));
      }
      float v16 = *(float *)(*(void *)(*(void *)(a2 + 2072) + 8 * a5) + 4);
      unint64_t v17 = *(unsigned __int16 *)(v12 + 12 * (int)a3 + 4)
          + ((unint64_t)*(unsigned __int16 *)(v12 + 12 * (int)a4 + 8) << 9);
LABEL_13:
      *(float *)&double result = *(float *)&result + (float)(v16 * *(float *)(v9 + 4 * v17));
      return result;
    }
    int v21 = *(_DWORD *)(a1 + 2164);
    int v22 = *(_DWORD *)(a1 + 2148);
    uint64_t v23 = *(void *)(a2 + 2032);
    int v24 = *(_DWORD *)(a2 + 2060);
    uint64_t v25 = *(void *)(v23 + 8 * (v24 & a3));
    if (v25)
    {
      while (*(_DWORD *)v25 != a3)
      {
        uint64_t v25 = *(void *)(v25 + 16);
        if (!v25) {
          goto LABEL_17;
        }
      }
      unsigned int v26 = *(_DWORD *)(v25 + 8);
    }
    else
    {
LABEL_17:
      MFS__log_select_Diag(*(void *)(a2 + 1928), 3, (uint64_t)"Unexpected NULL JoinElem returned for UID %d");
      unsigned int v26 = 0;
      uint64_t v23 = *(void *)(a2 + 2032);
      int v24 = *(_DWORD *)(a2 + 2060);
    }
    uint64_t v28 = *(void *)(v23 + 8 * (v24 & a4));
    if (v28)
    {
      while (*(_DWORD *)v28 != a4)
      {
        uint64_t v28 = *(void *)(v28 + 16);
        if (!v28) {
          goto LABEL_23;
        }
      }
      unsigned int v29 = *(_DWORD *)(v28 + 4);
    }
    else
    {
LABEL_23:
      MFS__log_select_Diag(*(void *)(a2 + 1928), 3, (uint64_t)"Unexpected NULL JoinElem returned for UID %d");
      unsigned int v29 = 0;
    }
    uint64_t v30 = *(void *)(a1 + 1072);
    if (!*(_DWORD *)(v30 + 8392) && ((v26 | v29) & 2) != 0)
    {
      BOOL v34 = *(_DWORD *)(v30 + 8892) == 0;
      double result = 0.0;
    }
    else
    {
      float v31 = *(float *)(v8 + 4 * (((v26 >> 14) & 0x1FF) + ((v29 >> 14) & 0x1FF) * v21));
      float v32 = *(float *)(*(void *)(*(void *)(a2 + 2072) + 8 * a5) + 8);
      float v33 = v31 * v32;
      *(float *)&double result = v31 + v32;
      BOOL v34 = *(_DWORD *)(v30 + 8892) == 0;
      if (v34) {
        *(float *)&double result = v33;
      }
    }
    float v35 = *(float *)(v9 + 4 * (((v26 >> 2) & 0xFFF) + ((v29 >> 2) & 0xFFF) * v22));
    float v36 = *(float *)(*(void *)(*(void *)(a2 + 2072) + 8 * a5) + 4);
    if (v34) {
      *(float *)&double result = *(float *)&result + (float)(v36 * v35);
    }
    else {
      *(float *)&double result = v35 + (float)(*(float *)&result + v36);
    }
  }
  return result;
}

uint64_t mfs_BPESymData_Init_Obersee(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 8344) != 4)
  {
    unsigned int v10 = *(_DWORD *)(a2 + 2440);
LABEL_6:
    uint64_t v9 = 0;
    *(_DWORD *)(a2 + 1928) = v10;
    *(void *)(a2 + 1904) = *(void *)(a1 + 23624);
    uint64_t v11 = *(int **)(a1 + 23864);
    *(void *)(a2 + 1920) = *(void *)(a1 + 16904);
    int v12 = *v11;
    *(void *)(a2 + 1912) = v11 + 1;
    *(unsigned char *)(a2 + 1932) = v12;
    *(_DWORD *)(a2 + 1936) = *(_DWORD *)(a1 + 23872);
    return v9;
  }
  unsigned int v8 = *(_DWORD *)(a2 + 2424);
  if ((v8 & 7) == 0)
  {
    unsigned int v10 = v8 >> 3;
    goto LABEL_6;
  }
  MFS__log_select_Error(*(void *)(a2 + 2408), 1, (uint64_t)"%s, only byte-aligned row are supported for BPE of bit-packed symdata", a4, a5, a6, a7, a8);
  return 2229281034;
}

uint64_t mfs_BPESymData_DeInit_Obersee(uint64_t result)
{
  *(void *)(result + 1904) = 0;
  return result;
}

uint64_t mfs_BPESymDataCache_Init_Obersee(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a2 + 1072);
  if ((*(_DWORD *)(v9 + 8344) - 3) > 1)
  {
    MFS__log_select_Error(a3, 1, (uint64_t)"%s: compression mode %d not supported!", a4, a5, a6, a7, a8);
    return 2229280775;
  }
  else
  {
    uint64_t v12 = heap_Alloc(*(void *)(a3 + 8), 24);
    if (v12)
    {
      *(void *)(v12 + 8) = a2;
      unsigned int v13 = mfs_symData_recoverFeatVectBPEBitPack_Obersee;
      if (*(_DWORD *)(v9 + 8344) == 3) {
        unsigned int v13 = mfs_symData_recoverFeatVectBPE_Obersee;
      }
      *(void *)(v12 + 16) = v13;
      return mfs_DataCachePair_Init_Obersee(a1, 0x800u, 0x40u, (uint64_t)mfs_symdata_BPECache_callback, v12, a3);
    }
    else
    {
      return 2229280774;
    }
  }
}

uint64_t mfs_symData_recoverFeatVectBPE_Obersee(uint64_t a1, int a2, unsigned int a3, uint64_t a4)
{
  return mfs_symdata_BPEUncompressRow((uint64_t *)(a1 + 1904), a2, a3, a4);
}

uint64_t mfs_symData_recoverFeatVectBPEBitPack_Obersee(uint64_t a1, int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(unsigned int *)(a1 + 2440);
  uint64_t result = mfs_symdata_BPEUncompressRow((uint64_t *)(a1 + 1904), a2, a3, (uint64_t)v14);
  if ((result & 0x80000000) == 0 && v6)
  {
    uint64_t v8 = 0;
    unsigned int v9 = 0;
    int v10 = 0;
    do
    {
      int v11 = *(unsigned __int8 *)(*(void *)(a1 + 2416) + v8);
      unint64_t v12 = (unint64_t)v9 >> 3;
      int v13 = v14[v12] << 8;
      if ((v10 + v11) >= 9) {
        v13 |= v14[v12 + 1];
      }
      *(unsigned char *)(a4 + v8) = (unsigned __int16)(v13 << v10) >> (16 - v11);
      v9 += v11;
      int v10 = v9 & 7;
      ++v8;
    }
    while (v6 != v8);
  }
  return result;
}

uint64_t mfs_symdata_BPECache_callback(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  return 0;
}

double mfs_BPESymDataCache_DeInit_Obersee(uint64_t a1, uint64_t a2)
{
  heap_Free(*(void **)(a2 + 8), *(void *)(a1 + 8));
  return mfs_DataCachePair_DeInit_Obersee(a1, a2);
}

uint64_t mfs_symData_recoverCompactFeatVect_Obersee(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned char *__dst, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD *)(*(void *)(a1 + 1072) + 8344);
  if ((v8 - 3) >= 2)
  {
    if (v8 == 1)
    {
      uint64_t v13 = *(unsigned int *)(a1 + 2440);
      if (v13)
      {
        uint64_t v14 = 0;
        unsigned int v15 = *(_DWORD *)(a1 + 2424) * a4;
        uint64_t v16 = *(void *)(a1 + 2432) + (v15 >> 3);
        unsigned int v17 = v15 & 7;
        do
        {
          int v18 = v15 & 7;
          int v19 = *(unsigned __int8 *)(*(void *)(a1 + 2416) + v14);
          unint64_t v20 = (unint64_t)v17 >> 3;
          int v21 = *(unsigned __int8 *)(v16 + v20) << 8;
          if ((v18 + v19) >= 9) {
            v21 |= *(unsigned __int8 *)(v16 + v20 + 1);
          }
          __dst[v14] = (unsigned __int16)(v21 << v18) >> (16 - v19);
          unsigned int v15 = v17 + v19;
          ++v14;
          unsigned int v17 = v15;
        }
        while (v13 != v14);
      }
      return 0;
    }
    else
    {
      MFS__log_select_Error(a2, 1, (uint64_t)"%s: compression mode %d not supported!", a4, (uint64_t)__dst, a6, a7, a8);
      return 2229280775;
    }
  }
  else
  {
    unsigned int v9 = *(unsigned int **)(a3 + 8);
    char v10 = *(unsigned char *)(a1 + 1932);
    unsigned int v11 = ((0xFFFFFFFF >> -v10) & a4) + *(_DWORD *)(*(void *)(a1 + 1912) + 4 * (a4 >> v10));
    *unsigned int v9 = a4 >> v10;
    v9[1] = v11;
    return mfs_DataCachePair_ReadAndWrite_Obersee(a3, v11, __dst);
  }
}

uint64_t mfs_symData_recoverCompactNFeatVect_Obersee(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a4;
  uint64_t v43 = *MEMORY[0x263EF8340];
  int v11 = *(_DWORD *)(*(void *)(a1 + 1072) + 8344);
  switch(v11)
  {
    case 4:
      char v21 = *(unsigned char *)(a1 + 1932);
      int v22 = a3 >> v21;
      int v23 = *(_DWORD *)(*(void *)(a1 + 1912) + 4 * (a3 >> v21));
      int v24 = (uint64_t *)(a1 + 1904);
      unsigned int v25 = ((0xFFFFFFFF >> -v21) & a3) + v23;
      unsigned int v26 = 0;
      if (a4)
      {
        uint64_t v27 = *(unsigned __int8 **)(a1 + 2416);
        uint64_t v28 = a4;
        do
        {
          int v29 = *v27++;
          v26 += v29;
          --v28;
        }
        while (v28);
      }
      if ((v26 & 7) != 0) {
        unsigned int v30 = (v26 >> 3) + 1;
      }
      else {
        unsigned int v30 = v26 >> 3;
      }
      uint64_t result = mfs_symdata_BPEUncompressNBytes(v24, v22, v25, v30, (uint64_t)v42);
      if (v9 && (result & 0x80000000) == 0)
      {
        uint64_t v31 = 0;
        unsigned int v32 = 0;
        int v33 = 0;
        do
        {
          int v34 = *(unsigned __int8 *)(*(void *)(a1 + 2416) + v31);
          unint64_t v35 = (unint64_t)v32 >> 3;
          int v36 = v42[v35] << 8;
          if ((v33 + v34) >= 9) {
            v36 |= v42[v35 + 1];
          }
          *(unsigned char *)(a5 + v31) = (unsigned __int16)(v36 << v33) >> (16 - v34);
          v32 += v34;
          int v33 = v32 & 7;
          ++v31;
        }
        while (v9 != v31);
      }
      break;
    case 3:
      char v37 = *(unsigned char *)(a1 + 1932);
      int v38 = a3 >> v37;
      int v39 = *(_DWORD *)(*(void *)(a1 + 1912) + 4 * (a3 >> v37));
      uint64_t v40 = (uint64_t *)(a1 + 1904);
      unsigned int v41 = ((0xFFFFFFFF >> -v37) & a3) + v39;
      return mfs_symdata_BPEUncompressNBytes(v40, v38, v41, a4, a5);
    case 1:
      if (a4)
      {
        uint64_t v12 = 0;
        unsigned int v13 = *(_DWORD *)(a1 + 2424) * a3;
        uint64_t v14 = *(void *)(a1 + 2432) + (v13 >> 3);
        unsigned int v15 = v13 & 7;
        do
        {
          int v16 = v13 & 7;
          int v17 = *(unsigned __int8 *)(*(void *)(a1 + 2416) + v12);
          unint64_t v18 = (unint64_t)v15 >> 3;
          int v19 = *(unsigned __int8 *)(v14 + v18) << 8;
          if ((v16 + v17) >= 9) {
            v19 |= *(unsigned __int8 *)(v14 + v18 + 1);
          }
          *(unsigned char *)(a5 + v12) = (unsigned __int16)(v19 << v16) >> (16 - v17);
          unsigned int v13 = v15 + v17;
          ++v12;
          unsigned int v15 = v13;
        }
        while (a4 != v12);
      }
      return 0;
    default:
      MFS__log_select_Error(a2, 1, (uint64_t)"%s, compression mode %d not supported!", a4, a5, a6, a7, a8);
      return 2229280775;
  }
  return result;
}

void mfs_symData_DistanceOnUid_PreCalcVitSymRulesForTargetVector_Obersee(uint64_t a1, int a2, unsigned int a3, unsigned __int8 *a4, unsigned __int8 *a5, void *a6)
{
  uint64_t v6 = *(unsigned int *)(a1 + 2440);
  uint64_t v7 = *(void *)(a1 + 2400);
  if (v7 && a5[v6] > a3)
  {
    if (v6)
    {
      unsigned int v8 = v6 * (a2 - 1);
      unsigned int v9 = v6 * (a2 + 4 * a3 - 1);
      char v10 = *(uint64_t **)(a1 + 2400);
      do
      {
        uint64_t v11 = *(void *)(v7 + 8 * v9);
        if (v11 || (uint64_t v11 = *(void *)(v7 + 8 * v8)) != 0 || (uint64_t v11 = *v10) != 0)
        {
          if (*a4 >= *a5) {
            uint64_t v11 = 0;
          }
          else {
            v11 += 2 * *a5 * (unint64_t)*a4;
          }
        }
        *a6++ = v11;
        ++v10;
        ++a4;
        ++a5;
        ++v8;
        ++v9;
        --v6;
      }
      while (v6);
    }
  }
  else if (v6)
  {
    bzero(a6, 8 * v6);
  }
}

float mfs_symData_DistanceOnUid_Obersee(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  uint64_t v11 = *(unsigned int *)(a1 + 2440);
  mfs_symData_recoverCompactFeatVect_Obersee(a1, a2, a7, a4, __dst, a6, a7, a8);
  if (v11)
  {
    uint64_t v13 = 0;
    float v14 = 0.0;
    while (1)
    {
      uint64_t v15 = __dst[v13];
      if (*(unsigned __int8 *)(a3 + 4 + v13) != v15)
      {
        uint64_t v16 = *(void *)(a6 + 8 * v13);
        if (!v16)
        {
          uint64_t v17 = *(void *)(a3 + 184);
LABEL_8:
          float v12 = *(float *)(v17 + 4 * v13);
          float v14 = v14 + (float)(v12 * 10.0);
          goto LABEL_9;
        }
        uint64_t v17 = *(void *)(a3 + 184);
        if (v15 >= *(unsigned __int8 *)(a5 + v13)) {
          goto LABEL_8;
        }
        LOWORD(v12) = *(_WORD *)(v16 + 2 * v15);
        float v12 = (float)LODWORD(v12);
        float v14 = v14 + (float)(v12 * *(float *)(v17 + 4 * v13));
      }
LABEL_9:
      if (v11 == ++v13) {
        return v14 / 10.0;
      }
    }
  }
  float v14 = 0.0;
  return v14 / 10.0;
}

uint64_t mfs_symdata_BPEUncompressRow(uint64_t *a1, int a2, unsigned int a3, uint64_t a4)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  float v4 = (unsigned char *)(a1[2] + a3);
  uint64_t v5 = *a1;
  char v20 = 0;
  memset(v19, 0, sizeof(v19));
  int v6 = *((_DWORD *)a1 + 6);
  unsigned int v7 = v6 - 1;
  if (v6 == 1)
  {
    uint64_t result = 0;
    unsigned int v8 = 0;
  }
  else
  {
    unsigned int v8 = 0;
    unsigned int v9 = 0;
    unsigned int v10 = 0;
    uint64_t v11 = v5 + (a2 << 9);
    do
    {
      uint64_t v12 = v10 - 1;
      uint64_t v13 = &v4[v9];
      if (v10)
      {
        float v14 = (unsigned __int8 *)v19 + v12;
      }
      else
      {
        LODWORD(v12) = 0;
        ++v9;
        float v14 = v13;
      }
      uint64_t v15 = *v14;
      int v16 = *(unsigned __int8 *)(v11 + v15);
      if (v15 == v16)
      {
        *(unsigned char *)(a4 + v8++) = v15;
        unsigned int v10 = v12;
      }
      else
      {
        uint64_t v17 = (char *)v19 + v12;
        *uint64_t v17 = *(unsigned char *)(v11 + 256 + v15);
        unsigned int v10 = v12 + 2;
        v17[1] = v16;
      }
    }
    while (v10 <= 0xFF && v8 < v7);
    if (v10 >= 0x101) {
      uint64_t result = 2229281034;
    }
    else {
      uint64_t result = 0;
    }
    if (v10) {
      float v4 = (char *)v19 + v10 - 1;
    }
    else {
      v4 += v9;
    }
  }
  *(unsigned char *)(a4 + v8) = *v4;
  return result;
}

uint64_t mfs_symdata_BPEUncompressNBytes(uint64_t *a1, int a2, unsigned int a3, unsigned int a4, uint64_t a5)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t v5 = a1[2];
  uint64_t v6 = *a1;
  char v20 = 0;
  memset(v19, 0, sizeof(v19));
  if (!a4) {
    return 0;
  }
  unint64_t v7 = 0;
  unsigned int v8 = 0;
  unsigned int v9 = 0;
  uint64_t v10 = v5 + a3;
  uint64_t v11 = v6 + (a2 << 9);
  do
  {
    uint64_t v12 = v9 - 1;
    uint64_t v13 = (unsigned __int8 *)(v10 + v8);
    if (v9)
    {
      float v14 = (unsigned __int8 *)v19 + v12;
    }
    else
    {
      LODWORD(v12) = 0;
      ++v8;
      float v14 = v13;
    }
    uint64_t v15 = *v14;
    int v16 = *(unsigned __int8 *)(v11 + v15);
    if (v15 == v16)
    {
      *(unsigned char *)(a5 + v7++) = v15;
      unsigned int v9 = v12;
    }
    else
    {
      uint64_t v17 = (char *)v19 + v12;
      *uint64_t v17 = *(unsigned char *)(v11 + 256 + v15);
      unsigned int v9 = v12 + 2;
      v17[1] = v16;
    }
  }
  while (v9 <= 0xFF && v7 < a4);
  if (v9 >= 0x100) {
    return 2229281034;
  }
  else {
    return 0;
  }
}

uint64_t mfs_CostList_QSelect(uint64_t a1, int a2, int a3, uint64_t (*a4)(char *, char *), unsigned int a5)
{
  uint64_t v25 = a5 * a3;
  unsigned int v6 = a2 - 1;
  if (a2 != 1)
  {
    unsigned int v9 = 0;
    unsigned int v28 = 0;
    unsigned int v26 = (char *)(a1 + v25);
    do
    {
      uint64_t v10 = (char *)(a1 + v6 * a3);
      if (a3)
      {
        int v11 = a3;
        uint64_t v12 = (char *)(a1 + v6 * a3);
        uint64_t v13 = v26;
        do
        {
          char v14 = *v13;
          *v13++ = *v12;
          *v12++ = v14;
          --v11;
        }
        while (v11);
      }
      unsigned int v15 = v9;
      if (v9 < v6)
      {
        uint64_t v16 = v9;
        unsigned int v15 = v9;
        do
        {
          uint64_t v17 = (char *)(a1 + (v16 * a3));
          if ((a4(v17, v10) & 0x80000000) != 0)
          {
            if (a3)
            {
              unint64_t v18 = (char *)(a1 + v15 * a3);
              int v19 = a3;
              do
              {
                char v20 = *v17;
                *v17++ = *v18;
                *v18++ = v20;
                --v19;
              }
              while (v19);
            }
            ++v15;
          }
          ++v16;
        }
        while (v16 != v6);
      }
      if (a3)
      {
        uint64_t v21 = (char *)(a1 + v15 * a3);
        int v22 = a3;
        do
        {
          char v23 = *v10;
          *v10++ = *v21;
          *v21++ = v23;
          --v22;
        }
        while (v22);
      }
      if (v15 == a5) {
        break;
      }
      if (v15 >= a5) {
        unsigned int v6 = v15 - 1;
      }
      else {
        unsigned int v9 = v15 + 1;
      }
      ++v28;
    }
    while (v28 < v6);
  }
  return a1 + v25;
}

uint64_t mfs_Viterbi_Init_Obersee(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = 2229280778;
  bzero((void *)a1, 0x308uLL);
  *(void *)(a1 + 712) = 0;
  *(void *)a1 = a2;
  fastallo_Init((_WORD *)(a1 + 24), *(void *)(a2 + 8), 4096);
  *(void *)(a1 + 8) = a4;
  *(void *)(a1 + 16) = a3;
  *(void *)(a1 + 760) = a5;
  *(void *)(a1 + 604) = 0;
  *(void *)(a1 + 612) = 0;
  *(void *)(a1 + 596) = 0;
  *(_DWORD *)(a1 + 720) = 1065353216;
  uint64_t v11 = *(void *)(a3 + 1072);
  *(float *)(a1 + 724) = *(float *)(v11 + 8384) + 1.0;
  *(float *)(a1 + 728) = *(float *)(v11 + 8384) + 1.0;
  *(_DWORD *)(a1 + 732) = 0;
  *(_DWORD *)(a1 + 736) = *(_DWORD *)(v11 + 8384);
  *(_DWORD *)(a1 + 740) = *(_DWORD *)(v11 + 8384);
  *(_DWORD *)(a1 + 744) = 1065353216;
  *(float *)(a1 + 748) = *(float *)(v11 + 8384) + 1.0;
  *(float *)(a1 + 752) = *(float *)(v11 + 8384) + 1.0;
  uint64_t v12 = *(unsigned int *)(v11 + 8240);
  uint64_t v13 = heap_Alloc(*(void *)(*(void *)a1 + 8), 32 * v12);
  *(void *)(a1 + 624) = v13;
  if (v13)
  {
    uint64_t v14 = heap_Alloc(*(void *)(*(void *)a1 + 8), 32 * v12);
    *(void *)(a1 + 632) = v14;
    if (v14)
    {
      *(_DWORD *)(a1 + 660) = v12;
      *(_DWORD *)(a1 + 680) = v12;
      uint64_t v15 = heap_Alloc(*(void *)(*(void *)a1 + 8), 4 * v12);
      *(void *)(a1 + 672) = v15;
      if (v15)
      {
        uint64_t v16 = heap_Alloc(*(void *)(*(void *)a1 + 8), *(unsigned int *)(a1 + 680));
        *(void *)(a1 + 704) = v16;
        if (v16)
        {
          uint64_t v17 = heap_Alloc(*(void *)(*(void *)a1 + 8), 4 * *(unsigned int *)(a1 + 680));
          *(void *)(a1 + 688) = v17;
          if (v17)
          {
            uint64_t v18 = heap_Alloc(*(void *)(*(void *)a1 + 8), 4 * *(unsigned int *)(a1 + 680));
            *(void *)(a1 + 696) = v18;
            if (v18)
            {
              uint64_t v19 = heap_Alloc(*(void *)(*(void *)a1 + 8), 2 * *(unsigned int *)(a1 + 680));
              *(void *)(a1 + 640) = v19;
              if (v19)
              {
                *(_WORD *)(a1 + 592) = 200;
                uint64_t v20 = heap_Alloc(*(void *)(*(void *)a1 + 8), 400);
                *(void *)(a1 + 584) = v20;
                if (v20)
                {
                  MFS__log_select_Diag(*(void *)a1, 1, (uint64_t)"S8_X2B Viterbi Decoder Variant 2 has been selected\n");
                  return 0;
                }
              }
            }
          }
        }
      }
    }
  }
  return v10;
}

uint64_t mfs_Viterbi_Reset_Obersee(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 596) = a2;
  *(_DWORD *)(a1 + 612) = a2;
  *(_DWORD *)(a1 + 616) = 0;
  *(_DWORD *)(a1 + 648) = 0;
  *(void *)(a1 + 600) = 0;
  *(_DWORD *)(a1 + 608) = 0;
  MFS__log_select_Diag(*(void *)a1, 1, (uint64_t)"Viterbi regular search and emission, from=%d to=?\n");
  return 0;
}

uint64_t mfs_Viterbi_DeInit_Obersee(uint64_t a1)
{
  if (*(void *)(a1 + 8))
  {
    fastallo_Terminate((void *)(a1 + 24));
    uint64_t v2 = *(void *)(a1 + 624);
    if (v2)
    {
      heap_Free(*(void **)(*(void *)a1 + 8), v2);
      *(void *)(a1 + 624) = 0;
    }
    uint64_t v3 = *(void *)(a1 + 632);
    if (v3)
    {
      heap_Free(*(void **)(*(void *)a1 + 8), v3);
      *(void *)(a1 + 632) = 0;
    }
    *(_DWORD *)(a1 + 680) = 0;
    uint64_t v4 = *(void *)(a1 + 672);
    if (v4)
    {
      heap_Free(*(void **)(*(void *)a1 + 8), v4);
      *(void *)(a1 + 672) = 0;
    }
    uint64_t v5 = *(void *)(a1 + 704);
    if (v5)
    {
      heap_Free(*(void **)(*(void *)a1 + 8), v5);
      *(void *)(a1 + 704) = 0;
    }
    uint64_t v6 = *(void *)(a1 + 688);
    if (v6)
    {
      heap_Free(*(void **)(*(void *)a1 + 8), v6);
      *(void *)(a1 + 688) = 0;
    }
    uint64_t v7 = *(void *)(a1 + 696);
    if (v7)
    {
      heap_Free(*(void **)(*(void *)a1 + 8), v7);
      *(void *)(a1 + 696) = 0;
    }
    uint64_t v8 = *(void *)(a1 + 640);
    if (v8)
    {
      heap_Free(*(void **)(*(void *)a1 + 8), v8);
      *(void *)(a1 + 640) = 0;
    }
    uint64_t v9 = *(void *)(a1 + 584);
    if (v9)
    {
      heap_Free(*(void **)(*(void *)a1 + 8), v9);
      *(void *)(a1 + 584) = 0;
      *(_WORD *)(a1 + 592) = 0;
    }
    *(void *)(a1 + 8) = 0;
  }
  return 0;
}

uint64_t mfs_Viterbi_DumpHeapStats(uint64_t *a1)
{
  int v2 = 79 * *(_DWORD *)(*(void *)(a1[2] + 1072) + 8240);
  MFS__log_select_Diag(*a1, 9, (uint64_t)"memstats:viterbi mem usage: %d bytes (prev&cur timeslice+unitid+bSLL+joinENDLF0+MCP)\n");
  int UsedMemory = fastallo_GetUsedMemory((uint64_t)(a1 + 3));
  MFS__log_select_Diag(*a1, 9, (uint64_t)"memstats:viterbi backtrace mem usage: %d bytes from %d entries (%d states,%d bytes overhead)\n");
  return (UsedMemory + v2);
}

uint64_t mfs_Viterbi_FillPrevStateCacheTables(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 656))
  {
    unint64_t v2 = 0;
    uint64_t v3 = *(void *)(a2 + 32);
    do
    {
      uint64_t v4 = v3 + 24 * *(unsigned __int16 *)(*(void *)(result + 640) + 2 * v2);
      *(_DWORD *)(*(void *)(result + 672) + 4 * v2) = *(_DWORD *)(v4 + 4);
      uint64_t v5 = *(void *)(v4 + 16);
      *(_DWORD *)(*(void *)(result + 688) + 4 * v2) = *(_DWORD *)(v5 + 12);
      *(_DWORD *)(*(void *)(result + 696) + 4 * v2) = *(unsigned __int16 *)(v5 + 16);
      *(unsigned char *)(*(void *)(result + 704) + v2++) = *(unsigned char *)(v5 + 28);
    }
    while (v2 < *(unsigned int *)(result + 656));
  }
  return result;
}

uint64_t mfs_Viterbi_DecodeState_MCP_S9_LF0_S8_X2B_Obersee(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  v258[0] = 0;
  uint64_t v4 = *(void **)(a1 + 16);
  uint64_t v5 = v4[134];
  uint64_t v6 = a1 + 24;
  uint64_t v7 = *(_DWORD **)(a1 + 672);
  uint64_t v8 = *(unsigned __int8 **)(a1 + 704);
  float v9 = *(float *)(v5 + 8388);
  float v10 = *(float *)(v5 + 8172);
  uint64_t v255 = v4[267];
  uint64_t v256 = v4[269];
  uint64_t v11 = *(void *)(*(void *)(a1 + 8) + 2072);
  uint64_t v12 = *(void *)(a2 + 32);
  unsigned int v13 = -1431655765 * ((unint64_t)(*(void *)(a2 + 40) - v12) >> 3);
  int v14 = *(_DWORD *)(a1 + 616);
  if (v14)
  {
    int v15 = *(_DWORD *)(v5 + 8564);
    unsigned int v16 = *(_DWORD *)(a1 + 612) + v14;
    uint64_t v253 = *(void *)(a2 + 32);
    if (v15)
    {
      unsigned int v17 = v16 + ~*(_DWORD *)(a1 + 596);
      unsigned int v18 = *(unsigned __int16 *)(a1 + 592);
      if (v17 >= v18)
      {
        unsigned __int16 v19 = v18 + 100;
        *(_WORD *)(a1 + 592) = v19;
        int v243 = v15;
        uint64_t v21 = v11;
        uint64_t v22 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 584), 2 * v19);
        uint64_t v11 = v21;
        uint64_t v2 = a2;
        int v15 = v243;
        *(void *)(a1 + 584) = v22;
        if (!v22) {
          return 10;
        }
      }
    }
    else
    {
      unsigned int v17 = 0;
    }
    *(_WORD *)(*(void *)(a1 + 584) + 2 * v17) = 0;
    float v34 = 0.0;
    float v35 = 0.0;
    if (*(_DWORD *)(v5 + 8264)) {
      float v35 = *(float *)(v2 + 64);
    }
    uint64_t v246 = v6;
    uint64_t v247 = v17;
    if (*(_DWORD *)(v5 + 8268))
    {
      int v252 = *(_DWORD *)(v2 + 68);
      float v34 = (float)*(int *)(v2 + 72);
    }
    else
    {
      int v252 = 0;
    }
    uint64_t v36 = *(void *)(a1 + 8);
    float v37 = *(float *)(*(void *)(v36 + 2088) + 4 * v16);
    float v38 = *(float *)(*(void *)(v36 + 2096) + 4 * v16);
    int v39 = *(float **)(v11 + 8 * v16);
    float v40 = v37 * *v39;
    float v41 = v37 * v39[2];
    float v42 = v37 * v39[1];
    MFS__log_select_Diag(*(void *)a1, 20, (uint64_t)"Join cost %d\n");
    MFS__log_select_Diag(*(void *)a1, 20, (uint64_t)"Normalized ADJ weight %f\n");
    MFS__log_select_Diag(*(void *)a1, 20, (uint64_t)"Normalized LF0 weight %f\n");
    MFS__log_select_Diag(*(void *)a1, 20, (uint64_t)"Normalized MCP weight %f\n");
    uint64_t v43 = *(void *)(a1 + 624);
    uint64_t v44 = *(void *)(a1 + 632);
    *(void *)(a1 + 624) = v44;
    *(void *)(a1 + 632) = v43;
    unsigned int v45 = *(_DWORD *)(a1 + 656);
    *(_DWORD *)(a1 + 652) = v45;
    unsigned int v46 = *(_DWORD *)(v2 + 60);
    if (v46 >= v13) {
      unsigned int v46 = v13;
    }
    *(_DWORD *)(a1 + 656) = v46;
    if (v46)
    {
      int v244 = v15;
      uint64_t v242 = v2;
      unint64_t v47 = 0;
      int v254 = 0;
      unsigned int v48 = 0;
      uint64_t v49 = a1 + 744;
      uint64_t v50 = v45 & 3;
      int v51 = v252;
      float v52 = v38;
      float v53 = (float)v252;
      unsigned int v245 = v16 % 3;
      uint64_t v248 = 4 * ((v45 & 3) - 1) + 4;
      HIWORD(v54) = 19224;
      float v55 = 10000000.0;
      uint64_t v56 = v253;
      uint64_t v251 = v43;
      float v250 = v52;
      float v249 = v35;
      do
      {
        LODWORD(v258[0]) = 0;
        float v57 = 0.0;
        uint64_t v257 = v47;
        if (v35 != 0.0)
        {
          float v58 = v55;
          mfs_getBeginEndPitch_Obersee(*(void *)(a1 + 16), *(void *)(v56 + 24 * v47 + 16), (float *)v258, 0);
          unint64_t v47 = v257;
          float v55 = v58;
          float v35 = v249;
          uint64_t v50 = v45 & 3;
          float v52 = v250;
          int v51 = v252;
          uint64_t v43 = v251;
          uint64_t v56 = v253;
          HIWORD(v54) = WORD1(v258[0]);
          if (*(float *)v258 >= 0.0) {
            float v57 = *(float *)v258;
          }
          else {
            float v57 = 0.0;
          }
          *(float *)int v258 = v57;
        }
        uint64_t v59 = *(int **)(v56 + 24 * v47 + 16);
        if (*(_DWORD *)(v5 + 8268)) {
          int v60 = *((unsigned __int8 *)v59 + 27);
        }
        else {
          int v60 = 0;
        }
        uint64_t v61 = *(unsigned int **)(a1 + 688);
        float v62 = *(unsigned int **)(a1 + 696);
        LOWORD(v54) = *(_WORD *)(v56 + 24 * v47 + 8);
        int v63 = *v59;
        unint64_t v64 = *((unsigned __int8 *)v59 + 28);
        if (v64 <= 2)
        {
          uint64_t v65 = 4 * v64;
          do
          {
            *(float *)(v49 + v65) = (float)(v9 * *(float *)(v49 + v65 - 12)) + (float)(v40 * *(float *)(v49 + v65 - 24));
            v65 += 4;
          }
          while (v65 != 12);
        }
        float v66 = (float)((float)(1.0 - v37) * (float)LODWORD(v54)) / 100.0;
        unint64_t v67 = v49 + 4 * v64;
        uint64_t v68 = v255 + ((unint64_t)*((unsigned __int16 *)v59 + 10) << 11);
        uint64_t v69 = v256 + ((unint64_t)*((unsigned __int16 *)v59 + 9) << 10);
        float v70 = 10000000.0 - v66;
        if (v51)
        {
          if (v50)
          {
            float v71 = (unsigned int *)((char *)v61 + v248);
            unint64_t v72 = *(unsigned __int16 **)(a1 + 640);
            uint64_t v73 = (unsigned int *)((char *)v62 + v248);
            uint64_t v74 = v50;
            float v75 = v7;
            uint64_t v76 = v8;
            while (1)
            {
              unsigned int v78 = *v72++;
              uint64_t v77 = v78;
              float v79 = *(float *)(v44 + 32 * v78);
              if (v79 > v70) {
                break;
              }
              unsigned int v80 = *v61++;
              float v81 = *(float *)(v67 + 4 * *v76) + (float)(v41 * *(float *)(v69 + 4 * v80));
              unsigned int v82 = *v62++;
              float v83 = v81 + (float)(v42 * *(float *)(v68 + 4 * v82));
              if (v63 == *v75) {
                float v83 = 0.0;
              }
              float v84 = v79 + v83;
              int v85 = v60 - v51 + *(__int16 *)(v44 + 32 * v77 + 16);
              if (v85 < 0) {
                int v85 = -v85;
              }
              if ((float)(*(float *)(v5 + 8308) * v34) <= (float)v85) {
                float v84 = v84 + (float)((float)(*(float *)(v5 + 8312) * (float)v85) / v53);
              }
              if (v84 < v70)
              {
                float v70 = v84;
                unsigned int v48 = v77;
              }
              ++v76;
              ++v75;
              if (!--v74)
              {
                float v62 = v73;
                uint64_t v61 = v71;
                unsigned int v86 = v50;
                goto LABEL_78;
              }
            }
          }
          else
          {
            unsigned int v86 = 0;
LABEL_78:
            if (v86 < v45)
            {
              uint64_t v110 = *(void *)(a1 + 640);
              int v111 = v60 - v51;
              float v112 = *(float *)(v5 + 8308) * v34;
              do
              {
                uint64_t v113 = *(unsigned __int16 *)(v110 + 2 * v86);
                uint64_t v114 = v44 + 32 * v113;
                float v115 = (float)(*(float *)(v67 + 4 * v8[v86]) + (float)(v41 * *(float *)(v69 + 4 * *v61)))
                     + (float)(v42 * *(float *)(v68 + 4 * *v62));
                if (v63 == v7[v86]) {
                  float v115 = 0.0;
                }
                float v116 = *(float *)v114 + v115;
                int v117 = v111 + *(__int16 *)(v114 + 16);
                if (v117 < 0) {
                  int v117 = -v117;
                }
                if (v112 <= (float)v117) {
                  float v116 = v116 + (float)((float)(*(float *)(v5 + 8312) * (float)v117) / v53);
                }
                if (v116 >= v70) {
                  LODWORD(v113) = v48;
                }
                else {
                  float v70 = v116;
                }
                uint64_t v118 = v44 + 32 * *(unsigned __int16 *)(v110 + 2 * (v86 + 1));
                float v119 = (float)(*(float *)(v67 + 4 * v8[v86 + 1]) + (float)(v41 * *(float *)(v69 + 4 * v61[1])))
                     + (float)(v42 * *(float *)(v68 + 4 * v62[1]));
                if (v63 == v7[v86 + 1]) {
                  float v119 = 0.0;
                }
                float v120 = *(float *)v118 + v119;
                int v121 = v111 + *(__int16 *)(v118 + 16);
                if (v121 < 0) {
                  int v121 = -v121;
                }
                if (v112 <= (float)v121) {
                  float v120 = v120 + (float)((float)(*(float *)(v5 + 8312) * (float)v121) / v53);
                }
                if (v120 < v70)
                {
                  float v70 = v120;
                  LODWORD(v113) = *(unsigned __int16 *)(v110 + 2 * (v86 + 1));
                }
                uint64_t v122 = v44 + 32 * *(unsigned __int16 *)(v110 + 2 * (v86 + 2));
                float v123 = (float)(*(float *)(v67 + 4 * v8[v86 + 2]) + (float)(v41 * *(float *)(v69 + 4 * v61[2])))
                     + (float)(v42 * *(float *)(v68 + 4 * v62[2]));
                if (v63 == v7[v86 + 2]) {
                  float v123 = 0.0;
                }
                float v124 = *(float *)v122 + v123;
                int v125 = v111 + *(__int16 *)(v122 + 16);
                if (v125 < 0) {
                  int v125 = -v125;
                }
                if (v112 <= (float)v125) {
                  float v124 = v124 + (float)((float)(*(float *)(v5 + 8312) * (float)v125) / v53);
                }
                if (v124 >= v70)
                {
                  unsigned int v48 = v113;
                }
                else
                {
                  float v70 = v124;
                  unsigned int v48 = *(unsigned __int16 *)(v110 + 2 * (v86 + 2));
                }
                uint64_t v126 = v86 + 3;
                uint64_t v127 = *(unsigned __int16 *)(v110 + 2 * v126);
                float v128 = *(float *)(v44 + 32 * v127);
                if (v128 > v70) {
                  break;
                }
                float v129 = (float)(*(float *)(v67 + 4 * v8[v126]) + (float)(v41 * *(float *)(v69 + 4 * v61[3])))
                     + (float)(v42 * *(float *)(v68 + 4 * v62[3]));
                if (v63 == v7[v126]) {
                  float v129 = 0.0;
                }
                float v130 = v128 + v129;
                int v131 = v111 + *(__int16 *)(v44 + 32 * v127 + 16);
                if (v131 < 0) {
                  int v131 = -v131;
                }
                if (v112 <= (float)v131) {
                  float v130 = v130 + (float)((float)(*(float *)(v5 + 8312) * (float)v131) / v53);
                }
                if (v130 < v70)
                {
                  float v70 = v130;
                  unsigned int v48 = v127;
                }
                v86 += 4;
                v61 += 4;
                v62 += 4;
              }
              while (v86 < v45);
            }
          }
        }
        else if (v57 == 0.0)
        {
          if (v245)
          {
            if (v50)
            {
              uint64_t v132 = (unsigned int *)((char *)v61 + v248);
              uint64_t v133 = *(unsigned __int16 **)(a1 + 640);
              size_t v134 = (unsigned int *)((char *)v62 + v248);
              uint64_t v135 = v50;
              unsigned int v136 = v7;
              int v137 = v8;
              while (1)
              {
                unsigned int v139 = *v133++;
                unsigned int v138 = v139;
                float v140 = *(float *)(v44 + 32 * v139);
                if (v140 > v70) {
                  break;
                }
                unsigned int v141 = *v137++;
                float v142 = *(float *)(v67 + 4 * v141);
                unsigned int v143 = *v61++;
                float v144 = v142 + (float)(v41 * *(float *)(v69 + 4 * v143));
                unsigned int v145 = *v62++;
                float v146 = v144 + (float)(v42 * *(float *)(v68 + 4 * v145));
                int v147 = *v136++;
                if (v63 == v147) {
                  float v146 = 0.0;
                }
                float v148 = v140 + v146;
                if (v148 < v70)
                {
                  float v70 = v148;
                  unsigned int v48 = v138;
                }
                if (!--v135)
                {
                  float v62 = v134;
                  uint64_t v61 = v132;
                  unsigned int v149 = v50;
                  goto LABEL_223;
                }
              }
            }
            else
            {
              unsigned int v149 = 0;
LABEL_223:
              if (v149 < v45)
              {
                uint64_t v203 = *(void *)(a1 + 640);
                do
                {
                  unsigned int v204 = *(unsigned __int16 *)(v203 + 2 * v149);
                  float v205 = (float)(*(float *)(v67 + 4 * v8[v149]) + (float)(v41 * *(float *)(v69 + 4 * *v61)))
                       + (float)(v42 * *(float *)(v68 + 4 * *v62));
                  if (v63 == v7[v149]) {
                    float v205 = 0.0;
                  }
                  if ((float)(*(float *)(v44 + 32 * *(unsigned __int16 *)(v203 + 2 * v149)) + v205) < v70) {
                    float v70 = *(float *)(v44 + 32 * *(unsigned __int16 *)(v203 + 2 * v149)) + v205;
                  }
                  else {
                    unsigned int v204 = v48;
                  }
                  float v206 = (float)(*(float *)(v67 + 4 * v8[v149 + 1]) + (float)(v41 * *(float *)(v69 + 4 * v61[1])))
                       + (float)(v42 * *(float *)(v68 + 4 * v62[1]));
                  if (v63 == v7[v149 + 1]) {
                    float v206 = 0.0;
                  }
                  float v207 = *(float *)(v44 + 32 * *(unsigned __int16 *)(v203 + 2 * (v149 + 1))) + v206;
                  unsigned int v208 = v149 + 2;
                  if (v207 < v70)
                  {
                    float v70 = v207;
                    unsigned int v204 = *(unsigned __int16 *)(v203 + 2 * (v149 + 1));
                  }
                  float v209 = (float)(*(float *)(v67 + 4 * v8[v208]) + (float)(v41 * *(float *)(v69 + 4 * v61[2])))
                       + (float)(v42 * *(float *)(v68 + 4 * v62[2]));
                  if (v63 == v7[v208]) {
                    float v209 = 0.0;
                  }
                  float v210 = *(float *)(v44 + 32 * *(unsigned __int16 *)(v203 + 2 * (v149 + 2))) + v209;
                  if (v210 >= v70)
                  {
                    unsigned int v48 = v204;
                  }
                  else
                  {
                    float v70 = v210;
                    unsigned int v48 = *(unsigned __int16 *)(v203 + 2 * (v149 + 2));
                  }
                  uint64_t v211 = v149 + 3;
                  float v212 = *(float *)(v44 + 32 * *(unsigned __int16 *)(v203 + 2 * v211));
                  if (v212 > v70) {
                    break;
                  }
                  float v213 = (float)(*(float *)(v67 + 4 * v8[v211]) + (float)(v41 * *(float *)(v69 + 4 * v61[3])))
                       + (float)(v42 * *(float *)(v68 + 4 * v62[3]));
                  if (v63 == v7[v211]) {
                    float v213 = 0.0;
                  }
                  float v214 = v212 + v213;
                  if (v214 < v70)
                  {
                    float v70 = v214;
                    unsigned int v48 = *(unsigned __int16 *)(v203 + 2 * v211);
                  }
                  v149 += 4;
                  v61 += 4;
                  v62 += 4;
                }
                while (v149 < v45);
              }
            }
          }
          else
          {
            BOOL v195 = *(unsigned __int16 **)(a1 + 640);
            unsigned int v48 = *v195;
            float v196 = *(float *)(v44 + 32 * *v195) + 4.0;
            if (v50)
            {
              uint64_t v197 = v50;
              uint64_t v198 = v7;
              int v199 = *(unsigned __int16 **)(a1 + 640);
              while (1)
              {
                unsigned int v201 = *v199++;
                unsigned int v200 = v201;
                float v70 = *(float *)(v44 + 32 * v201);
                if (v70 > v196) {
                  break;
                }
                if (v63 == *v198)
                {
                  unsigned int v48 = v200;
                  goto LABEL_259;
                }
                ++v198;
                if (!--v197)
                {
                  unsigned int v202 = v50;
                  goto LABEL_247;
                }
              }
            }
            else
            {
              unsigned int v202 = 0;
LABEL_247:
              while (v202 < v45)
              {
                uint64_t v215 = v202;
                if (v63 == v7[v202]) {
                  goto LABEL_257;
                }
                uint64_t v216 = v202 + 1;
                if (v63 == v7[v216] || (uint64_t v216 = (v215 + 2), v63 == v7[v216]))
                {
                  uint64_t v215 = v216;
LABEL_257:
                  unsigned int v48 = v195[v215];
                  float v70 = *(float *)(v44 + 32 * v195[v215]);
                  goto LABEL_259;
                }
                uint64_t v217 = (v215 + 3);
                float v70 = *(float *)(v44 + 32 * v195[v217]);
                if (v70 > v196) {
                  break;
                }
                if (v63 == v7[v217])
                {
                  unsigned int v48 = v195[v217];
                  goto LABEL_259;
                }
                unsigned int v202 = v215 + 4;
              }
            }
            float v70 = *(float *)(v44 + 32 * *v195) + 4.0;
          }
        }
        else if (v50)
        {
          float v87 = (unsigned int *)((char *)v61 + v248);
          char v88 = *(unsigned __int16 **)(a1 + 640);
          int v89 = (unsigned int *)((char *)v62 + v248);
          uint64_t v90 = v50;
          float v91 = v7;
          uint64_t v92 = v8;
          while (1)
          {
            unsigned int v94 = *v88++;
            uint64_t v93 = v94;
            float v95 = *(float *)(v44 + 32 * v94);
            if (v95 > v70) {
              break;
            }
            unsigned int v96 = *v61++;
            float v97 = *(float *)(v67 + 4 * *v92) + (float)(v41 * *(float *)(v69 + 4 * v96));
            unsigned int v98 = *v62++;
            float v99 = v97 + (float)(v42 * *(float *)(v68 + 4 * v98));
            if (v63 == *v91) {
              float v99 = 0.0;
            }
            float v100 = v95 + v99;
            long long v101 = (float *)(v44 + 32 * v93);
            float v102 = v101[2];
            if (v102 != 0.0)
            {
              float v103 = v102 - v57;
              float v104 = -v103;
              if (v103 >= 0.0) {
                float v104 = v103;
              }
              float v105 = v103 - (float)(v101[1] - v35);
              if (v105 < 0.0) {
                float v105 = -v105;
              }
              float v106 = v101[3];
              float v107 = v106 - v57;
              if ((float)(v106 - v57) < 0.0) {
                float v107 = -(float)(v106 - v57);
              }
              if (v106 == 0.0) {
                float v108 = 0.0;
              }
              else {
                float v108 = v107;
              }
              if (v104 > *(float *)(v5 + 8284)) {
                float v100 = v100 + (float)(*(float *)(v5 + 8288) * v104);
              }
              if (v108 > *(float *)(v5 + 8292)) {
                float v100 = v100 + (float)(*(float *)(v5 + 8296) * v108);
              }
              if (v105 > *(float *)(v5 + 8300)) {
                float v100 = v100 + (float)(*(float *)(v5 + 8304) * v105);
              }
            }
            if (v100 < v70)
            {
              float v70 = v100;
              unsigned int v48 = v93;
            }
            ++v92;
            ++v91;
            if (!--v90)
            {
              float v62 = v89;
              uint64_t v61 = v87;
              unsigned int v109 = v50;
              goto LABEL_129;
            }
          }
        }
        else
        {
          unsigned int v109 = 0;
LABEL_129:
          if (v109 < v45)
          {
            uint64_t v150 = *(void *)(a1 + 640);
            do
            {
              uint64_t v151 = *(unsigned __int16 *)(v150 + 2 * v109);
              uint64_t v152 = (float *)(v44 + 32 * v151);
              float v153 = (float)(*(float *)(v67 + 4 * v8[v109]) + (float)(v41 * *(float *)(v69 + 4 * *v61)))
                   + (float)(v42 * *(float *)(v68 + 4 * *v62));
              if (v63 == v7[v109]) {
                float v153 = 0.0;
              }
              float v154 = *v152 + v153;
              float v155 = v152[2];
              if (v155 != 0.0)
              {
                float v156 = v155 - v57;
                float v157 = -v156;
                if (v156 >= 0.0) {
                  float v157 = v156;
                }
                float v158 = v156 - (float)(v152[1] - v35);
                if (v158 < 0.0) {
                  float v158 = -v158;
                }
                float v159 = v152[3];
                float v160 = v159 - v57;
                if ((float)(v159 - v57) < 0.0) {
                  float v160 = -(float)(v159 - v57);
                }
                if (v159 == 0.0) {
                  float v161 = 0.0;
                }
                else {
                  float v161 = v160;
                }
                if (v157 > *(float *)(v5 + 8284)) {
                  float v154 = v154 + (float)(*(float *)(v5 + 8288) * v157);
                }
                if (v161 > *(float *)(v5 + 8292)) {
                  float v154 = v154 + (float)(*(float *)(v5 + 8296) * v161);
                }
                if (v158 > *(float *)(v5 + 8300)) {
                  float v154 = v154 + (float)(*(float *)(v5 + 8304) * v158);
                }
              }
              if (v154 >= v70) {
                LODWORD(v151) = v48;
              }
              else {
                float v70 = v154;
              }
              uint64_t v162 = (float *)(v44 + 32 * *(unsigned __int16 *)(v150 + 2 * (v109 + 1)));
              float v163 = (float)(*(float *)(v67 + 4 * v8[v109 + 1]) + (float)(v41 * *(float *)(v69 + 4 * v61[1])))
                   + (float)(v42 * *(float *)(v68 + 4 * v62[1]));
              if (v63 == v7[v109 + 1]) {
                float v163 = 0.0;
              }
              float v164 = *v162 + v163;
              float v165 = v162[2];
              if (v165 != 0.0)
              {
                float v166 = v165 - v57;
                float v167 = -v166;
                if (v166 >= 0.0) {
                  float v167 = v166;
                }
                float v168 = v166 - (float)(v162[1] - v35);
                if (v168 < 0.0) {
                  float v168 = -v168;
                }
                float v169 = v162[3];
                float v170 = v169 - v57;
                if ((float)(v169 - v57) < 0.0) {
                  float v170 = -(float)(v169 - v57);
                }
                if (v169 == 0.0) {
                  float v171 = 0.0;
                }
                else {
                  float v171 = v170;
                }
                if (v167 > *(float *)(v5 + 8284)) {
                  float v164 = v164 + (float)(*(float *)(v5 + 8288) * v167);
                }
                if (v171 > *(float *)(v5 + 8292)) {
                  float v164 = v164 + (float)(*(float *)(v5 + 8296) * v171);
                }
                if (v168 > *(float *)(v5 + 8300)) {
                  float v164 = v164 + (float)(*(float *)(v5 + 8304) * v168);
                }
              }
              if (v164 < v70)
              {
                float v70 = v164;
                LODWORD(v151) = *(unsigned __int16 *)(v150 + 2 * (v109 + 1));
              }
              uint64_t v172 = (float *)(v44 + 32 * *(unsigned __int16 *)(v150 + 2 * (v109 + 2)));
              float v173 = (float)(*(float *)(v67 + 4 * v8[v109 + 2]) + (float)(v41 * *(float *)(v69 + 4 * v61[2])))
                   + (float)(v42 * *(float *)(v68 + 4 * v62[2]));
              if (v63 == v7[v109 + 2]) {
                float v173 = 0.0;
              }
              float v174 = *v172 + v173;
              float v175 = v172[2];
              if (v175 != 0.0)
              {
                float v176 = v175 - v57;
                float v177 = -v176;
                if (v176 >= 0.0) {
                  float v177 = v176;
                }
                float v178 = v176 - (float)(v172[1] - v35);
                if (v178 < 0.0) {
                  float v178 = -v178;
                }
                float v179 = v172[3];
                float v180 = v179 - v57;
                if ((float)(v179 - v57) < 0.0) {
                  float v180 = -(float)(v179 - v57);
                }
                if (v179 == 0.0) {
                  float v181 = 0.0;
                }
                else {
                  float v181 = v180;
                }
                if (v177 > *(float *)(v5 + 8284)) {
                  float v174 = v174 + (float)(*(float *)(v5 + 8288) * v177);
                }
                if (v181 > *(float *)(v5 + 8292)) {
                  float v174 = v174 + (float)(*(float *)(v5 + 8296) * v181);
                }
                if (v178 > *(float *)(v5 + 8300)) {
                  float v174 = v174 + (float)(*(float *)(v5 + 8304) * v178);
                }
              }
              if (v174 >= v70)
              {
                unsigned int v48 = v151;
              }
              else
              {
                float v70 = v174;
                unsigned int v48 = *(unsigned __int16 *)(v150 + 2 * (v109 + 2));
              }
              uint64_t v182 = v109 + 3;
              uint64_t v183 = *(unsigned __int16 *)(v150 + 2 * v182);
              float v184 = *(float *)(v44 + 32 * v183);
              if (v184 > v70) {
                break;
              }
              float v185 = (float)(*(float *)(v67 + 4 * v8[v182]) + (float)(v41 * *(float *)(v69 + 4 * v61[3])))
                   + (float)(v42 * *(float *)(v68 + 4 * v62[3]));
              if (v63 == v7[v182]) {
                float v185 = 0.0;
              }
              float v186 = v184 + v185;
              unint64_t v187 = (float *)(v44 + 32 * v183);
              float v188 = v187[2];
              if (v188 != 0.0)
              {
                float v189 = v188 - v57;
                float v190 = -v189;
                if (v189 >= 0.0) {
                  float v190 = v189;
                }
                float v191 = v189 - (float)(v187[1] - v35);
                if (v191 < 0.0) {
                  float v191 = -v191;
                }
                float v192 = v187[3];
                float v193 = v192 - v57;
                if ((float)(v192 - v57) < 0.0) {
                  float v193 = -(float)(v192 - v57);
                }
                if (v192 == 0.0) {
                  float v194 = 0.0;
                }
                else {
                  float v194 = v193;
                }
                if (v190 > *(float *)(v5 + 8284)) {
                  float v186 = v186 + (float)(*(float *)(v5 + 8288) * v190);
                }
                if (v194 > *(float *)(v5 + 8292)) {
                  float v186 = v186 + (float)(*(float *)(v5 + 8296) * v194);
                }
                if (v191 > *(float *)(v5 + 8300)) {
                  float v186 = v186 + (float)(*(float *)(v5 + 8304) * v191);
                }
              }
              if (v186 < v70)
              {
                float v70 = v186;
                unsigned int v48 = v183;
              }
              v109 += 4;
              v61 += 4;
              v62 += 4;
            }
            while (v109 < v45);
          }
        }
LABEL_259:
        float v54 = v66 + v70;
        uint64_t v218 = v257;
        uint64_t v219 = v43 + 32 * v257;
        if (v54 <= (float)(v52 + v55))
        {
          *(float *)uint64_t v219 = v54;
          MemoryFromChunuint64_t k = *(void *)(a1 + 80);
          if (MemoryFromChunk)
          {
            *(void *)(a1 + 80) = *(void *)MemoryFromChunk;
          }
          else
          {
            float v221 = v55;
            MemoryFromChunuint64_t k = fastallo_AllocateMemoryFromChunk(v246, 2u, (int *)v258 + 1);
            uint64_t v218 = v257;
            float v55 = v221;
            float v35 = v249;
            uint64_t v50 = v45 & 3;
            float v52 = v250;
            int v51 = v252;
            uint64_t v43 = v251;
            uint64_t v56 = v253;
          }
          uint64_t v23 = HIDWORD(v258[0]);
          if ((v258[0] & 0x8000000000000000) != 0) {
            return v23;
          }
          ++*(_DWORD *)(a1 + 648);
          *(_DWORD *)MemoryFromChunuint64_t k = *(_DWORD *)(v56 + 24 * v218 + 4);
          *(_WORD *)(MemoryFromChunk + 4) = 0;
          uint64_t v222 = *(void *)(*(void *)(a1 + 624) + 32 * v48 + 24);
          int v223 = *(unsigned __int16 *)(v222 + 4);
          *(_WORD *)(v222 + 4) = v223 + 1;
          if (!v223) {
            ++*(_WORD *)(*(void *)(a1 + 584) + 2 * v247);
          }
          *(void *)(MemoryFromChunk + 8) = v222;
          *(void *)(v43 + 32 * v218 + 24) = MemoryFromChunk;
          if (*(_DWORD *)(v5 + 8264))
          {
            if (*(float *)v258 == 0.0)
            {
              uint64_t v226 = v44 + 32 * v48;
              *(void *)(v43 + 32 * v218 + 8) = *(void *)(v226 + 8);
              float v225 = *(float *)(v226 + 4);
            }
            else
            {
              uint64_t v224 = v43 + 32 * v218;
              *(_DWORD *)(v224 + 12) = *(_DWORD *)(v44 + 32 * v48 + 8);
              *(_DWORD *)(v224 + 8) = v258[0];
              float v225 = v35;
            }
            *(float *)(v43 + 32 * v218 + 4) = v225;
          }
          if (*(_DWORD *)(v5 + 8268))
          {
            if (v51) {
              __int16 v227 = 0;
            }
            else {
              __int16 v227 = *(_WORD *)(v44 + 32 * v48 + 16) + v60;
            }
            *(_WORD *)(v43 + 32 * v218 + 16) = v227;
          }
          float v54 = *(float *)v219;
          BOOL v228 = *(float *)v219 < v55;
          if (*(float *)v219 < v55) {
            float v55 = *(float *)v219;
          }
          int v229 = v254;
          if (v228) {
            int v229 = v218;
          }
          int v254 = v229;
        }
        else
        {
          *(_DWORD *)uint64_t v219 = 1259902592;
          *(void *)(v219 + 24) = 0;
        }
        unint64_t v47 = v218 + 1;
        unint64_t v230 = *(unsigned int *)(a1 + 656);
      }
      while (v47 < v230);
      int v231 = 0;
      if (v52 > 4.0)
      {
        uint64_t v2 = v242;
        int v232 = v254;
LABEL_311:
        mfs_Viterbi_sortCurrentStateByScore(a1);
        *(_DWORD *)(a1 + 656) -= v231;
        mfs_Viterbi_FillPrevStateCacheTables(a1, v2);
        *(_DWORD *)(a1 + 664) = v232;
        goto LABEL_312;
      }
      if (v230)
      {
        uint64_t v2 = v242;
        int v15 = v244;
        int v232 = v254;
        do
        {
          uint64_t v233 = *(void **)(v43 + 24);
          if (*(float *)v43 <= (float)(v52 + v55))
          {
            uint64_t v236 = (_DWORD *)v233[1];
            if (v236) {
              *v236 |= 0x80000000;
            }
          }
          else
          {
            *(_DWORD *)uint64_t v43 = 1259902592;
            ++v231;
            if (v233)
            {
              uint64_t v234 = v233[1];
              __int16 v235 = *(_WORD *)(v234 + 4) - 1;
              *(_WORD *)(v234 + 4) = v235;
              if (!v235) {
                --*(_WORD *)(*(void *)(a1 + 584) + 2 * v247);
              }
              *uint64_t v233 = *(void *)(a1 + 80);
              *(void *)(a1 + 80) = v233;
              --*(_DWORD *)(a1 + 648);
              *(void *)(v43 + 24) = 0;
            }
          }
          v43 += 32;
          --v230;
        }
        while (v230);
      }
      else
      {
        uint64_t v2 = v242;
        int v15 = v244;
        int v232 = v254;
      }
    }
    else
    {
      int v232 = 0;
      int v231 = 0;
      if (v38 > 4.0) {
        goto LABEL_311;
      }
    }
    unint64_t v237 = *(unsigned int *)(a1 + 652);
    if (!v237) {
      goto LABEL_311;
    }
    uint64_t v238 = 0;
    while (1)
    {
      unsigned int v239 = *(int **)(v44 + 32 * *(unsigned __int16 *)(*(void *)(a1 + 640) + 2 * v238) + 24);
      if (v239)
      {
        int v240 = *v239;
        if (v15)
        {
          if (*((_WORD *)v239 + 2) && v240 < 0)
          {
LABEL_309:
            *unsigned int v239 = v240 & 0x7FFFFFFF;
            goto LABEL_310;
          }
          if (v247)
          {
            mfs_Viterbi_DecrementRefCountCascade(a1, *((void *)v239 + 1), v247 - 1);
            unint64_t v237 = *(unsigned int *)(a1 + 652);
          }
        }
        else if (v240 < 0)
        {
          goto LABEL_309;
        }
        *(void *)unsigned int v239 = *(void *)(a1 + 80);
        *(void *)(a1 + 80) = v239;
        --*(_DWORD *)(a1 + 648);
      }
LABEL_310:
      if (++v238 >= v237) {
        goto LABEL_311;
      }
    }
  }
  unsigned int v24 = *(_DWORD *)(a2 + 60);
  if (v24 >= v13) {
    unsigned int v24 = -1431655765 * ((unint64_t)(*(void *)(a2 + 40) - v12) >> 3);
  }
  *(_DWORD *)(a1 + 656) = v24;
  if (!v24)
  {
LABEL_15:
    mfs_Viterbi_sortCurrentStateByScore(a1);
    mfs_Viterbi_FillPrevStateCacheTables(a1, v2);
LABEL_312:
    uint64_t v23 = 0;
    ++*(_DWORD *)(a1 + 616);
    return v23;
  }
  uint64_t v25 = 0;
  unint64_t v26 = 0;
  float v27 = 1.0 - v10;
  uint64_t v28 = *(void *)(a1 + 632);
  int v29 = (unsigned __int16 *)(v12 + 8);
  unsigned int v30 = (unsigned __int16 *)(v12 + 8);
  while (1)
  {
    unsigned int v31 = *v30;
    v30 += 12;
    uint64_t v32 = v28 + v25;
    *(float *)uint64_t v32 = v27 * (float)((float)v31 / 100.0);
    *(void *)(v32 + 4) = 0;
    *(void *)(v32 + 10) = 0;
    uint64_t v33 = *(void *)(a1 + 80);
    if (v33) {
      *(void *)(a1 + 80) = *(void *)v33;
    }
    else {
      uint64_t v33 = fastallo_AllocateMemoryFromChunk(v6, 2u, (int *)v258 + 1);
    }
    uint64_t v23 = HIDWORD(v258[0]);
    if ((v258[0] & 0x8000000000000000) != 0) {
      return v23;
    }
    ++*(_DWORD *)(a1 + 648);
    *(_DWORD *)uint64_t v33 = *((_DWORD *)v29 - 1);
    *(_WORD *)(v33 + 4) = 0;
    *(void *)(v33 + 8) = 0;
    uint64_t v28 = *(void *)(a1 + 632);
    *(void *)(v28 + v25 + 24) = v33;
    ++v26;
    v25 += 32;
    int v29 = v30;
    if (v26 >= *(unsigned int *)(a1 + 656)) {
      goto LABEL_15;
    }
  }
}

uint64_t mfs_Viterbi_sortCurrentStateByScore(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 656);
  uint64_t v3 = *(void *)(a1 + 640);
  if (v2)
  {
    for (uint64_t i = 0; i != v2; ++i)
      *(_WORD *)(v3 + 2 * i) = i;
  }
  return qsortex(v3, v2, 2, (uint64_t (*)(char *, char *, uint64_t))mfs_SortIndex_By_PathScore_Obersee, a1);
}

uint64_t mfs_Viterbi_DecrementRefCountCascade(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = a3;
  do
  {
    __int16 v4 = *(_WORD *)(a2 + 4) - 1;
    *(_WORD *)(a2 + 4) = v4;
    if (v4) {
      break;
    }
    --*(_WORD *)(*(void *)(result + 584) + 2 * v3);
    uint64_t v5 = *(void *)(a2 + 8);
    *(void *)a2 = *(void *)(result + 80);
    *(void *)(result + 80) = a2;
    --*(_DWORD *)(result + 648);
    if (!v3) {
      break;
    }
    --v3;
    a2 = v5;
  }
  while (v5);
  return result;
}

uint64_t mfs_Viterbi_SelectBestPath(uint64_t a1, int a2)
{
  int v4 = *(_DWORD *)(a1 + 612);
  int v5 = *(_DWORD *)(a1 + 616);
  int v6 = *(_DWORD *)(a1 + 596);
  if (a2)
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 632) + 32 * *(unsigned int *)(a1 + 664) + 24);
    if (v7)
    {
      int v8 = a2 - 1;
      do
      {
        *(_DWORD *)v7 |= 0x80000000;
        if (!v8) {
          break;
        }
        uint64_t v7 = *(void *)(v7 + 8);
        --v8;
      }
      while (v7);
    }
  }
  if (!*(_DWORD *)(a1 + 656))
  {
    *(_DWORD *)(a1 + 656) = 0;
    return 1;
  }
  unint64_t v9 = 0;
  unsigned int v10 = 0;
  unsigned int v11 = v4 + v5 + ~v6 - 1;
  do
  {
    uint64_t v12 = *(void *)(a1 + 640);
    uint64_t v13 = *(unsigned __int16 *)(v12 + 2 * v9);
    if (*(_DWORD *)(a1 + 664) == v13) {
      goto LABEL_11;
    }
    uint64_t v14 = *(void *)(*(void *)(a1 + 632) + 32 * v13 + 24);
    if (checkMarkBackTracesAlive(v14))
    {
      uint64_t v12 = *(void *)(a1 + 640);
LABEL_11:
      *(_WORD *)(v12 + 2 * v10++) = v13;
      goto LABEL_12;
    }
    uint64_t v15 = *(void *)(v14 + 8);
    if (v15) {
      mfs_Viterbi_DecrementRefCountCascade(a1, v15, v11);
    }
LABEL_12:
    ++v9;
  }
  while (v9 < *(unsigned int *)(a1 + 656));
  *(_DWORD *)(a1 + 656) = v10;
  if (v10)
  {
    uint64_t v16 = 0;
    uint64_t v17 = *(void *)(a1 + 640);
    uint64_t v18 = *(void *)(a1 + 632);
    do
    {
      if (a2)
      {
        unsigned __int16 v19 = (_DWORD **)(v18 + 32 * *(unsigned __int16 *)(v17 + 2 * v16) + 24);
        int v20 = a2;
        do
        {
          uint64_t v21 = *v19;
          if (!v21) {
            break;
          }
          if ((*v21 & 0x80000000) == 0) {
            break;
          }
          *v21 &= ~0x80000000;
          unsigned __int16 v19 = (_DWORD **)(v21 + 2);
          --v20;
        }
        while (v20);
      }
      ++v16;
    }
    while (v16 != v10);
  }
  return 1;
}

uint64_t checkMarkBackTracesAlive(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (_DWORD *)result;
    if ((*(_DWORD *)result & 0x80000000) == 0)
    {
      uint64_t result = checkMarkBackTracesAlive(*(void *)(result + 8));
      if (!result) {
        return result;
      }
      *v1 |= 0x80000000;
    }
    return 1;
  }
  return result;
}

BOOL mfs_Viterbi_CheckRiskForBufferUnderrun(uint64_t *a1, BOOL a2)
{
  if (!ForcedEEController_HasStartedPlayback(a2)) {
    return 0;
  }
  BOOL v9 = ForcedEEController_CheckRiskForBufferUnderrun(a2);
  uint64_t v10 = *a1;
  if (v9)
  {
    MFS__log_out_Event(v10, 27, (uint64_t)"%s%u%s%u%s%u%s%u", v4, v5, v6, v7, v8, "ETIME_PROCESS_START");
    uint64_t v10 = *a1;
    unsigned int v11 = "WARNING: RiskForBufferUnderrun at idx %d : %u | %u + %u >= %u (msec since ProcessStart | msec since StartedPla"
          "yback + msec lead >= msec audio)  \n";
  }
  else
  {
    unsigned int v11 = "No RiskForBufferUnderrun at idx %d : %u | %u + %u < %u (msec since ProcessStart | msec since StartedPlayback +"
          " msec lead < msec audio)  \n";
  }
  MFS__log_select_Diag(v10, 1, (uint64_t)v11);
  return v9;
}

uint64_t mfs_Viterbi_ReadyForEarlyEmission_OnUniquePath(uint64_t a1, unsigned int a2)
{
  int v2 = *(_DWORD *)(a1 + 612);
  unsigned int v3 = *(_DWORD *)(a1 + 616) + v2;
  unsigned int v4 = *(_DWORD *)(a1 + 596);
  unint64_t v5 = v3 + ~v4;
  BOOL v6 = v3 <= v4 || v5 == 0;
  if (v6) {
    return 0;
  }
  unsigned int v7 = *(_DWORD *)(a1 + 608);
  if (v7 >= v5) {
    return 0;
  }
  uint64_t v8 = *(unsigned int *)(a1 + 608);
  while (*(_WORD *)(*(void *)(a1 + 584) + 2 * v8) == 1)
  {
    if (++v8 >= v5) {
      goto LABEL_11;
    }
  }
  LODWORD(v5) = v8;
LABEL_11:
  if (v5 <= v7) {
    return 0;
  }
  int v9 = v5 + v4;
  unsigned int v10 = 3 * ((v5 + v4) / 3);
  unsigned int v11 = v10 - a2;
  if (v10 <= a2) {
    return 0;
  }
  uint64_t v12 = 0;
  if (v10 < a2) {
    unsigned int v11 = 0;
  }
  BOOL v6 = v4 == v2;
  uint64_t v13 = 8576;
  if (v6) {
    uint64_t v13 = 8572;
  }
  if (v11 >= *(_DWORD *)(*(void *)(*(void *)(a1 + 16) + 1072) + v13))
  {
    *(_DWORD *)(a1 + 600) = v9;
    *(_DWORD *)(a1 + 604) = v10;
    *(_DWORD *)(a1 + 608) = v5;
    uint64_t v12 = 1;
    MFS__log_select_Diag(*(void *)a1, 1, (uint64_t)"EarlyEmissionEval3:At utt.state %u we have %u known units (= +%d), %u full segment emittable (vit from %u) emitNow:%d\n");
  }
  return v12;
}

uint64_t mfs_Viterbi_ReadyForEarlyEmission_OnNonUniquePath(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v3 = 0;
  unsigned int v28 = 0;
  int v4 = *(_DWORD *)(a1 + 612);
  int v5 = *(_DWORD *)(a1 + 616);
  unsigned int v6 = *(_DWORD *)(a1 + 596);
  unsigned int v7 = v5 + v4 + ~v6;
  if (v5 + v4 > v6 && v7 != 0)
  {
    if ((a3 - 1) > 1
      || *(_DWORD *)(*(void *)(*(void *)(a1 + 16) + 1072) + 8588) == -1
      || (paramc_ParamGetUInt(*(void *)(*(void *)a1 + 40), (uint64_t)"feedback-amount-of-output-msecs-for-this-speakrequest", &v28) & 0x80000000) != 0|| v28 < 2 * *(_DWORD *)(*(void *)(*(void *)(a1 + 16) + 1072) + 8588))
    {
      if (a3 == 3)
      {
        int v16 = *(_DWORD *)(a1 + 616) + *(_DWORD *)(a1 + 612);
        BOOL v18 = v16 != 0;
        unsigned int v15 = v16 - 1;
        if (!v18) {
          unsigned int v15 = 0;
        }
        if (v15) {
          goto LABEL_31;
        }
      }
      else
      {
        if (a3 != 2)
        {
          if (a3 == 1)
          {
            unsigned int v12 = *(_DWORD *)(*(void *)(*(void *)(a1 + 16) + 1072) + 8580);
            if (v12 != -1)
            {
              unsigned int v13 = v5 + v4 - v6;
              while (1)
              {
                unsigned int v14 = v13 - 2;
                if ((int)(v13 - 2) < 0) {
                  break;
                }
                --v13;
                if (v12 >= *(unsigned __int16 *)(*(void *)(a1 + 584) + 2 * v14))
                {
                  unsigned int v15 = *(_DWORD *)(a1 + 596) + v13;
                  if (v15) {
                    goto LABEL_31;
                  }
                  return 0;
                }
              }
            }
          }
          return 0;
        }
        unsigned int v17 = *(_DWORD *)(*(void *)(*(void *)(a1 + 16) + 1072) + 8584);
        BOOL v18 = v17 != -1 && v7 >= v17;
        if (v18)
        {
          unsigned int v19 = v5 + v4 - v6 - v17;
          do
          {
            unsigned int v20 = v19;
            if (v19 >= v7) {
              break;
            }
            uint64_t v21 = *(void *)(a1 + 584);
            int v22 = *(unsigned __int16 *)(v21 + 2 * (v19 - 1));
            LODWORD(v21) = *(unsigned __int16 *)(v21 + 2 * v19++);
          }
          while (v22 == v21);
          unsigned int v15 = *(_DWORD *)(a1 + 596) + v20;
          if (v15)
          {
LABEL_31:
            unsigned int v23 = 3 * (v15 / 3);
            if (v23 > a2 && v23 > *(_DWORD *)(a1 + 596))
            {
              int v25 = *(_DWORD *)(a1 + 612);
              int v26 = *(_DWORD *)(a1 + 616);
              if (v26 + v25 >= v23)
              {
                mfs_Viterbi_SelectBestPath(a1, v25 - v23 + v26);
                *(_DWORD *)(a1 + 600) = v23;
                *(_DWORD *)(a1 + 604) = v23;
                *(_DWORD *)(a1 + 608) = 0;
                uint64_t v3 = 1;
                MFS__log_select_Diag(*(void *)a1, 1, (uint64_t)"WARNING: %s Early Emission at idx %u :  emit from %u to %u (%u states) \n");
                return v3;
              }
            }
          }
        }
      }
    }
    return 0;
  }
  return v3;
}

uint64_t mfs_Viterbi_IsEarlyEmissionPossible(uint64_t *a1, BOOL a2, unsigned int a3)
{
  if (!*(_DWORD *)(*(void *)(a1[2] + 1072) + 8564)) {
    return 0;
  }
  if (!mfs_Viterbi_CheckRiskForBufferUnderrun(a1, a2))
  {
    uint64_t v7 = 1;
    if (!mfs_Viterbi_ReadyForEarlyEmission_OnUniquePath((uint64_t)a1, a3)
      && !mfs_Viterbi_ReadyForEarlyEmission_OnNonUniquePath((uint64_t)a1, a3, 1))
    {
      int v5 = 2;
      goto LABEL_4;
    }
    return v7;
  }
  int v5 = 3;
LABEL_4:
  return mfs_Viterbi_ReadyForEarlyEmission_OnNonUniquePath((uint64_t)a1, a3, v5);
}

uint64_t mfs_Viterbi_ResultScore_Obersee(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v4 = *(_DWORD *)(a1 + 616) + *(_DWORD *)(a1 + 612) - 1;
  if (v4 >= *(_DWORD *)(a1 + 596))
  {
    int v5 = (void *)(*(void *)(a1 + 632) + 32 * *(unsigned int *)(a1 + 664) + 24);
    uint64_t v6 = *(void *)(a2 + 8);
    uint64_t v7 = *(void *)(a3 + 8);
    do
    {
      uint64_t v8 = (_DWORD *)*v5;
      int v9 = *v8;
      int v5 = v8 + 2;
      *(_DWORD *)(v6 + 4 * v4) = v9 & 0x7FFFFFFF;
      *(_DWORD *)(v7 + 4 * v4--) = 0;
    }
    while (v4 >= *(_DWORD *)(a1 + 596));
  }
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 16) + 1072) + 8564))
  {
    if (*(_DWORD *)(*(void *)(a1 + 8) + 2580))
    {
      MFS__log_select_Diag(*(void *)a1, 1, (uint64_t)"EarlyEmissionEval1:Subsequent emission:At utt.state %u we can emit %u utt.states (%u more were determined)\n");
      uint64_t v10 = *(void *)a1;
      unsigned int v11 = "EarlyEmissionEval1:Subsequent emission:After first emission of %u, cumulSubseqEmit %u & cumulSubseqCalc %u a"
            "fter emit utt.state %u (deltaBuffer %d)\n";
    }
    else
    {
      *(_DWORD *)(a1 + 768) = *(_DWORD *)(a1 + 604);
      *(_DWORD *)(a1 + 772) = *(_DWORD *)(a1 + 616) + *(_DWORD *)(a1 + 612);
      uint64_t v10 = *(void *)a1;
      unsigned int v11 = "EarlyEmissionEval1:First emission:At utt.state %u we can emit %u utt.states (%u more were determined)\n";
    }
    MFS__log_select_Diag(v10, 1, (uint64_t)v11);
  }
  int v12 = *(_DWORD *)(a1 + 600);
  if (v12)
  {
    int v13 = *(_DWORD *)(a1 + 596);
    int v14 = *(_DWORD *)(a1 + 616) + *(_DWORD *)(a1 + 612) + ~v13;
    *(_DWORD *)(a1 + 596) = v12;
    *(_DWORD *)(a1 + 600) = 0;
    memmove(*(void **)(a1 + 584), (const void *)(*(void *)(a1 + 584) + 2 * (v12 - v13)), 2 * (v14 - (v12 - v13)));
    *(_DWORD *)(a1 + 608) = 0;
  }
  return 0;
}

uint64_t mfs_SortIndex_By_PathScore_Obersee(unsigned __int16 *a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a3 + 632);
  unsigned int v4 = *(_DWORD *)(v3 + 32 * *a1);
  LODWORD(v3) = *(_DWORD *)(v3 + 32 * *a2);
  BOOL v5 = v4 > v3;
  if (v4 >= v3) {
    unsigned int v6 = 0;
  }
  else {
    unsigned int v6 = -1;
  }
  if (v5) {
    return 1;
  }
  else {
    return v6;
  }
}

uint64_t mfs_SegmentList_Init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)a3 = a1;
  *(void *)(a3 + 8) = a2;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 24) = 0;
  *(_DWORD *)(a3 + 32) = 0;
  return 0;
}

void *mfs_SegmentList_DeInit(void *result)
{
  uint64_t v1 = result;
  if (result[1])
  {
    uint64_t result = heap_Free(*(void **)(*result + 8), result[2]);
    v1[2] = 0;
  }
  *((_DWORD *)v1 + 8) = 0;
  v1[3] = 0;
  return result;
}

uint64_t mfs_SegmentList_AddSeg(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 24);
  if (v4 < *(_DWORD *)(a1 + 32))
  {
    uint64_t v5 = *(void *)(a1 + 16);
LABEL_5:
    uint64_t result = 0;
    uint64_t v9 = v5 + 28 * v4;
    *(_DWORD *)uint64_t v9 = *(_DWORD *)a2;
    *(unsigned char *)(v9 + 4) = *(unsigned char *)(a2 + 4);
    *(void *)(v9 + 8) = *(void *)(a2 + 8);
    *(_DWORD *)(v9 + 16) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 24) = v4 + 1;
    return result;
  }
  unsigned int v6 = v4 + 64;
  uint64_t v7 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 16), 28 * (v4 + 64));
  if (v7)
  {
    uint64_t v5 = v7;
    *(void *)(a1 + 16) = v7;
    *(_DWORD *)(a1 + 32) = v6;
    unsigned int v4 = *(_DWORD *)(a1 + 24);
    goto LABEL_5;
  }
  return 2229280778;
}

uint64_t mfs_SegmentList_Add(uint64_t a1, int a2, char a3, int a4, int a5)
{
  unsigned int v10 = *(_DWORD *)(a1 + 24);
  if (v10 < *(_DWORD *)(a1 + 32))
  {
    uint64_t v11 = *(void *)(a1 + 16);
LABEL_5:
    uint64_t result = 0;
    uint64_t v15 = v11 + 28 * v10;
    *(_DWORD *)uint64_t v15 = a2;
    *(unsigned char *)(v15 + 4) = a3;
    *(_DWORD *)(v15 + 8) = a4;
    *(_DWORD *)(v15 + 12) = a5;
    *(_DWORD *)(v15 + 16) = 1;
    *(_DWORD *)(a1 + 24) = v10 + 1;
    return result;
  }
  unsigned int v12 = v10 + 64;
  uint64_t v13 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 16), 28 * (v10 + 64));
  if (v13)
  {
    uint64_t v11 = v13;
    *(void *)(a1 + 16) = v13;
    *(_DWORD *)(a1 + 32) = v12;
    unsigned int v10 = *(_DWORD *)(a1 + 24);
    goto LABEL_5;
  }
  return 2229280778;
}

uint64_t mfs_SegmentList_Merge(uint64_t *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v70 = *(void *)(a4 + 1072);
  long long v75 = *(_OWORD *)a1;
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  uint64_t v76 = 0;
  if (*((_DWORD *)a1 + 7))
  {
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    LODWORD(v11) = 0;
    do
    {
      uint64_t v12 = a1[2] + v9;
      int v13 = *(_DWORD *)(v12 + 16);
      uint64_t result = mfs_SegmentList_AddSeg((uint64_t)&v75, v12);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      unint64_t v11 = (v13 + v11);
      ++v10;
      v9 += 28;
    }
    while (v10 < *((unsigned int *)a1 + 7));
    unsigned int v15 = v77;
    uint64_t v16 = a2;
  }
  else
  {
    uint64_t v16 = a2;
    uint64_t result = 2229280775;
    if (!a2) {
      return result;
    }
    unsigned int v60 = *((_DWORD *)a1 + 6);
    if (!v60 || v60 > *(_DWORD *)(a2 + 24)) {
      return result;
    }
    unsigned int v15 = 0;
    LODWORD(v10) = 0;
    unint64_t v11 = 0;
  }
  unsigned int v17 = *((_DWORD *)a1 + 6);
  int v18 = v17 - v10;
  if (v17 <= v10) {
    goto LABEL_65;
  }
  int v68 = a3;
  uint64_t v66 = a5;
  unint64_t v67 = (unsigned __int8 *)a4;
  int v19 = 0;
  uint64_t v69 = 0;
  uint64_t v20 = v10;
  uint64_t v21 = 28 * v10;
  uint64_t v22 = 28 * v11 + 12;
  int v23 = -1;
  while (v11 < *(unsigned int *)(v16 + 24))
  {
    uint64_t v24 = a1[2] + v21;
    if (*(_DWORD *)v24 == -1)
    {
      uint64_t v26 = *(void *)(v16 + 16);
      uint64_t v24 = v26 + 28 * v11;
      int v25 = *(_DWORD *)(v26 + v22);
      HIDWORD(v69) += v25;
      LODWORD(v69) = v69 + 1;
    }
    else
    {
      int v25 = *(_DWORD *)(v24 + 12);
    }
    if (v20 == *((_DWORD *)a1 + 7))
    {
      uint64_t result = mfs_SegmentList_Add((uint64_t)&v75, *(_DWORD *)v24, *(unsigned char *)(v24 + 4), *(_DWORD *)(v24 + 8), *(_DWORD *)(v24 + 12));
      if ((result & 0x80000000) != 0) {
        return result;
      }
      int v23 = *(_DWORD *)v24;
      float v27 = (const float *)(v24 + 12);
      float32x2_t v28 = vld1_dup_f32(v27);
      *(float32x2_t *)(v76 + 28 * v15 + 20) = v28;
      uint64_t v16 = a2;
      goto LABEL_59;
    }
    if (*(unsigned char *)(v24 + 4) != 1
      || (unsigned int v29 = *(_DWORD *)a1[1], *(_DWORD *)(v70 + 8256)) && (v11 % v29 || *(_DWORD *)v24 != -1))
    {
      v74[0] = 0;
      v74[1] = 0;
      uint64_t v73 = v74;
      if (*(_DWORD *)(v70 + 8328))
      {
        memset(v72, 0, sizeof(v72));
        int v30 = *(_DWORD *)v24;
        if (v23 == -1)
        {
          if (v30 == -1) {
            goto LABEL_35;
          }
        }
        else if (v30 != -1)
        {
          uint64_t result = mfs_getUnitData_Obersee((uint64_t)v67, v66, v23, (uint64_t)v72);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t v16 = a2;
          if (DWORD1(v72[0]) == *(_DWORD *)v24)
          {
LABEL_35:
            uint64_t v31 = v76;
            unsigned int v32 = v15;
            int v36 = *(_DWORD *)(v76 + 28 * v15 + 12);
LABEL_36:
            uint64_t v47 = v31 + 28 * v32;
            int v48 = v36 + *(_DWORD *)(v24 + 12);
            int v51 = *(_DWORD *)(v47 + 16);
            uint64_t v50 = (_DWORD *)(v47 + 16);
            int v49 = v51;
            *(v50 - 1) = v48;
            if (v51 >= 1) {
              *(_DWORD *)(v31 + 28 * v32 + 24) = *(_DWORD *)(v24 + 12);
            }
            *uint64_t v50 = v49 + 1;
            int v23 = *(_DWORD *)v24;
            goto LABEL_59;
          }
        }
        goto LABEL_53;
      }
      if (!v68)
      {
        uint64_t v31 = v76;
        unsigned int v32 = v15;
        uint64_t v33 = v76 + 28 * v15;
        int v35 = *(_DWORD *)(v33 + 8);
        float v34 = (_DWORD *)(v33 + 8);
        int v36 = v34[1];
        int v37 = v36 + v35;
        int v38 = *(_DWORD *)(v24 + 8);
        if (v36 + v35 == v38)
        {
          unsigned int v39 = *(_DWORD *)(v76 + 28 * v15);
          if (v39 != -1 && *(_DWORD *)v24 != -1)
          {
            uint64_t v65 = v76;
            int v63 = v34 + 1;
            unint64_t v64 = v34;
            mfs_getUnitDataFromMfsData(v67, v39, (uint64_t *)&v73);
            int v62 = *((unsigned __int16 *)v73 + 5);
            mfs_getUnitDataFromMfsData(v67, *(_DWORD *)v24, (uint64_t *)&v73);
            int v40 = v62;
            unsigned int v32 = v15;
            uint64_t v31 = v65;
            uint64_t v16 = a2;
            int v41 = *((unsigned __int16 *)v73 + 5);
            int v36 = *v63;
            int v38 = *(_DWORD *)(v24 + 8);
            int v37 = *v63 + *v64;
            goto LABEL_43;
          }
          int v41 = 0;
          int v40 = 0;
LABEL_49:
          int v55 = *(_DWORD *)(v31 + 28 * v32);
          if (v55 == *(_DWORD *)v24 || v55 != -1 && *(_DWORD *)v24 != -1 && v40 == v41) {
            goto LABEL_36;
          }
        }
        else
        {
          int v40 = 0;
          int v41 = 0;
LABEL_43:
          if (v37 == v38) {
            goto LABEL_49;
          }
        }
      }
LABEL_53:
      uint64_t result = mfs_SegmentList_Add((uint64_t)&v75, *(_DWORD *)v24, *(unsigned char *)(v24 + 4), *(_DWORD *)(v24 + 8), *(_DWORD *)(v24 + 12));
      if ((result & 0x80000000) != 0) {
        return result;
      }
      int v23 = *(_DWORD *)v24;
      unsigned int v56 = v15 + 1;
      unsigned int v15 = v56;
      uint64_t v57 = v76;
      int v58 = *(_DWORD *)(v76 + 28 * v56 + 16);
      uint64_t v16 = a2;
      if (v58 == 1)
      {
        int v59 = *(_DWORD *)(v24 + 12);
        *(_DWORD *)(v76 + 28 * v56 + 20) = v59;
LABEL_58:
        *(_DWORD *)(v57 + 28 * v56 + 24) = v59;
        goto LABEL_59;
      }
      if (v58 >= 1)
      {
        int v59 = *(_DWORD *)(v24 + 12);
        goto LABEL_58;
      }
      goto LABEL_59;
    }
    if (v11 % v29)
    {
      uint64_t v42 = v76;
      uint64_t v43 = v76 + 28 * v15;
      int v46 = *(_DWORD *)(v43 + 16);
      uint64_t v44 = (_DWORD *)(v43 + 16);
      int v45 = v46;
      *(v44 - 1) += *(_DWORD *)(v24 + 12);
      if (v46 >= 1) {
        *(_DWORD *)(v42 + 28 * v15 + 24) = *(_DWORD *)(v24 + 12);
      }
      *uint64_t v44 = v45 + 1;
      goto LABEL_59;
    }
    uint64_t result = mfs_SegmentList_Add((uint64_t)&v75, *(_DWORD *)v24, 1, *(_DWORD *)(v24 + 8), *(_DWORD *)(v24 + 12));
    if ((result & 0x80000000) != 0) {
      return result;
    }
    int v23 = *(_DWORD *)v24;
    ++v15;
    uint64_t v52 = v76;
    int v53 = *(_DWORD *)(v76 + 28 * v15 + 16);
    uint64_t v16 = a2;
    if (v53 == 1)
    {
      int v54 = *(_DWORD *)(v24 + 12);
      *(_DWORD *)(v76 + 28 * v15 + 20) = v54;
LABEL_47:
      *(_DWORD *)(v52 + 28 * v15 + 24) = v54;
      goto LABEL_59;
    }
    if (v53 >= 1)
    {
      int v54 = *(_DWORD *)(v24 + 12);
      goto LABEL_47;
    }
LABEL_59:
    v19 += v25;
    ++v20;
    ++v11;
    v21 += 28;
    v22 += 28;
    if (!--v18) {
      break;
    }
  }
  unsigned int v15 = v77;
LABEL_65:
  heap_Free(*(void **)(*a1 + 8), a1[2]);
  a1[2] = v76;
  int v61 = v78;
  *((_DWORD *)a1 + 7) = v15;
  *((_DWORD *)a1 + 8) = v61;
  *((_DWORD *)a1 + 6) = v15;
  MFS__log_select_Diag(*a1, 1, (uint64_t)"hybrid at %1.0f %% parameteric states at %1.0f %% dur\n");
  return 0;
}

uint64_t mfs_SegmentList_Get(uint64_t a1, unsigned int a2, _DWORD *a3, unsigned char *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7, _DWORD *a8)
{
  if (a1 && *(_DWORD *)(a1 + 24) > a2)
  {
    uint64_t result = 0;
    uint64_t v10 = *(void *)(a1 + 16) + 28 * a2;
    *a3 = *(_DWORD *)v10;
    *a4 = *(unsigned char *)(v10 + 4);
    unint64_t v11 = (_DWORD *)(*(void *)(a1 + 16) + 28 * a2);
    *a5 = v11[2];
    *a6 = v11[3];
    *a7 = v11[5];
    *a8 = v11[6];
  }
  else
  {
    *a3 = 0;
    *a4 = 0;
    *a6 = 0;
    uint64_t result = 2229280775;
    *a5 = 0;
  }
  return result;
}

uint64_t mfs_InitHashTable(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  if (!a1 || !a2 || !a4)
  {
    MFS__log_select_Diag(a1, 1, (uint64_t)"\n");
    return 0;
  }
  int v5 = *(_DWORD *)(a3 + 25140);
  if ((v5 & 0xFFFFFFFE) != 2)
  {
    if (v5 == 1 && a2[541] == 256 && a2[537] == 512)
    {
      unsigned int v10 = 1;
      *(_DWORD *)(a4 + 2064) = 1;
      uint64_t v11 = a2[274];
      int v12 = 32;
      do
      {
        if (v11 <= v10) {
          break;
        }
        v10 *= 2;
        --v12;
      }
      while (v12);
      *(_DWORD *)(a4 + 2060) = v10 - 1;
      *(_DWORD *)(a4 + 2056) = v11;
      int v13 = (void *)heap_Calloc(*(void **)(a1 + 8), v11, 8);
      *(void *)(a4 + 2048) = v13;
      if (v13) {
        goto LABEL_21;
      }
      return 2229280778;
    }
LABEL_20:
    *(_DWORD *)(a4 + 2064) = 0;
    *(void *)(a4 + 2056) = 0x1FFFF00020000;
    int v13 = (void *)heap_Calloc(*(void **)(a1 + 8), 0x20000, 8);
    *(void *)(a4 + 2032) = v13;
    if (v13)
    {
LABEL_21:
      bzero(v13, 8 * *(unsigned int *)(a4 + 2056));
      return 0;
    }
    return 2229280778;
  }
  if (a2[541] != 256 || a2[537] != 512) {
    goto LABEL_20;
  }
  *(_DWORD *)(a4 + 2064) = 2;
  unsigned int v6 = a2[274];
  unsigned int v7 = 1;
  int v8 = 32;
  do
  {
    if (v6 <= v7) {
      break;
    }
    v7 *= 2;
    --v8;
  }
  while (v8);
  uint64_t result = 0;
  *(_DWORD *)(a4 + 2060) = v7 - 1;
  *(_DWORD *)(a4 + 2056) = v6;
  return result;
}

uint64_t mfs_DeInitHashTable(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a2 + 2064);
  if (v3 != 2)
  {
    if (v3 == 1)
    {
      uint64_t v4 = *(void *)(a2 + 2048);
      if (v4)
      {
        int v5 = (void *)(a2 + 2048);
LABEL_7:
        heap_Free(*(void **)(a1 + 8), v4);
        *int v5 = 0;
      }
    }
    else
    {
      uint64_t v4 = *(void *)(a2 + 2032);
      if (v4)
      {
        int v5 = (void *)(a2 + 2032);
        goto LABEL_7;
      }
    }
  }
  *(_DWORD *)(a2 + 2056) = 0;
  return 0;
}

uint64_t mfs_Search_FindNodeCandidates_StatSelect(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  uint64_t v102 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)(a2 + 1928);
  char v97 = 0;
  __int16 v96 = 0;
  memset(v95, 0, sizeof(v95));
  long long v93 = 0u;
  long long v94 = 0u;
  long long v91 = 0u;
  long long v92 = 0u;
  long long v90 = 0u;
  memset(v89, 0, sizeof(v89));
  float v7 = *(float *)(a3 + 8972);
  long long v101 = 0u;
  memset(v100, 0, sizeof(v100));
  v88[0] = 0;
  v88[1] = 0;
  float v87 = v88;
  *(void *)(a2 + 2192) = 0;
  UNICORN__mfs_S32Vect_Init(v6, v95);
  uint64_t v85 = v6;
  mfs_TCost_Init(v6, a3, (uint64_t)v89);
  float v8 = *(float *)(a3 + 8180);
  uint64_t v84 = *((void *)a1 + 1516);
  uint64_t v9 = a1[610];
  if ((int)v9 < 1)
  {
    unsigned int v11 = 0;
  }
  else
  {
    uint64_t v10 = 0;
    while (*(unsigned char *)(*((void *)a1 + 307) + v10) != 31)
    {
      if (v9 == ++v10) {
        goto LABEL_9;
      }
    }
    unsigned int v11 = v10;
  }
  if (v11 == v9)
  {
LABEL_9:
    MFS__log_select_Diag(v6, 3, (uint64_t)"Can not identify DIFFERENTIATOR ID (%d), please CHECK!\n");
    unsigned int v11 = 0;
  }
  uint64_t v81 = a3;
  MFS__log_select_Diag(v6, 3, (uint64_t)"TARGET DIFFERENTIATOR FEATURE ID = %d\n");
  if (*(int *)(v4 + 608) < 1)
  {
    uint64_t v14 = 0;
    uint64_t v19 = a3;
LABEL_67:
    if (*(_DWORD *)(v19 + 8564) == 1)
    {
      float v55 = *(float *)(v4 + 2616);
      if (v55 == 0.0)
      {
        uint64_t v65 = "Early emission enabled in pipeline header but no search-xRT estimate yet\n";
      }
      else
      {
        *(_DWORD *)(v4 + 2608) = (int)((double)*(int *)(v4 + 2604) / (v55 * 0.8 + 1.0));
        MFS__log_select_Diag(v85, 1, (uint64_t)"Given search-xRT estimate %.6f, and estimated output of %d ms, set early emission to %d ms\n");
        uint64_t v56 = *(unsigned int *)(v4 + 608);
        int v57 = *(_DWORD *)(v4 + 2596);
        if ((int)v56 >= 2)
        {
          int v58 = 0;
          uint64_t v59 = 1;
          int v60 = *(_DWORD *)(v4 + 2596);
          do
          {
            if (v60) {
              break;
            }
            int v61 = *a1;
            if ((int)*a1 >= 1)
            {
              int v62 = (int *)(*(void *)(*(void *)(v4 + 600) + 528 * v59 + 16) + 8);
              uint64_t v63 = *a1;
              do
              {
                int v64 = *v62++;
                v58 += v64 * *(_DWORD *)(v19 + 24);
                --v63;
              }
              while (v63);
            }
            ++v59;
            if (v58 >= *(_DWORD *)(v4 + 2608))
            {
              int v57 = v61 * v59;
              *(_DWORD *)(v4 + 2596) = v61 * v59;
              int v60 = v61 * v59;
            }
            else
            {
              int v60 = 0;
            }
          }
          while (v59 != v56);
        }
        if (!v57) {
          goto LABEL_85;
        }
        uint64_t v65 = "Final output state (excluding Viterbi runway) for early emission will be %d\n";
      }
    }
    else
    {
      uint64_t v65 = "Early emission not enabled in pipeline header\n";
    }
    MFS__log_select_Diag(v85, 1, (uint64_t)v65);
LABEL_85:
    *(_DWORD *)(v4 + 2200) = 0;
    goto LABEL_86;
  }
  uint64_t v12 = 0;
  int v13 = 0;
  uint64_t v14 = 0;
  unsigned int v15 = (void *)(v4 + 1944);
  float v16 = v7 * 0.5;
  float v17 = 1.0 - v8;
  int v68 = v11;
  int v18 = (unsigned __int8 *)&v100[1] + v11;
  uint64_t v19 = a3;
  uint64_t v76 = (_DWORD *)(a3 + 25288);
  uint64_t v73 = v4 + 1944;
  uint64_t v74 = v4;
  unint64_t v67 = v18;
  while (1)
  {
    uint64_t v71 = v12;
    uint64_t v20 = *(void *)(v4 + 600);
    MFS__log_select_Diag(v85, 3, (uint64_t)"phoneme %d\n");
    mfs_symData_GetTargetVector((uint64_t)a1, (uint64_t)v100, *(void *)(v4 + 8), v12);
    MFS__log_select_Diag(v85, 3, (uint64_t)"TARGET DIFFERENTIATOR %d\n");
    unsigned __int8 v69 = *v18;
    UNICORN__mfs_Ling_GetPhonCtxt(*(void *)(v4 + 8), v12, &v96);
    mfs_Ling_LogPhonCtxt(v85, v19, *(void *)(v4 + 8), v12);
    if ((int)*a1 >= 1) {
      break;
    }
LABEL_64:
    ++v12;
    uint64_t v19 = v81;
    if (v12 >= *(int *)(v4 + 608)) {
      goto LABEL_67;
    }
  }
  uint64_t v83 = v20 + 528 * v12;
  uint64_t v21 = (uint64_t *)(v83 + 16);
  uint64_t v70 = (void *)(v83 + 312);
  unint64_t v72 = (void *)(v83 + 80);
  uint64_t v22 = v13;
  uint64_t v79 = 2488;
  uint64_t v78 = 2640;
  uint64_t v23 = 2;
  uint64_t v24 = (_DWORD *)v81;
  while (1)
  {
    uint64_t v80 = v22;
    if (v12)
    {
      uint64_t v25 = *v21;
      int v26 = v68;
      if (v12 != *(_DWORD *)(v4 + 608) - 1) {
        *(_DWORD *)(v4 + 2604) += *(_DWORD *)(v25 + 4 * v23) * v24[6];
      }
    }
    else
    {
      uint64_t v25 = *v21;
      int v26 = v68;
    }
    uint64_t v14 = mfs_FillTgtVect((uint64_t)v24, v4, (uint64_t)v89, *(_DWORD *)(v25 + 4 * v23));
    if ((v14 & 0x80000000) != 0) {
      break;
    }
    if ((*(unsigned char *)(*v70 + v23) & 4) != 0) {
      float v27 = 2.0;
    }
    else {
      float v27 = 1.0;
    }
    signed int v28 = v24[2056];
    if (HIBYTE(v96) != 1
      || *(_DWORD *)(v81 + 8256) && (v12 && v23 == 2 || v23 == *a1 + 1 && v12 != *(_DWORD *)(v4 + 608) - 1))
    {
      uint64_t v29 = mfs_VennDiaGrams_Tahoe(v85, (uint64_t)a1, v81, 1, v23, (uint64_t)&v96, *(_DWORD *)(*v72 + 4 * v23), *(_DWORD *)(*(void *)(v4 + 1952) + 32 * v80 + 16), v27, v28, v15, v80, v69, v26);
      if ((v29 & 0x80000000) != 0) {
        return v29;
      }
      if ((*(unsigned char *)(*v70 + v23) & 4) != 0)
      {
        uint64_t AcousticVector = mfs_VennDiaGrams_Tahoe(v85, (uint64_t)a1, v81, 2, v23, (uint64_t)&v96, *(_DWORD *)(*(void *)(v83 + 88) + 4 * v23), *(_DWORD *)(*(void *)(v4 + 1952) + 32 * v80 + 16), v27, v28, v15, v80, v69, v26);
        if ((AcousticVector & 0x80000000) != 0) {
          goto LABEL_81;
        }
      }
      uint64_t v14 = mfs_VennDiaGrams_Tahoe(v85, (uint64_t)a1, v81, 0, v23, (uint64_t)&v96, *(_DWORD *)(v83 + 8), *(_DWORD *)(*(void *)(v4 + 1952) + 32 * v80 + 16), v27, v28, v15, v80, v69, v26);
      if ((v14 & 0x80000000) != 0) {
        break;
      }
    }
    unsigned int v31 = *(_DWORD *)(*(void *)(v4 + 1952) + 32 * v80 + 16);
    if (v31 < 0x33)
    {
      unsigned int v77 = v14;
      uint64_t v32 = v80;
      uint64_t v24 = (_DWORD *)v81;
      if (v31) {
        goto LABEL_41;
      }
    }
    else
    {
      uint64_t v32 = v80;
      int v33 = (int)(float)(*(float *)(v81 + 8232) * (float)v31);
      if (v28 < v33) {
        int v33 = v28;
      }
      uint64_t v24 = (_DWORD *)v81;
      if (v33 <= 50) {
        unsigned int v34 = 50;
      }
      else {
        unsigned int v34 = v33;
      }
      if (v31 == v34) {
        goto LABEL_41;
      }
      MFS__log_select_Diag(v85, 1, (uint64_t)"nCan:(%d)|bInv:(%d)|Prne:(%d)|CtxtW:(%f)\n");
      uint64_t v35 = mfs_CostList_Sort((uint64_t)v15, v80, 1);
      uint64_t v14 = v35;
      if ((v35 & 0x80000000) != 0) {
        break;
      }
      unsigned int v77 = v35;
      mfs_CostList_Prune(v15, v80, v34);
      unsigned int v31 = *(_DWORD *)(*(void *)(v4 + 1952) + 32 * v80 + 16);
      uint64_t v32 = v80;
      if (v31)
      {
LABEL_41:
        uint64_t v36 = 0;
        int v37 = v24[2240];
        uint64_t v75 = v31;
        while (1)
        {
          int v86 = 0;
          memset(v98, 0, sizeof(v98));
          uint64_t v38 = 32 * v32;
          uint64_t v82 = v36;
          uint64_t v39 = *(unsigned int *)(*(void *)(*(void *)(v4 + 1952) + 32 * v32) + 8 * v36);
          uint64_t AcousticVector = mfs_ParamMap_GetAcousticVector(v85, (uint64_t)a1, v4, v39, (uint64_t)v98, &v86);
          if ((AcousticVector & 0x80000000) != 0) {
            break;
          }
          if ((int)v90 <= v86) {
            unsigned int v40 = v86;
          }
          else {
            unsigned int v40 = v90;
          }
          LODWORD(v92) = v40;
          uint64_t v14 = UNICORN__mfs_S32Vect_Reserve((uint64_t)&v91, v40);
          if ((v14 & 0x80000000) != 0) {
            return v14;
          }
          if (*v76)
          {
            uint64_t v14 = mfs_TCost_CandidateCostStream_kld((uint64_t)v89, (uint64_t)a1, v81, v85, (uint64_t)v98, v86, v39, *(unsigned int *)(*v72 + 4 * v23), v23, (uint64_t)v99);
            if ((v14 & 0x80000000) != 0) {
              goto LABEL_86;
            }
          }
          else
          {
            mfs_TCost_CandidateCostStream_Faster((uint64_t)v89, v81, (uint64_t)v98, v86, (uint64_t)v99);
          }
          unsigned int v77 = v14;
          uint64_t v41 = *(void *)(*(void *)(v4 + 1952) + v38) + 8 * v82;
          float v43 = *(float *)(v41 + 4);
          uint64_t v42 = (_DWORD *)(v41 + 4);
          float v44 = v43;
          if (v43 < 0.0)
          {
            *uint64_t v42 = 0;
            float v44 = 0.0;
          }
          uint64_t v45 = 0;
          float v46 = 0.0;
          uint64_t v48 = v78;
          uint64_t v47 = v79;
          uint64_t v24 = (_DWORD *)v81;
          do
          {
            *((void *)&v101 + 1) = *(void *)((char *)a1 + v48);
            v100[0] = *(unsigned int *)((char *)a1 + v47);
            float v49 = mfs_symData_DistanceOnUid(v85, (uint64_t)a1, v81, (uint64_t)v100, *a1, v39, v23, HIBYTE(v96));
            int LeafIndex = mfs_GetLeafIndex(v83, v45, v23);
            if (v84)
            {
              int v51 = LeafIndex;
              mfs_getUnitDataFromMfsData((unsigned __int8 *)a1, v39, (uint64_t *)&v87);
              double v52 = mfs_symData_GenreDivergence((uint64_t)a1, v45, v23, v51, v37, *((unsigned __int16 *)v87 + 5));
              float v53 = (float)(v8 * v99[v45])
                  + (float)((float)(v17 * v49) * (float)((float)(*(float *)&v52 * *(float *)(v81 + 8964)) + 1.0));
            }
            else
            {
              float v53 = (float)(v8 * v99[v45]) + (float)(v17 * v49);
            }
            float v46 = v46 + v53;
            ++v45;
            v48 += 72;
            v47 += 36;
          }
          while (v45 != 3);
          uint64_t v4 = v74;
          mfs_ParamMap_UnMapSection(v74);
          unsigned int v15 = (void *)v73;
          uint64_t v32 = v80;
          mfs_CostList_UpdateCost(v73, v80, v82, (float)((float)(v44 * v16) + 1.0) * v46);
          uint64_t v36 = v82 + 1;
          if (v82 + 1 == v75) {
            goto LABEL_59;
          }
        }
LABEL_81:
        uint64_t v14 = AcousticVector;
        break;
      }
    }
LABEL_59:
    uint64_t v22 = v32 + 1;
    v78 += 8;
    v79 += 4;
    BOOL v54 = v23++ <= (int)*a1;
    uint64_t v12 = v71;
    uint64_t v21 = (uint64_t *)(v83 + 16);
    if (!v54)
    {
      int v13 = v22;
      int v18 = v67;
      uint64_t v14 = v77;
      goto LABEL_64;
    }
  }
LABEL_86:
  UNICORN__mfs_S32Vect_Clear(v95);
  mfs_TCost_Clear(v89);
  return v14;
}

uint64_t mfs_Search_FindNodeCandidates_StatSelect_Tahoe(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v174 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a2 + 1928);
  if (*a1 != 3)
  {
    MFS__log_select_Diag(*(void *)(a2 + 1928), 1, (uint64_t)"CONFIG ERROR : Search is implemented for 3 states only\n");
    return -2065686262;
  }
  uint64_t v4 = a3;
  uint64_t v5 = a2;
  float v7 = *(float *)(a3 + 8972);
  unsigned __int8 v155 = 0;
  __int16 v154 = 0;
  memset(v153, 0, sizeof(v153));
  memset(v140, 0, sizeof(v140));
  long long v141 = 0u;
  long long v142 = 0u;
  long long v143 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  long long v146 = 0u;
  long long v147 = 0u;
  long long v148 = 0u;
  long long v149 = 0u;
  long long v150 = 0u;
  long long v151 = 0u;
  long long v152 = 0u;
  long long v173 = 0u;
  memset(v172, 0, sizeof(v172));
  bzero(v171, 0x400uLL);
  bzero(v170, 0x400uLL);
  *(void *)(v5 + 2192) = 0;
  UNICORN__mfs_S32Vect_Init(v3, v153);
  mfs_TCost_Init(v3, v4, (uint64_t)v140);
  int v8 = 0;
  float v9 = *(float *)(v4 + 8180);
  if (*(_DWORD *)(v4 + 8356) == 1)
  {
    uint64_t v10 = a1[610];
    if ((int)v10 < 1)
    {
      int v8 = 0;
    }
    else
    {
      uint64_t v11 = 0;
      while (*(unsigned char *)(*((void *)a1 + 307) + v11) != 31)
      {
        if (v10 == ++v11) {
          goto LABEL_12;
        }
      }
      int v8 = v11;
    }
    if (v8 == v10)
    {
LABEL_12:
      MFS__log_select_Diag(v3, 3, (uint64_t)"Can not identify DIFFERENTIATOR ID (%d), please CHECK!\n");
      int v8 = 0;
    }
    MFS__log_select_Diag(v3, 3, (uint64_t)"TARGET DIFFERENTIATOR FEATURE ID = %d\n");
  }
  if (*(int *)(v5 + 608) < 1)
  {
    unsigned int v134 = 0;
LABEL_166:
    if (*(_DWORD *)(v4 + 8564) == 1)
    {
      float v93 = *(float *)(v5 + 2616);
      if (v93 == 0.0)
      {
        float v103 = "Early emission enabled in pipeline header but no search-xRT estimate yet\n";
      }
      else
      {
        *(_DWORD *)(v5 + 2608) = (int)((double)*(int *)(v5 + 2604) / (v93 * 0.8 + 1.0));
        MFS__log_select_Diag(v3, 1, (uint64_t)"Given search-xRT estimate %.6f, and estimated output of %d ms, set early emission to %d ms\n");
        uint64_t v94 = *(unsigned int *)(v5 + 608);
        int v95 = *(_DWORD *)(v5 + 2596);
        if ((int)v94 >= 2)
        {
          int v96 = 0;
          uint64_t v97 = 1;
          int v98 = *(_DWORD *)(v5 + 2596);
          do
          {
            if (v98) {
              break;
            }
            int v99 = *a1;
            if ((int)*a1 >= 1)
            {
              float v100 = (int *)(*(void *)(*(void *)(v5 + 600) + 528 * v97 + 16) + 8);
              uint64_t v101 = *a1;
              do
              {
                int v102 = *v100++;
                v96 += v102 * *(_DWORD *)(v4 + 24);
                --v101;
              }
              while (v101);
            }
            ++v97;
            if (v96 >= *(_DWORD *)(v5 + 2608))
            {
              int v95 = v99 * v97;
              *(_DWORD *)(v5 + 2596) = v99 * v97;
              int v98 = v99 * v97;
            }
            else
            {
              int v98 = 0;
            }
          }
          while (v97 != v94);
        }
        if (!v95) {
          goto LABEL_185;
        }
        float v103 = "Final output state (excluding Viterbi runway) for early emission will be %d\n";
      }
    }
    else
    {
      float v103 = "Early emission not enabled in pipeline header\n";
    }
    MFS__log_select_Diag(v3, 1, (uint64_t)v103);
LABEL_185:
    *(_DWORD *)(v5 + 2200) = 0;
    goto LABEL_186;
  }
  uint64_t v12 = 0;
  unsigned int v134 = 0;
  unsigned __int8 v130 = 0;
  int v109 = 0;
  int v137 = (void *)(v5 + 1944);
  float v13 = v7 * 0.5;
  uint64_t v105 = 0;
  float v106 = (unsigned __int8 *)&v172[1] + v8;
  uint64_t v14 = (void *)(v5 + 1968);
  float v119 = (_DWORD *)(v4 + 25288);
  uint64_t v138 = v5;
  float v128 = (void *)(v5 + 1968);
  int v129 = v8;
  uint64_t v117 = v4;
  uint64_t v118 = v3;
  while (1)
  {
    uint64_t v15 = *(void *)(v5 + 600);
    MFS__log_select_Diag(v3, 3, (uint64_t)"phoneme %d %d %d\n");
    mfs_symData_GetTargetVector((uint64_t)a1, (uint64_t)v172, *(void *)(v5 + 8), v12);
    if (*(_DWORD *)(v4 + 8356) == 1)
    {
      MFS__log_select_Diag(v3, 3, (uint64_t)"TARGET DIFFERENTIATOR %d\n");
      unsigned __int8 v130 = *v106;
      uint64_t v14 = v128;
    }
    UNICORN__mfs_Ling_GetPhonCtxt(*(void *)(v5 + 8), v12, &v154);
    mfs_Ling_LogPhonCtxt(v3, v4, *(void *)(v5 + 8), v12);
    LODWORD(v16) = *a1;
    if ((int)*a1 >= 1)
    {
      uint64_t v17 = 0;
      uint64_t v18 = v15 + 528 * v12;
      int v131 = (void *)(v18 + 312);
      int v111 = (void *)(v18 + 88);
      uint64_t v114 = (void *)(v18 + 16);
      float v120 = (int *)(v18 + 8);
      float v123 = (void *)(v18 + 80);
      uint64_t v19 = (32 * v109) | 0x10;
      while (1)
      {
        uint64_t v20 = v17;
        if (v12 && v12 != *(_DWORD *)(v138 + 608) - 1) {
          *(_DWORD *)(v138 + 2604) += *(_DWORD *)(*v114 + 4 * v17 + 8) * *(_DWORD *)(v4 + 24);
        }
        if ((*(unsigned char *)(*v131 + v17 + 2) & 4) != 0) {
          float v21 = 2.0;
        }
        else {
          float v21 = 1.0;
        }
        signed int v136 = *(_DWORD *)(v4 + 8224);
        v169[v17] = 0;
        if (HIBYTE(v154) != 1)
        {
LABEL_38:
          uint64_t v23 = v12;
          int v24 = *(_DWORD *)(*(void *)(v138 + 1952) + v19);
          uint64_t v25 = *(uint64_t **)(v138 + 2640);
          if (!v25
            || (unsigned int v26 = v109 + v20 + *((_DWORD *)v25 + 5), LODWORD(v157) = 0, v27 = *v25, *(_DWORD *)(v27 + 48 * v26))
            || (int v30 = *(_DWORD *)(v27 + 48 * v26 + 24)) == 0
            || (unsigned int v31 = *(_DWORD *)(*(void *)(v27 + 48 * v26 + 8) + 4 * (v30 - 1)), v31 >= a1[274] - 1)
            || (unsigned int v32 = mfs_CostList_Add((uint64_t)a1, v137, v109 + (int)v20, v31, *((void *)a1 + 298), a1[598], (unsigned int *)&v157, v21), (v32 & 0x80000000) != 0))
          {
            signed int v28 = v109 + v20;
            unsigned int AcousticVector = mfs_VennDiaGrams_Tahoe(v3, (uint64_t)a1, v4, 1, (int)v20 + 2, (uint64_t)&v154, *(_DWORD *)(*v123 + 4 * v20 + 8), v24, v21, v136, v137, v109 + (int)v20, v130, v129);
            if ((AcousticVector & 0x80000000) != 0
              || (*(unsigned char *)(*v131 + v20 + 2) & 4) != 0
              && (unsigned int AcousticVector = mfs_VennDiaGrams_Tahoe(v3, (uint64_t)a1, v4, 2, (int)v20 + 2, (uint64_t)&v154, *(_DWORD *)(*v111 + 4 * v20 + 8), *(_DWORD *)(*(void *)(v138 + 1952) + v19), v21, v136, v137, v28, v130, v129), (AcousticVector & 0x80000000) != 0))
            {
LABEL_180:
              unsigned int v134 = AcousticVector;
              goto LABEL_186;
            }
            uint64_t v12 = v23;
            unsigned int v134 = mfs_VennDiaGrams_Tahoe(v3, (uint64_t)a1, v4, 0, (int)v20 + 2, (uint64_t)&v154, *v120, *(_DWORD *)(*(void *)(v138 + 1952) + v19), v21, v136, v137, v28, v130, v129);
            if ((v134 & 0x80000000) != 0) {
              goto LABEL_186;
            }
          }
          else
          {
            unsigned int v134 = v32;
            v169[v20] = 1;
            uint64_t v12 = v23;
          }
          goto LABEL_44;
        }
        if (v17 != 1 && *(_DWORD *)(v4 + 8256))
        {
          if (v17)
          {
            if (v17 + 2 != v16 + 1) {
              goto LABEL_38;
            }
            if (v12 == *(_DWORD *)(v138 + 608) - 1 || v155 == 1) {
              goto LABEL_44;
            }
            int v22 = v154;
          }
          else
          {
            if (!v12 || v154 == 1) {
              goto LABEL_44;
            }
            int v22 = v155;
          }
          if (v22 != 1) {
            goto LABEL_38;
          }
        }
LABEL_44:
        uint64_t v16 = (int)*a1;
        v19 += 32;
        uint64_t v17 = v20 + 1;
        if (v20 + 2 > v16)
        {
          v109 += v17;
          uint64_t v5 = v138;
          uint64_t v14 = v128;
          goto LABEL_51;
        }
      }
    }
    signed int v136 = *(_DWORD *)(v4 + 8224);
LABEL_51:
    uint64_t v107 = v12;
    if (HIBYTE(v154) != 1)
    {
      if ((int)v16 >= -1) {
        int v33 = v16 + 1;
      }
      else {
        int v33 = v16 + 2;
      }
      uint64_t v34 = (v109 - (v33 >> 1));
      uint64_t v139 = 0;
      uint64_t v35 = *(void *)(v5 + 1976);
      *(_DWORD *)(v35 + 208) = 0;
      *(_DWORD *)(v35 + 240) = 0;
      uint64_t v36 = (v34 - 1);
      uint64_t v37 = (v34 + 1);
      uint64_t v38 = *(void *)(v5 + 1952);
      uint64_t v39 = *(unsigned int *)(v38 + 32 * v34 + 16);
      uint64_t v40 = v36;
      uint64_t v121 = v34;
      uint64_t v124 = v37;
      if (v39)
      {
        uint64_t v41 = 0;
        int v135 = v169[0];
        int v132 = v169[2];
        unsigned int v115 = *(_DWORD *)(v38 + 32 * v37 + 16);
        unsigned int v112 = *(_DWORD *)(v38 + 32 * v36 + 16);
        uint64_t v126 = 8 * v39;
        while (1)
        {
          int v168 = 0;
          long long v166 = 0u;
          long long v167 = 0u;
          long long v164 = 0u;
          long long v165 = 0u;
          long long v162 = 0u;
          long long v163 = 0u;
          long long v160 = 0u;
          long long v161 = 0u;
          long long v158 = 0u;
          long long v159 = 0u;
          long long v157 = 0u;
          v156[0] = (uint64_t)&v157;
          uint64_t v42 = *(void *)(v5 + 1952);
          uint64_t v43 = 32 * v34;
          int v44 = *(_DWORD *)(*(void *)(v42 + 32 * v34) + v41);
          unsigned int CandVector = mfs_symData_GetCandVector(v3, (uint64_t)a1, v4, *a1, v44, 3, v156);
          unsigned int v46 = CandVector;
          if ((CandVector & 0x80000000) != 0)
          {
            unsigned int v134 = CandVector;
            goto LABEL_186;
          }
          if (v135) {
            goto LABEL_64;
          }
          unsigned int v47 = CandVector;
          if ((v112 < 0x64 || *(unsigned __int8 *)v156[0] == v154)
            && !mfs_CostList_IsNodeInList((uint64_t)v137, v36, v44 - 1, (uint64_t)a1, (unsigned int *)&v139))
          {
            if (!mfs_CostList_IsNodeInList((uint64_t)v128, 0, v44 - 1, (uint64_t)a1, (unsigned int *)&v139))
            {
              int IsNodeInList = mfs_CostList_IsNodeInList((uint64_t)v128, 1u, v44 - 1, (uint64_t)a1, (unsigned int *)&v139);
              unsigned int v46 = v47;
              uint64_t v36 = v40;
              uint64_t v34 = v121;
              if (!IsNodeInList) {
                unsigned int v46 = mfs_CostList_Pad((uint64_t)a1, v128, 6u, v44 - 1, *((void *)a1 + 298), a1[598], (_DWORD *)&v139 + 1, *(float *)(*(void *)(*(void *)(v138 + 1952) + v43) + v41 + 4));
              }
              goto LABEL_64;
            }
            unsigned int v46 = v47;
            uint64_t v36 = v40;
          }
          else
          {
            unsigned int v46 = v47;
          }
          uint64_t v34 = v121;
LABEL_64:
          if (!v132)
          {
            unsigned int v48 = v46;
            if ((v115 < 0x64 || *(unsigned __int8 *)(v156[0] + 2) == v155)
              && (unsigned int v49 = v44 + 1,
                  !mfs_CostList_IsNodeInList((uint64_t)v137, v124, v49, (uint64_t)a1, (unsigned int *)&v139)))
            {
              if (mfs_CostList_IsNodeInList((uint64_t)v128, 4u, v49, (uint64_t)a1, (unsigned int *)&v139))
              {
                unsigned int v46 = v48;
                uint64_t v36 = v40;
              }
              else
              {
                int v51 = mfs_CostList_IsNodeInList((uint64_t)v128, 5u, v49, (uint64_t)a1, (unsigned int *)&v139);
                unsigned int v46 = v48;
                uint64_t v36 = v40;
                if (!v51) {
                  unsigned int v46 = mfs_CostList_Pad((uint64_t)a1, v128, 7u, v49, *((void *)a1 + 298), a1[598], (_DWORD *)&v139 + 1, *(float *)(*(void *)(*(void *)(v138 + 1952) + v43) + v41 + 4));
                }
              }
            }
            else
            {
              unsigned int v46 = v48;
            }
          }
          v41 += 8;
          uint64_t v5 = v138;
          if (v126 == v41)
          {
            unsigned int v134 = v46;
            uint64_t v35 = *(void *)(v138 + 1976);
            if (*(_DWORD *)(v35 + 208))
            {
              uint64_t v14 = v128;
              mfs_ConcatTwoLists(v128, 1u, (uint64_t)v128, 6u);
              uint64_t v35 = *(void *)(v138 + 1976);
              uint64_t v12 = v107;
            }
            else
            {
              uint64_t v12 = v107;
              uint64_t v14 = v128;
            }
            uint64_t v37 = v124;
            break;
          }
        }
      }
      if (*(_DWORD *)(v35 + 240))
      {
        mfs_ConcatTwoLists(v14, 5u, (uint64_t)v14, 7u);
        uint64_t v37 = v124;
        uint64_t v35 = *(void *)(v5 + 1976);
      }
      LODWORD(v139) = 0;
      *(_DWORD *)(v35 + 208) = 0;
      double v52 = (_DWORD *)(v35 + 208);
      if (v169[1])
      {
        *double v52 = 0;
      }
      else
      {
        uint64_t v82 = *(unsigned int *)(*(void *)(v5 + 1952) + 32 * v36 + 16);
        if (v82)
        {
          uint64_t v83 = 0;
          uint64_t v84 = 8 * v82;
          do
          {
            uint64_t v85 = 32 * v36;
            unsigned int v86 = *(_DWORD *)(*(void *)(*(void *)(v5 + 1952) + v85) + v83) + 1;
            if (!mfs_CostList_IsNodeInList((uint64_t)v137, v34, v86, (uint64_t)a1, (unsigned int *)&v139))
            {
              if (mfs_CostList_IsNodeInList((uint64_t)v128, 2u, v86, (uint64_t)a1, (unsigned int *)&v139))
              {
                LODWORD(v34) = v121;
              }
              else
              {
                LODWORD(v34) = v121;
                if (!mfs_CostList_IsNodeInList((uint64_t)v128, 3u, v86, (uint64_t)a1, (unsigned int *)&v139))unsigned int v134 = mfs_CostList_Pad((uint64_t)a1, v128, 6u, v86, *((void *)a1 + 298), a1[598], (_DWORD *)&v139 + 1, *(float *)(*(void *)(*(void *)(v5 + 1952) + v85) + v83 + 4) * 20.0); {
              }
                }
            }
            v83 += 8;
            uint64_t v36 = v40;
          }
          while (v84 != v83);
          uint64_t v87 = *(void *)(v5 + 1976);
          if (*(_DWORD *)(v87 + 208))
          {
            uint64_t v14 = v128;
            mfs_ConcatTwoLists(v128, 3u, (uint64_t)v128, 6u);
            uint64_t v87 = *(void *)(v5 + 1976);
            uint64_t v12 = v107;
          }
          else
          {
            uint64_t v12 = v107;
            uint64_t v14 = v128;
          }
          LODWORD(v139) = 0;
          double v52 = (_DWORD *)(v87 + 208);
          uint64_t v37 = v124;
        }
        *double v52 = 0;
        uint64_t v88 = *(unsigned int *)(*(void *)(v5 + 1952) + 32 * v37 + 16);
        if (v88)
        {
          uint64_t v89 = 0;
          uint64_t v90 = 8 * v88;
          do
          {
            uint64_t v91 = 32 * v37;
            unsigned int v92 = *(_DWORD *)(*(void *)(*(void *)(v5 + 1952) + 32 * v37) + v89) - 1;
            if (!mfs_CostList_IsNodeInList((uint64_t)v137, v34, v92, (uint64_t)a1, (unsigned int *)&v139))
            {
              if (mfs_CostList_IsNodeInList((uint64_t)v128, 2u, v92, (uint64_t)a1, (unsigned int *)&v139))
              {
                LODWORD(v34) = v121;
              }
              else
              {
                LODWORD(v34) = v121;
                if (!mfs_CostList_IsNodeInList((uint64_t)v128, 3u, v92, (uint64_t)a1, (unsigned int *)&v139))unsigned int v134 = mfs_CostList_Pad((uint64_t)a1, v128, 6u, v92, *((void *)a1 + 298), a1[598], (_DWORD *)&v139 + 1, *(float *)(*(void *)(*(void *)(v5 + 1952) + v91) + v89 + 4) * 20.0); {
              }
                }
            }
            v89 += 8;
            uint64_t v37 = v124;
          }
          while (v90 != v89);
          if (!*(_DWORD *)(*(void *)(v5 + 1976) + 208))
          {
            uint64_t v12 = v107;
            float v53 = v137;
            uint64_t v14 = v128;
LABEL_88:
            LODWORD(v16) = *a1;
            if ((int)*a1 >= 1)
            {
              uint64_t v54 = v12;
              uint64_t v55 = 0;
              uint64_t v56 = 1;
              signed int v57 = 1;
              do
              {
                uint64_t v58 = *(void *)(v5 + 1976);
                if (*(_DWORD *)(v58 + (v55 >> 27) + 16))
                {
                  mfs_ConcatTwoLists(v53, v40 + v56 - 1, (uint64_t)v128, v57 - 1);
                  uint64_t v58 = *(void *)(v5 + 1976);
                }
                if (*(_DWORD *)(v58 + 32 * v57 + 16)) {
                  mfs_ConcatTwoLists(v53, v40 + v56 - 1, (uint64_t)v128, v57);
                }
                uint64_t v16 = (int)*a1;
                ++v56;
                v57 += 2;
                v55 += 0x200000000;
              }
              while (v56 <= v16);
              uint64_t v12 = v54;
              uint64_t v14 = v128;
            }
            goto LABEL_96;
          }
          uint64_t v14 = v128;
          mfs_ConcatTwoLists(v128, 3u, (uint64_t)v128, 6u);
          uint64_t v12 = v107;
        }
      }
      float v53 = v137;
      goto LABEL_88;
    }
LABEL_96:
    if ((int)v16 >= 1) {
      break;
    }
    v109 -= v16;
LABEL_140:
    if (++v12 >= *(int *)(v5 + 608)) {
      goto LABEL_166;
    }
  }
  uint64_t v59 = v109 - (int)v16;
  uint64_t v127 = 2488;
  uint64_t v125 = 2640;
  uint64_t v60 = 2;
  while (1)
  {
    uint64_t v61 = *(void *)(v5 + 600);
    unsigned int v134 = mfs_FillTgtVect(v4, v5, (uint64_t)v140, *(_DWORD *)(*(void *)(v61 + 528 * v12 + 16) + 4 * v60));
    if ((v134 & 0x80000000) != 0) {
      break;
    }
    if (v60 == 4)
    {
      if (!mfs_Ling_IsSilence(v4, *(void *)(v5 + 8), v12))
      {
        uint64_t v64 = v61 + 528 * v12;
        int v65 = v105;
        uint64_t v66 = v5 + 4 * v105;
        *(_DWORD *)(v66 + 3468) = *(_DWORD *)(v64 + 24);
        int v67 = *(_DWORD *)(v64 + 28);
        if (v105 < 0x190) {
          int v65 = v105 + 1;
        }
        LODWORD(v105) = v65;
        if (!v67) {
          int v67 = 1;
        }
        *(_DWORD *)(v66 + 5072) = v67;
      }
    }
    else if (v60 == 3 && mfs_Ling_IsVowel(v4, *(void *)(v5 + 8), v12))
    {
      float v62 = fmaxf(*(float *)v141, 0.0);
      int v63 = HIDWORD(v105);
      if (HIDWORD(v105) < 0xC8) {
        int v63 = HIDWORD(v105) + 1;
      }
      *(float *)(v5 + 4 * HIDWORD(v105) + 2664) = v62;
      HIDWORD(v105) = v63;
    }
    unsigned int v68 = *(_DWORD *)(*(void *)(v5 + 1952) + 32 * v59 + 16);
    if (v68 >= 0x33)
    {
      int v69 = (int)(float)(*(float *)(v4 + 8232) * (float)v68);
      if (v136 < v69) {
        int v69 = v136;
      }
      if (v69 <= 50) {
        unsigned int v70 = 50;
      }
      else {
        unsigned int v70 = v69;
      }
      if (v68 == v70)
      {
LABEL_121:
        uint64_t v71 = v61 + 528 * v107;
        uint64_t v72 = 0;
        uint64_t v113 = (void *)(v71 + 80);
        float v108 = (int *)(v71 + 28);
        uint64_t v110 = (int *)(v71 + 24);
        uint64_t v116 = v68;
        uint64_t v122 = v59;
        while (1)
        {
          HIDWORD(v139) = 0;
          long long v160 = 0u;
          long long v161 = 0u;
          long long v158 = 0u;
          long long v159 = 0u;
          long long v157 = 0u;
          uint64_t v73 = *(unsigned int *)(*(void *)(*(void *)(v5 + 1952) + 32 * v59) + 8 * v72);
          unsigned int AcousticVector = mfs_ParamMap_GetAcousticVector(v3, (uint64_t)a1, v5, v73, (uint64_t)&v157, (int *)&v139 + 1);
          if ((AcousticVector & 0x80000000) != 0) {
            goto LABEL_180;
          }
          if ((int)v148 <= SHIDWORD(v139)) {
            unsigned int v74 = HIDWORD(v139);
          }
          else {
            unsigned int v74 = v148;
          }
          LODWORD(v150) = v74;
          unsigned int v134 = UNICORN__mfs_S32Vect_Reserve((uint64_t)&v149, v74);
          if ((v134 & 0x80000000) != 0) {
            goto LABEL_186;
          }
          if (*v119)
          {
            unsigned int v134 = mfs_TCost_CandidateCostStream_kld((uint64_t)v140, (uint64_t)a1, v4, v3, (uint64_t)&v157, SHIDWORD(v139), v73, *(unsigned int *)(*v113 + 4 * v60), v60, (uint64_t)v156);
            if ((v134 & 0x80000000) != 0) {
              goto LABEL_186;
            }
          }
          else
          {
            mfs_TCost_CandidateCostStream_Faster((uint64_t)v140, v4, (uint64_t)&v157, SHIDWORD(v139), (uint64_t)v156);
          }
          float v75 = *(float *)(*(void *)(*(void *)(v5 + 1952) + 32 * v59) + 8 * v72 + 4);
          mfs_symData_DistanceOnUid_PreCalc(v3, (uint64_t)a1, v4, (uint64_t)v172, *a1, v73, v60, HIBYTE(v154), (uint64_t)v171, (uint64_t)v170);
          float v76 = 0.0;
          uint64_t v133 = v72;
          if (*(_DWORD *)(v4 + 8272) && HIBYTE(v154) != 1) {
            float v76 = (float)(int)CandidatePhonemeDurationDistance((uint64_t)a1, v73, v60, *v110, *v108) * 0.01 + 0.0;
          }
          uint64_t v77 = 0;
          float v78 = (float)(v75 * v13) + 1.0;
          uint64_t v80 = v125;
          uint64_t v79 = v127;
          uint64_t v4 = v117;
          uint64_t v3 = v118;
          do
          {
            *((void *)&v173 + 1) = *(void *)((char *)a1 + v80);
            v172[0] = *(unsigned int *)((char *)a1 + v79);
            float v76 = v76
                + (float)((float)(v9 * *(float *)((char *)v156 + v77))
                        + (float)((float)(1.0 - v9)
                                * mfs_symData_DistanceOnUid_Tahoe(v118, (uint64_t)a1, v117, (uint64_t)v172, *a1, v73, v60, HIBYTE(v154), v171)));
            v77 += 4;
            v80 += 72;
            v79 += 36;
          }
          while (v77 != 12);
          uint64_t v5 = v138;
          mfs_ParamMap_UnMapSection(v138);
          uint64_t v59 = v122;
          mfs_CostList_UpdateCost((uint64_t)v137, v122, v133, v78 * v76);
          uint64_t v72 = v133 + 1;
          if (v133 + 1 == v116) {
            goto LABEL_137;
          }
        }
      }
      MFS__log_select_Diag(v3, 1, (uint64_t)"nCan:(%d)|bInv:(%d)|Prne:(%d)|CtxtW:(%f)\n");
      unsigned int v134 = mfs_CostList_Sort((uint64_t)v137, v59, 1);
      if ((v134 & 0x80000000) != 0) {
        break;
      }
      mfs_CostList_Prune(v137, v59, v70);
      unsigned int v68 = *(_DWORD *)(*(void *)(v5 + 1952) + 32 * v59 + 16);
    }
    if (v68) {
      goto LABEL_121;
    }
LABEL_137:
    ++v59;
    v125 += 8;
    v127 += 4;
    BOOL v81 = v60++ <= (int)*a1;
    uint64_t v12 = v107;
    if (!v81)
    {
      int v109 = v59;
      uint64_t v14 = v128;
      goto LABEL_140;
    }
  }
LABEL_186:
  UNICORN__mfs_S32Vect_Clear(v153);
  mfs_TCost_Clear(v140);
  return v134;
}

uint64_t mfs_Search_FindNodeCandidates(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v100 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)(a2 + 1928);
  char v98 = 0;
  __int16 v97 = 0;
  memset(v96, 0, sizeof(v96));
  long long v94 = 0u;
  memset(v95, 0, 152);
  long long v92 = 0u;
  long long v93 = 0u;
  long long v90 = 0u;
  long long v91 = 0u;
  memset(v89, 0, sizeof(v89));
  unsigned int v88 = 0;
  v87[0] = 0;
  v87[1] = 0;
  unsigned int v86 = (unsigned __int8 *)v87;
  *(void *)(a2 + 2192) = 0;
  mfs_Harch_Init(v6, (uint64_t)v95);
  UNICORN__mfs_S32Vect_Init(v6, v96);
  mfs_TCost_Init(v6, a3, (uint64_t)v89);
  if (*(int *)(a2 + 608) < 1)
  {
    uint64_t v11 = 0;
LABEL_94:
    if (*(_DWORD *)(a3 + 8564) == 1)
    {
      float v55 = *(float *)(a2 + 2616);
      if (v55 == 0.0)
      {
        int v65 = "Early emission configured in pipeline header, no search-xRT estimate yet\n";
      }
      else
      {
        *(_DWORD *)(a2 + 2608) = (int)((double)*(int *)(a2 + 2604) / (v55 * 0.8 + 1.0));
        MFS__log_select_Diag(v6, 1, (uint64_t)"Given search-xRT estimate %.6f, and estimated output of %d ms, set early emission to %d ms\n");
        uint64_t v56 = *(unsigned int *)(a2 + 608);
        int v57 = *(_DWORD *)(a2 + 2596);
        if ((int)v56 >= 2)
        {
          int v58 = 0;
          uint64_t v59 = 1;
          int v60 = *(_DWORD *)(a2 + 2596);
          do
          {
            if (v60) {
              break;
            }
            int v61 = *a1;
            if ((int)*a1 >= 1)
            {
              float v62 = (int *)(*(void *)(*(void *)(a2 + 600) + 528 * v59 + 16) + 8);
              uint64_t v63 = *a1;
              do
              {
                int v64 = *v62++;
                v58 += v64 * *(_DWORD *)(a3 + 24);
                --v63;
              }
              while (v63);
            }
            ++v59;
            if (v58 >= *(_DWORD *)(a2 + 2608))
            {
              int v57 = v61 * v59;
              *(_DWORD *)(a2 + 2596) = v61 * v59;
              int v60 = v61 * v59;
            }
            else
            {
              int v60 = 0;
            }
          }
          while (v59 != v56);
        }
        if (!v57) {
          goto LABEL_112;
        }
        int v65 = "Final output state (excluding Viterbi runway) for early emission will be %d\n";
      }
    }
    else
    {
      int v65 = "Early emission not configured in pipeline header\n";
    }
    MFS__log_select_Diag(v6, 1, (uint64_t)v65);
LABEL_112:
    if (*(int *)(a2 + 2192) < 5 || *(int *)(a2 + 2196) <= 4) {
      *(_DWORD *)(a2 + 2200) = 0;
    }
    goto LABEL_115;
  }
  uint64_t v7 = 0;
  int v82 = 0;
  uint64_t v84 = (void *)(a2 + 1944);
  int v8 = (uint64_t *)(a1 + 486);
  while (1)
  {
    uint64_t v9 = *(void *)(a2 + 600);
    MFS__log_select_Diag(v6, 3, (uint64_t)"phoneme %d\n");
    UNICORN__mfs_Ling_GetPhonCtxt(*(void *)(a2 + 8), v7, &v97);
    mfs_Ling_LogPhonCtxt(v6, a3, *(void *)(a2 + 8), v7);
    BOOL IsBoundary = mfs_Harch_IsBoundary((uint64_t)v95, 1u);
    uint64_t v11 = mfs_Harch_Search(v6, v8, v95, a2, v7);
    if ((v11 & 0x80000000) != 0) {
      break;
    }
    MFS__log_select_Diag(v6, 3, (uint64_t)"\n");
    BOOL v12 = IsBoundary && mfs_Ling_IsVowelVowelTrans(a3, *(void *)(a2 + 8), v7)
       || mfs_Harch_FewCands((int *)v95);
    mfs_Harch_FewCands((int *)v95);
    int v78 = v12;
    MFS__log_select_Diag(v6, 3, (uint64_t)"wordbound(%d) breakwords(%d) few(%d)\n");
    unsigned int v70 = mfs_Ling_IsVowel(a3, *(void *)(a2 + 8), v7);
    if ((int)*a1 >= 1)
    {
      float v13 = (int *)(v9 + 528 * v7);
      float v76 = v13 + 4;
      uint64_t v79 = v13 + 78;
      int v67 = v13 + 22;
      unsigned int v68 = v8;
      uint64_t v71 = v13 + 84;
      uint64_t v72 = v13 + 86;
      uint64_t v14 = v82;
      uint64_t v15 = 2;
      uint64_t v81 = v6;
      uint64_t v73 = a3;
      unsigned int v74 = v13;
      uint64_t v69 = v7;
      while (1)
      {
        uint64_t v83 = v14;
        if (v7 && v7 != *(_DWORD *)(a2 + 608) - 1) {
          *(_DWORD *)(a2 + 2604) += *(_DWORD *)(*v76 + 4 * v15) * *(_DWORD *)(a3 + 24);
        }
        BOOL v16 = (*(unsigned char *)(*v79 + v15) & 4) == 0;
        int v17 = *(_DWORD *)(a3 + 8656);
        uint64_t v18 = v15;
        BOOL IsPerceptualInvariantState = mfs_IsPerceptualInvariantState(a3, a2, v13);
        if (v17) {
          int v20 = IsPerceptualInvariantState || v16;
        }
        else {
          int v20 = IsPerceptualInvariantState && v16;
        }
        uint64_t v80 = v18;
        if (v20)
        {
          if (mfs_ProbSynthNoDegradation(a2, *(_DWORD *)(*v76 + 4 * v18)) == 0.0 && HIBYTE(v97) != 1)
          {
            MFS__log_select_Diag(v6, 3, (uint64_t)"F0 low -> made made Variant !\n");
            int v20 = 0;
          }
        }
        uint64_t AcousticVector = mfs_FillTgtVect(a3, a2, (uint64_t)v89, *(_DWORD *)(*v76 + 4 * v18));
        if ((AcousticVector & 0x80000000) != 0)
        {
LABEL_108:
          uint64_t v11 = AcousticVector;
          goto LABEL_115;
        }
        uint64_t v23 = 8224;
        if (v20) {
          uint64_t v23 = 8228;
        }
        float v24 = 0.009901;
        uint64_t v25 = (void *)(a2 + 1944);
        if (v78)
        {
          if (v20)
          {
            float v24 = *(float *)(a3 + 8164);
          }
          else
          {
            float v24 = 0.047619;
            if (!v70) {
              float v24 = *(float *)(a3 + 8168);
            }
          }
        }
        unsigned int v26 = *(_DWORD *)(a3 + v23);
        if ((*(unsigned char *)(*v79 + v80) & 4) != 0) {
          ++*(_DWORD *)(a2 + 2192);
        }
        else {
          ++*(_DWORD *)(a2 + 2196);
        }
        signed int v75 = v26;
        mfs_loc_AddMainCandidates(v6, (uint64_t)a1, (_DWORD *)a3, v13, v80, v84, v83, v26, v24, v78, v20, (unsigned __int8 *)&v97, v95, (uint64_t)v96, 1);
        uint64_t v27 = *(void *)(a2 + 1952);
        int v77 = v20;
        if (v20) {
          break;
        }
        uint64_t v28 = v80;
        if ((*(unsigned char *)(*v79 + v80) & 4) == 0) {
          goto LABEL_55;
        }
        unsigned int v29 = *(_DWORD *)(v27 + 32 * v83 + 16);
        unsigned int v30 = *(_DWORD *)(a3 + 8944);
        int v31 = v78;
        signed int v32 = v75;
        if (v29 < v30)
        {
          if ((int)v30 >= v75) {
            unsigned int v33 = v75;
          }
          else {
            unsigned int v33 = *(_DWORD *)(a3 + 8944);
          }
          char v34 = v78 ^ 1;
          if (*(_DWORD *)(a3 + 8788)) {
            char v34 = 1;
          }
          if ((v34 & 1) == 0)
          {
            uint64_t AcousticVector = mfs_IbAddtoVect(v6, (uint64_t)a1, a3, 0, 2, v80, *(_DWORD *)(*v67 + 4 * v80), v29, v24, 0.8, 0.25, v33, v84, v83, (unsigned __int8 *)&v97, 0);
            if ((AcousticVector & 0x80000000) != 0) {
              goto LABEL_108;
            }
            uint64_t v27 = *(void *)(a2 + 1952);
            uint64_t v25 = (void *)(a2 + 1944);
            uint64_t v28 = v80;
            signed int v32 = v75;
            int v31 = v78;
          }
          if (*(_DWORD *)(a3 + 8792))
          {
            unsigned int v35 = *(_DWORD *)(v27 + 32 * v83 + 16) - v29;
            if (v35 <= 0xC7 && v35 < v33)
            {
              if (*(int *)(*v72 + 4 * v28) >= 1)
              {
                uint64_t v36 = 0;
                while (1)
                {
                  uint64_t v37 = v28;
                  uint64_t AcousticVector = mfs_IbAddtoVect(v6, (uint64_t)a1, a3, 0, 2, v28, *(_DWORD *)(*(void *)(*v71 + 8 * v28) + 4 * v36), v29, v24, 0.8, 0.25, v33, v25, v83, (unsigned __int8 *)&v97, 0);
                  if ((AcousticVector & 0x80000000) != 0) {
                    goto LABEL_108;
                  }
                  ++v36;
                  uint64_t v25 = (void *)(a2 + 1944);
                  uint64_t v28 = v37;
                  if (v36 >= *(int *)(*v72 + 4 * v37))
                  {
                    int v20 = v77;
                    break;
                  }
                }
              }
              MFS__log_select_Diag(v6, 3, (uint64_t)"@@@@@@@@@@@@ BACKOFF %lu\n");
              uint64_t v27 = *(void *)(a2 + 1952);
              LODWORD(v28) = v80;
              goto LABEL_55;
            }
          }
        }
LABEL_56:
        int v38 = (int)(float)(*(float *)(a3 + 8232) * (float)*(unsigned int *)(v27 + 32 * v83 + 16));
        if (v32 < v38) {
          int v38 = v32;
        }
        if (v38 <= 1) {
          unsigned int v39 = 1;
        }
        else {
          unsigned int v39 = v38;
        }
        if (v39 < 0x28) {
          int v40 = v31;
        }
        else {
          int v40 = 0;
        }
        if (!v20 && v40)
        {
          signed int v41 = v32;
          mfs_loc_AddMainCandidates(v6, (uint64_t)a1, (_DWORD *)a3, v74, v28, v25, v83, v32, 0.0, v31, 0, (unsigned __int8 *)&v97, 0, (uint64_t)v96, 0);
          uint64_t v27 = *(void *)(a2 + 1952);
          int v42 = (int)(float)(*(float *)(a3 + 8232) * (float)*(unsigned int *)(v27 + 32 * v83 + 16));
          if (v41 < v42) {
            int v42 = v41;
          }
          if (v42 <= 1) {
            unsigned int v39 = 1;
          }
          else {
            unsigned int v39 = v42;
          }
        }
        if (*(_DWORD *)(a3 + 8948))
        {
          uint64_t v43 = v83 - 1;
          if (*(_DWORD *)(v27 + 32 * (v83 - 1) + 16))
          {
            uint64_t v44 = 0;
            unint64_t v45 = 0;
            do
            {
              unsigned int v46 = *(_DWORD *)(*(void *)(v27 + 32 * v43) + v44) + 1;
              mfs_getUnitDataFromMfsData((unsigned __int8 *)a1, v46, (uint64_t *)&v86);
              if (mfs_PhoneticContextCost(v86 + 12, (unsigned __int8 *)&v97, 1.0) <= 0.5)
              {
                uint64_t v47 = mfs_CostList_Add((uint64_t)a1, v25, v83, v46, *((void *)a1 + 298), a1[598], &v88, (float)(1000.0 - *(float *)v86) + 100.0);
                if ((v47 & 0x80000000) != 0)
                {
                  uint64_t v11 = v47;
                  if ((v47 & 0x1FFF) != 2) {
                    goto LABEL_115;
                  }
                  uint64_t v25 = (void *)(a2 + 1944);
                  mfs_CostList_UpdateCost((uint64_t)v84, v83, v88, *(float *)(*(void *)(*(void *)(a2 + 1952) + 32 * v83) + 8 * v88 + 4) - *(float *)v86);
                }
                else
                {
                  ++v39;
                  MFS__log_select_Diag(v81, 3, (uint64_t)"CostList %lu, backfilled tri-phone %lu\n");
                  uint64_t v25 = (void *)(a2 + 1944);
                }
              }
              ++v45;
              uint64_t v27 = *(void *)(a2 + 1952);
              v44 += 8;
            }
            while (v45 < *(unsigned int *)(v27 + 32 * v43 + 16));
          }
        }
        uint64_t v6 = v81;
        MFS__log_select_Diag(v81, 3, (uint64_t)"nCan:(%d)|bInv:(%d)|Prne:(%d)|CtxtW:(%f)\n");
        uint64_t v48 = mfs_CostList_Sort((uint64_t)v25, v83, 1);
        unsigned int v49 = v25;
        uint64_t v11 = v48;
        if ((v48 & 0x80000000) != 0) {
          goto LABEL_115;
        }
        mfs_CostList_Prune(v49, v83, v39);
        uint64_t v50 = *(void *)(a2 + 1952);
        a3 = v73;
        if (*(_DWORD *)(v50 + 32 * v83 + 16))
        {
          uint64_t v51 = 0;
          unint64_t v52 = 0;
          do
          {
            int v85 = 0;
            memset(v99, 0, 80);
            uint64_t AcousticVector = mfs_ParamMap_GetAcousticVector(v81, (uint64_t)a1, a2, *(unsigned int *)(*(void *)(v50 + 32 * v83) + v51), (uint64_t)v99, &v85);
            if ((AcousticVector & 0x80000000) != 0) {
              goto LABEL_108;
            }
            if ((int)v90 <= v85) {
              unsigned int v53 = v85;
            }
            else {
              unsigned int v53 = v90;
            }
            LODWORD(v92) = v53;
            uint64_t v11 = UNICORN__mfs_S32Vect_Reserve((uint64_t)&v91, v53);
            if ((v11 & 0x80000000) != 0) {
              return v11;
            }
            float v54 = mfs_TCost_CandidateCost((uint64_t)v89, v73, (uint64_t)v99, v85);
            mfs_ParamMap_UnMapSection(a2);
            mfs_CostList_UpdateCost((uint64_t)v84, v83, v52++, v54);
            uint64_t v50 = *(void *)(a2 + 1952);
            v51 += 8;
          }
          while (v52 < *(unsigned int *)(v50 + 32 * v83 + 16));
        }
        uint64_t v14 = v83 + 1;
        uint64_t v15 = v80 + 1;
        int v8 = v68;
        uint64_t v7 = v69;
        float v13 = v74;
        if (v80 > (int)*a1)
        {
          int v82 = v83 + 1;
          goto LABEL_91;
        }
      }
      LODWORD(v28) = v80;
LABEL_55:
      signed int v32 = v75;
      int v31 = v78;
      goto LABEL_56;
    }
LABEL_91:
    if (++v7 >= *(int *)(a2 + 608)) {
      goto LABEL_94;
    }
  }
LABEL_115:
  mfs_Harch_DeInit((uint64_t)v95);
  UNICORN__mfs_S32Vect_Clear(v96);
  mfs_TCost_Clear(v89);
  return v11;
}