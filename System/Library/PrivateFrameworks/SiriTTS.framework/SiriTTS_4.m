double edct_DctItOpen(uint64_t a1, _DWORD *a2, uint64_t *a3)
{
  double result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t vars8;

  if (a2[11] != 1)
  {
    if (a2[8])
    {
      if (DctIt_RO_Open(a1, (uint64_t)a2, a3)) {
        return result;
      }
      v7 = *a3;
      *(_DWORD *)(v7 + 40) = 0;
      if (DctIt_RO_HasEnded(v7)) {
        return result;
      }
    }
    else
    {
      ++a2[10];
      if (DctIt_RW_Open(a1, (uint64_t)a2, a3)) {
        return result;
      }
      v8 = *a3;
      *(_DWORD *)(v8 + 40) = 0;
      if (DctIt_RW_HasEnded(v8)) {
        return result;
      }
    }
    *(void *)*a3 = a1;
    *(void *)(*a3 + 8) = a2;
    *(void *)(*a3 + 32) = 0;
    *(void *)(*a3 + 16) = 0;
    v9 = *a3;
    *(_DWORD *)(v9 + 24) = 0;
    *(void *)&result = 0x100000000;
    *(void *)(v9 + 44) = 0x100000000;
    return result;
  }
  kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pDct");
  return result;
}

uint64_t edct_DctItClose(uint64_t *a1)
{
  uint64_t v2 = a1[1];
  if (*(_DWORD *)(v2 + 32))
  {
    uint64_t result = DctIt_RO_FreeLastItem(a1);
    if (result) {
      return result;
    }
    goto LABEL_6;
  }
  --*(_DWORD *)(v2 + 40);
  uint64_t result = DctIt_RW_FreeLastItem((uint64_t)a1);
  if (!result)
  {
    uint64_t result = DctIt_RW_Close((uint64_t)a1);
    if (!result)
    {
LABEL_6:
      OOCAllocator_Free(*a1, (uint64_t)a1);
      return 0;
    }
  }
  return result;
}

uint64_t edct_DctItHasEnded(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 40);
  return 0;
}

uint64_t edct_DctItCurrent(uint64_t a1, void *a2, void *a3, _DWORD *a4, _DWORD *a5)
{
  if (a2) {
    *a2 = 0;
  }
  if (a3) {
    *a3 = 0;
  }
  if (a4) {
    *a4 = 0;
  }
  if (a5) {
    *a5 = 0;
  }
  *(_DWORD *)(a1 + 52) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  if (a2) {
    *(_DWORD *)(a1 + 52) = 1;
  }
  if (a3) {
    *(_DWORD *)(a1 + 56) = 1;
  }
  if (*(_DWORD *)(a1 + 40))
  {
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pDctIt");
  }
  else
  {
    if (!*(_DWORD *)(a1 + 44))
    {
      if (*(_DWORD *)(*(void *)(a1 + 8) + 32))
      {
        uint64_t result = DctIt_RO_Current(a1);
        if (result) {
          return result;
        }
      }
      else
      {
        uint64_t result = DctIt_RW_Current(a1);
        if (result) {
          return result;
        }
      }
    }
    if (a2) {
      *a2 = *(void *)(a1 + 32);
    }
    if (a3) {
      *a3 = *(void *)(a1 + 16);
    }
    if (a4) {
      *a4 = *(_DWORD *)(a1 + 24);
    }
    if (a5) {
      *a5 = *(_DWORD *)(a1 + 48);
    }
    uint64_t result = 0;
    *(void *)(a1 + 44) = 1;
  }
  return result;
}

uint64_t edct_DctItIncrement(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 40))
  {
    if (*(_DWORD *)(*(void *)(a1 + 8) + 32))
    {
      uint64_t result = DctIt_RO_FreeLastItem((uint64_t *)a1);
      if (result) {
        return result;
      }
      uint64_t result = DctIt_RO_Increment(a1);
      if (result) {
        return result;
      }
      uint64_t result = DctIt_RO_HasEnded(a1);
      if (result) {
        return result;
      }
    }
    else
    {
      uint64_t result = DctIt_RW_FreeLastItem(a1);
      if (result) {
        return result;
      }
      uint64_t result = DctIt_RW_Increment(a1);
      if (result) {
        return result;
      }
      uint64_t result = DctIt_RW_HasEnded(a1);
      if (result) {
        return result;
      }
    }
    uint64_t result = 0;
    *(_DWORD *)(a1 + 44) = 0;
    return result;
  }
  return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pDctIt");
}

uint64_t CDSObject_Con(void *a1, uint64_t a2, _OWORD *a3, uint64_t a4, _DWORD *a5)
{
  uint64_t result = CDSBase_Con(a1, a2, a3, a4, a5);
  if (!result)
  {
    *a1 = &__CDSObject;
    a1[19] = &unk_26C21A3A0;
    a1[20] = &unk_26C21A3D8;
    a1[21] = &unk_26C21A400;
    a1[22] = &unk_26C21A418;
    a1[3] = &unk_26C21A358;
    return __CDSObject_Init((uint64_t)a1, a2);
  }
  return result;
}

uint64_t __CDSObject_Init(uint64_t a1, uint64_t a2)
{
  unsigned int v7 = 0;
  *(_DWORD *)(a1 + 200) = 0;
  v4 = (void *)OOCAllocator_Calloc(a2, 1, 40, &v7);
  *(void *)(a1 + 184) = v4;
  uint64_t v5 = v7;
  if (!v7)
  {
    void *v4 = a1 + 144;
    return PNEW_TranscriptionTokenizer_Con(a2, a2, (void *)(a1 + 192));
  }
  return v5;
}

uint64_t CDSObject_Des(void *a1)
{
  uint64_t v2 = a1[13];
  uint64_t result = OOC_PlacementDeleteObject(v2, a1[24]);
  if (!result)
  {
    uint64_t v4 = a1[23];
    if (v4) {
      OOCAllocator_Free(v2, v4);
    }
    return CDSBase_Des(a1);
  }
  return result;
}

uint64_t CDSObject_BorrowTranscriptionSpec(uint64_t a1, void *a2)
{
  *a2 = *(void *)(a1 + 184);
  return 0;
}

uint64_t CDSObject_CastToIVoConObject(uint64_t a1)
{
  return a1 + 24;
}

uint64_t CDSObject_FetchInfo(uint64_t a1, uint64_t a2)
{
  unsigned int v7 = 0;
  uint64_t v4 = (void *)OOCAllocator_Calloc(*(void *)(a1 + 104), 1, 24, &v7);
  *(void *)a2 = v4;
  uint64_t v5 = v7;
  if (!v7)
  {
    void *v4 = a1 + 144;
    *(void *)(*(void *)a2 + 8) = CDSHash_GetNbrKeyEntries(a1);
    *(void *)(*(void *)a2 + 16) = CDSBase_GetNbrValueEntries(a1);
    return v7;
  }
  return v5;
}

uint64_t CDSObject_FetchKeys(uint64_t a1, uint64_t *a2, void *a3)
{
  unsigned int v23 = 0;
  v21 = 0;
  uint64_t v6 = *(void *)(a1 + 104);
  unsigned int NbrKeyEntries = CDSHash_GetNbrKeyEntries(a1);
  uint64_t v8 = NbrKeyEntries;
  *a3 = NbrKeyEntries;
  uint64_t v9 = 8 * NbrKeyEntries;
  unint64_t v10 = 0;
  if (NbrKeyEntries)
  {
    int v11 = 0;
    while (1)
    {
      uint64_t v12 = CDSHash_UnhashKey(a1) + 1;
      v13 = (unsigned __int16 *)OOCAllocator_Calloc(v6, 2, v12, &v23);
      uint64_t result = v23;
      if (v23) {
        break;
      }
      CDSHash_UnhashKey(a1);
      CDSHash_DecodeKey(a1, v12, (uint64_t)v13);
      v21 = v13;
      unint64_t v15 = utf16_utf8_byte_count(&v21);
      if (v15 == -1) {
        return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pUcs2Key");
      }
      v9 += v15 + 1;
      if (v15 >= v10) {
        unint64_t v10 = v15 + 1;
      }
      OOCAllocator_Free(v6, (uint64_t)v13);
      if (v8 == ++v11) {
        goto LABEL_8;
      }
    }
  }
  else
  {
LABEL_8:
    uint64_t v16 = OOCAllocator_Calloc(v6, 1, v9, &v23);
    *a2 = v16;
    uint64_t result = v23;
    if (!v23)
    {
      uint64_t v22 = v16 + 8 * v8;
      v17 = (unsigned __int16 *)OOCAllocator_Calloc(v6, 2, v10, &v23);
      uint64_t result = v23;
      if (!v23)
      {
        if (v8)
        {
          uint64_t v18 = 0;
          uint64_t v19 = v16 + v9;
          while (1)
          {
            int v20 = CDSHash_UnhashKey(a1);
            CDSHash_DecodeKey(a1, v20 + 1, (uint64_t)v17);
            *(void *)(v16 + 8 * v18) = v22;
            v21 = v17;
            if (utf16_to_utf8(&v21, &v17[v20 + 1], &v22, v19)) {
              return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pUcs2Key");
            }
            if (v8 == ++v18) {
              goto LABEL_14;
            }
          }
        }
        else
        {
LABEL_14:
          OOCAllocator_Free(v6, (uint64_t)v17);
          return v23;
        }
      }
    }
  }
  return result;
}

uint64_t CDSObject_FetchTranscriptionSpec(uint64_t a1, void *a2)
{
  *a2 = *(void *)(a1 + 184);
  return 0;
}

uint64_t CDSObject_FetchTranscriptions(uint64_t a1, char *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v27 = 0;
  unsigned int v31 = 0;
  unsigned int v32 = 0;
  unint64_t v29 = 0;
  uint64_t v30 = 0;
  char FieldSeparator = CDSBase_GetFieldSeparator(a1);
  uint64_t v9 = *(void *)(a1 + 104);
  uint64_t result = utf8_str_to_utf16(v9, a2, &v30, &v29);
  if (!result)
  {
    unsigned int v28 = 0;
    uint64_t result = CDSBase_GetOutputString(a1, v30, 0, &v27, &v31, (int *)&v28, &v32);
    unsigned int v33 = result;
    if (!result)
    {
      OOCAllocator_Free(v9, v30);
      uint64_t v11 = v28;
      if (v28)
      {
        uint64_t v12 = v27;
        uint64_t v13 = OOCAllocator_Calloc(v9, v28, 24, &v33);
        uint64_t result = v33;
        if (v33) {
          return result;
        }
        v25 = a4;
        unint64_t v26 = v11;
        unint64_t v14 = 0;
        unint64_t v15 = 0;
        unint64_t v16 = 0;
        unint64_t v17 = v31;
        do
        {
          if (v16 == v17 || FieldSeparator == *(char *)(v12 + v16))
          {
            uint64_t v19 = v16 - v15;
            if (v16 > v15)
            {
              if (v14 >= v26)
              {
                uint64_t result = kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Inconsitent CDS output");
                a4 = v25;
                uint64_t v11 = v26;
                if (result) {
                  return result;
                }
                goto LABEL_25;
              }
              *(_DWORD *)(v13 + 24 * v14) = CDSBase_GetTranscriptionType(a1);
              int v20 = (unsigned char *)(v12 + v15);
              if (*(_DWORD *)(a1 + 200))
              {
                BOOL v21 = *v20 == 35;
                if (*v20 == 35) {
                  uint64_t v22 = v20 + 1;
                }
                else {
                  uint64_t v22 = (unsigned char *)(v12 + v15);
                }
                *(void *)(v13 + 24 * v14 + 8) = v22;
                uint64_t v19 = v19 - v21 - (v20[v19 - v21] == 35);
                int v20 = v22;
              }
              else
              {
                *(void *)(v13 + 24 * v14 + 8) = v20;
              }
              v20[v19] = 0;
              *(void *)(v13 + 24 * v14++ + 16) = v19 + 1;
              unint64_t v17 = v31;
            }
            unint64_t v18 = v16 + 1;
            unint64_t v15 = v16 + 1;
          }
          else
          {
            unint64_t v18 = v16 + 1;
          }
          BOOL v23 = v16 >= v17;
          unint64_t v16 = v18;
        }
        while (!v23);
        uint64_t v11 = v26;
        if (v14 == v26) {
          uint64_t result = v33;
        }
        else {
          uint64_t result = kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Inconsitent CDS output");
        }
        a4 = v25;
        if (result) {
          return result;
        }
      }
      else
      {
        uint64_t v13 = 0;
      }
LABEL_25:
      uint64_t result = TranscriptionTokenizer_FetchTranscriptions(*(void *)(a1 + 192), v13, v11, a3, a4);
      if (!result)
      {
        if (v13)
        {
          uint64_t v24 = *(void *)(a1 + 104);
          OOCAllocator_Free(v24, v27);
          OOCAllocator_Free(v24, v13);
        }
        return lhi_LogPhoneticTranscriptions(*(void *)(a1 + 40), (const char *)0x3E62B2CD, a2, *a3, *a4);
      }
    }
  }
  return result;
}

uint64_t CDSObject_QueryInterface(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if (a2 > 1210932135)
  {
    if (a2 == 1210932136)
    {
      uint64_t v3 = a1 + 168;
      goto LABEL_11;
    }
    if (a2 == 3420193956)
    {
      uint64_t v3 = a1 + 176;
      goto LABEL_11;
    }
    return VoConObject_QueryInterface(a1, a2, a3);
  }
  if (a2 == 414531107)
  {
    uint64_t v3 = a1 + 160;
    goto LABEL_11;
  }
  if (a2 != 414531721) {
    return VoConObject_QueryInterface(a1, a2, a3);
  }
  uint64_t v3 = a1 + 152;
LABEL_11:
  *a3 = v3;
  return 0;
}

uint64_t CDSObject_ReturnInfo(uint64_t a1, uint64_t a2)
{
  if (a2) {
    OOCAllocator_Free(*(void *)(a1 + 104), a2);
  }
  return 0;
}

uint64_t CDSObject_ReturnKeys(uint64_t a1, uint64_t a2)
{
  if (a2) {
    OOCAllocator_Free(*(void *)(a1 + 104), a2);
  }
  return 0;
}

uint64_t CDSObject_ReturnTranscriptionSpec()
{
  return 0;
}

uint64_t CDSObject_ReturnTranscriptions(uint64_t a1, uint64_t a2)
{
  return TranscriptionTokenizer_ReturnTranscriptions(*(void *)(a1 + 192), a2);
}

uint64_t CDSObject_SetSilenceRemoveMode(uint64_t result, int a2)
{
  *(_DWORD *)(result + 200) = a2;
  return result;
}

uint64_t PNEW_CDSObject_Con(uint64_t a1, uint64_t a2, _OWORD *a3, uint64_t a4, _DWORD *a5, void *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = (void *)OOCAllocator_Malloc(a1, 208, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = CDSObject_Con(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      v12[2] = a1;
      *a6 = v12;
    }
  }
  return result;
}

uint64_t DctArchive(uint64_t a1, char *__b, int *a3, int a4)
{
  int v8 = *a3;
  if (__b) {
    memset(__b, 170, *a3);
  }
  v29[0] = 0;
  v29[1] = 0;
  __dst = 0;
  unsigned int v28 = 0;
  v25 = 0;
  uint64_t v26 = 0;
  uint64_t v24 = 0;
  uint64_t result = srvspi_MemblockInit((uint64_t)v29, v8, (uint64_t)__b);
  if (result) {
    return result;
  }
  if (a4)
  {
    uint64_t result = srvspi_MemblockAlign((int *)v29, 4u);
    if (result) {
      return result;
    }
    uint64_t result = srvspi_MemblockAlloc((unsigned int *)v29, 8, &v24);
    if (result) {
      return result;
    }
    if (v24) {
      *uint64_t v24 = 1397247071;
    }
  }
  uint64_t result = srvspi_MemblockAlign((int *)v29, 4u);
  if (result) {
    return result;
  }
  uint64_t result = srvspi_MemblockAlloc((unsigned int *)v29, 24, &v28);
  if (result) {
    return result;
  }
  if (*(void *)a1)
  {
    int v10 = strlen(*(const char **)a1) + 1;
    HIDWORD(v26) = v10;
    uint64_t result = srvspi_MemblockAlign((int *)v29, 1u);
    if (result) {
      return result;
    }
    uint64_t result = srvspi_MemblockAlloc((unsigned int *)v29, v10, &__dst);
    if (result) {
      return result;
    }
    if (__dst) {
      strcpy(__dst, *(const char **)a1);
    }
  }
  else
  {
    uint64_t result = srvspi_MemblockAlign((int *)v29, 1u);
    if (result) {
      return result;
    }
    uint64_t result = srvspi_MemblockAlloc((unsigned int *)v29, 1, &__dst);
    if (result) {
      return result;
    }
    if (__dst) {
      char *__dst = 0;
    }
  }
  uint64_t v11 = *(const char **)(a1 + 8);
  if (v11)
  {
    int v12 = strlen(v11);
    uint64_t result = srvspi_MemblockAlign((int *)v29, 1u);
    if (result) {
      return result;
    }
    uint64_t result = srvspi_MemblockAlloc((unsigned int *)v29, v12 + 1, &__dst);
    if (result) {
      return result;
    }
    if (__dst) {
      strcpy(__dst, *(const char **)(a1 + 8));
    }
  }
  else
  {
    uint64_t result = srvspi_MemblockAlign((int *)v29, 1u);
    if (result) {
      return result;
    }
    uint64_t result = srvspi_MemblockAlloc((unsigned int *)v29, 1, &__dst);
    if (result) {
      return result;
    }
    if (__dst) {
      char *__dst = 0;
    }
  }
  int NbrSubDct = GetNbrSubDct(a1);
  HIDWORD(v26) = 4 * NbrSubDct;
  uint64_t result = srvspi_MemblockAlign((int *)v29, 4u);
  if (result) {
    return result;
  }
  uint64_t result = srvspi_MemblockAlloc((unsigned int *)v29, 4 * NbrSubDct, &v25);
  if (result) {
    return result;
  }
  int v23 = 0;
  uint64_t result = DctGetBufferType(a1, &v23);
  if (result) {
    return result;
  }
  uint64_t v14 = *(void *)(a1 + 56);
  uint64_t result = srvspi_MemblockGetUsed(v29, &v26);
  if (result) {
    return result;
  }
  if (!v14)
  {
LABEL_42:
    uint64_t result = srvspi_MemblockGetUsed(v29, (_DWORD *)&v26 + 1);
    if (result) {
      return result;
    }
    unint64_t v17 = v28;
    if (v28)
    {
      uint64_t result = 0;
      *unsigned int v28 = v23;
      int v18 = HIDWORD(v26);
      *(void *)(v17 + 1) = HIDWORD(v26);
      *(void *)(v17 + 3) = *(void *)(a1 + 20);
      v17[5] = NbrSubDct;
      *a3 = v18;
      if (a4 != 1) {
        return result;
      }
      v17[1] = v18 - 8;
    }
    else
    {
      int v18 = HIDWORD(v26);
      *a3 = HIDWORD(v26);
      if (a4 != 1) {
        return 0;
      }
    }
    if (__b)
    {
      *((_DWORD *)__b + 1) = v18;
      uint64_t v19 = (v18 - 8);
      if (v19)
      {
        int v20 = &__b[v19 + 8];
        BOOL v21 = __b + 8;
        char v22 = -21;
        do
        {
          uint64_t result = 0;
          *v21++ += v22;
          v22 += 111;
        }
        while (v21 < v20);
        return result;
      }
    }
    return 0;
  }
  int v15 = v23;
  while (1)
  {
    uint64_t result = srvspi_MemblockAlign((int *)v29, 4u);
    if (result) {
      return result;
    }
    uint64_t result = srvspi_MemblockGetUsed(v29, (_DWORD *)&v26 + 1);
    if (result) {
      return result;
    }
    unint64_t v16 = v25;
    if (v25)
    {
      _DWORD *v25 = HIDWORD(v26) - v26;
      v25 = v16 + 1;
    }
    uint64_t result = SubDctArchive(v14, v15, (int *)v29);
    if (result) {
      return result;
    }
    uint64_t v14 = *(void *)(v14 + 136);
    if (!v14) {
      goto LABEL_42;
    }
  }
}

uint64_t DctGetBufferType(uint64_t a1, int *a2)
{
  *a2 = 0;
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {
    int v3 = 0;
    while (1)
    {
      if (*(void *)(v2 + 32))
      {
        if (!v3)
        {
          int v3 = 7;
LABEL_12:
          *a2 = v3;
          goto LABEL_13;
        }
        if (v3 != 7) {
          return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Unexpected: sub dictionaries should have the same type.");
        }
      }
      else
      {
        if (!v3)
        {
          int v3 = 6;
          goto LABEL_12;
        }
        if (v3 != 6) {
          return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Unexpected: sub dictionaries should have the same type.");
        }
      }
LABEL_13:
      uint64_t v2 = *(void *)(v2 + 136);
      if (!v2) {
        return 0;
      }
    }
  }
  *a2 = 6;
  return 0;
}

uint64_t SubDctArchive(uint64_t a1, int a2, int *a3)
{
  uint64_t v66 = 0;
  v67[0] = 0;
  v64 = 0;
  v65 = 0;
  uint64_t v63 = 0;
  memset(v62, 0, sizeof(v62));
  v60 = 0;
  v61 = 0;
  v58 = 0;
  v59 = 0;
  uint64_t result = srvspi_MemblockGetUsed(a3, v67);
  if (!result)
  {
    if (a2 == 7)
    {
      HIDWORD(v67[0]) = 52;
      uint64_t result = srvspi_MemblockAlign(a3, 4u);
      if (result) {
        return result;
      }
      int v7 = HIDWORD(v67[0]);
      int v8 = &v65;
    }
    else
    {
      HIDWORD(v67[0]) = 48;
      uint64_t result = srvspi_MemblockAlign(a3, 4u);
      if (result) {
        return result;
      }
      int v7 = HIDWORD(v67[0]);
      int v8 = &v64;
    }
    uint64_t result = srvspi_MemblockAlloc((unsigned int *)a3, v7, v8);
    if (!result)
    {
      uint64_t v9 = *(const char **)(a1 + 24);
      if (v9)
      {
        __dst[0] = 0;
        HIDWORD(v67[0]) = strlen(v9) + 1;
        uint64_t result = srvspi_MemblockAlign(a3, 1u);
        if (result) {
          return result;
        }
        uint64_t result = srvspi_MemblockAlloc((unsigned int *)a3, SHIDWORD(v67[0]), __dst);
        if (result) {
          return result;
        }
        if (__dst[0]) {
          strcpy(__dst[0], *(const char **)(a1 + 24));
        }
        int v10 = 1;
      }
      else
      {
        int v10 = 0;
      }
      uint64_t v11 = *(const char **)(a1 + 32);
      if (v11)
      {
        __dst[0] = 0;
        HIDWORD(v67[0]) = strlen(v11) + 1;
        uint64_t result = srvspi_MemblockAlign(a3, 1u);
        if (result) {
          return result;
        }
        uint64_t result = srvspi_MemblockAlloc((unsigned int *)a3, SHIDWORD(v67[0]), __dst);
        if (result) {
          return result;
        }
        if (__dst[0]) {
          strcpy(__dst[0], *(const char **)(a1 + 32));
        }
        int v12 = 1;
        int v13 = 6;
      }
      else
      {
        int v12 = 0;
        int v13 = 7;
      }
      if (v13 == a2) {
        return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Unexpected");
      }
      if (*(void *)(a1 + 40))
      {
        __dst[0] = 0;
        HIDWORD(v67[0]) = 129;
        uint64_t result = srvspi_MemblockAlign(a3, 1u);
        if (result) {
          return result;
        }
        uint64_t result = srvspi_MemblockAlloc((unsigned int *)a3, SHIDWORD(v67[0]), __dst);
        if (result) {
          return result;
        }
        uint64_t v14 = __dst[0];
        if (__dst[0])
        {
          uint64_t v15 = *(void *)(a1 + 40);
          *(_OWORD *)__dst[0] = *(_OWORD *)v15;
          long long v16 = *(_OWORD *)(v15 + 16);
          long long v17 = *(_OWORD *)(v15 + 32);
          long long v18 = *(_OWORD *)(v15 + 64);
          *((_OWORD *)v14 + 3) = *(_OWORD *)(v15 + 48);
          *((_OWORD *)v14 + 4) = v18;
          *((_OWORD *)v14 + 1) = v16;
          *((_OWORD *)v14 + 2) = v17;
          long long v19 = *(_OWORD *)(v15 + 80);
          long long v20 = *(_OWORD *)(v15 + 96);
          long long v21 = *(_OWORD *)(v15 + 112);
          v14[128] = *(unsigned char *)(v15 + 128);
          *((_OWORD *)v14 + 6) = v20;
          *((_OWORD *)v14 + 7) = v21;
          *((_OWORD *)v14 + 5) = v19;
        }
        int v22 = 1;
      }
      else
      {
        int v22 = 0;
      }
      int v23 = *(const char **)(a1 + 48);
      if (v23)
      {
        __dst[0] = 0;
        HIDWORD(v67[0]) = strlen(v23) + 1;
        uint64_t result = srvspi_MemblockAlign(a3, 1u);
        if (result) {
          return result;
        }
        uint64_t result = srvspi_MemblockAlloc((unsigned int *)a3, SHIDWORD(v67[0]), __dst);
        if (result) {
          return result;
        }
        if (__dst[0]) {
          strcpy(__dst[0], *(const char **)(a1 + 48));
        }
        int v24 = 1;
      }
      else
      {
        int v24 = 0;
      }
      HIDWORD(v67[0]) = 4 * *(_DWORD *)a1 + 4;
      uint64_t result = srvspi_MemblockAlign(a3, 4u);
      if (!result)
      {
        uint64_t result = srvspi_MemblockAlloc((unsigned int *)a3, SHIDWORD(v67[0]), &v61);
        if (!result)
        {
          uint64_t result = srvspi_MemblockGetUsed(a3, (_DWORD *)&v66 + 1);
          if (!result)
          {
            uint64_t result = DICTITT_Init((uint64_t)v62, (uint64_t *)(a1 + 56));
            if (!result)
            {
              int v25 = 0;
              while (DWORD2(v62[0]) || v63 != -1)
              {
                do
                  DICTITT_Current((unsigned int *)v62, (uint64_t)__dst);
                while (v57 == 1);
                int v27 = strlen(__dst[0]);
                if (v63 == -1) {
                  uint64_t result = BINTREEITT_Inc((unsigned int *)v62 + 2);
                }
                else {
                  uint64_t result = 0;
                }
                v25 += v27 + 1;
                if (result) {
                  return result;
                }
              }
              uint64_t result = ARRAY_Flush((uint64_t)&v62[1] + 8);
              if (!result)
              {
                HIDWORD(v67[0]) = 1;
                uint64_t result = srvspi_MemblockAlign(a3, 1u);
                if (!result)
                {
                  uint64_t result = srvspi_MemblockAlloc((unsigned int *)a3, v25, &v58);
                  if (!result)
                  {
                    uint64_t result = srvspi_MemblockGetUsed(a3, (_DWORD *)v67 + 1);
                    if (!result)
                    {
                      int v53 = HIDWORD(v67[0]);
                      int v28 = HIDWORD(v66);
                      HIDWORD(v67[0]) = 4 * *(_DWORD *)a1 + 4;
                      uint64_t result = srvspi_MemblockAlign(a3, 4u);
                      if (!result)
                      {
                        uint64_t result = srvspi_MemblockAlloc((unsigned int *)a3, SHIDWORD(v67[0]), &v60);
                        if (!result)
                        {
                          uint64_t result = srvspi_MemblockGetUsed(a3, &v66);
                          if (!result)
                          {
                            uint64_t result = srvspi_MemblockAlign(a3, 1u);
                            if (!result)
                            {
                              uint64_t result = srvspi_MemblockAlloc((unsigned int *)a3, 1, &v59);
                              if (!result)
                              {
                                int v48 = v22;
                                int v49 = v24;
                                int v46 = v12;
                                int v47 = v10;
                                if (v59) {
                                  unsigned char *v59 = -86;
                                }
                                v51 = v58;
                                uint64_t result = DICTITT_Init((uint64_t)v62, (uint64_t *)(a1 + 56));
                                if (!result)
                                {
                                  if (!DWORD2(v62[0]) && v63 == -1)
                                  {
LABEL_68:
                                    uint64_t result = ARRAY_Flush((uint64_t)&v62[1] + 8);
                                    if (!result)
                                    {
                                      uint64_t result = srvspi_MemblockGetUsed(a3, (_DWORD *)v67 + 1);
                                      if (!result)
                                      {
                                        if (v60) {
                                          _DWORD *v60 = HIDWORD(v67[0]) - v66;
                                        }
                                        int v29 = HIDWORD(v67[0]);
                                        int v30 = v66;
                                        if (v61 && v51 && v58) {
                                          _DWORD *v61 = v51 - v58;
                                        }
                                        int v31 = v53 - v28;
                                        int v32 = v29 - v30;
                                        unsigned int v33 = v65;
                                        if (v65)
                                        {
                                          uint64_t result = 0;
                                          _DWORD *v65 = HIDWORD(v67[0]) - LODWORD(v67[0]);
                                          *((void *)v33 + 1) = *(void *)(a1 + 8);
                                          v33[4] = *(_DWORD *)(a1 + 16);
                                          v33[5] = v47;
                                          v33[6] = v46;
                                          v33[7] = v48;
                                          v33[8] = v49;
                                          *(void *)(v33 + 9) = *(void *)a1;
                                          v33[11] = v31;
                                          v33[12] = v32;
                                        }
                                        else
                                        {
                                          unsigned int v33 = v64;
                                          if (!v64) {
                                            return 0;
                                          }
                                          uint64_t result = 0;
                                          _DWORD *v64 = HIDWORD(v67[0]) - LODWORD(v67[0]);
                                          *((void *)v33 + 1) = *(void *)(a1 + 8);
                                          v33[4] = *(_DWORD *)(a1 + 16);
                                          v33[5] = v47;
                                          v33[6] = v48;
                                          v33[7] = v49;
                                          *((void *)v33 + 4) = *(void *)a1;
                                          v33[10] = v31;
                                          v33[11] = v32;
                                        }
                                        v33[1] = 0;
                                        return result;
                                      }
                                    }
                                    return result;
                                  }
                                  int v34 = 0;
                                  while (1)
                                  {
                                    v54 = 0;
                                    DICTITT_Current((unsigned int *)v62, (uint64_t)__dst);
                                    __src = __dst[1];
                                    int v35 = v56;
                                    int v52 = v57;
                                    if (!v34)
                                    {
                                      v38 = __dst[0];
                                      v39 = v61;
                                      v40 = v58;
                                      if (v61) {
                                        BOOL v41 = v51 == 0;
                                      }
                                      else {
                                        BOOL v41 = 1;
                                      }
                                      if (!v41 && v58 != 0)
                                      {
                                        _DWORD *v61 = v51 - v58;
                                        v61 = v39 + 1;
                                      }
                                      if (v40 && v51)
                                      {
                                        size_t v43 = strlen(v38) + 1;
                                        memcpy(v51, v38, v43);
                                        v51 += v43;
                                      }
                                      uint64_t result = srvspi_MemblockGetUsed(a3, (_DWORD *)v67 + 1);
                                      if (result) {
                                        return result;
                                      }
                                      v44 = v60;
                                      if (v60)
                                      {
                                        if (v52 == 1)
                                        {
                                          _DWORD *v60 = v66 - HIDWORD(v67[0]);
                                          v60 = v44 + 1;
                                          HIDWORD(v67[0]) = v35;
                                          int v36 = 1;
LABEL_84:
                                          __dst[0] = 0;
                                          uint64_t result = srvspi_MemblockAlign(a3, 2u);
                                          if (result) {
                                            return result;
                                          }
                                          uint64_t result = srvspi_MemblockAlloc((unsigned int *)a3, 2, __dst);
                                          if (result) {
                                            return result;
                                          }
                                          if (__dst[0]) {
                                            *(_WORD *)__dst[0] = WORD2(v67[0]);
                                          }
                                          char v37 = 0;
                                          goto LABEL_105;
                                        }
                                        _DWORD *v60 = HIDWORD(v67[0]) - v66;
                                        v60 = v44 + 1;
                                      }
                                    }
                                    if (v52 == 1) {
                                      int v36 = 1;
                                    }
                                    else {
                                      int v36 = v34;
                                    }
                                    HIDWORD(v67[0]) = v35;
                                    if (v36) {
                                      goto LABEL_84;
                                    }
                                    char v37 = 1;
LABEL_105:
                                    uint64_t result = srvspi_MemblockAlign(a3, 1u);
                                    if (result) {
                                      return result;
                                    }
                                    uint64_t result = srvspi_MemblockAlloc((unsigned int *)a3, SHIDWORD(v67[0]), &v54);
                                    if (result) {
                                      return result;
                                    }
                                    if (v54) {
                                      memcpy(v54, __src, HIDWORD(v67[0]));
                                    }
                                    if ((v37 & 1) == 0)
                                    {
                                      uint64_t result = srvspi_MemblockAlign(a3, 2u);
                                      if (result) {
                                        return result;
                                      }
                                    }
                                    if (v52) {
                                      int v34 = v36;
                                    }
                                    else {
                                      int v34 = 0;
                                    }
                                    int v45 = v63;
                                    if (v63 == -1)
                                    {
                                      uint64_t result = BINTREEITT_Inc((unsigned int *)v62 + 2);
                                      if (result) {
                                        return result;
                                      }
                                      int v45 = v63;
                                    }
                                    if (!DWORD2(v62[0]) && v45 == -1) {
                                      goto LABEL_68;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t DctFromArchive(char **a1, uint64_t a2)
{
  v16[0] = 0;
  v16[1] = 0;
  __src = 0;
  __s = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v17 = a2;
  uint64_t result = srvspi_MemblockInit((uint64_t)v16, *(_DWORD *)(a2 + 4), a2);
  if (!result)
  {
    uint64_t result = srvspi_MemblockAlign((int *)v16, 4u);
    if (!result)
    {
      uint64_t result = srvspi_MemblockRead(v16, 24, &v17);
      if (!result)
      {
        int v4 = *(_DWORD *)v17;
        if ((*(_DWORD *)v17 & 0xFFFFFE) != 6)
        {
          uint64_t v5 = "Wrong buffer type!";
          return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v5);
        }
        if (*(_DWORD *)(v17 + 8))
        {
          uint64_t v5 = "Corrupted buffer!";
          return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)v5);
        }
        *(char **)((char *)a1 + 20) = *(char **)(v17 + 12);
        uint64_t result = srvspi_MemblockAlign((int *)v16, 1u);
        if (!result)
        {
          uint64_t result = srvspi_MemblockRead(v16, 0, &__s);
          if (!result)
          {
            size_t v6 = strlen(__s);
            uint64_t result = srvspi_MemblockRead(v16, v6 + 1, &__s);
            unsigned int v18 = result;
            if (!result)
            {
              if (v6)
              {
                int v7 = (char *)OOCAllocator_Malloc((uint64_t)a1[6], v6 + 1, &v18);
                *a1 = v7;
                uint64_t result = v18;
                if (v18) {
                  return result;
                }
                strcpy(v7, __s);
              }
              else
              {
                *a1 = 0;
              }
              uint64_t result = srvspi_MemblockAlign((int *)v16, 1u);
              unsigned int v18 = result;
              if (!result)
              {
                uint64_t result = srvspi_MemblockRead(v16, 0, &__src);
                unsigned int v18 = result;
                if (!result)
                {
                  size_t v8 = strlen(__src);
                  uint64_t result = srvspi_MemblockRead(v16, v8 + 1, &__src);
                  unsigned int v18 = result;
                  if (!result)
                  {
                    if (v8)
                    {
                      uint64_t v9 = (char *)OOCAllocator_Malloc((uint64_t)a1[6], v8 + 1, &v18);
                      a1[1] = v9;
                      uint64_t result = v18;
                      if (v18) {
                        return result;
                      }
                      strcpy(v9, __src);
                    }
                    else
                    {
                      a1[1] = 0;
                    }
                    uint64_t result = srvspi_MemblockAlign((int *)v16, 4u);
                    unsigned int v18 = result;
                    if (!result)
                    {
                      uint64_t result = srvspi_MemblockRead(v16, (4 * *(_DWORD *)(v17 + 20)), &v13);
                      unsigned int v18 = result;
                      if (!result)
                      {
                        uint64_t result = srvspi_MemblockAlign((int *)v16, 4u);
                        unsigned int v18 = result;
                        if (!result)
                        {
                          uint64_t result = srvspi_MemblockRead(v16, 0, &v12);
                          unsigned int v18 = result;
                          if (!result)
                          {
                            if (*(_DWORD *)(v17 + 20))
                            {
                              unsigned int v10 = 0;
                              do
                              {
                                uint64_t v11 = 0;
                                uint64_t result = CreateSubDct((uint64_t)a1, &v11);
                                unsigned int v18 = result;
                                if (result) {
                                  break;
                                }
                                uint64_t result = srvspi_MemblockAlign((int *)v16, 4u);
                                unsigned int v18 = result;
                                if (result) {
                                  break;
                                }
                                uint64_t result = SubDctFromArchive(v11, v4 & 0xFFFFFF, (int *)v16, (uint64_t)a1[6]);
                                unsigned int v18 = result;
                                if (result) {
                                  break;
                                }
                                v13 += 4;
                                ++v10;
                              }
                              while (v10 < *(_DWORD *)(v17 + 20));
                            }
                            else
                            {
                              return 0;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t SubDctFromArchive(uint64_t a1, int a2, int *a3, uint64_t a4)
{
  v50 = 0;
  v51 = 0;
  int v45 = 0;
  uint64_t result = srvspi_MemblockAlign(a3, 4u);
  unsigned int v52 = result;
  if (!result)
  {
    int v49 = 0;
    int v47 = 0;
    int v48 = 0;
    uint64_t v46 = 0;
    if (a2 == 6)
    {
      uint64_t result = srvspi_MemblockRead(a3, 48, &v51);
      unsigned int v52 = result;
      if (result) {
        return result;
      }
      uint64_t v9 = 0;
      unsigned int v10 = v51;
    }
    else
    {
      uint64_t result = srvspi_MemblockRead(a3, 52, &v50);
      unsigned int v52 = result;
      if (result) {
        return result;
      }
      unsigned int v10 = 0;
      uint64_t v9 = v50;
    }
    if (v10) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = v9;
    }
    int v12 = v11[1];
    *(_DWORD *)(a1 + 8) = v11[2];
    *(_DWORD *)(a1 + 16) = v11[4];
    *(_DWORD *)(a1 + 12) = v11[3];
    uint64_t v13 = v10 + 8;
    if (!v10) {
      uint64_t v13 = v9 + 9;
    }
    *(_DWORD *)a1 = *v13;
    uint64_t v14 = v10 + 9;
    if (!v10) {
      uint64_t v14 = v9 + 10;
    }
    *(_DWORD *)(a1 + 4) = *v14;
    *(void *)(a1 + 24) = 0;
    uint64_t result = srvspi_MemblockAlign(a3, 1u);
    unsigned int v52 = result;
    if (!result)
    {
      if (v10) {
        uint64_t v15 = v10;
      }
      else {
        uint64_t v15 = v9;
      }
      if (v15[5] == 1)
      {
        __s = 0;
        uint64_t result = srvspi_MemblockRead(a3, 0, &__s);
        unsigned int v52 = result;
        if (result) {
          return result;
        }
        uint64_t v16 = strlen(__s) + 1;
        uint64_t result = srvspi_MemblockRead(a3, v16, &__s);
        unsigned int v52 = result;
        if (result) {
          return result;
        }
        uint64_t v17 = (char *)OOCAllocator_Malloc(a4, v16, &v52);
        *(void *)(a1 + 24) = v17;
        uint64_t result = v52;
        if (v52) {
          return result;
        }
        strcpy(v17, __s);
      }
      *(void *)(a1 + 32) = 0;
      uint64_t result = srvspi_MemblockAlign(a3, 1u);
      unsigned int v52 = result;
      if (result) {
        return result;
      }
      if (!v10 && v9[6] == 1)
      {
        __s = 0;
        uint64_t result = srvspi_MemblockRead(a3, 0, &__s);
        unsigned int v52 = result;
        if (result) {
          return result;
        }
        uint64_t v18 = strlen(__s) + 1;
        uint64_t result = srvspi_MemblockRead(a3, v18, &__s);
        unsigned int v52 = result;
        if (result) {
          return result;
        }
        long long v19 = (char *)OOCAllocator_Malloc(a4, v18, &v52);
        *(void *)(a1 + 32) = v19;
        uint64_t result = v52;
        if (v52) {
          return result;
        }
        strcpy(v19, __s);
      }
      *(void *)(a1 + 40) = 0;
      uint64_t result = srvspi_MemblockAlign(a3, 1u);
      unsigned int v52 = result;
      if (result) {
        return result;
      }
      long long v20 = v10 + 6;
      if (!v10) {
        long long v20 = v9 + 7;
      }
      if (*v20 == 1)
      {
        __s = 0;
        uint64_t result = srvspi_MemblockRead(a3, 0, &__s);
        unsigned int v52 = result;
        if (result) {
          return result;
        }
        uint64_t result = srvspi_MemblockRead(a3, 129, &__s);
        unsigned int v52 = result;
        if (result) {
          return result;
        }
        long long v21 = (_OWORD *)OOCAllocator_Malloc(a4, 129, &v52);
        *(void *)(a1 + 40) = v21;
        uint64_t result = v52;
        if (v52) {
          return result;
        }
        int v22 = __s;
        long long v23 = *((_OWORD *)__s + 3);
        long long v25 = *(_OWORD *)__s;
        long long v24 = *((_OWORD *)__s + 1);
        v21[2] = *((_OWORD *)__s + 2);
        v21[3] = v23;
        _OWORD *v21 = v25;
        v21[1] = v24;
        long long v26 = *((_OWORD *)v22 + 7);
        long long v28 = *((_OWORD *)v22 + 4);
        long long v27 = *((_OWORD *)v22 + 5);
        v21[6] = *((_OWORD *)v22 + 6);
        v21[7] = v26;
        v21[4] = v28;
        v21[5] = v27;
        *(unsigned char *)(*(void *)(a1 + 40) + 128) = 0;
      }
      *(void *)(a1 + 48) = 0;
      unsigned int v52 = srvspi_MemblockAlign(a3, 1u);
      if (v10)
      {
        if (!v10[7]) {
          goto LABEL_47;
        }
      }
      else if (!v9[8])
      {
LABEL_47:
        uint64_t result = DICT_Init(a1 + 56, a4, 10000, 50000);
        unsigned int v52 = result;
        if (!result)
        {
          uint64_t result = srvspi_MemblockAlign(a3, 4u);
          unsigned int v52 = result;
          if (!result)
          {
            uint64_t result = srvspi_MemblockRead(a3, (4 * *(_DWORD *)a1 + 4), &v48);
            unsigned int v52 = result;
            if (!result)
            {
              unsigned int v31 = v12 ? 2 : 1;
              uint64_t result = srvspi_MemblockAlign(a3, v31);
              unsigned int v52 = result;
              if (!result)
              {
                int v32 = v10 + 10;
                if (!v10) {
                  int v32 = v9 + 11;
                }
                uint64_t result = srvspi_MemblockRead(a3, *v32, &v46);
                unsigned int v52 = result;
                if (!result)
                {
                  uint64_t result = srvspi_MemblockAlign(a3, 4u);
                  unsigned int v52 = result;
                  if (!result)
                  {
                    uint64_t result = srvspi_MemblockRead(a3, (4 * *(_DWORD *)a1 + 4), &v47);
                    unsigned int v52 = result;
                    if (!result)
                    {
                      uint64_t result = srvspi_MemblockGetUsed(a3, &v49);
                      unsigned int v52 = result;
                      if (!result)
                      {
                        uint64_t result = srvspi_MemblockAlign(a3, 1u);
                        unsigned int v52 = result;
                        if (!result)
                        {
                          uint64_t result = srvspi_MemblockRead(a3, 1, 0);
                          unsigned int v52 = result;
                          if (!result)
                          {
                            if (*(_DWORD *)a1)
                            {
                              int v33 = v12;
                              for (unsigned int i = 0; i < *(_DWORD *)a1; ++i)
                              {
                                __s = 0;
                                int v43 = -1;
                                if (v33)
                                {
                                  v42 = 0;
                                  uint64_t result = utf16_str_to_utf8(a4, (unsigned __int16 *)(v46 + *v48), (uint64_t *)&v45, (unint64_t *)&v42);
                                  unsigned int v52 = result;
                                  if (result) {
                                    return result;
                                  }
                                }
                                else
                                {
                                  size_t v35 = strlen((const char *)(v46 + *v48));
                                  int v36 = (char *)OOCAllocator_Realloc(a4, (uint64_t)v45, v35 + 1, &v52);
                                  int v45 = v36;
                                  uint64_t result = v52;
                                  if (v52) {
                                    return result;
                                  }
                                  strcpy(v36, (const char *)(v46 + *v48));
                                }
                                int v37 = v47[1];
                                if (v37 >= 0) {
                                  unsigned int v38 = v47[1];
                                }
                                else {
                                  unsigned int v38 = -v37;
                                }
                                if ((*v47 & 0x80000000) != 0)
                                {
                                  int v41 = 0;
                                  int v41 = -*v47;
                                  uint64_t result = srvspi_MemblockAlign(a3, 2u);
                                  unsigned int v52 = result;
                                  if (result) {
                                    return result;
                                  }
                                  unsigned int v40 = v41;
                                  while (v40 < v38)
                                  {
                                    v42 = 0;
                                    uint64_t result = srvspi_MemblockRead(a3, 2, &v42);
                                    unsigned int v52 = result;
                                    if (result) {
                                      return result;
                                    }
                                    uint64_t result = srvspi_MemblockAlign(a3, 1u);
                                    unsigned int v52 = result;
                                    if (result) {
                                      return result;
                                    }
                                    uint64_t result = srvspi_MemblockRead(a3, *v42, &__s);
                                    unsigned int v52 = result;
                                    if (result) {
                                      return result;
                                    }
                                    uint64_t result = DICT_Add(a1 + 56, v45, __s, *v42, &v43);
                                    unsigned int v52 = result;
                                    if (result) {
                                      return result;
                                    }
                                    uint64_t result = srvspi_MemblockAlign(a3, 2u);
                                    unsigned int v52 = result;
                                    if (result) {
                                      return result;
                                    }
                                    uint64_t result = srvspi_MemblockGetUsed(a3, &v41);
                                    unsigned int v52 = result;
                                    if (result) {
                                      return result;
                                    }
                                    unsigned int v40 = v41 - v49;
                                    v41 -= v49;
                                  }
                                }
                                else
                                {
                                  LODWORD(v42) = 0;
                                  uint64_t result = srvspi_MemblockAlign(a3, 1u);
                                  unsigned int v52 = result;
                                  if (result) {
                                    return result;
                                  }
                                  uint64_t result = srvspi_MemblockGetUsed(a3, &v42);
                                  unsigned int v52 = result;
                                  if (result) {
                                    return result;
                                  }
                                  LODWORD(v42) = v42 - v49;
                                  uint64_t v39 = v38 - v42;
                                  uint64_t result = srvspi_MemblockRead(a3, v39, &__s);
                                  unsigned int v52 = result;
                                  if (result) {
                                    return result;
                                  }
                                  uint64_t result = DICT_Add(a1 + 56, v45, __s, v39, &v43);
                                  unsigned int v52 = result;
                                  if (result) {
                                    return result;
                                  }
                                }
                                ++v47;
                                ++v48;
                              }
                            }
                            OOCAllocator_Free(a4, (uint64_t)v45);
                            return v52;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result;
      }
      __s = 0;
      uint64_t result = srvspi_MemblockRead(a3, 0, &__s);
      unsigned int v52 = result;
      if (result) {
        return result;
      }
      uint64_t v29 = strlen(__s) + 1;
      uint64_t result = srvspi_MemblockRead(a3, v29, &__s);
      unsigned int v52 = result;
      if (result) {
        return result;
      }
      int v30 = (char *)OOCAllocator_Malloc(a4, v29, &v52);
      *(void *)(a1 + 48) = v30;
      uint64_t result = v52;
      if (v52) {
        return result;
      }
      strcpy(v30, __s);
      goto LABEL_47;
    }
  }
  return result;
}

uint64_t DctDecryptArchive(_DWORD **a1, int *a2)
{
  uint64_t v2 = *a1;
  if (**a1 == 1397247071)
  {
    int v4 = v2 + 2;
    if (v2[1] != 8)
    {
      unint64_t v5 = (unint64_t)&v4[v2[1] - 8];
      char v6 = -21;
      int v7 = v4;
      do
      {
        *v7++ -= v6;
        v6 += 111;
      }
      while ((unint64_t)v7 < v5);
      uint64_t v2 = *a1;
    }
    *uint64_t v2 = 1397247021;
    goto LABEL_10;
  }
  if (*v2 == 1397247021)
  {
    int v4 = v2 + 2;
LABEL_10:
    *a1 = v4;
    int v3 = 1;
    goto LABEL_11;
  }
  int v3 = 0;
LABEL_11:
  *a2 = v3;
  return 0;
}

uint64_t _DTQuestion_Con(void *a1, uint64_t a2)
{
  *a1 = &__DTQuestion;
  a1[1] = a2;
  return 0;
}

void *GetDTQuestionClass()
{
  return &__DTQuestion;
}

uint64_t PNEW_DTHypothesisList_Con(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  unsigned int v10 = 0;
  size_t v8 = (void *)OOCAllocator_Malloc(a1, 48, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = PtrList_Con((uint64_t)v8, a2, 1u, 1);
    if (result)
    {
      unsigned int v10 = result;
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *size_t v8 = &__DTHypothesisList;
      v8[5] = a3;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t DTGraphemeBuffer_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__DTGraphemeBuffer;
    *(void *)(a1 + 8) = a2;
    *(void *)(a1 + 24) = 0;
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 16) = a3;
    *(unsigned char *)(a1 + 40) = 0;
    return _DTGraphemeBuffer_CreateGPTable(a1);
  }
  return result;
}

uint64_t _DTGraphemeBuffer_CreateGPTable(uint64_t a1)
{
  unsigned int v22 = 0;
  uint64_t v2 = (void *)OOCAllocator_Realloc(*(void *)(a1 + 8), *(void *)(a1 + 24), 8 * *(unsigned __int16 *)(*(void *)(a1 + 16) + 4) + 8, &v22);
  *(void *)(a1 + 24) = v2;
  uint64_t v3 = v22;
  if (!v22)
  {
    int v4 = *(_DWORD **)(a1 + 16);
    unsigned int v6 = *v4;
    unint64_t v5 = (char *)v4 + 6;
    unint64_t v7 = *(void *)(a1 + 16) + v6;
    *uint64_t v2 = v5;
    uint64_t v8 = 1;
    *(unsigned char *)(a1 + 40) = 1;
    if (*(unsigned __int16 *)(*(void *)(a1 + 16) + 4) >= 2u)
    {
      uint64_t v8 = 1;
      unsigned __int8 v9 = 1;
      int v10 = 1;
      while (!*v5)
      {
LABEL_7:
        *(void *)(*(void *)(a1 + 24) + 8 * v8) = ++v5;
        if (**(unsigned __int8 **)(*(void *)(a1 + 24) + 8 * v8) != **(unsigned __int8 **)(*(void *)(a1 + 24)
                                                                                           + 8 * v8
                                                                                           - 8))
          *(unsigned char *)(a1 + 40) = ++v9;
        uint64_t v8 = ++v10;
        if (*(unsigned __int16 *)(*(void *)(a1 + 16) + 4) <= v10) {
          goto LABEL_12;
        }
      }
      while ((unint64_t)v5 < v7)
      {
        if (!*++v5) {
          goto LABEL_7;
        }
      }
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Grapheme block is corrupt");
    }
    unsigned __int8 v9 = 1;
LABEL_12:
    if (*v5)
    {
      while ((unint64_t)v5 < v7)
      {
        if (!*++v5) {
          goto LABEL_15;
        }
      }
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Grapheme block is corrupt");
    }
LABEL_15:
    *(void *)(*(void *)(a1 + 24) + 8 * v8) = v5 + 1;
    uint64_t v13 = OOCAllocator_Realloc(*(void *)(a1 + 8), *(void *)(a1 + 32), 16 * v9, &v22);
    *(void *)(a1 + 32) = v13;
    uint64_t v3 = v22;
    if (v22)
    {
      *(unsigned char *)(a1 + 40) = 0;
    }
    else
    {
      uint64_t v16 = *(void *)(a1 + 16);
      uint64_t v15 = *(void **)(a1 + 24);
      *(void *)uint64_t v13 = *v15;
      *(unsigned char *)(v13 + 8) = 0;
      unsigned int v17 = *(unsigned __int16 *)(v16 + 4);
      if (v17 >= 2)
      {
        unsigned __int8 v18 = 0;
        for (unsigned __int8 i = 1; i < v17; ++i)
        {
          long long v20 = (unsigned __int8 *)v15[i];
          if (*v20 != **(unsigned __int8 **)(v13 + 16 * v18))
          {
            uint64_t v21 = v13 + 16 * ++v18;
            *(void *)uint64_t v21 = v20;
            *(unsigned char *)(v21 + 8) = i;
          }
        }
      }
      lhstdlib_qsort(v13, *(unsigned __int8 *)(a1 + 40), 0x10u, (uint64_t (*)(unsigned char *, unsigned char *))__DTGraphemeBuffer_Compare);
      return v22;
    }
  }
  return v3;
}

uint64_t DTGraphemeBuffer_Des(uint64_t a1)
{
  *(void *)(a1 + 16) = 0;
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    OOCAllocator_Free(*(void *)(a1 + 8), v2);
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    OOCAllocator_Free(*(void *)(a1 + 8), v3);
    *(void *)(a1 + 32) = 0;
    *(unsigned char *)(a1 + 40) = 0;
  }
  return Object_Des();
}

uint64_t DTGraphemeBuffer_FirstGraphemeID(uint64_t a1, uint64_t a2)
{
  int v4 = -1;
  v5[0] = a2;
  v5[1] = 0;
  unint64_t v2 = lhstdlib_bsearch((uint64_t)v5, *(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40), 0x10uLL, (uint64_t (*)(uint64_t, unint64_t))__DTGraphemeBuffer_Compare, &v4);
  if (v2) {
    return *(unsigned __int8 *)(v2 + 8);
  }
  else {
    return 255;
  }
}

uint64_t __DTGraphemeBuffer_Compare(char **a1, char **a2)
{
  int v2 = **a1;
  int v3 = **a2;
  BOOL v4 = v2 < v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v5;
  }
}

uint64_t PNEW_DTGraphemeBuffer_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 48, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = DTGraphemeBuffer_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

uint64_t DTQuestionGPBin_IsTrue(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(a1 + 8);
  int v5 = *(char *)(v4 + 1) + a2;
  if (v5 < 0) {
    return 0;
  }
  uint64_t result = 0;
  if (a3 && v5 < a4)
  {
    int v7 = *(unsigned __int8 *)(v4 + 2);
    if (*(unsigned char *)(v4 + 2))
    {
      int v8 = 0;
      unsigned int v9 = *(unsigned __int8 *)(a3 + v5);
      uint64_t v10 = v4 + 3;
      int v11 = v7 - 1;
      while (1)
      {
        int v12 = (v11 + v8) >> 1;
        unsigned int v13 = *(unsigned __int8 *)(v10 + v12);
        if (v9 >= v13)
        {
          if (v9 <= v13) {
            return 1;
          }
          int v8 = v12 + 1;
        }
        else
        {
          int v11 = v12 - 1;
        }
        if (v8 > v11) {
          return 0;
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t PNEW_DTQuestionGPBin_Con(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  unsigned int v6 = (void *)OOCAllocator_Malloc(a1, 16, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = _DTQuestion_Con(v6, a2);
    if (result)
    {
      unsigned int v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *unsigned int v6 = &__DTQuestionGPBin;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t DTQuestionPP_IsTrue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v6 = *(void *)(a1 + 8);
  int v7 = *(char *)(v6 + 1);
  unsigned int v8 = v7 + a6;
  if (v7 + a6 < 0) {
    return 0;
  }
  uint64_t result = 0;
  if (!a5 || (v7 & 0x80000000) == 0) {
    return result;
  }
  uint64_t v10 = *(unsigned __int8 *)(v6 + 2);
  if (!*(unsigned char *)(v6 + 2)) {
    return 0;
  }
  int v11 = *(unsigned __int16 *)(a5 + 2 * v8);
  int v12 = (unsigned __int16 *)(v6 + 3);
  while (1)
  {
    int v13 = *v12++;
    if (v13 == v11) {
      break;
    }
    if (!--v10) {
      return 0;
    }
  }
  return 1;
}

uint64_t PNEW_DTQuestionPP_Con(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = (void *)OOCAllocator_Malloc(a1, 16, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = _DTQuestion_Con(v6, a2);
    if (result)
    {
      unsigned int v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *uint64_t v6 = &__DTQuestionPP;
      *a3 = v6;
    }
  }
  return result;
}

BOOL DTQuestionSG_IsTrue(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(a1 + 8);
  BOOL result = 0;
  int v6 = *(char *)(v4 + 1) + a2;
  if (v6 >= 0 && a3 && v6 < a4) {
    return *(unsigned __int8 *)(a3 + v6) == *(unsigned __int8 *)(v4 + 2);
  }
  return result;
}

uint64_t PNEW_DTQuestionSG_Con(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  int v6 = (void *)OOCAllocator_Malloc(a1, 16, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = _DTQuestion_Con(v6, a2);
    if (result)
    {
      unsigned int v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *int v6 = &__DTQuestionSG;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t PNEW_DTNodeBuffer_Con(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v7 = 0;
  int v5 = (void *)OOCAllocator_Malloc(a1, 16, &v7);
  uint64_t result = v7;
  if (!v7)
  {
    *int v5 = a2;
    v5[1] = a2 + 4;
    *a3 = v5;
  }
  return result;
}

uint64_t PDELETE_DTNodeBuffer(uint64_t a1, uint64_t a2)
{
  return 0;
}

uint64_t DTQuestionGP_IsTrue(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(a1 + 8);
  int v5 = *(char *)(v4 + 1) + a2;
  if (v5 < 0) {
    return 0;
  }
  uint64_t result = 0;
  if (!a3 || v5 >= a4) {
    return result;
  }
  uint64_t v7 = *(unsigned __int8 *)(v4 + 2);
  if (!*(unsigned char *)(v4 + 2)) {
    return 0;
  }
  int v8 = *(unsigned __int8 *)(a3 + v5);
  unsigned int v9 = (unsigned __int8 *)(v4 + 3);
  while (1)
  {
    int v10 = *v9++;
    if (v10 == v8) {
      break;
    }
    if (!--v7) {
      return 0;
    }
  }
  return 1;
}

uint64_t PNEW_DTQuestionGP_Con(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  int v6 = (void *)OOCAllocator_Malloc(a1, 16, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = _DTQuestion_Con(v6, a2);
    if (result)
    {
      unsigned int v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *int v6 = &__DTQuestionGP;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t addExpScore(int a1, int a2)
{
  __int16 v2 = a1 - a2;
  int v3 = (a1 - a2) << 16;
  if (((a1 - a2) & 0x8000) != 0) {
    int v4 = a1;
  }
  else {
    int v4 = a2;
  }
  if ((((_WORD)a1 - (_WORD)a2) & 0x8000) != 0) {
    __int16 v2 = a2 - a1;
  }
  BOOL v5 = v3 <= 16646144;
  if (v3 <= 16646144) {
    int v6 = v4;
  }
  else {
    int v6 = a2;
  }
  if (!v5) {
    __int16 v2 = 254;
  }
  return (v6 + sc_logAddTable[v2]);
}

uint64_t PNEW_DTPhonemeBuffer_Con(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v7 = 0;
  BOOL v5 = (void *)OOCAllocator_Malloc(a1, 16, &v7);
  uint64_t result = v7;
  if (!v7)
  {
    *BOOL v5 = a2;
    v5[1] = a2 + 2;
    *a3 = v5;
  }
  return result;
}

uint64_t PNEW_DTNode_Con(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v7 = 0;
  BOOL v5 = (void *)OOCAllocator_Malloc(a1, 8, &v7);
  uint64_t result = v7;
  if (!v7)
  {
    *BOOL v5 = a2;
    *a3 = v5;
  }
  return result;
}

uint64_t DTTree_Con(uint64_t *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    *a1 = (uint64_t)&__DTTree;
    a1[1] = a2;
    uint64_t result = PNEW_DTBuffer_Con(a2, a3, a1 + 2);
    if (!result)
    {
      uint64_t result = PNEW_DTNodeBuffer_Con(a2, *(void *)a1[2] + *(unsigned int *)(*(void *)a1[2] + 32), a1 + 3);
      if (!result)
      {
        uint64_t result = PNEW_DTNode_Con(a2, *(void *)a1[2] + *(unsigned int *)(*(void *)a1[2] + 36), a1 + 4);
        if (!result)
        {
          uint64_t result = PNEW_DTPhonemeBuffer_Con(a2, *(void *)a1[2] + *(unsigned int *)(*(void *)a1[2] + 44), a1 + 5);
          if (!result)
          {
            uint64_t result = PNEW_DTPhonemeBuffer_Con(a2, *(void *)a1[2] + *(unsigned int *)(*(void *)a1[2] + 48), a1 + 6);
            if (!result)
            {
              uint64_t result = PNEW_DTGraphemeBuffer_Con(a2, a2, *(void *)a1[2] + *(unsigned int *)(*(void *)a1[2] + 40), a1 + 7);
              if (!result)
              {
                uint64_t result = PNEW_DTQuestionBuffer_Con(a2, a2, *(void *)a1[2] + *(unsigned int *)(*(void *)a1[2] + 52), a1 + 8);
                if (!result)
                {
                  uint64_t v7 = *(void *)a1[2];
                  a1[9] = v7 + *(unsigned int *)(v7 + 28);
                  uint64_t v8 = *(unsigned int *)(v7 + 56);
                  if (v8)
                  {
                    uint64_t result = PNEW_DTNode_Con(a2, v7 + v8, a1 + 10);
                    if (result) {
                      return result;
                    }
                  }
                  else
                  {
                    a1[10] = 0;
                  }
                  uint64_t result = PNEW_DTNode_Con(a2, 0, a1 + 11);
                  if (!result)
                  {
                    a1[12] = 0;
                    return _DTTree_CreateStartNodeIdTable(a1);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t _DTTree_CreateStartNodeIdTable(uint64_t *a1)
{
  unsigned int v16 = 0;
  uint64_t v2 = *(unsigned __int16 *)(*(void *)(a1[7] + 16) + 4);
  uint64_t v3 = OOCAllocator_Realloc(a1[1], a1[12], 2 * v2, &v16);
  a1[12] = v3;
  uint64_t v4 = v16;
  if (!v16)
  {
    unsigned __int8 v15 = 0;
    if (v2)
    {
      unsigned __int8 v5 = 0;
      uint64_t v6 = a1[3];
      uint64_t v7 = a1[11];
      do
      {
        *(_WORD *)(v3 + 2 * v5) = 0;
        uint64_t v8 = *(unsigned __int16 **)(v6 + 8);
        *(void *)uint64_t v7 = v8;
        uint64_t v9 = *v8;
        if (v9 != 0xFFFF)
        {
          for (uint64_t i = a1[8]; *(unsigned char *)(*(void *)(i + 32) + v9) == 4; uint64_t i = a1[8])
          {
            uint64_t v11 = DTQuestionBuffer_BorrowQuestion(i, (unsigned __int16)v9);
            if ((*(unsigned int (**)(uint64_t, void, unsigned __int8 *, uint64_t, void, void))(*(void *)v11 + 24))(v11, 0, &v15, 1, 0, 0))
            {
              uint64_t v7 = a1[11];
              uint64_t v3 = a1[12];
              unsigned __int16 v12 = *(_WORD *)(*(void *)v7 + 2);
              unsigned __int8 v5 = v15;
            }
            else
            {
              unsigned __int8 v5 = v15;
              uint64_t v7 = a1[11];
              uint64_t v3 = a1[12];
              unsigned __int16 v12 = *(_WORD *)(v3 + 2 * v15) + 1;
            }
            *(_WORD *)(v3 + 2 * v15) = v12;
            uint64_t v6 = a1[3];
            uint64_t v13 = *(void *)(v6 + 8);
            *(void *)uint64_t v7 = v13 + 4 * v12;
            uint64_t v9 = *(unsigned __int16 *)(v13 + 4 * v12);
            if (v9 == 0xFFFF) {
              break;
            }
          }
        }
        unsigned __int8 v15 = ++v5;
      }
      while (v2 > v5);
      return v16;
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

uint64_t DTTree_Des(uint64_t *a1)
{
  uint64_t result = OOC_PlacementDeleteObject(a1[1], a1[8]);
  if (!result)
  {
    uint64_t result = OOC_PlacementDeleteObject(a1[1], a1[7]);
    if (!result)
    {
      uint64_t result = PDELETE_DTNodeBuffer(a1[1], a1[6]);
      if (!result)
      {
        uint64_t result = PDELETE_DTNodeBuffer(a1[1], a1[5]);
        if (!result)
        {
          uint64_t result = PDELETE_DTNodeBuffer(a1[1], a1[4]);
          if (!result)
          {
            uint64_t result = PDELETE_DTNodeBuffer(a1[1], a1[3]);
            if (!result)
            {
              uint64_t result = PDELETE_DTNodeBuffer(a1[1], a1[2]);
              if (!result)
              {
                uint64_t result = PDELETE_DTNodeBuffer(a1[1], a1[11]);
                if (!result)
                {
                  uint64_t v3 = a1[10];
                  if (!v3 || (uint64_t result = PDELETE_DTNodeBuffer(a1[1], v3), !result))
                  {
                    uint64_t v4 = a1[12];
                    if (v4) {
                      OOCAllocator_Free(a1[1], v4);
                    }
                    return Object_Des();
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

unint64_t DTTree_Traverse(uint64_t a1, uint64_t a2, unsigned char *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v14 = *(unsigned __int16 *)(*(void *)(a1 + 96) + 2 * a3[a2]);
  unsigned __int8 v15 = (unsigned __int16 *)(*(void *)(*(void *)(a1 + 24) + 8) + 4 * v14);
  **(void **)(a1 + 88) = v15;
  int v16 = *v15;
  if (v16 != 0xFFFF)
  {
    do
    {
      uint64_t v17 = DTQuestionBuffer_BorrowQuestion(*(void *)(a1 + 64), (unsigned __int16)v16);
      if ((*(unsigned int (**)(uint64_t, uint64_t, unsigned char *, size_t, uint64_t, uint64_t))(*(void *)v17 + 24))(v17, a2, a3, a4, a5, a6))
      {
        uint64_t v18 = *(void *)(a1 + 88);
        LOWORD(v14) = *(_WORD *)(*(void *)v18 + 2);
      }
      else
      {
        LOWORD(v14) = v14 + 1;
        uint64_t v18 = *(void *)(a1 + 88);
      }
      uint64_t v19 = *(void *)(*(void *)(a1 + 24) + 8);
      uint64_t v20 = 4 * (unsigned __int16)v14;
      *(void *)uint64_t v18 = v19 + v20;
      int v16 = *(unsigned __int16 *)(v19 + v20);
    }
    while (v16 != 0xFFFF);
    unsigned __int8 v15 = (unsigned __int16 *)(v19 + v20);
  }
  uint64_t PLeaf = DTLeafBuffer_GetPLeaf(*(void **)(a1 + 32), v15[1]);
  *a7 = PLeaf;
  if (((*(unsigned char *)(PLeaf + 1) & 2) == 0 || !*(void *)(a1 + 80))
    && ((*(unsigned char *)(PLeaf + 1) & 1) == 0
     || (*(unsigned char *)(PLeaf + 1) & 0xFC | (*(unsigned __int8 *)(PLeaf + 2) << 8)) != 4
     || !*(void *)(a1 + 80)))
  {
    return 0;
  }
  return _DTTree_GraphemeFallbackTraverse(a1, a2, a3, a4, a5, a6, (uint64_t)a7);
}

unint64_t _DTTree_GraphemeFallbackTraverse(uint64_t a1, uint64_t a2, unsigned char *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  char v16 = a3[a2];
  unint64_t result = DTGraphemeFallback_GetFallback(*(void **)(a1 + 80), v16, &v16);
  unsigned int v17 = result;
  if (!result)
  {
    unsigned __int8 v15 = (void *)OOCAllocator_Malloc(*(void *)(a1 + 8), a4, &v17);
    unint64_t result = v17;
    if (!v17)
    {
      memcpy(v15, a3, a4);
      *((unsigned char *)v15 + a2) = v16;
      unint64_t result = DTTree_Traverse(a1, a2, v15, a4, a5, a6, a7);
      unsigned int v17 = result;
      if (!result)
      {
        OOCAllocator_Free(*(void *)(a1 + 8), (uint64_t)v15);
        return v17;
      }
    }
  }
  return result;
}

uint64_t PNEW_DTTree_Con(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t **a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = (uint64_t *)OOCAllocator_Malloc(a1, 104, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = DTTree_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

unint64_t DTGraphemeFallback_GetFallback(void *a1, char a2, unsigned char *a3)
{
  int v7 = 0;
  unint64_t v5 = *a1 + 2;
  unint64_t v4 = *(unsigned __int16 *)*a1;
  v8[0] = a2;
  v8[1] = 0;
  unint64_t result = lhstdlib_bsearch((uint64_t)v8, v5, v4, 2uLL, (uint64_t (*)(uint64_t, unint64_t))compareFallback, &v7);
  if (result)
  {
    *a3 = *(unsigned char *)(result + 1);
    return 1;
  }
  return result;
}

uint64_t compareFallback(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v2 = *a1;
  unsigned int v3 = *a2;
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t DTBuffer_Con(void *a1, _DWORD *a2)
{
  *a1 = a2;
  if (a2[2] == 4)
  {
    if (a2[3] == 21586)
    {
      unsigned int v2 = a2[1];
      if (a2[8] <= v2)
      {
        if (a2[9] <= v2)
        {
          if (a2[11] <= v2 && a2[10] <= v2)
          {
            if (a2[13] <= v2)
            {
              return 0;
            }
            else
            {
              *a1 = 0;
              return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Questions block offset out of range");
            }
          }
          else
          {
            *a1 = 0;
            return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Pseudo-phonemes block offset out of range");
          }
        }
        else
        {
          *a1 = 0;
          return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Leafs block offset out of range");
        }
      }
      else
      {
        *a1 = 0;
        return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Nodes block offset out of range");
      }
    }
    else
    {
      *a1 = 0;
      return kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Invalid build ID");
    }
  }
  else
  {
    *a1 = 0;
    return err_GenerateErrorVersion();
  }
}

uint64_t PNEW_DTBuffer_Con(uint64_t a1, _DWORD *a2, void *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = (void *)OOCAllocator_Malloc(a1, 8, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = DTBuffer_Con(v6, a2);
    unsigned int v8 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *a3 = v6;
    }
  }
  return result;
}

int8x16_t DTPostProcessor_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!Object_Con((void *)a1))
  {
    *(void *)a1 = &__DTPostProcessor;
    *(void *)(a1 + 8) = a2;
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 32) = 0;
    uint64_t v7 = *(void *)(a3 + 72);
    *(void *)(a1 + 56) = *(void *)(v7 + 16);
    *(void *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
    *(_OWORD *)(a1 + 16) = *(_OWORD *)(a3 + 40);
    int8x16_t result = vextq_s8(*(int8x16_t *)(v7 + 28), *(int8x16_t *)(v7 + 28), 8uLL);
    *(int8x16_t *)(a1 + 80) = result;
  }
  return result;
}

uint64_t DTPostProcessor_Des(uint64_t a1)
{
  _DTPostProcessor_Clear(a1);
  return Object_Des();
}

uint64_t _DTPostProcessor_Clear(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 32);
  if (v2)
  {
    unint64_t v3 = *(void *)(result + 40);
    if (v3)
    {
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v5 = *(void *)(*(void *)(v1 + 32) + 8 * i);
        if (v5)
        {
          OOCAllocator_Free(*(void *)(v1 + 8), v5);
          unint64_t v3 = *(void *)(v1 + 40);
        }
      }
      uint64_t v2 = *(void *)(v1 + 32);
    }
    int8x16_t result = OOCAllocator_Free(*(void *)(v1 + 8), v2);
    *(void *)(v1 + 32) = 0;
  }
  uint64_t v6 = *(void *)(v1 + 48);
  if (v6)
  {
    int8x16_t result = OOCAllocator_Free(*(void *)(v1 + 8), v6);
    *(void *)(v1 + 48) = 0;
  }
  *(void *)(v1 + 40) = 0;
  *(_DWORD *)(v1 + 96) = 0;
  *(_WORD *)(v1 + 100) = -1;
  *(_DWORD *)(v1 + 104) = 1;
  return result;
}

uint64_t DTPostProcessor_CreateNBest(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int PhonemeSeq = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  __s2 = 0;
  _DTPostProcessor_Clear(a1);
  *(void *)(a1 + 40) = 0;
  if (kaldi::MatrixBase<float>::Stride(a2) < a3) {
    a3 = kaldi::MatrixBase<float>::Stride(a2);
  }
  if (a3)
  {
    *(void *)(a1 + 32) = OOCAllocator_Calloc(*(void *)(a1 + 8), a3, 8, &PhonemeSeq);
    if (!PhonemeSeq)
    {
      *(void *)(a1 + 48) = OOCAllocator_Calloc(*(void *)(a1 + 8), a3, 4, &PhonemeSeq);
      if (!PhonemeSeq && *(void *)(a1 + 40) < (unint64_t)a3)
      {
        unsigned int v6 = 0;
        do
        {
          if (v6 >= kaldi::MatrixBase<float>::Stride(a2)) {
            break;
          }
          uint64_t v7 = *(void *)(*(void *)(a2 + 40) + 16);
          if (*(__int16 *)(v7 + PtrList_ItemN(a2, v6) * *(void *)(*(void *)(a2 + 40) + 24) + 4) == -1) {
            break;
          }
          uint64_t v8 = PtrList_ItemN(a2, v6);
          uint64_t v9 = (unsigned int *)(*(void *)(*(void *)(a2 + 40) + 16) + *(void *)(*(void *)(a2 + 40) + 24) * v8);
          unsigned int PhonemeSeq = _DTPostProcessor_GetPhonemeSeq(a1, (uint64_t)v9 + 6, *v9, (uint64_t *)&v21, &v20);
          if (PhonemeSeq) {
            return PhonemeSeq;
          }
          if (v20)
          {
            unsigned int v10 = v21;
            unsigned int PhonemeSeq = _DTPostProcessor_GetTransFromPhnId(a1, v21, v20, &__s2);
            if (PhonemeSeq) {
              return PhonemeSeq;
            }
            if (*(_DWORD *)(a1 + 60) || (char v16 = __s2, !_DTPostProcessor_IsDoubleTranscription(a1, __s2)))
            {
              int v11 = *(_DWORD *)(a1 + 80);
              int v12 = *(_DWORD *)(a1 + 84);
              unsigned int v13 = (v12
                   + v11
                   * *(unsigned __int16 *)(*(void *)(*(void *)(a2 + 40) + 16)
                                                       + *(void *)(*(void *)(a2 + 40) + 24) * v8
                                                       + 4))
                  / 0x3E8;
              if (*(_DWORD *)(a1 + 88))
              {
                BOOL v14 = _DTPostProcessor_KeepVariant(a1, (v12+ v11* *(unsigned __int16 *)(*(void *)(*(void *)(a2 + 40) + 16)+ *(void *)(*(void *)(a2 + 40) + 24) * v8+ 4))/ 0x3E8);
                unsigned __int8 v15 = __s2;
                if (!v14)
                {
                  OOCAllocator_Free(*(void *)(a1 + 8), (uint64_t)__s2);
                  if (!v10) {
                    return PhonemeSeq;
                  }
LABEL_23:
                  OOCAllocator_Free(*(void *)(a1 + 8), (uint64_t)v10);
                  return PhonemeSeq;
                }
              }
              else
              {
                unsigned __int8 v15 = __s2;
              }
              uint64_t v17 = *(void *)(a1 + 40);
              *(void *)(*(void *)(a1 + 32) + 8 * v17) = v15;
              *(_DWORD *)(*(void *)(a1 + 48) + 4 * v17) = v13;
              *(void *)(a1 + 40) = v17 + 1;
            }
            else
            {
              OOCAllocator_Free(*(void *)(a1 + 8), (uint64_t)v16);
              __s2 = 0;
            }
          }
          ++v6;
        }
        while (*(void *)(a1 + 40) < (unint64_t)a3);
        unsigned int v10 = v21;
        if (!v21) {
          return PhonemeSeq;
        }
        goto LABEL_23;
      }
    }
  }
  return PhonemeSeq;
}

uint64_t _DTPostProcessor_GetPhonemeSeq(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  unsigned int v22 = 0;
  if (a3)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    do
      v10 += *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 16) + 8) + *(unsigned __int16 *)(a2 + 2 * v11++));
    while (a3 != v11);
    if (v10)
    {
      *a4 = OOCAllocator_Realloc(*(void *)(a1 + 8), *a4, v10, &v22);
      uint64_t result = v22;
      if (v22) {
        return result;
      }
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      *a5 = 0;
      uint64_t v15 = *(void *)(a1 + 16);
      while (1)
      {
        uint64_t v16 = *(unsigned __int16 *)(a2 + 2 * v14);
        uint64_t v17 = (unsigned __int8 *)(*(void *)(v15 + 8) + v16);
        int v19 = *v17;
        uint64_t v18 = v17 + 1;
        if (v19) {
          break;
        }
LABEL_17:
        if (++v14 == a3) {
          return v22;
        }
      }
      uint64_t v20 = 0;
      while (1)
      {
        if (*(_DWORD *)(a1 + 56))
        {
          uint64_t v21 = *a4;
        }
        else
        {
          uint64_t v21 = *a4;
          if (v13 && *(unsigned __int8 *)(v13 + v21 - 1) == v18[v20]) {
            goto LABEL_12;
          }
        }
        *(unsigned char *)(v21 + v13) = v18[v20];
        uint64_t v13 = *a5 + 1;
        *a5 = v13;
        uint64_t v15 = *(void *)(a1 + 16);
        uint64_t v16 = *(unsigned __int16 *)(a2 + 2 * v14);
LABEL_12:
        if (++v20 >= (unint64_t)*(unsigned __int8 *)(*(void *)(v15 + 8) + v16)) {
          goto LABEL_17;
        }
      }
    }
  }
  uint64_t result = 0;
  *a5 = 0;
  return result;
}

uint64_t _DTPostProcessor_GetTransFromPhnId(uint64_t a1, unsigned __int8 *a2, uint64_t a3, void *a4)
{
  unsigned int v17 = 0;
  if (!a3) {
    goto LABEL_8;
  }
  uint64_t v5 = a3;
  unsigned int v6 = a2;
  uint64_t v8 = 0;
  uint64_t v9 = *(void *)(*(void *)(a1 + 24) + 8);
  uint64_t v10 = a2;
  uint64_t v11 = a3;
  do
  {
    unsigned int v12 = *v10++;
    v8 += strlen((const char *)(v9 + v12));
    --v11;
  }
  while (v11);
  if (v8)
  {
    uint64_t v13 = (unsigned char *)OOCAllocator_Malloc(*(void *)(a1 + 8), v8 + 1, &v17);
    *a4 = v13;
    uint64_t result = v17;
    if (!v17)
    {
      do
      {
        unsigned int v15 = *v6++;
        size_t v16 = strlen((const char *)(*(void *)(*(void *)(a1 + 24) + 8) + v15));
        memcpy(v13, (const void *)(*(void *)(*(void *)(a1 + 24) + 8) + v15), v16);
        v13 += v16;
        --v5;
      }
      while (v5);
      unsigned char *v13 = 0;
      return v17;
    }
  }
  else
  {
LABEL_8:
    uint64_t result = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t _DTPostProcessor_IsDoubleTranscription(uint64_t a1, char *__s2)
{
  if (!__s2) {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2) {
    return 0;
  }
  for (unint64_t i = *(const char ***)(a1 + 32); strcmp(*i, __s2); ++i)
  {
    if (!--v2) {
      return 0;
    }
  }
  return 1;
}

BOOL _DTPostProcessor_KeepVariant(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 104))
  {
    *(_DWORD *)(a1 + 96) = a2;
  }
  else
  {
    int v4 = addExpScore(a2, *(_DWORD *)(a1 + 96));
    *(_DWORD *)(a1 + 96) = v4;
    if (v4 <= *(_DWORD *)(a1 + 88))
    {
      BOOL result = *(_DWORD *)(a1 + 92) + *(unsigned __int16 *)(a1 + 100) > a2;
      goto LABEL_6;
    }
  }
  BOOL result = 1;
LABEL_6:
  *(_WORD *)(a1 + 100) = a2;
  *(_DWORD *)(a1 + 104) = 0;
  return result;
}

size_t DTPostProcessor_GetTranscriptionSize(uint64_t a1, uint64_t a2)
{
  return strlen(*(const char **)(*(void *)(a1 + 32) + 8 * a2));
}

void PNEW_DTPostProcessor_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 112, &v10);
  if (!v10)
  {
    DTPostProcessor_Con(v8, a2, a3);
    int v10 = v9;
    if (v9)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
    }
    else
    {
      *a4 = v8;
    }
  }
}

uint64_t DTHypothesisPool_Compare(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v5 = (unsigned int *)(v3 + v4 * *a2);
  unsigned int v6 = *((unsigned __int16 *)v5 + 2);
  uint64_t v7 = v3 + v4 * *a3;
  unsigned int v8 = *(unsigned __int16 *)(v7 + 4);
  if (v6 < v8) {
    return 0xFFFFFFFFLL;
  }
  if (v6 > v8) {
    return 1;
  }
  uint64_t v10 = *v5;
  if (v10 < *(_DWORD *)v7) {
    return 0xFFFFFFFFLL;
  }
  if (v10 > *(_DWORD *)v7) {
    return 1;
  }
  if (v10)
  {
    uint64_t v11 = (unsigned __int16 *)v5 + 3;
    unsigned int v12 = (unsigned __int16 *)(v7 + 6);
    while (1)
    {
      unsigned int v14 = *v11++;
      unsigned int v13 = v14;
      unsigned int v15 = *v12++;
      BOOL v16 = v13 > v15;
      if (v13 < v15) {
        break;
      }
      if (v16) {
        return 1;
      }
      uint64_t result = 0;
      if (!--v10) {
        return result;
      }
    }
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t DTHypothesisPool_Con(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = ((2 - 2 * (_BYTE)a3) & 2) + 2 * a3 + 6;
    *(_DWORD *)(a1 + 32) = 0;
    *(void *)a1 = &__DTHypothesisPool;
    *(void *)(a1 + 8) = a2;
    return PNEW_PtrStack_Con(a2, a2, 1, (uint64_t *)(a1 + 40));
  }
  return result;
}

uint64_t DTHypothesisPool_Des(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  if (v2) {
    OOCAllocator_Free(a1[1], v2);
  }
  uint64_t result = OOC_PlacementDeleteObject(a1[1], a1[5]);
  if (!result)
  {
    return Object_Des();
  }
  return result;
}

uint64_t DTHypothesisPool_FetchHypoID(uint64_t a1, _DWORD *a2)
{
  unsigned int v14 = 0;
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = *(_DWORD *)(v4 + 24);
  if (v5)
  {
    uint64_t v6 = *(void *)(*(void *)(v4 + 32) + 8 * (v5 - 1));
    uint64_t result = PtrStack_Remove(v4);
    if (result) {
      return result;
    }
    uint64_t v8 = (v6 - 1);
    uint64_t v9 = *(void *)(a1 + 16) + *(void *)(a1 + 24) * v8;
    *(_DWORD *)uint64_t v9 = 0;
    *(_WORD *)(v9 + 4) = 0;
    goto LABEL_10;
  }
  uint64_t v8 = *(unsigned int *)(a1 + 32);
  uint64_t v10 = (v8 + 1);
  uint64_t v11 = OOCAllocator_Realloc(*(void *)(a1 + 8), *(void *)(a1 + 16), *(void *)(a1 + 24) * v10, &v14);
  uint64_t result = v14;
  if (v14) {
    return result;
  }
  *(void *)(a1 + 16) = v11;
  uint64_t v12 = (*(_DWORD *)(a1 + 32) + 1);
  *(_DWORD *)(a1 + 32) = v12;
  if (v12 <= v10)
  {
LABEL_9:
    uint64_t v13 = v11 + *(void *)(a1 + 24) * v8;
    *(_DWORD *)uint64_t v13 = 0;
    *(_WORD *)(v13 + 4) = 0;
    uint64_t result = v14;
LABEL_10:
    *a2 = v8;
    return result;
  }
  while (1)
  {
    uint64_t result = PtrStack_Put(*(void *)(a1 + 40), v12);
    unsigned int v14 = result;
    if (result) {
      return result;
    }
    if (v10 >= --v12)
    {
      uint64_t v11 = *(void *)(a1 + 16);
      goto LABEL_9;
    }
  }
}

uint64_t DTHypothesisPool_Resize(uint64_t a1, unsigned int a2)
{
  *(void *)(a1 + 24) = ((2 - 2 * (_BYTE)a2) & 2) + 2 * a2 + 6;
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    OOCAllocator_Free(*(void *)(a1 + 8), v3);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  uint64_t v4 = *(void *)(a1 + 40);
  if (!*(_DWORD *)(v4 + 24)) {
    return 0;
  }
  do
  {
    uint64_t v5 = PtrStack_Remove(v4);
    uint64_t v4 = *(void *)(a1 + 40);
  }
  while (*(_DWORD *)(v4 + 24));
  return v5;
}

uint64_t DTHypothesisPool_ReturnHypoID(void *a1, unsigned int a2)
{
  *(_DWORD *)(a1[2] + a1[3] * a2) = -1;
  return PtrStack_Put(a1[5], a2 + 1);
}

uint64_t PNEW_DTHypothesisPool_Con(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 48, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = DTHypothesisPool_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

uint64_t DTQuestionBuffer_Con(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v14 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v7 = 0;
  uint64_t result = Object_Con(a1);
  unsigned int v15 = result;
  if (!result)
  {
    *a1 = &__DTQuestionBuffer;
    a1[1] = a2;
    a1[2] = a3;
    a1[4] = a3 + 4;
    a1[3] = OOCAllocator_Calloc(a2, 9, 8, &v15);
    uint64_t result = v15;
    if (!v15)
    {
      uint64_t result = PNEW_DTQuestionPP_Con(a2, 0, &v14);
      unsigned int v15 = result;
      if (!result)
      {
        *(void *)(a1[3] + 8) = v14;
        uint64_t result = PNEW_DTQuestionWB_Con(a2, 0, &v12);
        unsigned int v15 = result;
        if (!result)
        {
          *(void *)(a1[3] + 16) = v12;
          uint64_t result = PNEW_DTQuestionGP_Con(a2, 0, &v13);
          unsigned int v15 = result;
          if (!result)
          {
            *(void *)(a1[3] + 24) = v13;
            uint64_t result = PNEW_DTQuestionTG_Con(a2, 0, &v11);
            unsigned int v15 = result;
            if (!result)
            {
              *(void *)(a1[3] + 32) = v11;
              uint64_t result = PNEW_DTQuestionSG_Con(a2, 0, &v10);
              unsigned int v15 = result;
              if (!result)
              {
                *(void *)(a1[3] + 40) = v10;
                uint64_t result = PNEW_DTQuestionSP_Con(a2, 0, &v9);
                unsigned int v15 = result;
                if (!result)
                {
                  *(void *)(a1[3] + 48) = v9;
                  uint64_t result = PNEW_DTQuestionPPBin_Con(a2, 0, &v8);
                  unsigned int v15 = result;
                  if (!result)
                  {
                    *(void *)(a1[3] + 56) = v8;
                    uint64_t result = PNEW_DTQuestionGPBin_Con(a2, 0, &v7);
                    if (!result) {
                      *(void *)(a1[3] + 64) = v7;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t DTQuestionBuffer_Des(uint64_t *a1)
{
  uint64_t v2 = 0;
  a1[2] = 0;
  while (1)
  {
    uint64_t v3 = *(void *)(a1[3] + v2);
    if (v3)
    {
      uint64_t result = OOC_PlacementDeleteObject(a1[1], v3);
      if (result) {
        break;
      }
    }
    v2 += 8;
    if (v2 == 72)
    {
      OOCAllocator_Free(a1[1], a1[3]);
      return Object_Des();
    }
  }
  return result;
}

uint64_t DTQuestionBuffer_BorrowQuestion(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = (unsigned __int8 *)(*(void *)(a1 + 32) + a2);
  uint64_t result = *(void *)(*(void *)(a1 + 24) + 8 * *v2);
  *(void *)(result + 8) = v2;
  return result;
}

uint64_t PNEW_DTQuestionBuffer_Con(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = (void *)OOCAllocator_Malloc(a1, 40, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = DTQuestionBuffer_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

uint64_t DTSearch_Con(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__DTSearch;
    *(void *)(a1 + 8) = a2;
    *(void *)(a1 + 16) = a3;
    uint64_t result = PNEW_DTHypothesisPool_Con(a2, a2, 0, (uint64_t *)(a1 + 24));
    if (!result)
    {
      uint64_t result = PNEW_DTHypothesisList_Con(a2, a2, *(void *)(a1 + 24), (void *)(a1 + 32));
      if (!result)
      {
        uint64_t result = PNEW_DTHypothesisList_Con(a2, a2, *(void *)(a1 + 24), (void *)(a1 + 40));
        unsigned int v10 = result;
        if (!result)
        {
          *(void *)(a1 + 64) = 0;
          *(void *)(a1 + 72) = 0;
          uint64_t v7 = *(__int16 **)(*(void *)(a1 + 16) + 72);
          __int16 v8 = *v7;
          *(_WORD *)(a1 + 48) = *v7;
          *(_WORD *)(a1 + 50) = v8;
          uint64_t v9 = *((unsigned int *)v7 + 2);
          *(_DWORD *)(a1 + 52) = *((_DWORD *)v7 + 1);
          *(_DWORD *)(a1 + 56) = v9;
          LOWORD(v7) = v7[6];
          *(_WORD *)(a1 + 60) = (_WORD)v7;
          *(_WORD *)(a1 + 62) = (_WORD)v7;
          *(void *)(a1 + 80) = 0;
          if (v9)
          {
            *(void *)(a1 + 80) = OOCAllocator_Realloc(a2, 0, 4 * v9, &v10);
            return v10;
          }
          else
          {
            return 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t DTSearch_Des(uint64_t *a1)
{
  uint64_t result = _DTSearch_ClearHypothesis((uint64_t)a1, a1[5]);
  if (!result)
  {
    uint64_t result = _DTSearch_ClearHypothesis((uint64_t)a1, a1[4]);
    if (!result)
    {
      uint64_t result = OOC_PlacementDeleteObject(a1[1], a1[4]);
      if (!result)
      {
        uint64_t result = OOC_PlacementDeleteObject(a1[1], a1[5]);
        if (!result)
        {
          uint64_t result = OOC_PlacementDeleteObject(a1[1], a1[3]);
          if (!result)
          {
            uint64_t result = __DTSearch_LeafPoolClear(a1);
            if (!result)
            {
              a1[2] = 0;
              a1[4] = 0;
              a1[5] = 0;
              uint64_t v3 = a1[10];
              if (v3) {
                OOCAllocator_Free(a1[1], v3);
              }
              return Object_Des();
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t _DTSearch_ClearHypothesis(uint64_t a1, uint64_t a2)
{
  if (kaldi::MatrixBase<float>::Stride(a2))
  {
    unsigned int v4 = 0;
    while (1)
    {
      unsigned int v5 = PtrList_ItemN(a2, v4);
      uint64_t result = DTHypothesisPool_ReturnHypoID(*(void **)(a1 + 24), v5);
      if (result) {
        break;
      }
      if (++v4 >= kaldi::MatrixBase<float>::Stride(a2)) {
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    PtrList_RemoveAll(a2);
    return 0;
  }
  return result;
}

uint64_t __DTSearch_LeafPoolClear(uint64_t *a1)
{
  uint64_t v2 = a1 + 8;
  uint64_t v1 = a1[8];
  if (!v1) {
    return 0;
  }
  if (a1[9])
  {
    uint64_t v4 = 0;
    unint64_t v5 = 0;
    while (1)
    {
      uint64_t result = DTLeaf_Con((void *)(*v2 + v4), 0);
      if (result) {
        break;
      }
      ++v5;
      v4 += 8;
      if (v5 >= a1[9])
      {
        uint64_t v1 = *v2;
        goto LABEL_7;
      }
    }
  }
  else
  {
LABEL_7:
    OOCAllocator_Free(a1[1], v1);
    uint64_t result = 0;
    *uint64_t v2 = 0;
    v2[1] = 0;
  }
  return result;
}

unint64_t DTSearch_BeamSearch(uint64_t a1, unsigned char *a2, size_t a3, void *a4)
{
  unsigned int v36 = 0;
  unint64_t result = _DTSearch_LeafPoolResize((uint64_t *)a1, 1uLL);
  if (result) {
    return result;
  }
  unint64_t result = _DTSearch_ClearHypothesis(a1, *(void *)(a1 + 32));
  if (result) {
    return result;
  }
  if (!a3)
  {
    uint64_t v15 = 0;
    goto LABEL_19;
  }
  unint64_t result = DTHypothesisPool_Resize(*(void *)(a1 + 24), a3);
  if (result) {
    return result;
  }
  int v9 = *(unsigned __int16 *)(a1 + 48);
  *(_WORD *)(a1 + 50) = v9;
  if (!v9) {
    LOWORD(v9) = *(_WORD *)(a1 + 60);
  }
  *(_WORD *)(a1 + 62) = v9;
  unint64_t result = DTTree_Traverse(*(void *)(a1 + 16), 0, a2, a3, 0, 0, *(uint64_t **)(a1 + 64));
  if (result) {
    return result;
  }
  if ((*(unsigned char *)(**(void **)(a1 + 64) + 1) & 2) != 0)
  {
LABEL_20:
    if (a3 >= 2)
    {
      uint64_t v16 = 1;
      do
      {
        uint64_t v18 = *(void *)(a1 + 32);
        uint64_t v17 = *(void *)(a1 + 40);
        *(void *)(a1 + 32) = v17;
        *(void *)(a1 + 40) = v18;
        unint64_t result = _DTSearch_ClearHypothesis(a1, v17);
        if (result) {
          return result;
        }
        unsigned int v19 = kaldi::MatrixBase<float>::Stride(*(void *)(a1 + 40));
        unint64_t result = _DTSearch_LeafPoolResize((uint64_t *)a1, v19);
        if (result) {
          return result;
        }
        if (kaldi::MatrixBase<float>::Stride(*(void *)(a1 + 40)))
        {
          uint64_t v23 = 0;
          unint64_t v24 = 0;
          do
          {
            long long v25 = (unsigned int *)(*(void *)(*(void *)(a1 + 24) + 16)
                                 + *(void *)(*(void *)(a1 + 24) + 24)
                                 * PtrList_ItemN(*(void *)(a1 + 40), v24));
            unint64_t result = DTTree_Traverse(*(void *)(a1 + 16), v16, a2, a3, (uint64_t)v25 + 6, *v25, (uint64_t *)(*(void *)(a1 + 64) + v23));
            if (result) {
              return result;
            }
            ++v24;
            v23 += 8;
          }
          while (v24 < kaldi::MatrixBase<float>::Stride(*(void *)(a1 + 40)));
        }
        if (*(_DWORD *)(a1 + 52)) {
          _DTSearch_GetHistogramPruningThreshold(a1, *(void *)(a1 + 40), v20, v21, v22, (_WORD *)(a1 + 50));
        }
        if (kaldi::MatrixBase<float>::Stride(*(void *)(a1 + 40)))
        {
          uint64_t v26 = 0;
LABEL_32:
          uint64_t v27 = 0;
          uint64_t v28 = PtrList_ItemN(*(void *)(a1 + 40), v26);
          uint64_t v29 = *(void *)(*(void *)(a1 + 64) + 8 * v26);
          while (1)
          {
            __int16 v30 = *(unsigned __int8 *)(v29 + v27);
            if (!_DTSearch_HypoWillBePruned(a1, *(void *)(a1 + 32), *(unsigned __int8 *)(v29 + v27)))
            {
              unint64_t result = DTHypothesisPool_FetchHypoID(*(void *)(a1 + 24), &v36);
              if (result) {
                return result;
              }
              uint64_t v31 = *(void *)(a1 + 24);
              memcpy((void *)(*(void *)(v31 + 16) + *(void *)(v31 + 24) * v36), (const void *)(*(void *)(v31 + 16) + *(void *)(v31 + 24) * v28), *(void *)(v31 + 24));
              unsigned int v32 = v36;
              int v33 = (unsigned int *)(*(void *)(*(void *)(a1 + 24) + 16)
                                   + *(void *)(*(void *)(a1 + 24) + 24) * v36);
              *((_WORD *)v33 + 2) += v30;
              if (*(unsigned __int16 *)(*(void *)(*(void *)(a1 + 64) + 8 * v26) + v27 + 1) >= 4u)
              {
                uint64_t v34 = *v33;
                *((_WORD *)v33 + v34 + 3) = *(_WORD *)(*(void *)(*(void *)(a1 + 64) + 8 * v26) + v27 + 1) >> 2;
                *int v33 = v34 + 1;
                unsigned int v32 = v36;
              }
              unint64_t result = _DTSearch_AddHypothesis(a1, *(void *)(a1 + 32), v32);
              if (result) {
                return result;
              }
            }
            uint64_t v29 = *(void *)(*(void *)(a1 + 64) + 8 * v26);
            char v35 = *(unsigned char *)(v29 + v27 + 1);
            v27 += 3;
            if (v35)
            {
              if (++v26 < (unint64_t)kaldi::MatrixBase<float>::Stride(*(void *)(a1 + 40))) {
                goto LABEL_32;
              }
              break;
            }
          }
        }
      }
      while (++v16 != a3);
    }
    unint64_t result = _DTSearch_ClearHypothesis(a1, *(void *)(a1 + 40));
    if (result) {
      return result;
    }
    PtrList_UdSort(*(void *)(a1 + 32), (uint64_t (*)(char *, char *, uint64_t))__DTSearch_HypoCompare, *(void *)(a1 + 24));
    uint64_t v15 = kaldi::MatrixBase<float>::Stride(*(void *)(a1 + 32));
LABEL_19:
    unint64_t result = 0;
    *a4 = v15;
    return result;
  }
  unint64_t result = DTHypothesisPool_FetchHypoID(*(void *)(a1 + 24), &v36);
  if (!result)
  {
    uint64_t v10 = 0;
    do
    {
      uint64_t v11 = (unsigned __int8 *)(**(void **)(a1 + 64) + v10);
      unsigned int v12 = v36;
      uint64_t v13 = *(void *)(*(void *)(a1 + 24) + 16) + *(void *)(*(void *)(a1 + 24) + 24) * v36;
      *(_WORD *)(v13 + 4) = *v11;
      unsigned int v14 = *(unsigned __int16 *)(v11 + 1);
      if (v14 >= 4)
      {
        *(_WORD *)(v13 + 6) = v14 >> 2;
        *(_DWORD *)uint64_t v13 = 1;
        unsigned int v12 = v36;
      }
      unint64_t result = _DTSearch_AddHypothesis(a1, *(void *)(a1 + 32), v12);
      if (result) {
        break;
      }
      if (*(unsigned char *)(**(void **)(a1 + 64) + v10 + 1)) {
        goto LABEL_20;
      }
      unint64_t result = DTHypothesisPool_FetchHypoID(*(void *)(a1 + 24), &v36);
      v10 += 3;
    }
    while (!result);
  }
  return result;
}

uint64_t _DTSearch_LeafPoolResize(uint64_t *a1, unint64_t a2)
{
  uint64_t result = 0;
  unsigned int v8 = 0;
  if (a1[9] < a2)
  {
    a1[8] = OOCAllocator_Realloc(a1[1], a1[8], 8 * a2, &v8);
    uint64_t result = v8;
    if (!v8)
    {
      unint64_t v5 = a1[9];
      unint64_t v6 = a2 - v5;
      if (a2 <= v5)
      {
LABEL_7:
        uint64_t result = 0;
        a1[9] = a2;
      }
      else
      {
        uint64_t v7 = 8 * v5;
        while (1)
        {
          uint64_t result = DTLeaf_Con((void *)(a1[8] + v7), 0);
          unsigned int v8 = result;
          if (result) {
            break;
          }
          v7 += 8;
          if (!--v6) {
            goto LABEL_7;
          }
        }
      }
    }
  }
  return result;
}

uint64_t _DTSearch_AddHypothesis(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (kaldi::MatrixBase<float>::Stride(a2))
  {
    uint64_t v6 = *(void *)(a1 + 24);
    uint64_t v7 = *(void *)(v6 + 16);
    unsigned int v8 = *(unsigned __int16 *)(v7 + *(void *)(v6 + 24) * a3 + 4);
    unsigned int v9 = PtrList_ItemN(a2, 0);
    uint64_t v10 = *(void **)(a1 + 24);
    if (v8 == 0xFFFF
      || (unsigned int v11 = *(unsigned __int16 *)(v7 + v9 * v10[3] + 4), *(_WORD *)(a1 + 50))
      && *(unsigned __int16 *)(a1 + 50) + v11 < v8)
    {
      return DTHypothesisPool_ReturnHypoID(v10, a3);
    }
    uint64_t v14 = a2;
    uint64_t v13 = a3;
    if (v8 >= v11)
    {
      return PtrList_Append(a2, a3);
    }
  }
  else
  {
    uint64_t v13 = a3;
    uint64_t v14 = a2;
  }
  return PtrList_Prepend(v14, v13);
}

uint64_t _DTSearch_GetHistogramPruningThreshold(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _WORD *a6)
{
  unsigned int v9 = *(char **)(a1 + 80);
  if (kaldi::MatrixBase<float>::Stride(a2))
  {
    unint64_t v10 = 0;
    unsigned int v11 = 0;
    do
    {
      uint64_t v12 = *(void *)(*(void *)(a1 + 64) + 8 * v10);
      char v14 = *(unsigned char *)(v12 + 1);
      uint64_t v13 = (char *)(v12 + 1);
      if ((v14 & 2) == 0)
      {
        do
        {
          ++v11;
          char v15 = *v13;
          v13 += 3;
        }
        while ((v15 & 1) == 0);
      }
      ++v10;
    }
    while (v10 < kaldi::MatrixBase<float>::Stride(a2));
  }
  else
  {
    unsigned int v11 = 0;
  }
  uint64_t v16 = *(unsigned int *)(a1 + 56);
  if (v11 < *(_DWORD *)(a1 + 52))
  {
    LOWORD(v17) = 0;
    unsigned __int16 v18 = 0;
    unsigned __int16 v19 = 0;
    LODWORD(v20) = *(_DWORD *)(a1 + 56);
LABEL_31:
    if (v20) {
      unint64_t v17 = v16 * (unint64_t)*(unsigned __int16 *)(a1 + 62) / v20;
    }
    goto LABEL_33;
  }
  bzero(v9, 4 * v16);
  if (kaldi::MatrixBase<float>::Stride(a2))
  {
    uint64_t v21 = 0;
    unsigned __int16 v19 = 0;
    unsigned __int16 v18 = 0;
    LOWORD(v17) = 0;
    while (1)
    {
      __int16 v22 = *(_WORD *)(*(void *)(*(void *)(a1 + 24) + 16)
                     + *(void *)(*(void *)(a1 + 24) + 24) * PtrList_ItemN(a2, v21)
                     + 4);
      uint64_t v23 = *(unsigned __int8 ***)(a1 + 64);
      if (!v21)
      {
        unsigned __int16 v18 = v22 + **v23;
        unsigned __int16 v19 = v18;
      }
      unint64_t v24 = v23[v21];
      if ((v24[1] & 2) == 0) {
        break;
      }
LABEL_23:
      if (++v21 >= (unint64_t)kaldi::MatrixBase<float>::Stride(a2)) {
        goto LABEL_26;
      }
    }
    long long v25 = (char *)(v24 + 1);
    while (1)
    {
      LOWORD(v17) = v22 + *(v25 - 1);
      uint64_t v26 = v9;
      if ((unsigned __int16)v17 < v18) {
        goto LABEL_19;
      }
      unsigned int v27 = *(_DWORD *)(a1 + 56);
      unsigned int v28 = v27 * ((unsigned __int16)v17 - v18) / *(unsigned __int16 *)(a1 + 62);
      if (v28 < v27) {
        break;
      }
LABEL_20:
      if ((unsigned __int16)v17 < v19) {
        unsigned __int16 v19 = v17;
      }
      char v29 = *v25;
      v25 += 3;
      if (v29) {
        goto LABEL_23;
      }
    }
    uint64_t v26 = &v9[4 * v28];
LABEL_19:
    ++*(_DWORD *)v26;
    goto LABEL_20;
  }
  LOWORD(v17) = 0;
  unsigned __int16 v18 = 0;
  unsigned __int16 v19 = 0;
LABEL_26:
  uint64_t v20 = *(unsigned int *)(a1 + 56);
  if (v20)
  {
    unint64_t v30 = 0;
    uint64_t v16 = 0;
    while (v30 < *(unsigned int *)(a1 + 52))
    {
      v30 += *(unsigned int *)&v9[4 * v16++];
      if (v20 == v16)
      {
        uint64_t v16 = *(unsigned int *)(a1 + 56);
        goto LABEL_31;
      }
    }
    goto LABEL_31;
  }
LABEL_33:
  *a6 = v17 - v19 + v18;
  if (*(_WORD *)(a1 + 48))
  {
    unsigned int v31 = (unsigned __int16)(v17 - v19 + v18);
    if (v31 >= *(unsigned __int16 *)(a1 + 48)) {
      LOWORD(v31) = *(_WORD *)(a1 + 48);
    }
    *a6 = v31;
  }
  return 0;
}

uint64_t _DTSearch_HypoWillBePruned(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result = kaldi::MatrixBase<float>::Stride(a2);
  if (result)
  {
    unsigned int v7 = PtrList_ItemN(a2, 0);
    return *(_WORD *)(a1 + 50)
        && *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 24) + 16)
                               + *(void *)(*(void *)(a1 + 24) + 24) * v7
                               + 4)
         + *(unsigned __int16 *)(a1 + 50) < a3;
  }
  return result;
}

uint64_t __DTSearch_HypoCompare(unsigned int *a1, unsigned int *a2, uint64_t a3)
{
  return DTHypothesisPool_Compare(a3, a1, a2);
}

uint64_t DTSearch_SetHistogramBins(uint64_t a1, unsigned int a2)
{
  unsigned int v3 = 0;
  *(_DWORD *)(a1 + 56) = a2;
  if (!a2) {
    return 0;
  }
  *(void *)(a1 + 80) = OOCAllocator_Realloc(*(void *)(a1 + 8), *(void *)(a1 + 80), 4 * a2, &v3);
  return v3;
}

uint64_t DTSearch_SetHistogramDiff(uint64_t result, __int16 a2)
{
  *(_WORD *)(result + 60) = a2;
  return result;
}

uint64_t DTSearch_SetHistogramPruning(uint64_t result, int a2)
{
  *(_DWORD *)(result + 52) = a2;
  return result;
}

uint64_t DTSearch_SetPruning(uint64_t result, __int16 a2)
{
  *(_WORD *)(result + 48) = a2;
  return result;
}

uint64_t PNEW_DTSearch_Con(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 88, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = DTSearch_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

BOOL DTQuestionSP_IsTrue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v6 = *(void *)(a1 + 8);
  int v7 = *(char *)(v6 + 1);
  BOOL result = 0;
  if (v7 + a6 >= 0 && a5 && v7 < 0) {
    return *(unsigned __int16 *)(a5 + 2 * (v7 + a6)) == *(unsigned __int16 *)(v6 + 2);
  }
  return result;
}

uint64_t PNEW_DTQuestionSP_Con(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = (void *)OOCAllocator_Malloc(a1, 16, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = _DTQuestion_Con(v6, a2);
    if (result)
    {
      unsigned int v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *uint64_t v6 = &__DTQuestionSP;
      *a3 = v6;
    }
  }
  return result;
}

BOOL DTQuestionTG_IsTrue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(unsigned __int8 *)(a3 + a2) == *(unsigned __int8 *)(*(void *)(a1 + 8) + 2);
}

uint64_t PNEW_DTQuestionTG_Con(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = (void *)OOCAllocator_Malloc(a1, 16, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = _DTQuestion_Con(v6, a2);
    if (result)
    {
      unsigned int v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *uint64_t v6 = &__DTQuestionTG;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t DTGraphemeParser_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    OOCAllocator_Free(*(void *)(a1 + 8), v2);
    *(void *)(a1 + 24) = 0;
  }
  return Object_Des();
}

uint64_t DTGraphemeParser_Parse(void *a1, char *__s)
{
  unsigned int v18 = 0;
  size_t v4 = strlen(__s);
  if (v4)
  {
    size_t v5 = v4;
    size_t v6 = a1[4];
    if (v4 >= v6)
    {
      int v7 = (void *)OOCAllocator_Realloc(a1[1], a1[3], v4, &v18);
      a1[3] = v7;
      uint64_t v9 = v18;
      if (v18) {
        return v9;
      }
      a1[4] = v5;
      size_t v6 = v5;
    }
    else
    {
      int v7 = (void *)a1[3];
    }
    a1[5] = 0;
    bzero(v7, v6);
    size_t v10 = 0;
    unsigned int v11 = *(unsigned __int16 *)(*(void *)(a1[2] + 16) + 4);
    while (1)
    {
      unsigned int GraphemeID = DTGraphemeBuffer_FirstGraphemeID(a1[2], (uint64_t)&__s[v10]);
      if (v11 <= GraphemeID) {
        break;
      }
      unsigned __int8 v13 = GraphemeID;
      uint64_t v14 = *(void *)(a1[2] + 24);
      while (1)
      {
        uint64_t v15 = v14 + 8 * v13;
        size_t v16 = *(void *)(v15 + 8) + ~*(void *)v15;
        if (!strncmp(*(const char **)v15, &__s[v10], v16)) {
          break;
        }
        if (v11 <= ++v13) {
          goto LABEL_17;
        }
      }
      *(unsigned char *)(a1[3] + a1[5]++) = v13;
      v10 += v16;
      if (v10 >= v5) {
        return v18;
      }
    }
LABEL_17:
    a1[5] = 0;
    bzero((void *)a1[3], a1[4]);
    return 4;
  }
  else
  {
    a1[5] = 0;
    unsigned int v8 = (void *)a1[3];
    if (v8) {
      bzero(v8, a1[4]);
    }
    return 0;
  }
}

uint64_t PNEW_DTGraphemeParser_Con(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  unsigned int v11 = 0;
  unsigned int v8 = (void *)OOCAllocator_Malloc(a1, 48, &v11);
  uint64_t result = v11;
  if (!v11)
  {
    uint64_t result = Object_Con(v8);
    if (result)
    {
      unsigned int v11 = result;
      OOCAllocator_Free(a1, (uint64_t)v8);
      *a4 = 0;
      return v11;
    }
    else
    {
      *unsigned int v8 = &__DTGraphemeParser;
      v8[1] = a2;
      uint64_t v10 = *(void *)(a3 + 56);
      v8[4] = 0;
      v8[5] = 0;
      unsigned char v8[2] = v10;
      v8[3] = 0;
      *a4 = v8;
    }
  }
  return result;
}

uint64_t DTQuestionPPBin_IsTrue(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v6 = *(void *)(a1 + 8);
  int v7 = *(char *)(v6 + 1);
  unsigned int v8 = v7 + a6;
  if (v7 + a6 < 0) {
    return 0;
  }
  uint64_t result = 0;
  if (a5 && v7 < 0)
  {
    int v10 = *(unsigned __int8 *)(v6 + 2);
    if (*(unsigned char *)(v6 + 2))
    {
      int v11 = 0;
      unsigned int v12 = *(unsigned __int16 *)(a5 + 2 * v8);
      uint64_t v13 = v6 + 3;
      int v14 = v10 - 1;
      while (1)
      {
        int v15 = (v14 + v11) >> 1;
        unsigned int v16 = *(unsigned __int16 *)(v13 + 2 * v15);
        if (v12 >= v16)
        {
          if (v12 <= v16) {
            return 1;
          }
          int v11 = v15 + 1;
        }
        else
        {
          int v14 = v15 - 1;
        }
        if (v11 > v14) {
          return 0;
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t PNEW_DTQuestionPPBin_Con(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = (void *)OOCAllocator_Malloc(a1, 16, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = _DTQuestion_Con(v6, a2);
    if (result)
    {
      unsigned int v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *uint64_t v6 = &__DTQuestionPPBin;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t DTLeaf_Con(void *a1, uint64_t a2)
{
  *a1 = a2;
  return 0;
}

double LexDT_Con(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5)
{
  if (!_LexChain_Con((void *)a1, a2, a3))
  {
    *(void *)a1 = &__LexDT;
    *(void *)(a1 + 72) = 0;
    *(void *)(a1 + 80) = 0;
    if (a4)
    {
      *(void *)(a1 + 72) = a4;
      *(void *)(a1 + 80) = a5;
      if (!PNEW_DTTree_Con(a2, a2, a4, (uint64_t **)(a1 + 56))
        && !PNEW_DTGraphemeParser_Con(a2, a2, *(void *)(a1 + 56), (void *)(a1 + 32))
        && !PNEW_DTSearch_Con(a2, a2, *(void *)(a1 + 56), (uint64_t *)(a1 + 40)))
      {
        PNEW_DTPostProcessor_Con(a2, a2, *(void *)(a1 + 56), (uint64_t *)(a1 + 48));
        if (!v10) {
          *(_DWORD *)(a1 + 64) = *(_DWORD *)(*(void *)(*(void *)(a1 + 56) + 72) + 24);
        }
      }
    }
    else
    {
      double result = 0.0;
      *(_OWORD *)(a1 + 32) = 0u;
      *(_OWORD *)(a1 + 48) = 0u;
    }
  }
  return result;
}

uint64_t LexDT_Des(uint64_t *a1)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = a1[6];
  if (!v3 || (uint64_t result = OOC_PlacementDeleteObject(a1[2], v3), !result))
  {
    uint64_t v5 = a1[5];
    if (!v5 || (uint64_t result = OOC_PlacementDeleteObject(v2, v5), !result))
    {
      uint64_t v6 = a1[4];
      if (!v6 || (uint64_t result = OOC_PlacementDeleteObject(v2, v6), !result))
      {
        uint64_t v7 = a1[7];
        if (!v7 || (uint64_t result = OOC_PlacementDeleteObject(v2, v7), !result))
        {
          uint64_t v8 = a1[10];
          if (v8) {
            OOCAllocator_Free(v8, a1[9]);
          }
          return LexChain_Des((uint64_t)a1);
        }
      }
    }
  }
  return result;
}

uint64_t LexDT_GetParamList(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t result = 0;
  uint64_t v5 = a3;
  uint64_t v6 = (_DWORD *)(a2 + 4);
  do
  {
    switch(*(v6 - 1))
    {
      case 0:
        int v7 = *(_DWORD *)(a1 + 64);
        goto LABEL_15;
      case 1:
        int v7 = *(unsigned __int16 *)(*(void *)(a1 + 40) + 48);
        goto LABEL_15;
      case 2:
        int v7 = *(_DWORD *)(*(void *)(a1 + 40) + 52);
        goto LABEL_15;
      case 3:
        uint64_t v8 = *(void *)(a1 + 40);
        goto LABEL_13;
      case 4:
        int v7 = *(unsigned __int16 *)(*(void *)(a1 + 40) + 60);
        goto LABEL_15;
      case 5:
        int v7 = *(_DWORD *)(*(void *)(a1 + 48) + 88);
        goto LABEL_15;
      case 6:
        int v7 = *(_DWORD *)(*(void *)(a1 + 48) + 92);
        goto LABEL_15;
      case 7:
        uint64_t v8 = *(void *)(a1 + 48);
LABEL_13:
        int v7 = *(_DWORD *)(v8 + 56);
        goto LABEL_15;
      case 8:
        int v7 = *(_DWORD *)(*(void *)(a1 + 48) + 60);
LABEL_15:
        *uint64_t v6 = v7;
        break;
      default:
        uint64_t result = kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Param list contains parameter with invalid ID");
        break;
    }
    v6 += 2;
    --v5;
  }
  while (v5);
  return result;
}

uint64_t LexDT_HasParam(uint64_t a1, int a2)
{
  uint64_t v2 = 0;
  while (dword_20D62D270[v2] != a2)
  {
    if (++v2 == 9) {
      return 0;
    }
  }
  return 1;
}

uint64_t LexDT_SetParamList(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t v4 = 0;
  uint64_t v5 = a3;
  uint64_t v6 = (__int16 *)(a2 + 4);
  do
  {
    switch(*((_DWORD *)v6 - 1))
    {
      case 0:
        *(_DWORD *)(a1 + 64) = *(_DWORD *)v6;
        break;
      case 1:
        DTSearch_SetPruning(*(void *)(a1 + 40), *v6);
        break;
      case 2:
        DTSearch_SetHistogramPruning(*(void *)(a1 + 40), *(_DWORD *)v6);
        break;
      case 3:
        uint64_t v7 = DTSearch_SetHistogramBins(*(void *)(a1 + 40), *(_DWORD *)v6);
        goto LABEL_9;
      case 4:
        DTSearch_SetHistogramDiff(*(void *)(a1 + 40), *v6);
        break;
      case 5:
        *(_DWORD *)(*(void *)(a1 + 48) + 88) = *(_DWORD *)v6;
        break;
      case 6:
        *(_DWORD *)(*(void *)(a1 + 48) + 92) = *(_DWORD *)v6;
        break;
      case 7:
        *(_DWORD *)(*(void *)(a1 + 48) + 56) = *(_DWORD *)v6;
        break;
      case 8:
        *(_DWORD *)(*(void *)(a1 + 48) + 60) = *(_DWORD *)v6;
        break;
      default:
        uint64_t v7 = kaldi::PipeInputImpl::MyType((kaldi::PipeInputImpl *)"Param list contains parameter with invalid ID");
LABEL_9:
        uint64_t v4 = v7;
        break;
    }
    v6 += 4;
    --v5;
  }
  while (v5);
  return v4;
}

BOOL _LexDT_AcceptWordType(uint64_t a1, int a2)
{
  return a2 == 4;
}

unint64_t _LexDT_FindWord(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 16);
  unint64_t result = DTGraphemeParser_Parse(*(void **)(a1 + 32), *(char **)(a2 + 8));
  if (!result)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    size_t v8 = *(unsigned int *)(v7 + 40);
    if (!*(_DWORD *)(v7 + 40)) {
      return 0;
    }
    uint64_t v9 = *(unsigned char **)(v7 + 24);
    uint64_t v17 = 0;
    unint64_t result = DTSearch_BeamSearch(*(void *)(a1 + 40), v9, v8, &v17);
    if (result) {
      return result;
    }
    unint64_t result = DTPostProcessor_CreateNBest(*(void *)(a1 + 48), *(void *)(*(void *)(a1 + 40) + 32), *(_DWORD *)(a1 + 64));
    if (result) {
      return result;
    }
    uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 40);
    if (!v10) {
      return 0;
    }
    for (uint64_t i = 0; i != v10; ++i)
    {
      uint64_t v16 = 0;
      uint64_t v12 = *(void *)(a1 + 48);
      uint64_t v13 = *(unsigned char **)(*(void *)(v12 + 32) + 8 * i);
      unsigned int TranscriptionSize = DTPostProcessor_GetTranscriptionSize(v12, i);
      unint64_t result = PNEW_Transcription_Con(v5, v5, v13, TranscriptionSize, 1, 1, &v16);
      if (result) {
        break;
      }
      uint64_t v15 = v16;
      *(_DWORD *)(v16 + 28) = *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 48) + 4 * i);
      unint64_t result = PtrQueue_Put(a3, v15);
      if (result) {
        break;
      }
    }
  }
  return result;
}

void PNEW_LexDT_Con(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t *a6)
{
  int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 88, &v14);
  if (!v14)
  {
    LexDT_Con(v12, a2, a3, a4, a5);
    int v14 = v13;
    if (v13)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
    }
    else
    {
      *a6 = v12;
    }
  }
}

uint64_t DTLeafBuffer_GetPLeaf(void *a1, unsigned int a2)
{
  return *a1 + a2 + 4;
}

uint64_t DTQuestionWB_IsTrue(uint64_t a1, int a2, uint64_t a3, int a4)
{
  int v4 = *(char *)(*(void *)(a1 + 8) + 1);
  unsigned int v5 = v4 + a2;
  if (v4 < 0)
  {
    if ((int)v5 < a4)
    {
      if ((v5 & 0x80000000) != 0) {
        return 1;
      }
      if (!*(unsigned char *)(a3 + v5))
      {
        uint64_t result = 1;
        if (v5 == a4 - 1) {
          return result;
        }
        return *(unsigned __int8 *)(a3 + v5 + result) != 0;
      }
    }
    return 0;
  }
  if ((v5 & 0x80000000) != 0) {
    return 0;
  }
  if ((int)v5 >= a4) {
    return 1;
  }
  if (*(unsigned char *)(a3 + v5)) {
    return 0;
  }
  if (!v5) {
    return 1;
  }
  LODWORD(result) = -1;
  return *(unsigned __int8 *)(a3 + v5 + result) != 0;
}

uint64_t PNEW_DTQuestionWB_Con(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = (void *)OOCAllocator_Malloc(a1, 16, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = _DTQuestion_Con(v6, a2);
    if (result)
    {
      unsigned int v8 = result;
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *uint64_t v6 = &__DTQuestionWB;
      *a3 = v6;
    }
  }
  return result;
}

uint64_t _LexChain_Con(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    *a1 = &__LexChain;
    a1[1] = a3;
    a1[2] = a2;
    a1[3] = 0;
  }
  return result;
}

uint64_t LexChain_Des(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    uint64_t result = OOC_PlacementDeleteObject(*(void *)(a1 + 16), v2);
    if (result) {
      return result;
    }
    *(void *)(a1 + 24) = 0;
  }
  return Object_Des();
}

uint64_t LexChain_AddPostProcessor(uint64_t a1, uint64_t a2)
{
  unsigned int v5 = (uint64_t *)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 24);
  if (!v4)
  {
    uint64_t result = PNEW_PtrList_Con(*(void *)(a1 + 16), *(void *)(a1 + 16), 8u, 8, v5);
    if (result) {
      return result;
    }
    uint64_t v4 = *v5;
  }
  return PtrList_Append(v4, a2);
}

uint64_t LexChain_FetchTranscription(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((*(unsigned int (**)(void *, void))(*a1 + 72))(a1, *(unsigned int *)(a2 + 20)))
  {
    memset(v17, 0, sizeof(v17));
    uint64_t result = PtrQueue_Con((uint64_t)v17, a1[2], 5u, 5);
    if (!result)
    {
      uint64_t result = (*(uint64_t (**)(void *, uint64_t, _OWORD *))(*a1 + 64))(a1, a2, v17);
      if (!result)
      {
        if (PtrQueue_IsEmpty((uint64_t)v17))
        {
          uint64_t v9 = a1[1];
          if (v9)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v9 + 24))(v9, a2, a3, a4);
            if (result) {
              return result;
            }
          }
        }
        else
        {
          while (!PtrQueue_IsEmpty((uint64_t)v17))
          {
            uint64_t v11 = PtrQueue_Item((uint64_t)v17);
            uint64_t v12 = v11;
            if (a3 && (*(_DWORD *)(v11 + 20) & a3) == 0)
            {
              uint64_t v13 = a1[1];
              if (v13)
              {
                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v13 + 24))(v13, v12, a3, a4);
                if (result) {
                  return result;
                }
              }
              uint64_t result = PDELETE_Transcription(a1[2], v12);
              if (result) {
                return result;
              }
            }
            else
            {
              uint64_t result = PtrQueue_Put(a4, v11);
              if (result) {
                return result;
              }
            }
            uint64_t result = PtrQueue_Remove((uint64_t)v17);
            if (result) {
              return result;
            }
          }
        }
        uint64_t v14 = a1[3];
        if (v14 && kaldi::MatrixBase<float>::Stride(v14))
        {
          unsigned int v15 = 0;
          while (1)
          {
            uint64_t v16 = PtrList_ItemN(a1[3], v15);
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v16 + 80))(v16, a2, a3, a4);
            if (result) {
              break;
            }
            if (++v15 >= kaldi::MatrixBase<float>::Stride(a1[3])) {
              return (*(uint64_t (**)(_OWORD *))(*(void *)&v17[0] + 16))(v17);
            }
          }
        }
        else
        {
          return (*(uint64_t (**)(_OWORD *))(*(void *)&v17[0] + 16))(v17);
        }
      }
    }
  }
  else
  {
    uint64_t result = a1[1];
    if (result)
    {
      uint64_t v10 = *(uint64_t (**)(void))(*(void *)result + 24);
      return v10();
    }
  }
  return result;
}

uint64_t LexChain_GetParamList()
{
  return err_GenerateErrorNotSupported();
}

uint64_t LexChain_HasParam()
{
  return 0;
}

uint64_t LexChain_SetParamList()
{
  return err_GenerateErrorNotSupported();
}

uint64_t _LexChain_PostProcess(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  memset(v13, 0, sizeof(v13));
  int v7 = PtrQueue_NrItems(a4);
  uint64_t result = PtrQueue_Con((uint64_t)v13, a1[2], 5u, 5);
  if (!result)
  {
    if (v7)
    {
      int v9 = 0;
      while (1)
      {
        uint64_t v10 = PtrQueue_Item(a4);
        uint64_t result = PtrQueue_Remove(a4);
        if (result) {
          break;
        }
        if ((*(unsigned int (**)(uint64_t *, void))(*a1 + 72))(a1, *(unsigned int *)(v10 + 20)))
        {
          uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, _OWORD *))(*a1 + 24))(a1, v10, a3, v13);
          if (result) {
            return result;
          }
          while (!PtrQueue_IsEmpty((uint64_t)v13))
          {
            uint64_t v11 = PtrQueue_Item((uint64_t)v13);
            uint64_t result = PtrQueue_Put(a4, v11);
            if (!result)
            {
              uint64_t result = PtrQueue_Remove((uint64_t)v13);
              if (!result) {
                continue;
              }
            }
            return result;
          }
          uint64_t result = PDELETE_Transcription(a1[2], v10);
          if (result) {
            return result;
          }
        }
        else
        {
          uint64_t result = PtrQueue_Put(a4, v10);
          if (result) {
            return result;
          }
          while (!PtrQueue_IsEmpty((uint64_t)v13))
          {
            uint64_t v12 = PtrQueue_Item((uint64_t)v13);
            uint64_t result = PDELETE_Transcription(a1[2], v12);
            if (!result)
            {
              uint64_t result = PtrQueue_Remove((uint64_t)v13);
              if (!result) {
                continue;
              }
            }
            return result;
          }
        }
        if (++v9 == v7) {
          return (*(uint64_t (**)(_OWORD *))(*(void *)&v13[0] + 16))(v13);
        }
      }
    }
    else
    {
      return (*(uint64_t (**)(_OWORD *))(*(void *)&v13[0] + 16))(v13);
    }
  }
  return result;
}

void *GetLexChainClass()
{
  return &__LexChain;
}

uint64_t Transcription_Con(uint64_t a1, uint64_t a2, unsigned char *a3, unsigned int a4, int a5, int a6)
{
  unsigned int v16 = 0;
  if (a5 == 1)
  {
    if (a3[a4 - 1]) {
      unsigned int v12 = a4 + 1;
    }
    else {
      unsigned int v12 = a4;
    }
  }
  else
  {
    unsigned int v12 = a4;
    if (a5 == 4)
    {
      if (!a4 || (unsigned int v12 = a4, a3[a4 - 1])) {
        unsigned int v12 = a4 + 1;
      }
    }
  }
  uint64_t v13 = (void *)OOCAllocator_Calloc(a2, 1, v12, &v16);
  *(void *)(a1 + 8) = v13;
  uint64_t v14 = v16;
  if (!v16)
  {
    memcpy(v13, a3, a4);
    *(_DWORD *)(a1 + 16) = v12;
    *(_DWORD *)(a1 + 20) = a5;
    *(_DWORD *)(a1 + 24) = a6;
    *(_DWORD *)(a1 + 28) = 0;
    *(void *)a1 = a2;
    return v16;
  }
  return v14;
}

uint64_t Transcription_Des(uint64_t a1)
{
  if (*(int *)(a1 + 16) >= 1) {
    OOCAllocator_Free(*(void *)a1, *(void *)(a1 + 8));
  }
  return 0;
}

uint64_t PNEW_Transcription_Con(uint64_t a1, uint64_t a2, unsigned char *a3, unsigned int a4, int a5, int a6, uint64_t *a7)
{
  unsigned int v16 = 0;
  uint64_t v14 = OOCAllocator_Malloc(a1, 32, &v16);
  uint64_t result = v16;
  if (!v16)
  {
    uint64_t result = Transcription_Con(v14, a2, a3, a4, a5, a6);
    unsigned int v16 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v14);
      *a7 = 0;
      return v16;
    }
    else
    {
      *a7 = v14;
    }
  }
  return result;
}

uint64_t PDELETE_Transcription(uint64_t a1, uint64_t a2)
{
  if (*(int *)(a2 + 16) >= 1) {
    OOCAllocator_Free(*(void *)a2, *(void *)(a2 + 8));
  }
  OOCAllocator_Free(a1, a2);
  return 0;
}

uint64_t StringTokenizer_Con(void *a1, uint64_t a2)
{
  uint64_t result = Object_Con(a1);
  unsigned int v5 = result;
  if (!result)
  {
    *a1 = &__StringTokenizer;
    a1[1] = a2;
    a1[3] = 50;
    a1[5] = 50;
    a1[2] = OOCAllocator_Malloc(a2, 50, &v5);
    uint64_t result = v5;
    if (!v5)
    {
      a1[4] = OOCAllocator_Malloc(a1[1], a1[5], &v5);
      uint64_t result = v5;
      if (!v5) {
        a1[6] = 0;
      }
    }
  }
  return result;
}

uint64_t StringTokenizer_Des(uint64_t *a1)
{
  OOCAllocator_Free(a1[1], a1[2]);
  OOCAllocator_Free(a1[1], a1[4]);
  return Object_Des();
}

uint64_t StringTokenizer_ExpandPhoneticMultiples(uint64_t a1, uint64_t a2, char *a3, uint64_t *a4, void *a5)
{
  uint64_t v15 = 0;
  unsigned int v16 = 0;
  *a4 = 0;
  uint64_t v8 = __StringTokenizer_ExpandMultiple(a2, a3, &v15, &v16);
  if (!v8)
  {
    unsigned int v9 = v16;
    uint64_t v10 = v15;
    if (v16 >= 0x11)
    {
      uint64_t v11 = (uint64_t *)(v15 + 128);
      uint64_t v12 = v16 - 16;
      do
      {
        uint64_t v13 = *v11++;
        OOCAllocator_Free(a2, v13);
        --v12;
      }
      while (v12);
      unsigned int v9 = 16;
    }
    *a4 = v10;
    *a5 = v9;
  }
  return v8;
}

uint64_t __StringTokenizer_ExpandMultiple(uint64_t a1, char *a2, uint64_t *a3, unsigned int *a4)
{
  uint64_t v4 = a3;
  unsigned int v5 = a2;
  unsigned int v98 = 0;
  *a4 = 0;
  *a3 = 0;
  uint64_t v6 = strchr(a2, 40);
  if (v6)
  {
    int v7 = v6;
    uint64_t v8 = v6 + 1;
    unsigned int v9 = strchr(v6 + 2, 37);
    uint64_t v10 = strchr(v8, 41);
    if (v10)
    {
      uint64_t v11 = v10;
      while (*(v11 - 1) == 37)
      {
        uint64_t v11 = strchr(v11 + 1, 41);
        if (!v11) {
          return v98;
        }
      }
      if (!v9 || v9 >= v11) {
        goto LABEL_24;
      }
      do
      {
        uint64_t v13 = v9 + 1;
        if (v9[1] == 34)
        {
          uint64_t v14 = strchr(v9 + 2, 34);
          if (!v14) {
            return v98;
          }
          uint64_t v15 = v14;
          if (v14 > v11)
          {
            for (uint64_t i = v14 + 1; ; uint64_t i = v17 + 1)
            {
              uint64_t v17 = strchr(i, 41);
              uint64_t v11 = v17;
              if (!v17 || *(v17 - 1) != 37) {
                break;
              }
            }
          }
          uint64_t v13 = v15 + 1;
        }
        unsigned int v18 = strchr(v13, 37);
        if (!v18) {
          break;
        }
        unsigned int v9 = v18;
      }
      while (v18 < v11);
      if (v11)
      {
LABEL_24:
        for (j = v8; ; j = v21)
        {
          uint64_t v20 = strchr(j, 40);
          if (!v20 || v20 >= v11) {
            break;
          }
          uint64_t v21 = v20 + 1;
          __int16 v22 = strchr(v20 + 1, 37);
          uint64_t v23 = strchr(v11 + 1, 41);
          if (!v23) {
            return v98;
          }
          uint64_t v11 = v23;
          while (*(v11 - 1) == 37)
          {
            uint64_t v11 = strchr(v11 + 1, 41);
            if (!v11) {
              return v98;
            }
          }
          if (v22 && v22 < v11)
          {
            do
            {
              unint64_t v24 = v22 + 1;
              if (v22[1] == 34)
              {
                long long v25 = strchr(v22 + 2, 34);
                if (!v25) {
                  return v98;
                }
                uint64_t v26 = v25;
                if (v25 > v11)
                {
                  for (k = v25 + 1; ; k = v28 + 1)
                  {
                    unsigned int v28 = strchr(k, 41);
                    uint64_t v11 = v28;
                    if (!v28 || *(v28 - 1) != 37) {
                      break;
                    }
                  }
                }
                unint64_t v24 = v26 + 1;
              }
              char v29 = strchr(v24, 37);
              if (!v29) {
                break;
              }
              __int16 v22 = v29;
            }
            while (v29 < v11);
            if (!v11) {
              return v98;
            }
          }
        }
        int v91 = strlen(v11);
        __dst = (char *)OOCAllocator_Malloc(a1, v11 - v7, &v98);
        if (!v98)
        {
          unint64_t v30 = strncpy(__dst, v8, v11 - v7 - 1);
          __dst[v11 - v7 - 1] = 0;
          LODWORD(v97) = 0;
          unsigned int v31 = strchr(v30, 124);
          if (!v31)
          {
            uint64_t v83 = 0;
            unsigned int v82 = 1;
            v81 = __dst;
            goto LABEL_124;
          }
          unsigned int v32 = v31;
          uint64_t v93 = 0;
          unsigned int v33 = 0;
          uint64_t v34 = __dst;
          char v35 = __dst;
          v89 = v4;
          v90 = v5;
          do
          {
            unsigned int v36 = strchr(v35, 40);
            if (!v36 || v32 <= v36) {
              goto LABEL_55;
            }
            int v37 = 1;
            do
            {
              unsigned int v36 = strchr(v36 + 1, 40);
              --v37;
            }
            while (v36 && v32 > v36);
            if (v37 == 1) {
              goto LABEL_55;
            }
            int v43 = 0;
            int v87 = -v37;
            do
            {
              v44 = v35 + 1;
              int v45 = strchr(v44, 37);
              uint64_t v46 = strchr(v44, 41);
              if (!v46) {
                goto LABEL_83;
              }
              char v35 = v46;
              while (*(v35 - 1) == 37)
              {
                char v35 = strchr(v35 + 1, 41);
                if (!v35) {
                  goto LABEL_83;
                }
              }
              if (v45 && v45 < v35)
              {
                do
                {
                  int v47 = v45 + 1;
                  if (v45[1] == 34)
                  {
                    int v48 = strchr(v45 + 2, 34);
                    if (!v48) {
                      goto LABEL_83;
                    }
                    int v49 = v48;
                    if (v48 > v35)
                    {
                      for (m = v48 + 1; ; m = v51 + 1)
                      {
                        v51 = strchr(m, 41);
                        char v35 = v51;
                        if (!v51 || *(v51 - 1) != 37) {
                          break;
                        }
                      }
                    }
                    int v47 = v49 + 1;
                  }
                  unsigned int v52 = strchr(v47, 37);
                  if (!v52) {
                    break;
                  }
                  int v45 = v52;
                }
                while (v52 < v35);
                if (!v35)
                {
LABEL_83:
                  unsigned int v88 = 0;
                  goto LABEL_84;
                }
              }
            }
            while (v87 != v43++);
            if (v32 > v35)
            {
LABEL_55:
              uint64_t v38 = OOCAllocator_Realloc(a1, v93, 8 * (v33 + 1), &v97);
              unsigned int v39 = v97;
              if (!v97)
              {
                uint64_t v40 = v38;
                int64_t v41 = v32 - v34;
                v42 = (char *)OOCAllocator_Malloc(a1, v32 - v34 + 2, &v97);
                *(void *)(v40 + 8 * v33) = v42;
                unsigned int v39 = v97;
                if (!v97)
                {
                  strncpy(v42, v34, v32 - v34);
                  *(unsigned char *)(*(void *)(v40 + 8 * v33) + v41) = 0;
                  uint64_t v93 = v40;
                  uint64_t v4 = v89;
                  unsigned int v5 = v90;
                  *(unsigned char *)(v41 + *(void *)(v40 + 8 * v33) + 1) = 0;
                  char v35 = v32 + 1;
                  ++v33;
                  uint64_t v34 = v32 + 1;
                  goto LABEL_58;
                }
              }
              return v39;
            }
            ++v35;
LABEL_58:
            unsigned int v32 = strchr(v35, 124);
          }
          while (v32);
          v81 = v34;
          unsigned int v82 = v33 + 1;
          uint64_t v83 = v93;
LABEL_124:
          uint64_t v75 = OOCAllocator_Realloc(a1, v83, 8 * v82, &v97);
          unsigned int v39 = v97;
          if (v97) {
            return v39;
          }
          uint64_t v76 = v75;
          int v77 = strlen(v81);
          v78 = (char *)OOCAllocator_Malloc(a1, (v77 + 2), &v97);
          uint64_t v79 = v82 - 1;
          *(void *)(v76 + 8 * v79) = v78;
          unsigned int v39 = v97;
          if (v97) {
            return v39;
          }
          unsigned int v88 = v82;
          strcpy(v78, v81);
          uint64_t v93 = v76;
          *(unsigned char *)(*(void *)(v76 + 8 * v79) + (v77 + 1)) = 0;
LABEL_84:
          unsigned int v98 = v97;
          if (!v97)
          {
            uint64_t *v4 = OOCAllocator_Malloc(a1, 8 * v88, &v98);
            if (!v98)
            {
              uint64_t v54 = v88;
              *a4 = v88;
              if (v88)
              {
                uint64_t v55 = 0;
                unsigned int v56 = 0;
                int v86 = v7 - v5;
                __src = v11 + 1;
                __uint64_t n = (v7 - v5);
                while (1)
                {
                  int v57 = strlen(*(const char **)(v93 + 8 * v55));
                  v58 = (char *)OOCAllocator_Malloc(a1, (v91 + 1 + v57 + v86), &v98);
                  if (v98) {
                    return v98;
                  }
                  v59 = v58;
                  v60 = strncpy(v58, v5, __n);
                  v61 = strcpy(&v60[__n], *(const char **)(v93 + 8 * v55));
                  strcpy(&v61[v57], __src);
                  v59[v57 + v86 + v91] = 0;
                  if (strchr(v59, 40)) {
                    break;
                  }
                  *(void *)(*v4 + 8 * v56++) = v59;
LABEL_115:
                  if (++v55 == v54) {
                    goto LABEL_116;
                  }
                }
                uint64_t v62 = v54;
                v97 = 0;
                unsigned int v96 = 0;
                unsigned int v98 = __StringTokenizer_ExpandMultiple(a1, v59, &v97, &v96);
                if (v98) {
                  return v98;
                }
                uint64_t v63 = v96;
                unsigned int v64 = *a4 + v96 - 1;
                if (v64 > 0x10)
                {
                  if (*a4 < 0x10)
                  {
                    uint64_t *v4 = OOCAllocator_Realloc(a1, *v4, 128, &v98);
                    if (v98) {
                      return v98;
                    }
                    uint64_t v65 = (uint64_t)v97;
                    if (v63)
                    {
                      v71 = v97;
                      do
                      {
                        uint64_t v72 = *v71;
                        if (v56 > 0xF)
                        {
                          if (v72)
                          {
                            OOCAllocator_Free(a1, v72);
                            uint64_t *v71 = 0;
                          }
                        }
                        else
                        {
                          *(void *)(*v4 + 8 * v56++) = v72;
                        }
                        ++v71;
                        --v63;
                      }
                      while (v63);
                    }
                    uint64_t v66 = v55;
                    *a4 = 16;
                    goto LABEL_114;
                  }
                  uint64_t v65 = (uint64_t)v97;
                  if (v96)
                  {
                    uint64_t v68 = 0;
                    uint64_t v69 = 8 * v96;
                    do
                    {
                      uint64_t v70 = *(void *)(v65 + v68);
                      if (v70)
                      {
                        OOCAllocator_Free(a1, v70);
                        *(void *)(v65 + v68) = 0;
                      }
                      v68 += 8;
                    }
                    while (v69 != v68);
                  }
                }
                else
                {
                  *a4 = v64;
                  uint64_t *v4 = OOCAllocator_Realloc(a1, *v4, 8 * v64, &v98);
                  if (v98) {
                    return v98;
                  }
                  uint64_t v65 = (uint64_t)v97;
                  if (v63)
                  {
                    uint64_t v66 = v55;
                    for (uint64_t n = 0; n != v63; ++n)
                      *(void *)(*v4 + 8 * (v56 + n)) = *(void *)(v65 + 8 * n);
                    v56 += n;
                    goto LABEL_114;
                  }
                }
                uint64_t v66 = v55;
LABEL_114:
                OOCAllocator_Free(a1, v65);
                OOCAllocator_Free(a1, (uint64_t)v59);
                uint64_t v54 = v62;
                uint64_t v55 = v66;
                goto LABEL_115;
              }
LABEL_116:
              if (__dst) {
                OOCAllocator_Free(a1, (uint64_t)__dst);
              }
              if (v93)
              {
                if (v88)
                {
                  v73 = (uint64_t *)v93;
                  do
                  {
                    uint64_t v74 = *v73++;
                    OOCAllocator_Free(a1, v74);
                    --v54;
                  }
                  while (v54);
                }
                OOCAllocator_Free(a1, v93);
              }
            }
          }
        }
      }
    }
  }
  else if (!strchr(v5, 124))
  {
    uint64_t *v4 = OOCAllocator_Malloc(a1, 8, &v98);
    if (!v98)
    {
      size_t v12 = strlen(v5);
      *(void *)uint64_t *v4 = OOCAllocator_Malloc(a1, v12 + 2, &v98);
      if (!v98)
      {
        strcpy(*(char **)*v4, v5);
        *(unsigned char *)(strlen(v5) + *(void *)*v4 + 1) = 0;
        *a4 = 1;
      }
    }
  }
  return v98;
}

uint64_t PNEW_StringTokenizer_Con(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v8 = 0;
  uint64_t v6 = (void *)OOCAllocator_Malloc(a1, 56, &v8);
  uint64_t result = v8;
  if (!v8)
  {
    uint64_t result = StringTokenizer_Con(v6, a2);
    unsigned int v8 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v6);
      *a3 = 0;
      return v8;
    }
    else
    {
      *a3 = v6;
    }
  }
  return result;
}

uint64_t abbrtn_checkIfBisectedbyTokenType(uint64_t a1, unsigned int a2, unsigned int a3, int a4, _DWORD *a5)
{
  int v20 = 0;
  *a5 = 0;
  LDO_GetLabels(*(void *)(a1 + 192), &v18);
  uint64_t v9 = 0;
  uint64_t v10 = (uint64_t **)v18.n128_u64[1];
  unint64_t v11 = v19;
  if (v18.n128_u64[1] < v19)
  {
    do
    {
      v18.n128_u32[0] = 0;
      int U32Attribute = LDOObject_GetU32Attribute(*v10, "_TTYPE", &v18, &v20);
      uint64_t v9 = LH_ERROR_to_VERROR(U32Attribute);
      if ((v9 & 0x80000000) != 0) {
        break;
      }
      unsigned int AbsoluteFrom = LDOLabel_GetAbsoluteFrom((uint64_t)*v10);
      unsigned int AbsoluteTo = LDOLabel_GetAbsoluteTo((uint64_t)*v10);
      if (v18.n128_u32[0] == 1 && v20 == a4)
      {
        BOOL v16 = AbsoluteFrom < a2 || AbsoluteFrom >= a3;
        if (!v16 || AbsoluteTo > a2 && AbsoluteTo <= a3)
        {
          *a5 = 1;
          return v9;
        }
      }
      ++v10;
    }
    while ((unint64_t)v10 < v11);
  }
  return v9;
}

uint64_t abbrtn_checkIfSubsumedbyOtherToken(uint64_t a1, unsigned int a2, unsigned int a3, int a4, int a5, _DWORD *a6)
{
  int v24 = 0;
  *a6 = 0;
  LDO_GetLabels(*(void *)(a1 + 192), &v22);
  uint64_t v10 = 0;
  size_t v12 = (uint64_t **)v22.n128_u64[1];
  unint64_t v11 = v23;
  if (v22.n128_u64[1] < v23)
  {
    do
    {
      uint64_t v13 = *v12;
      v22.n128_u32[0] = 0;
      int U32Attribute = LDOObject_GetU32Attribute(v13, "_TTYPE", &v22, &v24);
      uint64_t v10 = LH_ERROR_to_VERROR(U32Attribute);
      if ((v10 & 0x80000000) != 0) {
        break;
      }
      unsigned int AbsoluteFrom = LDOLabel_GetAbsoluteFrom((uint64_t)v13);
      unsigned int AbsoluteTo = LDOLabel_GetAbsoluteTo((uint64_t)v13);
      if (v22.n128_u32[0] == 1)
      {
        BOOL v17 = AbsoluteFrom == a2 && AbsoluteTo == a3;
        BOOL v18 = v17;
        BOOL v19 = v24 == a4 && v18;
        if (v24 == a5 && !v19 && AbsoluteFrom <= a2 && AbsoluteTo >= a3 && !v18)
        {
          *a6 = 1;
          return v10;
        }
      }
      ++v12;
    }
    while ((unint64_t)v12 < v11);
  }
  return v10;
}

uint64_t abbrtn_TnLookup(void *a1, const char *a2, unsigned __int16 a3, __int16 a4, char *a5, uint64_t a6)
{
  unsigned __int16 v8 = a3;
  uint64_t v106 = *MEMORY[0x263EF8340];
  __int16 v11 = a3 - 1;
  __int16 v94 = a3 - 1;
  __n128 v92 = 0uLL;
  unint64_t v93 = 0;
  uint64_t v90 = 0;
  uint64_t v91 = 0;
  int v88 = 0;
  int v89 = 0;
  uint64_t v86 = 0;
  uint64_t v87 = 0;
  __s1[0] = 0;
  __s[0] = 0;
  v103[0] = 0;
  __s2[0] = 0;
  v101[0] = 0;
  v100[0] = 0;
  int v12 = LDO_ComputeNodesCoveredByLabel(a1[24], a6, (uint64_t)&v92);
  uint64_t v13 = LH_ERROR_to_VERROR(v12);
  if ((v13 & 0x80000000) != 0) {
    return v13;
  }
  unint64_t v85 = (v93 - v92.n128_u64[1]) >> 3;
  if (!v85) {
    goto LABEL_137;
  }
  v84 = a2;
  if (a4 < 1) {
    goto LABEL_137;
  }
  unsigned int v14 = 0;
  __int16 v82 = a4;
  int v83 = 3;
  v81 = a5;
  do
  {
    int v15 = v8;
    while (1)
    {
      BOOL v16 = *(uint64_t **)(v92.n128_u64[1] + 8 * v14);
      int v17 = abbrtn_checkForTokens((uint64_t)a1, (uint64_t)v16, v15, (_WORD *)&v88 + 1, &v88, (_DWORD *)&v87 + 1, (_DWORD *)&v86 + 1);
      if (v17 < 0) {
        goto LABEL_142;
      }
      int v97 = 0;
      LODWORD(v87) = 0;
      LDO_GetLabels(a1[24], &v95);
      LODWORD(v13) = 0;
      BOOL v18 = (uint64_t **)v95.n128_u64[1];
      unint64_t v19 = v96;
      while ((unint64_t)v18 < v19)
      {
        int v20 = *v18;
        int v98 = 0;
        int U32Attribute = LDOObject_GetU32Attribute(v20, "_TTYPE", &v98, &v97);
        LODWORD(v13) = LH_ERROR_to_VERROR(U32Attribute);
        if ((v13 & 0x80000000) != 0) {
          goto LABEL_138;
        }
        if (v98 == 1 && v97 == 4)
        {
          int v23 = LDOLabel_ContainsNode((uint64_t)v20, (uint64_t)v16, &v87);
          LODWORD(v13) = LH_ERROR_to_VERROR(v23);
          if ((v13 & 0x80000000) != 0) {
            goto LABEL_138;
          }
          if (v87 == 1) {
            break;
          }
        }
        ++v18;
      }
      uint64_t v24 = v14;
      if (HIDWORD(v87) != 1) {
        break;
      }
      if (HIDWORD(v86) == 1)
      {
        unsigned __int16 v80 = HIWORD(v88);
        int v25 = 6;
        unsigned __int16 v26 = v88;
        goto LABEL_28;
      }
LABEL_22:
      ++v14;
      if ((int)v24 + 1 >= v85) {
        goto LABEL_138;
      }
    }
    if (v87 == 1) {
      goto LABEL_22;
    }
    int v27 = LDOTreeNode_ComputeAbsoluteFrom((uint64_t)v16, &v90);
    int v17 = LH_ERROR_to_VERROR(v27);
    if (v17 < 0) {
      goto LABEL_142;
    }
    unsigned __int16 v80 = v90;
    int v28 = LDOTreeNode_ComputeAbsoluteTo((size_t)v16, &v89);
    int v17 = LH_ERROR_to_VERROR(v28);
    if (v17 < 0) {
      goto LABEL_142;
    }
    unsigned __int16 v26 = v89;
    int v29 = LDOObject_GetU32Attribute(v16, "_TTYPE", &v91, (_DWORD *)&v91 + 1);
    int v17 = LH_ERROR_to_VERROR(v29);
    if (v17 < 0) {
      goto LABEL_142;
    }
    int v25 = HIDWORD(v91);
LABEL_28:
    uint64_t v13 = abbrtn_checkForTokens((uint64_t)a1, (uint64_t)v16, v26, (_WORD *)&v88 + 1, &v88, &v86, (_DWORD *)&v86 + 1);
    if ((v13 & 0x80000000) != 0) {
      goto LABEL_138;
    }
    ++v14;
    if ((int)v24 + 1 >= v85)
    {
      unsigned int v31 = 9999;
      int v30 = 3;
      goto LABEL_36;
    }
    if (v86 == 1)
    {
      int v30 = 1;
      unsigned int v31 = v24 + 1;
      goto LABEL_36;
    }
    unsigned int v32 = *(uint64_t **)(v92.n128_u64[1] + 8 * v14);
    int v33 = LDOObject_GetU32Attribute(v32, "_TTYPE", &v91, (_DWORD *)&v91 + 1);
    int v17 = LH_ERROR_to_VERROR(v33);
    if (v17 < 0) {
      goto LABEL_142;
    }
    unsigned __int16 v34 = v26;
    int v35 = HIDWORD(v91);
    int v36 = LDOTreeNode_ComputeAbsoluteTo((size_t)v32, (_DWORD *)&v90 + 1);
    uint64_t v13 = LH_ERROR_to_VERROR(v36);
    if ((v13 & 0x80000000) != 0) {
      goto LABEL_138;
    }
    unsigned int v31 = v24 + 1;
    int v30 = v35;
    unsigned __int16 v26 = v34;
LABEL_36:
    unsigned __int16 v37 = v80;
    int v38 = (__int16)v80;
    if ((__int16)v80 <= v11) {
      goto LABEL_128;
    }
    if (v83 != 3) {
      goto LABEL_116;
    }
    unsigned int v39 = v84;
    if (v25 == 3) {
      goto LABEL_115;
    }
    int v78 = v25;
    uint64_t v40 = 0;
    unsigned __int16 v41 = v80;
    v42 = v81;
    while (1)
    {
      unsigned int v43 = v84[v41];
      BOOL v44 = v43 > 0x20 || ((1 << v43) & 0x100002601) == 0;
      if (!v44 || v43 == 95) {
        break;
      }
      ++v41;
      __s1[v40++] = v43;
      if (v40 == 128)
      {
        int v25 = v78;
        goto LABEL_115;
      }
    }
    int v79 = v30;
    __s1[v40] = 0;
    __strcpy_chk();
    v95.n128_u64[0] = 0;
    LOWORD(v98) = 0;
    memset(v99, 0, sizeof(v99));
    uint64_t v13 = (*(uint64_t (**)(void, void, char *, uint64_t, const char *, char *, __n128 *, int *))(a1[8] + 120))(a1[6], a1[7], __s, 255, "femwtn", v81, &v95, &v98);
    if ((v13 & 0x80000000) != 0)
    {
LABEL_138:
      int v75 = LDO_FreeLDOTreeNodeVector(a1[24], (uint64_t)&v92);
      unsigned int v76 = LH_ERROR_to_VERROR(v75);
      if ((int)v13 >= 0) {
        return v76;
      }
      else {
        return v13;
      }
    }
    if ((_WORD)v98)
    {
      unsigned __int8 v45 = 0;
      unint64_t v46 = 0;
      do
      {
        unsigned int v47 = LH_atou(*(const char **)(v95.n128_u64[0] + 8 * v46));
        if (v47 <= 0x3F) {
          *((unsigned char *)v99 + v45++) = v47;
        }
        ++v46;
      }
      while (v46 < (unsigned __int16)v98);
      ssft_qsort((uint64_t)v99, v45, 1, (uint64_t (*)(unint64_t, unint64_t))compare);
      unsigned int v39 = v84;
      if (v45)
      {
        unint64_t v48 = 0;
        do
        {
          if (v31 == 9999)
          {
LABEL_57:
            unsigned int v31 = 9999;
          }
          else if (*((unsigned char *)v99 + v48))
          {
            while (1)
            {
              int v49 = LDOObject_GetU32Attribute(*(uint64_t **)(v92.n128_u64[1] + 8 * v31), "_TTYPE", &v91, (_DWORD *)&v91 + 1);
              uint64_t v13 = LH_ERROR_to_VERROR(v49);
              if ((v13 & 0x80000000) != 0) {
                goto LABEL_138;
              }
              unsigned int v50 = v31 + 1;
              if (v31 + 1 >= v85)
              {
                int v79 = 0;
                unsigned int v31 = 9999;
                break;
              }
              if (v31 == 9998)
              {
                int v79 = 0;
                goto LABEL_57;
              }
              ++v31;
              if (!*((unsigned char *)v99 + v48))
              {
                int v79 = 0;
                unsigned int v31 = v50;
                break;
              }
            }
          }
          unsigned int v51 = *((unsigned __int8 *)v99 + v48);
          if (*((unsigned char *)v99 + v48))
          {
            uint64_t v52 = 0;
            int v53 = 0;
            uint64_t v54 = 0;
            unsigned int v55 = v84[v80];
            unsigned __int16 v56 = v80;
            while (v55)
            {
              __s[v52] = v55;
              if (v52 == 255) {
                goto LABEL_100;
              }
              uint64_t v57 = ++v56;
              unsigned int v55 = v84[v56];
              BOOL v58 = v55 > 0x20 || ((1 << v55) & 0x100002600) == 0;
              if (!v58 || v55 == 95)
              {
                unsigned int v59 = v84[v56 - 1];
                int v60 = v59 == 95 ? v53 : v53 + 1;
                BOOL v61 = v59 > 0x20;
                uint64_t v62 = (1 << v59) & 0x100002600;
                if (v61 || v62 == 0) {
                  int v53 = v60;
                }
              }
              ++v52;
              ++v54;
              if (v51 <= v53) {
                goto LABEL_88;
              }
            }
            uint64_t v54 = (unsigned __int16)v52;
            uint64_t v57 = v56;
          }
          else
          {
            uint64_t v54 = 0;
            LOBYTE(v53) = 0;
            uint64_t v57 = v80;
          }
LABEL_88:
          __s[v54] = 0;
          if (!v84[v57])
          {
            unsigned int v64 = v84[v57 - 1];
            BOOL v65 = v64 > 0x20 || ((1 << v64) & 0x100002600) == 0;
            if (v65 && v64 != 95) {
              LOBYTE(v53) = v53 + 1;
            }
          }
          if (v51 == v53)
          {
            __strcpy_chk();
            int v17 = (*(uint64_t (**)(void, void, char *, char *, uint64_t))(a1[8] + 112))(a1[6], a1[7], v81, v101, 256);
            if (v17 < 0) {
              goto LABEL_142;
            }
            __n128 v95 = v92;
            unint64_t v96 = v93;
            uint64_t v13 = abbrtn_Lookup((uint64_t)a1, v101, __s, v81, v84, v80, v24, &v94, (uint64_t)&v95);
            if ((v13 & 0x80000000) != 0) {
              goto LABEL_138;
            }
            __int16 v11 = v94;
          }
LABEL_100:
          ++v48;
        }
        while (v48 < v45 && (__int16)v80 > v11);
        int v38 = (__int16)v80;
        unsigned __int16 v37 = v80;
        v42 = v81;
        if ((__int16)v80 > v11) {
          goto LABEL_106;
        }
        goto LABEL_108;
      }
      unsigned __int16 v37 = v80;
      v42 = v81;
    }
    else
    {
      ssft_qsort((uint64_t)v99, 0, 1, (uint64_t (*)(unint64_t, unint64_t))compare);
      unsigned __int16 v37 = v80;
    }
LABEL_106:
    __n128 v95 = v92;
    unint64_t v96 = v93;
    unsigned __int16 v66 = v37;
    uint64_t v13 = abbrtn_Lookup((uint64_t)a1, __s1, __s1, v42, v39, v37, v24, &v94, (uint64_t)&v95);
    if ((v13 & 0x80000000) != 0) {
      goto LABEL_138;
    }
    __int16 v11 = v94;
    unsigned __int16 v37 = v66;
LABEL_108:
    if (v38 <= v11)
    {
      int v25 = v78;
      int v30 = v79;
LABEL_115:
      unsigned int v14 = v24 + 1;
      goto LABEL_116;
    }
    unsigned __int16 v67 = v37;
    __strcpy_chk();
    uint64_t v13 = (*(uint64_t (**)(void, void, char *, char *, uint64_t))(a1[8] + 112))(a1[6], a1[7], v42, __s2, 128);
    if ((v13 & 0x80000000) != 0) {
      goto LABEL_138;
    }
    if (strcmp(__s1, __s2))
    {
      __n128 v95 = v92;
      unint64_t v96 = v93;
      uint64_t v13 = abbrtn_Lookup((uint64_t)a1, __s2, __s1, v42, v39, v67, v24, &v94, (uint64_t)&v95);
      if ((v13 & 0x80000000) != 0) {
        goto LABEL_138;
      }
      __int16 v11 = v94;
    }
    int v25 = v78;
    int v30 = v79;
    unsigned int v14 = v24 + 1;
    unsigned __int16 v37 = v67;
LABEL_116:
    if (v38 > v11 && !v25 && (v83 != 3 || v30 != 3))
    {
      size_t v68 = *(void *)(v92.n128_u64[1] + 8 * v24);
      int v69 = LDOTreeNode_ComputeAbsoluteFrom(v68, &v90);
      int v17 = LH_ERROR_to_VERROR(v69);
      if ((v17 & 0x80000000) == 0)
      {
        uint64_t v70 = (unsigned __int16)v90;
        int v71 = LDOTreeNode_ComputeAbsoluteTo(v68, (_DWORD *)&v90 + 1);
        uint64_t v13 = LH_ERROR_to_VERROR(v71);
        if ((v13 & 0x80000000) != 0) {
          goto LABEL_138;
        }
        unint64_t v72 = WORD2(v90) - (unint64_t)v70;
        unsigned __int16 v37 = v70;
        if ((int)v72 <= 127)
        {
          __strncpy_chk();
          v103[v72] = 0;
          __strcpy_chk();
          uint64_t v13 = (*(uint64_t (**)(void, void, char *, char *, uint64_t))(a1[8] + 104))(a1[6], a1[7], v81, v100, 128);
          if ((v13 & 0x80000000) != 0) {
            goto LABEL_138;
          }
          if (!strcmp(__s2, v100))
          {
            unsigned __int16 v37 = v70;
          }
          else
          {
            __n128 v95 = v92;
            unint64_t v96 = v93;
            uint64_t v73 = abbrtn_Lookup((uint64_t)a1, v100, v103, v81, v84, v70, v24, &v94, (uint64_t)&v95);
            unsigned __int16 v37 = v70;
            uint64_t v13 = v73;
            if ((v73 & 0x80000000) != 0) {
              goto LABEL_138;
            }
          }
        }
        goto LABEL_128;
      }
LABEL_142:
      LODWORD(v13) = v17;
      goto LABEL_138;
    }
LABEL_128:
    __int16 v74 = v94;
    if (v94 < (__int16)v37) {
      __int16 v74 = v26;
    }
    if (HIDWORD(v87) == 1) {
      unsigned int v14 = v24;
    }
    __int16 v11 = v74 - 1;
    __int16 v94 = v74 - 1;
    if (v14 >= v85) {
      break;
    }
    unsigned __int16 v8 = v74;
    int v83 = v25;
  }
  while (v74 < v82);
LABEL_137:
  if (v85) {
    goto LABEL_138;
  }
  return v13;
}

uint64_t abbrtn_checkForTokens(uint64_t a1, uint64_t a2, int a3, _WORD *a4, _WORD *a5, _DWORD *a6, _DWORD *a7)
{
  int v25 = 0;
  *a6 = 0;
  *a7 = 0;
  LDO_GetLabels(*(void *)(a1 + 192), &v23);
  uint64_t v12 = 0;
  unsigned int v14 = (uint64_t **)v23.n128_u64[1];
  unint64_t v13 = v24;
  if (v23.n128_u64[1] < v24)
  {
    do
    {
      int v15 = *v14;
      v23.n128_u32[0] = 0;
      int U32Attribute = LDOObject_GetU32Attribute(v15, "_TTYPE", &v23, &v25);
      uint64_t v12 = LH_ERROR_to_VERROR(U32Attribute);
      if ((v12 & 0x80000000) != 0) {
        break;
      }
      if (v23.n128_u32[0] == 1 && v25 == 6)
      {
        int v18 = LDOLabel_ContainsNode((uint64_t)v15, a2, a6);
        uint64_t v12 = LH_ERROR_to_VERROR(v18);
        if ((v12 & 0x80000000) != 0) {
          return v12;
        }
        if (*a6 == 1)
        {
          int AbsoluteFrom = LDOLabel_GetAbsoluteFrom((uint64_t)v15);
          __int16 AbsoluteTo = LDOLabel_GetAbsoluteTo((uint64_t)v15);
          if (AbsoluteFrom == a3)
          {
            *a4 = a3;
            *a5 = AbsoluteTo;
            *a7 = 1;
          }
          return v12;
        }
      }
      ++v14;
    }
    while ((unint64_t)v14 < v13);
  }
  return v12;
}

uint64_t abbrtn_Lookup(uint64_t a1, const char *a2, char *__s, char *a4, const char *a5, uint64_t a6, unsigned int a7, _WORD *a8, uint64_t a9)
{
  uint64_t v10 = a6;
  uint64_t v250 = *MEMORY[0x263EF8340];
  unsigned __int16 v247 = 0;
  uint64_t v245 = 0;
  if (a2)
  {
    if (!*a2) {
      return 0;
    }
    v232 = a8;
    int v16 = strlen(__s) + a6;
    *(_DWORD *)__sa = 0;
    v233 = a2;
    __s2 = a4;
    if (strcmp(a2, __s))
    {
      int v17 = (char *)&a5[v10];
      LOWORD(v18) = v10;
      if ((*(unsigned int (**)(void, void, char *))(*(void *)(a1 + 64) + 128))(*(void *)(a1 + 48), *(void *)(a1 + 56), v17))
      {
        int v18 = v10;
        do
        {
          v18 += utf8_determineUTF8CharLength(*v17);
          int v17 = (char *)&a5[(unsigned __int16)v18];
        }
        while ((*(unsigned int (**)(void, void, char *))(*(void *)(a1 + 64) + 128))(*(void *)(a1 + 48), *(void *)(a1 + 56), v17));
      }
      uint64_t v19 = v10;
      uint64_t PreviousUtf8Offset = (unsigned __int16)utf8_GetPreviousUtf8Offset((uint64_t)a5, (unsigned __int16)v16);
      uint64_t v21 = &a5[PreviousUtf8Offset];
      int v22 = (*(uint64_t (**)(void, void, const char *))(*(void *)(a1 + 64) + 128))(*(void *)(a1 + 48), *(void *)(a1 + 56), &a5[PreviousUtf8Offset]);
      if (PreviousUtf8Offset && v22)
      {
        do
        {
          uint64_t PreviousUtf8Offset = (unsigned __int16)utf8_GetPreviousUtf8Offset((uint64_t)a5, PreviousUtf8Offset);
          uint64_t v21 = &a5[PreviousUtf8Offset];
          int v23 = (*(uint64_t (**)(void, void, const char *))(*(void *)(a1 + 64) + 128))(*(void *)(a1 + 48), *(void *)(a1 + 56), &a5[PreviousUtf8Offset]);
        }
        while (PreviousUtf8Offset && v23);
      }
      utf8_determineUTF8CharLength(*(unsigned __int8 *)v21);
      uint64_t v10 = v19;
      goto LABEL_14;
    }
  }
  else
  {
    __s2 = a4;
    v232 = a8;
    v233 = 0;
    int v16 = strlen(__s) + a6;
    *(_DWORD *)__sa = 0;
  }
  LOWORD(v18) = v10;
LABEL_14:
  uint64_t v248 = 0;
  unsigned __int8 v246 = 0;
  uint64_t v27 = abbrtn_checkIfSubsumedbyOtherToken(a1, (unsigned __int16)v18, (unsigned __int16)v16, 4, 6, __sa);
  if ((v27 & 0x80000000) != 0) {
    return v27;
  }
  if (*(_DWORD *)__sa == 1)
  {
    uint64_t v28 = *(void *)(*(void *)(a1 + 16) + 32);
    int v29 = "BLOCK Creating TN DCT token record for %s %d,%d bSubsumed=%d";
    v214 = __s;
LABEL_17:
    log_OutText(v28, (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)v29, v24, v25, v26, (uint64_t)v214);
    return v27;
  }
  size_t v30 = *(void *)(*(void *)(a9 + 8) + 8 * a7);
  int v31 = LDOTreeNode_ComputeAbsoluteFrom(v30, (_DWORD *)&v245 + 1);
  uint64_t v32 = LH_ERROR_to_VERROR(v31);
  if ((v32 & 0x80000000) != 0) {
    return v32;
  }
  int v33 = LDOTreeNode_ComputeAbsoluteTo(v30, &v245);
  uint64_t v32 = LH_ERROR_to_VERROR(v33);
  if ((v32 & 0x80000000) != 0) {
    return v32;
  }
  log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"TN look up %s", v34, v35, v36, (uint64_t)v233);
  LODWORD(v214) = 0;
  uint64_t v37 = (*(uint64_t (**)(void, void, const char *, const char *, uint64_t *, unsigned __int16 *, unsigned __int8 *, void))(*(void *)(a1 + 64) + 240))(*(void *)(a1 + 48), *(void *)(a1 + 56), "tn", v233, &v248, &v247, &v246, *(unsigned __int8 *)(a1 + 112));
  uint64_t v27 = v37;
  if ((v37 & 0x80000000) != 0 || !v247) {
    return v27;
  }
  unsigned int NextTOKEN_INT_TNPos = v37;
  unsigned int v217 = (unsigned __int16)v16;
  unsigned __int16 v234 = 0;
  unint64_t v38 = 0;
  v223 = &byte_20D5A22AE;
  v224 = __s - 1;
  unsigned int v227 = 1;
  unsigned int v222 = v10;
  __int16 v229 = v16;
  do
  {
    unsigned int v39 = *(char **)(v248 + 8 * v38);
    uint64_t v40 = strchr(v39, v246);
    unint64_t v235 = v38;
    if (!v40)
    {
      v230 = 0;
      unint64_t v46 = 0;
LABEL_31:
      unint64_t v48 = 0;
      unsigned int v50 = 0;
      v231 = 0;
      goto LABEL_34;
    }
    char *v40 = 0;
    v230 = v40 + 1;
    unsigned __int8 v45 = strchr(v40 + 1, v246);
    unint64_t v46 = v45;
    if (!v45) {
      goto LABEL_31;
    }
    *unsigned __int8 v45 = 0;
    unint64_t v46 = v45 + 1;
    unsigned int v47 = strchr(v45 + 1, v246);
    unint64_t v48 = v47;
    if (!v47)
    {
      unsigned int v50 = 0;
LABEL_33:
      v231 = 0;
      goto LABEL_34;
    }
    *unsigned int v47 = 0;
    unint64_t v48 = v47 + 1;
    int v49 = strchr(v47 + 1, v246);
    unsigned int v50 = v49;
    if (!v49) {
      goto LABEL_33;
    }
    *int v49 = 0;
    unsigned int v50 = v49 + 1;
    unsigned int v51 = strchr(v49 + 1, v246);
    if (!v51) {
      goto LABEL_33;
    }
    char *v51 = 0;
    v231 = v51 + 1;
    uint64_t v52 = strchr(v51 + 1, v246);
    if (v52) {
      *uint64_t v52 = 0;
    }
LABEL_34:
    uint64_t v53 = *(void *)(*(void *)(a1 + 16) + 32);
    if (!v39)
    {
      uint64_t v27 = 2310021127;
      log_OutPublic(v53, (uint64_t)"FE_ABBRTN", 32001, 0, v41, v42, v43, v44, v214);
      return v27;
    }
    v237 = v39;
    log_OutText(v53, (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"TN Validating %s", v42, v43, v44, (uint64_t)v39);
    if (v46 && *v46)
    {
      if ((uint64_t v54 = strstr(v46, __s2)) == 0
        || (v55 = v54, size_t v56 = strlen(__s2), v55 != v46) && *(v55 - 1) != 44
        || v55[v56] && v55[v56] != 44)
      {
        uint64_t v57 = *(void *)(*(void *)(a1 + 16) + 32);
        BOOL v58 = "TN Domain validation not OK";
LABEL_151:
        log_OutText(v57, (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)v58, v24, v25, v26, (uint64_t)v214);
        __int16 v59 = v229;
        unint64_t v60 = v235;
        goto LABEL_152;
      }
    }
    if (!v50)
    {
      __int16 v59 = v229;
      unint64_t v60 = v235;
      goto LABEL_51;
    }
    if (!strcmp(v50, "8"))
    {
      uint64_t v57 = *(void *)(*(void *)(a1 + 16) + 32);
      BOOL v58 = "TN expansion only valid within regexps";
      goto LABEL_151;
    }
    if (strcmp(v50, "1") && strcmp(v50, "4") && strcmp(v50, "5") && strcmp(v50, "7")) {
      goto LABEL_77;
    }
    if (v48 && *v48)
    {
      int64_t v63 = strlen(__s);
      if (v63 < 1)
      {
        unsigned __int16 v66 = &__s[v63];
      }
      else
      {
        unsigned int v64 = &v224[v63];
        while (v64 > __s)
        {
          int v65 = *v64--;
          if (v65 >= -64)
          {
            unsigned __int16 v66 = v64 + 1;
            goto LABEL_86;
          }
        }
        unsigned __int16 v66 = __s;
      }
LABEL_86:
      int v72 = (*(uint64_t (**)(void, void, char *))(*(void *)(a1 + 64) + 128))(*(void *)(a1 + 48), *(void *)(a1 + 56), v66);
      if (v66)
      {
        do
        {
          uint64_t v73 = v66;
          if (!v72) {
            break;
          }
          if (v66 > __s)
          {
            __int16 v74 = v66 - 1;
            while (v74 > __s)
            {
              int v75 = *v74--;
              if (v75 >= -64)
              {
                unsigned __int16 v66 = v74 + 1;
                goto LABEL_94;
              }
            }
            unsigned __int16 v66 = __s;
          }
LABEL_94:
          int v72 = (*(uint64_t (**)(void, void, char *))(*(void *)(a1 + 64) + 128))(*(void *)(a1 + 48), *(void *)(a1 + 56), v66);
        }
        while (v66 != v73);
      }
      for (uint64_t i = __s;
            (*(unsigned int (**)(void, void, char *))(*(void *)(a1 + 64) + 128))(*(void *)(a1 + 48), *(void *)(a1 + 56), i);
      while ((*(unsigned int (**)(void, void, const char *))(*(void *)(a1 + 64) + 128))(*(void *)(a1 + 48), *(void *)(a1 + 56), v48))v48 += utf8_determineUTF8CharLength(*(unsigned __int8 *)v48);
      if (i <= v66)
      {
        do
        {
          int v77 = abbrtn_compareUtf8Char((uint64_t)i, (uint64_t)v48);
          unsigned int v78 = utf8_determineUTF8CharLength(*i);
          v48 += utf8_determineUTF8CharLength(*(unsigned __int8 *)v48);
          if (v77) {
            break;
          }
          i += v78;
        }
        while (i <= v66);
        BOOL v70 = v77 == 0;
      }
      else
      {
        BOOL v70 = 1;
      }
      BOOL v61 = v237;
      if (v70 && *v48)
      {
        do
        {
          int v79 = (*(uint64_t (**)(void, void, const char *))(*(void *)(a1 + 64) + 128))(*(void *)(a1 + 48), *(void *)(a1 + 56), v48);
          v48 += utf8_determineUTF8CharLength(*(unsigned __int8 *)v48);
          if (v79) {
            BOOL v80 = *v48 == 0;
          }
          else {
            BOOL v80 = 1;
          }
        }
        while (!v80);
        BOOL v70 = v79 != 0;
      }
LABEL_113:
      if (!v70)
      {
        uint64_t v57 = *(void *)(*(void *)(a1 + 16) + 32);
        BOOL v58 = "TN Case validation not OK";
        goto LABEL_151;
      }
      goto LABEL_114;
    }
    unsigned __int8 v67 = *__s;
    if (*__s)
    {
      size_t v68 = __s;
      do
      {
        BOOL v70 = 0;
        if ((v67 - 97) >= 0x1Au)
        {
          if (v67 != 195
            || (v68[1] - 133 <= 0x37
              ? (BOOL v69 = ((1 << (v68[1] + 123)) & 0x82101780000001) == 0)
              : (BOOL v69 = 1),
                v69))
          {
            BOOL v70 = 1;
          }
        }
        unsigned int v71 = utf8_determineUTF8CharLength(v67);
        if (!v70) {
          break;
        }
        v68 += v71;
        unsigned __int8 v67 = *v68;
      }
      while (*v68);
      BOOL v61 = v237;
      goto LABEL_113;
    }
LABEL_77:
    BOOL v61 = v237;
LABEL_114:
    if (!strcmp(v50, "3") || !strcmp(v50, "5") || !strcmp(v50, "6") || !strcmp(v50, "7"))
    {
      int64_t v81 = strlen(__s);
      __int16 v82 = v81;
      if (v81 < 1)
      {
        unint64_t v85 = &__s[v81];
      }
      else
      {
        int v83 = &v224[v81];
        while (v83 > __s)
        {
          int v84 = *v83--;
          if (v84 >= -64)
          {
            unint64_t v85 = v83 + 1;
            goto LABEL_126;
          }
        }
        unint64_t v85 = __s;
      }
LABEL_126:
      unsigned __int16 v86 = v82 - strlen(v85);
      unsigned int NextUtf8Offset = v86;
      uint64_t v88 = v86;
      int v89 = (*(uint64_t (**)(void, void, char *))(*(void *)(a1 + 64) + 128))(*(void *)(a1 + 48), *(void *)(a1 + 56), &__s[v86]);
      if (NextUtf8Offset && v89)
      {
        do
        {
          unsigned __int16 v90 = utf8_GetPreviousUtf8Offset((uint64_t)__s, NextUtf8Offset);
          uint64_t v88 = v90;
          unsigned int NextUtf8Offset = v90;
          int v91 = (*(uint64_t (**)(void, void, char *))(*(void *)(a1 + 64) + 128))(*(void *)(a1 + 48), *(void *)(a1 + 56), &__s[v90]);
        }
        while (v88 && v91);
      }
      int64_t v92 = strlen(__s);
      int64_t v93 = v92;
      if (v92 < 1)
      {
        unint64_t v96 = &__s[v92];
      }
      else
      {
        __int16 v94 = &v224[v92];
        while (v94 > __s)
        {
          int v95 = *v94--;
          if (v95 >= -64)
          {
            unint64_t v96 = v94 + 1;
            goto LABEL_137;
          }
        }
        unint64_t v96 = __s;
      }
LABEL_137:
      if (v93 - strlen(v96) != v88) {
        unsigned int NextUtf8Offset = (unsigned __int16)utf8_GetNextUtf8Offset(__s, NextUtf8Offset);
      }
      BOOL v61 = v237;
      if (v48 && *v48)
      {
        int64_t v97 = strlen(v48);
        if (v97 < 1)
        {
          v48 += v97;
        }
        else
        {
          int v98 = &v48[v97 - 1];
          while (v98 > v48)
          {
            int v99 = *v98--;
            if (v99 >= -64)
            {
              unint64_t v48 = v98 + 1;
              break;
            }
          }
        }
        if (abbrtn_compareUtf8Char((uint64_t)&__s[NextUtf8Offset], (uint64_t)v48))
        {
          uint64_t v57 = *(void *)(*(void *)(a1 + 16) + 32);
          BOOL v58 = "Punctuation validation not OK";
          goto LABEL_151;
        }
      }
      else if (__s[NextUtf8Offset] != 46)
      {
        uint64_t v57 = *(void *)(*(void *)(a1 + 16) + 32);
        BOOL v58 = "TN Punctuation validation not OK";
        goto LABEL_151;
      }
    }
    if (strcmp(v50, "2") && strcmp(v50, "4") && strcmp(v50, "6") && strcmp(v50, "7"))
    {
      __int16 v59 = v229;
      unint64_t v60 = v235;
      goto LABEL_52;
    }
    __s1 = 0;
    LOWORD(v241) = 0;
    int64_t v100 = strlen(a5);
    __int16 v101 = v100;
    if (v100 < 1)
    {
      uint64_t v104 = v10;
      v105 = &a5[v100];
    }
    else
    {
      v102 = &a5[v100 - 1];
      while (v102 > a5)
      {
        int v103 = *v102--;
        if (v103 >= -64)
        {
          uint64_t v104 = v10;
          v105 = v102 + 1;
          goto LABEL_167;
        }
      }
      uint64_t v104 = v10;
      v105 = a5;
    }
LABEL_167:
    __int16 v106 = strlen(v105);
    v243 = 0;
    BYTE4(v238) = 0;
    LOWORD(v240) = 0;
    LOWORD(v239) = 0;
    unsigned int v242 = 0;
    strcpy(__sa, "disambiguate_abbreviations");
    unsigned __int16 v220 = strlen(__sa);
    unsigned __int16 v107 = v222;
    if (!(_WORD)v222) {
      goto LABEL_188;
    }
    int v108 = 0;
    v109 = &a5[(unsigned __int16)v222];
    do
    {
      unsigned int v110 = a5[--v107];
      BOOL v111 = v110 > 0x20 || ((1 << v110) & 0x100002600) == 0;
      if (!v111 || v110 == 95)
      {
        unsigned int v112 = *(unsigned __int8 *)v109;
        int v113 = v112 == 95 ? v108 : v108 + 1;
        BOOL v148 = v112 > 0x20;
        uint64_t v114 = (1 << v112) & 0x100002600;
        if (v148 || v114 == 0) {
          int v108 = v113;
        }
      }
      if (v108 > 3u) {
        break;
      }
      --v109;
    }
    while (v107);
    if (v107) {
      unsigned int v226 = v107 + utf8_determineUTF8CharLength(a5[v107]);
    }
    else {
LABEL_188:
    }
      unsigned int v226 = 0;
    unsigned int v116 = (unsigned __int16)(v101 - v106);
    if (v116 >= (unsigned __int16)v222)
    {
      int v163 = 0;
      LOBYTE(v164) = a5[(unsigned __int16)v222];
      unsigned int v118 = v222;
      do
      {
        v118 += utf8_determineUTF8CharLength(v164);
        unsigned int v164 = a5[(unsigned __int16)v118];
        BOOL v165 = v164 > 0x20 || ((1 << v164) & 0x100002600) == 0;
        if (!v165 || v164 == 95)
        {
          unsigned int v166 = a5[(unsigned __int16)v118 - 1];
          int v167 = v166 == 95 ? v163 : v163 + 1;
          BOOL v148 = v166 > 0x20;
          uint64_t v168 = (1 << v166) & 0x100002600;
          if (v148 || v168 == 0) {
            int v163 = v167;
          }
        }
        int v117 = (unsigned __int16)v118;
      }
      while (v163 <= 3u && v116 >= (unsigned __int16)v118);
    }
    else
    {
      int v117 = (unsigned __int16)v222;
      LOWORD(v118) = v222;
    }
    int v119 = v117 - (unsigned __int16)v226;
    int v120 = strlen(v237);
    int v121 = v119 + 25;
    v122 = (unsigned char *)heap_Realloc(*(uint64_t **)(*(void *)(a1 + 16) + 8), *(void *)(a1 + 96), (v121 + v120));
    if (!v122
      || (*(void *)(a1 + 96) = v122,
          unsigned char *v122 = 0,
          int v127 = strlen(v237),
          (v128 = (unsigned char *)heap_Realloc(*(uint64_t **)(*(void *)(a1 + 16) + 8), *(void *)(a1 + 104), (v121 + v127))) == 0))
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 32000, 0, v123, v124, v125, v126, v214);
      return -1984946166;
    }
    *(void *)(a1 + 104) = v128;
    unsigned char *v128 = 0;
    __int16 v129 = strlen(__s);
    v130 = (char *)&a5[(unsigned __int16)v222];
    LOWORD(v131) = v222;
    if ((*(unsigned int (**)(void, void, char *))(*(void *)(a1 + 64) + 128))(*(void *)(a1 + 48), *(void *)(a1 + 56), v130))
    {
      unsigned int v131 = v222;
      do
      {
        v131 += utf8_determineUTF8CharLength(*v130);
        v130 = (char *)&a5[(unsigned __int16)v131];
      }
      while ((*(unsigned int (**)(void, void, char *))(*(void *)(a1 + 64) + 128))(*(void *)(a1 + 48), *(void *)(a1 + 56), v130));
    }
    unsigned __int16 v132 = utf8_GetPreviousUtf8Offset((uint64_t)a5, (unsigned __int16)(v222 + v129));
    unsigned int v133 = v132;
    v134 = (unsigned __int8 *)&a5[v132];
    int v135 = (*(uint64_t (**)(void, void, unsigned __int8 *))(*(void *)(a1 + 64) + 128))(*(void *)(a1 + 48), *(void *)(a1 + 56), v134);
    if (v132 && v135)
    {
      do
      {
        unsigned __int16 v132 = utf8_GetPreviousUtf8Offset((uint64_t)a5, v133);
        unsigned int v133 = v132;
        v134 = (unsigned __int8 *)&a5[v132];
        int v136 = (*(uint64_t (**)(void, void, unsigned __int8 *))(*(void *)(a1 + 64) + 128))(*(void *)(a1 + 48), *(void *)(a1 + 56), v134);
      }
      while (v132 && v136);
    }
    __int16 v137 = utf8_determineUTF8CharLength(*v134);
    unsigned int NextTOKEN_INT_TNPos = getNextTOKEN_INT_TNPos(a1, &v240, &v239, (uint64_t *)&v243, (unsigned __int16)v226, (unsigned __int16)v118, &v242);
    if ((NextTOKEN_INT_TNPos & 0x80000000) != 0) {
      return NextTOKEN_INT_TNPos;
    }
    if ((unsigned __int16)v226 >= (unsigned __int16)v118)
    {
      uint64_t v10 = v104;
      __int16 v59 = v229;
      unint64_t v60 = v235;
LABEL_277:
      log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"%s L1: %s", v138, v139, v140, (uint64_t)__sa);
      unsigned __int16 v170 = strlen(*(const char **)(a1 + 96));
      unsigned int v171 = (*(uint64_t (**)(void, void, void, void, void))(*(void *)(a1 + 88) + 120))(*(void *)(a1 + 72), *(void *)(a1 + 80), 0, *(void *)(a1 + 96), v170);
      if ((v171 & 0x80000000) != 0) {
        return v171;
      }
      log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"%s L2: %s", v172, v173, v174, (uint64_t)__sa);
      unsigned __int16 v175 = strlen(*(const char **)(a1 + 104));
      unsigned int v171 = (*(uint64_t (**)(void, void, uint64_t, void, void))(*(void *)(a1 + 88) + 120))(*(void *)(a1 + 72), *(void *)(a1 + 80), 1, *(void *)(a1 + 104), v175);
      if ((v171 & 0x80000000) != 0) {
        return v171;
      }
      if (strcmp(__s2, "normal") && strlen(__s2) + v220 + 2 <= 0x7F)
      {
        __strcat_chk();
        __strcat_chk();
      }
      if (((*(uint64_t (**)(void, void, char *))(*(void *)(a1 + 88) + 80))(*(void *)(a1 + 72), *(void *)(a1 + 80), __sa) & 0x80000000) != 0&& (__sa[v220] = 0, unsigned int v171 = (*(uint64_t (**)(void, void, char *))(*(void *)(a1 + 88) + 80))(*(void *)(a1 + 72), *(void *)(a1 + 80), __sa), (v171 & 0x80000000) != 0))
      {
        return v171;
      }
      else
      {
        unsigned int NextTOKEN_INT_TNPos = (*(uint64_t (**)(void, void, void, char **, unsigned int *))(*(void *)(a1 + 88) + 128))(*(void *)(a1 + 72), *(void *)(a1 + 80), 0, &__s1, &v241);
        if ((NextTOKEN_INT_TNPos & 0x80000000) == 0)
        {
          __s1[(unsigned __int16)v241] = 0;
          log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"%s O1: %s", v176, v177, v178, (uint64_t)__sa);
          v179 = strstr(__s1, "§");
          if (v179)
          {
            v180 = v179;
            while (1)
            {
              int v181 = utf8_determineUTF8CharLength(*v180);
              v182 = strstr(&v180[v181], "§");
              if (!v182) {
                break;
              }
              v183 = v182;
              int v184 = v180[utf8_determineUTF8CharLength(*v180)];
              v180 = v183;
              if (v184 != 32) {
                goto LABEL_298;
              }
            }
          }
LABEL_51:
          BOOL v61 = v237;
          if (!v231 || !*v231) {
            goto LABEL_82;
          }
LABEL_52:
          unsigned int v62 = (unsigned __int16)atoi(v231);
          if (v62 < v227)
          {
            log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"Lower priority than previous valid normalizations", v24, v25, v26, (uint64_t)v214);
            goto LABEL_152;
          }
          if (v62 > v227)
          {
            if (v234) {
              log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"Higher priority than previous valid normalizations", v24, v25, v26, (uint64_t)v214);
            }
            unsigned __int16 v234 = 0;
          }
          else
          {
LABEL_82:
            unsigned int v62 = v227;
          }
          ++v234;
          v223 = v61;
          unsigned int v227 = v62;
          goto LABEL_152;
        }
      }
      return NextTOKEN_INT_TNPos;
    }
    unsigned __int16 v141 = v137 + v132;
    unsigned int v219 = v141;
    unsigned __int16 v142 = v226;
    uint64_t v10 = v104;
    v143 = v230;
    uint64_t v218 = v104;
    unsigned __int16 v221 = v141;
    while (1)
    {
      uint64_t v144 = (unsigned __int16)v240;
      unsigned int v145 = (unsigned __int16)v239;
      if (v242 == 1
        && (unsigned __int16)v240 == (unsigned __int16)v226
        && (unsigned __int16)v239 == (unsigned __int16)v118)
      {
        break;
      }
      if (v242 != 1)
      {
        if (v142 > (unsigned __int16)v131 || v242) {
          goto LABEL_294;
        }
LABEL_225:
        addToLayer(a1, (uint64_t)a5, v142, (unsigned __int16)v131, 0, 0, (unsigned __int8 *)&v238 + 4);
        if (BYTE4(v238) > 0x13u) {
          goto LABEL_297;
        }
        addToLayer(a1, (uint64_t)a5, (unsigned __int16)v131, v221, v237, v143, (unsigned __int8 *)&v238 + 4);
        if (BYTE4(v238) > 0x13u) {
          goto LABEL_297;
        }
        unsigned __int16 v142 = v221;
        if (v144 == (unsigned __int16)v131)
        {
          unsigned __int16 v142 = v221;
          unsigned int NextTOKEN_INT_TNPos = getNextTOKEN_INT_TNPos(a1, &v240, &v239, (uint64_t *)&v243, v221, (unsigned __int16)v118, &v242);
          if ((NextTOKEN_INT_TNPos & 0x80000000) != 0) {
            return NextTOKEN_INT_TNPos;
          }
        }
        goto LABEL_255;
      }
      if ((unsigned __int16)v240 >= (unsigned __int16)v131
        && v142 <= (unsigned __int16)v131
        && v142 <= (unsigned __int16)v240)
      {
        goto LABEL_225;
      }
      BOOL v146 = v142 > (unsigned __int16)v240;
      if (v219 > v142) {
        BOOL v146 = 1;
      }
      BOOL v148 = v142 <= (unsigned __int16)v240
          && v142 < (unsigned __int16)v131
          && (unsigned __int16)v131 > (unsigned __int16)v240;
      if (!v148 && v146)
      {
LABEL_294:
        addToLayer(a1, (uint64_t)a5, v142, (unsigned __int16)v118, 0, 0, (unsigned __int8 *)&v238 + 4);
        __int16 v59 = v229;
        unint64_t v60 = v235;
        if (BYTE4(v238) <= 0x13u) {
          goto LABEL_277;
        }
        goto LABEL_298;
      }
      addToLayer(a1, (uint64_t)a5, v142, (unsigned __int16)v240, 0, 0, (unsigned __int8 *)&v238 + 4);
      unsigned int v149 = BYTE4(v238);
      if (BYTE4(v238) > 0x13u) {
        goto LABEL_297;
      }
      if (v145 > (unsigned __int16)v118)
      {
        LOWORD(v239) = v118;
        unsigned __int16 v228 = v118;
LABEL_231:
        LOWORD(v145) = 0;
        int v150 = 0;
        do
        {
          if (!a5[(unsigned __int16)v150]) {
            break;
          }
          v150 += utf8_determineUTF8CharLength(a5[(unsigned __int16)v150]);
          LOWORD(v145) = v145 + 1;
        }
        while ((unsigned __int16)v150 < v228);
        goto LABEL_236;
      }
      unsigned __int16 v228 = v145;
      if (v145) {
        goto LABEL_231;
      }
      unsigned __int16 v228 = 0;
LABEL_236:
      unsigned __int16 v151 = 0;
      if (v144)
      {
        int v152 = 0;
        do
        {
          if (!a5[(unsigned __int16)v152]) {
            break;
          }
          v152 += utf8_determineUTF8CharLength(a5[(unsigned __int16)v152]);
          ++v151;
        }
        while (v144 > (unsigned __int16)v152);
      }
      strncat(*(char **)(a1 + 96), &a5[v144], v228 - v144);
      size_t v153 = strlen(v243);
      strncat(*(char **)(a1 + 104), v243 + 1, v153 - 2);
      size_t v154 = strlen(v243);
      int v155 = (unsigned __int16)v145 - v151;
      if ((v154 << 16) - 0x20000 <= v155 << 16)
      {
        int v158 = v155 + 2;
        if (v154 != v158)
        {
          int v159 = 0;
          uint64_t v160 = v158;
          do
          {
            *(_WORD *)(*(void *)(a1 + 104) + strlen(*(const char **)(a1 + 104))) = 126;
            ++v159;
          }
          while (v160 - strlen(v243) > (unsigned __int16)v159);
        }
      }
      else
      {
        unint64_t v156 = v151 - (unint64_t)(unsigned __int16)v145 - 2;
        if (v156 + v154)
        {
          unint64_t v161 = 1;
          do
          {
            *(_WORD *)(*(void *)(a1 + 96) + strlen(*(const char **)(a1 + 96))) = 126;
            unsigned int v157 = v149 + 1;
            BOOL v148 = v156 + strlen(v243) > v161++;
          }
          while (v148 && v149++ < 0x13);
        }
        else
        {
          unsigned int v157 = v149;
        }
        BYTE4(v238) = v157;
        if (v157 > 0x13)
        {
          uint64_t v10 = v218;
LABEL_297:
          __int16 v59 = v229;
          unint64_t v60 = v235;
          goto LABEL_298;
        }
      }
      unsigned __int16 v142 = v228;
      uint64_t v10 = v218;
      unsigned int NextTOKEN_INT_TNPos = getNextTOKEN_INT_TNPos(a1, &v240, &v239, (uint64_t *)&v243, v228, (unsigned __int16)v118, &v242);
      v143 = v230;
      if ((NextTOKEN_INT_TNPos & 0x80000000) != 0) {
        return NextTOKEN_INT_TNPos;
      }
LABEL_255:
      if (v142 >= (unsigned __int16)v118) {
        goto LABEL_292;
      }
    }
    addToLayer(a1, (uint64_t)a5, (unsigned __int16)v226, (unsigned __int16)v118, v237, v143, (unsigned __int8 *)&v238 + 4);
    unsigned int v242 = 0;
    unsigned int v222 = v226;
LABEL_292:
    __int16 v59 = v229;
    unint64_t v60 = v235;
    if (BYTE4(v238) <= 0x13u) {
      goto LABEL_277;
    }
LABEL_298:
    log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"Context validation not OK", v138, v139, v140, (uint64_t)v214);
LABEL_152:
    unint64_t v38 = v60 + 1;
  }
  while (v38 < v247 && v234 < 2u);
  uint64_t v27 = NextTOKEN_INT_TNPos;
  if (!v234) {
    return v27;
  }
  if (v234 != 1)
  {
    uint64_t v28 = *(void *)(*(void *)(a1 + 16) + 32);
    int v29 = "Multiple valid lookups => no normalization";
    goto LABEL_17;
  }
  _WORD *v232 = v59;
  unsigned int v242 = v217;
  LODWORD(v243) = 0;
  unsigned int v241 = v217;
  if (v233 && strcmp(v233, __s))
  {
    v185 = (char *)&a5[v10];
    for (int j = (*(uint64_t (**)(void, void, char *))(*(void *)(a1 + 64) + 128))(*(void *)(a1 + 48), *(void *)(a1 + 56), v185);
          j;
          int j = (*(uint64_t (**)(void, void, char *))(*(void *)(a1 + 64) + 128))(*(void *)(a1 + 48), *(void *)(a1 + 56), v185))
    {
      LODWORD(v10) = v10 + utf8_determineUTF8CharLength(*v185);
      v185 = (char *)&a5[(unsigned __int16)v10];
    }
    uint64_t v187 = (uint64_t)a5;
    for (unsigned int k = v217; ; unsigned int k = v189)
    {
      unsigned int v189 = utf8_GetPreviousUtf8Offset(v187, k);
      if (!(*(unsigned int (**)(void, void, const char *))(*(void *)(a1 + 64) + 128))(*(void *)(a1 + 48), *(void *)(a1 + 56), &a5[v189])|| v189 == 0)
      {
        break;
      }
      uint64_t v187 = (uint64_t)a5;
    }
    unsigned int v242 = v189 + utf8_determineUTF8CharLength(a5[v189]);
  }
  int v191 = LDO_CountLeafNodesOnRange(*(void *)(a1 + 192), &v242, &v241, &v243, &v242);
  uint64_t v32 = LH_ERROR_to_VERROR(v191);
  if ((v32 & 0x80000000) != 0) {
    return v32;
  }
  unsigned __int16 v195 = v243 ? v242 : v59;
  unsigned int v196 = v195;
  log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"Creating TN DCT token record for %s %d,%d %s", v192, v193, v194, (uint64_t)__s);
  *(void *)__sa = 0;
  __s1 = 0;
  unsigned int v239 = v196;
  unsigned int v240 = (unsigned __int16)v10;
  uint64_t v238 = 0;
  LODWORD(v243) = 0;
  int v197 = LDO_CountLeafNodesOnRange(*(void *)(a1 + 192), &v240, &v239, &v243, 0);
  uint64_t v32 = LH_ERROR_to_VERROR(v197);
  if ((v32 & 0x80000000) != 0) {
    return v32;
  }
  if (v239 <= v240 || v243)
  {
    uint64_t v207 = *(void *)(a1 + 192);
    v208 = &v240;
    v209 = &v239;
LABEL_332:
    int v210 = LDO_AddLabelOnSubstring(v207, "TOKEN", "TOKEN", v208, v209, __sa);
    uint64_t v27 = LH_ERROR_to_VERROR(v210);
    if ((v27 & 0x80000000) != 0) {
      return v27;
    }
    goto LABEL_335;
  }
  log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"No node in the given range => attempting to find a containing node", v198, v199, v200, v215);
  int v201 = LDO_ComputeLeafNodeContainingRange(*(void *)(a1 + 192), &v240, &v239, (size_t *)&__s1);
  uint64_t v27 = LH_ERROR_to_VERROR(v201);
  if ((v27 & 0x80000000) != 0) {
    return v27;
  }
  if (!__s1)
  {
    log_OutText(*(void *)(*(void *)(a1 + 16) + 32), (uint64_t)"FE_ABBRTN", 5, 0, (uint64_t)"No containing node found => no label created", v202, v203, v204, v216);
LABEL_335:
    if (*(void *)__sa)
    {
      LDOObject_SetU32Attribute(*(uint64_t *)__sa, "_TTYPE", 4);
      uint64_t v32 = LH_ERROR_to_VERROR(v211);
      if ((v32 & 0x80000000) == 0)
      {
        int v212 = LDOObject_SetStringAttribute(*(uint64_t *)__sa, "NORM", v223);
        return LH_ERROR_to_VERROR(v212);
      }
      return v32;
    }
    return v27;
  }
  int v205 = LDOTreeNode_ComputeAbsoluteFrom((uint64_t)__s1, (_DWORD *)&v238 + 1);
  uint64_t v32 = LH_ERROR_to_VERROR(v205);
  if ((v32 & 0x80000000) == 0)
  {
    int v206 = LDOTreeNode_ComputeAbsoluteTo((size_t)__s1, &v238);
    uint64_t v32 = LH_ERROR_to_VERROR(v206);
    if ((v32 & 0x80000000) == 0)
    {
      uint64_t v207 = *(void *)(a1 + 192);
      v208 = (unsigned int *)&v238 + 1;
      v209 = (unsigned int *)&v238;
      goto LABEL_332;
    }
  }
  return v32;
}

uint64_t abbrtn_sanitizeTokenDCTAndIntTN(uint64_t a1)
{
  uint64_t v2 = 0;
  int v27 = 0;
  uint64_t v3 = *(void *)(*(void *)(a1 + 192) + 32);
  uint64_t v4 = *(uint64_t **)(v3 + 24);
  if ((unint64_t)v4 >= *(void *)(v3 + 32))
  {
LABEL_29:
    uint64_t v15 = *(void *)(*(void *)(a1 + 192) + 32);
    int v16 = *(uint64_t **)(v15 + 24);
    if ((unint64_t)v16 >= *(void *)(v15 + 32))
    {
      unint64_t v6 = 0;
    }
    else
    {
      int v17 = 0;
      unint64_t v6 = 0;
      unsigned int v18 = 0;
      do
      {
        uint64_t v19 = *v16;
        uint64_t v28 = 0;
        uint64_t v29 = 0;
        uint64_t v20 = abbrtn_filterLabelByTokenType(v19, 6, (_DWORD *)&v28 + 1, (_DWORD *)&v29 + 1, &v29);
        uint64_t v2 = v20;
        if ((v20 & 0x80000000) != 0 || !HIDWORD(v28))
        {
          if ((v20 & 0x80000000) != 0) {
            goto LABEL_56;
          }
        }
        else
        {
          uint64_t v2 = abbrtn_checkIfBisectedbyTokenType(a1, HIDWORD(v29), v29, 4, &v28);
          if ((v2 & 0x80000000) != 0) {
            goto LABEL_56;
          }
          if (v28 == 1)
          {
            unint64_t v21 = (unint64_t)v17 - v6;
            unsigned int v22 = (((unint64_t)v17 - v6) >> 3) + 1;
            if (v22 > v18)
            {
              unsigned int v23 = 2 * v18;
              if (2 * v18 >= v18 + 1000000) {
                unsigned int v23 = v18 + 1000000;
              }
              if (v23 > v22) {
                unsigned int v22 = v23;
              }
              if (v22 <= 8) {
                unsigned int v18 = 8;
              }
              else {
                unsigned int v18 = v22;
              }
              unint64_t v6 = OOCAllocator_Realloc(a1 + 152, v6, 8 * v18, &v27);
              int v12 = v27;
              if (v27) {
                goto LABEL_55;
              }
              int v17 = (uint64_t *)(v6 + (v21 & 0x7FFFFFFF8));
            }
            *v17++ = v19;
          }
        }
        ++v16;
      }
      while ((unint64_t)v16 < *(void *)(*(void *)(*(void *)(a1 + 192) + 32) + 32));
      if (v6 < (unint64_t)v17)
      {
        uint64_t v24 = (uint64_t *)v6;
        do
        {
          int v25 = LDO_RemoveLabel(*(void *)(a1 + 192), *v24);
          uint64_t v2 = LH_ERROR_to_VERROR(v25);
          if ((v2 & 0x80000000) != 0) {
            goto LABEL_56;
          }
          ++v24;
        }
        while (v24 < v17);
      }
    }
    int v12 = v27;
    if (v27) {
LABEL_55:
    }
      uint64_t v2 = LH_ERROR_to_VERROR(v12);
  }
  else
  {
    unsigned int v5 = 0;
    unint64_t v6 = 0;
    unsigned int v7 = 0;
    while (1)
    {
      uint64_t v8 = *v4;
      HIDWORD(v29) = 0;
      uint64_t v2 = abbrtn_checkIfLabelSpanIsStrictlyContainedInOtherLabelSpan(a1, v8, 4, 6, (_DWORD *)&v29 + 1);
      if ((v2 & 0x80000000) != 0) {
        break;
      }
      if (HIDWORD(v29) == 1) {
        goto LABEL_11;
      }
      uint64_t v2 = abbrtn_checkIfLabelSpanIsStrictlyContainedInOtherLabelSpan(a1, v8, 4, 4, (_DWORD *)&v29 + 1);
      if ((v2 & 0x80000000) != 0) {
        break;
      }
      if (HIDWORD(v29) == 1) {
        goto LABEL_11;
      }
      uint64_t v2 = abbrtn_checkIfLabelSpanIsStrictlyContainedInOtherLabelSpan(a1, v8, 6, 4, (_DWORD *)&v29 + 1);
      if ((v2 & 0x80000000) != 0) {
        break;
      }
      if (HIDWORD(v29) == 1) {
        goto LABEL_11;
      }
      uint64_t v2 = abbrtn_checkIfLabelSpanIsStrictlyContainedInOtherLabelSpan(a1, v8, 6, 6, (_DWORD *)&v29 + 1);
      if ((v2 & 0x80000000) != 0) {
        break;
      }
      if (HIDWORD(v29) == 1)
      {
LABEL_11:
        unint64_t v9 = (unint64_t)v5 - v6;
        unsigned int v10 = (((unint64_t)v5 - v6) >> 3) + 1;
        if (v10 > v7)
        {
          unsigned int v11 = 2 * v7;
          if (2 * v7 >= v7 + 1000000) {
            unsigned int v11 = v7 + 1000000;
          }
          if (v11 > v10) {
            unsigned int v10 = v11;
          }
          if (v10 <= 8) {
            unsigned int v7 = 8;
          }
          else {
            unsigned int v7 = v10;
          }
          unint64_t v6 = OOCAllocator_Realloc(a1 + 152, v6, 8 * v7, &v27);
          int v12 = v27;
          if (v27) {
            goto LABEL_55;
          }
          unsigned int v5 = (uint64_t *)(v6 + (v9 & 0x7FFFFFFF8));
        }
        *v5++ = v8;
      }
      if ((unint64_t)++v4 >= *(void *)(*(void *)(*(void *)(a1 + 192) + 32) + 32))
      {
        if (v6 >= (unint64_t)v5)
        {
LABEL_27:
          if (v6) {
            OOCAllocator_Free(a1 + 152, v6);
          }
          goto LABEL_29;
        }
        unint64_t v13 = (uint64_t *)v6;
        while (1)
        {
          int v14 = LDO_RemoveLabel(*(void *)(a1 + 192), *v13);
          uint64_t v2 = LH_ERROR_to_VERROR(v14);
          if ((v2 & 0x80000000) != 0) {
            goto LABEL_56;
          }
          if (++v13 >= v5) {
            goto LABEL_27;
          }
        }
      }
    }
  }
LABEL_56:
  if (v6) {
    OOCAllocator_Free(a1 + 152, v6);
  }
  return v2;
}

BOOL compare(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 < *a2;
}

uint64_t abbrtn_compareUtf8Char(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  utf8_getUTF8Char(a1, 0, __s1);
  utf8_getUTF8Char(a2, 0, __s2);
  return strcmp(__s1, __s2);
}

uint64_t getNextTOKEN_INT_TNPos(uint64_t a1, _WORD *a2, _WORD *a3, uint64_t *a4, unsigned int a5, unsigned int a6, _DWORD *a7)
{
  __n128 v25 = 0uLL;
  unint64_t v26 = 0;
  LDO_GetLabels(*(void *)(a1 + 192), &v25);
  uint64_t v11 = 0;
  __s1 = 0;
  *a7 = 0;
  int v12 = (uint64_t *)v25.n128_u64[1];
  if (v25.n128_u64[1] < v26)
  {
    int v24 = 0;
    while (1)
    {
      uint64_t v22 = 0;
      unsigned __int16 AbsoluteFrom = LDOLabel_GetAbsoluteFrom(*v12);
      unsigned __int16 AbsoluteTo = LDOLabel_GetAbsoluteTo(*v12);
      int Category = LDOObject_GetCategory(*v12, (uint64_t *)&__s1);
      uint64_t v11 = LH_ERROR_to_VERROR(Category);
      if ((v11 & 0x80000000) != 0) {
        return v11;
      }
      if (!strcmp(__s1, "TOKEN")) {
        break;
      }
LABEL_5:
      if ((unint64_t)++v12 >= v26) {
        return v11;
      }
    }
    if (AbsoluteFrom >= a5)
    {
      if (AbsoluteTo > a6) {
        goto LABEL_12;
      }
    }
    else if (AbsoluteTo <= a5 || AbsoluteTo >= a6)
    {
LABEL_12:
      if (AbsoluteFrom <= a5 || AbsoluteFrom >= a6 || AbsoluteTo <= a6) {
        goto LABEL_5;
      }
    }
    int U32Attribute = LDOObject_GetU32Attribute((uint64_t *)*v12, "_TTYPE", (_DWORD *)&v22 + 1, &v24);
    uint64_t v11 = LH_ERROR_to_VERROR(U32Attribute);
    if ((v11 & 0x80000000) != 0) {
      return v11;
    }
    if (v24 == 6)
    {
      int StringAttribute = LDOObject_GetStringAttribute((uint64_t *)*v12, "TNTAG", &v22, a4);
      uint64_t v11 = LH_ERROR_to_VERROR(StringAttribute);
      if ((v11 & 0x80000000) != 0) {
        return v11;
      }
      if (v22 == 1)
      {
        if (AbsoluteFrom >= a5 || AbsoluteTo <= a5 || (__int16 v18 = a5, AbsoluteTo >= a6)) {
          __int16 v18 = AbsoluteFrom;
        }
        *a2 = v18;
        if (AbsoluteFrom <= a5 || AbsoluteFrom >= a6 || AbsoluteTo <= a6) {
          LOWORD(a6) = AbsoluteTo;
        }
        *a3 = a6;
        *a7 = 1;
        return v11;
      }
    }
    goto LABEL_5;
  }
  return v11;
}

size_t addToLayer(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, const char *a5, const char *a6, unsigned __int8 *a7)
{
  if (a5)
  {
    size_t v11 = *(void *)(a1 + 96) + strlen(*(const char **)(a1 + 96));
    *(_WORD *)size_t v11 = -22590;
    *(unsigned char *)(v11 + 2) = 0;
    strcat(*(char **)(a1 + 96), a5);
    int v12 = strlen(a6);
    unsigned __int16 v13 = Utf8_LengthInUtf8chars((unint64_t)a6, v12);
    int v14 = strlen(a5);
    unsigned __int16 v15 = Utf8_LengthInUtf8chars((unint64_t)a5, v14);
    if (v13 > v15)
    {
      int v16 = v13 - v15;
      if (v16 >= 1)
      {
        int v17 = 0;
        unsigned __int8 v18 = *a7;
        do
        {
          if (v18 > 0x13u) {
            break;
          }
          *(_WORD *)(*(void *)(a1 + 96) + strlen(*(const char **)(a1 + 96))) = 126;
          ++v17;
          unsigned __int8 v18 = *a7 + 1;
          *a7 = v18;
        }
        while (v16 > (unsigned __int16)v17);
      }
    }
    size_t v19 = *(void *)(a1 + 96) + strlen(*(const char **)(a1 + 96));
    *(_WORD *)size_t v19 = -22590;
    *(unsigned char *)(v19 + 2) = 0;
    size_t v20 = *(void *)(a1 + 104) + strlen(*(const char **)(a1 + 104));
    *(_WORD *)size_t v20 = -22590;
    *(unsigned char *)(v20 + 2) = 0;
    strcat(*(char **)(a1 + 104), a6);
    int v21 = strlen(a5);
    unsigned __int16 v22 = Utf8_LengthInUtf8chars((unint64_t)a5, v21);
    int v23 = strlen(a6);
    unsigned __int16 v24 = Utf8_LengthInUtf8chars((unint64_t)a6, v23);
    if (v22 > v24)
    {
      int v25 = v22 - v24;
      if (v25 >= 1)
      {
        int v26 = 0;
        do
        {
          *(_WORD *)(*(void *)(a1 + 104) + strlen(*(const char **)(a1 + 104))) = 126;
          ++v26;
        }
        while (v25 > (unsigned __int16)v26);
      }
    }
    int v27 = *(const char **)(a1 + 104);
    size_t result = strlen(v27);
    uint64_t v29 = (char *)&v27[result];
    *(_WORD *)uint64_t v29 = -22590;
    void v29[2] = 0;
  }
  else
  {
    size_t result = (size_t)strncat(*(char **)(a1 + 96), (const char *)(a2 + a3), a4 - (unint64_t)a3);
    int v33 = 0;
    if (a3)
    {
      unsigned __int16 v34 = 0;
      do
      {
        size_t result = *(unsigned __int8 *)(a2 + v34);
        if (!*(unsigned char *)(a2 + v34)) {
          break;
        }
        size_t result = utf8_determineUTF8CharLength(result);
        v34 += result;
        ++v33;
      }
      while (a3 > v34);
    }
    unsigned __int16 v35 = 0;
    if (a4)
    {
      unsigned __int16 v36 = 0;
      do
      {
        size_t result = *(unsigned __int8 *)(a2 + v36);
        if (!*(unsigned char *)(a2 + v36)) {
          break;
        }
        size_t result = utf8_determineUTF8CharLength(result);
        v36 += result;
        ++v35;
      }
      while (a4 > v36);
    }
    for (; (unsigned __int16)v33 < v35; ++v33)
    {
      size_t result = strlen(*(const char **)(a1 + 104));
      *(_WORD *)(*(void *)(a1 + 104) + result) = 32;
    }
  }
  return result;
}

uint64_t abbrtn_checkIfLabelSpanIsStrictlyContainedInOtherLabelSpan(uint64_t a1, uint64_t a2, int a3, int a4, _DWORD *a5)
{
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  unsigned int v14 = 0;
  *a5 = 0;
  uint64_t result = abbrtn_filterLabelByTokenType(a2, a3, (_DWORD *)&v16 + 1, &v16, (_DWORD *)&v15 + 1);
  if ((result & 0x80000000) == 0)
  {
    if (HIDWORD(v16))
    {
      uint64_t v9 = *(void *)(*(void *)(a1 + 192) + 32);
      unsigned int v10 = *(uint64_t **)(v9 + 24);
      if ((unint64_t)v10 < *(void *)(v9 + 32))
      {
        unsigned int v12 = HIDWORD(v15);
        unsigned int v11 = v16;
        do
        {
          uint64_t result = abbrtn_filterLabelByTokenType(*v10, a4, (_DWORD *)&v16 + 1, &v15, &v14);
          if ((result & 0x80000000) != 0) {
            break;
          }
          if (HIDWORD(v16) == 1)
          {
            BOOL v13 = v11 < v15 || v12 >= v14;
            if (!v13 || v11 > v15 && v12 <= v14)
            {
              *a5 = 1;
              return result;
            }
          }
          ++v10;
        }
        while ((unint64_t)v10 < *(void *)(*(void *)(*(void *)(a1 + 192) + 32) + 32));
      }
    }
  }
  return result;
}

uint64_t abbrtn_filterLabelByTokenType(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t v13 = 0;
  *a3 = 0;
  if (!*(_DWORD *)(a1 + 104)) {
    return 0;
  }
  int U32Attribute = LDOObject_GetU32Attribute((uint64_t *)a1, "_TTYPE", (_DWORD *)&v13 + 1, &v13);
  uint64_t v11 = LH_ERROR_to_VERROR(U32Attribute);
  if ((v11 & 0x80000000) == 0 && HIDWORD(v13) && v13 == a2)
  {
    *a3 = 1;
    *a4 = LDOLabel_GetAbsoluteFrom(a1);
    *a5 = LDOLabel_GetAbsoluteTo(a1);
  }
  return v11;
}

uint64_t abbrtn_load_lua_code(_WORD *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  int v16 = 0;
  if (*a4)
  {
    OOC_PlacementDeleteObject(a3, *a4);
    *a4 = 0;
  }
  int IsLuaCodeAvailable = LuaVMLDO_IsLuaCodeAvailable(a1, a2, 0, &v16);
  uint64_t v9 = LH_ERROR_to_VERROR(IsLuaCodeAvailable);
  int v10 = v16;
  if ((v9 & 0x80000000) != 0 || v16 != 1)
  {
LABEL_8:
    if ((v9 & 0x80000000) == 0 && v10) {
      return v9;
    }
    goto LABEL_12;
  }
  int v16 = 0;
  int v11 = PNEW_LuaVMLDO_Con(a3, a3, (uint64_t)a1, a2, (uint64_t)abbrtn_hlp_lua_log_callback, (uint64_t **)a4);
  uint64_t v12 = LH_ERROR_to_VERROR(v11);
  if ((v12 & 0x80000000) == 0)
  {
    int ScriptFromRIFF = LuaVMLDO_LoadScriptFromRIFF(*a4, 0);
    uint64_t v12 = LH_ERROR_to_VERROR(ScriptFromRIFF);
    if ((v12 & 0x80000000) == 0)
    {
      int IsLuaFunctionAvailable = LuaVMLDO_IsLuaFunctionAvailable(*a4, (uint64_t)"runAbbrtn", &v16);
      uint64_t v9 = LH_ERROR_to_VERROR(IsLuaFunctionAvailable);
      int v10 = v16;
      goto LABEL_8;
    }
  }
  uint64_t v9 = v12;
LABEL_12:
  if (*a4)
  {
    OOC_PlacementDeleteObject(a3, *a4);
    *a4 = 0;
  }
  return v9;
}

uint64_t abbrtn_hlp_lua_log_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return log_OutText(a1, (uint64_t)"FE_ABBRTN", 4, 0, a2, a6, a7, a8, 0);
}

uint64_t abbrtn_dumpNodes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v29 = 0;
  log_OutText(*(void *)(a1 + 32), a2, 4, 0, (uint64_t)"abbrtn_dumpNodes : %s : Start", a6, a7, a8, a5);
  int v12 = LDO_ComputeText(a3, &v29);
  uint64_t v13 = LH_ERROR_to_VERROR(v12);
  if ((v13 & 0x80000000) == 0)
  {
    uint64_t v14 = fst::FstImpl<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::Properties(v29);
    log_OutText(*(void *)(a1 + 32), a2, 4, 0, (uint64_t)"LDO text |%s|", v15, v16, v17, v14);
    uint64_t v21 = *(void *)(a3 + 16);
    unsigned __int16 v22 = *(uint64_t **)(v21 + 80);
    if ((unint64_t)v22 >= *(void *)(v21 + 88))
    {
LABEL_13:
      log_OutText(*(void *)(a1 + 32), a2, 4, 0, (uint64_t)"abbrtn_dumpNodes : End", v18, v19, v20, 0);
    }
    else
    {
      int v23 = 0;
      while (1)
      {
        int v24 = LDOTreeNode_ComputeAbsoluteFrom(*v22, &v31);
        uint64_t v25 = LH_ERROR_to_VERROR(v24);
        if ((v25 & 0x80000000) != 0) {
          break;
        }
        int v26 = LDOTreeNode_ComputeAbsoluteTo(*v22, (_DWORD *)&v30 + 1);
        uint64_t v25 = LH_ERROR_to_VERROR(v26);
        if ((v25 & 0x80000000) != 0) {
          break;
        }
        int U32Attribute = LDOObject_GetU32Attribute((uint64_t *)*v22, "_TTYPE", (_DWORD *)&v31 + 1, &v30);
        uint64_t v13 = LH_ERROR_to_VERROR(U32Attribute);
        if ((v13 & 0x80000000) != 0) {
          goto LABEL_15;
        }
        if (HIDWORD(v31) == 1)
        {
          if ((HIDWORD(v30) - v31) < 0x80)
          {
            __strncpy_chk();
            v32[(HIDWORD(v30) - v31)] = 0;
          }
          else
          {
            strcpy(v32, "(TOKEN TOO LONG)");
          }
          log_OutText(*(void *)(a1 + 32), a2, 4, 0, (uint64_t)"[%d] %s %d,%d |%s|", v18, v19, v20, (unsigned __int16)v23++);
        }
        if ((unint64_t)++v22 >= *(void *)(v21 + 88)) {
          goto LABEL_13;
        }
      }
      uint64_t v13 = v25;
    }
  }
LABEL_15:
  if (v29) {
    OOC_PlacementDeleteObject(a4, v29);
  }
  return v13;
}

uint64_t abbrtn_dumpLabels(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v61 = *MEMORY[0x263EF8340];
  uint64_t v58 = 0;
  uint64_t v59 = 0;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  log_OutText(*(void *)(a1 + 32), a2, 4, 0, (uint64_t)"abbrtn_dumpLabels : %s : Start", a6, a7, a8, a5);
  int v12 = LDO_ComputeText(a3, &v58);
  uint64_t v13 = LH_ERROR_to_VERROR(v12);
  if ((v13 & 0x80000000) == 0)
  {
    uint64_t v54 = a4;
    uint64_t v53 = fst::FstImpl<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::Properties(v58);
    uint64_t v55 = a2;
    log_OutText(*(void *)(a1 + 32), a2, 4, 0, (uint64_t)"LDO text |%s|", v14, v15, v16, v53);
    uint64_t v20 = *(void *)(a3 + 32);
    uint64_t v21 = *(uint64_t **)(v20 + 24);
    if ((unint64_t)v21 >= *(void *)(v20 + 32))
    {
LABEL_29:
      log_OutText(*(void *)(a1 + 32), v55, 4, 0, (uint64_t)"abbrtn_dumpLabels : End", v17, v18, v19, 0);
    }
    else
    {
      unsigned __int16 v22 = 0;
      int v23 = "_TTYPE";
      while (1)
      {
        int v24 = (uint64_t *)*v21;
        int AbsoluteFrom = LDOLabel_GetAbsoluteFrom(*v21);
        int AbsoluteTo = LDOLabel_GetAbsoluteTo((uint64_t)v24);
        int U32Attribute = LDOObject_GetU32Attribute(v24, v23, &v59, (_DWORD *)&v59 + 1);
        uint64_t v28 = LH_ERROR_to_VERROR(U32Attribute);
        if ((v28 & 0x80000000) != 0) {
          break;
        }
        if (v59 == 1)
        {
          uint64_t v32 = a3;
          uint64_t v33 = v23;
          int v34 = HIDWORD(v59);
          unsigned int v35 = AbsoluteTo - AbsoluteFrom;
          if (AbsoluteTo == AbsoluteFrom)
          {
            strcpy(v60, "NULL");
          }
          else if (v35 < 0x80)
          {
            __strncpy_chk();
            v60[v35] = 0;
          }
          else
          {
            strcpy(v60, "(TOKEN TOO LONG)");
          }
          int v36 = v34 - 4;
          int v23 = v33;
          switch(v36)
          {
            case 0:
              log_OutText(*(void *)(a1 + 32), v55, 4, 0, (uint64_t)"[%d] TOKEN_DCT %d,%d |%s|", v29, v30, v31, v22);
              goto LABEL_22;
            case 1:
              int StringAttribute = LDOObject_GetStringAttribute(v24, "TNTAG", &v59, &v57);
              uint64_t v28 = LH_ERROR_to_VERROR(StringAttribute);
              if ((v28 & 0x80000000) != 0) {
                goto LABEL_30;
              }
              a3 = v32;
              uint64_t v41 = *(void *)(a1 + 32);
              if (v59 == 1) {
                log_OutText(v41, v55, 4, 0, (uint64_t)"[%d] TOKEN_USER_TN %d,%d |%s| (%s)", v38, v39, v40, v22);
              }
              else {
                log_OutText(v41, v55, 4, 0, (uint64_t)"[%d] TOKEN_USER_TN %d,%d |%s| (no TNTAG)", v38, v39, v40, v22);
              }
              break;
            case 2:
              int v42 = LDOObject_GetStringAttribute(v24, "LANGMAP", &v59, &v56);
              uint64_t v28 = LH_ERROR_to_VERROR(v42);
              if ((v28 & 0x80000000) != 0) {
                goto LABEL_30;
              }
              a3 = v32;
              uint64_t v46 = *(void *)(a1 + 32);
              if (v59 == 1) {
                log_OutText(v46, v55, 4, 0, (uint64_t)"[%d] TOKEN_INT_TN %d,%d |%s| LANGMAP=\"%s\"", v43, v44, v45, v22);
              }
              else {
                log_OutText(v46, v55, 4, 0, (uint64_t)"[%d] TOKEN_INT_TN %d,%d |%s|", v43, v44, v45, v22);
              }
              break;
            case 3:
              log_OutText(*(void *)(a1 + 32), v55, 4, 0, (uint64_t)"[%d] TOKEN_CASEGENDER %d,%d |%s|", v29, v30, v31, v22);
              goto LABEL_22;
            case 4:
              log_OutText(*(void *)(a1 + 32), v55, 4, 0, (uint64_t)"[%d] TOKEN_DEPES %d,%d |%s|", v29, v30, v31, v22);
              goto LABEL_22;
            default:
              log_OutText(*(void *)(a1 + 32), v55, 4, 0, (uint64_t)"[%d] TOKEN type=%d %d,%d |%s|", v29, v30, v31, v22);
              int v23 = v33;
LABEL_22:
              a3 = v32;
              break;
          }
        }
        int v47 = LDOObject_GetU32Attribute(v24, "_MTYPE", &v59, (_DWORD *)&v59 + 1);
        uint64_t v13 = LH_ERROR_to_VERROR(v47);
        if ((v13 & 0x80000000) != 0) {
          goto LABEL_31;
        }
        if (v59 == 1)
        {
          uint64_t v48 = *(void *)(a1 + 32);
          marker_getString(SHIDWORD(v59));
          log_OutText(v48, v55, 4, 0, (uint64_t)"[%d] MARKER %s %d,%d", v49, v50, v51, v22);
        }
        ++v22;
        if ((unint64_t)++v21 >= *(void *)(*(void *)(a3 + 32) + 32)) {
          goto LABEL_29;
        }
      }
LABEL_30:
      uint64_t v13 = v28;
    }
LABEL_31:
    a4 = v54;
  }
  if (v58) {
    OOC_PlacementDeleteObject(a4, v58);
  }
  return v13;
}

uint64_t abbrtn_process_ldo_with_lua(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v34 = 0;
  int v10 = LDO_ComputeText(a3, &v34);
  uint64_t v11 = LH_ERROR_to_VERROR(v10);
  if ((v11 & 0x80000000) == 0)
  {
    uint64_t v12 = fst::FstImpl<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::Properties(v34);
    if (v12)
    {
      log_OutText(*(void *)(a1 + 32), a2, 5, 0, (uint64_t)"LDO sentence: %s", v13, v14, v15, v12);
      uint64_t v19 = abbrtn_dumpNodes(a1, a2, a3, a4, (uint64_t)"abbrtn: before Lua", v16, v17, v18);
      if ((v19 & 0x80000000) != 0
        || (uint64_t v19 = abbrtn_dumpLabels(a1, a2, a3, a4, (uint64_t)"abbrtn: before Lua", v20, v21, v22),
            (v19 & 0x80000000) != 0))
      {
LABEL_8:
        uint64_t v11 = v19;
        goto LABEL_9;
      }
      int v23 = LuaVMLDO_RunFunction(a5, (uint64_t)"runAbbrtn", a3);
      uint64_t v24 = LH_ERROR_to_VERROR(v23);
      if ((v24 & 0x80000000) == 0)
      {
        uint64_t v19 = abbrtn_dumpNodes(a1, a2, a3, a4, (uint64_t)"abbrtn: after Lua", v26, v27, v28);
        if ((v19 & 0x80000000) == 0) {
          uint64_t v19 = abbrtn_dumpLabels(a1, a2, a3, a4, (uint64_t)"abbrtn: after Lua", v29, v30, v31);
        }
        goto LABEL_8;
      }
      uint64_t v11 = v24;
      log_OutPublic(*(void *)(a1 + 32), a2, 32004, 0, v25, v26, v27, v28, v33);
    }
  }
LABEL_9:
  if (v34) {
    OOC_PlacementDeleteObject(a4, v34);
  }
  return v11;
}

uint64_t fe_abbrtn_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2310021121;
  }
  uint64_t result = 0;
  *a2 = &IFeAbbrtn;
  return result;
}

uint64_t fe_abbrtn_ClassOpen(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0;
  if (!a3) {
    return 2310021127;
  }
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *(void *)a3 = a1;
    *(void *)(a3 + 8) = a2;
  }
  return result;
}

uint64_t fe_abbrtn_ClassClose()
{
  return 0;
}

uint64_t fe_abbrtn_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  uint64_t v5 = 2310021127;
  uint64_t v34 = 0;
  uint64_t v35 = 0;
  if (!a5) {
    return v5;
  }
  *(void *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  uint64_t inited = InitRsrcFunction(a3, a4, &v37);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t inited = objc_GetObject(v37[6], (uint64_t)"LINGDB", &v36);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t Object = objc_GetObject(v37[6], (uint64_t)"FE_DCTLKP", &v35);
  uint64_t v13 = v37[6];
  if ((Object & 0x80000000) != 0)
  {
    uint64_t v32 = "LINGDB";
LABEL_13:
    objc_ReleaseObject(v13, (uint64_t)v32);
    return Object;
  }
  uint64_t v14 = objc_GetObject(v13, (uint64_t)"FE_DEPES", &v34);
  if ((v14 & 0x80000000) != 0)
  {
    uint64_t Object = v14;
    objc_ReleaseObject(v37[6], (uint64_t)"LINGDB");
    uint64_t v13 = v37[6];
    uint64_t v32 = "FE_DCTLKP";
    goto LABEL_13;
  }
  uint64_t v15 = heap_Alloc(v37[1], 216);
  if (v15)
  {
    uint64_t v20 = v15;
    *(void *)uint64_t v15 = a1;
    *(void *)(v15 + 8) = a2;
    uint64_t v22 = v36;
    uint64_t v21 = v37;
    *(void *)(v15 + 16) = v37;
    *(void *)(v15 + 24) = a3;
    *(void *)(v15 + 32) = a4;
    *(void *)(v15 + 40) = *(void *)(v22 + 8);
    uint64_t v23 = v35;
    *(void *)(v15 + 64) = *(void *)(v35 + 8);
    *(_OWORD *)(v15 + 48) = *(_OWORD *)(v23 + 16);
    uint64_t v24 = v34;
    *(void *)(v15 + 88) = *(void *)(v34 + 8);
    long long v25 = *(_OWORD *)(v24 + 16);
    *(void *)(v15 + 120) = heap_Alloc;
    *(_OWORD *)(v15 + 72) = v25;
    *(void *)(v15 + 96) = 0;
    *(void *)(v15 + 104) = 0;
    *(void *)(v15 + 192) = 0;
    *(void *)(v15 + 200) = 0;
    *(void *)(v15 + 208) = "FE_ABBRTN";
    *(void *)(v15 + 128) = heap_Calloc;
    *(void *)(v15 + 136) = heap_Realloc;
    *(void *)(v15 + 144) = heap_Free;
    int v26 = OOCAllocator_Con(v15 + 152, (_OWORD *)(v15 + 120), v21[1]);
    uint64_t v27 = LH_ERROR_to_VERROR(v26);
    if ((v27 & 0x80000000) != 0)
    {
      uint64_t v5 = v27;
      log_OutPublic(v37[4], (uint64_t)"FE_ABBRTN", 32003, 0, v28, v29, v30, v31, v34);
LABEL_17:
      fe_abbrtn_ObjClose(*(void **)a5, *(void *)(a5 + 8));
      *(void *)a5 = 0;
      *(_DWORD *)(a5 + 8) = 0;
      return v5;
    }
    *(void *)a5 = v20;
    *(_DWORD *)(a5 + 8) = 62338;
    uint64_t v5 = fe_abbrtn_ObjReopen(v20, *(void *)(a5 + 8));
    if ((v5 & 0x80000000) != 0) {
      goto LABEL_17;
    }
  }
  else
  {
    log_OutPublic(v37[4], (uint64_t)"FE_ABBRTN", 32000, 0, v16, v17, v18, v19, v34);
    objc_ReleaseObject(v37[6], (uint64_t)"LINGDB");
    objc_ReleaseObject(v37[6], (uint64_t)"FE_DCTLKP");
    objc_ReleaseObject(v37[6], (uint64_t)"FE_DEPES");
    return 2310021130;
  }
  return v5;
}

uint64_t fe_abbrtn_ObjClose(void *a1, int a2)
{
  uint64_t result = safeh_HandleCheck((uint64_t)a1, a2, 62338, 216);
  if ((result & 0x80000000) != 0) {
    return 2310021128;
  }
  if (a1)
  {
    luavmldoutil_destroy_lua_vm((uint64_t)(a1 + 19), a1 + 25);
    kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(a1 + 19));
    objc_ReleaseObject(*(void *)(a1[2] + 48), (uint64_t)"LINGDB");
    objc_ReleaseObject(*(void *)(a1[2] + 48), (uint64_t)"FE_DCTLKP");
    objc_ReleaseObject(*(void *)(a1[2] + 48), (uint64_t)"FE_DEPES");
    heap_Free(*(void **)(a1[2] + 8), (uint64_t)a1);
    return 0;
  }
  return result;
}

uint64_t fe_abbrtn_ObjReopen(uint64_t a1, int a2)
{
  uint64_t result = safeh_HandleCheck(a1, a2, 62338, 216);
  if ((result & 0x80000000) != 0) {
    return 2310021128;
  }
  if (!a1) {
    return result;
  }
  *(unsigned char *)(a1 + 112) = 1;
  *(void *)&__c[3] = 0;
  *(_WORD *)&__c[1] = -1;
  __c[0] = 0;
  uint64_t result = (*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 64) + 96))(*(void *)(a1 + 48), *(void *)(a1 + 56), "fecfg", "nrpart_tn", &__c[3], &__c[1], __c);
  if ((result & 0x80000000) != 0 || !*(_WORD *)&__c[1])
  {
    if ((result & 0x80000000) != 0) {
      return result;
    }
  }
  else
  {
    uint64_t v4 = **(const char ***)&__c[3];
    uint64_t v5 = strchr(**(char ***)&__c[3], __c[0]);
    if (v5)
    {
      *uint64_t v5 = 0;
      uint64_t v4 = **(const char ***)&__c[3];
    }
    *(unsigned char *)(a1 + 112) = atoi(v4);
  }
  luavmldoutil_destroy_lua_vm(a1 + 152, (uint64_t *)(a1 + 200));
  return abbrtn_load_lua_code(*(_WORD **)(a1 + 24), *(void *)(a1 + 32), a1 + 152, (uint64_t *)(a1 + 200));
}

uint64_t fe_abbrtn_ProcessStart(uint64_t a1, int a2)
{
  LODWORD(result) = safeh_HandleCheck(a1, a2, 62338, 216);
  if ((int)result >= 0) {
    return result;
  }
  else {
    return 2310021128;
  }
}

uint64_t fe_abbrtn_Process(void *a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  int v47 = 0;
  __s1 = 0;
  int v45 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 62338, 216) & 0x80000000) != 0) {
    return 2310021128;
  }
  *a5 = 1;
  uint64_t v9 = LingDBHasSentence(a1[5], a3, a4, &v45);
  unint64_t v10 = 0;
  if ((v9 & 0x80000000) != 0 || v45 != 1)
  {
LABEL_48:
    if ((v9 & 0x80000000) != 0) {
      goto LABEL_52;
    }
    goto LABEL_49;
  }
  uint64_t v11 = (uint64_t)(a1 + 19);
  uint64_t v12 = a1 + 24;
  uint64_t inited = initLDO((uint64_t)(a1 + 19), a1 + 24);
  if ((inited & 0x80000000) != 0)
  {
LABEL_45:
    uint64_t v9 = inited;
    goto LABEL_46;
  }
  uint64_t v9 = importFromLingDB(a1[2], a1[5], a3, a4, a1 + 24);
  if ((v9 & 0x80000000) != 0)
  {
LABEL_46:
    unint64_t v10 = 0;
    goto LABEL_52;
  }
  if (!*v12)
  {
    unint64_t v10 = 0;
    goto LABEL_48;
  }
  int v14 = LDO_ComputeText(*v12, &v44);
  uint64_t inited = LH_ERROR_to_VERROR(v14);
  if ((inited & 0x80000000) != 0) {
    goto LABEL_45;
  }
  uint64_t v15 = fst::FstImpl<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::Properties(v44);
  uint64_t v16 = *(void *)(*v12 + 32);
  uint64_t v17 = *(uint64_t ***)(v16 + 24);
  if ((unint64_t)v17 >= *(void *)(v16 + 32))
  {
    unint64_t v10 = 0;
  }
  else
  {
    int v42 = (const char *)v15;
    uint64_t v18 = 0;
    unint64_t v10 = 0;
    unsigned int v19 = 0;
    do
    {
      uint64_t v20 = *v17;
      if (*((_DWORD *)*v17 + 26))
      {
        LODWORD(v43) = 0;
        int U32Attribute = LDOObject_GetU32Attribute(v20, "_TTYPE", &v43, (_DWORD *)&v43 + 1);
        uint64_t v9 = LH_ERROR_to_VERROR(U32Attribute);
        if ((v9 & 0x80000000) != 0) {
          goto LABEL_52;
        }
        if (v43 == 1 && HIDWORD(v43) == 5)
        {
          uint64_t v23 = v18;
          unint64_t v24 = (unint64_t)v18 - v10;
          unsigned int v25 = (v24 >> 3) + 1;
          if (v25 <= v19)
          {
            uint64_t v28 = v23;
          }
          else
          {
            unsigned int v26 = 2 * v19;
            if (2 * v19 >= v19 + 1000000) {
              unsigned int v26 = v19 + 1000000;
            }
            if (v26 > v25) {
              unsigned int v25 = v26;
            }
            if (v25 <= 8) {
              unsigned int v19 = 8;
            }
            else {
              unsigned int v19 = v25;
            }
            uint64_t v27 = OOCAllocator_Realloc((uint64_t)(a1 + 19), v10, 8 * v19, &v47);
            unint64_t v10 = v27;
            if (v47) {
              goto LABEL_48;
            }
            uint64_t v28 = (uint64_t **)(v27 + (v24 & 0x7FFFFFFF8));
          }
          *uint64_t v28 = v20;
          uint64_t v18 = v28 + 1;
        }
      }
      ++v17;
    }
    while ((unint64_t)v17 < *(void *)(*(void *)(*v12 + 32) + 32));
    if (v10 < (unint64_t)v18)
    {
      unint64_t v29 = (unint64_t)v18;
      uint64_t v30 = (uint64_t *)v10;
      do
      {
        uint64_t v31 = (uint64_t *)*v30;
        if (*(_DWORD *)(*v30 + 104))
        {
          unsigned __int16 AbsoluteFrom = LDOLabel_GetAbsoluteFrom(*v30);
          __int16 AbsoluteTo = LDOLabel_GetAbsoluteTo((uint64_t)v31);
          int StringAttribute = LDOObject_GetStringAttribute(v31, "TNTAG", &v43, (uint64_t *)&__s1);
          uint64_t v35 = LH_ERROR_to_VERROR(StringAttribute);
          if ((v35 & 0x80000000) != 0) {
            goto LABEL_51;
          }
          uint64_t v36 = __s1;
          if (!strstr(__s1, "spell"))
          {
            if (strcmp(v36, "phon"))
            {
              if (!strstr(v36, "prompt")
                && !strstr(v36, "raw")
                && !strstr(v36, "RAW")
                && !strstr(v36, "internal-nuance-system-norm"))
              {
                uint64_t v35 = abbrtn_TnLookup(a1, v42, AbsoluteFrom, AbsoluteTo, v36, (uint64_t)v31);
                if ((v35 & 0x80000000) != 0) {
                  goto LABEL_51;
                }
              }
            }
          }
        }
        ++v30;
      }
      while ((unint64_t)v30 < v29);
    }
    uint64_t v11 = (uint64_t)(a1 + 19);
  }
  uint64_t v35 = abbrtn_sanitizeTokenDCTAndIntTN((uint64_t)a1);
  if ((v35 & 0x80000000) != 0
    || (uint64_t v41 = a1[25]) != 0
    && (uint64_t v35 = abbrtn_process_ldo_with_lua(a1[2], a1[26], a1[24], v11, v41), (v35 & 0x80000000) != 0))
  {
LABEL_51:
    uint64_t v9 = v35;
    goto LABEL_52;
  }
  uint64_t v9 = exportToLingDB(a1[2], a1[5], a3, a4, v11, a1[24], 1, 0);
  if ((v9 & 0x80000000) != 0) {
    goto LABEL_52;
  }
LABEL_49:
  if (v47)
  {
    uint64_t v35 = LH_ERROR_to_VERROR(v47);
    goto LABEL_51;
  }
LABEL_52:
  uint64_t v37 = a1[12];
  if (v37)
  {
    heap_Free(*(void **)(a1[2] + 8), v37);
    a1[12] = 0;
  }
  uint64_t v38 = a1[13];
  if (v38)
  {
    heap_Free(*(void **)(a1[2] + 8), v38);
    a1[13] = 0;
  }
  if (v44)
  {
    OOC_PlacementDeleteObject((uint64_t)(a1 + 19), v44);
    uint64_t v44 = 0;
  }
  if (v10) {
    OOCAllocator_Free((uint64_t)(a1 + 19), v10);
  }
  uint64_t v39 = a1[24];
  if (v39)
  {
    deinitLDO((uint64_t)(a1 + 19), v39);
    a1[24] = 0;
  }
  return v9;
}

uint64_t fe_abbrtn_ProcessEnd(uint64_t a1, int a2)
{
  LODWORD(result) = safeh_HandleCheck(a1, a2, 62338, 216);
  if ((int)result >= 0) {
    return result;
  }
  else {
    return 2310021128;
  }
}

uint64_t fe_dctlkp_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, int a4, uint64_t a5)
{
  uint64_t v51 = 0;
  uint64_t v52 = 0;
  uint64_t CanonMap = 2306875402;
  uint64_t v49 = 0;
  if (!a5) {
    return 2306875399;
  }
  memset(__c, 0, sizeof(__c));
  *(void *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  uint64_t inited = InitRsrcFunction(a3, a4, &v52);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  log_OutText(v52[4], (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_ObjOpen", v8, v9, v10, v47);
  uint64_t inited = objc_GetObject(v52[6], (uint64_t)"LINGDB", &v51);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t v11 = heap_Calloc((void *)v52[1], 1, 3696);
  if (v11)
  {
    uint64_t v16 = v11;
    *(void *)a5 = v11;
    *(_DWORD *)(a5 + 8) = 62335;
    *(void *)(v11 + 568) = *(void *)(v51 + 8);
    *(void *)uint64_t v11 = v52;
    *(_WORD *)(v11 + 1632) = 1;
    *(_DWORD *)(v11 + 2660) = 1;
    *(void *)(v11 + 496) = 0;
    *(_DWORD *)(v11 + 488) = 0;
    uint64_t v17 = (_DWORD *)(v11 + 8);
    *(_WORD *)(v11 + 80) = 0;
    *(_WORD *)(v11 + 160) = 0;
    *(_WORD *)(v11 + 240) = 0;
    *(_WORD *)(v11 + 320) = 0;
    *(_WORD *)(v11 + 400) = 0;
    *(_WORD *)(v11 + 480) = 0;
    uint64_t v18 = (uint64_t *)(v11 + 16);
    set_DctBrk(v11 + 16, v52[3]);
    set_DctBrk(v16 + 96, v52[3]);
    set_DctBrk(v16 + 176, v52[3]);
    set_DctBrk(v16 + 256, v52[3]);
    set_DctBrk(v16 + 336, v52[3]);
    set_DctBrk(v16 + 416, v52[3]);
    *(void *)(v16 + 64) = 0;
    *(void *)(v16 + 144) = 0;
    *(void *)(v16 + 224) = 0;
    *(void *)(v16 + 304) = 0;
    *(void *)(v16 + 384) = 0;
    *(void *)(v16 + 464) = 0;
    *(_DWORD *)(v16 + 152) = 0;
    *(_DWORD *)(v16 + 232) = 0;
    *(_DWORD *)(v16 + 72) = 0;
    *(_DWORD *)(v16 + 312) = 0;
    *(_DWORD *)(v16 + 392) = 0;
    *(_DWORD *)(v16 + 472) = 0;
    if ((hlp_CreateBrokerString((uint64_t)v52, (char *)(v16 + 1634), 0) & 0x80000000) != 0
      || (open_DctRom(v18, v16 + 1634, v17) & 0x80000000) != 0)
    {
      uint64_t BrokerString = hlp_CreateBrokerString((uint64_t)v52, (char *)(v16 + 1634), 1);
      if ((BrokerString & 0x80000000) != 0) {
        goto LABEL_48;
      }
      uint64_t BrokerString = open_DctRom(v18, v16 + 1634, v17);
      if ((BrokerString & 0x80000000) != 0) {
        goto LABEL_48;
      }
    }
    if ((hlp_CreateVoiceBrokerString((uint64_t)v52, (char *)(v16 + 1890), 1) & 0x80000000) != 0
      || (open_DctRom((uint64_t *)(v16 + 336), v16 + 1890, (_DWORD *)(v16 + 328)) & 0x80000000) != 0)
    {
      uint64_t BrokerString = hlp_CreateVoiceBrokerString((uint64_t)v52, (char *)(v16 + 1890), 0);
      if ((BrokerString & 0x80000000) != 0) {
        goto LABEL_48;
      }
      if ((open_DctRom((uint64_t *)(v16 + 336), v16 + 1890, (_DWORD *)(v16 + 328)) & 0x80000000) != 0) {
        *(_DWORD *)(v16 + 328) = 0;
      }
    }
    uint64_t v20 = (_DWORD *)(v16 + 88);
    BOOL v21 = 0;
    if ((paramc_ParamGetStr(*(void *)(*(void *)v16 + 40), (uint64_t)"clcpppipelinemode", &v49) & 0x80000000) == 0
      && v49)
    {
      BOOL v21 = *v49 != 0;
    }
    uint64_t v22 = open_DctRom((uint64_t *)(v16 + 96), (uint64_t)"sysdct", (_DWORD *)(v16 + 88));
    uint64_t CanonMap = v22;
    if (!v21 && (v22 & 0x80000000) != 0)
    {
      *(_DWORD *)(v16 + 168) = 0;
      log_OutPublic(*(void *)(*(void *)v16 + 32), (uint64_t)"FE_DCTLKP", 41005, "%s", v23, v24, v25, v26, "sysdct.dat not found");
      goto LABEL_50;
    }
    char v27 = !v21;
    if ((int)v22 >= 0) {
      char v27 = 1;
    }
    if ((v27 & 1) == 0) {
      *uint64_t v20 = 0;
    }
    uint64_t v28 = open_DctRom((uint64_t *)(v16 + 176), (uint64_t)"lid", (_DWORD *)(v16 + 168));
    char v33 = (int)v28 >= 0 || v21;
    if ((v33 & 1) == 0)
    {
      uint64_t CanonMap = v28;
      *(_DWORD *)(v16 + 168) = 0;
      log_OutPublic(*(void *)(*(void *)v16 + 32), (uint64_t)"FE_DCTLKP", 41007, "%s", v29, v30, v31, v32, "lid.dat not found");
      goto LABEL_50;
    }
    char v34 = !v21;
    if ((int)v28 >= 0) {
      char v34 = 1;
    }
    if ((v34 & 1) == 0) {
      *uint64_t v20 = 0;
    }
    if ((open_DctRom((uint64_t *)(v16 + 416), (uint64_t)"clmnn:clmnndic", (_DWORD *)(v16 + 408)) & 0x80000000) != 0) {
      *(_DWORD *)(v16 + 408) = 0;
    }
    hlp_OpenMl2Dct((uint64_t)v52, v16);
    *(_WORD *)&__c[1] = -1;
    uint64_t BrokerString = loc_fe_dctlkp_LookupUtf(*(void *)a5, *(void *)(a5 + 8), "fecfg", "punc", &__c[3], &__c[1], __c, 0);
    if ((BrokerString & 0x80000000) == 0)
    {
      if (*(void *)&__c[3])
      {
        uint64_t v35 = **(const char ***)&__c[3];
        uint64_t v36 = strchr(**(char ***)&__c[3], __c[0]);
        if (v36)
        {
          *uint64_t v36 = 0;
          uint64_t v35 = **(const char ***)&__c[3];
        }
        int v37 = strlen(v35);
        uint64_t v38 = (char *)heap_Alloc(v52[1], (v37 + 1));
        *(void *)(v16 + 504) = v38;
        if (v38)
        {
          strcpy(v38, **(const char ***)&__c[3]);
          *(_WORD *)&__c[1] = -1;
          uint64_t BrokerString = loc_fe_dctlkp_LookupUtf(*(void *)a5, *(void *)(a5 + 8), "fecfg", "canonmapdomain", &__c[3], &__c[1], __c, 0);
          if ((BrokerString & 0x80000000) == 0)
          {
            if (*(_WORD *)&__c[1]) {
              *(_DWORD *)(v16 + 2660) = 0;
            }
            uint64_t BrokerString = loc_fe_dctlkp_getDomainTokenDefs(*(void *)a5, *(void *)(a5 + 8), v16);
            if ((BrokerString & 0x80000000) == 0)
            {
              strcpy((char *)(v16 + 2402), "normal");
              *(void *)(v16 + 584) = 0;
              *(void *)(v16 + 2664) = 0;
              uint64_t CanonMap = LoadCanonMap(*(void *)a5, *(void *)(a5 + 8));
              if ((CanonMap & 0x80000000) == 0)
              {
LABEL_51:
                log_OutText(v52[4], (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Leaving fe_dctlkp_ObjOpen", v43, v44, v45, v48);
                return CanonMap;
              }
LABEL_50:
              fe_dctlkp_ObjClose(*(unsigned __int16 **)a5, *(void *)(a5 + 8));
              *(void *)a5 = 0;
              *(_DWORD *)(a5 + 8) = 0;
              goto LABEL_51;
            }
          }
          goto LABEL_48;
        }
        log_OutPublic(*(void *)(*(void *)v16 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v39, v40, v41, v42, v48);
      }
      uint64_t CanonMap = 2306875402;
      goto LABEL_50;
    }
LABEL_48:
    uint64_t CanonMap = BrokerString;
    goto LABEL_50;
  }
  log_OutPublic(v52[4], (uint64_t)"FE_DCTLKP", 41000, 0, v12, v13, v14, v15, v48);
  objc_ReleaseObject(v52[6], (uint64_t)"LINGDB");
  return CanonMap;
}

uint64_t hlp_CreateBrokerString(uint64_t a1, char *a2, int a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v7 = &byte_20D5A22AE;
  *(void *)uint64_t v8 = 0;
  uint64_t v17 = 0;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v10 = 0u;
  uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"langcode", v8);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v9 = 0x2F746364737973;
    __strcat_chk();
    if (!a3)
    {
      uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"fecfg", &v7);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      __strcat_chk();
      __strcat_chk();
    }
    return brokeraux_ComposeBrokerString(a1, (const char *)&v9, 1, 1, *(char **)v8, 0, 0, a2, 0x100uLL);
  }
  return result;
}

uint64_t hlp_CreateVoiceBrokerString(uint64_t a1, char *a2, int a3)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v9 = 0;
  long long v10 = 0;
  uint64_t v8 = 0;
  memset(v18, 0, sizeof(v18));
  long long v17 = 0u;
  long long v16 = 0u;
  long long v15 = 0u;
  long long v14 = 0u;
  long long v13 = 0u;
  long long v12 = 0u;
  uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"langcode", &v10);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"voice", &v9);
    if ((result & 0x80000000) == 0)
    {
      if (a3)
      {
        if ((paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"voicemodel", &v8) & 0x80000000) != 0)
        {
          uint64_t v7 = 0;
          uint64_t v8 = 0;
        }
        else
        {
          uint64_t v7 = v8;
        }
      }
      else
      {
        uint64_t v7 = 0;
      }
      strcpy(v11, "voicedct");
      return brokeraux_ComposeBrokerString(a1, v11, 1, 1, v10, v9, v7, a2, 0x100uLL);
    }
  }
  return result;
}

uint64_t hlp_OpenMl2Dct(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  memset(v16, 0, sizeof(v16));
  long long v15 = 0u;
  long long v14 = 0u;
  long long v13 = 0u;
  long long v12 = 0u;
  long long v11 = 0u;
  long long v10 = 0u;
  *(void *)uint64_t v8 = 0;
  uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"langcode", v8);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v5 = (char *)(a2 + 2146);
    strcpy(v9, "ml2dct");
    __strcat_chk();
    uint64_t result = brokeraux_ComposeBrokerString(a1, v9, 1, 0, *(char **)v8, 0, 0, (char *)(a2 + 2146), 0x100uLL);
    if ((result & 0x80000000) == 0)
    {
      uint64_t v6 = (_DWORD *)(a2 + 248);
      uint64_t v7 = (uint64_t *)(a2 + 256);
      uint64_t result = open_DctRom(v7, (uint64_t)v5, v6);
      if ((result & 0x80000000) != 0)
      {
        memset(v16, 0, sizeof(v16));
        long long v15 = 0u;
        long long v14 = 0u;
        long long v13 = 0u;
        long long v12 = 0u;
        long long v11 = 0u;
        long long v10 = 0u;
        *(void *)uint64_t v8 = 0;
        uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"langcode", v8);
        if ((result & 0x80000000) == 0)
        {
          strcpy(v9, "ml2dct");
          uint64_t result = brokeraux_ComposeBrokerString(a1, v9, 1, 0, *(char **)v8, 0, 0, v5, 0x100uLL);
          if ((result & 0x80000000) == 0)
          {
            uint64_t result = open_DctRom(v7, (uint64_t)v5, v6);
            if ((result & 0x80000000) != 0) {
              *uint64_t v6 = 0;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t fe_dctlkp_LookupUtf(uint64_t a1, int a2, char *a3, const char *a4, void *a5, _WORD *a6, unsigned char *a7)
{
  return loc_fe_dctlkp_LookupUtf(a1, a2, a3, a4, a5, a6, a7, 0);
}

uint64_t loc_fe_dctlkp_getDomainTokenDefs(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  *(void *)&__c[3] = 0;
  __c[0] = 0;
  *(_WORD *)(a3 + 1616) = 0;
  *(_WORD *)&__c[1] = -1;
  uint64_t v6 = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", "domdef", &__c[3], &__c[1], __c, 0);
  if ((v6 & 0x80000000) != 0 || *(unsigned __int16 *)&__c[1] != 1) {
    return v6;
  }
  __strcpy_chk();
  uint64_t v7 = strchr(__s, __c[0]);
  if (v7) {
    *uint64_t v7 = 0;
  }
  if (strlen(**(const char ***)&__c[3]) <= 0xFF)
  {
    if (!__s[0]) {
      return v6;
    }
    unsigned __int16 v12 = 0;
    while (1)
    {
      for (unsigned __int16 i = v12; ; unsigned __int16 i = v14 + 1)
      {
        uint64_t v14 = i;
        int v15 = __s[i];
        if (!v15 || v15 == 44) {
          break;
        }
      }
      if (v14 != v12)
      {
        uint64_t v16 = v14 - v12;
        __strncpy_chk();
        __src[v16] = 0;
        if (*(_WORD *)(a3 + 1616))
        {
          uint64_t v17 = heap_Realloc(*(uint64_t **)(*(void *)a3 + 8), *(void *)(a3 + 1624), 32 * *(unsigned __int16 *)(a3 + 1616) + 32);
          if (!v17) {
            return 2306875402;
          }
          *(void *)(a3 + 1624) = v17;
        }
        else
        {
          uint64_t v17 = heap_Calloc(*(void **)(*(void *)a3 + 8), 32, 1);
          *(void *)(a3 + 1624) = v17;
          if (!v17) {
            return 2306875402;
          }
        }
        uint64_t v18 = (_OWORD *)(v17 + 32 * *(unsigned __int16 *)(a3 + 1616));
        *uint64_t v18 = 0u;
        v18[1] = 0u;
        int v19 = strlen(__src);
        uint64_t v20 = (char *)heap_Calloc(*(void **)(*(void *)a3 + 8), (v19 + 1), 1);
        uint64_t v21 = *(unsigned __int16 *)(a3 + 1616);
        *(void *)(*(void *)(a3 + 1624) + 32 * v21) = v20;
        if (!v20)
        {
          *(_WORD *)(a3 + 1616) = v21 + 1;
          return 2306875402;
        }
        strcpy(v20, __src);
        uint64_t TokenDef = loc_fe_dctlkp_getTokenDef(a1, a2, (uint64_t *)a3, (uint64_t)__src, (uint64_t)"_alpha", (char **)(*(void *)(a3 + 1624) + 32 * *(unsigned __int16 *)(a3 + 1616) + 8));
        if ((TokenDef & 0x80000000) != 0
          || (uint64_t TokenDef = loc_fe_dctlkp_getTokenDef(a1, a2, (uint64_t *)a3, (uint64_t)__src, (uint64_t)"_digit", (char **)(*(void *)(a3 + 1624) + 32 * *(unsigned __int16 *)(a3 + 1616) + 16)), (TokenDef & 0x80000000) != 0))
        {
          uint64_t v6 = TokenDef;
LABEL_30:
          ++*(_WORD *)(a3 + 1616);
          return v6;
        }
        uint64_t v6 = loc_fe_dctlkp_getTokenDef(a1, a2, (uint64_t *)a3, (uint64_t)__src, (uint64_t)"_punc", (char **)(*(void *)(a3 + 1624) + 32 * *(unsigned __int16 *)(a3 + 1616) + 24));
        if ((v6 & 0x80000000) != 0) {
          goto LABEL_30;
        }
        uint64_t v27 = *(void *)(a3 + 1624);
        uint64_t v28 = *(unsigned __int16 *)(a3 + 1616);
        uint64_t v29 = v27 + 32 * v28;
        if (!*(void *)(v29 + 8) && !*(void *)(v29 + 16) && !*(void *)(v27 + 32 * v28 + 24))
        {
          log_OutPublic(*(void *)(*(void *)a3 + 32), (uint64_t)"FE_DCTLKP", 41004, "%s%s", v23, v24, v25, v26, __src);
          ++*(_WORD *)(a3 + 1616);
          return 2306875392;
        }
        *(_WORD *)(a3 + 1616) = v28 + 1;
        unsigned __int16 v12 = v14 + 1;
      }
      if (!__s[v12]) {
        return v6;
      }
    }
  }
  log_OutPublic(*(void *)(*(void *)a3 + 32), (uint64_t)"FE_DCTLKP", 41003, 0, v8, v9, v10, v11, v31);
  return 2306875392;
}

uint64_t LoadCanonMap(uint64_t a1, int a2)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  uint64_t v2 = 2306875402;
  if (!a1) {
    return 2306875400;
  }
  memset(__c, 0, sizeof(__c));
  bzero((void *)(a1 + 592), 0x400uLL);
  bzero((void *)(a1 + 2672), 0x400uLL);
  strcpy(v36, "canonmap_");
  __strcat_chk();
  uint64_t v5 = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", v36, &__c[3], &__c[1], __c, 0);
  if ((v5 & 0x80000000) != 0) {
    return v5;
  }
  unsigned int v6 = *(unsigned __int16 *)&__c[1];
  if (*(_WORD *)&__c[1]) {
    goto LABEL_53;
  }
  *(_WORD *)&__c[1] = 0;
  strcpy(v36, "canonmap");
  uint64_t v5 = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", v36, &__c[3], &__c[1], __c, 0);
  if ((v5 & 0x80000000) != 0) {
    return v5;
  }
  unsigned int v6 = *(unsigned __int16 *)&__c[1];
  if (*(_WORD *)&__c[1])
  {
LABEL_53:
    if (*(void *)(a1 + 584)) {
      goto LABEL_5;
    }
    uint64_t v29 = heap_Alloc(*(void *)(*(void *)a1 + 8), 2048);
    *(void *)(a1 + 584) = v29;
    if (!v29) {
      goto LABEL_49;
    }
    for (uint64_t i = 0; i != 2048; i += 8)
      *(void *)(*(void *)(a1 + 584) + i) = 0;
    unsigned int v6 = *(unsigned __int16 *)&__c[1];
    if (*(_WORD *)&__c[1])
    {
LABEL_5:
      unint64_t v7 = 0;
      do
      {
        uint64_t v8 = *(unsigned __int8 **)(*(void *)&__c[3] + 8 * v7);
        unsigned int v11 = *v8;
        uint64_t v9 = (const char *)(v8 + 2);
        uint64_t v10 = v11;
        *(_DWORD *)(a1 + 4 * v11 + 592) = 1;
        if (!*(void *)(*(void *)(a1 + 584) + 8 * v11))
        {
          int v12 = strlen(v9);
          *(void *)(*(void *)(a1 + 584) + 8 * v10) = heap_Alloc(*(void *)(*(void *)a1 + 8), (v12 + 1));
          uint64_t v17 = *(char **)(*(void *)(a1 + 584) + 8 * v10);
          if (!v17) {
            goto LABEL_49;
          }
          strcpy(v17, v9);
          unsigned int v6 = *(unsigned __int16 *)&__c[1];
        }
        ++v7;
      }
      while (v7 < v6);
    }
  }
  *(_WORD *)&__c[1] = 0;
  strcpy(v36, "canonmapg2pdct_");
  __strcat_chk();
  uint64_t v5 = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", v36, &__c[3], &__c[1], __c, 0);
  if ((v5 & 0x80000000) != 0) {
    return v5;
  }
  unsigned int v18 = *(unsigned __int16 *)&__c[1];
  if (*(_WORD *)&__c[1]) {
    goto LABEL_12;
  }
  *(_WORD *)&__c[1] = 0;
  strcpy(v36, "canonmapg2pdct");
  uint64_t v5 = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", v36, &__c[3], &__c[1], __c, 0);
  if ((v5 & 0x80000000) != 0) {
    return v5;
  }
  unsigned int v18 = *(unsigned __int16 *)&__c[1];
  if (!*(_WORD *)&__c[1]) {
    goto LABEL_18;
  }
LABEL_12:
  if (!*(void *)(a1 + 2664))
  {
    uint64_t v31 = heap_Alloc(*(void *)(*(void *)a1 + 8), 2048);
    *(void *)(a1 + 2664) = v31;
    if (v31)
    {
      for (uint64_t j = 0; j != 2048; j += 8)
        *(void *)(*(void *)(a1 + 2664) + j) = 0;
      unsigned int v18 = *(unsigned __int16 *)&__c[1];
      if (!*(_WORD *)&__c[1]) {
        goto LABEL_18;
      }
      goto LABEL_13;
    }
LABEL_49:
    log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v13, v14, v15, v16, v34);
    return v2;
  }
LABEL_13:
  unint64_t v19 = 0;
  do
  {
    uint64_t v20 = *(unsigned __int8 **)(*(void *)&__c[3] + 8 * v19);
    unsigned int v23 = *v20;
    uint64_t v21 = (const char *)(v20 + 2);
    uint64_t v22 = v23;
    *(_DWORD *)(a1 + 4 * v23 + 2672) = 1;
    if (!*(void *)(*(void *)(a1 + 2664) + 8 * v23))
    {
      int v24 = strlen(v21);
      *(void *)(*(void *)(a1 + 2664) + 8 * v22) = heap_Alloc(*(void *)(*(void *)a1 + 8), (v24 + 1));
      uint64_t v25 = *(char **)(*(void *)(a1 + 2664) + 8 * v22);
      if (!v25) {
        goto LABEL_49;
      }
      strcpy(v25, v21);
      unsigned int v18 = *(unsigned __int16 *)&__c[1];
    }
    ++v19;
  }
  while (v19 < v18);
LABEL_18:
  *(_WORD *)&__c[1] = -1;
  strcpy(v36, "canonmapusage_");
  __strcat_chk();
  uint64_t v2 = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", v36, &__c[3], &__c[1], __c, 0);
  if ((v2 & 0x80000000) == 0)
  {
    int v26 = *(unsigned __int16 *)&__c[1];
    if (!*(_WORD *)&__c[1])
    {
      *(_WORD *)&__c[1] = -1;
      strcpy(v36, "canonmapusage");
      uint64_t v2 = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", v36, &__c[3], &__c[1], __c, 0);
      if ((v2 & 0x80000000) != 0) {
        return v2;
      }
      int v26 = *(unsigned __int16 *)&__c[1];
    }
    if (v26 == 1)
    {
      uint64_t v27 = **(const char ***)&__c[3];
      uint64_t v28 = strchr(**(char ***)&__c[3], __c[0]);
      if (v28)
      {
        *uint64_t v28 = 0;
        uint64_t v27 = **(const char ***)&__c[3];
      }
      if (!strcmp(v27, "all")) {
        *(_WORD *)(a1 + 1632) = 0;
      }
      if (!strcmp(v27, "nocaseconv")) {
        *(_WORD *)(a1 + 1632) = 2;
      }
      if (!strcmp(v27, "g2pdct")) {
        *(_WORD *)(a1 + 1632) = 1;
      }
    }
  }
  return v2;
}

uint64_t fe_dctlkp_ObjClose(unsigned __int16 *a1, int a2)
{
  uint64_t result = safeh_HandleCheck((uint64_t)a1, a2, 62335, 3696);
  if ((result & 0x80000000) != 0) {
    return 2306875400;
  }
  if (a1)
  {
    log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_ObjClose", v4, v5, v6, v20);
    if (a1[244])
    {
      unint64_t v7 = 0;
      do
      {
        uint64_t v8 = *(void *)(*((void *)a1 + 62) + 8 * v7);
        uint64_t v9 = *(void *)(v8 + 624);
        if (v9)
        {
          uint64_t v10 = *(void *)(v8 + 56);
          if (v10)
          {
            brk_DataUnmap(*(void *)(*(void *)a1 + 24), v9, v10);
            uint64_t v9 = *(void *)(*(void *)(*((void *)a1 + 62) + 8 * v7) + 624);
          }
          brk_DataClose(*(void *)(*(void *)a1 + 24), v9);
          uint64_t v8 = *(void *)(*((void *)a1 + 62) + 8 * v7);
        }
        heap_Free(*(void **)(*(void *)a1 + 8), v8);
        ++v7;
      }
      while (v7 < a1[244]);
    }
    objc_ReleaseObject(*(void *)(*(void *)a1 + 48), (uint64_t)"LINGDB");
    hlp_LookupFree(a1);
    close_DctRom((uint64_t)(a1 + 8));
    close_DctRom((uint64_t)(a1 + 48));
    close_DctRom((uint64_t)(a1 + 88));
    close_DctRom((uint64_t)(a1 + 128));
    close_DctRom((uint64_t)(a1 + 168));
    close_DctRom((uint64_t)(a1 + 208));
    uint64_t v11 = *((void *)a1 + 63);
    if (v11) {
      heap_Free(*(void **)(*(void *)a1 + 8), v11);
    }
    uint64_t v12 = *((void *)a1 + 62);
    if (v12) {
      heap_Free(*(void **)(*(void *)a1 + 8), v12);
    }
    hlp_domainToksFree(a1);
    if (*((void *)a1 + 73))
    {
      for (uint64_t i = 0; i != 2048; i += 8)
      {
        uint64_t v17 = *(void *)(*((void *)a1 + 73) + i);
        if (v17) {
          heap_Free(*(void **)(*(void *)a1 + 8), v17);
        }
      }
      heap_Free(*(void **)(*(void *)a1 + 8), *((void *)a1 + 73));
    }
    if (*((void *)a1 + 333))
    {
      for (uint64_t j = 0; j != 2048; j += 8)
      {
        uint64_t v19 = *(void *)(*((void *)a1 + 333) + j);
        if (v19) {
          heap_Free(*(void **)(*(void *)a1 + 8), v19);
        }
      }
      heap_Free(*(void **)(*(void *)a1 + 8), *((void *)a1 + 333));
    }
    log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Leaving fe_dctlkp_ObjClose", v13, v14, v15, v21);
    heap_Free(*(void **)(*(void *)a1 + 8), (uint64_t)a1);
    return 0;
  }
  return result;
}

uint64_t fe_dctlkp_ObjReopen(uint64_t a1, int a2)
{
  uint64_t CanonMap = 2306875400;
  if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) != 0 || !a1) {
    return CanonMap;
  }
  __c_3 = 0;
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_ObjReopen", v5, v6, v7, v27);
  hlp_LookupFree((void *)a1);
  close_DctRom(a1 + 16);
  close_DctRom(a1 + 256);
  close_DctRom(a1 + 336);
  uint64_t v8 = *(void *)(a1 + 504);
  if (v8) {
    heap_Free(*(void **)(*(void *)a1 + 8), v8);
  }
  hlp_domainToksFree((void *)a1);
  if (*(void *)(a1 + 584))
  {
    for (uint64_t i = 0; i != 2048; i += 8)
    {
      uint64_t v10 = *(void *)(*(void *)(a1 + 584) + i);
      if (v10)
      {
        heap_Free(*(void **)(*(void *)a1 + 8), v10);
        *(void *)(*(void *)(a1 + 584) + i) = 0;
      }
    }
    heap_Free(*(void **)(*(void *)a1 + 8), *(void *)(a1 + 584));
    *(void *)(a1 + 584) = 0;
  }
  if (*(void *)(a1 + 2664))
  {
    for (uint64_t j = 0; j != 2048; j += 8)
    {
      uint64_t v12 = *(void *)(*(void *)(a1 + 2664) + j);
      if (v12)
      {
        heap_Free(*(void **)(*(void *)a1 + 8), v12);
        *(void *)(*(void *)(a1 + 2664) + j) = 0;
      }
    }
    heap_Free(*(void **)(*(void *)a1 + 8), *(void *)(a1 + 2664));
    *(void *)(a1 + 2664) = 0;
  }
  *(_DWORD *)(a1 + 8) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 376) = 0;
  *(void *)(a1 + 296) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 344) = 0;
  *(void *)(a1 + 352) = 0;
  *(_OWORD *)(a1 + 536) = 0u;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 504) = 0u;
  *(_OWORD *)(a1 + 520) = 0u;
  *(void *)(a1 + 576) = 0;
  *(_DWORD *)(a1 + 2660) = 1;
  *(_WORD *)(a1 + 1632) = 1;
  if ((hlp_CreateBrokerString(*(void *)a1, (char *)(a1 + 1634), 0) & 0x80000000) != 0
    || (open_DctRom((uint64_t *)(a1 + 16), a1 + 1634, (_DWORD *)(a1 + 8)) & 0x80000000) != 0)
  {
    uint64_t BrokerString = hlp_CreateBrokerString(*(void *)a1, (char *)(a1 + 1634), 1);
    if ((BrokerString & 0x80000000) != 0) {
      return BrokerString;
    }
    uint64_t BrokerString = open_DctRom((uint64_t *)(a1 + 16), a1 + 1634, (_DWORD *)(a1 + 8));
    if ((BrokerString & 0x80000000) != 0) {
      return BrokerString;
    }
  }
  if ((hlp_CreateVoiceBrokerString(*(void *)a1, (char *)(a1 + 1890), 1) & 0x80000000) != 0
    || (open_DctRom((uint64_t *)(a1 + 336), a1 + 1890, (_DWORD *)(a1 + 328)) & 0x80000000) != 0)
  {
    uint64_t BrokerString = hlp_CreateVoiceBrokerString(*(void *)a1, (char *)(a1 + 1890), 0);
    if ((BrokerString & 0x80000000) == 0)
    {
      if ((open_DctRom((uint64_t *)(a1 + 336), a1 + 1890, (_DWORD *)(a1 + 328)) & 0x80000000) != 0) {
        *(_DWORD *)(a1 + 328) = 0;
      }
      goto LABEL_26;
    }
    return BrokerString;
  }
LABEL_26:
  BYTE5(v27) = 0;
  hlp_OpenMl2Dct(*(void *)a1, a1);
  HIWORD(v27) = -1;
  uint64_t BrokerString = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", "punc", &__c_3, (_WORD *)&v27 + 3, (unsigned char *)&v27 + 5, 0);
  if ((BrokerString & 0x80000000) != 0) {
    return BrokerString;
  }
  uint64_t v14 = *__c_3;
  uint64_t v15 = strchr(*__c_3, BYTE5(v27));
  if (v15)
  {
    *uint64_t v15 = 0;
    uint64_t v14 = *__c_3;
  }
  int v16 = strlen(v14);
  uint64_t v17 = (char *)heap_Alloc(*(void *)(*(void *)a1 + 8), (v16 + 1));
  *(void *)(a1 + 504) = v17;
  if (!v17)
  {
    log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v18, v19, v20, v21, v27);
    return 2306875402;
  }
  strcpy(v17, *__c_3);
  HIWORD(v27) = -1;
  uint64_t BrokerString = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", "canonmapdomain", &__c_3, (_WORD *)&v27 + 3, (unsigned char *)&v27 + 5, 0);
  if ((BrokerString & 0x80000000) != 0) {
    return BrokerString;
  }
  if (HIWORD(v27)) {
    *(_DWORD *)(a1 + 2660) = 0;
  }
  uint64_t BrokerString = loc_fe_dctlkp_getDomainTokenDefs(a1, a2, a1);
  if ((BrokerString & 0x80000000) != 0) {
    return BrokerString;
  }
  strcpy((char *)(a1 + 2402), "normal");
  *(void *)(a1 + 584) = 0;
  *(void *)(a1 + 2664) = 0;
  uint64_t CanonMap = LoadCanonMap(a1, a2);
  if ((CanonMap & 0x80000000) == 0)
  {
    if (*(_WORD *)(a1 + 488))
    {
      uint64_t v25 = 0;
      while (1)
      {
        uint64_t CanonMap = hlp_EnableAddon(a1, a2, *(void *)(*(void *)(a1 + 496) + 8 * v25));
        if ((CanonMap & 0x80000000) != 0) {
          break;
        }
        if (++v25 >= (unint64_t)*(unsigned __int16 *)(a1 + 488)) {
          goto LABEL_39;
        }
      }
    }
    else
    {
LABEL_39:
      log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Leaving fe_dctlkp_ObjReopen", v22, v23, v24, v27);
    }
  }
  return CanonMap;
}

void *hlp_LookupFree(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[67];
  if (v2)
  {
    uint64_t result = heap_Free(*(void **)(*result + 8), v2);
    v1[67] = 0;
  }
  uint64_t v3 = v1[7];
  if (v3)
  {
    uint64_t result = heap_Free(*(void **)(*v1 + 8), v3);
    v1[7] = 0;
  }
  uint64_t v4 = (uint64_t *)v1[66];
  if (v4)
  {
    uint64_t v5 = *v4;
    if (*v4)
    {
      uint64_t v6 = 0;
      unsigned __int16 v7 = 0;
      do
      {
        heap_Free(*(void **)(*v1 + 8), v5);
        *(void *)(v1[66] + 8 * v6) = 0;
        ++v7;
        uint64_t v4 = (uint64_t *)v1[66];
        uint64_t v6 = v7;
        uint64_t v5 = v4[v7];
      }
      while (v5);
    }
    else
    {
      unsigned __int16 v7 = 0;
    }
    uint64_t result = heap_Free(*(void **)(*v1 + 8), (uint64_t)v4);
    v1[66] = 0;
  }
  else
  {
    unsigned __int16 v7 = 0;
  }
  uint64_t v8 = (uint64_t *)v1[64];
  if (v8)
  {
    uint64_t v9 = *v8;
    if (*v8)
    {
      uint64_t v10 = 0;
      unsigned __int16 v7 = 0;
      do
      {
        heap_Free(*(void **)(*v1 + 8), v9);
        *(void *)(v1[64] + 8 * v10) = 0;
        ++v7;
        uint64_t v8 = (uint64_t *)v1[64];
        uint64_t v10 = v7;
        uint64_t v9 = v8[v7];
      }
      while (v9);
    }
    else
    {
      unsigned __int16 v7 = 0;
    }
    uint64_t result = heap_Free(*(void **)(*v1 + 8), (uint64_t)v8);
    v1[64] = 0;
  }
  uint64_t v11 = (uint64_t *)v1[65];
  if (v11)
  {
    uint64_t v12 = *v11;
    if (*v11)
    {
      uint64_t v13 = 0;
      unsigned __int16 v14 = 0;
      do
      {
        v1[4] = v12;
        exit_DctRom((uint64_t)(v1 + 2), *(void *)(v1[68] + 8 * v13));
        heap_Free(*(void **)(*v1 + 8), *(void *)(v1[65] + 8 * v13));
        *(void *)(v1[65] + 8 * v13) = 0;
        ++v14;
        uint64_t v11 = (uint64_t *)v1[65];
        uint64_t v13 = v14;
        uint64_t v12 = v11[v14];
      }
      while (v12);
    }
    else
    {
      unsigned __int16 v14 = 0;
    }
    uint64_t result = heap_Free(*(void **)(*v1 + 8), (uint64_t)v11);
    v1[65] = 0;
    unsigned __int16 v7 = v14;
  }
  uint64_t v15 = v1[68];
  if (v15)
  {
    if (v7)
    {
      uint64_t v16 = 0;
      uint64_t v17 = 8 * v7;
      do
      {
        uint64_t v18 = *(void *)(v1[68] + v16);
        if (v18)
        {
          brk_DataClose(*(void *)(*v1 + 24), v18);
          *(void *)(v1[68] + v16) = 0;
        }
        v16 += 8;
      }
      while (v17 != v16);
      uint64_t v15 = v1[68];
    }
    uint64_t result = heap_Free(*(void **)(*v1 + 8), v15);
    v1[68] = 0;
  }
  uint64_t v19 = v1[69];
  if (v19)
  {
    uint64_t v20 = v1[70];
    if (v20)
    {
      brk_DataUnmap(*(void *)(*v1 + 24), v19, v20);
      v1[70] = 0;
      uint64_t v19 = v1[69];
    }
    uint64_t result = (void *)brk_DataClose(*(void *)(*v1 + 24), v19);
    v1[69] = 0;
  }
  v1[72] = 0;
  return result;
}

void *hlp_domainToksFree(void *result)
{
  if (*((_WORD *)result + 808))
  {
    uint64_t v1 = result;
    uint64_t v2 = 0;
    unint64_t v3 = 0;
    uint64_t v4 = result[203];
    do
    {
      if (*(void *)(v4 + v2))
      {
        heap_Free(*(void **)(*v1 + 8), *(void *)(v4 + v2));
        uint64_t v4 = v1[203];
        *(void *)(v4 + v2) = 0;
      }
      if (*(void *)(v4 + v2 + 8))
      {
        heap_Free(*(void **)(*v1 + 8), *(void *)(v4 + v2 + 8));
        uint64_t v4 = v1[203];
        *(void *)(v4 + v2 + 8) = 0;
      }
      if (*(void *)(v4 + v2 + 16))
      {
        heap_Free(*(void **)(*v1 + 8), *(void *)(v4 + v2 + 16));
        uint64_t v4 = v1[203];
        *(void *)(v4 + v2 + 16) = 0;
      }
      if (*(void *)(v4 + v2 + 24))
      {
        heap_Free(*(void **)(*v1 + 8), *(void *)(v4 + v2 + 24));
        uint64_t v4 = v1[203];
        *(void *)(v4 + v2 + 24) = 0;
      }
      ++v3;
      v2 += 32;
    }
    while (v3 < *((unsigned __int16 *)v1 + 808));
    uint64_t result = heap_Free(*(void **)(*v1 + 8), v4);
    v1[203] = 0;
    *((_WORD *)v1 + 808) = 0;
  }
  return result;
}

uint64_t hlp_EnableAddon(uint64_t a1, int a2, uint64_t a3)
{
  unsigned __int16 v14 = &byte_20D5A22AE;
  __s = 0;
  *(_WORD *)&__c[1] = -1;
  if (!a1) {
    return 2306875400;
  }
  *(void *)&__c[3] = 0;
  __c[0] = 0;
  *(_DWORD *)(a3 + 620) = 0;
  uint64_t Str = paramc_ParamGetStr(*(void *)(*(void *)a1 + 40), (uint64_t)"langcode", &__s);
  if ((Str & 0x80000000) == 0)
  {
    lowercase(__s, (uint64_t)__s1);
    lowercase((const char *)(a3 + 80), (uint64_t)__s2);
    if (!strcmp(__s1, __s2))
    {
      uint64_t Str = paramc_ParamGetStr(*(void *)(*(void *)a1 + 40), (uint64_t)"fecfg", &v14);
      if ((Str & 0x80000000) == 0 && !strcmp(v14, (const char *)(a3 + 84)))
      {
        uint64_t Str = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", "addoncomp", &__c[3], &__c[1], __c, 0);
        if (*(_WORD *)&__c[1])
        {
          unsigned __int16 v7 = **(const char ***)&__c[3];
          uint64_t v8 = strchr(**(char ***)&__c[3], __c[0]);
          if (v8)
          {
            *uint64_t v8 = 0;
            unsigned __int16 v7 = **(const char ***)&__c[3];
          }
          int v9 = atoi(v7);
        }
        else
        {
          int v9 = 1;
        }
        if (v9 == *(unsigned __int8 *)(a3 + 105) && *(unsigned char *)(a3 + 104) == 1) {
          *(_DWORD *)(a3 + 620) = 1;
        }
      }
    }
  }
  return Str;
}

uint64_t fe_dctlkp_CheckVersion(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4)
{
  if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) != 0) {
    return 2306875400;
  }
  *(void *)&__c[1] = 0;
  __c[0] = 0;
  *a4 = 0;
  *a3 = 0;
  __int16 v24 = -1;
  uint64_t v8 = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", "versioninfo", &__c[1], &v24, __c, 0);
  if ((v8 & 0x80001FFF) != 0x8000000A && v24)
  {
    __endptr = 0;
    int v9 = **(char ***)&__c[1];
    uint64_t v10 = strchr(**(char ***)&__c[1], __c[0]);
    if (v10)
    {
      *uint64_t v10 = 0;
      int v9 = **(char ***)&__c[1];
    }
    uint64_t v22 = v9;
    *a4 = 1;
    int v15 = strtol(v9, &__endptr, 10);
    BOOL v16 = v15 < 1 || __endptr == 0;
    if (v16
      || *__endptr != 46
      || (unsigned int v17 = strtol(__endptr + 1, &v22, 10), (v17 & 0x80000000) != 0)
      || !v22
      || *v22 != 46
      || (int v18 = strtol(v22 + 1, &__endptr, 10), v18 < 0)
      || !__endptr
      || *__endptr != 46 && *__endptr)
    {
      log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 41006, 0, v11, v12, v13, v14, v20);
      return 2306875392;
    }
    if (v15 > 7) {
      goto LABEL_19;
    }
    if (v15 == 7)
    {
      if (v17 > 4 || v17 == 4 && v18)
      {
LABEL_19:
        log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 5, 0, (uint64_t)"productVersion %d.%d.%d dctVersion %s", v12, v13, v14, 7);
        return v8;
      }
    }
    else if (v15 == 1 && !(v18 | v17))
    {
      *a3 = 0;
      return v8;
    }
    *a3 = 1;
  }
  return v8;
}

uint64_t fe_dctlkp_GetDataBlock(uint64_t a1, int a2, char *a3, void *a4)
{
  uint64_t v25 = 0;
  uint64_t v7 = 2306875399;
  if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) != 0) {
    return 2306875400;
  }
  uint64_t v12 = *(void *)a1;
  if (a3)
  {
    uint64_t v13 = brk_DataOpen(*(void *)(v12 + 24));
    if ((v13 & 0x80000000) != 0)
    {
      return v13;
    }
    else
    {
      uint64_t v14 = brk_DataMap(*(void *)(*(void *)a1 + 24), *(void *)(a1 + 552), 40, *(unsigned int *)(a1 + 8), (uint64_t)&v25);
      if (v14)
      {
        uint64_t v15 = v14;
        brk_DataClose(*(void *)(*(void *)a1 + 24), *(void *)(a1 + 552));
        *(void *)(a1 + 552) = 0;
        return v15;
      }
      else
      {
        if (LH_stricmp(v25, a3))
        {
          uint64_t v16 = 0;
          unsigned int v17 = 0;
          while (v17 < *(_DWORD *)(a1 + 8))
          {
            int v18 = strlen(&v25[v16]);
            uint64_t v16 = v18 + v17 + ((~(_BYTE)v18 - (_BYTE)v17) & 3) + 5;
            unsigned int v17 = v16;
            unsigned int v19 = v16;
            if (!LH_stricmp(&v25[v16], a3)) {
              goto LABEL_16;
            }
          }
          unsigned int v19 = v17;
        }
        else
        {
          unsigned int v19 = 0;
          uint64_t v16 = 0;
        }
LABEL_16:
        if (v19 >= *(_DWORD *)(a1 + 8))
        {
          brk_DataUnmap(*(void *)(*(void *)a1 + 24), *(void *)(a1 + 552), (uint64_t)v25);
          return 2306875412;
        }
        else
        {
          int v20 = strlen(&v25[v16]);
          uint64_t v21 = *(unsigned int *)&v25[v19 + 1 + v20 + ((~(_BYTE)v20 - (_BYTE)v19) & 3)];
          brk_DataUnmap(*(void *)(*(void *)a1 + 24), *(void *)(a1 + 552), (uint64_t)v25);
          uint64_t v7 = brk_DataMap(*(void *)(*(void *)a1 + 24), *(void *)(a1 + 552), v21, 4, (uint64_t)&v25);
          if (!v7)
          {
            uint64_t v22 = *(unsigned int *)v25;
            brk_DataUnmap(*(void *)(*(void *)a1 + 24), *(void *)(a1 + 552), (uint64_t)v25);
            uint64_t v7 = brk_DataMap(*(void *)(*(void *)a1 + 24), *(void *)(a1 + 552), (v21 + 4), v22, (uint64_t)a4);
            if ((v7 & 0x80000000) == 0) {
              *(void *)(a1 + 560) = *a4;
            }
          }
        }
      }
    }
  }
  else
  {
    log_OutPublic(*(void *)(v12 + 32), (uint64_t)"FE_DCTLKP", 41001, 0, v8, v9, v10, v11, v24);
  }
  return v7;
}

uint64_t fe_dctlkp_QueryDictExists(_DWORD *a1, int a2, char *a3, _DWORD *a4)
{
  uint64_t optional_brk_resource = 2306875399;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 62335, 3696) & 0x80000000) != 0) {
    return 2306875400;
  }
  uint64_t v12 = *(void *)(*(void *)a1 + 32);
  if (!a3)
  {
    log_OutPublic(v12, (uint64_t)"FE_DCTLKP", 41001, 0, v8, v9, v10, v11, v16);
    return optional_brk_resource;
  }
  log_OutText(v12, (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_QueryDictExists : %s?", v9, v10, v11, (uint64_t)a3);
  *a4 = 0;
  if ((hlp_SearchDctName((uint64_t)a1, a3, &byte_20D5A22AE) & 0x80000000) == 0)
  {
    uint64_t optional_brk_resource = 0;
    *a4 = 1;
    return optional_brk_resource;
  }
  uint64_t v14 = *(void *)(*(void *)a1 + 24);
  uint64_t optional_brk_resource = loc_fe_dctlkp_query_optional_brk_resource(v14, (uint64_t)"sysdct", a1 + 22, a3, a4);
  if ((optional_brk_resource & 0x80000000) == 0 && !*a4)
  {
    *a4 = 0;
    if (!a1[2]) {
      goto LABEL_14;
    }
    uint64_t v15 = brk_DataOpen(v14);
    if ((v15 & 0x80000000) != 0) {
      return v15;
    }
    uint64_t optional_brk_resource = query_DctRom((uint64_t)(a1 + 4), a3, a1[2], 0, a4);
    if ((optional_brk_resource & 0x80000000) == 0)
    {
      brk_DataClose(v14, 0);
      if (!*a4)
      {
LABEL_14:
        uint64_t optional_brk_resource = loc_fe_dctlkp_query_optional_brk_resource(v14, (uint64_t)"lid", a1 + 42, a3, a4);
        if ((optional_brk_resource & 0x80000000) == 0 && !*a4)
        {
          uint64_t optional_brk_resource = loc_fe_dctlkp_query_optional_brk_resource(v14, (uint64_t)a1 + 2146, a1 + 62, a3, a4);
          if ((optional_brk_resource & 0x80000000) == 0 && !*a4)
          {
            uint64_t optional_brk_resource = loc_fe_dctlkp_query_optional_brk_resource(v14, (uint64_t)a1 + 1890, a1 + 82, a3, a4);
            if ((optional_brk_resource & 0x80000000) == 0 && !*a4) {
              return loc_fe_dctlkp_query_optional_brk_resource(v14, (uint64_t)"clmnn:clmnndic", a1 + 102, a3, a4);
            }
          }
        }
      }
    }
  }
  return optional_brk_resource;
}

uint64_t loc_fe_dctlkp_query_optional_brk_resource(uint64_t a1, uint64_t a2, _DWORD *a3, char *a4, _DWORD *a5)
{
  uint64_t v11 = 0;
  *a5 = 0;
  if (!*a3 || (brk_DataOpenEx(a1, a2, 1, (uint64_t)&v11) & 0x80000000) != 0) {
    return 0;
  }
  uint64_t DctRom = query_DctRom((uint64_t)(a3 + 2), a4, *a3, v11, a5);
  if ((DctRom & 0x80000000) == 0) {
    brk_DataClose(a1, v11);
  }
  return DctRom;
}

uint64_t fe_dctlkp_QueryLidDictExists(unsigned int *a1, int a2, char *a3, int a4, _DWORD *a5)
{
  uint64_t DctRom = 2306875399;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 62335, 3696) & 0x80000000) != 0) {
    return 2306875400;
  }
  uint64_t v21 = 0;
  *a5 = 0;
  uint64_t v14 = *(void *)(*(void *)a1 + 32);
  if (a3)
  {
    log_OutText(v14, (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_QueryLidDictExists : %s?", v11, v12, v13, (uint64_t)a3);
    uint64_t v15 = *(void *)(*(void *)a1 + 24);
    if (a4)
    {
      if ((brk_DataOpenEx(v15, (uint64_t)"lid", 1, (uint64_t)&v21) & 0x80000000) != 0) {
        return 0;
      }
      uint64_t v16 = (uint64_t)(a1 + 44);
      uint64_t v17 = a1[42];
    }
    else
    {
      uint64_t v18 = brk_DataOpen(v15);
      if ((v18 & 0x80000000) != 0) {
        return v18;
      }
      uint64_t v16 = (uint64_t)(a1 + 4);
      uint64_t v17 = a1[2];
    }
    uint64_t DctRom = query_DctRom(v16, a3, v17, v21, a5);
    if ((DctRom & 0x80000000) == 0) {
      brk_DataClose(*(void *)(*(void *)a1 + 24), v21);
    }
  }
  else
  {
    log_OutPublic(v14, (uint64_t)"FE_DCTLKP", 41001, 0, v10, v11, v12, v13, v20);
  }
  return DctRom;
}

uint64_t fe_dctlkp_LangAndDomCheck(uint64_t result, _WORD *a2, __int16 *a3, unsigned int a4, uint64_t a5, unsigned int a6)
{
  uint64_t v6 = (unsigned __int16)*a2;
  if (v6 < a6)
  {
    uint64_t v8 = result;
    int v9 = *(_DWORD *)(a5 + 12);
    unsigned __int16 v10 = a6;
    uint64_t v11 = (int *)(a5 + 32 * v6);
    do
    {
      if (v11[3] - v9 > a4) {
        break;
      }
      int v12 = *v11;
      v11 += 8;
      if (v12 == 36) {
        unsigned __int16 v10 = v6;
      }
      *a2 = ++v6;
    }
    while (a6 != v6);
    if (a6 > v10)
    {
      unint64_t v13 = *(unsigned __int16 *)(result + 1616);
      if (*(_WORD *)(result + 1616))
      {
        uint64_t v14 = 0;
        uint64_t v15 = 0;
        uint64_t v16 = *(const char **)(a5 + 32 * v10 + 24);
        do
        {
          if (v16)
          {
            uint64_t result = strcmp(v16, *(const char **)(*(void *)(v8 + 1624) + v14));
            if (result) {
              __int16 v17 = 999;
            }
            else {
              __int16 v17 = v15;
            }
          }
          else
          {
            __int16 v17 = 999;
          }
          if (++v15 >= v13) {
            break;
          }
          v14 += 32;
        }
        while (v17 == 999);
      }
      else
      {
        __int16 v17 = 999;
      }
      *a3 = v17;
    }
  }
  return result;
}

uint64_t fe_dctlkp_Tokenize(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  int v80 = 0;
  unsigned __int16 v79 = 0;
  unsigned __int16 v77 = 0;
  int v75 = 0;
  int v76 = 0;
  __s = 0;
  unsigned __int16 v73 = 999;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 62335, 3696) & 0x80000000) != 0) {
    return 2306875400;
  }
  log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_Tokenize", v11, v12, v13, v67);
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *))(a1[71] + 104))(a3, a4, 1, 0, (char *)&v80 + 2);
  if ((v14 & 0x80000000) != 0)
  {
LABEL_61:
    uint64_t v18 = v14;
    goto LABEL_64;
  }
  uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, char **, char *))(a1[71] + 176))(a3, a4, HIWORD(v80), 0, &__s, (char *)&v75 + 2);
  if ((v18 & 0x80000000) == 0)
  {
    LOWORD(v80) = 0;
    __int16 v78 = 0;
    unsigned int v19 = __s;
    if ((unsigned __int16)strlen(__s))
    {
      int v20 = 0;
      uint64_t v69 = a6;
      uint64_t v70 = a3;
      unsigned int v72 = a6;
      uint64_t v71 = a4;
      do
      {
        unsigned __int16 v79 = v20;
        unsigned int v21 = strlen(v19);
        if (a6)
        {
          uint64_t v22 = v69;
          uint64_t v23 = (unsigned int *)a5;
          unsigned int v24 = (unsigned int *)a5;
          while (1)
          {
            unsigned int v25 = *v24;
            v24 += 8;
            uint64_t v26 = (1 << v25) & 0x3C8010124021140;
            if (v25 <= 0x39 && v26 != 0)
            {
              unsigned int v28 = v23[3];
              int v29 = *(_DWORD *)(a5 + 12);
              if (v28 > v29 + v20) {
                break;
              }
            }
            uint64_t v23 = v24;
            if (!--v22) {
              goto LABEL_16;
            }
          }
          unsigned int v21 = v28 - v29;
        }
LABEL_16:
        fe_dctlkp_LangAndDomCheck((uint64_t)a1, &v78, (__int16 *)&v73, (unsigned __int16)v20, a5, a6);
        uint64_t v30 = (unsigned __int8 *)&v19[(unsigned __int16)v20];
        unsigned int v31 = v73;
        BOOL v32 = IsAlphaUtf((uint64_t)a1, v30, v73);
        char v33 = (unsigned __int8 *)&__s[(unsigned __int16)v80];
        if (v32)
        {
          __int16 v34 = utf8_determineUTF8CharLength(*v33);
          unsigned int v35 = 0;
          int v76 = 0;
          __int16 v36 = v80;
          uint64_t v37 = __s;
          do
          {
            LOWORD(v80) = v36 + v34;
            __int16 v34 = utf8_determineUTF8CharLength(v37[(unsigned __int16)(v36 + v34)]);
            if (!IsAlphaUtf((uint64_t)a1, (unsigned __int8 *)&__s[(unsigned __int16)v80], v31) || v35 > 0x7E) {
              break;
            }
            ++v35;
            __int16 v36 = v80;
            uint64_t v37 = __s;
          }
          while ((unsigned __int16)v80 < (unsigned __int16)strlen(__s) && v21 > (unsigned __int16)v80);
        }
        else
        {
          BOOL v39 = IsDigitUtf((uint64_t)a1, v33, v31);
          uint64_t v40 = (unsigned __int8 *)&__s[(unsigned __int16)v80];
          if (v39)
          {
            __int16 v41 = utf8_determineUTF8CharLength(*v40);
            unsigned int v42 = 0;
            int v76 = 1;
            __int16 v43 = v80;
            uint64_t v44 = __s;
            do
            {
              LOWORD(v80) = v43 + v41;
              __int16 v41 = utf8_determineUTF8CharLength(v44[(unsigned __int16)(v43 + v41)]);
              if (!IsDigitUtf((uint64_t)a1, (unsigned __int8 *)&__s[(unsigned __int16)v80], v31) || v42 > 0x7E) {
                break;
              }
              ++v42;
              __int16 v43 = v80;
              uint64_t v44 = __s;
            }
            while ((unsigned __int16)v80 < (unsigned __int16)strlen(__s) && v21 > (unsigned __int16)v80);
          }
          else
          {
            if (IsPuncUtf((uint64_t)a1, v40, v31))
            {
              int v76 = 2;
              __int16 v46 = v80 + 1;
LABEL_36:
              LOWORD(v80) = v46;
              goto LABEL_49;
            }
            uint64_t v47 = __s;
            unsigned __int16 v48 = v80;
            unsigned int v49 = __s[(unsigned __int16)v80];
            BOOL v50 = v49 > 0x20 || ((1 << v49) & 0x100002600) == 0;
            if (v50 && v49 != 95)
            {
              __int16 v62 = utf8_determineUTF8CharLength(v49);
              log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Warning - character \"%c\" marked as alpha by default. Assign to domain definitions.", v63, v64, v65, __s[(unsigned __int16)v80]);
              int v76 = 0;
              __int16 v46 = v80 + v62;
              goto LABEL_36;
            }
            int v76 = 3;
            unsigned int v51 = v79;
            do
            {
              LOWORD(v80) = ++v48;
              fe_dctlkp_LangAndDomCheck((uint64_t)a1, &v78, (__int16 *)&v73, v51, a5, v72);
              unsigned int v52 = v47[v48];
              BOOL v53 = v52 > 0x20 || ((1 << v52) & 0x100002600) == 0;
            }
            while ((!v53 || v52 == 95) && (unsigned __int16)strlen(v47) > v48);
          }
        }
LABEL_49:
        uint64_t v54 = a1[71];
        if (v79)
        {
          uint64_t v56 = v70;
          uint64_t v55 = v71;
          uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, void, unsigned __int16 *))(v54 + 80))(v70, v71, v77, &v77);
          if ((v14 & 0x80000000) != 0) {
            goto LABEL_61;
          }
        }
        else
        {
          uint64_t v56 = v70;
          uint64_t v55 = v71;
          uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, unsigned __int16 *))(v54 + 72))(v70, v71, 3, HIWORD(v80), &v77);
          if ((v14 & 0x80000000) != 0) {
            goto LABEL_61;
          }
        }
        uint64_t v57 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, int *, int *))(a1[71] + 160))(v56, v55, v77, 0, 1, &v76, &v75);
        if ((v57 & 0x80000000) != 0
          || (uint64_t v57 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned __int16 *, int *))(a1[71] + 160))(v56, v55, v77, 1, 1, &v79, &v75), (v57 & 0x80000000) != 0))
        {
          uint64_t v18 = v57;
LABEL_63:
          log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_DCTLKP", 41002, 0, v58, v59, v60, v61, v68);
          break;
        }
        uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, int *))(a1[71] + 160))(v56, v55, v77, 2, 1, &v80, &v75);
        if ((v18 & 0x80000000) != 0) {
          goto LABEL_63;
        }
        int v20 = (unsigned __int16)v80;
        unsigned int v19 = __s;
        a6 = v72;
      }
      while ((unsigned __int16)v80 < (unsigned __int16)strlen(__s));
    }
  }
LABEL_64:
  log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Leaving fe_dctlkp_Tokenize", v15, v16, v17, v68);
  return v18;
}

BOOL IsAlphaUtf(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  if (a3 != 999)
  {
    uint64_t v6 = *(char **)(*(void *)(a1 + 1624) + 32 * a3 + 8);
    if (v6)
    {
      if (a2) {
        return utf8_strchr(v6, a2) != 0;
      }
      return 0;
    }
  }
  BOOL result = 0;
  unsigned int v8 = *a2;
  BOOL v9 = v8 > 0x20 || ((1 << v8) & 0x100002600) == 0;
  if (v9 && v8 != 95)
  {
    if (!IsPuncUtf(a1, a2, a3)) {
      return !IsDigitUtf(a1, a2, a3);
    }
    return 0;
  }
  return result;
}

BOOL IsDigitUtf(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  if (a3 == 999) {
    return *a2 - 48 < 0xA;
  }
  unint64_t v3 = *(char **)(*(void *)(a1 + 1624) + 32 * a3 + 16);
  if (!v3) {
    return *a2 - 48 < 0xA;
  }
  if (a2) {
    return utf8_strchr(v3, a2) != 0;
  }
  return 0;
}

BOOL IsPuncUtf(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  if (a3 == 999 || !*(void *)(*(void *)(a1 + 1624) + 32 * a3 + 24))
  {
    return loc_fe_dctlkp_IsPunctUtf(a1, a2);
  }
  else
  {
    return a2 && utf8_strchr(*(char **)(*(void *)(a1 + 1624) + 32 * a3 + 24), a2) != 0;
  }
}

uint64_t fe_dctlkp_PartLookupUtf(uint64_t a1, int a2, char *a3, const char *a4, void *a5, __int16 *a6, unsigned char *a7, uint64_t a8)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (!a8) {
    return a8;
  }
  int v14 = a8 - 1;
  if (a8 != 1)
  {
    unsigned int v16 = 0;
    __int16 v17 = *a6;
    do
    {
      __strcpy_chk();
      LH_itoa(v16, v19, 0xAu);
      __strcat_chk();
      *a6 = v17;
      a8 = loc_fe_dctlkp_LookupUtf(a1, a2, v20, a4, a5, a6, a7, 0);
      if ((a8 & 0x80000000) != 0) {
        break;
      }
      if (*a6) {
        break;
      }
    }
    while (v14 != v16++);
    return a8;
  }
  return loc_fe_dctlkp_LookupUtf(a1, a2, a3, a4, a5, a6, a7, 0);
}

uint64_t fe_dctlkp_PartLookupAddonDct(uint64_t a1, int a2, char *a3, const char *a4, void *a5, unsigned __int16 *a6, unsigned char *a7, uint64_t a8, _DWORD *a9)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  if (!a8) {
    return a8;
  }
  int v14 = a8 - 1;
  if (a8 != 1)
  {
    unsigned int v16 = 0;
    unsigned __int16 v17 = *a6;
    do
    {
      __strcpy_chk();
      LH_itoa(v16, v20, 0xAu);
      __strcat_chk();
      *a6 = v17;
      a8 = fe_dctlkp_LookupAddonDct(a1, a2, v21, a4, a5, a6, a7, a9);
      if ((a8 & 0x80000000) != 0) {
        break;
      }
      if (*a6) {
        break;
      }
    }
    while (v14 != v16++);
    return a8;
  }
  return fe_dctlkp_LookupAddonDct(a1, a2, a3, a4, a5, a6, a7, a9);
}

uint64_t fe_dctlkp_LookupAddonDct(uint64_t a1, int a2, char *a3, const char *a4, void *a5, unsigned __int16 *a6, unsigned char *a7, _DWORD *a8)
{
  uint64_t v13 = a1;
  __int16 v82 = 0;
  if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) != 0) {
    return 2306875400;
  }
  unsigned int Str = paramc_ParamGetStr(*(void *)(*(void *)v13 + 40), (uint64_t)"addondct_extended_lookup", &v82);
  if ((Str & 0x80000000) == 0 && !strcmp(v82, "yes"))
  {
    log_OutText(*(void *)(*(void *)v13 + 32), (uint64_t)"FE_DCTLKP", 5, 0, (uint64_t)"<%s> enables extended lookup (both DDU and system dct)", v15, v16, v17, (uint64_t)"addondct_extended_lookup");
    char v18 = 1;
  }
  else
  {
    char v18 = 0;
  }
  unsigned __int16 v74 = *a6;
  unsigned int v20 = *(unsigned __int16 *)(v13 + 488);
  int64_t v81 = a5;
  if (!*(_WORD *)(v13 + 488))
  {
    unsigned __int16 v52 = 0;
    uint64_t v23 = 0;
    char v54 = 1;
    goto LABEL_54;
  }
  char v69 = v18;
  unsigned int v72 = Str;
  unsigned int v73 = 0;
  uint64_t v70 = a8;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v80 = v13;
  while (1)
  {
    uint64_t v79 = v21;
    uint64_t v24 = *(void *)(*(void *)(v13 + 496) + 8 * v21);
    if (!*(_DWORD *)(v24 + 620)) {
      goto LABEL_46;
    }
    if (strstr(a3, "femwg2p"))
    {
      unsigned int v25 = 0;
      uint64_t v26 = "addonmwg2p";
      goto LABEL_20;
    }
    if (strstr(a3, "femwtn"))
    {
      unsigned int v25 = 0;
      uint64_t v26 = "addonmwtn";
      goto LABEL_20;
    }
    if (!strstr(a3, "g2p")) {
      break;
    }
    int v27 = *(unsigned __int8 *)(v24 + 106);
    uint64_t v26 = (char *)(v24 + 106);
    if (v27) {
      goto LABEL_19;
    }
LABEL_46:
    uint64_t v21 = v79 + 1;
    if (v79 + 1 >= (unint64_t)v20)
    {
      unsigned __int16 v52 = v22;
      if (v73)
      {
        a8 = v70;
        char v53 = v69 ^ 1;
        if (!v70) {
          char v53 = 1;
        }
        if (v53)
        {
          if (v70) {
            *uint64_t v70 = 1;
          }
          *a6 = 0;
          uint64_t v55 = v72;
          goto LABEL_68;
        }
        char v54 = 0;
      }
      else
      {
        char v54 = 1;
        a8 = v70;
      }
LABEL_54:
      *a6 = v74;
      uint64_t v55 = loc_fe_dctlkp_LookupUtf(v13, a2, a3, a4, v81, a6, a7, 0);
      if ((v55 & 0x80000000) != 0)
      {
        uint64_t v19 = v55;
        goto LABEL_82;
      }
      if (a8)
      {
        if ((v54 & 1) == 0 && !*a6)
        {
          *a8 = 1;
          *a7 = 14;
          goto LABEL_69;
        }
        *a8 = 0;
      }
      unsigned int v56 = *a6;
      if (*a6)
      {
        unint64_t v57 = 0;
        do
        {
          uint64_t v58 = *(unsigned char **)(*v81 + 8 * v57);
          char v59 = *v58;
          if (*v58)
          {
            uint64_t v60 = v58 + 1;
            do
            {
              if (*a7 == v59) {
                *(v60 - 1) = 14;
              }
              int v61 = *v60++;
              char v59 = v61;
            }
            while (v61);
            unsigned int v56 = *a6;
          }
          ++v57;
        }
        while (v57 < v56);
      }
LABEL_68:
      *a7 = 14;
      uint64_t v19 = v55;
      if (!a8)
      {
LABEL_70:
        if (v52)
        {
          uint64_t v62 = 0;
          while (1)
          {
            uint64_t v63 = *a6;
            if ((int)v62 + (int)v63 >= 20 * *(unsigned __int16 *)(v13 + 578)) {
              break;
            }
            if (v23) {
              strcpy(*(char **)(*(void *)(v13 + 528) + 8 * (v62 + v63)), *(const char **)(v23 + 8 * v62));
            }
            if (v52 == ++v62)
            {
              LOWORD(v62) = v52;
              break;
            }
          }
        }
        else
        {
          LOWORD(v62) = 0;
        }
        *a6 += v62;
LABEL_82:
        LOWORD(v41) = v52;
        uint64_t v34 = v23;
        if (v23) {
          goto LABEL_83;
        }
        return v19;
      }
LABEL_69:
      uint64_t v19 = v55;
      if (!*a8) {
        goto LABEL_82;
      }
      goto LABEL_70;
    }
  }
  if (!*(unsigned char *)(v24 + 362)) {
    goto LABEL_46;
  }
  uint64_t v26 = (char *)(v24 + 362);
LABEL_19:
  unsigned int v25 = (unsigned __int16)atoi(v26 + 6);
LABEL_20:
  if (v25 < v73) {
    goto LABEL_46;
  }
  unsigned int v71 = v25;
  if (!*v26) {
    goto LABEL_46;
  }
  while (1)
  {
    unsigned int v28 = strchr(v26, 124);
    int v76 = v28;
    if (v28)
    {
      int v75 = *v28;
      *unsigned int v28 = 0;
    }
    else
    {
      int v75 = 0;
    }
    *a6 = v74;
    unsigned int v72 = loc_fe_dctlkp_LookupUtf(v13, a2, v26, a4, a5, a6, a7, *(unsigned int **)(*(void *)(v13 + 496) + 8 * v79));
    if ((v72 & 0x80000000) != 0)
    {
      unsigned __int16 v52 = v22;
      uint64_t v19 = v72;
      goto LABEL_82;
    }
    if (*a6) {
      break;
    }
LABEL_40:
    if (v76 && v75)
    {
      *int v76 = v75;
      a5 = v81;
    }
    else
    {
      a5 = v81;
      if (!v76) {
        goto LABEL_45;
      }
    }
    uint64_t v26 = v76 + 1;
    if (!v76[1])
    {
LABEL_45:
      unsigned int v20 = *(unsigned __int16 *)(v13 + 488);
      goto LABEL_46;
    }
  }
  uint64_t v29 = heap_Realloc(*(uint64_t **)(*(void *)v13 + 8), v23, 8 * (*a6 + (unint64_t)(unsigned __int16)v22));
  if (!v29)
  {
    unsigned __int16 v52 = v22;
    log_OutPublic(*(void *)(*(void *)v13 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v30, v31, v32, v33, v68);
    uint64_t v19 = 2306875402;
    goto LABEL_82;
  }
  uint64_t v34 = v29;
  bzero((void *)(v29 + 8 * (unsigned __int16)v22), 8 * *a6);
  if (!*a6)
  {
    uint64_t v41 = v22;
LABEL_39:
    uint64_t v13 = v80;
    log_OutEvent(*(uint64_t ***)(*(void *)v80 + 32), 28, "%s%s", v35, v36, v37, v38, v39, "ADDON_NAME");
    uint64_t v23 = v34;
    uint64_t v22 = v41;
    unsigned int v73 = v71;
    goto LABEL_40;
  }
  uint64_t v40 = 0;
  LODWORD(v41) = v22;
  while (1)
  {
    int v42 = strlen(*(const char **)(*v81 + 8 * v40));
    __int16 v43 = (char *)heap_Realloc(*(uint64_t **)(*(void *)v80 + 8), *(void *)(v34 + 8 * (unsigned __int16)v41), (v42 + 1));
    if (!v43) {
      break;
    }
    *(void *)(v34 + 8 * (unsigned __int16)v41) = v43;
    strcpy(v43, *(const char **)(*v81 + 8 * v40));
    unsigned __int16 v48 = *(unsigned char **)(v34 + 8 * (unsigned __int16)v41);
    char v49 = *v48;
    if (*v48)
    {
      BOOL v50 = v48 + 1;
      do
      {
        if (*a7 == v49) {
          *(v50 - 1) = 14;
        }
        int v51 = *v50++;
        char v49 = v51;
      }
      while (v51);
    }
    uint64_t v41 = (v41 + 1);
    if (++v40 >= (unint64_t)*a6) {
      goto LABEL_39;
    }
  }
  uint64_t v13 = v80;
  log_OutPublic(*(void *)(*(void *)v80 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v44, v45, v46, v47, v68);
  uint64_t v19 = 2306875402;
LABEL_83:
  if ((_WORD)v41)
  {
    uint64_t v64 = (unsigned __int16)v41;
    uint64_t v65 = (uint64_t *)v34;
    do
    {
      uint64_t v66 = *v65++;
      heap_Free(*(void **)(*(void *)v13 + 8), v66);
      --v64;
    }
    while (v64);
  }
  heap_Free(*(void **)(*(void *)v13 + 8), v34);
  return v19;
}

uint64_t fe_dctlkp_InitStatus(uint64_t a1)
{
  if (!a1) {
    return 2306875399;
  }
  uint64_t result = 0;
  *(void *)a1 = 0;
  *(_WORD *)(a1 + 8) = 0;
  return result;
}

BOOL fe_dctlkp_IsValidStatus(_DWORD *a1)
{
  return *a1 != 0;
}

uint64_t fe_dctlkp_InitEntry(uint64_t a1)
{
  if (!a1) {
    return 2306875399;
  }
  uint64_t result = 0;
  *(_DWORD *)a1 = -1;
  *(_WORD *)(a1 + 4) = 0;
  *(void *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 16) = 0;
  return result;
}

BOOL fe_dctlkp_IsValidEntry(_DWORD *a1)
{
  return *a1 >= 0;
}

uint64_t fe_dctlkp_DoLookupStep(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7)
{
  uint64_t v13 = 2306875399;
  if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) != 0) {
    return 2306875400;
  }
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_DoLookupStep (%d byte(s) of '%s')", v14, v15, v16, a7);
  if (a5)
  {
    *(_DWORD *)a5 = -1;
    *(_WORD *)(a5 + 4) = 0;
    *(void *)(a5 + 8) = 0;
    *(_WORD *)(a5 + 16) = 0;
    int v17 = WordToHashOpt(a3 + 8, a6, 0, (unsigned __int16)a7 - 1, 0, a4);
    *(_DWORD *)a5 = v17;
    if (v17 == -2) {
      uint64_t v13 = 10;
    }
    else {
      uint64_t v13 = 0;
    }
    int v18 = *(_DWORD *)(a4 + 8);
    *(void *)(a5 + 8) = *(void *)a4;
    *(_DWORD *)(a5 + 16) = v18;
  }
  return v13;
}

uint64_t fe_dctlkp_GetEntryContents(uint64_t a1, uint64_t a2, void *a3, int *a4, unsigned __int8 **a5, _WORD *a6, unsigned char *a7, unsigned char *a8)
{
  if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) != 0) {
    return 2306875400;
  }
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_GetEntryContents", v16, v17, v18, v21);
  uint64_t v19 = fe_dctlkp_LookupFromStateAddress(a1, a2, a3, *a4, a5, a6, a8);
  *a7 = GetFieldSeparator((uint64_t)(a3 + 1));
  return v19;
}

uint64_t fe_dctlkp_LookupFromStateAddress(uint64_t a1, uint64_t a2, void *a3, int a4, unsigned __int8 **a5, _WORD *a6, unsigned char *a7)
{
  v50[7] = *MEMORY[0x263EF8340];
  if (!a1) {
    return 2306875400;
  }
  v50[0] = a3[2];
  BOOL v9 = *a5;
  *a7 = 1;
  if (a4 < 0) {
    goto LABEL_8;
  }
  int v11 = DecoAddr(a3 + 1, a4);
  if (v11 == -2) {
    return 10;
  }
  if (v11 < 0
    || brk_DataMap(a3[4], a3[5], (*(_DWORD *)(a3[3] + 132) + v11), *(unsigned __int16 *)(*(void *)a3[3] + 52), (uint64_t)v50))
  {
LABEL_8:
    uint64_t result = 0;
    *a7 = 0;
  }
  else
  {
    uint64_t v13 = 0;
    LOWORD(v14) = 0;
    int v15 = 0;
    LOBYTE(v16) = *(unsigned char *)v50[0];
    do
    {
      v9[(__int16)v15++] = v16;
      uint64_t v17 = (unsigned __int8 **)a3[3];
      uint64_t v18 = *v17;
      do
      {
        uint64_t v14 = (__int16)v14;
        uint64_t v19 = v9[(__int16)v14];
        uint64_t v20 = 2 * (v19 - v18[6]);
        unsigned int v21 = v17[2][v20];
        if (v17[2][v20])
        {
          __int16 v22 = v15 - 1;
          do
          {
            if ((int)v14 < (__int16)(v15 - 1))
            {
              uint64_t v23 = v22;
              do
              {
                v9[v23 + 1] = v9[v23];
                --v23;
              }
              while (v23 > v14);
              uint64_t v17 = (unsigned __int8 **)a3[3];
              LODWORD(v19) = v9[v14];
              uint64_t v18 = *v17;
            }
            ++v15;
            v9[v14 + 1] = v17[2][2 * (v19 - (unint64_t)v18[6]) + 1];
            v9[v14] = v21;
            uint64_t v17 = (unsigned __int8 **)a3[3];
            uint64_t v18 = *v17;
            ++v22;
            LODWORD(v19) = v21;
            unsigned int v21 = v17[2][2 * (v21 - (unint64_t)(*v17)[6])];
          }
          while (v21);
        }
        LODWORD(v14) = (__int16)(v14 + 1);
      }
      while ((int)v14 < (__int16)v15);
      ++v13;
      uint64_t v24 = v50[0];
      unsigned int v16 = *(unsigned __int8 *)(v50[0] + v13);
      unsigned int v25 = v18[10];
    }
    while (v16 != v18[8] && (v16 < v25 || v16 > v18[11]));
    unsigned int v26 = *v9;
    if (v26 >= v25)
    {
      while (1)
      {
        int v27 = v26;
        unsigned int v28 = v18[11];
        uint64_t v24 = v50[0];
        if (v26 > v28) {
          break;
        }
        int v29 = v18[8];
        int v30 = *(unsigned __int8 *)(v50[0] + (int)v13);
        if (v30 == v29)
        {
LABEL_29:
          int v33 = 1;
        }
        else
        {
          uint64_t v31 = (unsigned __int8 *)(v50[0] + (int)v13 + 1);
          while (v30 < v25 || v28 < v30)
          {
            LODWORD(v13) = v13 + 1;
            int v32 = *v31++;
            LOBYTE(v30) = v32;
            if (v32 == v29) {
              goto LABEL_29;
            }
          }
          int v33 = 0;
          LOBYTE(v29) = v30;
        }
        LODWORD(v13) = v13 + v33;
        unsigned int v34 = v25;
        unsigned __int8 v35 = v25 - 1;
        if (v29 <= v28 && v29 >= v34) {
          unsigned __int8 v35 = v29;
        }
        if (v35 >= v26)
        {
          LODWORD(v13) = v13 + 1;
        }
        else
        {
          LOWORD(v37) = 0;
          int v38 = 0;
          uint64_t v39 = v17[2];
          uint64_t v40 = v18[6];
          uint64_t v13 = (int)v13;
          do
          {
            uint64_t v41 = (__int16)v38++;
            *((unsigned char *)&v50[1] + v41 + 7) = *(unsigned char *)(v24 + v13);
            do
            {
              uint64_t v37 = (__int16)v37;
              uint64_t v42 = *((unsigned __int8 *)&v50[1] + (__int16)v37 + 7);
              if (v39[2 * (v42 - v40)])
              {
                __int16 v43 = v38 - 1;
                do
                {
                  if ((int)v37 < (__int16)(v38 - 1))
                  {
                    uint64_t v44 = v43;
                    do
                    {
                      *((unsigned char *)&v50[2] + v44) = *((unsigned char *)&v50[1] + v44 + 7);
                      --v44;
                    }
                    while (v44 > v37);
                    uint64_t v42 = *((unsigned __int8 *)&v50[1] + v37 + 7);
                  }
                  uint64_t v45 = &v39[2 * (v42 - v40)];
                  *((unsigned char *)&v50[2] + v37) = v45[1];
                  uint64_t v42 = *v45;
                  *((unsigned char *)&v50[1] + v37 + 7) = v42;
                  ++v38;
                  ++v43;
                }
                while (v39[2 * (v42 - v40)]);
              }
              LODWORD(v37) = (__int16)(v37 + 1);
              LOBYTE(v26) = v26 - 1;
            }
            while ((int)v37 < (__int16)v38 && v26 >= v35);
            ++v13;
          }
          while (v26 >= v35);
          int v46 = v27 - v35;
          if ((__int16)v15 >= 2)
          {
            uint64_t v47 = (unsigned __int16)v15 - 1;
            uint64_t v48 = (__int16)(v15 + v27 - v35) - 1;
            do
              v9[v48--] = v9[v47--];
            while (v47);
          }
          if ((v46 & 0x80000000) == 0)
          {
            int v49 = 0;
            do
            {
              v9[(__int16)v49] = *((unsigned char *)&v50[1] + (__int16)v49 + 7);
              ++v49;
            }
            while (v46 >= (__int16)v49);
          }
          LOWORD(v15) = v15 + v46;
          LOBYTE(v26) = v35;
        }
        uint64_t v17 = (unsigned __int8 **)a3[3];
        uint64_t v18 = *v17;
        unsigned int v25 = (*v17)[10];
        if (v25 > v26)
        {
          uint64_t v24 = v50[0];
          break;
        }
      }
    }
    brk_DataUnmap(a3[4], a3[5], v24);
    uint64_t result = 0;
    *a6 = v15;
  }
  return result;
}

uint64_t fe_dctlkp_GetNextEntry(uint64_t a1, uint64_t a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  char v10 = 0;
  int v9 = 0;
  __int16 v12 = 0;
  *(void *)__s = 0;
  uint64_t v3 = a1 + 8;
  uint64_t v7 = *(void *)(a2 + 8);
  int v8 = *(_DWORD *)(a2 + 16);
  ++*(_WORD *)(a2 + 4);
  __strcat_chk();
  LH_itoa(*(unsigned __int16 *)(a2 + 4), (char *)&v9, 0xAu);
  __strcat_chk();
  __int16 v4 = strlen(__s);
  int v5 = WordToHashOpt(v3, (uint64_t)__s, 0, v4 - 1, 0, (uint64_t)&v7);
  *(_DWORD *)a2 = v5;
  if (v5 == -2) {
    return 10;
  }
  else {
    return 0;
  }
}

uint64_t loc_fe_dctlkp_LookupUtf(uint64_t a1, int a2, char *a3, const char *a4, void *a5, _WORD *a6, unsigned char *a7, unsigned int *a8)
{
  uint64_t v120 = *MEMORY[0x263EF8340];
  __int16 v116 = 0;
  char v115 = 0;
  *(_DWORD *)__s2 = 0;
  uint64_t v8 = 2306875402;
  __int16 v119 = 0;
  *(void *)__s = 0;
  uint64_t v9 = 2306875399;
  if (a3)
  {
    if (a4)
    {
      int v11 = a5;
      if (a5)
      {
        if (a6 && a7)
        {
          if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) == 0)
          {
            int v117 = 0;
            int v113 = 0;
            log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 5, 0, (uint64_t)"Entering fe_dctlkp_Lookup: searching %s in %s", v17, v18, v19, (uint64_t)a4);
            uint64_t v112 = 0;
            uint64_t v110 = 0;
            int v111 = 0;
            if (a8)
            {
              uint64_t v23 = heap_strdup(*(void *)(*(void *)a1 + 8), a3);
              if (v23)
              {
                __src = v23;
                LH_itoa(*((unsigned __int16 *)a8 + 36), __s, 0xAu);
                unsigned int v28 = a8;
LABEL_28:
                int v35 = (unsigned __int16)*a6;
                if ((v35 - 1) < 2 || v35 == 0xFFFF)
                {
                  BOOL v108 = strncmp(a3, "ml2mw", 5uLL) == 0;
                  *a6 = 0;
                }
                else
                {
                  BOOL v108 = 1;
                }
                int v36 = hlp_SearchDctName(a1, __src, __s);
                if ((v36 & 0x80000000) == 0)
                {
                  uint64_t v37 = 0;
                  unsigned int v38 = 0;
                  *((void *)v28 + 3) = *(void *)(*(void *)(a1 + 520) + 8 * (unsigned __int16)v36);
                  BOOL v39 = v108;
LABEL_34:
                  *a7 = GetFieldSeparator((uint64_t)(v28 + 2));
                  int v40 = (__int16)(strlen(a4) + 5);
                  if (v40 > *(__int16 *)(a1 + 582))
                  {
                    uint64_t v41 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 536), (unsigned __int16)v40);
                    if (!v41) {
                      goto LABEL_75;
                    }
                    *(_WORD *)(a1 + 582) = v40;
                    *(void *)(a1 + 536) = v41;
                  }
                  *a6 = 0;
                  *int v11 = *(void *)(a1 + 528);
                  unsigned __int16 v107 = v11;
                  if (v38 > *(unsigned __int16 *)(a1 + 580))
                  {
                    if (*(_WORD *)(a1 + 578))
                    {
                      unsigned __int16 v46 = 0;
                      do
                      {
                        uint64_t v47 = v46;
                        uint64_t v48 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(*(void *)(a1 + 528) + 8 * v46), v38 + 1);
                        if (!v48)
                        {
                          log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v49, v50, v51, v52, v106);
                          uint64_t v37 = 2306875402;
                          int v11 = v107;
                          goto LABEL_84;
                        }
                        *(void *)(*(void *)(a1 + 528) + 8 * v47) = v48;
                        unsigned __int16 v46 = v47 + 1;
                      }
                      while (20 * *(unsigned __int16 *)(a1 + 578) - 1 > (unsigned __int16)(v47 + 1));
                    }
                    *(_WORD *)(a1 + 580) = v38;
                    int v11 = v107;
                    BOOL v39 = v108;
                  }
                  LOWORD(v53) = *a6;
                  if (v39 || !*a6)
                  {
                    while (1)
                    {
                      HIWORD(v117) = 0;
                      if ((unsigned __int16)v53 == 1)
                      {
                        uint64_t v110 = v112;
                        int v111 = v113;
                      }
                      else
                      {
                        if (!(_WORD)v53)
                        {
                          strcpy(*(char **)(a1 + 536), a4);
                          goto LABEL_51;
                        }
                        uint64_t v112 = v110;
                        int v113 = v111;
                      }
                      **(_WORD **)(a1 + 536) = 23;
                      LH_itoa((unsigned __int16)*a6, __s2, 0xAu);
                      strcat(*(char **)(a1 + 536), __s2);
LABEL_51:
                      char v54 = *(const char **)(a1 + 536);
                      LOWORD(v117) = strlen(v54) - 1;
                      unsigned int v55 = DctLookup((uint64_t)(v28 + 2), (uint64_t)v54, (unsigned __int16 *)&v117 + 1, (__int16 *)&v117, 0, &v116, (uint64_t)&v112);
                      if (v55)
                      {
                        if ((v55 & 0x1FFF) == 0x14) {
                          unsigned int v70 = 0;
                        }
                        else {
                          unsigned int v70 = v55;
                        }
                        if ((v55 & 0x1FFF) == 0xA) {
                          uint64_t v37 = 2306875402;
                        }
                        else {
                          uint64_t v37 = v70;
                        }
                        break;
                      }
                      if ((unsigned __int16)*a6 + 2 > 20 * *(unsigned __int16 *)(a1 + 578))
                      {
                        uint64_t v56 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 528), 160 * *(unsigned __int16 *)(a1 + 578) + 160);
                        if (!v56) {
                          goto LABEL_75;
                        }
                        *(void *)(a1 + 528) = v56;
                        __int16 v57 = 20 * *(_WORD *)(a1 + 578);
                        if (*(_WORD *)(a1 + 578)) {
                          unsigned __int16 v58 = v57 - 1;
                        }
                        else {
                          unsigned __int16 v58 = 0;
                        }
                        unsigned int v59 = v58;
                        unint64_t v60 = v58;
                        bzero((void *)(v56 + 8 * v58), 8 * (((unsigned __int16)(v57 + 20) & 0xFFFC) - (unint64_t)v58));
                        __int16 v61 = *(_WORD *)(a1 + 578);
                        if (v59 < (unsigned __int16)(20 * v61 + 19))
                        {
                          int v11 = v107;
                          while (1)
                          {
                            uint64_t v62 = heap_Alloc(*(void *)(*(void *)a1 + 8), *(unsigned __int16 *)(a1 + 580) + 1);
                            if (!v62) {
                              break;
                            }
                            *(void *)(*(void *)(a1 + 528) + 8 * v60++) = v62;
                            __int16 v61 = *(_WORD *)(a1 + 578);
                            if (v60 >= (unsigned __int16)(20 * v61 + 19))
                            {
                              unint64_t v60 = (unsigned __int16)v60;
                              goto LABEL_63;
                            }
                          }
LABEL_75:
                          log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v42, v43, v44, v45, v106);
                          uint64_t v37 = 2306875402;
                          break;
                        }
                        int v11 = v107;
LABEL_63:
                        *(void *)(*(void *)(a1 + 528) + 8 * v60) = 0;
                        *(_WORD *)(a1 + 578) = v61 + 1;
                      }
                      if (v116 < 1)
                      {
                        LOWORD(v63) = 0;
                      }
                      else
                      {
                        uint64_t v63 = 0;
                        do
                        {
                          *(unsigned char *)(*(void *)(*(void *)(a1 + 528) + 8 * (unsigned __int16)*a6) + v63) = *(unsigned char *)(*((void *)v28 + 6) + v63);
                          ++v63;
                        }
                        while (v63 < v116);
                      }
                      *(unsigned char *)(*(void *)(*(void *)(a1 + 528) + 8 * (unsigned __int16)*a6) + (unsigned __int16)v63) = 0;
                      int v53 = (unsigned __int16)(*a6)++ + 1;
                      if (!v39 && (v53 & 0x10000) == 0)
                      {
                        uint64_t v37 = 0;
                        break;
                      }
                    }
                  }
LABEL_84:
                  uint64_t v71 = (uint64_t)__src;
                  char v72 = 1;
                  uint64_t v8 = v37;
                  goto LABEL_109;
                }
                uint64_t v64 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 544), 8 * *(unsigned __int16 *)(a1 + 576) + 16);
                if (!v64) {
                  goto LABEL_107;
                }
                *(void *)(a1 + 544) = v64;
                uint64_t v69 = *(unsigned __int16 *)(a1 + 576);
                *(void *)(v64 + 8 * v69) = 0;
                *(void *)(*(void *)(a1 + 544) + 8 * v69 + 8) = 0;
                if (!a8)
                {
                  uint64_t v73 = brk_DataOpen(*(void *)(*(void *)a1 + 24));
                  if ((v73 & 0x80000000) != 0)
                  {
                    char v72 = 0;
                    uint64_t v8 = v73;
                    goto LABEL_108;
                  }
                  uint64_t v69 = *(unsigned __int16 *)(a1 + 576);
                }
                uint64_t v74 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 520), 8 * v69 + 16);
                if (!v74) {
                  goto LABEL_107;
                }
                *(void *)(a1 + 520) = v74;
                uint64_t v75 = *(unsigned __int16 *)(a1 + 576);
                *(void *)(v74 + 8 * v75) = 0;
                *(void *)(*(void *)(a1 + 520) + 8 * v75 + 8) = 0;
                uint64_t v76 = heap_Calloc(*(void **)(*(void *)a1 + 8), 1, 144);
                if (!v76) {
                  goto LABEL_107;
                }
                uint64_t v77 = *(unsigned __int16 *)(a1 + 576);
                *(void *)(*(void *)(a1 + 520) + 8 * v77) = v76;
                *((void *)v28 + 3) = *(void *)(*(void *)(a1 + 520) + 8 * v77);
                uint64_t inited = init_DctRom((uint64_t)(v28 + 2), a3, *v28, *(void *)(*(void *)(a1 + 544) + 8 * v77));
                uint64_t v37 = inited;
                if ((inited & 0x80000000) != 0)
                {
                  if ((inited & 0x1FFF) == 0x14)
                  {
                    heap_Free(*(void **)(*(void *)a1 + 8), *(void *)(*(void *)(a1 + 520) + 8 * *(unsigned __int16 *)(a1 + 576)));
                    uint64_t v105 = *(unsigned __int16 *)(a1 + 576);
                    *(void *)(*(void *)(a1 + 520) + 8 * v105) = 0;
                    brk_DataClose(*(void *)(*(void *)a1 + 24), *(void *)(*(void *)(a1 + 544) + 8 * v105));
                    char v72 = 0;
                    uint64_t v8 = 0;
                    *(void *)(*(void *)(a1 + 544) + 8 * *(unsigned __int16 *)(a1 + 576)) = 0;
                  }
                  else
                  {
                    char v72 = 0;
                    uint64_t v8 = inited;
                  }
                  goto LABEL_108;
                }
                uint64_t v79 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 512), 8 * *(unsigned __int16 *)(a1 + 576) + 16);
                if (!v79) {
                  goto LABEL_107;
                }
                *(void *)(a1 + 512) = v79;
                uint64_t v80 = *(unsigned __int16 *)(a1 + 576);
                *(void *)(v79 + 8 * v80) = 0;
                *(void *)(*(void *)(a1 + 512) + 8 * v80 + 8) = 0;
                unsigned __int16 v81 = strlen(__s);
                int v82 = strlen(__src);
                int v83 = v81 ? v81 + 1 : 0;
                uint64_t v84 = heap_Alloc(*(void *)(*(void *)a1 + 8), (v82 + v83 + 1));
                if (!v84) {
                  goto LABEL_107;
                }
                uint64_t v85 = *(unsigned __int16 *)(a1 + 576);
                *(void *)(*(void *)(a1 + 512) + 8 * v85) = v84;
                unsigned __int16 v86 = *(void **)(*(void *)(a1 + 512) + 8 * v85);
                if (v81)
                {
                  memcpy(v86, __s, v81);
                  *(unsigned char *)(*(void *)(*(void *)(a1 + 512) + 8 * *(unsigned __int16 *)(a1 + 576)) + v81) = 95;
                  unsigned __int16 v86 = (void *)(*(void *)(*(void *)(a1 + 512) + 8 * *(unsigned __int16 *)(a1 + 576)) + v81 + 1);
                }
                strcpy((char *)v86, __src);
                MaxOutLeuint64_t n = GetMaxOutLen((uint64_t)(v28 + 2));
                if (MaxOutLen)
                {
                  unsigned int v38 = MaxOutLen;
                  BOOL v39 = v108;
                  if (MaxOutLen <= *(unsigned __int16 *)(a1 + 580))
                  {
LABEL_106:
                    ++*(_WORD *)(a1 + 576);
                    goto LABEL_34;
                  }
                  uint64_t v92 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *((void *)v28 + 6), MaxOutLen + 1);
                  if (v92)
                  {
                    *(void *)(a1 + 56) = v92;
                    *(void *)(a1 + 136) = v92;
                    *(void *)(a1 + 216) = v92;
                    *(void *)(a1 + 296) = v92;
                    *(void *)(a1 + 376) = v92;
                    *(void *)(a1 + 456) = v92;
                    uint64_t v93 = *(unsigned __int16 *)(a1 + 488);
                    if (*(_WORD *)(a1 + 488))
                    {
                      __int16 v94 = *(uint64_t **)(a1 + 496);
                      do
                      {
                        uint64_t v95 = *v94++;
                        *(void *)(v95 + 48) = v92;
                        --v93;
                      }
                      while (v93);
                    }
                    goto LABEL_106;
                  }
LABEL_107:
                  log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v65, v66, v67, v68, v106);
                  char v72 = 0;
                  goto LABEL_108;
                }
                log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 41001, 0, v88, v89, v90, v91, v106);
                char v72 = 0;
LABEL_87:
                uint64_t v8 = 2306875399;
LABEL_108:
                uint64_t v71 = (uint64_t)__src;
LABEL_109:
                heap_Free(*(void **)(*(void *)a1 + 8), v71);
                if ((v8 & 0x80000000) != 0)
                {
                  if ((v72 & 1) == 0)
                  {
                    uint64_t v96 = *(void *)(a1 + 512);
                    if (v96)
                    {
                      uint64_t v97 = *(void *)(v96 + 8 * *(unsigned __int16 *)(a1 + 576));
                      if (v97)
                      {
                        heap_Free(*(void **)(*(void *)a1 + 8), v97);
                        *(void *)(*(void *)(a1 + 512) + 8 * *(unsigned __int16 *)(a1 + 576)) = 0;
                      }
                    }
                    uint64_t v98 = *(void *)(a1 + 520);
                    if (v98)
                    {
                      uint64_t v99 = *(unsigned __int16 *)(a1 + 576);
                      uint64_t v100 = *(void *)(v98 + 8 * v99);
                      if (v100)
                      {
                        if (v28)
                        {
                          uint64_t v101 = *(void *)(a1 + 544);
                          if (v101)
                          {
                            if (*(void *)(v101 + 8 * v99))
                            {
                              *((void *)v28 + 3) = v100;
                              exit_DctRom((uint64_t)(v28 + 2), *(void *)(v101 + 8 * v99));
                              uint64_t v100 = *(void *)(*(void *)(a1 + 520) + 8 * *(unsigned __int16 *)(a1 + 576));
                            }
                          }
                        }
                        heap_Free(*(void **)(*(void *)a1 + 8), v100);
                        *(void *)(*(void *)(a1 + 520) + 8 * *(unsigned __int16 *)(a1 + 576)) = 0;
                      }
                    }
                    uint64_t v102 = *(void *)(a1 + 544);
                    if (v102)
                    {
                      uint64_t v103 = *(void *)(v102 + 8 * *(unsigned __int16 *)(a1 + 576));
                      if (v103)
                      {
                        brk_DataClose(*(void *)(*(void *)a1 + 24), v103);
                        *(void *)(*(void *)(a1 + 544) + 8 * *(unsigned __int16 *)(a1 + 576)) = 0;
                      }
                    }
                  }
                  uint64_t v34 = v8;
                }
                else
                {
                  uint64_t v34 = v8;
                  if (*a6) {
                    *int v11 = *(void *)(a1 + 528);
                  }
                }
                goto LABEL_127;
              }
            }
            else
            {
              int v29 = (unsigned __int16)*a6;
              if (v29 == 2)
              {
                if (!*(_DWORD *)(a1 + 328))
                {
                  uint64_t v34 = 2306875399;
                  goto LABEL_127;
                }
                unsigned int v28 = (unsigned int *)(a1 + 328);
              }
              else
              {
                if (v29 == 1)
                {
                  int v30 = strlen(a3);
                  uint64_t v31 = (char *)heap_Alloc(*(void *)(*(void *)a1 + 8), (v30 + 2));
                  if (v31)
                  {
                    int v32 = v31;
                    int v33 = strcpy(v31, a3);
                    __src = v32;
                    *(_WORD *)&v32[strlen(v33)] = 67;
                    if (!strcmp(a3, "lidcfg") || !strncmp(a3, "mertfrq", 7uLL) || !strncmp(a3, "merwfrq", 7uLL))
                    {
                      unsigned int v28 = (unsigned int *)(a1 + 168);
                      if (*(_DWORD *)(a1 + 168)) {
                        goto LABEL_28;
                      }
                    }
                    else if (!strncmp(a3, "ml2", 3uLL) || !strncmp(a3, "lid", 3uLL))
                    {
                      unsigned int v28 = (unsigned int *)(a1 + 248);
                      if (*(_DWORD *)(a1 + 248)) {
                        goto LABEL_28;
                      }
                    }
                    else if (!strncmp(a3, "clm", 3uLL))
                    {
                      if (*(_DWORD *)(a1 + 408))
                      {
                        unsigned int v28 = (unsigned int *)(a1 + 408);
                        goto LABEL_28;
                      }
                    }
                    else
                    {
                      unsigned int v28 = (unsigned int *)(a1 + 88);
                      if (*(_DWORD *)(a1 + 88)) {
                        goto LABEL_28;
                      }
                    }
                    unsigned int v28 = 0;
                    char v72 = 1;
                    goto LABEL_87;
                  }
                  goto LABEL_26;
                }
                unsigned int v28 = (unsigned int *)(a1 + 8);
              }
              __src = heap_strdup(*(void *)(*(void *)a1 + 8), a3);
              if (__src) {
                goto LABEL_28;
              }
            }
LABEL_26:
            log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v24, v25, v26, v27, v106);
            uint64_t v34 = 2306875402;
LABEL_127:
            log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Leaving fe_dctlkp_Lookup", v20, v21, v22, v106);
            return v34;
          }
          return 2306875400;
        }
      }
    }
  }
  return v9;
}

uint64_t fe_dctlkp_ConvertToCanonicalTokenUtf(size_t a1, int a2, const char *a3, const char *a4, unsigned int a5)
{
  uint64_t v10 = safeh_HandleCheck(a1, a2, 62335, 3696);
  if ((v10 & 0x80000000) != 0) {
    return 2306875400;
  }
  uint64_t CanonMap = v10;
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_ConvertToCanonicalToken", v11, v12, v13, v21);
  if (!a4)
  {
    log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 41001, 0, v15, v16, v17, v18, v22);
    return 2306875399;
  }
  if (*(_DWORD *)(a1 + 2660) && strcmp(a3, (const char *)(a1 + 2402)))
  {
    uint64_t CanonMap = LoadCanonMap(a1, a2);
    if ((CanonMap & 0x80000000) != 0) {
      return CanonMap;
    }
    __strcpy_chk();
  }
  if (*(_WORD *)(a1 + 1632) != 2)
  {
    if (*(_WORD *)(a1 + 1632))
    {
      if ((unsigned __int16)Utf8_Utf8NbrOfSymbols(a4) - 3 <= 0xFFFFFFFD && (unsigned __int16)strlen(a4))
      {
        int v19 = 0;
        do
          v19 += hlp_tolower_char((unsigned __int8 *)&a4[(unsigned __int16)v19]);
        while ((unsigned __int16)strlen(a4) > (unsigned __int16)v19);
      }
    }
    else
    {
      hlp_ConvertToCanonicalTokenUtf(a1, a2, a1, *(void *)(a1 + 584), a4, a5);
      uint64_t CanonMap = 0;
    }
  }
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Leaving fe_dctlkp_ConvertToCanonicalToken", v16, v17, v18, v22);
  return CanonMap;
}

size_t hlp_ConvertToCanonicalTokenUtf(size_t result, int a2, uint64_t a3, uint64_t a4, const char *a5, unsigned int a6)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  if (*(_WORD *)(a3 + 1632) != 2)
  {
    uint64_t v8 = result;
    strcpy(v21, "canonmap");
    if (*(void *)(a3 + 2664) == a4)
    {
      __strcat_chk();
      uint64_t v9 = a3 + 2672;
    }
    else
    {
      uint64_t v9 = a3 + 592;
    }
    uint64_t result = Utf8_Utf8NbrOfSymbols(a5);
    if ((unsigned __int16)result - 3 <= 0xFFFFFFFD)
    {
      uint64_t result = strlen(a5);
      unsigned __int16 v10 = result;
      if ((_WORD)result)
      {
        int v11 = 0;
        unsigned __int16 v12 = 0;
        int v13 = (unsigned __int16)result;
        do
        {
          uint64_t v14 = &a5[v12];
          unsigned __int16 v15 = utf8_determineUTF8CharLength(*(unsigned __int8 *)v14);
          if (hlp_getUtf8CanMap(v8, a2, (uint64_t)v21, v9, v14, __s))
          {
            unsigned __int16 v16 = strlen(__s);
            unsigned __int16 v17 = v13 - v15 + v16;
            if (a6 > v17)
            {
              size_t v18 = v16;
              memmove((void *)&v14[v16], &v14[v15], v13 - (v11 + v15) + 1);
              strncpy((char *)&a5[v12], __s, v18);
              unsigned __int16 v10 = v17;
            }
          }
          else
          {
            hlp_tolower_char((unsigned __int8 *)&a5[v12]);
          }
          uint64_t result = utf8_determineUTF8CharLength(*(unsigned __int8 *)v14);
          v12 += result;
          int v11 = v12;
          int v13 = v10;
        }
        while (v12 < v10);
      }
    }
  }
  return result;
}

unsigned __int8 *hlp_tolower_char(unsigned __int8 *result)
{
  uint64_t v1 = result;
  LODWORD(result) = *result;
  if ((result - 65) > 0x19)
  {
    if (result == 195)
    {
      int v2 = v1[1];
      LOWORD(result) = 2;
      switch(v1[1])
      {
        case 0x84:
          char v3 = -92;
          goto LABEL_16;
        case 0x85:
          char v3 = -91;
          goto LABEL_16;
        case 0x86:
          char v3 = -90;
          goto LABEL_16;
        case 0x87:
          char v3 = -89;
          goto LABEL_16;
        case 0x88:
        case 0x8A:
        case 0x8B:
        case 0x8C:
        case 0x8D:
        case 0x8E:
        case 0x8F:
        case 0x90:
          return (unsigned __int8 *)(unsigned __int16)result;
        case 0x89:
          char v3 = -87;
          goto LABEL_16;
        case 0x91:
          char v3 = -79;
          goto LABEL_16;
        default:
          if (v2 == 150)
          {
            char v3 = -74;
          }
          else
          {
            if (v2 != 156) {
              return (unsigned __int8 *)(unsigned __int16)result;
            }
            char v3 = -68;
          }
LABEL_16:
          v1[1] = v3;
          break;
      }
    }
    else
    {
      LOWORD(result) = utf8_determineUTF8CharLength(result);
    }
  }
  else
  {
    *uint64_t v1 = (_BYTE)result + 32;
    LOWORD(result) = 1;
  }
  return (unsigned __int8 *)(unsigned __int16)result;
}

uint64_t fe_dctlkp_G2PConvertToCanonicalTokenUtf(size_t a1, int a2, const char *a3, const char *a4, unsigned int a5)
{
  uint64_t v10 = 2306875399;
  if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) != 0) {
    return 2306875400;
  }
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_G2PConvertToCanonicalToken", v11, v12, v13, v24);
  if (a4)
  {
    if (*(_DWORD *)(a1 + 2660) && strcmp(a3, (const char *)(a1 + 2402)))
    {
      uint64_t CanonMap = LoadCanonMap(a1, a2);
      if ((CanonMap & 0x80000000) != 0) {
        return CanonMap;
      }
      __strcpy_chk();
    }
    uint64_t v19 = *(void *)(a1 + 2664);
    if (!v19) {
      uint64_t v19 = *(void *)(a1 + 584);
    }
    hlp_ConvertToCanonicalTokenUtf(a1, a2, a1, v19, a4, a5);
    log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Leaving fe_dctlkp_G2PConvertToCanonicalToken", v20, v21, v22, v25);
    return 0;
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 41001, 0, v14, v15, v16, v17, v25);
  }
  return v10;
}

uint64_t fe_dctlkp_ConvertToCanonicalWordUtf(uint64_t a1, int a2, const char *a3, char *a4, unsigned int a5)
{
  uint64_t v10 = safeh_HandleCheck(a1, a2, 62335, 3696);
  if ((v10 & 0x80000000) != 0) {
    return 2306875400;
  }
  uint64_t CanonMap = v10;
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_ConvertToCanonicalWord", v11, v12, v13, v35);
  if (a4)
  {
    if (*a4)
    {
      if (!*(_DWORD *)(a1 + 2660) || !strcmp(a3, (const char *)(a1 + 2402)))
      {
LABEL_8:
        if (*(_WORD *)(a1 + 1632))
        {
          if ((unsigned __int16)strlen(a4))
          {
            int v19 = 0;
            do
            {
              uint64_t v20 = *(char **)(a1 + 504);
              if (!v20) {
                break;
              }
              uint64_t v21 = &a4[(unsigned __int16)v19];
              if (!*v21) {
                break;
              }
              if (!utf8_strchr(v20, (unsigned __int8 *)&a4[(unsigned __int16)v19])) {
                break;
              }
              v19 += utf8_determineUTF8CharLength(*v21);
            }
            while ((unsigned __int16)strlen(a4) > (unsigned __int16)v19);
          }
          else
          {
            int v19 = 0;
          }
          __int16 v25 = strlen(a4);
          int v26 = (__int16)(v25 - 1) & ((__int16)(v25 - 1) >> 31);
          LOWORD(v27) = v25;
          do
          {
            int v27 = (__int16)(v27 - 1);
            if (v27 < 1) {
              goto LABEL_35;
            }
          }
          while (a4[(unsigned __int16)v27] < -64);
          unsigned int v28 = *(char **)(a1 + 504);
          if (v28)
          {
            while (2)
            {
              int v29 = (unsigned __int8 *)&a4[(unsigned __int16)v27];
              if (*v29 && utf8_strchr(v28, v29))
              {
                LOWORD(v26) = v27;
                do
                {
                  int v26 = (__int16)(v26 - 1);
                  if (v26 < 1)
                  {
                    __int16 v30 = v27;
                    if ((__int16)v27 >= 1) {
                      __int16 v30 = 1;
                    }
                    LOWORD(v26) = v30 - 1;
                    goto LABEL_35;
                  }
                }
                while (a4[(unsigned __int16)v26] < -64);
                unsigned int v28 = *(char **)(a1 + 504);
                LOWORD(v27) = v26;
                if (v28) {
                  continue;
                }
LABEL_35:
                a4[(unsigned __int16)(v26 + utf8_determineUTF8CharLength(a4[(unsigned __int16)v26]))] = 0;
                uint64_t v31 = (unsigned __int16)v19;
                if (*(_WORD *)(a1 + 1632) != 2
                  && (unsigned __int16)Utf8_Utf8NbrOfSymbols(&a4[(unsigned __int16)v19]) - 3 <= 0xFFFFFFFD
                  && (unsigned __int16)strlen(a4) > (unsigned __int16)v19)
                {
                  do
                    v19 += hlp_tolower_char((unsigned __int8 *)&a4[(unsigned __int16)v19]);
                  while ((unsigned __int16)strlen(a4) > (unsigned __int16)v19);
                }
                int v32 = &a4[v31];
                size_t v33 = strlen(v32);
                memmove(a4, v32, v33 + 1);
                goto LABEL_40;
              }
              break;
            }
          }
          LOWORD(v26) = v27;
          goto LABEL_35;
        }
        hlp_ConvertToCanonicalWordUtf(a1, a2, a1, *(void *)(a1 + 584), a4, a5);
        uint64_t CanonMap = 0;
LABEL_40:
        log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Leaving fe_dctlkp_ConvertToCanonicalWord", v22, v23, v24, v36);
        return CanonMap;
      }
      uint64_t CanonMap = LoadCanonMap(a1, a2);
      if ((CanonMap & 0x80000000) == 0)
      {
        __strcpy_chk();
        goto LABEL_8;
      }
    }
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 41001, 0, v15, v16, v17, v18, v36);
    return 2306875399;
  }
  return CanonMap;
}

void *hlp_ConvertToCanonicalWordUtf(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char *__s, unsigned int a6)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  strcpy(v33, "canonmap");
  if (*(void *)(a3 + 2664) == a4)
  {
    __strcat_chk();
    uint64_t v9 = a3 + 2672;
  }
  else
  {
    uint64_t v9 = a3 + 592;
  }
  if ((unsigned __int16)strlen(__s))
  {
    int v10 = 0;
    do
    {
      if (!loc_fe_dctlkp_IsPunctUtf(a3, (unsigned __int8 *)&__s[(unsigned __int16)v10])) {
        break;
      }
      v10 += utf8_determineUTF8CharLength(__s[(unsigned __int16)v10]);
    }
    while ((unsigned __int16)strlen(__s) > (unsigned __int16)v10);
  }
  else
  {
    LOWORD(v10) = 0;
  }
  size_t v11 = strlen(__s);
  __int16 v12 = v11 - 1;
  if (v11) {
    __int16 v13 = v11 - 1;
  }
  else {
    __int16 v13 = 0;
  }
  LOWORD(v14) = v13;
  if (v13 >= 1)
  {
    while (__s[(unsigned __int16)v12] < -64)
    {
      int v15 = v12--;
      if (v15 <= 1)
      {
        LOWORD(v14) = 0;
        goto LABEL_27;
      }
    }
    if (loc_fe_dctlkp_IsPunctUtf(a3, (unsigned __int8 *)&__s[(unsigned __int16)v12]))
    {
      while (2)
      {
        LOWORD(v14) = v12;
        do
        {
          int v14 = (__int16)(v14 - 1);
          if (v14 < 1)
          {
            __int16 v16 = v12;
            if (v12 >= 1) {
              __int16 v16 = 1;
            }
            LOWORD(v14) = v16 - 1;
            goto LABEL_27;
          }
        }
        while (__s[(unsigned __int16)v14] < -64);
        __int16 v12 = v14;
        if (loc_fe_dctlkp_IsPunctUtf(a3, (unsigned __int8 *)&__s[(unsigned __int16)v14])) {
          continue;
        }
        break;
      }
    }
    else
    {
      LOWORD(v14) = v12;
    }
  }
LABEL_27:
  unsigned int v17 = (unsigned __int16)utf8_determineUTF8CharLength(__s[(unsigned __int16)v14])
      + (unsigned __int16)v14;
  if (v17 >= a6) {
    LOWORD(v17) = a6 - 1;
  }
  __s[(unsigned __int16)v17] = 0;
  uint64_t v30 = (unsigned __int16)v10;
  if (*(_WORD *)(a3 + 1632) != 2
    && (unsigned __int16)Utf8_Utf8NbrOfSymbols(&__s[(unsigned __int16)v10]) - 3 <= 0xFFFFFFFD)
  {
    unsigned __int16 v18 = strlen(__s);
    unsigned __int16 v19 = v18;
    if (v18)
    {
      int v20 = 0;
      int v21 = 0;
      int v22 = v18;
      do
      {
        uint64_t v23 = &__s[(unsigned __int16)v21];
        unsigned __int16 v24 = utf8_determineUTF8CharLength(*(unsigned __int8 *)v23);
        if (hlp_getUtf8CanMap(a1, a2, (uint64_t)v33, v9, v23, __sa))
        {
          unsigned __int16 v25 = strlen(__sa);
          unsigned __int16 v26 = v22 - v24 + v25;
          if (a6 > v26)
          {
            size_t v27 = v25;
            memmove((void *)&v23[v25], &v23[v24], v22 - (v20 + v24) + 1);
            strncpy(&__s[(unsigned __int16)v21], __sa, v27);
            unsigned __int16 v19 = v26;
          }
        }
        else
        {
          hlp_tolower_char((unsigned __int8 *)&__s[(unsigned __int16)v21]);
        }
        v21 += utf8_determineUTF8CharLength(*(unsigned __int8 *)v23);
        int v20 = (unsigned __int16)v21;
        int v22 = v19;
      }
      while ((unsigned __int16)v21 < v19);
    }
  }
  size_t v28 = strlen(&__s[v30]);
  return memmove(__s, &__s[v30], v28 + 1);
}

BOOL loc_fe_dctlkp_IsPunctUtf(BOOL result, unsigned __int8 *a2)
{
  if (result)
  {
    uint64_t v2 = result;
    uint64_t result = 0;
    if (a2)
    {
      char v3 = *(char **)(v2 + 504);
      if (v3) {
        return *a2 && utf8_strchr(v3, a2) != 0;
      }
    }
  }
  return result;
}

uint64_t fe_dctlkp_G2PConvertToCanonicalWordUtf(uint64_t a1, int a2, const char *a3, char *a4, unsigned int a5)
{
  uint64_t v10 = 2306875399;
  if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) != 0) {
    return 2306875400;
  }
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_G2PConvertToCanonicalWord", v11, v12, v13, v24);
  if (a4)
  {
    if (*(_DWORD *)(a1 + 2660) && strcmp(a3, (const char *)(a1 + 2402)))
    {
      uint64_t CanonMap = LoadCanonMap(a1, a2);
      if ((CanonMap & 0x80000000) != 0) {
        return CanonMap;
      }
      __strcpy_chk();
    }
    uint64_t v19 = *(void *)(a1 + 2664);
    if (!v19) {
      uint64_t v19 = *(void *)(a1 + 584);
    }
    hlp_ConvertToCanonicalWordUtf(a1, a2, a1, v19, a4, a5);
    log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Leaving fe_dctlkp_G2PConvertToCanonicalWord", v20, v21, v22, v25);
    return 0;
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 41001, 0, v14, v15, v16, v17, v25);
  }
  return v10;
}

uint64_t fe_dctlkp_LookupMultiwordUtf(uint64_t a1, int a2, char *a3, unsigned int a4, char *a5, const char *a6, void *a7, unsigned __int16 *a8)
{
  char v35 = 0;
  uint64_t v16 = 2306875399;
  if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) != 0) {
    return 2306875400;
  }
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Entering fe_dctlkp_LookupMultiword", v17, v18, v19, v33);
  if (!a3 || !a7 || !a8)
  {
    log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 41001, 0, v20, v21, v22, v23, v34);
    return v16;
  }
  if (*(_DWORD *)(a1 + 2660) && strcmp(a6, (const char *)(a1 + 2402)))
  {
    uint64_t CanonMap = LoadCanonMap(a1, a2);
    if ((CanonMap & 0x80000000) != 0) {
      return CanonMap;
    }
    __strcpy_chk();
  }
  if ((unsigned __int16)strlen(a3))
  {
    int v25 = 0;
    do
    {
      if (!loc_fe_dctlkp_IsPunctUtf(a1, (unsigned __int8 *)&a3[(unsigned __int16)v25])) {
        break;
      }
      v25 += utf8_determineUTF8CharLength(a3[(unsigned __int16)v25]);
    }
    while ((unsigned __int16)strlen(a3) > (unsigned __int16)v25);
  }
  else
  {
    int v25 = 0;
  }
  int v26 = *(unsigned __int16 *)(a1 + 1632);
  if (*(_WORD *)(a1 + 1632)) {
    goto LABEL_22;
  }
  if ((unsigned __int16)Utf8_Utf8NbrOfSymbols(a3) - 3 > 0xFFFFFFFD)
  {
    int v26 = *(unsigned __int16 *)(a1 + 1632);
LABEL_22:
    if (v26 != 2 && (unsigned __int16)strlen(a3) > (unsigned __int16)v25)
    {
      int v27 = v25;
      do
        v27 += hlp_tolower_char((unsigned __int8 *)&a3[(unsigned __int16)v27]);
      while ((unsigned __int16)strlen(a3) > (unsigned __int16)v27);
    }
    goto LABEL_26;
  }
  hlp_ConvertToCanonicalWordUtf(a1, a2, a1, *(void *)(a1 + 584), a3, a4);
LABEL_26:
  size_t v28 = strlen(&a3[(unsigned __int16)v25]);
  memmove(a3, &a3[(unsigned __int16)v25], v28 + 1);
  *a8 = 0;
  uint64_t v16 = fe_dctlkp_LookupAddonDct(a1, a2, a5, a3, a7, a8, &v35, 0);
  if ((v16 & 0x80000000) == 0) {
    log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 4, 0, (uint64_t)"Leaving fe_dctlkp_LookupMultiword", v29, v30, v31, v34);
  }
  return v16;
}

BOOL fe_dctlkp_IsPunctUtf(uint64_t a1, int a2, unsigned __int8 *a3)
{
  if ((safeh_HandleCheck(a1, a2, 62335, 3696) & 0x80000000) != 0) {
    return 0;
  }
  return loc_fe_dctlkp_IsPunctUtf(a1, a3);
}

unsigned int *fe_GetDct(unsigned int *a1, int a2, char *__s, _WORD *a4)
{
  if (!a1) {
    return 0;
  }
  int v7 = (unsigned __int16)*a4;
  if (v7 == 2)
  {
    uint64_t v17 = a1 + 82;
    uint64_t v15 = __s;
LABEL_13:
    *a4 = 0;
    goto LABEL_14;
  }
  if (v7 == 1)
  {
    uint64_t v8 = *(void *)(*(void *)a1 + 8);
    int v9 = strlen(__s);
    uint64_t v10 = (char *)heap_Alloc(v8, (v9 + 2));
    if (!v10)
    {
LABEL_24:
      log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v11, v12, v13, v14, v38);
      return 0;
    }
    uint64_t v15 = v10;
    uint64_t v16 = strcpy(v10, __s);
    *(_WORD *)&v15[strlen(v16)] = 67;
    uint64_t v17 = a1 + 22;
    int v7 = (unsigned __int16)*a4;
  }
  else
  {
    uint64_t v17 = a1 + 2;
    uint64_t v15 = __s;
  }
  if ((v7 - 1) < 2 || v7 == 0xFFFF) {
    goto LABEL_13;
  }
LABEL_14:
  int v19 = hlp_SearchDctName((uint64_t)a1, v15, &byte_20D5A22AE);
  if ((v19 & 0x80000000) == 0)
  {
    *((void *)v17 + 3) = *(void *)(*((void *)a1 + 65) + 8 * (unsigned __int16)v19);
    return v17;
  }
  uint64_t v20 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *((void *)a1 + 68), 8 * *((unsigned __int16 *)a1 + 288) + 16);
  if (!v20) {
    goto LABEL_24;
  }
  *((void *)a1 + 68) = v20;
  uint64_t v21 = *((unsigned __int16 *)a1 + 288);
  *(void *)(v20 + 8 * v21) = 0;
  *(void *)(*((void *)a1 + 68) + 8 * v21 + 8) = 0;
  if ((brk_DataOpen(*(void *)(*(void *)a1 + 24)) & 0x80000000) != 0) {
    return v17;
  }
  uint64_t v22 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *((void *)a1 + 65), 8 * *((unsigned __int16 *)a1 + 288) + 16);
  if (!v22) {
    goto LABEL_24;
  }
  *((void *)a1 + 65) = v22;
  uint64_t v23 = *((unsigned __int16 *)a1 + 288);
  *(void *)(v22 + 8 * v23) = 0;
  *(void *)(*((void *)a1 + 65) + 8 * v23 + 8) = 0;
  uint64_t v24 = heap_Calloc(*(void **)(*(void *)a1 + 8), 1, 144);
  if (!v24) {
    goto LABEL_24;
  }
  uint64_t v25 = *((unsigned __int16 *)a1 + 288);
  *(void *)(*((void *)a1 + 65) + 8 * v25) = v24;
  *((void *)v17 + 3) = *(void *)(*((void *)a1 + 65) + 8 * v25);
  int inited = init_DctRom((uint64_t)(v17 + 2), __s, *v17, *(void *)(*((void *)a1 + 68) + 8 * v25));
  if (inited < 0)
  {
    if ((inited & 0x1FFF) == 0x14)
    {
      heap_Free(*(void **)(*(void *)a1 + 8), *(void *)(*((void *)a1 + 65) + 8 * *((unsigned __int16 *)a1 + 288)));
      uint64_t v37 = *((unsigned __int16 *)a1 + 288);
      *(void *)(*((void *)a1 + 65) + 8 * v37) = 0;
      brk_DataClose(*(void *)(*(void *)a1 + 24), *(void *)(*((void *)a1 + 68) + 8 * v37));
      *(void *)(*((void *)a1 + 68) + 8 * *((unsigned __int16 *)a1 + 288)) = 0;
    }
  }
  else
  {
    uint64_t v27 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *((void *)a1 + 64), 8 * *((unsigned __int16 *)a1 + 288) + 16);
    if (v27
      && (*((void *)a1 + 64) = v27,
          uint64_t v32 = *((unsigned __int16 *)a1 + 288),
          *(void *)(v27 + 8 * v32) = 0,
          *(void *)(*((void *)a1 + 64) + 8 * v32 + 8) = 0,
          int v33 = strlen(v15),
          (uint64_t v34 = heap_Alloc(*(void *)(*(void *)a1 + 8), (v33 + 1))) != 0))
    {
      uint64_t v35 = *((unsigned __int16 *)a1 + 288);
      *(void *)(*((void *)a1 + 64) + 8 * v35) = v34;
      strcpy(*(char **)(*((void *)a1 + 64) + 8 * v35), v15);
    }
    else
    {
      log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v28, v29, v30, v31, v38);
    }
  }
  return v17;
}

uint64_t hlp_SearchDctName(uint64_t a1, const char *a2, char *__s)
{
  unsigned __int16 v6 = strlen(__s);
  uint64_t v7 = *(unsigned __int16 *)(a1 + 576);
  if (*(_WORD *)(a1 + 576))
  {
    uint64_t v8 = 0;
    size_t v9 = v6;
    uint64_t v10 = *(void *)(a1 + 512);
    do
    {
      uint64_t v11 = *(void *)(v10 + 8 * v8);
      if (v9)
      {
        if (!strncmp(*(const char **)(v10 + 8 * v8), __s, v9) && *(unsigned char *)(v11 + v9) == 95)
        {
          size_t v12 = strlen(a2);
          if (!strncmp((const char *)(v11 + v9 + 1), a2, v12)) {
            return (__int16)v8;
          }
        }
      }
      else if (!strcmp(*(const char **)(v10 + 8 * v8), a2))
      {
        return (__int16)v8;
      }
      ++v8;
    }
    while (v7 != v8);
  }
  LOWORD(v8) = -1;
  return (__int16)v8;
}

const char *lowercase(const char *__s, uint64_t a2)
{
  if (*__s)
  {
    char v3 = __s;
    uint64_t v4 = 0;
    int v5 = 0;
    do
    {
      int v6 = v3[v4];
      if ((v6 - 65) < 0x1A) {
        LOBYTE(v6) = v6 + 32;
      }
      *(unsigned char *)(a2 + v4) = v6;
      uint64_t v4 = (unsigned __int16)++v5;
      __s = (const char *)strlen(v3);
    }
    while ((unint64_t)__s > (unsigned __int16)v5);
  }
  else
  {
    uint64_t v4 = 0;
  }
  *(unsigned char *)(a2 + v4) = 0;
  return __s;
}

uint64_t fe_dctlkp_LoadAddonDct(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, const char *a7)
{
  *(_WORD *)&__c[1] = -1;
  uint64_t v7 = 2306875402;
  if (!a1) {
    return 2306875400;
  }
  *(void *)&__c[3] = 0;
  uint64_t v15 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 496), 8 * *(unsigned __int16 *)(a1 + 488) + 8);
  if (!v15) {
    goto LABEL_6;
  }
  *(void *)(a1 + 496) = v15;
  uint64_t v20 = heap_Alloc(*(void *)(*(void *)a1 + 8), 640);
  uint64_t v21 = *(unsigned __int16 *)(a1 + 488);
  *(void *)(*(void *)(a1 + 496) + 8 * v21) = v20;
  uint64_t v22 = *(void *)(*(void *)(a1 + 496) + 8 * v21);
  if (!v22) {
    goto LABEL_6;
  }
  if (a7)
  {
    int v23 = strlen(a7);
    uint64_t v24 = heap_Alloc(*(void *)(*(void *)a1 + 8), (v23 + 1));
    uint64_t v25 = *(void *)(a1 + 496);
    uint64_t v26 = *(unsigned __int16 *)(a1 + 488);
    *(void *)(*(void *)(v25 + 8 * v26) + 632) = v24;
    uint64_t v27 = *(char **)(*(void *)(v25 + 8 * v26) + 632);
    if (!v27)
    {
LABEL_6:
      log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DCTLKP", 41000, 0, v16, v17, v18, v19, v49);
      return v7;
    }
  }
  else
  {
    uint64_t v27 = *(char **)(v22 + 632);
  }
  strcpy(v27, a7);
  uint64_t v28 = *(void *)(a1 + 496);
  uint64_t v29 = *(unsigned __int16 *)(a1 + 488);
  *(void *)(*(void *)(v28 + 8 * v29) + 624) = a5;
  uint64_t v30 = *(void *)(v28 + 8 * v29);
  *(_WORD *)(v30 + 72) = *(_WORD *)(a1 + 490);
  *(void *)(v30 + 56) = a3;
  uint64_t v31 = *(void *)(v28 + 8 * v29);
  *(_DWORD *)(v31 + 64) = a4;
  uint64_t v32 = open_DctRom((uint64_t *)(v31 + 8), 0, (_DWORD *)v31);
  if ((v32 & 0x80000000) != 0) {
    return v32;
  }
  __c[0] = 0;
  uint64_t v33 = *(void *)(a1 + 496);
  uint64_t v34 = *(unsigned __int16 *)(a1 + 488);
  *(void *)(*(void *)(v33 + 8 * v34) + 48) = *(void *)(a1 + 56);
  loc_fe_dctlkp_LookupUtf(a1, a2, "addoncfg", "lang", &__c[3], &__c[1], __c, *(unsigned int **)(v33 + 8 * v34));
  if (*(_WORD *)&__c[1])
  {
    uint64_t v35 = strchr(**(char ***)&__c[3], __c[0]);
    if (v35) {
      *uint64_t v35 = 0;
    }
    __strcpy_chk();
  }
  *(_WORD *)&__c[1] = -1;
  loc_fe_dctlkp_LookupUtf(a1, a2, "addoncfg", "cfg", &__c[3], &__c[1], __c, *(unsigned int **)(*(void *)(a1 + 496) + 8 * *(unsigned __int16 *)(a1 + 488)));
  if (*(_WORD *)&__c[1])
  {
    uint64_t v36 = strchr(**(char ***)&__c[3], __c[0]);
    if (v36) {
      *uint64_t v36 = 0;
    }
    __strcpy_chk();
  }
  *(_WORD *)&__c[1] = -1;
  loc_fe_dctlkp_LookupUtf(a1, a2, "addoncfg", "codecomp", &__c[3], &__c[1], __c, *(unsigned int **)(*(void *)(a1 + 496) + 8 * *(unsigned __int16 *)(a1 + 488)));
  if (*(_WORD *)&__c[1])
  {
    uint64_t v37 = **(const char ***)&__c[3];
    unsigned int v38 = strchr(**(char ***)&__c[3], __c[0]);
    if (v38)
    {
      char *v38 = 0;
      uint64_t v37 = **(const char ***)&__c[3];
    }
    char v39 = atoi(v37);
    uint64_t v40 = *(void *)(*(void *)(a1 + 496) + 8 * *(unsigned __int16 *)(a1 + 488));
    *(unsigned char *)(v40 + 104) = v39;
  }
  else
  {
    uint64_t v40 = *(void *)(*(void *)(a1 + 496) + 8 * *(unsigned __int16 *)(a1 + 488));
  }
  *(_WORD *)&__c[1] = -1;
  loc_fe_dctlkp_LookupUtf(a1, a2, "addoncfg", "datacomp", &__c[3], &__c[1], __c, (unsigned int *)v40);
  if (*(_WORD *)&__c[1])
  {
    uint64_t v41 = **(const char ***)&__c[3];
    uint64_t v42 = strchr(**(char ***)&__c[3], __c[0]);
    if (v42)
    {
      char *v42 = 0;
      uint64_t v41 = **(const char ***)&__c[3];
    }
    char v43 = atoi(v41);
    uint64_t v44 = *(void *)(*(void *)(a1 + 496) + 8 * *(unsigned __int16 *)(a1 + 488));
    *(unsigned char *)(v44 + 105) = v43;
  }
  else
  {
    uint64_t v44 = *(void *)(*(void *)(a1 + 496) + 8 * *(unsigned __int16 *)(a1 + 488));
  }
  *(_WORD *)&__c[1] = -1;
  loc_fe_dctlkp_LookupUtf(a1, a2, "addoncfg", "g2pdcts", &__c[3], &__c[1], __c, (unsigned int *)v44);
  if (*(_WORD *)&__c[1])
  {
    uint64_t v45 = strchr(**(char ***)&__c[3], __c[0]);
    if (v45) {
      *uint64_t v45 = 0;
    }
    __strcpy_chk();
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 496) + 8 * *(unsigned __int16 *)(a1 + 488)) + 106) = 0;
  }
  *(_WORD *)&__c[1] = -1;
  loc_fe_dctlkp_LookupUtf(a1, a2, "addoncfg", "tndcts", &__c[3], &__c[1], __c, *(unsigned int **)(*(void *)(a1 + 496) + 8 * *(unsigned __int16 *)(a1 + 488)));
  if (*(_WORD *)&__c[1])
  {
    unsigned __int16 v46 = strchr(**(char ***)&__c[3], __c[0]);
    if (v46) {
      *unsigned __int16 v46 = 0;
    }
    __strcpy_chk();
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 496) + 8 * *(unsigned __int16 *)(a1 + 488)) + 362) = 0;
  }
  uint64_t v7 = hlp_EnableAddon(a1, a2, *(void *)(*(void *)(a1 + 496) + 8 * *(unsigned __int16 *)(a1 + 488)));
  uint64_t v47 = *(unsigned __int16 *)(a1 + 488);
  *(void *)a6 = *(void *)(*(void *)(a1 + 496) + 8 * v47);
  *(_DWORD *)(a6 + 8) = 62335;
  *(_WORD *)(a1 + 488) = v47 + 1;
  ++*(_WORD *)(a1 + 490);
  return v7;
}

uint64_t fe_dctlkp_UnLoadAddonDct(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  uint64_t result = 2306875400;
  if (a1)
  {
    LOWORD(v5) = *(_WORD *)(a1 + 488);
    if ((_WORD)v5)
    {
      uint64_t v6 = a3;
      unint64_t v7 = 0;
      uint64_t v8 = 8;
      do
      {
        if (*(void *)(*(void *)(a1 + 496) + 8 * v7) == v6)
        {
          uint64_t v9 = *(void *)(v6 + 632);
          if (v9)
          {
            heap_Free(*(void **)(*(void *)a1 + 8), v9);
            uint64_t v10 = *(void *)(a1 + 496);
            *(void *)(*(void *)(v10 + 8 * v7) + 632) = 0;
            uint64_t v11 = *(void *)(v10 + 8 * v7);
            __int16 v34 = 0;
            *(void *)__s = 0;
            if (!v11) {
              return 2306875400;
            }
          }
          else
          {
            __int16 v34 = 0;
            *(void *)__s = 0;
            uint64_t v11 = v6;
          }
          LH_itoa(*(unsigned __int16 *)(v11 + 72), __s, 0xAu);
          unsigned __int16 v12 = *(_WORD *)(a1 + 576);
          if (v12)
          {
            unint64_t v13 = 0;
            unsigned __int16 v14 = 0;
            int v15 = 0;
            __int16 v16 = 0;
            do
            {
              uint64_t v17 = *(void *)(a1 + 512);
              uint64_t v18 = *(const char **)(v17 + 8 * v13);
              size_t v19 = strlen(__s);
              if (!strncmp(v18, __s, v19))
              {
                uint64_t v20 = *(void *)(*(void *)(a1 + 520) + 8 * v13);
                if (v20)
                {
                  heap_Free(*(void **)(*(void *)a1 + 8), v20);
                  *(void *)(*(void *)(a1 + 520) + 8 * v13) = 0;
                  uint64_t v18 = *(const char **)(*(void *)(a1 + 512) + 8 * v13);
                }
                if (v18)
                {
                  heap_Free(*(void **)(*(void *)a1 + 8), (uint64_t)v18);
                  *(void *)(*(void *)(a1 + 512) + 8 * v13) = 0;
                }
                uint64_t v21 = *(void *)(*(void *)(a1 + 544) + 8 * v13);
                if (v21)
                {
                  brk_DataClose(*(void *)(*(void *)a1 + 24), v21);
                  *(void *)(*(void *)(a1 + 544) + 8 * v13) = 0;
                }
                ++v16;
                unsigned __int16 v12 = *(_WORD *)(a1 + 576);
                int v15 = 1;
              }
              else
              {
                if (v15)
                {
                  *(void *)(v17 + 8 * v14) = v18;
                  *(void *)(*(void *)(a1 + 520) + 8 * v14) = *(void *)(*(void *)(a1 + 520) + 8 * v13);
                  *(void *)(*(void *)(a1 + 544) + 8 * v14) = *(void *)(*(void *)(a1 + 544) + 8 * v13);
                }
                ++v14;
              }
              ++v13;
            }
            while (v13 < v12);
            uint64_t v6 = a3;
            if (v16)
            {
              *(_WORD *)(a1 + 576) = v12 - v16;
              uint64_t v22 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 512), 8 * (unsigned __int16)(v12 - v16) + 16);
              if (!v22) {
                return 2306875402;
              }
              *(void *)(a1 + 512) = v22;
              uint64_t v23 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 520), 8 * *(unsigned __int16 *)(a1 + 576) + 16);
              if (!v23) {
                return 2306875402;
              }
              *(void *)(a1 + 520) = v23;
              uint64_t v24 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 544), 8 * *(unsigned __int16 *)(a1 + 576) + 16);
              if (!v24) {
                return 2306875402;
              }
              *(void *)(a1 + 544) = v24;
              uint64_t v25 = *(unsigned __int16 *)(a1 + 576);
              *(void *)(*(void *)(a1 + 512) + 8 * v25) = 0;
              uint64_t v26 = 8 * v25 + 8;
              *(void *)(*(void *)(a1 + 512) + v26) = 0;
              *(void *)(*(void *)(a1 + 520) + 8 * v25) = 0;
              *(void *)(*(void *)(a1 + 520) + v26) = 0;
              *(void *)(*(void *)(a1 + 544) + 8 * v25) = 0;
              *(void *)(*(void *)(a1 + 544) + v26) = 0;
            }
          }
          uint64_t v27 = *(void *)(*(void *)(a1 + 496) + 8 * v7);
          uint64_t v28 = *(void *)(v27 + 624);
          if (v28)
          {
            uint64_t v29 = *(void *)(v27 + 56);
            if (v29)
            {
              brk_DataUnmap(*(void *)(*(void *)a1 + 24), v28, v29);
              uint64_t v28 = *(void *)(*(void *)(*(void *)(a1 + 496) + 8 * v7) + 624);
            }
            brk_DataClose(*(void *)(*(void *)a1 + 24), v28);
            uint64_t v27 = *(void *)(*(void *)(a1 + 496) + 8 * v7);
          }
          heap_Free(*(void **)(*(void *)a1 + 8), v27);
          int v5 = *(unsigned __int16 *)(a1 + 488) - 1;
          if (v5 > (int)v7)
          {
            uint64_t v30 = (unsigned __int16)v7;
            uint64_t v31 = v8;
            do
            {
              *(void *)(*(void *)(a1 + 496) + 8 * v30++) = *(void *)(*(void *)(a1 + 496) + v31);
              v31 += 8;
            }
            while (v5 > (unsigned __int16)v30);
          }
          *(_WORD *)(a1 + 488) = v5;
        }
        ++v7;
        v8 += 8;
      }
      while (v7 < (unsigned __int16)v5);
    }
    return 0;
  }
  return result;
}

uint64_t fe_dctlkp_GetCfgParamVal(uint64_t a1, int a2, const char *a3, char *a4, char **a5)
{
  *a5 = a4;
  __int16 __c_1 = -1;
  unsigned __int8 __c = 0;
  uint64_t v10 = 0;
  uint64_t v6 = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", a3, &v10, &__c_1, &__c, 0);
  if ((v6 & 0x80000000) == 0 && __c_1)
  {
    unint64_t v7 = *v10;
    uint64_t v8 = strchr(*v10, __c);
    if (v8)
    {
      *uint64_t v8 = 0;
      unint64_t v7 = *v10;
    }
    *a5 = v7;
  }
  return v6;
}

uint64_t fe_dctlkp_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2306875393;
  }
  uint64_t result = 0;
  *a2 = &IFeDctLkp;
  return result;
}

uint64_t loc_fe_dctlkp_getTokenDef(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, uint64_t a5, char **a6)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  memset(__c, 0, sizeof(__c));
  __strcpy_chk();
  __strcat_chk();
  uint64_t v10 = loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", v23, &__c[3], &__c[1], __c, 0);
  if ((v10 & 0x80000000) == 0 && *(unsigned __int16 *)&__c[1] == 1)
  {
    uint64_t v11 = **(const char ***)&__c[3];
    unsigned __int16 v12 = strchr(**(char ***)&__c[3], __c[0]);
    if (v12)
    {
      *unsigned __int16 v12 = 0;
      uint64_t v11 = **(const char ***)&__c[3];
    }
    size_t v13 = strlen(v11);
    uint64_t v18 = *a3;
    if (v13 < 0x100)
    {
      size_t v19 = (char *)heap_Calloc(*(void **)(v18 + 8), v13 + 1, 1);
      *a6 = v19;
      if (v19) {
        strcpy(v19, **(const char ***)&__c[3]);
      }
      else {
        return 2306875402;
      }
    }
    else
    {
      uint64_t v10 = 2306875392;
      log_OutPublic(*(void *)(v18 + 32), (uint64_t)"FE_DCTLKP", 41003, 0, v14, v15, v16, v17, v21);
    }
  }
  return v10;
}

char *heap_strdup(uint64_t a1, char *__s)
{
  int v4 = strlen(__s);
  uint64_t result = (char *)heap_Alloc(a1, (v4 + 1));
  if (result) {
    return strcpy(result, __s);
  }
  return result;
}

BOOL hlp_getUtf8CanMap(uint64_t a1, int a2, uint64_t a3, uint64_t a4, const char *a5, char *a6)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  unsigned __int16 v16 = 0;
  if (!*(_DWORD *)(a4 + 4 * *(unsigned __int8 *)a5)) {
    return 0;
  }
  uint64_t v17 = 0;
  char v15 = 0;
  *a6 = 0;
  __strcpy_chk();
  __strcat_chk();
  __strcat_chk();
  if ((loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", v18, &v17, &v16, &v15, 0) & 0x80000000) != 0) {
    return 0;
  }
  if (!v16)
  {
    unsigned __int16 v16 = 0;
    __strcpy_chk();
    if ((loc_fe_dctlkp_LookupUtf(a1, a2, "fecfg", v18, &v17, &v16, &v15, 0) & 0x80000000) != 0 || !v16) {
      return 0;
    }
  }
  if (*a6) {
    return 1;
  }
  for (unint64_t i = 0; i < v16; ++i)
  {
    uint64_t v11 = *(const char **)(v17 + 8 * i);
    int v12 = utf8_determineUTF8CharLength(*(unsigned __int8 *)v11);
    v11[utf8_determineUTF8CharLength(*(unsigned __int8 *)v11)] = 0;
    size_t v13 = strlen(v11);
    if (!strncmp(v11, a5, v13)) {
      strcpy(a6, &v11[v12 + 1]);
    }
    if (*a6) {
      break;
    }
  }
  return *a6 != 0;
}

uint64_t fe_nn_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2706382849;
  }
  uint64_t result = 0;
  *a2 = &IFeNn;
  return result;
}

uint64_t WordScanner_ResetFrom(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a1 + 16);
  if (v2 <= a2 || (uint64_t v3 = a2, utf8_BelongsToSet(1u, *(unsigned char **)(a1 + 8), a2, v2)))
  {
LABEL_3:
    return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"u16From");
  }
  unsigned int PreviousUtf8OffsetLimit = (unsigned __int16)utf8_GetPreviousUtf8OffsetLimit(*(void *)(a1 + 8), v3, *(unsigned __int16 *)(a1 + 16));
  unsigned int v7 = *(unsigned __int16 *)(a1 + 16);
  if (PreviousUtf8OffsetLimit < v7)
  {
    if (!utf8_BelongsToSet(1u, *(unsigned char **)(a1 + 8), PreviousUtf8OffsetLimit, v7)) {
      goto LABEL_3;
    }
    unsigned int v7 = *(unsigned __int16 *)(a1 + 16);
  }
  for (*(_WORD *)(a1 + 18) = v3; v7 > v3; unsigned int v7 = *(unsigned __int16 *)(a1 + 16))
  {
    if (utf8_BelongsToSet(1u, *(unsigned char **)(a1 + 8), v3, v7)) {
      break;
    }
    LODWORD(v3) = (unsigned __int16)utf8_GetNextUtf8OffsetLimit(*(unsigned char **)(a1 + 8), v3, *(unsigned __int16 *)(a1 + 16));
  }
  *(_WORD *)(a1 + 20) = v3;
  return 0;
}

uint64_t WordScanner_ConFrom(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__WordScanner;
    if (a2)
    {
      *(void *)(a1 + 8) = a2;
      *(_WORD *)(a1 + 16) = strlen(a2);
      return WordScanner_ResetFrom(a1, a3);
    }
    else
    {
      return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"szString");
    }
  }
  return result;
}

uint64_t WordScanner_NextWord(uint64_t a1)
{
  uint64_t NextUtf8OffsetLimit = *(unsigned __int16 *)(a1 + 20);
  for (unsigned int i = *(unsigned __int16 *)(a1 + 16); i > NextUtf8OffsetLimit; unsigned int i = *(unsigned __int16 *)(a1 + 16))
  {
    int v4 = utf8_BelongsToSet(1u, *(unsigned char **)(a1 + 8), NextUtf8OffsetLimit, i);
    unsigned int i = *(unsigned __int16 *)(a1 + 16);
    if (!v4) {
      break;
    }
    uint64_t NextUtf8OffsetLimit = (unsigned __int16)utf8_GetNextUtf8OffsetLimit(*(unsigned char **)(a1 + 8), NextUtf8OffsetLimit, *(unsigned __int16 *)(a1 + 16));
  }
  if (NextUtf8OffsetLimit >= i) {
    return 0;
  }
  *(_WORD *)(a1 + 18) = NextUtf8OffsetLimit;
  do
  {
    if (utf8_BelongsToSet(1u, *(unsigned char **)(a1 + 8), NextUtf8OffsetLimit, i)) {
      break;
    }
    LODWORD(NextUtf8OffsetLimit) = (unsigned __int16)utf8_GetNextUtf8OffsetLimit(*(unsigned char **)(a1 + 8), NextUtf8OffsetLimit, *(unsigned __int16 *)(a1 + 16));
    unsigned int i = *(unsigned __int16 *)(a1 + 16);
  }
  while (i > NextUtf8OffsetLimit);
  *(_WORD *)(a1 + 20) = NextUtf8OffsetLimit;
  return 1;
}

uint64_t WordScanner_PrevWord(uint64_t a1)
{
  unsigned int v2 = *(unsigned __int16 *)(a1 + 18);
  uint64_t v3 = *(void *)(a1 + 8);
  unsigned int v4 = *(unsigned __int16 *)(a1 + 16);
  unsigned int v5 = v2;
  while (1)
  {
    unsigned int PreviousUtf8OffsetLimit = (unsigned __int16)utf8_GetPreviousUtf8OffsetLimit(v3, v5, v4);
    unsigned int v7 = *(unsigned __int16 *)(a1 + 16);
    if (PreviousUtf8OffsetLimit >= v7) {
      break;
    }
    int v8 = utf8_BelongsToSet(1u, *(unsigned char **)(a1 + 8), PreviousUtf8OffsetLimit, v7);
    unsigned int v7 = *(unsigned __int16 *)(a1 + 16);
    if (!v8) {
      break;
    }
    LOWORD(v2) = PreviousUtf8OffsetLimit;
    uint64_t v3 = *(void *)(a1 + 8);
    unsigned int v5 = PreviousUtf8OffsetLimit;
    unsigned int v4 = *(unsigned __int16 *)(a1 + 16);
  }
  if (PreviousUtf8OffsetLimit >= v7) {
    return 0;
  }
  *(_WORD *)(a1 + 20) = v2;
  while (!utf8_BelongsToSet(1u, *(unsigned char **)(a1 + 8), PreviousUtf8OffsetLimit, v7))
  {
    LOWORD(v2) = PreviousUtf8OffsetLimit;
    unsigned __int16 v9 = utf8_GetPreviousUtf8OffsetLimit(*(void *)(a1 + 8), PreviousUtf8OffsetLimit, *(unsigned __int16 *)(a1 + 16));
    unsigned int v7 = *(unsigned __int16 *)(a1 + 16);
    if (v7 <= v9) {
      break;
    }
    unsigned int PreviousUtf8OffsetLimit = v9;
  }
  *(_WORD *)(a1 + 18) = v2;
  return 1;
}

uint64_t WordScanner_WordLen(uint64_t a1)
{
  return (unsigned __int16)(*(_WORD *)(a1 + 20) - *(_WORD *)(a1 + 18));
}

uint64_t PNEW_WordScanner_ConFrom(uint64_t a1, const char *a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 24, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = WordScanner_ConFrom(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

uint64_t ooc_utils_createAllocator(uint64_t a1, _WORD *a2, int a3)
{
  uint64_t v8 = 0;
  *(void *)&long long v5 = heap_Alloc;
  *((void *)&v5 + 1) = heap_Calloc;
  uint64_t v6 = heap_Realloc;
  unsigned int v7 = heap_Free;
  if ((InitRsrcFunction(a2, a3, &v8) & 0x80000000) == 0) {
    return OOCAllocator_Con(a1, &v5, *(void *)(v8 + 8));
  }
  err_GenerateErrorInternalMsg((uint64_t)"InitRsrcFunction");
  return 9;
}

uint64_t err_GenerateErrorInternalMsg(uint64_t a1)
{
  uint64_t v3 = 0;
  unsigned int v4 = 0;
  err_ErrorGetCallback(&v4, &v3);
  if (v4) {
    v4(v3, 9, "Internal Error.", a1);
  }
  return 9;
}

uint64_t Params_Con(void *a1, _WORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    *a1 = &__Params;
    a1[1] = a2;
    a1[2] = a3;
    a1[3] = 0;
    if ((InitRsrcFunction(a2, a3, a1 + 3) & 0x80000000) != 0)
    {
      return err_GenerateErrorInternalMsg((uint64_t)"InitRsrcFunction");
    }
    else
    {
      uint64_t result = ooc_utils_createAllocator((uint64_t)(a1 + 4), (_WORD *)a1[1], a1[2]);
      if (!result) {
        a1[9] = a4;
      }
    }
  }
  return result;
}

uint64_t Params_Des(uint64_t a1)
{
  kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(a1 + 32));
  return Object_Des();
}

uint64_t Params_GetCfgParamValueFloat(uint64_t a1, unsigned char *a2, float *a3, float a4)
{
  unsigned int v10 = 0;
  if (a3)
  {
    *a3 = a4;
    uint64_t CfgParamValueString = Params_GetCfgParamValueString(a1, a2, &v10);
    unsigned int v7 = v10;
    if (CfgParamValueString || !v10)
    {
      if (!v10) {
        return CfgParamValueString;
      }
    }
    else
    {
      uint64_t CfgParamValueString = 0;
      if (*v10)
      {
        float v8 = atof(v10);
        *a3 = v8;
      }
    }
    heap_Free(*(void **)(*(void *)(a1 + 24) + 8), (uint64_t)v7);
    return CfgParamValueString;
  }
  return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pVal");
}

uint64_t Params_GetCfgParamValueString(uint64_t a1, unsigned char *a2, char **a3)
{
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  __int16 v17 = -1;
  *(_DWORD *)&__c[1] = 0;
  __c[0] = 0;
  if (!a2 || !*a2)
  {
    int v12 = "szParamName";
LABEL_17:
    uint64_t ErrorInternalMsg = kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)v12);
LABEL_18:
    uint64_t v7 = ErrorInternalMsg;
    goto LABEL_19;
  }
  if (!a3)
  {
    int v12 = "pszParamValue";
    goto LABEL_17;
  }
  *a3 = 0;
  if ((objc_GetObject(*(void *)(*(void *)(a1 + 24) + 48), (uint64_t)"FE_DCTLKP", &v19) & 0x80000000) != 0)
  {
    char v15 = "objc_GetObject";
LABEL_26:
    uint64_t ErrorInternalMsg = err_GenerateErrorInternalMsg((uint64_t)v15);
    goto LABEL_18;
  }
  uint64_t v6 = *(const char **)(a1 + 72);
  if (!strcmp(v6, "fecfg")) {
    goto LABEL_9;
  }
  if (((*(uint64_t (**)(void, void, const char *, unsigned char *))(v19[1] + 72))(v19[2], v19[3], v6, &__c[1]) & 0x80000000) != 0)
  {
    char v15 = "pIDctlkp->pfQueryDictExists";
    goto LABEL_26;
  }
  if (!*(_DWORD *)&__c[1])
  {
    uint64_t v7 = 0;
    __int16 v17 = 0;
    goto LABEL_19;
  }
  __int16 v17 = 1;
  uint64_t v6 = *(const char **)(a1 + 72);
LABEL_9:
  if (((*(uint64_t (**)(void, void, const char *, unsigned char *, char ***, __int16 *, unsigned char *))(v19[1] + 96))(v19[2], v19[3], v6, a2, &v18, &v17, __c) & 0x80000000) != 0)
  {
    char v15 = "pIDctlkp->pfLookupUtf";
    goto LABEL_26;
  }
  uint64_t v7 = 0;
  if (v17 == 1 && v18)
  {
    float v8 = *v18;
    unsigned __int16 v9 = strchr(*v18, __c[0]);
    if (v9)
    {
      *unsigned __int16 v9 = 0;
      float v8 = *v18;
    }
    int v10 = strlen(v8);
    uint64_t v11 = (char *)heap_Calloc(*(void **)(*(void *)(a1 + 24) + 8), 1, (v10 + 1));
    *a3 = v11;
    if (v11)
    {
      strcpy(v11, *v18);
      uint64_t v7 = 0;
      goto LABEL_19;
    }
    uint64_t ErrorInternalMsg = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
    goto LABEL_18;
  }
LABEL_19:
  if (v19) {
    objc_ReleaseObject(*(void *)(*(void *)(a1 + 24) + 48), (uint64_t)"FE_DCTLKP");
  }
  return v7;
}

uint64_t Params_GetCfgParamValueInteger(uint64_t a1, unsigned char *a2, int a3, int *a4)
{
  unsigned __int16 v9 = 0;
  if (a4)
  {
    *a4 = a3;
    uint64_t CfgParamValueString = Params_GetCfgParamValueString(a1, a2, &v9);
    uint64_t v7 = v9;
    if (CfgParamValueString || !v9)
    {
      if (!v9) {
        return CfgParamValueString;
      }
    }
    else
    {
      uint64_t CfgParamValueString = 0;
      if (*v9) {
        *a4 = atoi(v9);
      }
    }
    heap_Free(*(void **)(*(void *)(a1 + 24) + 8), (uint64_t)v7);
    return CfgParamValueString;
  }
  return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"pVal");
}

uint64_t Params_GetCfgParamValueListOfStrings(uint64_t a1, unsigned char *a2, unsigned __int8 a3, uint64_t *a4)
{
  uint64_t v11 = 0;
  if (*a4
    || (uint64_t CfgParamValueString = PNEW_StringList_Con(a1 + 32, *(_WORD **)(a1 + 8), *(void *)(a1 + 16), a4),
        !CfgParamValueString))
  {
    uint64_t CfgParamValueString = Params_GetCfgParamValueString(a1, a2, &v11);
    unsigned __int16 v9 = v11;
    if (!CfgParamValueString && v11)
    {
      uint64_t CfgParamValueString = StringList_FromSplitString(*a4, v11, a3);
      unsigned __int16 v9 = v11;
    }
    if (v9) {
      heap_Free(*(void **)(*(void *)(a1 + 24) + 8), (uint64_t)v9);
    }
  }
  return CfgParamValueString;
}

uint64_t PNEW_Params_Con(uint64_t a1, _WORD *a2, uint64_t a3, uint64_t a4, void *a5)
{
  unsigned int v12 = 0;
  int v10 = (void *)OOCAllocator_Malloc(a1, 80, &v12);
  uint64_t result = v12;
  if (!v12)
  {
    uint64_t result = Params_Con(v10, a2, a3, a4);
    unsigned int v12 = result;
    if (result)
    {
      OOCAllocator_Free(a1, (uint64_t)v10);
      *a5 = 0;
      return v12;
    }
    else
    {
      *a5 = v10;
    }
  }
  return result;
}

uint64_t StringList_Con(uint64_t a1, _WORD *a2, uint64_t a3)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(void *)a1 = &__StringList;
    *(void *)(a1 + 8) = a2;
    *(void *)(a1 + 16) = a3;
    *(_WORD *)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = 0;
    *(_WORD *)(a1 + 64) = -1;
    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 24) = 0;
    int inited = InitRsrcFunction(a2, a3, (void *)(a1 + 24));
    uint64_t result = 0;
    if (inited < 0)
    {
      return err_GenerateErrorInternalMsg((uint64_t)"InitRsrcFunction");
    }
  }
  return result;
}

uint64_t StringList_Des(void *a1)
{
  StringList_Reset(a1);
  return Object_Des();
}

void *StringList_Reset(void *result)
{
  uint64_t v1 = result;
  unsigned int v2 = (uint64_t *)result[4];
  if (v2)
  {
    uint64_t v3 = *v2;
    if (*v2)
    {
      uint64_t v4 = 0;
      int v5 = 0;
      do
      {
        heap_Free(*(void **)(v1[3] + 8), v3);
        *(void *)(v1[4] + 8 * v4) = 0;
        ++v5;
        unsigned int v2 = (uint64_t *)v1[4];
        uint64_t v4 = (unsigned __int16)v5;
        uint64_t v3 = v2[(unsigned __int16)v5];
      }
      while (v3);
    }
    uint64_t result = heap_Free(*(void **)(v1[3] + 8), (uint64_t)v2);
    v1[4] = 0;
    *((_WORD *)v1 + 20) = 0;
  }
  v1[6] = 0;
  v1[7] = 0;
  *((_WORD *)v1 + 32) = -1;
  return result;
}

uint64_t StringList_Append(uint64_t a1, char *__s)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    int v3 = 0;
    do
      unsigned __int16 v4 = v3;
    while (*(void *)(v2 + 8 * (unsigned __int16)v3++));
  }
  else
  {
    unsigned __int16 v4 = 0;
  }
  return StringList_InsertAt(a1, v4, __s);
}

uint64_t StringList_InsertAt(uint64_t a1, unsigned int a2, char *__s)
{
  uint64_t v6 = *(void *)(a1 + 32);
  if (v6)
  {
    int v7 = 0;
    do
      unsigned __int16 v8 = v7;
    while (*(void *)(v6 + 8 * (unsigned __int16)v7++));
  }
  else
  {
    unsigned __int16 v8 = 0;
  }
  unsigned int v10 = v8;
  if (v8 < a2) {
    return 3;
  }
  unsigned int v12 = *(unsigned __int16 *)(a1 + 40);
  if (v8 + 2 > v12)
  {
    unsigned __int16 v13 = v12 + 20;
    uint64_t v14 = (kaldi::nnet1::UpdatableComponent *)heap_Realloc(*(uint64_t **)(*(void *)(a1 + 24) + 8), v6, 8 * (unsigned __int16)(v12 + 20));
    if (!v14) {
      goto LABEL_15;
    }
    char v15 = v14;
    if (v10 < v13) {
      bzero((char *)v14 + 8 * v10, 8 * (unsigned __int16)(v12 - v10 + 19) + 8);
    }
    *(void *)(a1 + 32) = v15;
    *(_WORD *)(a1 + 40) = v13;
  }
  size_t v16 = strlen(__s);
  uint64_t v14 = (kaldi::nnet1::UpdatableComponent *)__StringList_hlpDuplicateSubString(a1, (uint64_t)__s, 0, v16);
  if (v14)
  {
    __int16 v17 = v14;
    uint64_t v18 = *(void *)(a1 + 32) + 8 * a2;
    memmove((void *)(v18 + 8), (const void *)v18, 8 * (int)(v10 - a2));
    uint64_t result = 0;
    *(void *)(*(void *)(a1 + 32) + 8 * a2) = v17;
    return result;
  }
LABEL_15:
  return kaldi::nnet1::UpdatableComponent::IsUpdatable(v14);
}

uint64_t StringList_GetCountStrings(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    int v2 = 0;
    do
      unsigned __int16 v3 = v2;
    while (*(void *)(v1 + 8 * (unsigned __int16)v2++));
  }
  else
  {
    return 0;
  }
  return v3;
}

uint64_t StringList_FromSplitString(uint64_t a1, const char *a2, unsigned __int8 a3)
{
  int v5 = a3;
  StringList_Reset((void *)a1);
  size_t v6 = strlen(a2);
  size_t v7 = v6;
  uint64_t v8 = 0;
  unsigned __int16 v9 = 0;
  uint64_t v10 = 1;
  if (v6 + 1 > 1) {
    uint64_t v10 = v6 + 1;
  }
  do
  {
    int v11 = a2[v8];
    if (v11 == v5 || v11 == 0) {
      ++v9;
    }
    ++v8;
  }
  while (v10 != v8);
  int v13 = v9 + 1;
  uint64_t v14 = (kaldi::nnet1::UpdatableComponent *)heap_Calloc(*(void **)(*(void *)(a1 + 24) + 8), 1, (8 * v13));
  *(void *)(a1 + 32) = v14;
  if (v14)
  {
    uint64_t v15 = 0;
    unint64_t v16 = 0;
    unsigned __int16 v17 = 0;
    *(_WORD *)(a1 + 40) = v13;
    do
    {
      int v18 = a2[v16];
      if (v18 == v5 || v18 == 0)
      {
        uint64_t v14 = (kaldi::nnet1::UpdatableComponent *)__StringList_hlpDuplicateSubString(a1, (uint64_t)a2, v15, v16);
        *(void *)(*(void *)(a1 + 32) + 8 * v17) = v14;
        if (!*(void *)(*(void *)(a1 + 32) + 8 * v17)) {
          goto LABEL_20;
        }
        ++v16;
        ++v17;
        uint64_t v15 = v16;
      }
      else
      {
        ++v16;
      }
    }
    while (v16 <= v7);
    return 0;
  }
  else
  {
LABEL_20:
    uint64_t IsUpdatable = kaldi::nnet1::UpdatableComponent::IsUpdatable(v14);
    if (IsUpdatable) {
      StringList_Reset((void *)a1);
    }
  }
  return IsUpdatable;
}

char *__StringList_hlpDuplicateSubString(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  size_t v6 = a4 - a3;
  uint64_t result = (char *)heap_Calloc(*(void **)(*(void *)(a1 + 24) + 8), 1, a4 - a3 + 1);
  if (result) {
    return strncpy(result, (const char *)(a2 + a3), v6);
  }
  return result;
}

uint64_t StringList_FromSplitStringInUtf8(uint64_t a1, char *__s, int a3, char *__src, const char *a5, _WORD *a6)
{
  uint64_t v11 = *(void *)(a1 + 32);
  if (v11
    && ((unsigned int v12 = *(unsigned __int16 *)(a1 + 64), v12 >= 7) ? (v13 = v12 == 0xFFFF) : (v13 = 1),
        !v13 || (StringList_Reset((void *)a1), (uint64_t v11 = *(void *)(a1 + 32)) != 0)))
  {
    int v14 = 0;
    do
      int v15 = v14;
    while (*(void *)(v11 + 8 * (unsigned __int16)v14++));
    int v17 = 0;
  }
  else
  {
    int v15 = 0;
    int v17 = 1;
  }
  if (a3 == 0xFFFF) {
    LOWORD(a3) = strlen(__s);
  }
  if ((unsigned __int16)v15 < (unsigned __int16)a3)
  {
    int v18 = *(uint64_t **)(*(void *)(a1 + 24) + 8);
    uint64_t v19 = 8 * (unsigned __int16)a3;
    if (v17)
    {
      uint64_t v20 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc((uint64_t)v18, v19 + 8);
      if (!v20) {
        goto LABEL_42;
      }
    }
    else
    {
      uint64_t v20 = (kaldi::nnet1::UpdatableComponent *)heap_Realloc(v18, v11, v19 + 8);
      if (!v20)
      {
LABEL_42:
        return kaldi::nnet1::UpdatableComponent::IsUpdatable(v20);
      }
    }
    int v21 = v15;
    do
      *((void *)v20 + (unsigned __int16)v21++) = 0;
    while ((unsigned __int16)v21 <= (unsigned __int16)a3);
    *(void *)(a1 + 32) = v20;
    *(_WORD *)(a1 + 40) = a3 + 1;
    uint64_t v22 = (unsigned __int16)v15;
    while (1)
    {
      uint64_t v20 = (kaldi::nnet1::UpdatableComponent *)heap_Calloc(*(void **)(*(void *)(a1 + 24) + 8), 1, 7);
      *(void *)(*(void *)(a1 + 32) + 8 * v22) = v20;
      if (!*(void *)(*(void *)(a1 + 32) + 8 * v22)) {
        goto LABEL_42;
      }
      if ((unsigned __int16)a3 == ++v22)
      {
        *(_WORD *)(a1 + 64) = 7;
        break;
      }
    }
  }
  LOWORD(v23) = 0;
  if (*__s && (_WORD)a3)
  {
    uint64_t v30 = a6;
    unint64_t v23 = 0;
    uint64_t v24 = 0;
    unsigned __int16 v25 = 0;
    do
    {
      uint64_t v26 = &__s[v24];
      unsigned __int16 v27 = Utf8_LengthInBytes((unsigned __int8 *)&__s[v24], 1);
      if (a5 && !strncmp(v26, " ", v27))
      {
        strcpy(*(char **)(*(void *)(a1 + 32) + 8 * v23), a5);
      }
      else
      {
        strncpy(*(char **)(*(void *)(a1 + 32) + 8 * v23), v26, v27);
        *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8 * v23) + v27) = 0;
      }
      ++v23;
      v25 += v27;
      if (strlen(__s) <= v25) {
        break;
      }
      uint64_t v24 = v25;
    }
    while (v23 < (unsigned __int16)a3);
    a6 = v30;
  }
  *a6 = v23;
  if ((unsigned __int16)v23 < (unsigned __int16)a3)
  {
    unint64_t v23 = (unsigned __int16)v23;
    do
    {
      uint64_t v28 = *(char **)(*(void *)(a1 + 32) + 8 * v23);
      if (__src) {
        strcpy(v28, __src);
      }
      else {
        *uint64_t v28 = 0;
      }
      ++v23;
    }
    while ((unsigned __int16)a3 != (unsigned __int16)v23);
  }
  return 0;
}

uint64_t StringList_GetAt(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2) {
    return 0;
  }
  int v3 = 0;
  do
    unsigned __int16 v4 = v3;
  while (*(void *)(v2 + 8 * (unsigned __int16)v3++));
  if (a2 < v4) {
    return *(void *)(v2 + 8 * a2);
  }
  else {
    return 0;
  }
}

uint64_t StringList_GetIndex(uint64_t a1, char *__s2)
{
  if (__s2 && (uint64_t v2 = *(const char ***)(a1 + 32), (v3 = *v2) != 0))
  {
    unsigned __int16 v5 = 0;
    while (strcmp(v3, __s2))
    {
      int v3 = v2[++v5];
      if (!v3) {
        return (unsigned __int16)-1;
      }
    }
  }
  else
  {
    return (unsigned __int16)-1;
  }
  return v5;
}

uint64_t StringList_RemoveAt(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2) {
    return 3;
  }
  int v5 = 0;
  do
    unsigned __int16 v6 = v5;
  while (*(void *)(v2 + 8 * (unsigned __int16)v5++));
  if (a2 >= v6) {
    return 3;
  }
  heap_Free(*(void **)(*(void *)(a1 + 24) + 8), *(void *)(v2 + 8 * a2));
  *(void *)(*(void *)(a1 + 32) + 8 * a2) = 0;
  uint64_t v8 = *(void *)(a1 + 32) + 8 * a2;
  memmove((void *)v8, (const void *)(v8 + 8), 8 * (int)(~a2 + v6));
  uint64_t result = 0;
  *(void *)(*(void *)(a1 + 32) + 8 * (v6 - 1)) = 0;
  return result;
}

uint64_t PNEW_StringList_Con(uint64_t a1, _WORD *a2, uint64_t a3, uint64_t *a4)
{
  unsigned int v10 = 0;
  uint64_t v8 = OOCAllocator_Malloc(a1, 72, &v10);
  uint64_t result = v10;
  if (!v10)
  {
    uint64_t result = StringList_Con(v8, a2, a3);
    unsigned int v10 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v8);
      *a4 = 0;
      return v10;
    }
    else
    {
      *a4 = v8;
    }
  }
  return result;
}

uint64_t NN_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5)
{
  uint64_t result = Object_Con((void *)a1);
  if (!result)
  {
    *(_WORD *)(a1 + 136) = 0;
    *(_WORD *)(a1 + 152) = 0;
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 144) = 0;
    *(void *)(a1 + 160) = 0;
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 112) = 0;
    *(_WORD *)(a1 + 120) = 0;
    *(void *)a1 = &__NN;
    *(void *)(a1 + 8) = a2;
    *(void *)(a1 + 16) = a3;
    *(void *)(a1 + 32) = a4;
    *(void *)(a1 + 40) = a5;
    *(void *)(a1 + 96) = 0;
    if ((InitRsrcFunction(a4, a5, (void *)(a1 + 48)) & 0x80000000) != 0
      || (InitRsrcFunction(*(_WORD **)(a1 + 8), *(void *)(a1 + 16), (void *)(a1 + 24)) & 0x80000000) != 0)
    {
      return err_GenerateErrorInternalMsg((uint64_t)"InitRsrcFunction");
    }
    else
    {
      uint64_t v11 = *(_WORD **)(a1 + 32);
      uint64_t v12 = *(void *)(a1 + 40);
      return ooc_utils_createAllocator(a1 + 56, v11, v12);
    }
  }
  return result;
}

uint64_t NN_Des(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (void *)result;
    uint64_t v2 = *(void *)(result + 96);
    if (v2)
    {
      OOCAllocator_Free(result + 56, v2);
      v1[12] = 0;
    }
    uint64_t v3 = v1[13];
    if (v3)
    {
      OOC_PlacementDeleteObject((uint64_t)(v1 + 7), v3);
      v1[13] = 0;
    }
    uint64_t v4 = v1[14];
    if (v4)
    {
      OOC_PlacementDeleteObject((uint64_t)(v1 + 7), v4);
      v1[14] = 0;
    }
    __NN_CGN_Deinitialize((uint64_t)v1);
    __NN_TN_Deinitialize((uint64_t)v1);
    __NN_CLM_Deinitialize((uint64_t)v1);
    kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(v1 + 7));
    return Object_Des();
  }
  return result;
}

uint64_t __NN_CGN_Deinitialize(uint64_t result)
{
  uint64_t v1 = result;
  unsigned int v2 = *(unsigned __int16 *)(result + 120);
  if (*(_WORD *)(result + 120))
  {
    unint64_t v3 = 0;
    do
    {
      uint64_t v4 = *(void *)(*(void *)(v1 + 128) + 8 * v3);
      if (v4)
      {
        uint64_t result = OOC_PlacementDeleteObject(v1 + 56, v4);
        *(void *)(*(void *)(v1 + 128) + 8 * v3) = 0;
        unsigned int v2 = *(unsigned __int16 *)(v1 + 120);
      }
      ++v3;
    }
    while (v3 < v2);
    if (v2)
    {
      uint64_t result = OOCAllocator_Free(v1 + 56, *(void *)(v1 + 128));
      *(void *)(v1 + 128) = 0;
    }
  }
  *(_WORD *)(v1 + 120) = 0;
  return result;
}

uint64_t __NN_TN_Deinitialize(uint64_t result)
{
  uint64_t v1 = result;
  unsigned int v2 = *(unsigned __int16 *)(result + 136);
  if (*(_WORD *)(result + 136))
  {
    unint64_t v3 = 0;
    do
    {
      uint64_t v4 = *(void *)(*(void *)(v1 + 144) + 8 * v3);
      if (v4)
      {
        uint64_t result = OOC_PlacementDeleteObject(v1 + 56, v4);
        *(void *)(*(void *)(v1 + 144) + 8 * v3) = 0;
        unsigned int v2 = *(unsigned __int16 *)(v1 + 136);
      }
      ++v3;
    }
    while (v3 < v2);
    if (v2)
    {
      uint64_t result = OOCAllocator_Free(v1 + 56, *(void *)(v1 + 144));
      *(void *)(v1 + 144) = 0;
    }
  }
  *(_WORD *)(v1 + 136) = 0;
  return result;
}

uint64_t __NN_CLM_Deinitialize(uint64_t result)
{
  uint64_t v1 = result;
  unsigned int v2 = *(unsigned __int16 *)(result + 152);
  if (*(_WORD *)(result + 152))
  {
    unint64_t v3 = 0;
    do
    {
      uint64_t v4 = *(void *)(*(void *)(v1 + 160) + 8 * v3);
      if (v4)
      {
        uint64_t result = OOC_PlacementDeleteObject(v1 + 56, v4);
        *(void *)(*(void *)(v1 + 160) + 8 * v3) = 0;
        unsigned int v2 = *(unsigned __int16 *)(v1 + 152);
      }
      ++v3;
    }
    while (v3 < v2);
    if (v2)
    {
      uint64_t result = OOCAllocator_Free(v1 + 56, *(void *)(v1 + 160));
      *(void *)(v1 + 160) = 0;
    }
  }
  *(_WORD *)(v1 + 152) = 0;
  return result;
}

uint64_t NN_CGN_Predict(uint64_t a1, int a2, const char *a3, const char *a4, uint64_t a5, void *a6, int *a7)
{
  int v13 = safeh_HandleCheck(a1, a2, 1067, 8);
  uint64_t result = 2706382856;
  if ((v13 & 0x80000000) == 0 && a1)
  {
    if (NN_IsInitializedForCurrent(a1))
    {
      uint64_t v15 = *(unsigned __int16 *)(a1 + 120);
      if (!*(_WORD *)(a1 + 120)) {
        goto LABEL_9;
      }
      unint64_t v16 = *(uint64_t **)(a1 + 128);
      while (1)
      {
        uint64_t v17 = *v16;
        if (*v16)
        {
          if (!strcmp(a3, *(const char **)(v17 + 120))) {
            break;
          }
        }
        ++v16;
        if (!--v15) {
          goto LABEL_9;
        }
      }
      uint64_t result = CGN_Predict(v17, a4, a5, a6, a7);
      if (result)
      {
        uint64_t result = LH_ERROR_to_VERROR(result);
        if ((result & 0x1FFF) == 7)
        {
LABEL_9:
          uint64_t result = 0;
          *a7 = 0;
        }
      }
    }
    else
    {
      return 2706382848;
    }
  }
  return result;
}

BOOL NN_IsInitializedForCurrent(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  if (__NN_GetIdentificationForCurrent(a1, __s1)) {
    return 0;
  }
  unint64_t v3 = *(const char **)(a1 + 96);
  return v3 && strcmp(__s1, v3) == 0;
}

BOOL NN_CGN_QueryModelExists(uint64_t a1, int a2, const char *a3)
{
  if ((safeh_HandleCheck(a1, a2, 1067, 8) & 0x80000000) != 0) {
    return 0;
  }
  if (!a1) {
    return 0;
  }
  if (!NN_IsInitializedForCurrent(a1)) {
    return 0;
  }
  uint64_t v5 = *(unsigned __int16 *)(a1 + 120);
  if (!*(_WORD *)(a1 + 120)) {
    return 0;
  }
  for (unsigned int i = *(uint64_t **)(a1 + 128); ; ++i)
  {
    uint64_t v7 = *i;
    if (*i)
    {
      if (!strcmp(a3, *(const char **)(v7 + 120))) {
        break;
      }
    }
    if (!--v5) {
      return 0;
    }
  }
  return Model_QueryExists(v7);
}

uint64_t NN_CLM_Predict(uint64_t a1, int a2, const char *a3, char **a4, char **a5, char **a6, unsigned int *a7, uint64_t a8, uint64_t a9)
{
  int v16 = safeh_HandleCheck(a1, a2, 1067, 8);
  uint64_t result = 2706382856;
  if ((v16 & 0x80000000) == 0 && a1)
  {
    if (NN_IsInitializedForCurrent(a1))
    {
      uint64_t v18 = *(unsigned __int16 *)(a1 + 152);
      if (!*(_WORD *)(a1 + 152)) {
        goto LABEL_9;
      }
      uint64_t v19 = *(uint64_t **)(a1 + 160);
      while (1)
      {
        uint64_t v20 = *v19;
        if (*v19)
        {
          if (!strcmp(a3, *(const char **)(v20 + 120))) {
            break;
          }
        }
        ++v19;
        if (!--v18) {
          goto LABEL_9;
        }
      }
      uint64_t result = CLM_Predict(v20, a4, a5, a6, *a7, a8, a9);
      if (result)
      {
        uint64_t result = LH_ERROR_to_VERROR(result);
        if ((result & 0x1FFF) == 7)
        {
LABEL_9:
          uint64_t result = 0;
          *a7 = 0;
        }
      }
    }
    else
    {
      return 2706382848;
    }
  }
  return result;
}

BOOL NN_CLM_QueryModelExists(uint64_t a1, int a2, const char *a3)
{
  if ((safeh_HandleCheck(a1, a2, 1067, 8) & 0x80000000) != 0) {
    return 0;
  }
  if (!a1) {
    return 0;
  }
  if (!NN_IsInitializedForCurrent(a1)) {
    return 0;
  }
  uint64_t v5 = *(unsigned __int16 *)(a1 + 152);
  if (!*(_WORD *)(a1 + 152)) {
    return 0;
  }
  for (unsigned int i = *(uint64_t **)(a1 + 160); ; ++i)
  {
    uint64_t v7 = *i;
    if (*i)
    {
      if (!strcmp(a3, *(const char **)(v7 + 120))) {
        break;
      }
    }
    if (!--v5) {
      return 0;
    }
  }
  return Model_QueryExists(v7);
}

uint64_t NN_ClassClose()
{
  return 0;
}

uint64_t NN_ClassOpen(_WORD *a1, uint64_t a2, void *a3)
{
  uint64_t v7 = 0;
  if (!a3) {
    return 2706382855;
  }
  uint64_t result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *a3 = a1;
    a3[1] = a2;
  }
  return result;
}

uint64_t NN_G2POneWord_Predict(uint64_t a1, int a2, char *a3, void *a4)
{
  uint64_t v7 = safeh_HandleCheck(a1, a2, 1067, 8);
  uint64_t result = 2706382856;
  if ((v7 & 0x80000000) == 0 && a1)
  {
    if (NN_IsInitializedForCurrent(a1))
    {
      uint64_t v9 = *(void *)(a1 + 112);
      if (v9)
      {
        int v10 = G2POneWord_Predict(v9, a3, a4);
        uint64_t result = v7;
        if (v10)
        {
          return LH_ERROR_to_VERROR(v10);
        }
      }
      else
      {
        return v7;
      }
    }
    else
    {
      return 2706382848;
    }
  }
  return result;
}

BOOL NN_G2POneWord_QueryModelExists(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 1067, 8) & 0x80000000) != 0) {
    return 0;
  }
  if (!a1) {
    return 0;
  }
  if (!NN_IsInitializedForCurrent(a1)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 112);
  if (!v3) {
    return 0;
  }
  return Model_QueryExists(v3);
}

uint64_t NN_InitializeForCurrent(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (NN_IsInitializedForCurrent(a1)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 96);
  if (v3)
  {
    OOCAllocator_Free(a1 + 56, v3);
    *(void *)(a1 + 96) = 0;
  }
  uint64_t v5 = (uint64_t *)(a1 + 104);
  uint64_t v4 = *(void *)(a1 + 104);
  if (v4)
  {
    OOC_PlacementDeleteObject(a1 + 56, v4);
    *(void *)(a1 + 104) = 0;
  }
  uint64_t v6 = *(void *)(a1 + 112);
  if (v6)
  {
    OOC_PlacementDeleteObject(a1 + 56, v6);
    *(void *)(a1 + 112) = 0;
  }
  __NN_CGN_Deinitialize(a1);
  __NN_TN_Deinitialize(a1);
  __NN_CLM_Deinitialize(a1);
  uint64_t IdentificationForCurrent = __NN_GetIdentificationForCurrent(a1, __s);
  unsigned int v11 = IdentificationForCurrent;
  if (!IdentificationForCurrent)
  {
    size_t v7 = strlen(__s);
    uint64_t v8 = (char *)OOCAllocator_Malloc(a1 + 56, v7 + 1, &v11);
    *(void *)(a1 + 96) = v8;
    uint64_t IdentificationForCurrent = v11;
    if (!v11)
    {
      strcpy(v8, __s);
      int v12 = 0;
      uint64_t v9 = PNEW_ToBeSpelled_Con(a1 + 56, *(void *)(a1 + 8), *(void *)(a1 + 16), *(_WORD **)(a1 + 32), *(void *)(a1 + 40), (uint64_t *)(a1 + 104));
      if (v9) {
        return v9;
      }
      uint64_t IdentificationForCurrent = ToBeSpelled_LoadModel(*v5, &v12);
      if (IdentificationForCurrent || !v12)
      {
        OOC_PlacementDeleteObject(a1 + 56, *v5);
        *uint64_t v5 = 0;
        unsigned int v11 = IdentificationForCurrent;
        if (IdentificationForCurrent) {
          return IdentificationForCurrent;
        }
      }
      else
      {
        unsigned int v11 = 0;
      }
      uint64_t IdentificationForCurrent = __NN_G2POneWord_Initialize(a1);
      unsigned int v11 = IdentificationForCurrent;
      if (!IdentificationForCurrent)
      {
        uint64_t IdentificationForCurrent = __NN_CGN_Initialize(a1);
        unsigned int v11 = IdentificationForCurrent;
        if (!IdentificationForCurrent)
        {
          uint64_t IdentificationForCurrent = __NN_TN_Initialize(a1);
          unsigned int v11 = IdentificationForCurrent;
          if (!IdentificationForCurrent) {
            return __NN_CLM_Initialize(a1);
          }
        }
      }
    }
  }
  return IdentificationForCurrent;
}

uint64_t __NN_GetIdentificationForCurrent(uint64_t a1, char *a2)
{
  __s2 = 0;
  __src = 0;
  size_t v7 = 0;
  if ((paramc_ParamGetStr(*(void *)(*(void *)(a1 + 48) + 40), (uint64_t)"langcode", &__src) & 0x80000000) != 0
    || (paramc_ParamGetStr(*(void *)(*(void *)(a1 + 48) + 40), (uint64_t)"fecfg", &__s2) & 0x80000000) != 0)
  {
    return err_GenerateErrorInternalMsg((uint64_t)"paramc_ParamGetStr");
  }
  if ((paramc_ParamGetStr(*(void *)(*(void *)(a1 + 48) + 40), (uint64_t)"voice", &v7) & 0x80000000) != 0) {
    size_t v7 = 0;
  }
  uint64_t v4 = strcpy(a2, __src);
  *(_WORD *)&a2[strlen(v4)] = 95;
  strcat(a2, __s2);
  if (v7)
  {
    *(_WORD *)&a2[strlen(a2)] = 95;
    strcat(a2, v7);
  }
  if (*a2)
  {
    size_t v5 = 0;
    do
    {
      a2[v5] = __tolower(a2[v5]);
      ++v5;
    }
    while (v5 < strlen(a2));
  }
  return 0;
}

uint64_t __NN_G2POneWord_Initialize(uint64_t a1)
{
  int v7 = 0;
  uint64_t v1 = a1 + 56;
  unsigned int v2 = (uint64_t *)(a1 + 112);
  uint64_t v3 = PNEW_G2POneWord_Con(a1 + 56, *(void *)(a1 + 8), *(void *)(a1 + 16), *(_WORD **)(a1 + 32), *(void *)(a1 + 40), (uint64_t *)(a1 + 112));
  if (!v3)
  {
    uint64_t v4 = G2POneWord_LoadModel(*v2, &v7);
    if (v4) {
      BOOL v5 = 1;
    }
    else {
      BOOL v5 = v7 == 0;
    }
    if (v5)
    {
      uint64_t v3 = v4;
      OOC_PlacementDeleteObject(v1, *v2);
      *unsigned int v2 = 0;
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

uint64_t __NN_CGN_Initialize(uint64_t a1)
{
  uint64_t v11 = 0;
  int v10 = 0;
  uint64_t v2 = a1 + 56;
  unsigned int ErrorInternalMsg = PNEW_StringList_Con(a1 + 56, *(_WORD **)(a1 + 32), *(void *)(a1 + 40), &v11);
  if (!ErrorInternalMsg)
  {
    unsigned int ErrorInternalMsg = CGN_Models(*(_WORD **)(a1 + 32), *(void *)(a1 + 40), v11);
    if (!ErrorInternalMsg)
    {
      unsigned int CountStrings = StringList_GetCountStrings(v11);
      *(_WORD *)(a1 + 120) = CountStrings;
      if (CountStrings)
      {
        *(void *)(a1 + 128) = OOCAllocator_Malloc(v2, 8 * CountStrings, &ErrorInternalMsg);
        if (!ErrorInternalMsg)
        {
          if (*(_WORD *)(a1 + 120))
          {
            for (unint64_t i = 0; i < *(unsigned __int16 *)(a1 + 120); ++i)
            {
              unsigned int ErrorInternalMsg = PNEW_CGN_Con(v2, *(void *)(a1 + 8), *(void *)(a1 + 16), *(_WORD **)(a1 + 32), *(void *)(a1 + 40), (uint64_t *)(*(void *)(a1 + 128) + 8 * i));
              if (ErrorInternalMsg) {
                break;
              }
              uint64_t v6 = *(void *)(*(void *)(a1 + 128) + 8 * i);
              int v7 = (char *)StringList_GetAt(v11, (unsigned __int16)i);
              unsigned int v8 = CGN_LoadModel(v6, v7, &v10);
              unsigned int ErrorInternalMsg = v8;
              if (v8) {
                BOOL v9 = 1;
              }
              else {
                BOOL v9 = v10 == 0;
              }
              if (v9)
              {
                if (!v8) {
                  unsigned int ErrorInternalMsg = err_GenerateErrorInternalMsg((uint64_t)"not loaded");
                }
                OOC_PlacementDeleteObject(v2, *(void *)(*(void *)(a1 + 128) + 8 * i));
                *(void *)(*(void *)(a1 + 128) + 8 * i) = 0;
                break;
              }
            }
          }
        }
      }
    }
  }
  if (v11) {
    OOC_PlacementDeleteObject(v2, v11);
  }
  return ErrorInternalMsg;
}

uint64_t __NN_TN_Initialize(uint64_t a1)
{
  uint64_t v11 = 0;
  int v10 = 0;
  uint64_t v2 = a1 + 56;
  unsigned int ErrorInternalMsg = PNEW_StringList_Con(a1 + 56, *(_WORD **)(a1 + 32), *(void *)(a1 + 40), &v11);
  if (!ErrorInternalMsg)
  {
    unsigned int ErrorInternalMsg = TN_Models(*(_WORD **)(a1 + 32), *(void *)(a1 + 40), v11);
    if (!ErrorInternalMsg)
    {
      unsigned int CountStrings = StringList_GetCountStrings(v11);
      *(_WORD *)(a1 + 136) = CountStrings;
      if (CountStrings)
      {
        *(void *)(a1 + 144) = OOCAllocator_Malloc(v2, 8 * CountStrings, &ErrorInternalMsg);
        if (!ErrorInternalMsg)
        {
          if (*(_WORD *)(a1 + 136))
          {
            for (unint64_t i = 0; i < *(unsigned __int16 *)(a1 + 136); ++i)
            {
              unsigned int ErrorInternalMsg = PNEW_TN_Con(v2, *(void *)(a1 + 8), *(void *)(a1 + 16), *(_WORD **)(a1 + 32), *(void *)(a1 + 40), (uint64_t *)(*(void *)(a1 + 144) + 8 * i));
              if (ErrorInternalMsg) {
                break;
              }
              uint64_t v6 = *(void *)(*(void *)(a1 + 144) + 8 * i);
              int v7 = (char *)StringList_GetAt(v11, (unsigned __int16)i);
              unsigned int v8 = TN_LoadModel(v6, v7, &v10);
              unsigned int ErrorInternalMsg = v8;
              if (v8) {
                BOOL v9 = 1;
              }
              else {
                BOOL v9 = v10 == 0;
              }
              if (v9)
              {
                if (!v8) {
                  unsigned int ErrorInternalMsg = err_GenerateErrorInternalMsg((uint64_t)"not loaded");
                }
                OOC_PlacementDeleteObject(v2, *(void *)(*(void *)(a1 + 144) + 8 * i));
                *(void *)(*(void *)(a1 + 144) + 8 * i) = 0;
                break;
              }
            }
          }
        }
      }
    }
  }
  if (v11) {
    OOC_PlacementDeleteObject(v2, v11);
  }
  return ErrorInternalMsg;
}

uint64_t __NN_CLM_Initialize(uint64_t a1)
{
  uint64_t v11 = 0;
  int v10 = 0;
  uint64_t v2 = a1 + 56;
  unsigned int ErrorInternalMsg = PNEW_StringList_Con(a1 + 56, *(_WORD **)(a1 + 32), *(void *)(a1 + 40), &v11);
  if (!ErrorInternalMsg)
  {
    unsigned int ErrorInternalMsg = CLM_Models(*(_WORD **)(a1 + 32), *(void *)(a1 + 40), v11);
    if (!ErrorInternalMsg)
    {
      unsigned int CountStrings = StringList_GetCountStrings(v11);
      *(_WORD *)(a1 + 152) = CountStrings;
      if (CountStrings)
      {
        *(void *)(a1 + 160) = OOCAllocator_Malloc(v2, 8 * CountStrings, &ErrorInternalMsg);
        if (!ErrorInternalMsg)
        {
          if (*(_WORD *)(a1 + 152))
          {
            for (unint64_t i = 0; i < *(unsigned __int16 *)(a1 + 152); ++i)
            {
              unsigned int ErrorInternalMsg = PNEW_CLM_Con(v2, *(void *)(a1 + 8), *(void *)(a1 + 16), *(_WORD **)(a1 + 32), *(void *)(a1 + 40), (uint64_t *)(*(void *)(a1 + 160) + 8 * i));
              if (ErrorInternalMsg) {
                break;
              }
              uint64_t v6 = *(void *)(*(void *)(a1 + 160) + 8 * i);
              int v7 = (char *)StringList_GetAt(v11, (unsigned __int16)i);
              unsigned int v8 = CLM_LoadModel(v6, v7, &v10);
              unsigned int ErrorInternalMsg = v8;
              if (v8) {
                BOOL v9 = 1;
              }
              else {
                BOOL v9 = v10 == 0;
              }
              if (v9)
              {
                if (!v8) {
                  unsigned int ErrorInternalMsg = err_GenerateErrorInternalMsg((uint64_t)"not loaded");
                }
                OOC_PlacementDeleteObject(v2, *(void *)(*(void *)(a1 + 160) + 8 * i));
                *(void *)(*(void *)(a1 + 160) + 8 * i) = 0;
                break;
              }
            }
          }
        }
      }
    }
  }
  if (v11) {
    OOC_PlacementDeleteObject(v2, v11);
  }
  return ErrorInternalMsg;
}

uint64_t NN_ObjClose(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 1067, 8) & 0x80000000) == 0)
  {
    if (a1)
    {
      uint64_t v6 = 0;
      memset(v5, 0, sizeof(v5));
      int Allocator = ooc_utils_createAllocator((uint64_t)v5, *(_WORD **)(a1 + 32), *(void *)(a1 + 40));
      if (Allocator || (int Allocator = OOC_PlacementDeleteObject((uint64_t)v5, a1)) != 0) {
        LH_ERROR_to_VERROR(Allocator);
      }
    }
  }
  return 0;
}

uint64_t NN_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v18 = 0;
  if (!a5) {
    return 2706382855;
  }
  uint64_t v17 = 0;
  memset(v16, 0, sizeof(v16));
  *(void *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  int Allocator = ooc_utils_createAllocator((uint64_t)v16, a3, a4);
  if (Allocator) {
    return LH_ERROR_to_VERROR(Allocator);
  }
  int v12 = PNEW_NN_Con((uint64_t)v16, a1, a2, a3, a4, &v18);
  if (v12)
  {
    uint64_t v13 = LH_ERROR_to_VERROR(v12);
  }
  else
  {
    uint64_t v14 = v18;
    *(void *)a5 = v18;
    *(_DWORD *)(a5 + 8) = 1067;
    uint64_t v13 = NN_ObjReopen(v14, *(void *)(a5 + 8));
  }
  uint64_t v11 = v13;
  kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)v16);
  return v11;
}

uint64_t PNEW_NN_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 168, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = NN_Con(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *a6 = v12;
    }
  }
  return result;
}

uint64_t NN_ObjReopen(uint64_t a1, int a2)
{
  uint64_t v3 = safeh_HandleCheck(a1, a2, 1067, 8);
  uint64_t result = 2706382856;
  if ((v3 & 0x80000000) == 0 && a1)
  {
    int v5 = NN_InitializeForCurrent(a1);
    if (v5)
    {
      return LH_ERROR_to_VERROR(v5);
    }
    else
    {
      return v3;
    }
  }
  return result;
}

uint64_t NN_TN_Predict(uint64_t a1, int a2, const char *a3, unsigned int a4, char *a5, unsigned int a6, unsigned int a7, void *a8, int *a9)
{
  int v16 = safeh_HandleCheck(a1, a2, 1067, 8);
  uint64_t result = 2706382856;
  if ((v16 & 0x80000000) == 0 && a1)
  {
    if (NN_IsInitializedForCurrent(a1))
    {
      uint64_t v18 = *(unsigned __int16 *)(a1 + 136);
      if (!*(_WORD *)(a1 + 136)) {
        goto LABEL_9;
      }
      uint64_t v19 = *(uint64_t **)(a1 + 144);
      while (1)
      {
        uint64_t v20 = *v19;
        if (*v19)
        {
          if (!strcmp(a3, *(const char **)(v20 + 120))) {
            break;
          }
        }
        ++v19;
        if (!--v18) {
          goto LABEL_9;
        }
      }
      uint64_t result = TN_Predict(v20, a4, a5, a6, a7, a8, a9);
      if (result)
      {
        uint64_t result = LH_ERROR_to_VERROR(result);
        if ((result & 0x1FFF) == 7)
        {
LABEL_9:
          uint64_t result = 0;
          *a9 = 0;
        }
      }
    }
    else
    {
      return 2706382848;
    }
  }
  return result;
}

BOOL NN_TN_QueryModelExists(uint64_t a1, int a2, const char *a3)
{
  if ((safeh_HandleCheck(a1, a2, 1067, 8) & 0x80000000) != 0) {
    return 0;
  }
  if (!a1) {
    return 0;
  }
  if (!NN_IsInitializedForCurrent(a1)) {
    return 0;
  }
  uint64_t v5 = *(unsigned __int16 *)(a1 + 136);
  if (!*(_WORD *)(a1 + 136)) {
    return 0;
  }
  for (unint64_t i = *(uint64_t **)(a1 + 144); ; ++i)
  {
    uint64_t v7 = *i;
    if (*i)
    {
      if (!strcmp(a3, *(const char **)(v7 + 120))) {
        break;
      }
    }
    if (!--v5) {
      return 0;
    }
  }
  return Model_QueryExists(v7);
}

uint64_t NN_ToBeSpelled_Predict(uint64_t a1, int a2, char *a3, _DWORD *a4)
{
  uint64_t v7 = safeh_HandleCheck(a1, a2, 1067, 8);
  uint64_t result = 2706382856;
  if ((v7 & 0x80000000) == 0 && a1)
  {
    if (NN_IsInitializedForCurrent(a1))
    {
      uint64_t v9 = *(void *)(a1 + 104);
      if (v9)
      {
        int v10 = ToBeSpelled_Predict(v9, a3, a4);
        uint64_t result = v7;
        if (v10)
        {
          return LH_ERROR_to_VERROR(v10);
        }
      }
      else
      {
        return v7;
      }
    }
    else
    {
      return 2706382848;
    }
  }
  return result;
}

BOOL NN_ToBeSpelled_QueryModelExists(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 1067, 8) & 0x80000000) != 0) {
    return 0;
  }
  if (!a1) {
    return 0;
  }
  if (!NN_IsInitializedForCurrent(a1)) {
    return 0;
  }
  uint64_t v3 = *(void *)(a1 + 104);
  if (!v3) {
    return 0;
  }
  return Model_QueryExists(v3);
}

uint64_t _Model_Con(void *a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5)
{
  uint64_t result = Object_Con(a1);
  if (!result)
  {
    a1[12] = 0;
    a1[13] = 0;
    a1[14] = -1;
    *a1 = &__Model;
    a1[1] = a2;
    a1[2] = a3;
    a1[4] = a4;
    a1[5] = a5;
    a1[3] = 0;
    a1[6] = 0;
    if ((InitRsrcFunction(a4, a5, a1 + 6) & 0x80000000) == 0)
    {
      uint64_t result = ooc_utils_createAllocator((uint64_t)(a1 + 7), (_WORD *)a1[4], a1[5]);
      if (result) {
        return result;
      }
      if ((InitRsrcFunction((_WORD *)a1[1], a1[2], a1 + 3) & 0x80000000) == 0) {
        return 0;
      }
    }
    return err_GenerateErrorInternalMsg((uint64_t)"InitRsrcFunction");
  }
  return result;
}

uint64_t Model_Des(uint64_t a1)
{
  kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(a1 + 56));
  return Object_Des();
}

BOOL Model_QueryExists(BOOL result)
{
  if (result) {
    return *(void *)(result + 104) != 0;
  }
  return result;
}

uint64_t _Model_Load(uint64_t a1, char *a2, _DWORD *a3)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t result = (*(uint64_t (**)(uint64_t, _DWORD *))(*(void *)a1 + 24))(a1, a3);
  if (result) {
    return result;
  }
  if (!*a3) {
    return 0;
  }
  uint64_t v11 = &byte_20D5A22AE;
  *(void *)uint64_t v12 = 0;
  memset(v13, 0, sizeof(v13));
  uint64_t v7 = heap_Calloc(*(void **)(*(void *)(a1 + 48) + 8), 1, 1024);
  *(void *)(a1 + 96) = v7;
  if (!v7)
  {
    kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
    goto LABEL_14;
  }
  unsigned int v8 = (char *)v7;
  if (strchr(a2, 58))
  {
    strcpy(v8, a2);
    goto LABEL_14;
  }
  if ((paramc_ParamGetStr(*(void *)(*(void *)(a1 + 48) + 40), (uint64_t)"langcode", v12) & 0x80000000) != 0
    || (paramc_ParamGetStr(*(void *)(*(void *)(a1 + 48) + 40), (uint64_t)"fecfg", &v11) & 0x80000000) != 0)
  {
    uint64_t v9 = "paramc_ParamGetStr";
  }
  else
  {
    __strcat_chk();
    __strcat_chk();
    __strcat_chk();
    __strcat_chk();
    __strcat_chk();
    if ((brokeraux_ComposeBrokerString(*(void *)(a1 + 48), (const char *)v13, 1, 1, *(char **)v12, 0, 0, *(char **)(a1 + 96), 0x400uLL) & 0x80000000) == 0)goto LABEL_14; {
    uint64_t v9 = "brokeraux_ComposeBrokerString";
    }
  }
  err_GenerateErrorInternalMsg((uint64_t)v9);
LABEL_14:
  if ((fi_init(*(_WORD **)(a1 + 32), *(void *)(a1 + 40), *(_WORD **)(a1 + 8), *(void *)(a1 + 16), (void *)(a1 + 104), 0, *(void *)(a1 + 96), (uint64_t)"FINN", 1, 0) & 0x80000000) != 0)return err_GenerateErrorInternalMsg((uint64_t)"fi_init"); {
  int v10 = **(_DWORD ***)(a1 + 104);
  }
  *(_DWORD *)(a1 + 112) = v10[14];
  if (v10[13] >= 2u) {
    *(_DWORD *)(a1 + 116) = v10[15];
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
}

uint64_t _Model_Unload(uint64_t *a1)
{
  uint64_t result = (*(uint64_t (**)(uint64_t *))(*a1 + 40))(a1);
  if (result) {
    return result;
  }
  uint64_t v3 = a1[12];
  if (v3)
  {
    heap_Free(*(void **)(a1[6] + 8), v3);
    a1[12] = 0;
  }
  uint64_t v4 = (uint64_t *)a1[13];
  if (!v4) {
    goto LABEL_7;
  }
  if ((fi_deinit(a1[6], a1[3], v4) & 0x80000000) == 0)
  {
    a1[13] = 0;
    a1[14] = -1;
LABEL_7:
    uint64_t v5 = *(uint64_t (**)(uint64_t *))(*a1 + 48);
    return v5(a1);
  }
  return err_GenerateErrorInternalMsg((uint64_t)"fi_deinit");
}

void *GetModelClass()
{
  return &__Model;
}

uint64_t ToBeSpelled_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5)
{
  uint64_t v6 = _Model_Con((void *)a1, a2, a3, a4, a5);
  if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 16))(a1);
  }
  else
  {
    *(void *)a1 = &__ToBeSpelled;
    *(_DWORD *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = safeh_GetNullHandle();
    *(void *)(a1 + 144) = v7;
    *(_DWORD *)(a1 + 152) = 0;
    *(void *)(a1 + 160) = 0;
    *(_WORD *)(a1 + 168) = 0;
    *(void *)(a1 + 176) = 0;
    *(_WORD *)(a1 + 184) = 0;
    *(_DWORD *)(a1 + 188) = 0;
    *(void *)(a1 + 192) = 0;
  }
  return v6;
}

uint64_t ToBeSpelled_Des(uint64_t *a1)
{
  uint64_t result = _Model_Unload(a1);
  if (!result)
  {
    return Model_Des((uint64_t)a1);
  }
  return result;
}

uint64_t ToBeSpelled_LoadModel(uint64_t a1, _DWORD *a2)
{
  return _Model_Load(a1, "nn_tobespelled", a2);
}

uint64_t ToBeSpelled_Predict(uint64_t a1, char *a2, _DWORD *a3)
{
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  unsigned int v56 = 0;
  *a3 = 0;
  unsigned __int16 v59 = 0;
  uint64_t v5 = StringList_FromSplitStringInUtf8(*(void *)(a1 + 192), a2, *(unsigned __int16 *)(a1 + 120), "\v", "<sp>", &v59);
  if (v5) {
    goto LABEL_34;
  }
  log_OutText(*(void *)(*(void *)(a1 + 48) + 32), (uint64_t)"NN_TOBESPELLED", 5, 0, (uint64_t)"char lookup:", v6, v7, v8, 0);
  unsigned int v9 = *(_DWORD *)(a1 + 120);
  if (v9)
  {
    uint64_t v10 = 0;
    int v11 = 0;
    do
    {
      uint64_t v12 = *(void *)(*(void *)(a1 + 48) + 32);
      StringList_GetAt(*(void *)(a1 + 192), (unsigned __int16)v11);
      log_OutText(v12, (uint64_t)"NN_TOBESPELLED", 5, 0, (uint64_t)"[%d] \"%s\"", v13, v14, v15, v10);
      uint64_t v10 = (unsigned __int16)++v11;
      unsigned int v9 = *(_DWORD *)(a1 + 120);
    }
    while (v9 > (unsigned __int16)v11);
  }
  unsigned int v16 = *(_DWORD *)(a1 + 152) * v9;
  uint64_t v17 = (_DWORD *)heap_Alloc(*(void *)(*(void *)(a1 + 48) + 8), 4 * v16);
  uint64_t v58 = (uint64_t)v17;
  if (v17)
  {
    uint64_t v22 = v17;
    if (v16)
    {
      int v23 = 0;
      do
        v17[(unsigned __int16)v23++] = 0;
      while (v16 > (unsigned __int16)v23);
    }
    if (!v59) {
      goto LABEL_21;
    }
    unsigned int v24 = 0;
    while (1)
    {
      unsigned __int16 v25 = *(uint64_t (**)(void, void, uint64_t, void))(*(void *)(a1 + 128) + 56);
      uint64_t v26 = StringList_GetAt(*(void *)(a1 + 192), (unsigned __int16)v24);
      int v27 = v25(*(void *)(a1 + 136), *(void *)(a1 + 144), v26, *(void *)(a1 + 160));
      if ((v27 & 0x1FFF) == 0x14)
      {
        int v27 = (*(uint64_t (**)(void, void, const char *, void))(*(void *)(a1 + 128) + 56))(*(void *)(a1 + 136), *(void *)(a1 + 144), "$MEANW2V$", *(void *)(a1 + 160));
        if ((v27 & 0x1FFF) == 0x14) {
          break;
        }
      }
      if (v27 < 0)
      {
        uint64_t v29 = "__pIWordLkp->pfWord2fVector";
        goto LABEL_19;
      }
      memcpy(&v22[*(_DWORD *)(a1 + 152) * v24++], *(const void **)(a1 + 160), 4 * *(unsigned int *)(a1 + 152));
      if (v24 >= v59) {
        goto LABEL_21;
      }
    }
    uint64_t v29 = "mean vector $MEANW2V$ not found";
LABEL_19:
    uint64_t ErrorInternalMsg = err_GenerateErrorInternalMsg((uint64_t)v29);
  }
  else
  {
    uint64_t ErrorInternalMsg = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
  }
  uint64_t v30 = ErrorInternalMsg;
  if (ErrorInternalMsg) {
    goto LABEL_35;
  }
LABEL_21:
  if ((fi_predict(*(uint64_t ****)(a1 + 104), (const void **)&v58, *(unsigned int *)(a1 + 120), &v57, v18, v19, v20, v21) & 0x80000000) != 0)
  {
    uint64_t v37 = "fi_predict";
LABEL_33:
    uint64_t v5 = err_GenerateErrorInternalMsg((uint64_t)v37);
LABEL_34:
    uint64_t v30 = v5;
    goto LABEL_35;
  }
  if ((fi_shape_get_size((int *)(**(void **)(a1 + 104) + 92), (int *)&v56) & 0x80000000) != 0)
  {
    uint64_t v37 = "fi_shape_get_size";
    goto LABEL_33;
  }
  if (v56 != *(unsigned __int16 *)(a1 + 184))
  {
    uint64_t v37 = "Unexpected";
    goto LABEL_33;
  }
  unsigned int v55 = a3;
  unsigned __int16 v34 = 0;
  if (v56)
  {
    unsigned __int16 v35 = 0;
    float v36 = 0.0;
    do
    {
      if (v36 < *(float *)(v57 + 4 * v35))
      {
        float v36 = *(float *)(v57 + 4 * v35);
        unsigned __int16 v34 = v35;
      }
      ++v35;
    }
    while (v56 > v35);
  }
  else
  {
    float v36 = 0.0;
  }
  log_OutText(*(void *)(*(void *)(a1 + 48) + 32), (uint64_t)"NN_TOBESPELLED", 5, 0, (uint64_t)"results (threshold=%1.5lf)", v31, v32, v33, COERCE__INT64(*(float *)(a1 + 188)));
  if (v56)
  {
    uint64_t v39 = 0;
    for (unsigned __int16 i = 0; i < v56; v39 = ++i)
    {
      uint64_t v41 = *(void *)(*(void *)(a1 + 48) + 32);
      StringList_GetAt(*(void *)(a1 + 176), i);
      log_OutText(v41, (uint64_t)"NN_TOBESPELLED", 5, 0, (uint64_t)"[%3d] %1.5lf : %s %s", v42, v43, v44, v39);
    }
  }
  if (*(unsigned __int16 *)(a1 + 168) != v34)
  {
    uint64_t v50 = *(void *)(*(void *)(a1 + 48) + 32);
    uint64_t v51 = StringList_GetAt(*(void *)(a1 + 176), v34);
    StringList_GetAt(*(void *)(a1 + 176), *(unsigned __int16 *)(a1 + 168));
    log_OutText(v50, (uint64_t)"NN_TOBESPELLED", 5, 0, (uint64_t)"blocked selected prediction \"%s\"; not target label \"%s\"",
      v52,
      v53,
      v54,
      v51);
    goto LABEL_46;
  }
  if (v36 < *(float *)(a1 + 188))
  {
    uint64_t v45 = *(void *)(*(void *)(a1 + 48) + 32);
    uint64_t v46 = StringList_GetAt(*(void *)(a1 + 176), v34);
    log_OutText(v45, (uint64_t)"NN_TOBESPELLED", 5, 0, (uint64_t)"blocked selected prediction \"%s\"; value %1.5lf below pattern threshold %1.5lf",
      v47,
      v48,
      v49,
      v46);
LABEL_46:
    uint64_t v30 = 0;
    goto LABEL_35;
  }
  uint64_t v30 = 0;
  *unsigned int v55 = 1;
LABEL_35:
  if (v58) {
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), v58);
  }
  return v30;
}

uint64_t _ToBeSpelled_PostFIDeinit(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 176);
  if (v1)
  {
    OOC_PlacementDeleteObject(a1 + 56, v1);
    *(void *)(a1 + 176) = 0;
    *(_WORD *)(a1 + 184) = 0;
  }
  return 0;
}

uint64_t _ToBeSpelled_PostFIInit(uint64_t a1)
{
  if ((nn_word_lkp_GetInterface(1u, (void *)(a1 + 128)) & 0x80000000) != 0
    || (uint64_t v2 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 128) + 16),
        uint64_t NullHandle = safeh_GetNullHandle(),
        (v2(NullHandle) & 0x80000000) != 0))
  {
    unsigned int v9 = "nn_word_lkp_GetInterface";
  }
  else
  {
    if (((*(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 128) + 40))(*(void *)(a1 + 136), *(void *)(a1 + 144), a1 + 152) & 0x80000000) == 0)
    {
      unsigned int v4 = *(_DWORD *)(a1 + 152);
      if (v4 != *(_DWORD *)(a1 + 116))
      {
        err_GenerateErrorInternalMsg((uint64_t)"Mismatch between __word2vecVecLength and __inshape_dim2");
        unsigned int v4 = *(_DWORD *)(a1 + 152);
      }
      *(_DWORD *)(a1 + 120) = *(_DWORD *)(a1 + 112);
      uint64_t v5 = heap_Alloc(*(void *)(*(void *)(a1 + 48) + 8), 4 * v4);
      *(void *)(a1 + 160) = v5;
      if (v5)
      {
        uint64_t v6 = *(_WORD **)(a1 + 32);
        uint64_t v7 = *(void *)(a1 + 40);
        return PNEW_StringList_Con(a1 + 56, v6, v7, (uint64_t *)(a1 + 192));
      }
      else
      {
        return kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
      }
    }
    unsigned int v9 = "__pIWordLkp->pfGetVectorLength";
  }
  return err_GenerateErrorInternalMsg((uint64_t)v9);
}

uint64_t _ToBeSpelled_PreFIDeinit(void *a1)
{
  uint64_t v2 = a1[20];
  if (v2)
  {
    heap_Free(*(void **)(a1[6] + 8), v2);
    a1[20] = 0;
  }
  uint64_t v3 = a1[24];
  if (v3)
  {
    OOC_PlacementDeleteObject((uint64_t)(a1 + 7), v3);
    a1[24] = 0;
  }
  if (a1[16])
  {
    uint64_t NullHandle = safeh_GetNullHandle();
    if (!safeh_HandlesEqual(a1[17], a1[18], NullHandle, v5))
    {
      (*(void (**)(void, void))(a1[16] + 24))(a1[17], a1[18]);
      a1[17] = safeh_GetNullHandle();
      a1[18] = v6;
    }
    a1[16] = 0;
  }
  return 0;
}

uint64_t _ToBeSpelled_PreFIInit(uint64_t a1, _DWORD *a2)
{
  __s2 = 0;
  uint64_t v14 = 0;
  *a2 = 0;
  uint64_t v4 = a1 + 56;
  uint64_t CfgParamValueString = PNEW_Params_Con(a1 + 56, *(_WORD **)(a1 + 32), *(void *)(a1 + 40), (uint64_t)"fecfg", &v14);
  if (CfgParamValueString) {
    goto LABEL_17;
  }
  uint64_t CfgParamValueString = Params_GetCfgParamValueString(v14, "nntobespelled_prediction", &__s2);
  if (CfgParamValueString || __s2 == 0) {
    goto LABEL_17;
  }
  uint64_t v7 = (uint64_t *)(a1 + 176);
  uint64_t CfgParamValueString = Params_GetCfgParamValueListOfStrings(v14, "nntobespelled_labels", 0x3Bu, (uint64_t *)(a1 + 176));
  if (CfgParamValueString) {
    goto LABEL_17;
  }
  if (!*v7)
  {
    *(_WORD *)(a1 + 184) = 0;
LABEL_15:
    int v11 = "Unexpected";
LABEL_16:
    uint64_t CfgParamValueString = err_GenerateErrorInternalMsg((uint64_t)v11);
    goto LABEL_17;
  }
  int CountStrings = StringList_GetCountStrings(*v7);
  *(_WORD *)(a1 + 184) = CountStrings;
  if (!CountStrings) {
    goto LABEL_15;
  }
  unsigned __int16 v9 = 0;
  *a2 = 0;
  while (1)
  {
    if (*(unsigned __int16 *)(a1 + 184) <= v9)
    {
      int v11 = "Prediction does not exists";
      goto LABEL_16;
    }
    uint64_t v10 = (const char *)StringList_GetAt(*v7, v9);
    if (!strcmp(v10, __s2)) {
      break;
    }
    ++v9;
    if (*a2) {
      goto LABEL_24;
    }
  }
  *(_WORD *)(a1 + 168) = v9;
  *a2 = 1;
LABEL_24:
  uint64_t CfgParamValueString = Params_GetCfgParamValueFloat(v14, "nntobespelled_patternThreshold", (float *)(a1 + 188), 0.6);
  if (CfgParamValueString) {
    *a2 = 0;
  }
LABEL_17:
  if (v14) {
    OOC_PlacementDeleteObject(v4, v14);
  }
  if (__s2) {
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), (uint64_t)__s2);
  }
  return CfgParamValueString;
}

uint64_t PNEW_ToBeSpelled_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 200, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = ToBeSpelled_Con(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *a6 = v12;
    }
  }
  return result;
}

uint64_t G2POneWord_Des(uint64_t *a1)
{
  uint64_t result = _Model_Unload(a1);
  if (!result)
  {
    uint64_t v3 = a1[18];
    if (v3)
    {
      heap_Free(*(void **)(a1[6] + 8), v3);
      a1[18] = 0;
    }
    return Model_Des((uint64_t)a1);
  }
  return result;
}

uint64_t G2POneWord_LoadModel(uint64_t a1, _DWORD *a2)
{
  return _Model_Load(a1, "nn_g2poneword", a2);
}

uint64_t G2POneWord_Predict(uint64_t a1, char *a2, void *a3)
{
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  unsigned int v39 = 0;
  if (!a2 || !*a2)
  {
    uint64_t v10 = 0;
LABEL_8:
    uint64_t IsUpdatable = 0;
    *a3 = &byte_20D5A22AE;
    goto LABEL_9;
  }
  unsigned __int16 v44 = 0;
  uint64_t v43 = 0;
  memset(v42, 0, sizeof(v42));
  uint64_t IsUpdatable = StringList_Con((uint64_t)v42, *(_WORD **)(a1 + 32), *(void *)(a1 + 40));
  if (IsUpdatable
    || (uint64_t IsUpdatable = StringList_FromSplitStringInUtf8((uint64_t)v42, a2, 0xFFFF, 0, 0, &v44), IsUpdatable))
  {
    StringList_Des(v42);
    uint64_t v10 = 0;
LABEL_6:
    log_OutText(*(void *)(*(void *)(a1 + 48) + 32), (uint64_t)"NN_G2PONEWORD", 0, 0, (uint64_t)"%s : Error extracting features", v7, v8, v9, (uint64_t)a2);
    goto LABEL_9;
  }
  size_t v12 = strlen(a2);
  uint64_t v13 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc(*(void *)(*(void *)(a1 + 48) + 8), v12 + 1);
  uint64_t v10 = (char *)v13;
  if (v13
    && (*(unsigned char *)uint64_t v13 = 0,
        uint64_t v13 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc(*(void *)(*(void *)(a1 + 48) + 8), 4 * *(unsigned int *)(a1 + 132)), (v41 = (uint64_t)v13) != 0))
  {
    uint64_t v15 = v13;
    unsigned int v16 = *(_DWORD *)(a1 + 132);
    if (v16)
    {
      int v17 = 0;
      LOWORD(v14) = *(_WORD *)(a1 + 136);
      float v14 = (float)LODWORD(v14);
      do
        *((float *)v13 + (unsigned __int16)v17++) = v14;
      while (v16 > (unsigned __int16)v17);
    }
    if (v44)
    {
      unsigned __int16 v18 = 0;
      unsigned __int16 v19 = 0;
      do
      {
        uint64_t v20 = (char *)StringList_GetAt((uint64_t)v42, v19);
        unsigned int Index = StringList_GetIndex(*(void *)(a1 + 120), v20);
        if (Index != 0xFFFF)
        {
          unsigned int v22 = Index;
          strcat(v10, v20);
          float v14 = (float)v22;
          *((float *)v15 + v18++) = (float)v22;
          if (*(_DWORD *)(a1 + 132) - 1 == v18) {
            break;
          }
        }
        ++v19;
      }
      while (v44 > v19);
    }
    else
    {
      unsigned __int16 v18 = 0;
    }
    LOWORD(v14) = *(_WORD *)(a1 + 138);
    *((float *)v15 + v18) = (float)LODWORD(v14);
    StringList_Des(v42);
  }
  else
  {
    uint64_t IsUpdatable = kaldi::nnet1::UpdatableComponent::IsUpdatable(v13);
    StringList_Des(v42);
    if (IsUpdatable) {
      goto LABEL_6;
    }
  }
  if (!*v10) {
    goto LABEL_8;
  }
  if ((fi_predict(*(uint64_t ****)(a1 + 104), (const void **)&v41, 1, &v40, v23, v7, v8, v9) & 0x80000000) != 0)
  {
    uint64_t v28 = "nn_g2poneword:fi_predict";
LABEL_41:
    uint64_t ErrorInternalMsg = err_GenerateErrorInternalMsg((uint64_t)v28);
LABEL_42:
    uint64_t IsUpdatable = ErrorInternalMsg;
    goto LABEL_9;
  }
  if ((fi_shape_get_size((int *)(**(void **)(a1 + 104) + 92), (int *)&v39) & 0x80000000) != 0)
  {
    uint64_t v28 = "nn_g2poneword:fi_shape_get_size";
    goto LABEL_41;
  }
  if (v39)
  {
    unint64_t v24 = 0;
    uint64_t v25 = 0;
    do
    {
      unsigned int v26 = (int)*(float *)(v40 + 4 * v24);
      if (*(unsigned __int16 *)(a1 + 138) == v26) {
        break;
      }
      int v27 = (const char *)StringList_GetAt(*(void *)(a1 + 120), v26);
      if (v27) {
        v25 += strlen(v27);
      }
      ++v24;
    }
    while (v24 < v39);
  }
  else
  {
    uint64_t v25 = 0;
  }
  uint64_t v30 = (kaldi::nnet1::UpdatableComponent *)heap_Realloc(*(uint64_t **)(*(void *)(a1 + 48) + 8), *(void *)(a1 + 144), v25 + 1);
  *(void *)(a1 + 144) = v30;
  if (!a3)
  {
    uint64_t ErrorInternalMsg = kaldi::nnet1::UpdatableComponent::IsUpdatable(v30);
    goto LABEL_42;
  }
  *(unsigned char *)uint64_t v30 = 0;
  if (v39)
  {
    for (unint64_t i = 0; i < v39; ++i)
    {
      unsigned int v32 = (int)*(float *)(v40 + 4 * i);
      if (*(unsigned __int16 *)(a1 + 138) == v32) {
        break;
      }
      uint64_t v33 = (const char *)StringList_GetAt(*(void *)(a1 + 120), v32);
      if (v33) {
        strcat(*(char **)(a1 + 144), v33);
      }
    }
  }
  *a3 = *(void *)(a1 + 144);
  int v37 = strcmp(a2, v10);
  uint64_t v38 = *(void *)(*(void *)(a1 + 48) + 32);
  if (v37) {
    log_OutText(v38, (uint64_t)"NN_G2PONEWORD", 4, 0, (uint64_t)"(warning: word was [%s]) [%s]  --> [%s]", v34, v35, v36, (uint64_t)a2);
  }
  else {
    log_OutText(v38, (uint64_t)"NN_G2PONEWORD", 4, 0, (uint64_t)"[%s] --> [%s]", v34, v35, v36, (uint64_t)v10);
  }
  uint64_t IsUpdatable = 0;
LABEL_9:
  if (v41)
  {
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), v41);
    uint64_t v41 = 0;
  }
  if (v10) {
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), (uint64_t)v10);
  }
  return IsUpdatable;
}

uint64_t _G2POneWord_PostFIDeinit(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 120);
  if (v1)
  {
    OOC_PlacementDeleteObject(a1 + 56, v1);
    *(void *)(a1 + 120) = 0;
    *(_WORD *)(a1 + 128) = 0;
  }
  return 0;
}

uint64_t _G2POneWord_PostFIInit(_DWORD *a1)
{
  int v1 = a1[29];
  a1[33] = a1[28];
  if (v1 == -1) {
    return 0;
  }
  else {
    return err_GenerateErrorInternalMsg((uint64_t)"nn_g2poneword:only supports 1D inshape");
  }
}

uint64_t _G2POneWord_PreFIDeinit()
{
  return 0;
}

uint64_t _G2POneWord_PreFIInit(uint64_t a1, _DWORD *a2)
{
  uint64_t v13 = 0;
  __s = 0;
  *a2 = 0;
  uint64_t v4 = a1 + 56;
  uint64_t CfgParamValueString = PNEW_Params_Con(a1 + 56, *(_WORD **)(a1 + 32), *(void *)(a1 + 40), (uint64_t)"fecfg", &v13);
  if (!CfgParamValueString)
  {
    uint64_t CfgParamValueString = Params_GetCfgParamValueString(v13, "nn_g2poneword_vocab_separator", &__s);
    if (!CfgParamValueString)
    {
      unsigned __int8 v6 = __s && strlen(__s) == 1 ? *__s : 124;
      uint64_t v7 = (uint64_t *)(a1 + 120);
      uint64_t CfgParamValueString = Params_GetCfgParamValueListOfStrings(v13, "nn_g2poneword_vocab", v6, (uint64_t *)(a1 + 120));
      if (!CfgParamValueString)
      {
        if (*v7 && (int CountStrings = StringList_GetCountStrings(*v7), *(_WORD *)(a1 + 128) = CountStrings, CountStrings))
        {
          int Index = StringList_GetIndex(*(void *)(a1 + 120), "<pad>");
          *(_WORD *)(a1 + 136) = Index;
          if (Index == 0xFFFF)
          {
            int v11 = "nn_g2poneword:missing <pad> in vocab";
          }
          else
          {
            int v10 = StringList_GetIndex(*(void *)(a1 + 120), "<EOS>");
            *(_WORD *)(a1 + 138) = v10;
            if (v10 != 0xFFFF)
            {
              uint64_t CfgParamValueString = 0;
              *a2 = 1;
              goto LABEL_17;
            }
            int v11 = "nn_g2poneword:missing <EOS> in vocab";
          }
          uint64_t CfgParamValueString = err_GenerateErrorInternalMsg((uint64_t)v11);
        }
        else
        {
          uint64_t CfgParamValueString = 0;
        }
      }
    }
  }
LABEL_17:
  if (__s)
  {
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), (uint64_t)__s);
    __s = 0;
  }
  if (v13) {
    OOC_PlacementDeleteObject(v4, v13);
  }
  return CfgParamValueString;
}

uint64_t PNEW_G2POneWord_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 152, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = _Model_Con((void *)v12, a2, a3, a4, a5);
    if (result)
    {
      unsigned int v14 = result;
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *(void *)uint64_t v12 = &__G2POneWord;
      *(void *)(v12 + 120) = 0;
      *(_WORD *)(v12 + 128) = 0;
      *(void *)(v12 + 132) = 0xFFFFFFFF00000000;
      *(void *)(v12 + 144) = 0;
      *a6 = v12;
    }
  }
  return result;
}

uint64_t CGN_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5)
{
  uint64_t v6 = _Model_Con((void *)a1, a2, a3, a4, a5);
  if (!v6)
  {
    *(void *)a1 = &__CGN;
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = safeh_GetNullHandle();
    *(void *)(a1 + 144) = v7;
    *(void *)(a1 + 152) = safeh_GetNullHandle();
    *(void *)(a1 + 160) = v8;
    *(void *)(a1 + 208) = 0;
    *(_OWORD *)(a1 + 168) = 0u;
    *(_OWORD *)(a1 + 184) = 0u;
    *(_DWORD *)(a1 + 200) = 0;
  }
  return v6;
}

uint64_t CGN_Des(uint64_t *a1)
{
  uint64_t v2 = a1[15];
  if (v2)
  {
    heap_Free(*(void **)(a1[6] + 8), v2);
    a1[15] = 0;
  }
  uint64_t result = _Model_Unload(a1);
  if (!result)
  {
    return Model_Des((uint64_t)a1);
  }
  return result;
}

uint64_t CGN_LoadModel(uint64_t a1, char *__s, _DWORD *a3)
{
  uint64_t v6 = *(void *)(*(void *)(a1 + 48) + 8);
  size_t v7 = strlen(__s);
  uint64_t v8 = (char *)heap_Alloc(v6, v7 + 1);
  *(void *)(a1 + 120) = v8;
  if (v8
    && (strcpy(v8, __s),
        size_t v9 = strlen(__s),
        (uint64_t v8 = (char *)heap_Alloc(*(void *)(*(void *)(a1 + 48) + 8), v9 + 8)) != 0))
  {
    int v10 = v8;
    *(void *)uint64_t v8 = 0x5F6E67635F6E6ELL;
    strcat(v8, __s);
    uint64_t v11 = _Model_Load(a1, v10, a3);
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), (uint64_t)v10);
    return v11;
  }
  else
  {
    return kaldi::nnet1::UpdatableComponent::IsUpdatable((kaldi::nnet1::UpdatableComponent *)v8);
  }
}

uint64_t CGN_Models(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = a3;
  uint64_t v11 = 0;
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  uint64_t Allocator = ooc_utils_createAllocator((uint64_t)v9, a1, a2);
  if (!Allocator)
  {
    uint64_t v6 = PNEW_Params_Con((uint64_t)v9, a1, a2, (uint64_t)"fecfg", &v11);
    uint64_t v7 = v11;
    if (!v6)
    {
      uint64_t Allocator = Params_GetCfgParamValueListOfStrings(v11, "nn_cgn_models", 0x3Bu, &v12);
      uint64_t v7 = v11;
      if (!v11) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
    uint64_t Allocator = v6;
    if (v11) {
LABEL_4:
    }
      OOC_PlacementDeleteObject((uint64_t)v9, v7);
  }
LABEL_5:
  kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)v9);
  return Allocator;
}

uint64_t CGN_Predict(uint64_t a1, const char *a2, uint64_t a3, void *a4, int *a5)
{
  __s = 0;
  uint64_t v30 = 0;
  uint64_t v10 = heap_Alloc(*(void *)(*(void *)(a1 + 48) + 8), 4 * *(unsigned __int16 *)(a1 + 184) * (unint64_t)*(unsigned __int16 *)(a1 + 186));
  uint64_t v28 = v10;
  if (v10)
  {
    uint64_t v11 = v10;
    uint64_t ErrorInternalMsg = PNEW_WordScanner_ConFrom(a1 + 56, a2, a3, &v30);
    if (!ErrorInternalMsg)
    {
      unsigned int v17 = *(unsigned __int16 *)(a1 + 194);
      unsigned int v18 = *(unsigned __int16 *)(a1 + 186);
      uint64_t ErrorInternalMsg = __CGN_CloneWord(a1, v30, (uint64_t *)&__s);
      if (!ErrorInternalMsg)
      {
        unsigned __int16 v19 = (char *)(v11 + 4 * v18 * (unint64_t)v17);
        uint64_t ErrorInternalMsg = __CGN_FeaturesCurrent(a1, __s, v19);
        if (!ErrorInternalMsg)
        {
          if (*(_WORD *)(a1 + 194))
          {
            unsigned int v20 = 0;
            do
            {
              v19 += 4 * *(unsigned __int16 *)(a1 + 186);
              if (WordScanner_NextWord(v30))
              {
                uint64_t IsUpdatable = __CGN_CloneWord(a1, v30, (uint64_t *)&__s);
                if (IsUpdatable) {
                  goto LABEL_16;
                }
                uint64_t IsUpdatable = __CGN_FeaturesCurrent(a1, __s, v19);
                if (IsUpdatable) {
                  goto LABEL_16;
                }
              }
              else if (*(_WORD *)(a1 + 186))
              {
                memset_pattern16(v19, &unk_20D62D3B0, 4 * *(unsigned __int16 *)(a1 + 186));
              }
              ++v20;
              unsigned int v22 = *(unsigned __int16 *)(a1 + 194);
            }
            while (v20 < v22);
            uint64_t v11 = v28;
          }
          else
          {
            unsigned int v22 = 0;
          }
          unsigned int v25 = *(unsigned __int16 *)(a1 + 186);
          uint64_t ErrorInternalMsg = WordScanner_ResetFrom(v30, a3);
          if (!ErrorInternalMsg)
          {
            if (*(_WORD *)(a1 + 194))
            {
              int v26 = 0;
              int v27 = (char *)(v11 + 4 * v22 * (unint64_t)v25);
              while (1)
              {
                v27 -= 4 * *(unsigned __int16 *)(a1 + 186);
                if (WordScanner_PrevWord(v30))
                {
                  uint64_t IsUpdatable = __CGN_CloneWord(a1, v30, (uint64_t *)&__s);
                  if (IsUpdatable) {
                    goto LABEL_16;
                  }
                  uint64_t IsUpdatable = __CGN_FeaturesCurrent(a1, __s, v27);
                  if (IsUpdatable) {
                    goto LABEL_16;
                  }
                }
                else if (*(_WORD *)(a1 + 186))
                {
                  memset_pattern16(v27, &unk_20D62D3B0, 4 * *(unsigned __int16 *)(a1 + 186));
                }
                uint64_t ErrorInternalMsg = 0;
                if (++v26 >= *(unsigned __int16 *)(a1 + 194)) {
                  goto LABEL_17;
                }
              }
            }
            uint64_t ErrorInternalMsg = 0;
          }
        }
      }
    }
  }
  else
  {
    uint64_t IsUpdatable = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
LABEL_16:
    uint64_t ErrorInternalMsg = IsUpdatable;
  }
LABEL_17:
  if (v30) {
    OOC_PlacementDeleteObject(a1 + 56, v30);
  }
  if (__s) {
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), (uint64_t)__s);
  }
  if (!ErrorInternalMsg)
  {
    if ((fi_predict(*(uint64_t ****)(a1 + 104), (const void **)&v28, *(unsigned __int16 *)(a1 + 184), a4, v12, v13, v14, v15) & 0x80000000) != 0)
    {
      uint64_t v23 = "fi_predict";
    }
    else
    {
      if ((fi_shape_get_size((int *)(**(void **)(a1 + 104) + 92), a5) & 0x80000000) == 0)
      {
        uint64_t ErrorInternalMsg = 0;
        goto LABEL_28;
      }
      uint64_t v23 = "fi_shape_get_size";
    }
    uint64_t ErrorInternalMsg = err_GenerateErrorInternalMsg((uint64_t)v23);
  }
LABEL_28:
  if (v28) {
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), v28);
  }
  return ErrorInternalMsg;
}

uint64_t _CGN_PostFIDeinit(void *a1)
{
  *(void *)((char *)a1 + 196) = 0;
  *(void *)((char *)a1 + 190) = 0;
  uint64_t v2 = a1[26];
  if (v2) {
    heap_Free(*(void **)(a1[6] + 8), v2);
  }
  a1[26] = 0;
  return 0;
}

uint64_t _CGN_PostFIInit(uint64_t a1)
{
  if ((nn_word_lkp_GetInterface(1u, (void *)(a1 + 128)) & 0x80000000) != 0)
  {
    uint64_t v11 = "nn_word_lkp_GetInterface";
  }
  else
  {
    uint64_t v2 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 128) + 16);
    uint64_t NullHandle = safeh_GetNullHandle();
    if ((v2(NullHandle) & 0x80000000) == 0)
    {
      uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 128) + 16);
      uint64_t v5 = safeh_GetNullHandle();
      if ((v4(v5) & 0x80000000) == 0)
      {
        int v13 = 0;
        if (((*(uint64_t (**)(void, void, int *))(*(void *)(a1 + 128) + 40))(*(void *)(a1 + 136), *(void *)(a1 + 144), &v13) & 0x80000000) == 0)
        {
          if (v13 != *(unsigned __int16 *)(a1 + 196))
          {
            uint64_t v12 = "word embedding dimension";
            return err_GenerateErrorInternalMsg((uint64_t)v12);
          }
          if (((*(uint64_t (**)(void, void, int *))(*(void *)(a1 + 128) + 40))(*(void *)(a1 + 152), *(void *)(a1 + 160), &v13) & 0x80000000) == 0)
          {
            if (v13 == *(unsigned __int16 *)(a1 + 198))
            {
              uint64_t v6 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc(*(void *)(*(void *)(a1 + 48) + 8), 4 * *(unsigned __int16 *)(a1 + 196));
              *(void *)(a1 + 168) = v6;
              if (!v6) {
                return kaldi::nnet1::UpdatableComponent::IsUpdatable(v6);
              }
              uint64_t v6 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc(*(void *)(*(void *)(a1 + 48) + 8), 4 * *(unsigned __int16 *)(a1 + 198));
              *(void *)(a1 + 176) = v6;
              if (!v6) {
                return kaldi::nnet1::UpdatableComponent::IsUpdatable(v6);
              }
              unsigned __int16 v7 = (2 * *(_WORD *)(a1 + 194)) | 1;
              *(_WORD *)(a1 + 184) = v7;
              if (*(_DWORD *)(a1 + 112) == v7)
              {
                __int16 v8 = strlen(*(const char **)(a1 + 208));
                *(_WORD *)(a1 + 188) = v8;
                unsigned __int16 v9 = *(_WORD *)(a1 + 196) + (*(_WORD *)(a1 + 192) + *(_WORD *)(a1 + 190)) * *(_WORD *)(a1 + 198);
                *(_WORD *)(a1 + 186) = v9;
                if (*(_DWORD *)(a1 + 200))
                {
                  v9 += v8 + 2;
                  *(_WORD *)(a1 + 186) = v9;
                }
                if (*(_DWORD *)(a1 + 116) == v9) {
                  return 0;
                }
                uint64_t v12 = "inshape dimension 2";
              }
              else
              {
                uint64_t v12 = "inshape dimension 1";
              }
            }
            else
            {
              uint64_t v12 = "char embedding dimension";
            }
            return err_GenerateErrorInternalMsg((uint64_t)v12);
          }
        }
        uint64_t v12 = "__pIWordLkp->pfGetVectorLength";
        return err_GenerateErrorInternalMsg((uint64_t)v12);
      }
    }
    uint64_t v11 = "__pIWordLkp->pfObjOpen";
  }
  return err_GenerateErrorInternalMsg((uint64_t)v11);
}

uint64_t _CGN_PreFIDeinit(void *a1)
{
  if (a1[16])
  {
    uint64_t NullHandle = safeh_GetNullHandle();
    if (!safeh_HandlesEqual(a1[17], a1[18], NullHandle, v3))
    {
      (*(void (**)(void, void))(a1[16] + 24))(a1[17], a1[18]);
      a1[17] = safeh_GetNullHandle();
      a1[18] = v4;
    }
    uint64_t v5 = safeh_GetNullHandle();
    if (!safeh_HandlesEqual(a1[19], a1[20], v5, v6))
    {
      (*(void (**)(void, void))(a1[16] + 24))(a1[19], a1[20]);
      a1[19] = safeh_GetNullHandle();
      a1[20] = v7;
    }
    a1[16] = 0;
  }
  uint64_t v8 = a1[21];
  if (v8) {
    heap_Free(*(void **)(a1[6] + 8), v8);
  }
  uint64_t v9 = a1[22];
  a1[21] = 0;
  if (v9) {
    heap_Free(*(void **)(a1[6] + 8), v9);
  }
  *(void *)((char *)a1 + 182) = 0;
  a1[22] = 0;
  return 0;
}

uint64_t _CGN_PreFIInit(uint64_t a1, _DWORD *a2)
{
  uint64_t v11 = 0;
  *(void *)uint64_t v12 = 0;
  __s1 = 0;
  *a2 = 0;
  uint64_t v4 = a1 + 56;
  uint64_t ParamValueUnsignedShort = PNEW_Params_Con(a1 + 56, *(_WORD **)(a1 + 32), *(void *)(a1 + 40), (uint64_t)"fecfg", v12);
  if (!ParamValueUnsignedShort)
  {
    uint64_t ParamValueUnsignedShort = __CGN_GetParamValueUnsignedShort(a1, *(uint64_t *)v12, "concatenatedLeftChars", 0, (_WORD *)(a1 + 190), (uint64_t *)&v11);
    if (!ParamValueUnsignedShort)
    {
      uint64_t ParamValueUnsignedShort = __CGN_GetParamValueUnsignedShort(a1, *(uint64_t *)v12, "concatenatedRightChars", 3, (_WORD *)(a1 + 192), (uint64_t *)&v11);
      if (!ParamValueUnsignedShort)
      {
        uint64_t ParamValueUnsignedShort = __CGN_GetParamValueUnsignedShort(a1, *(uint64_t *)v12, "wordContextWindow", 5, (_WORD *)(a1 + 194), (uint64_t *)&v11);
        if (!ParamValueUnsignedShort)
        {
          uint64_t ParamValueUnsignedShort = __CGN_GetParamValueUnsignedShort(a1, *(uint64_t *)v12, "wordEmbeddingDimension", 0, (_WORD *)(a1 + 196), (uint64_t *)&v11);
          if (!ParamValueUnsignedShort)
          {
            uint64_t ParamValueUnsignedShort = __CGN_GetParamValueUnsignedShort(a1, *(uint64_t *)v12, "charEmbeddingDimension", 0, (_WORD *)(a1 + 198), (uint64_t *)&v11);
            if (!ParamValueUnsignedShort)
            {
              uint64_t ParamValueUnsignedShort = __CGN_FullParamName(a1, "wordPUNCTFeatureEnabled", (uint64_t *)&v11);
              if (!ParamValueUnsignedShort)
              {
                uint64_t ParamValueUnsignedShort = Params_GetCfgParamValueString(*(uint64_t *)v12, v11, &__s1);
                if (!ParamValueUnsignedShort)
                {
                  *(_DWORD *)(a1 + 200) = 1;
                  int v6 = __s1;
                  if (__s1)
                  {
                    if (!strcmp(__s1, "False")) {
                      *(_DWORD *)(a1 + 200) = 0;
                    }
                    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), (uint64_t)v6);
                  }
                  uint64_t ParamValueUnsignedShort = __CGN_FullParamName(a1, "wordPUNCTLoadList", (uint64_t *)&v11);
                  if (!ParamValueUnsignedShort)
                  {
                    uint64_t ParamValueUnsignedShort = Params_GetCfgParamValueString(*(uint64_t *)v12, v11, &__s1);
                    if (!ParamValueUnsignedShort)
                    {
                      uint64_t v7 = __s1;
                      if (__s1)
                      {
LABEL_18:
                        uint64_t ParamValueUnsignedShort = 0;
                        *(void *)(a1 + 208) = v7;
                        *a2 = 1;
                        goto LABEL_19;
                      }
                      uint64_t v8 = (char *)heap_Alloc(*(void *)(*(void *)(a1 + 48) + 8), 1);
                      __s1 = v8;
                      if (v8)
                      {
                        *uint64_t v8 = 0;
                        uint64_t v7 = __s1;
                        goto LABEL_18;
                      }
                      uint64_t ParamValueUnsignedShort = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
LABEL_19:
  if (*(void *)v12) {
    OOC_PlacementDeleteObject(v4, *(uint64_t *)v12);
  }
  if (v11) {
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), (uint64_t)v11);
  }
  return ParamValueUnsignedShort;
}

uint64_t __CGN_GetParamValueUnsignedShort(uint64_t a1, uint64_t a2, char *__s, int a4, _WORD *a5, uint64_t *a6)
{
  uint64_t result = __CGN_FullParamName(a1, __s, a6);
  if (!result)
  {
    int v11 = 0;
    uint64_t result = Params_GetCfgParamValueInteger(a2, (unsigned char *)*a6, a4, &v11);
    if (!result) {
      *a5 = v11;
    }
  }
  return result;
}

uint64_t __CGN_FullParamName(uint64_t a1, char *__s, uint64_t *a3)
{
  int v6 = *(uint64_t **)(*(void *)(a1 + 48) + 8);
  uint64_t v7 = *a3;
  size_t v8 = strlen(__s);
  size_t v9 = strlen(*(const char **)(a1 + 120));
  uint64_t v10 = (char *)heap_Realloc(v6, v7, v8 + v9 + 9);
  if (v10)
  {
    int v11 = v10;
    *(void *)uint64_t v10 = 0x5F6E67635F6E6ELL;
    uint64_t v12 = strcat(v10, *(const char **)(a1 + 120));
    *(_WORD *)&v11[strlen(v12)] = 95;
    strcat(v11, __s);
    *a3 = (uint64_t)v11;
    return 0;
  }
  else
  {
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
  }
}

uint64_t PNEW_CGN_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 216, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = CGN_Con(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *a6 = v12;
    }
  }
  return result;
}

uint64_t __CGN_CloneWord(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unsigned int v6 = WordScanner_WordLen(a2);
  uint64_t v7 = *(uint64_t **)(*(void *)(a1 + 48) + 8);
  size_t v8 = v6;
  size_t v9 = (char *)heap_Realloc(v7, *a3, v6 + 1);
  if (v9)
  {
    uint64_t v10 = strncpy(v9, (const char *)(*(void *)(a2 + 8) + *(unsigned __int16 *)(a2 + 18)), v8);
    v10[v8] = 0;
    *a3 = (uint64_t)v10;
    return 0;
  }
  else
  {
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
  }
}

uint64_t __CGN_FeaturesCurrent(uint64_t a1, char *__s, char *a3)
{
  unsigned int v6 = __s;
  do
  {
    if (!__CGN_IsPunct(v6))
    {
      unsigned __int16 v8 = strlen(__s);
      unsigned __int16 PreviousUtf8Offset = utf8_GetPreviousUtf8Offset((uint64_t)__s, v8);
      unsigned __int16 v10 = v8;
      if (__CGN_IsPunct(&__s[PreviousUtf8Offset]))
      {
        unsigned int v11 = PreviousUtf8Offset;
        do
        {
          unsigned __int16 v10 = PreviousUtf8Offset;
          unsigned __int16 PreviousUtf8Offset = utf8_GetPreviousUtf8Offset((uint64_t)__s, v11);
          unsigned int v11 = PreviousUtf8Offset;
        }
        while (__CGN_IsPunct(&__s[PreviousUtf8Offset]));
      }
      int i = 0;
      if (*(_DWORD *)(a1 + 200))
      {
        uint64_t v12 = &a3[4 * *(unsigned __int16 *)(a1 + 186) + -4 * (unsigned __int16)(*(_WORD *)(a1 + 188) + 2)];
        bzero(v12, 4 * (unsigned __int16)(*(_WORD *)(a1 + 188) + 2));
        int i = 1;
        if (v6 > __s)
        {
          int v13 = __s;
          do
          {
            __CGN_InPunctList(a1, v13, (uint64_t)v12, &i);
            unsigned int v14 = utf8_determineUTF8CharLength(*(unsigned __int8 *)v13);
            if (i) {
              *(_DWORD *)&v12[4 * *(unsigned __int16 *)(a1 + 188)] = 1065353216;
            }
            v13 += v14;
          }
          while (v13 < v6);
        }
        uint64_t v15 = v10;
        unsigned int v16 = &__s[v10];
        for (int i = 1; *v16; v16 += v17)
        {
          __CGN_InPunctList(a1, v16, (uint64_t)v12, &i);
          unsigned int v17 = utf8_determineUTF8CharLength(*(unsigned __int8 *)v16);
          if (i) {
            *(_DWORD *)&v12[4 * *(unsigned __int16 *)(a1 + 188) + 4] = 1065353216;
          }
        }
      }
      else
      {
        uint64_t v15 = v10;
      }
      __s[v15] = 0;
      int v18 = (*(uint64_t (**)(void, void, char *, void))(*(void *)(a1 + 128) + 56))(*(void *)(a1 + 136), *(void *)(a1 + 144), v6, *(void *)(a1 + 168));
      if ((v18 & 0x1FFF) != 0x14)
      {
        unsigned int v22 = 0;
        goto LABEL_31;
      }
      uint64_t v19 = *(void *)(*(void *)(a1 + 48) + 8);
      int v20 = Utf8_Utf8NbrOfSymbols(v6);
      uint64_t v21 = heap_Alloc(v19, (6 * v20) | 1);
      if (!v21)
      {
        uint64_t IsUpdatable = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
        goto LABEL_41;
      }
      unsigned int v22 = (const char *)v21;
      unsigned __int16 v23 = strlen(v6);
      unint64_t v24 = v22;
      uint64_t v25 = v23;
      if (v23)
      {
        uint64_t NextUtf8OffsetLimit = 0;
        unint64_t v24 = v22;
        do
        {
          utf8_ToLower(v6, NextUtf8OffsetLimit, (uint64_t)v24);
          v24 += utf8_determineUTF8CharLength(*(unsigned __int8 *)v24);
          uint64_t NextUtf8OffsetLimit = (unsigned __int16)utf8_GetNextUtf8OffsetLimit(v6, NextUtf8OffsetLimit, v25);
        }
        while (NextUtf8OffsetLimit < v25);
      }
      *unint64_t v24 = 0;
      int v27 = strcmp(v22, v6);
      uint64_t v28 = *(void *)(a1 + 136);
      uint64_t v29 = *(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(*(void *)(a1 + 128) + 56);
      uint64_t v30 = *(void *)(a1 + 168);
      uint64_t v31 = *(void *)(a1 + 144);
      if (v27)
      {
        int v18 = v29(v28, v31, v22, v30);
        if ((v18 & 0x1FFF) != 0x14) {
          goto LABEL_31;
        }
        int v18 = (*(uint64_t (**)(void, void, const char *, void))(*(void *)(a1 + 128) + 56))(*(void *)(a1 + 136), *(void *)(a1 + 144), "$MEANW2V$", *(void *)(a1 + 168));
      }
      else
      {
        int v18 = v29(v28, v31, "$MEANW2V$", v30);
      }
      if ((v18 & 0x1FFF) == 0x14)
      {
        uint64_t v33 = "mean vector";
        goto LABEL_39;
      }
LABEL_31:
      if ((v18 & 0x80000000) == 0)
      {
        uint64_t IsUpdatable = 0;
        if (!v22)
        {
LABEL_41:
          if (!IsUpdatable)
          {
            memcpy(a3, *(const void **)(a1 + 168), 4 * *(unsigned __int16 *)(a1 + 196));
            uint64_t v34 = &a3[4 * *(unsigned __int16 *)(a1 + 196)];
            unsigned __int16 v35 = Utf8_Utf8NbrOfSymbols(v6);
            int v36 = *(unsigned __int16 *)(a1 + 192);
            unsigned __int16 v37 = v36 + *(_WORD *)(a1 + 190);
            if (v37 + 1 >= v35)
            {
              if ((_WORD)v36 + *(_WORD *)(a1 + 190))
              {
                int v47 = 0;
                do
                {
                  if (*v6)
                  {
                    uint64_t v48 = (unsigned __int16)utf8_determineUTF8CharLength(*v6);
                    __strncpy_chk();
                    v50[v48] = 0;
                    uint64_t v41 = __CGN_CharLookup((void *)a1, (uint64_t)v50);
                    if (v41) {
                      return v41;
                    }
                    v6 += v48;
                    memcpy(v34, *(const void **)(a1 + 176), 4 * *(unsigned __int16 *)(a1 + 198));
                  }
                  else
                  {
                    bzero(v34, 4 * *(unsigned __int16 *)(a1 + 198));
                  }
                  v34 += 4 * *(unsigned __int16 *)(a1 + 198);
                  ++v47;
                }
                while ((unsigned __int16)v47 < v37);
              }
            }
            else
            {
              if (*(_WORD *)(a1 + 190))
              {
                int v38 = 0;
                unsigned int v39 = v6;
                while (1)
                {
                  uint64_t v40 = (unsigned __int16)utf8_determineUTF8CharLength(*v39);
                  __strncpy_chk();
                  v50[v40] = 0;
                  uint64_t v41 = __CGN_CharLookup((void *)a1, (uint64_t)v50);
                  if (v41) {
                    return v41;
                  }
                  v39 += v40;
                  memcpy(v34, *(const void **)(a1 + 176), 4 * *(unsigned __int16 *)(a1 + 198));
                  v34 += 4 * *(unsigned __int16 *)(a1 + 198);
                  if (++v38 >= *(unsigned __int16 *)(a1 + 190))
                  {
                    int v36 = *(unsigned __int16 *)(a1 + 192);
                    break;
                  }
                }
              }
              if (v36)
              {
                unsigned __int16 v42 = strlen(v6);
                unsigned int v43 = 0;
                do
                {
                  unsigned __int16 v42 = utf8_GetPreviousUtf8Offset((uint64_t)v6, v42);
                  ++v43;
                }
                while (v43 < *(unsigned __int16 *)(a1 + 192));
                if (*(_WORD *)(a1 + 192))
                {
                  unsigned int v44 = 0;
                  uint64_t v45 = &v6[v42];
                  do
                  {
                    uint64_t v46 = (unsigned __int16)utf8_determineUTF8CharLength(*v45);
                    __strncpy_chk();
                    v50[v46] = 0;
                    uint64_t IsUpdatable = __CGN_CharLookup((void *)a1, (uint64_t)v50);
                    if (IsUpdatable) {
                      break;
                    }
                    v45 += v46;
                    memcpy(v34, *(const void **)(a1 + 176), 4 * *(unsigned __int16 *)(a1 + 198));
                    v34 += 4 * *(unsigned __int16 *)(a1 + 198);
                    ++v44;
                  }
                  while (v44 < *(unsigned __int16 *)(a1 + 192));
                  return IsUpdatable;
                }
              }
            }
            return 0;
          }
          return IsUpdatable;
        }
LABEL_40:
        heap_Free(*(void **)(*(void *)(a1 + 48) + 8), (uint64_t)v22);
        goto LABEL_41;
      }
      uint64_t v33 = "__pIWordLkp->pfWord2fVector";
LABEL_39:
      uint64_t IsUpdatable = err_GenerateErrorInternalMsg((uint64_t)v33);
      if (!v22) {
        goto LABEL_41;
      }
      goto LABEL_40;
    }
    v6 += utf8_determineUTF8CharLength(*v6);
  }
  while (*v6);
  return kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)"szWord");
}

BOOL __CGN_IsPunct(char *__s)
{
  BOOL result = 0;
  if (*__s)
  {
    if (*__s != 35)
    {
      unsigned int v3 = strlen(__s);
      return utf8_BelongsToSet(9u, __s, 0, v3) == 0;
    }
  }
  return result;
}

uint64_t __CGN_InPunctList(uint64_t result, const char *a2, uint64_t a3, _DWORD *a4)
{
  if (*(_WORD *)(result + 188))
  {
    uint64_t v7 = result;
    unsigned __int16 v8 = 0;
    unsigned __int16 v9 = 0;
    uint64_t v10 = *(void *)(result + 208);
    while (1)
    {
      unsigned __int16 v11 = utf8_determineUTF8CharLength(*(unsigned __int8 *)(v10 + v9));
      uint64_t v10 = *(void *)(v7 + 208);
      BOOL result = strncmp(a2, (const char *)(v10 + v9), v11);
      if (!result) {
        break;
      }
      v9 += v11;
      ++v8;
      if (*(unsigned __int16 *)(v7 + 188) <= v9) {
        return result;
      }
    }
    *(_DWORD *)(a3 + 4 * v8) = 1065353216;
    *a4 = 0;
  }
  return result;
}

uint64_t __CGN_CharLookup(void *a1, uint64_t a2)
{
  int v3 = (*(uint64_t (**)(void, void, uint64_t, void))(a1[16] + 56))(a1[19], a1[20], a2, a1[22]);
  if ((v3 & 0x1FFF) == 0x14
    && (int v3 = (*(uint64_t (**)(void, void, const char *, void))(a1[16] + 56))(a1[19], a1[20], "$MEANW2V$", a1[22]), (v3 & 0x1FFF) == 0x14))
  {
    uint64_t v4 = "mean vector";
  }
  else
  {
    if ((v3 & 0x80000000) == 0) {
      return 0;
    }
    uint64_t v4 = "__pIWordLkp->pfWord2fVector";
  }
  return err_GenerateErrorInternalMsg((uint64_t)v4);
}

uint64_t TN_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5)
{
  uint64_t v6 = _Model_Con((void *)a1, a2, a3, a4, a5);
  if (!v6)
  {
    *(void *)a1 = &__TN;
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = safeh_GetNullHandle();
    *(void *)(a1 + 144) = v7;
    *(void *)(a1 + 152) = 0;
    *(void *)(a1 + 160) = 0;
    *(_WORD *)(a1 + 168) = 0;
  }
  return v6;
}

uint64_t TN_Des(uint64_t *a1)
{
  uint64_t v2 = a1[15];
  if (v2)
  {
    heap_Free(*(void **)(a1[6] + 8), v2);
    a1[15] = 0;
  }
  uint64_t result = _Model_Unload(a1);
  if (!result)
  {
    return Model_Des((uint64_t)a1);
  }
  return result;
}

uint64_t TN_LoadModel(uint64_t a1, char *__s, _DWORD *a3)
{
  uint64_t v6 = *(void *)(*(void *)(a1 + 48) + 8);
  size_t v7 = strlen(__s);
  unsigned __int16 v8 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc(v6, v7 + 1);
  *(void *)(a1 + 120) = v8;
  if (v8
    && (strcpy((char *)v8, __s),
        size_t v9 = strlen(__s),
        (unsigned __int16 v8 = (kaldi::nnet1::UpdatableComponent *)heap_Alloc(*(void *)(*(void *)(a1 + 48) + 8), v9 + 8)) != 0))
  {
    uint64_t v10 = (char *)v8;
    *(void *)unsigned __int16 v8 = 0x5F326E745F6E6ELL;
    unsigned __int16 v11 = (char *)v8 + 7;
    unsigned __int16 v12 = strlen(__s);
    uint64_t v13 = v12;
    if (v12)
    {
      uint64_t v14 = 0;
      do
      {
        utf8_ToLower(__s, v14, (uint64_t)v11);
        unsigned int v15 = *v11;
        if (v15 != 95) {
          v11 += utf8_determineUTF8CharLength(v15);
        }
        LODWORD(v14) = (unsigned __int16)utf8_GetNextUtf8OffsetLimit(__s, v14, v13);
      }
      while (v14 < v13);
    }
    *unsigned __int16 v11 = 0;
    uint64_t v16 = _Model_Load(a1, v10, a3);
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), (uint64_t)v10);
    return v16;
  }
  else
  {
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(v8);
  }
}

uint64_t TN_Models(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = a3;
  uint64_t v11 = 0;
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  uint64_t Allocator = ooc_utils_createAllocator((uint64_t)v9, a1, a2);
  if (!Allocator)
  {
    uint64_t v6 = PNEW_Params_Con((uint64_t)v9, a1, a2, (uint64_t)"fecfg", &v11);
    uint64_t v7 = v11;
    if (!v6)
    {
      uint64_t Allocator = Params_GetCfgParamValueListOfStrings(v11, "nn_tn2_models", 0x3Bu, &v12);
      uint64_t v7 = v11;
      if (!v11) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
    uint64_t Allocator = v6;
    if (v11) {
LABEL_4:
    }
      OOC_PlacementDeleteObject((uint64_t)v9, v7);
  }
LABEL_5:
  kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)v9);
  return Allocator;
}

uint64_t TN_Predict(uint64_t a1, unsigned int a2, char *__s, unsigned int a4, unsigned int a5, void *a6, int *a7)
{
  uint64_t v33 = 0;
  if (*(unsigned __int16 *)(a1 + 166) <= a2)
  {
    uint64_t v14 = "u16Pattern";
    goto LABEL_24;
  }
  if (!__s)
  {
    uint64_t v14 = "szSentence";
    goto LABEL_24;
  }
  if (a5 > (unsigned __int16)strlen(__s))
  {
    uint64_t v14 = "u16To";
LABEL_24:
    uint64_t ErrorInternalMsg = kaldi::OffsetFileInputImpl::MyType((kaldi::OffsetFileInputImpl *)v14);
    goto LABEL_25;
  }
  if (a4 >= a5)
  {
    uint64_t v14 = "u16From";
    goto LABEL_24;
  }
  uint64_t v36 = 0;
  int v34 = 0;
  int v35 = 0;
  unsigned int v15 = (char *)heap_Alloc(*(void *)(*(void *)(a1 + 48) + 8), 4 * *(unsigned __int16 *)(a1 + 168) * (unint64_t)*(unsigned __int16 *)(a1 + 160));
  uint64_t v33 = (uint64_t)v15;
  if (!v15)
  {
    uint64_t IsUpdatable = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
    goto LABEL_34;
  }
  uint64_t v16 = v15;
  if ((nn_tn_getCharContextString(*(void *)(a1 + 48), (uint64_t)"NN_TN", __s, a4, a5, &v36, (unsigned __int16 *)&v35 + 1, *(unsigned __int16 *)(a1 + 162), 2, "*", *(_WORD *)(a1 + 168), (unsigned __int16 *)&v35, (_WORD *)&v34 + 1, &v34) & 0x80000000) != 0)
  {
    uint64_t v29 = "nn_tn_getCharContextString";
    goto LABEL_33;
  }
  bzero(v16, 4 * *(unsigned __int16 *)(a1 + 168) * (unint64_t)*(unsigned __int16 *)(a1 + 160));
  if (!(_WORD)v35)
  {
LABEL_22:
    uint64_t v25 = 0;
    goto LABEL_35;
  }
  unint64_t v21 = 0;
  while (1)
  {
    unsigned int v22 = *(const char **)(v36 + 8 * v21);
    if (!strcmp(v22, "*"))
    {
      if (*(_WORD *)(a1 + 160)) {
        memset_pattern16(v16, &unk_20D62D3B0, 4 * *(unsigned __int16 *)(a1 + 160));
      }
      goto LABEL_21;
    }
    int v23 = (*(uint64_t (**)(void, void, const char *, void))(*(void *)(a1 + 128) + 56))(*(void *)(a1 + 136), *(void *)(a1 + 144), v22, *(void *)(a1 + 152));
    if ((v23 & 0x1FFF) == 0x14)
    {
      int v23 = (*(uint64_t (**)(void, void, const char *, void))(*(void *)(a1 + 128) + 56))(*(void *)(a1 + 136), *(void *)(a1 + 144), "$MEANW2V$", *(void *)(a1 + 152));
      if ((v23 & 0x1FFF) == 0x14) {
        break;
      }
    }
    if (v23 < 0)
    {
      uint64_t v29 = "__pIWordLkp->pfWord2fVector";
      goto LABEL_33;
    }
    memcpy(v16, *(const void **)(a1 + 152), 4 * *(unsigned __int16 *)(a1 + 164));
    uint64_t v24 = *(unsigned __int16 *)(a1 + 164);
    *(_DWORD *)&v16[4 * v24 + 4 * a2] = 1065353216;
    if (v21 >= HIWORD(v34) && v21 < (unsigned __int16)v34) {
      *(_DWORD *)&v16[4 * *(unsigned __int16 *)(a1 + 166) + 4 * v24] = 1065353216;
    }
LABEL_21:
    v16 += 4 * *(unsigned __int16 *)(a1 + 160);
    if (++v21 >= (unsigned __int16)v35) {
      goto LABEL_22;
    }
  }
  uint64_t v29 = "mean vector";
LABEL_33:
  uint64_t IsUpdatable = err_GenerateErrorInternalMsg((uint64_t)v29);
LABEL_34:
  uint64_t v25 = IsUpdatable;
LABEL_35:
  uint64_t v30 = v36;
  if (v36)
  {
    if (HIWORD(v35))
    {
      unint64_t v31 = 0;
      do
        heap_Free(*(void **)(*(void *)(a1 + 48) + 8), *(void *)(v36 + 8 * v31++));
      while (v31 < HIWORD(v35));
      uint64_t v30 = v36;
    }
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), v30);
  }
  if (!v25)
  {
    if ((fi_predict(*(uint64_t ****)(a1 + 104), (const void **)&v33, *(unsigned __int16 *)(a1 + 168), a6, v17, v18, v19, v20) & 0x80000000) != 0)
    {
      unsigned int v32 = "fi_predict";
    }
    else
    {
      if ((fi_shape_get_size((int *)(**(void **)(a1 + 104) + 92), a7) & 0x80000000) == 0)
      {
        uint64_t v25 = 0;
        goto LABEL_26;
      }
      unsigned int v32 = "fi_shape_get_size";
    }
    uint64_t ErrorInternalMsg = err_GenerateErrorInternalMsg((uint64_t)v32);
LABEL_25:
    uint64_t v25 = ErrorInternalMsg;
  }
LABEL_26:
  if (v33) {
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), v33);
  }
  return v25;
}

uint64_t _TN_PostFIDeinit(uint64_t a1)
{
  *(void *)(a1 + 162) = 0;
  return 0;
}

uint64_t _TN_PostFIInit(uint64_t a1)
{
  if ((nn_word_lkp_GetInterface(1u, (void *)(a1 + 128)) & 0x80000000) != 0)
  {
    unsigned __int16 v8 = "nn_word_lkp_GetInterface";
LABEL_11:
    return err_GenerateErrorInternalMsg((uint64_t)v8);
  }
  uint64_t v2 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 128) + 16);
  uint64_t NullHandle = safeh_GetNullHandle();
  if ((v2(NullHandle) & 0x80000000) != 0)
  {
    unsigned __int16 v8 = "__pIWordLkp->pfObjOpen";
    goto LABEL_11;
  }
  int v10 = 0;
  if (((*(uint64_t (**)(void, void, int *))(*(void *)(a1 + 128) + 40))(*(void *)(a1 + 136), *(void *)(a1 + 144), &v10) & 0x80000000) != 0)
  {
    size_t v9 = "__pIWordLkp->pfGetVectorLength";
  }
  else
  {
    uint64_t v4 = *(unsigned __int16 *)(a1 + 164);
    if (v10 == v4)
    {
      uint64_t v5 = heap_Alloc(*(void *)(*(void *)(a1 + 48) + 8), 4 * v4);
      *(void *)(a1 + 152) = v5;
      if (!v5) {
        return kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
      }
      if (*(_DWORD *)(a1 + 112) == *(unsigned __int16 *)(a1 + 168))
      {
        unsigned __int16 v6 = *(_WORD *)(a1 + 164) + *(_WORD *)(a1 + 166) + 1;
        *(_WORD *)(a1 + 160) = v6;
        if (*(_DWORD *)(a1 + 116) == v6) {
          return 0;
        }
        size_t v9 = "inshape dimension 2";
      }
      else
      {
        size_t v9 = "inshape dimension 1";
      }
    }
    else
    {
      size_t v9 = "char embedding dimension";
    }
  }
  return err_GenerateErrorInternalMsg((uint64_t)v9);
}

uint64_t _TN_PreFIDeinit(uint64_t a1)
{
  if (*(void *)(a1 + 128))
  {
    uint64_t NullHandle = safeh_GetNullHandle();
    if (!safeh_HandlesEqual(*(void *)(a1 + 136), *(void *)(a1 + 144), NullHandle, v3))
    {
      (*(void (**)(void, void))(*(void *)(a1 + 128) + 24))(*(void *)(a1 + 136), *(void *)(a1 + 144));
      *(void *)(a1 + 136) = safeh_GetNullHandle();
      *(void *)(a1 + 144) = v4;
    }
    *(void *)(a1 + 128) = 0;
  }
  uint64_t v5 = *(void *)(a1 + 152);
  if (v5) {
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), v5);
  }
  *(void *)(a1 + 152) = 0;
  *(_WORD *)(a1 + 160) = 0;
  return 0;
}

uint64_t _TN_PreFIInit(uint64_t a1, _DWORD *a2)
{
  unsigned __int16 v8 = 0;
  uint64_t v9 = 0;
  int v7 = 0;
  *a2 = 0;
  uint64_t v4 = a1 + 56;
  uint64_t CfgParamValueInteger = PNEW_Params_Con(a1 + 56, *(_WORD **)(a1 + 32), *(void *)(a1 + 40), (uint64_t)"fecfg", &v9);
  if (!CfgParamValueInteger)
  {
    uint64_t CfgParamValueInteger = __TN_FullParamName(a1, "charContextWindow", (uint64_t *)&v8);
    if (!CfgParamValueInteger)
    {
      uint64_t CfgParamValueInteger = Params_GetCfgParamValueInteger(v9, v8, 40, &v7);
      if (!CfgParamValueInteger)
      {
        *(_WORD *)(a1 + 162) = v7;
        uint64_t CfgParamValueInteger = __TN_FullParamName(a1, "charEmbeddingDimension", (uint64_t *)&v8);
        if (!CfgParamValueInteger)
        {
          uint64_t CfgParamValueInteger = Params_GetCfgParamValueInteger(v9, v8, 0, &v7);
          if (!CfgParamValueInteger)
          {
            *(_WORD *)(a1 + 164) = v7;
            uint64_t CfgParamValueInteger = __TN_FullParamName(a1, "numPatterns", (uint64_t *)&v8);
            if (!CfgParamValueInteger)
            {
              uint64_t CfgParamValueInteger = Params_GetCfgParamValueInteger(v9, v8, 1, &v7);
              if (!CfgParamValueInteger)
              {
                *(_WORD *)(a1 + 166) = v7;
                uint64_t CfgParamValueInteger = __TN_FullParamName(a1, "max_x_len", (uint64_t *)&v8);
                if (!CfgParamValueInteger)
                {
                  uint64_t CfgParamValueInteger = Params_GetCfgParamValueInteger(v9, v8, 0, &v7);
                  if (!CfgParamValueInteger)
                  {
                    *(_WORD *)(a1 + 168) = v7;
                    *a2 = 1;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (v9) {
    OOC_PlacementDeleteObject(v4, v9);
  }
  if (v8) {
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), (uint64_t)v8);
  }
  return CfgParamValueInteger;
}

uint64_t __TN_FullParamName(uint64_t a1, char *__s, uint64_t *a3)
{
  unsigned __int16 v6 = *(uint64_t **)(*(void *)(a1 + 48) + 8);
  uint64_t v7 = *a3;
  size_t v8 = strlen(__s);
  size_t v9 = strlen(*(const char **)(a1 + 120));
  int v10 = (char *)heap_Realloc(v6, v7, v8 + v9 + 9);
  if (v10)
  {
    uint64_t v11 = v10;
    *(void *)int v10 = 0x5F326E745F6E6ELL;
    uint64_t v12 = strcat(v10, *(const char **)(a1 + 120));
    *(_WORD *)&v11[strlen(v12)] = 95;
    strcat(v11, __s);
    *a3 = (uint64_t)v11;
    return 0;
  }
  else
  {
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
  }
}

uint64_t PNEW_TN_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 176, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = TN_Con(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *a6 = v12;
    }
  }
  return result;
}

uint64_t CLM_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5)
{
  uint64_t v6 = _Model_Con((void *)a1, a2, a3, a4, a5);
  if (!v6)
  {
    *(void *)a1 = &__CLM;
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 136) = safeh_GetNullHandle();
    *(void *)(a1 + 144) = v7;
    *(void *)(a1 + 152) = safeh_GetNullHandle();
    *(void *)(a1 + 160) = v8;
    *(void *)(a1 + 168) = safeh_GetNullHandle();
    *(void *)(a1 + 176) = v9;
    *(_OWORD *)(a1 + 184) = 0u;
    *(_OWORD *)(a1 + 200) = 0u;
    *(void *)(a1 + 214) = 0;
  }
  return v6;
}

uint64_t CLM_Des(uint64_t *a1)
{
  uint64_t v2 = a1[15];
  if (v2)
  {
    heap_Free(*(void **)(a1[6] + 8), v2);
    a1[15] = 0;
  }
  uint64_t result = _Model_Unload(a1);
  if (!result)
  {
    return Model_Des((uint64_t)a1);
  }
  return result;
}

uint64_t CLM_LoadModel(uint64_t a1, char *__s, _DWORD *a3)
{
  uint64_t v6 = *(void *)(*(void *)(a1 + 48) + 8);
  size_t v7 = strlen(__s);
  uint64_t v8 = (char *)heap_Alloc(v6, v7 + 1);
  *(void *)(a1 + 120) = v8;
  if (v8
    && (strcpy(v8, __s),
        size_t v9 = strlen(__s),
        (uint64_t v8 = (char *)heap_Alloc(*(void *)(*(void *)(a1 + 48) + 8), v9 + 14)) != 0))
  {
    int v10 = v8;
    strcpy(v8, "clmnn:nn_clm_");
    strcat(v8, __s);
    uint64_t v11 = _Model_Load(a1, v10, a3);
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), (uint64_t)v10);
    return v11;
  }
  else
  {
    return kaldi::nnet1::UpdatableComponent::IsUpdatable((kaldi::nnet1::UpdatableComponent *)v8);
  }
}

uint64_t CLM_Models(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = a3;
  uint64_t v11 = 0;
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  uint64_t Allocator = ooc_utils_createAllocator((uint64_t)v9, a1, a2);
  if (!Allocator)
  {
    uint64_t v6 = PNEW_Params_Con((uint64_t)v9, a1, a2, (uint64_t)"clmnncfg", &v11);
    uint64_t v7 = v11;
    if (!v6)
    {
      uint64_t Allocator = Params_GetCfgParamValueListOfStrings(v11, "nn_clm_models", 0x3Bu, &v12);
      uint64_t v7 = v11;
      if (!v11) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
    uint64_t Allocator = v6;
    if (v11) {
LABEL_4:
    }
      OOC_PlacementDeleteObject((uint64_t)v9, v7);
  }
LABEL_5:
  kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)v9);
  return Allocator;
}

uint64_t CLM_Predict(uint64_t a1, char **a2, char **a3, char **a4, unsigned int a5, uint64_t a6, uint64_t a7)
{
  unsigned int v14 = (char *)heap_Alloc(*(void *)(*(void *)(a1 + 48) + 8), 12* *(unsigned __int16 *)(a1 + 220)* (2 * *(unsigned __int16 *)(a1 + 218) + (unsigned __int16)a5));
  uint64_t v40 = (uint64_t)v14;
  if (v14)
  {
    unsigned int v15 = v14;
    uint64_t v39 = a7;
    uint64_t v16 = (unsigned __int16)a5;
    __int16 v17 = 3 * *(_WORD *)(a1 + 218) * *(_WORD *)(a1 + 220);
    if (v17)
    {
      uint64_t v18 = (unsigned __int16)(3 * *(_WORD *)(a1 + 218) * *(_WORD *)(a1 + 220));
      memset_pattern16(v14, &unk_20D62D3B0, 4 * v18);
    }
    else
    {
      uint64_t v18 = 0;
    }
    uint64_t v38 = v18;
    uint64_t v20 = &v15[4 * v18];
    if ((_WORD)a5)
    {
      while (1)
      {
        uint64_t v21 = __CLM_FeaturesLookups(a1, *(void *)(a1 + 136), *(void *)(a1 + 144), *a2, v20);
        if (v21) {
          break;
        }
        unsigned int v22 = &v20[4 * *(unsigned __int16 *)(a1 + 220)];
        uint64_t v21 = __CLM_FeaturesLookups(a1, *(void *)(a1 + 152), *(void *)(a1 + 160), *a3, v22);
        if (v21) {
          break;
        }
        int v23 = &v22[4 * *(unsigned __int16 *)(a1 + 220)];
        uint64_t v21 = __CLM_FeaturesLookups(a1, *(void *)(a1 + 168), *(void *)(a1 + 176), *a4, v23);
        if (v21) {
          break;
        }
        uint64_t v20 = &v23[4 * *(unsigned __int16 *)(a1 + 220)];
        ++a4;
        ++a3;
        ++a2;
        if (!--v16) {
          goto LABEL_12;
        }
      }
      uint64_t IsUpdatable = v21;
      goto LABEL_39;
    }
LABEL_12:
    BOOL v24 = v17 == 0;
    a7 = v39;
    if (!v24) {
      memset_pattern16(v20, &unk_20D62D3B0, 4 * v38);
    }
  }
  else
  {
    uint64_t IsUpdatable = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
    if (IsUpdatable) {
      return IsUpdatable;
    }
  }
  if (a5)
  {
    int v25 = 0;
    int v26 = 0;
    float v27 = 0.0;
    uint64_t v28 = (char *)v40;
    while (1)
    {
      uint64_t v42 = 0;
      uint64_t v43 = 0;
      unsigned int v41 = 0;
      if (!v28) {
        break;
      }
      uint64_t v29 = 4 * ((*(_WORD *)(a1 + 216) * *(_WORD *)(a1 + 220)) & 0x3FFF);
      uint64_t v30 = (void *)heap_Alloc(*(void *)(*(void *)(a1 + 48) + 8), v29);
      uint64_t v43 = (uint64_t)v30;
      if (v30)
      {
        memcpy(v30, v28, v29);
        if ((fi_predict(*(uint64_t ****)(a1 + 104), (const void **)&v43, *(unsigned __int16 *)(a1 + 216), &v42, v31, v32, v33, v34) & 0x80000000) != 0)
        {
          uint64_t v36 = "fi_predict";
        }
        else
        {
          if ((fi_shape_get_size((int *)(**(void **)(a1 + 104) + 92), (int *)&v41) & 0x80000000) == 0)
          {
            if (v41)
            {
              uint64_t v35 = 0;
              int v26 = 0;
              float v27 = 0.0;
              do
              {
                if (v27 < *(float *)(v42 + 4 * v35))
                {
                  float v27 = *(float *)(v42 + 4 * v35);
                  int v26 = v35;
                }
                ++v35;
              }
              while (v41 > (unsigned __int16)v35);
              uint64_t IsUpdatable = 0;
            }
            else
            {
              int v26 = 0;
              uint64_t IsUpdatable = 0;
              float v27 = 0.0;
            }
            goto LABEL_31;
          }
          uint64_t v36 = "fi_shape_get_size";
        }
LABEL_30:
        uint64_t IsUpdatable = err_GenerateErrorInternalMsg((uint64_t)v36);
LABEL_31:
        if (v43) {
          heap_Free(*(void **)(*(void *)(a1 + 48) + 8), v43);
        }
        goto LABEL_33;
      }
      uint64_t IsUpdatable = kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
LABEL_33:
      if (IsUpdatable) {
        goto LABEL_39;
      }
      *(float *)(a7 + 4 * (unsigned __int16)v25) = v27;
      *(_DWORD *)(a6 + 4 * (unsigned __int16)v25) = v26;
      v28 += 12 * *(unsigned __int16 *)(a1 + 220);
      if (a5 <= (unsigned __int16)++v25) {
        goto LABEL_37;
      }
    }
    uint64_t v36 = "pElemFeatures == NULL";
    goto LABEL_30;
  }
LABEL_37:
  uint64_t IsUpdatable = 0;
LABEL_39:
  if (v40) {
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), v40);
  }
  return IsUpdatable;
}

uint64_t _CLM_PostFIDeinit(uint64_t a1)
{
  *(_DWORD *)(a1 + 218) = 0;
  return 0;
}

uint64_t _CLM_PostFIInit(uint64_t a1)
{
  if ((nn_word_lkp_GetInterface(1u, (void *)(a1 + 128)) & 0x80000000) != 0)
  {
    uint64_t v16 = "nn_word_lkp_GetInterface";
LABEL_23:
    return err_GenerateErrorInternalMsg((uint64_t)v16);
  }
  size_t v2 = strlen(*(const char **)(a1 + 120));
  int v3 = (char *)heap_Alloc(*(void *)(*(void *)(a1 + 48) + 8), v2 + 16);
  *(void *)(a1 + 184) = v3;
  if (v3)
  {
    strcpy(v3, "clmorthforeign_");
    strcat(*(char **)(a1 + 184), *(const char **)(a1 + 120));
    uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 128) + 16);
    uint64_t NullHandle = safeh_GetNullHandle();
    if ((v4(NullHandle) & 0x80000000) != 0) {
      goto LABEL_22;
    }
    size_t v6 = strlen(*(const char **)(a1 + 120));
    int v3 = (char *)heap_Alloc(*(void *)(*(void *)(a1 + 48) + 8), v6 + 16);
    *(void *)(a1 + 192) = v3;
    if (!v3) {
      goto LABEL_19;
    }
    strcpy(v3, "clmphonforeign_");
    strcat(*(char **)(a1 + 192), *(const char **)(a1 + 120));
    uint64_t v7 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 128) + 16);
    uint64_t v8 = safeh_GetNullHandle();
    if ((v7(v8) & 0x80000000) != 0)
    {
LABEL_22:
      uint64_t v16 = "__pIWordLkp->pfObjOpen";
      goto LABEL_23;
    }
    size_t v9 = strlen(*(const char **)(a1 + 120));
    int v3 = (char *)heap_Alloc(*(void *)(*(void *)(a1 + 48) + 8), v9 + 13);
    *(void *)(a1 + 200) = v3;
    if (v3)
    {
      strcpy(v3, "clmphonmain_");
      strcat(*(char **)(a1 + 200), *(const char **)(a1 + 120));
      uint64_t v10 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 128) + 16);
      uint64_t v11 = safeh_GetNullHandle();
      if ((v10(v11) & 0x80000000) == 0)
      {
        int v18 = 0;
        if (((*(uint64_t (**)(void, void, int *))(*(void *)(a1 + 128) + 40))(*(void *)(a1 + 136), *(void *)(a1 + 144), &v18) & 0x80000000) == 0)
        {
          if (v18 != *(unsigned __int16 *)(a1 + 220))
          {
            __int16 v17 = "orth embedding dimension";
            return err_GenerateErrorInternalMsg((uint64_t)v17);
          }
          if (((*(uint64_t (**)(void, void, int *))(*(void *)(a1 + 128) + 40))(*(void *)(a1 + 152), *(void *)(a1 + 160), &v18) & 0x80000000) == 0)
          {
            if (v18 != *(unsigned __int16 *)(a1 + 220))
            {
              __int16 v17 = "phon embedding dimension";
              return err_GenerateErrorInternalMsg((uint64_t)v17);
            }
            if (((*(uint64_t (**)(void, void, int *))(*(void *)(a1 + 128) + 40))(*(void *)(a1 + 168), *(void *)(a1 + 176), &v18) & 0x80000000) == 0)
            {
              uint64_t v12 = *(unsigned __int16 *)(a1 + 220);
              if (v18 == v12)
              {
                uint64_t v13 = heap_Alloc(*(void *)(*(void *)(a1 + 48) + 8), 4 * v12);
                *(void *)(a1 + 208) = v13;
                if (!v13) {
                  return kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
                }
                unsigned __int16 v14 = 6 * *(_WORD *)(a1 + 218) + 3;
                *(_WORD *)(a1 + 216) = v14;
                if (*(_DWORD *)(a1 + 112) == v14)
                {
                  if (*(_DWORD *)(a1 + 116) == *(unsigned __int16 *)(a1 + 220)) {
                    return 0;
                  }
                  __int16 v17 = "inshape dimension 2";
                }
                else
                {
                  __int16 v17 = "inshape dimension 1";
                }
              }
              else
              {
                __int16 v17 = "main embedding dimension";
              }
              return err_GenerateErrorInternalMsg((uint64_t)v17);
            }
          }
        }
        __int16 v17 = "__pIWordLkp->pfGetVectorLength";
        return err_GenerateErrorInternalMsg((uint64_t)v17);
      }
      goto LABEL_22;
    }
  }
LABEL_19:
  return kaldi::nnet1::UpdatableComponent::IsUpdatable((kaldi::nnet1::UpdatableComponent *)v3);
}

uint64_t _CLM_PreFIDeinit(uint64_t a1)
{
  if (*(void *)(a1 + 128))
  {
    uint64_t NullHandle = safeh_GetNullHandle();
    if (!safeh_HandlesEqual(*(void *)(a1 + 136), *(void *)(a1 + 144), NullHandle, v3))
    {
      (*(void (**)(void, void))(*(void *)(a1 + 128) + 24))(*(void *)(a1 + 136), *(void *)(a1 + 144));
      *(void *)(a1 + 136) = safeh_GetNullHandle();
      *(void *)(a1 + 144) = v4;
    }
    uint64_t v5 = safeh_GetNullHandle();
    if (!safeh_HandlesEqual(*(void *)(a1 + 152), *(void *)(a1 + 160), v5, v6))
    {
      (*(void (**)(void, void))(*(void *)(a1 + 128) + 24))(*(void *)(a1 + 152), *(void *)(a1 + 160));
      *(void *)(a1 + 152) = safeh_GetNullHandle();
      *(void *)(a1 + 160) = v7;
    }
    uint64_t v8 = safeh_GetNullHandle();
    if (!safeh_HandlesEqual(*(void *)(a1 + 168), *(void *)(a1 + 176), v8, v9))
    {
      (*(void (**)(void, void))(*(void *)(a1 + 128) + 24))(*(void *)(a1 + 168), *(void *)(a1 + 176));
      *(void *)(a1 + 168) = safeh_GetNullHandle();
      *(void *)(a1 + 176) = v10;
    }
    *(void *)(a1 + 128) = 0;
  }
  uint64_t v11 = *(void *)(a1 + 184);
  if (v11) {
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), v11);
  }
  *(void *)(a1 + 184) = 0;
  uint64_t v12 = *(void *)(a1 + 192);
  if (v12) {
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), v12);
  }
  *(void *)(a1 + 192) = 0;
  uint64_t v13 = *(void *)(a1 + 200);
  if (v13) {
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), v13);
  }
  *(void *)(a1 + 200) = 0;
  uint64_t v14 = *(void *)(a1 + 208);
  if (v14) {
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), v14);
  }
  *(void *)(a1 + 208) = 0;
  *(_WORD *)(a1 + 216) = 0;
  return 0;
}

uint64_t _CLM_PreFIInit(uint64_t a1, _DWORD *a2)
{
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  int v7 = 0;
  *a2 = 0;
  uint64_t v4 = a1 + 56;
  uint64_t CfgParamValueInteger = PNEW_Params_Con(a1 + 56, *(_WORD **)(a1 + 32), *(void *)(a1 + 40), (uint64_t)"clmnncfg", &v9);
  if (!CfgParamValueInteger)
  {
    uint64_t CfgParamValueInteger = __CLM_FullParamName(a1, "charContextWindow", (uint64_t *)&v8);
    if (!CfgParamValueInteger)
    {
      uint64_t CfgParamValueInteger = Params_GetCfgParamValueInteger(v9, v8, 3, &v7);
      if (!CfgParamValueInteger)
      {
        *(_WORD *)(a1 + 218) = v7;
        uint64_t CfgParamValueInteger = __CLM_FullParamName(a1, "embxEmbeddingDimension", (uint64_t *)&v8);
        if (!CfgParamValueInteger)
        {
          uint64_t CfgParamValueInteger = Params_GetCfgParamValueInteger(v9, v8, 0, &v7);
          if (!CfgParamValueInteger)
          {
            *(_WORD *)(a1 + 220) = v7;
            *a2 = 1;
          }
        }
      }
    }
  }
  if (v9) {
    OOC_PlacementDeleteObject(v4, v9);
  }
  if (v8) {
    heap_Free(*(void **)(*(void *)(a1 + 48) + 8), (uint64_t)v8);
  }
  return CfgParamValueInteger;
}

uint64_t __CLM_FullParamName(uint64_t a1, char *__s, uint64_t *a3)
{
  int v6 = *(uint64_t **)(*(void *)(a1 + 48) + 8);
  uint64_t v7 = *a3;
  size_t v8 = strlen(__s);
  size_t v9 = strlen(*(const char **)(a1 + 120));
  uint64_t v10 = (char *)heap_Realloc(v6, v7, v8 + v9 + 9);
  if (v10)
  {
    uint64_t v11 = v10;
    *(void *)uint64_t v10 = 0x5F6D6C635F6E6ELL;
    uint64_t v12 = strcat(v10, *(const char **)(a1 + 120));
    *(_WORD *)&v11[strlen(v12)] = 95;
    strcat(v11, __s);
    *a3 = (uint64_t)v11;
    return 0;
  }
  else
  {
    return kaldi::nnet1::UpdatableComponent::IsUpdatable(0);
  }
}

uint64_t PNEW_CLM_Con(uint64_t a1, uint64_t a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  unsigned int v14 = 0;
  uint64_t v12 = OOCAllocator_Malloc(a1, 224, &v14);
  uint64_t result = v14;
  if (!v14)
  {
    uint64_t result = CLM_Con(v12, a2, a3, a4, a5);
    unsigned int v14 = result;
    if (result)
    {
      OOCAllocator_Free(a1, v12);
      *a6 = 0;
      return v14;
    }
    else
    {
      *a6 = v12;
    }
  }
  return result;
}

uint64_t __CLM_FeaturesLookups(uint64_t a1, uint64_t a2, uint64_t a3, char *__s1, void *a5)
{
  if (!strcmp(__s1, "#"))
  {
    if (*(_WORD *)(a1 + 220)) {
      memset_pattern16(a5, &unk_20D62D410, 4 * *(unsigned __int16 *)(a1 + 220));
    }
    return 0;
  }
  int v10 = (*(uint64_t (**)(uint64_t, uint64_t, char *, void))(*(void *)(a1 + 128) + 56))(a2, a3, __s1, *(void *)(a1 + 208));
  if ((v10 & 0x1FFF) != 0x14
    || (int v10 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, void))(*(void *)(a1 + 128) + 56))(a2, a3, "$MEANW2V$", *(void *)(a1 + 208)), (v10 & 0x1FFF) != 0x14))
  {
    if (v10 < 0)
    {
      uint64_t v11 = "__pIWordLkp->pfWord2fVector";
      goto LABEL_11;
    }
    memcpy(a5, *(const void **)(a1 + 208), 4 * *(unsigned __int16 *)(a1 + 220));
    return 0;
  }
  uint64_t v11 = "mean vector";
LABEL_11:
  return err_GenerateErrorInternalMsg((uint64_t)v11);
}

uint64_t fe_nn_g2p_component_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2707431425;
  }
  uint64_t result = 0;
  *a2 = &IFeNng2p;
  return result;
}

uint64_t fe_nng2p_ClassOpen(_WORD *a1, uint64_t a2, void *a3)
{
  uint64_t v7 = 0;
  if (!a3) {
    return 2707431431;
  }
  uint64_t result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *a3 = a1;
    a3[1] = a2;
  }
  return result;
}

uint64_t fe_nng2p_ClassClose()
{
  return 0;
}

uint64_t fe_nng2p_ObjOpen(_WORD *a1, int a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v5 = 2707431431;
  if (a5)
  {
    uint64_t inited = InitRsrcFunction(a1, a2, &v19);
    if ((inited & 0x80000000) == 0)
    {
      *(void *)a5 = 0;
      *(_DWORD *)(a5 + 8) = 0;
      uint64_t inited = InitRsrcFunction(a3, a4, &v18);
      if ((inited & 0x80000000) == 0)
      {
        int v10 = (void *)heap_Calloc(*(void **)(v18 + 8), 1, 64);
        if (!v10)
        {
          log_OutPublic(*(void *)(v18 + 32), (uint64_t)"FE_NN_G2P", 78000, 0, v11, v12, v13, v14, v18);
          return 2707431434;
        }
        unsigned int v15 = v10;
        *int v10 = a3;
        v10[1] = a4;
        int Allocator = ooc_utils_createAllocator((uint64_t)(v10 + 2), a3, a4);
        uint64_t inited = LH_ERROR_to_VERROR(Allocator);
        if ((inited & 0x80000000) == 0)
        {
          *(void *)a5 = v15;
          *(_DWORD *)(a5 + 8) = 1069;
          return fe_nng2p_ObjReopen(v15, *(void *)(a5 + 8));
        }
      }
    }
    return inited;
  }
  return v5;
}

uint64_t fe_nng2p_ObjClose(uint64_t a1, int a2)
{
  uint64_t v6 = 0;
  uint64_t v3 = 2707431432;
  if ((safeh_HandleCheck(a1, a2, 1069, 64) & 0x80000000) == 0 && a1)
  {
    uint64_t inited = InitRsrcFunction(*(_WORD **)a1, *(void *)(a1 + 8), &v6);
    if ((inited & 0x80000000) != 0)
    {
      return inited;
    }
    else
    {
      uint64_t v3 = LH_ERROR_to_VERROR(0);
      if ((v3 & 0x80000000) == 0)
      {
        luavmldoutil_destroy_lua_vm(a1 + 16, (uint64_t *)(a1 + 56));
        kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(a1 + 16));
        heap_Free(*(void **)(v6 + 8), a1);
      }
    }
  }
  return v3;
}

uint64_t fe_nng2p_ObjReopen(void *a1, int a2)
{
  if ((safeh_HandleCheck((uint64_t)a1, a2, 1069, 64) & 0x80000000) != 0 || !a1) {
    return 2707431432;
  }
  uint64_t v3 = (_WORD *)*a1;
  uint64_t v4 = a1[1];
  return luavmldoutil_initialize_lua_vm(v3, v4, (uint64_t)(a1 + 2), (uint64_t)"runG2P", (uint64_t)hlp_lua_log_callback, a1 + 7, 0);
}

uint64_t fe_nng2p_ProcessStart()
{
  return 0;
}

uint64_t fe_nng2p_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  if ((safeh_HandleCheck(a1, a2, 1069, 64) & 0x80000000) != 0) {
    return 2707431432;
  }
  uint64_t inited = InitRsrcFunction(*(_WORD **)a1, *(void *)(a1 + 8), &v25);
  if ((inited & 0x80000000) == 0)
  {
    *a5 = 1;
    log_OutText(*(void *)(v25 + 32), (uint64_t)"FE_NN_G2P", 4, 0, (uint64_t)"Entering fe_nng2p_Process", v9, v10, v11, v22);
    if (*(void *)(a1 + 56))
    {
      uint64_t Interface = lingdb_GetInterface(1u, &v24);
      if ((Interface & 0x80000000) != 0) {
        return Interface;
      }
      uint64_t inited = LingDBIsValid(v24, a3, a4, &v26);
      if ((inited & 0x80000000) != 0) {
        goto LABEL_22;
      }
      if (v26 == 1)
      {
        uint64_t inited = LingDBHasSentence(v24, a3, a4, (_DWORD *)&v26 + 1);
        if ((inited & 0x80000000) != 0) {
          goto LABEL_22;
        }
        if (HIDWORD(v26) == 1)
        {
          uint64_t v17 = auxTouchLingdbInstance(v24, a3, a4);
          if ((v17 & 0x80000000) != 0)
          {
LABEL_15:
            uint64_t inited = v17;
            goto LABEL_22;
          }
          uint64_t inited = initLDO(a1 + 16, &v23);
          if ((inited & 0x80000000) != 0) {
            goto LABEL_22;
          }
          if (v23)
          {
            uint64_t v17 = importFromLingDBWordRecord(v25, v24, a3, a4, &v23, 0);
            if ((v17 & 0x80000000) == 0)
            {
              int v18 = LuaVMLDO_RunFunction(*(void *)(a1 + 56), (uint64_t)"runG2P", v23);
              uint64_t v17 = LH_ERROR_to_VERROR(v18);
              if ((v17 & 0x80000000) == 0) {
                uint64_t v17 = exportToLingDBWordRecord(v25, v24, a3, a4, a1 + 16, v23, 0);
              }
            }
            goto LABEL_15;
          }
          uint64_t v19 = *(void *)(v25 + 32);
          uint64_t v20 = "Init LDO is NULL, returning";
        }
        else
        {
          uint64_t v19 = *(void *)(v25 + 32);
          uint64_t v20 = "LingDB has no sentence, returning";
        }
      }
      else
      {
        uint64_t v19 = *(void *)(v25 + 32);
        uint64_t v20 = "Empty or Invalid LingDB, returning";
      }
    }
    else
    {
      uint64_t v19 = *(void *)(v25 + 32);
      uint64_t v20 = "No NNG2P Lua script available, returning";
    }
    log_OutText(v19, (uint64_t)"FE_NN_G2P", 5, 0, (uint64_t)v20, v13, v14, v15, 0);
LABEL_22:
    if (v23) {
      deinitLDO(a1 + 16, v23);
    }
  }
  return inited;
}

uint64_t fe_nng2p_ProcessEnd(uint64_t a1, int a2)
{
  LODWORD(result) = safeh_HandleCheck(a1, a2, 1069, 64);
  if ((int)result >= 0) {
    return result;
  }
  else {
    return 2707431432;
  }
}

uint64_t hlp_lua_log_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return log_OutText(a1, (uint64_t)"FE_NN_G2P", 4, 0, a2, a6, a7, a8, 0);
}

uint64_t auxTouchLingdbInstance(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v7 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *))(a1 + 104))(a2, a3, 1, 0, (char *)&v7 + 2);
  if ((result & 0x80000000) == 0) {
    return (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(a1 + 160))(a2, a3, HIWORD(v7), 2, 1, &byte_20D5A22AE, &v7);
  }
  return result;
}

uint64_t fe_clm_component_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2346721281;
  }
  uint64_t result = 0;
  *a2 = &IFeClm;
  return result;
}

uint64_t fe_clm_ClassOpen(_WORD *a1, uint64_t a2, void *a3)
{
  uint64_t v7 = 0;
  if (!a3) {
    return 2346721287;
  }
  uint64_t result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *a3 = a1;
    a3[1] = a2;
  }
  return result;
}

uint64_t fe_clm_ClassClose()
{
  return 0;
}

uint64_t fe_clm_ObjOpen(_WORD *a1, int a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v5 = 2346721287;
  uint64_t v20 = 0;
  if (a5)
  {
    uint64_t inited = InitRsrcFunction(a1, a2, &v22);
    if ((inited & 0x80000000) == 0)
    {
      *(void *)a5 = 0;
      *(_DWORD *)(a5 + 8) = 0;
      uint64_t inited = InitRsrcFunction(a3, a4, &v21);
      if ((inited & 0x80000000) == 0)
      {
        uint64_t v10 = (uint64_t *)heap_Calloc(*(void **)(v21 + 8), 1, 72);
        if (!v10)
        {
          log_OutPublic(*(void *)(v21 + 32), (uint64_t)"FE_CLM", 78000, 0, v11, v12, v13, v14, v19[0]);
          return 2346721290;
        }
        uint64_t v15 = v10;
        *uint64_t v10 = (uint64_t)a3;
        v10[1] = a4;
        if ((paramc_ParamGetStr(*(void *)(v21 + 40), (uint64_t)"shortfragmentforceclm", &v20) & 0x80000000) != 0
          || !v20
          || (uint64_t v16 = *(void *)(v21 + 40),
              v19[0] = v15,
              v19[1] = fe_clm_CheckParamChange,
              v19[2] = fe_clm_LearnParamChange,
              uint64_t inited = paramc_ListenerAdd(v16, "shortfragmentforceclm", v19),
              (inited & 0x80000000) == 0))
        {
          int Allocator = ooc_utils_createAllocator((uint64_t)(v15 + 2), (_WORD *)*v15, v15[1]);
          uint64_t inited = LH_ERROR_to_VERROR(Allocator);
          if ((inited & 0x80000000) == 0)
          {
            *(void *)a5 = v15;
            *(_DWORD *)(a5 + 8) = 381;
            return fe_clm_ObjReopen(v15, *(void *)(a5 + 8));
          }
        }
      }
    }
    return inited;
  }
  return v5;
}

uint64_t fe_clm_ObjClose(uint64_t a1, int a2)
{
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t inited = 2346721288;
  if ((safeh_HandleCheck(a1, a2, 381, 72) & 0x80000000) == 0)
  {
    if (a1)
    {
      uint64_t inited = InitRsrcFunction(*(_WORD **)a1, *(void *)(a1 + 8), &v9);
      if ((inited & 0x80000000) == 0)
      {
        if ((paramc_ParamGetStr(*(void *)(v9 + 40), (uint64_t)"shortfragmentforceclm", &v8) & 0x80000000) == 0 && v8)
        {
          uint64_t v4 = *(void *)(v9 + 40);
          *(void *)&long long v6 = a1;
          *((void *)&v6 + 1) = fe_clm_CheckParamChange;
          uint64_t v7 = fe_clm_LearnParamChange;
          paramc_ListenerRemove(v4, "shortfragmentforceclm", &v6);
        }
        luavmldoutil_destroy_lua_vm(a1 + 16, (uint64_t *)(a1 + 56));
        kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(a1 + 16));
        heap_Free(*(void **)(v9 + 8), a1);
      }
    }
  }
  return inited;
}

uint64_t fe_clm_ObjReopen(uint64_t *a1, int a2)
{
  int v18 = 0;
  uint64_t v19 = 0;
  uint64_t v17 = 0;
  uint64_t v3 = 2346721288;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 381, 72) & 0x80000000) != 0 || !a1) {
    return v3;
  }
  uint64_t inited = InitRsrcFunction((_WORD *)*a1, a1[1], &v18);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  luavmldoutil_destroy_lua_vm((uint64_t)(a1 + 2), a1 + 7);
  uint64_t Object = paramc_ParamGet(v18[5], (uint64_t)"langcode", &v19, 0);
  if ((Object & 0x80000000) == 0)
  {
    uint64_t Object = objc_GetObject(v18[6], (uint64_t)"CLMOBJECT", &v17);
    if ((Object & 0x80000000) == 0)
    {
      uint64_t v3 = (*(uint64_t (**)(void, void, _WORD **))(v17[1] + 96))(v17[2], v17[3], (_WORD **)a1 + 8);
      if ((v3 & 0x80000000) != 0)
      {
LABEL_10:
        log_OutText(v18[4], (uint64_t)"FE_CLM", 5, 0, (uint64_t)"CLM Lua script for main language [%s] is not available, no CLM to main language in \"fe/fe_clm\" component (CLM done in upstream components).", v6, v7, v8, v19);
        goto LABEL_12;
      }
      int v9 = *((_DWORD *)a1 + 16);
      switch(v9)
      {
        case 2:
          uint64_t v11 = v18[4];
          uint64_t v12 = v19;
          uint64_t v13 = "CLM to main language [%s]  will be done in  \"fe/fe_clm\" component (after fe_global).";
          break;
        case 1:
          uint64_t v11 = v18[4];
          uint64_t v12 = v19;
          uint64_t v13 = "CLM to main language [%s]  will be done in  \"fe/fe_clm\" component (before fe_global).";
          break;
        case 0:
          goto LABEL_10;
        default:
LABEL_19:
          uint64_t v3 = luavmldoutil_initialize_lua_vm((_WORD *)*a1, a1[1], (uint64_t)(a1 + 2), (uint64_t)"runCLM", (uint64_t)hlp_lua_log_callback_0, a1 + 7, "clm");
          if ((v3 & 0x80000000) != 0)
          {
            log_OutText(v18[4], (uint64_t)"FE_CLM", 5, 0, (uint64_t)"CLM Lua function [%s] is not available, no CLM to main language in \"fe/fe_clm\" component (CLM done in upstream components).", v14, v15, v16, (uint64_t)"runCLM");
            uint64_t v3 = 0;
          }
          goto LABEL_12;
      }
      log_OutText(v11, (uint64_t)"FE_CLM", 5, 0, (uint64_t)v13, v6, v7, v8, v12);
      goto LABEL_19;
    }
  }
  uint64_t v3 = Object;
LABEL_12:
  if (v17) {
    objc_ReleaseObject(v18[6], (uint64_t)"CLMOBJECT");
  }
  return v3;
}

uint64_t fe_clm_ProcessStart()
{
  return 0;
}

uint64_t fe_clm_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t inited = 2346721288;
  if ((safeh_HandleCheck(a1, a2, 381, 72) & 0x80000000) != 0) {
    return inited;
  }
  if (!a1) {
    return inited;
  }
  uint64_t inited = InitRsrcFunction(*(_WORD **)a1, *(void *)(a1 + 8), &v27);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  *a5 = 1;
  log_OutText(*(void *)(v27 + 32), (uint64_t)"FE_CLM", 4, 0, (uint64_t)"Entering fe_clm_Process", v10, v11, v12, v23);
  if (*(void *)(a1 + 56))
  {
    uint64_t Interface = lingdb_GetInterface(1u, &v25);
    if ((Interface & 0x80000000) != 0) {
      return Interface;
    }
    uint64_t inited = LingDBIsValid(v25, a3, a4, &v24);
    if ((inited & 0x80000000) != 0) {
      goto LABEL_22;
    }
    if (v24 == 1)
    {
      uint64_t inited = LingDBHasSentence(v25, a3, a4, (_DWORD *)&v24 + 1);
      if ((inited & 0x80000000) != 0) {
        goto LABEL_22;
      }
      if (HIDWORD(v24) == 1)
      {
        uint64_t v17 = auxTouchLingdbInstance(v25, a3, a4);
        if ((v17 & 0x80000000) != 0)
        {
LABEL_16:
          uint64_t inited = v17;
          goto LABEL_22;
        }
        uint64_t inited = initLDO(a1 + 16, &v26);
        if ((inited & 0x80000000) != 0) {
          goto LABEL_22;
        }
        if (v26)
        {
          BOOL v18 = *(_DWORD *)(a1 + 64) != 1;
          uint64_t v17 = importFromLingDBWordRecord(v27, v25, a3, a4, &v26, v18);
          if ((v17 & 0x80000000) == 0)
          {
            int v19 = LuaVMLDO_RunFunction(*(void *)(a1 + 56), (uint64_t)"runCLM", v26);
            uint64_t v17 = LH_ERROR_to_VERROR(v19);
            if ((v17 & 0x80000000) == 0) {
              uint64_t v17 = exportToLingDBWordRecord(v27, v25, a3, a4, a1 + 16, v26, v18);
            }
          }
          goto LABEL_16;
        }
        uint64_t v20 = *(void *)(v27 + 32);
        uint64_t v21 = "Init LDO is NULL, returning";
      }
      else
      {
        uint64_t v20 = *(void *)(v27 + 32);
        uint64_t v21 = "LingDB has no sentence, returning";
      }
    }
    else
    {
      uint64_t v20 = *(void *)(v27 + 32);
      uint64_t v21 = "Empty or Invalid LingDB, returning";
    }
  }
  else
  {
    uint64_t v20 = *(void *)(v27 + 32);
    uint64_t v21 = "No CLM Lua script available, returning";
  }
  log_OutText(v20, (uint64_t)"FE_CLM", 5, 0, (uint64_t)v21, v13, v14, v15, 0);
LABEL_22:
  if (v26) {
    deinitLDO(a1 + 16, v26);
  }
  return inited;
}

uint64_t fe_clm_ProcessEnd(uint64_t a1, int a2)
{
  LODWORD(result) = safeh_HandleCheck(a1, a2, 381, 72);
  if ((int)result >= 0) {
    return result;
  }
  else {
    return 2346721288;
  }
}

uint64_t fe_clm_CheckParamChange(uint64_t a1, char *__s1, unsigned char *a3, _DWORD *a4)
{
  uint64_t v20 = 0;
  if (a1 && (int v7 = strcmp(__s1, "shortfragmentforceclm"), a3) && !v7 && *a3)
  {
    uint64_t result = InitRsrcFunction(*(_WORD **)a1, *(void *)(a1 + 8), &v20);
    if ((result & 0x80000000) == 0)
    {
      if (LH_strnicmp((uint64_t)a3, (uint64_t)"phrase:", 7uLL))
      {
        uint64_t v12 = a3 + 1;
        int v13 = 1;
        while (1)
        {
          int v14 = *(v12 - 1);
          if (!*(v12 - 1)) {
            goto LABEL_28;
          }
          if (v14 == 58) {
            break;
          }
          if ((v14 - 58) < 0xFFFFFFF6) {
            goto LABEL_28;
          }
          if (v13) {
            BOOL v15 = v14 == 48;
          }
          else {
            BOOL v15 = 0;
          }
          int v13 = v15;
          ++v12;
        }
        if (v13)
        {
LABEL_28:
          *a4 = 0;
          goto LABEL_29;
        }
        *a4 = 1;
      }
      else
      {
        *a4 = 1;
        uint64_t v12 = a3 + 7;
      }
      char v18 = *v12;
      uint64_t v16 = v12 + 1;
      char v17 = v18;
      while (v17 > 89 || v17 == 44)
      {
        int v19 = *v16++;
        char v17 = v19;
        if (!v19) {
          goto LABEL_23;
        }
      }
      *a4 = v17 == 0;
      if (v17) {
LABEL_29:
      }
        log_OutText(*(void *)(v20 + 32), (uint64_t)"FE_CLM", 5, 0, (uint64_t)"%s=%s : IGNORED (invalid)", v9, v10, v11, (uint64_t)"shortfragmentforceclm");
      return 0;
    }
  }
  else
  {
LABEL_23:
    uint64_t result = 0;
    *a4 = 1;
  }
  return result;
}

uint64_t fe_clm_LearnParamChange()
{
  return 0;
}

uint64_t hlp_lua_log_callback_0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return log_OutText(a1, (uint64_t)"FE_CLM", 4, 0, a2, a6, a7, a8, 0);
}

uint64_t com_depes_InitLayers(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = a1;
  *(_DWORD *)(a2 + 8) = 0;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 96) = 0u;
  *(_OWORD *)(a2 + 112) = 0u;
  return 0;
}

uint64_t com_depes_FreeLayers(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0;
  uint64_t v4 = a2 + 16;
  uint64_t v5 = (_WORD *)(a2 + 112);
  do
  {
    uint64_t v6 = *(void *)(v4 + v3);
    if (v6)
    {
      heap_Free(*(void **)(a1 + 8), v6);
      *(void *)(v4 + v3) = 0;
    }
    *(v5 - 16) = 0;
    *(v5 - 8) = 0;
    *v5++ = 0;
    v3 += 8;
  }
  while (v3 != 64);
  return 0;
}

uint64_t com_depes_PrepareLayersForLen(uint64_t *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 == 0xFFFF)
  {
    uint64_t v25 = 2305826825;
    uint64_t v21 = *a1;
    goto LABEL_28;
  }
  unsigned int v9 = *((unsigned __int16 *)a1 + 40);
  uint64_t v10 = *((unsigned __int16 *)a1 + 5);
  if (v10 >= 2)
  {
    uint64_t v11 = (unsigned __int16 *)a1 + 41;
    uint64_t v12 = v10 - 1;
    do
    {
      unsigned int v14 = *v11++;
      unsigned int v13 = v14;
      if (v14 >= (unsigned __int16)v9) {
        unsigned int v9 = (unsigned __int16)v9;
      }
      else {
        unsigned int v9 = v13;
      }
      --v12;
    }
    while (v12);
  }
  unsigned __int16 v15 = a2 + 1;
  if (v9 >= (unsigned __int16)(a2 + 1)) {
    return 0;
  }
  unsigned __int16 v16 = v9 ? v9 : 200;
  do
  {
    __int16 v17 = v16;
    unsigned int v18 = v16;
    if (v16 >= v15) {
      break;
    }
    v16 *= 2;
  }
  while ((v17 & 0x8000) == 0);
  unsigned __int16 v19 = v18 < v15 ? -1 : v17;
  if (!*((_WORD *)a1 + 5)) {
    return 0;
  }
  uint64_t v20 = 0;
  uint64_t v21 = *a1;
  uint64_t v22 = a1 + 10;
  while (*((unsigned __int16 *)v22 + v20) >= v19)
  {
LABEL_25:
    if (++v20 >= (unint64_t)v10) {
      return 0;
    }
  }
  uint64_t v23 = *(uint64_t **)(v21 + 8);
  if (*((_WORD *)v22 + v20))
  {
    uint64_t v24 = heap_Realloc(v23, v22[v20 - 8], v19);
    if (!v24) {
      goto LABEL_30;
    }
    goto LABEL_24;
  }
  uint64_t v24 = heap_Alloc((uint64_t)v23, v19);
  if (v24)
  {
LABEL_24:
    v22[v20 - 8] = v24;
    *((_WORD *)v22 + v20) = v19;
    LODWORD(v10) = *((unsigned __int16 *)a1 + 5);
    goto LABEL_25;
  }
LABEL_30:
  uint64_t v25 = 2305826826;
LABEL_28:
  log_OutPublic(*(void *)(v21 + 32), (uint64_t)"COM_DEPES", 38000, 0, a5, a6, a7, a8, v27);
  return v25;
}

uint64_t com_depes_StartWritingToLayers(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = com_depes_PrepareLayersForLen((uint64_t *)a1, 1, a3, a4, a5, a6, a7, a8);
  if ((result & 0x80000000) == 0 && *(_WORD *)(a1 + 10))
  {
    unint64_t v10 = 0;
    do
      **(unsigned char **)(a1 + 16 + 8 * v10++) = 0;
    while (v10 < *(unsigned __int16 *)(a1 + 10));
  }
  return result;
}

uint64_t com_depes_AddToLayerGen(uint64_t *a1, unsigned int a2, char *__s, int a4, int a5)
{
  uint64_t v6 = __s;
  unsigned int v9 = a4 & ~(a4 >> 31);
  unsigned __int16 v10 = strlen(__s);
  if (v9 >= v10) {
    unsigned __int16 v11 = v10;
  }
  else {
    unsigned __int16 v11 = v9;
  }
  int v12 = v11;
  __int16 v19 = Utf8_LengthInUtf8chars((unint64_t)v6, v11);
  __int16 v20 = 0;
  if (v12)
  {
    int v21 = v12;
    uint64_t v22 = v6;
    do
    {
      int v23 = *v22++;
      if (v23 != 126 || a5 == 0) {
        __int16 v25 = 1;
      }
      else {
        __int16 v25 = 2;
      }
      v20 += v25;
      --v21;
    }
    while (v21);
  }
  uint64_t v26 = (char *)a1 + 2 * a2;
  __int16 v28 = *((_WORD *)v26 + 48);
  unsigned int v27 = v26 + 96;
  uint64_t result = com_depes_PrepareLayersForLen(a1, (unsigned __int16)(v28 + v20), v13, v14, v15, v16, v17, v18);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v30 = (unsigned char *)(a1[a2 + 2] + (unsigned __int16)*v27);
    if (v12)
    {
      int v31 = 0;
      __int16 v32 = 0;
      do
      {
        LODWORD(v33) = *v6;
        if (a5 && v33 == 126)
        {
          uint64_t v33 = 0;
          char v34 = -62;
          do
          {
            v30[v33] = v34;
            char v34 = asc_20D5C5CCF[++v33];
          }
          while (v33 != 2);
          v30 += 2;
        }
        else
        {
          *v30++ = v33;
          LOWORD(v33) = 1;
        }
        v32 += v33;
        ++v6;
        ++v31;
      }
      while (v31 != v12);
    }
    else
    {
      __int16 v32 = 0;
    }
    *uint64_t v30 = 0;
    *v27 += v32;
    *((_WORD *)a1 + a2 + 56) += v19;
  }
  return result;
}

uint64_t com_depes_AddToLayerN(uint64_t *a1, unsigned int a2, char *a3, int a4)
{
  return com_depes_AddToLayerGen(a1, a2, a3, a4, 1);
}

uint64_t com_depes_AddToLayer(uint64_t *a1, unsigned int a2, char *__s)
{
  int v6 = (unsigned __int16)strlen(__s);
  return com_depes_AddToLayerGen(a1, a2, __s, v6, 1);
}

uint64_t com_depes_FillToMaxLayerSet(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned __int16 *)(a1 + 10);
  if (*(_WORD *)(a1 + 10))
  {
    uint64_t v12 = 0;
    unsigned __int16 v13 = 0;
    do
    {
      if (*(_DWORD *)(a2 + 4 * v12) == 1 && *(unsigned __int16 *)(a1 + 2 * v12 + 112) > v13) {
        unsigned __int16 v13 = *(_WORD *)(a1 + 2 * v12 + 112);
      }
      ++v12;
    }
    while (v8 != v12);
    unint64_t v14 = 0;
    do
    {
      if (*(_DWORD *)(a2 + 4 * v14) == 1)
      {
        uint64_t v15 = a1 + 2 * v14;
        int v16 = *(unsigned __int16 *)(v15 + 112);
        __int16 v17 = v13 - v16;
        uint64_t result = com_depes_PrepareLayersForLen((uint64_t *)a1, (unsigned __int16)(*(_WORD *)(v15 + 96) + v13 - v16), a3, a4, a5, a6, a7, a8);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        int v19 = *(unsigned __int8 *)(a3 + v14);
        uint64_t v20 = *(unsigned __int16 *)(v15 + 96);
        if (!*(unsigned char *)(a3 + v14))
        {
          if (*(_WORD *)(v15 + 96)) {
            int v19 = *(unsigned __int8 *)(*(void *)(a1 + 8 * v14 + 16) + (v20 - 1));
          }
          else {
            int v19 = 126;
          }
        }
        uint64_t v21 = *(void *)(a1 + 8 * v14 + 16);
        uint64_t v22 = (unsigned char *)(v21 + v20);
        if (v16 != v13)
        {
          unsigned __int16 v23 = v13 + ~(_WORD)v16;
          memset(v22, v19, v23 + 1);
          uint64_t v22 = (unsigned char *)(v21 + v20 + v23 + 1);
        }
        *uint64_t v22 = 0;
        *(_WORD *)(v15 + 96) += v17;
        *(_WORD *)(v15 + 112) += v17;
        LODWORD(v8) = *(unsigned __int16 *)(a1 + 10);
      }
      ++v14;
    }
    while (v14 < v8);
  }
  return 0;
}

uint64_t com_depes_FillToMaxLayerRange(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10 = a2;
  uint64_t v15 = *MEMORY[0x263EF8340];
  if (!a2 || (bzero(v14, 4 * a2), v10 <= a3))
  {
    do
    {
      v14[(unsigned __int16)v10] = 1;
      LOWORD(v10) = v10 + 1;
    }
    while (a3 >= (unsigned __int16)v10);
  }
  unsigned int v12 = *(unsigned __int16 *)(a1 + 10);
  if (v12 > (unsigned __int16)v10) {
    bzero(&v14[(unsigned __int16)v10], 4 * (unsigned __int16)(v12 + ~(_WORD)v10) + 4);
  }
  return com_depes_FillToMaxLayerSet(a1, (uint64_t)v14, a4, a4, a5, a6, a7, a8);
}

uint64_t com_depes_FillToMaxAllLayers(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return com_depes_FillToMaxLayerRange(a1, 0, (unsigned __int16)(*(_WORD *)(a1 + 10) - 1), a2, a5, a6, a7, a8);
}

uint64_t com_depes_InsertBeforeEnd(uint64_t *a1, unsigned int a2, char *__s, int a4)
{
  uint64_t v5 = __s;
  uint64_t v8 = (char *)a1 + 2 * a2;
  unsigned int v11 = *((unsigned __int16 *)v8 + 48);
  unsigned int v9 = v8 + 96;
  unsigned int v10 = v11;
  unsigned __int16 v12 = strlen(__s);
  int v13 = v12;
  __int16 v14 = Utf8_LengthInUtf8chars((unint64_t)v5, v12);
  uint64_t v21 = com_depes_PrepareLayersForLen(a1, (unsigned __int16)(*v9 + v12), v15, v16, v17, v18, v19, v20);
  if ((v21 & 0x80000000) == 0)
  {
    unsigned int v22 = a4 & ~(a4 >> 31);
    if (v22 >= v10) {
      size_t v23 = v10;
    }
    else {
      size_t v23 = v22;
    }
    uint64_t v24 = &a1[a2];
    uint64_t v26 = v24[2];
    __int16 v25 = v24 + 2;
    unsigned int v27 = (unsigned char *)(v26 + (unsigned __int16)*v9 - v23);
    memmove(&v27[v12], v27, v23);
    if (v12)
    {
      do
      {
        char v28 = *v5++;
        *v27++ = v28;
        --v13;
      }
      while (v13);
    }
    unsigned __int16 v29 = *v9 + v12;
    *unsigned int v9 = v29;
    *((_WORD *)a1 + a2 + 56) += v14;
    *(unsigned char *)(*v25 + v29) = 0;
  }
  return v21;
}

size_t GetContextLenInNrChars(size_t result, int a2, int a3, int a4, int a5, _WORD *a6, _WORD *a7)
{
  size_t v13 = result;
  int v14 = 0;
  *a6 = 0;
  LOWORD(v15) = a2;
  *a7 = 0;
  if (a2 <= a3)
  {
    Utf32SymToUtf8Sym(*(_DWORD *)(result + 4 * a2), __s, 5u);
    uint64_t result = strlen(__s);
    int v14 = (__int16)result;
  }
  if (a2 < a3 && v14 <= a4)
  {
    uint64_t v15 = a2;
    do
    {
      unsigned int v16 = *(_DWORD *)(v13 + 4 + 4 * v15++);
      Utf32SymToUtf8Sym(v16, __s, 5u);
      uint64_t result = strlen(__s);
      if (v15 >= a3) {
        break;
      }
      int v14 = (__int16)(v14 + result);
    }
    while (v14 <= a4);
  }
  *a6 = v15 - a2;
  if (a2 <= a3)
  {
    Utf32SymToUtf8Sym(*(_DWORD *)(v13 + 4 * a3), __s, 5u);
    uint64_t result = strlen(__s);
    int v17 = (__int16)result;
  }
  else
  {
    int v17 = 0;
  }
  LOWORD(v18) = a3;
  if (a2 < a3 && v17 <= a5)
  {
    uint64_t v18 = a3;
    do
    {
      unsigned int v19 = *(_DWORD *)(v13 - 4 + 4 * v18--);
      Utf32SymToUtf8Sym(v19, __s, 5u);
      uint64_t result = strlen(__s);
      if (v18 <= a2) {
        break;
      }
      int v17 = (__int16)(v17 + result);
    }
    while (v17 <= a5);
  }
  *a7 = a3 - v18;
  return result;
}

uint64_t INFERENCE(uint64_t a1, uint64_t a2, int a3, __int16 *a4)
{
  if (*(unsigned char *)(a1 + 1428)) {
    return 0;
  }
  uint64_t v5 = a4;
  uint64_t v7 = a2;
  memset(v147, 0, 512);
  uint64_t v9 = *a4;
  if (*(__int16 *)(a1 + 24) <= 0)
  {
    uint64_t v12 = a3;
    uint64_t v13 = a3 - 1;
    size_t v14 = (unsigned __int16)(v9 - a3 + 1);
    uint64_t v15 = v9 + 1;
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v12 = a3;
    uint64_t v13 = a3 - 1;
    size_t v14 = (unsigned __int16)(v9 - a3 + 1);
    uint64_t v15 = v9 + 1;
    uint64_t v16 = *(void *)(a1 + 1504);
    do
    {
      memmove((void *)(*(void *)(v16 + 8 * v11) + 4 * a3), (const void *)(*(void *)(v16 + 8 * v11) + 4 * v13), 4 * v14);
      uint64_t v16 = *(void *)(a1 + 1504);
      uint64_t v17 = *(void *)(v16 + 8 * v11);
      *(_DWORD *)(v17 + 4 * v15) = 31;
      *(_DWORD *)(v17 + 4 * v13) = 31;
      ++v11;
    }
    while (v11 < *(__int16 *)(a1 + 24));
    uint64_t v5 = a4;
    uint64_t v7 = a2;
  }
  memmove((void *)(*(void *)(a1 + 1560) + v12), (const void *)(*(void *)(a1 + 1560) + v13), v14);
  *(unsigned char *)(*(void *)(a1 + 1560) + v15) = 0;
  *(unsigned char *)(*(void *)(a1 + 1560) + v13) = 0;
  __int16 v21 = *v5 + 1;
  *uint64_t v5 = v21;
  *(_WORD *)&v147[34] = v21;
  uint64_t v22 = **(void **)(a1 + 1504);
  *(void *)(a1 + 1448) = v22;
  *(void *)(a1 + 1440) = v22;
  *(void *)&v147[8] = v22;
  *(void *)&v147[16] = v22;
  *(_WORD *)(a1 + 1410) = 0;
  __int16 v151 = 0;
  uint64_t v149 = 0;
  *(_OWORD *)(a1 + 2096) = 0u;
  memset(&v147[36], 0, 512);
  if (a3 < v21)
  {
    uint64_t v23 = a3;
    do
    {
      Utf32SymToUtf8Sym(*(_DWORD *)(**(void **)(a1 + 1504) + 4 * v23), v146, 5u);
      int v24 = v146[0];
      if (v146[0])
      {
        int v25 = 0;
        do
        {
          ++*(_WORD *)&v147[2 * v24 + 36];
          int v24 = v146[(__int16)++v25];
        }
        while (v146[(__int16)v25]);
      }
      ++v23;
    }
    while (v23 < *(__int16 *)&v147[34]);
  }
  *(_WORD *)&v147[98] = 2;
  *(_WORD *)&v147[30] = *(_WORD *)(*(void *)(a1 + 64) + 2 * ((int)v7 - 1)) - 1;
  if ((*(_WORD *)&v147[30] & 0x8000) != 0) {
    return 0;
  }
  uint64_t v26 = (int)v7 - 1;
  log_OutText(*(void *)(*(void *)(a1 + 2080) + 32), (uint64_t)"FE_DEPES", 6, 0, (uint64_t)"Start gram number %d", v18, v19, v20, v7);
  *(_WORD *)(a1 + 2 * *(__int16 *)(a1 + 1430) + 1568) = a3;
  int v27 = *(__int16 *)&v147[30];
  *(_WORD *)(a1 + 2 * *(__int16 *)(a1 + 1430) + 1824) = *(_WORD *)&v147[30];
  if (v27 < *(__int16 *)(*(void *)(a1 + 72) + 2 * v26))
  {
    char v28 = (uint64_t *)(a1 + 152);
    do
    {
      uint64_t v29 = *(void *)(a1 + 120);
      *(_DWORD *)v147 = *(_DWORD *)(*(void *)(a1 + 112) + 4 * (__int16)v27);
      GetContextLenInNrChars(*(size_t *)&v147[8], a3, *(__int16 *)&v147[34], *(unsigned __int8 *)(v29 + (__int16)v27), *(unsigned __int8 *)(*(void *)(a1 + 128) + (__int16)v27), &v147[24], &v147[26]);
      uint64_t v34 = *(unsigned __int16 *)&v147[30] + 1;
      ++*(_WORD *)&v147[30];
      uint64_t v35 = *(void *)(a1 + 176);
      uint64_t v36 = *(unsigned int *)v147;
      unsigned int v37 = *(unsigned __int8 *)(v35 + (*(_DWORD *)v147 - 1));
      if (v37 > 0x64) {
        v37 -= 100;
      }
      *(_WORD *)(a1 + 1408) = v37;
      switch(v37)
      {
        case 1u:
          uint64_t v38 = (__int16)v34 - 1;
          if (*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 160) + v38) + 36])
          {
            if (*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 168) + v38) + 36])
            {
              unsigned __int8 v150 = *(unsigned char *)(v35 + v36);
              LOWORD(v39) = *(_WORD *)&v147[24] + a3;
              *(_WORD *)&v147[32] = *(_WORD *)&v147[24] + a3;
              if (*(__int16 *)&v147[34] - *(__int16 *)&v147[26] >= (__int16)(*(_WORD *)&v147[24] + a3))
              {
                int v39 = (__int16)v39;
                do
                {
                  if (*(unsigned char *)(a1 + 1428)) {
                    break;
                  }
                  Utf32SymToUtf8Sym(*(_DWORD *)(*(void *)(a1 + 1440) + 4 * (v39 - 1)), v146, 5u);
                  if (v146[0] == v150)
                  {
                    unsigned __int16 v148 = 0;
                    *(void *)(a1 + 1456) = *(void *)(a1 + 176) + (*(_DWORD *)v147 + 1);
                    *(_WORD *)(a1 + 1470) = 1;
                    EXEC_RULE(a1, *(__int16 *)&v147[30], (__int16)(*(_WORD *)&v147[32] + 1), (uint64_t)v147, v40, v41, v42, v43);
                    __int16 v44 = v148 + 1;
                    __int16 v45 = *(_WORD *)&v147[32];
                  }
                  else
                  {
                    __int16 v45 = 1;
                    __int16 v44 = *(_WORD *)&v147[32];
                  }
                  *(_WORD *)&v147[32] = v44 + v45;
                  int v39 = (__int16)(v44 + v45);
                }
                while (*(__int16 *)&v147[34] - *(__int16 *)&v147[26] >= *(__int16 *)&v147[32]);
              }
            }
          }
          goto LABEL_219;
        case 2u:
          uint64_t v48 = (__int16)v34 - 1;
          if (*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 160) + v48) + 36])
          {
            if (*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 168) + v48) + 36])
            {
              LOWORD(v49) = *(_WORD *)&v147[34] - *(_WORD *)&v147[26] + 1;
              *(_WORD *)&v147[32] = v49;
              unsigned __int8 v150 = *(unsigned char *)(v35 + v36);
              if (*(__int16 *)&v147[24] + a3 <= (__int16)v49)
              {
                int v49 = (__int16)v49;
                do
                {
                  if (*(unsigned char *)(a1 + 1428)) {
                    break;
                  }
                  Utf32SymToUtf8Sym(*(_DWORD *)(*(void *)(a1 + 1440) + 4 * (v49 - 1)), v146, 5u);
                  if (v146[0] == v150)
                  {
                    *(void *)(a1 + 1456) = *(void *)(a1 + 176) + (*(_DWORD *)v147 + 1);
                    *(_WORD *)(a1 + 1470) = 1;
                    EXEC_RULE(a1, *(__int16 *)&v147[30], (__int16)(*(_WORD *)&v147[32] + 1), (uint64_t)v147, v50, v51, v52, v53);
                  }
                  --*(_WORD *)&v147[32];
                  int v49 = *(__int16 *)&v147[32];
                }
                while (*(__int16 *)&v147[24] + a3 <= *(__int16 *)&v147[32]);
              }
            }
          }
          goto LABEL_219;
        case 3u:
          uint64_t v54 = (__int16)v34 - 1;
          if (*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 160) + v54) + 36])
          {
            if (*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 168) + v54) + 36])
            {
              __int16 v55 = *(_WORD *)&v147[24] + a3;
              *(_WORD *)&v147[32] = *(_WORD *)&v147[24] + a3;
              unsigned __int8 v150 = *(unsigned char *)(v35 + v36);
              *(_DWORD *)(a1 + 1384) = 0;
              if (*(__int16 *)&v147[34] - *(__int16 *)&v147[26] >= v55)
              {
                int v56 = v55;
                do
                {
                  if (*(unsigned char *)(a1 + 1428)) {
                    goto LABEL_62;
                  }
                  Utf32SymToUtf8Sym(*(_DWORD *)(*(void *)(a1 + 1440) + 4 * (v56 - 1)), v146, 5u);
                  if (v146[0] == v150)
                  {
                    *(void *)(a1 + 1456) = *(void *)(a1 + 176) + (*(_DWORD *)v147 + 1);
                    *(_WORD *)(a1 + 1470) = 1;
                    EXEC_RULE(a1, *(__int16 *)&v147[30], (__int16)(*(_WORD *)&v147[32] + 1), (uint64_t)v147, v57, v58, v59, v60);
                    __int16 v61 = ++*(_WORD *)&v147[32];
                    if (*(_DWORD *)(a1 + 1384) == 1) {
                      goto LABEL_91;
                    }
                  }
                  else
                  {
                    __int16 v61 = ++*(_WORD *)&v147[32];
                  }
                  int v56 = v61;
                }
                while (*(__int16 *)&v147[34] - *(__int16 *)&v147[26] >= v61);
                goto LABEL_62;
              }
            }
          }
          goto LABEL_219;
        case 4u:
          uint64_t v62 = (__int16)v34 - 1;
          if (*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 160) + v62) + 36])
          {
            if (*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 168) + v62) + 36])
            {
              __int16 v63 = *(_WORD *)&v147[34] - *(_WORD *)&v147[26] + 1;
              *(_WORD *)&v147[32] = v63;
              unsigned __int8 v150 = *(unsigned char *)(v35 + v36);
              *(_DWORD *)(a1 + 1384) = 0;
              if (*(__int16 *)&v147[24] + a3 <= v63)
              {
                int v64 = v63;
                do
                {
                  if (*(unsigned char *)(a1 + 1428)) {
                    break;
                  }
                  Utf32SymToUtf8Sym(*(_DWORD *)(*(void *)(a1 + 1440) + 4 * (v64 - 1)), v146, 5u);
                  if (v146[0] == v150)
                  {
                    *(_WORD *)(a1 + 1470) = 1;
                    *(void *)(a1 + 1456) = *(void *)(a1 + 176) + (*(_DWORD *)v147 + 1);
                    EXEC_RULE(a1, *(__int16 *)&v147[30], (__int16)(*(_WORD *)&v147[32] + 1), (uint64_t)v147, v65, v66, v67, v68);
                    __int16 v69 = --*(_WORD *)&v147[32];
                    if (*(_DWORD *)(a1 + 1384) == 1) {
                      goto LABEL_91;
                    }
                  }
                  else
                  {
                    __int16 v69 = --*(_WORD *)&v147[32];
                  }
                  int v64 = v69;
                }
                while (*(__int16 *)&v147[24] + a3 <= v69);
LABEL_62:
                if (*(_DWORD *)(a1 + 1384) == 1) {
                  goto LABEL_91;
                }
              }
            }
          }
          goto LABEL_219;
        case 5u:
          uint64_t v70 = (__int16)v34 - 1;
          if (*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 160) + v70) + 36]
            && *(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 168) + v70) + 36])
          {
            for (__int16 i = *(_WORD *)&v147[24] + a3; ; __int16 i = v148 + *(_WORD *)&v147[32] + 1)
            {
              *(_WORD *)&v147[32] = i;
              if (*(__int16 *)&v147[34] - *(__int16 *)&v147[26] < i || *(unsigned char *)(a1 + 1428)) {
                break;
              }
              unsigned __int16 v148 = 0;
              *(void *)(a1 + 1456) = *(void *)(a1 + 176) + *(unsigned int *)v147;
              *(_WORD *)(a1 + 1470) = 0;
              EXEC_RULE(a1, *(__int16 *)&v147[30], i, (uint64_t)v147, v30, v31, v32, v33);
            }
          }
          goto LABEL_219;
        case 6u:
          uint64_t v72 = (__int16)v34 - 1;
          if (*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 160) + v72) + 36]
            && *(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 168) + v72) + 36])
          {
            for (__int16 j = *(_WORD *)&v147[34] - *(_WORD *)&v147[26]; ; __int16 j = *(_WORD *)&v147[32] - 1)
            {
              *(_WORD *)&v147[32] = j;
              if (*(__int16 *)&v147[24] + a3 > j || *(unsigned char *)(a1 + 1428)) {
                break;
              }
              *(void *)(a1 + 1456) = *(void *)(a1 + 176) + *(unsigned int *)v147;
              *(_WORD *)(a1 + 1470) = 0;
              EXEC_RULE(a1, *(__int16 *)&v147[30], j, (uint64_t)v147, v30, v31, v32, v33);
            }
          }
          goto LABEL_219;
        case 7u:
          uint64_t v74 = (__int16)v34 - 1;
          if (*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 160) + v74) + 36])
          {
            if (*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 168) + v74) + 36])
            {
              __int16 v75 = *(_WORD *)&v147[24] + a3;
              *(_WORD *)&v147[32] = *(_WORD *)&v147[24] + a3;
              *(_DWORD *)(a1 + 1384) = 0;
              if (*(__int16 *)&v147[34] - *(__int16 *)&v147[26] >= v75)
              {
                while (1)
                {
                  int v76 = *(_DWORD *)(a1 + 1384);
                  if (v76) {
                    goto LABEL_90;
                  }
                  if (*(unsigned char *)(a1 + 1428)) {
                    break;
                  }
                  *(void *)(a1 + 1456) = *(void *)(a1 + 176) + *(unsigned int *)v147;
                  *(_WORD *)(a1 + 1470) = 0;
                  EXEC_RULE(a1, *(__int16 *)&v147[30], v75, (uint64_t)v147, v30, v31, v32, v33);
                  __int16 v75 = *(_WORD *)&v147[32] + 1;
                  *(_WORD *)&v147[32] = v75;
                  if (*(__int16 *)&v147[34] - *(__int16 *)&v147[26] < v75) {
                    goto LABEL_89;
                  }
                }
              }
            }
          }
          goto LABEL_219;
        case 8u:
          uint64_t v77 = (__int16)v34 - 1;
          if (!*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 160) + v77) + 36]) {
            goto LABEL_219;
          }
          if (!*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 168) + v77) + 36]) {
            goto LABEL_219;
          }
          __int16 v78 = *(_WORD *)&v147[34] - *(_WORD *)&v147[26];
          *(_WORD *)&v147[32] = *(_WORD *)&v147[34] - *(_WORD *)&v147[26];
          *(_DWORD *)(a1 + 1384) = 0;
          if (*(__int16 *)&v147[24] + a3 > v78) {
            goto LABEL_219;
          }
          while (1)
          {
            int v76 = *(_DWORD *)(a1 + 1384);
            if (v76) {
              break;
            }
            if (*(unsigned char *)(a1 + 1428)) {
              goto LABEL_219;
            }
            *(void *)(a1 + 1456) = *(void *)(a1 + 176) + *(unsigned int *)v147;
            *(_WORD *)(a1 + 1470) = 0;
            EXEC_RULE(a1, *(__int16 *)&v147[30], v78, (uint64_t)v147, v30, v31, v32, v33);
            __int16 v78 = *(_WORD *)&v147[32] - 1;
            *(_WORD *)&v147[32] = v78;
            if (*(__int16 *)&v147[24] + a3 > v78)
            {
LABEL_89:
              int v76 = *(_DWORD *)(a1 + 1384);
              break;
            }
          }
LABEL_90:
          if (v76 == 1)
          {
LABEL_91:
            uint64_t v79 = *(void *)(a1 + 144);
            uint64_t v80 = *(__int16 *)&v147[30];
            goto LABEL_131;
          }
          goto LABEL_219;
        case 9u:
          LODWORD(v149) = 1;
          int v81 = *(unsigned __int16 *)&v147[24] + a3;
          *(_WORD *)&v147[32] = *(_WORD *)&v147[24] + a3;
          __int16 v82 = *(_WORD *)&v147[26];
          if (*(__int16 *)&v147[34] - *(__int16 *)&v147[26] < (__int16)(*(_WORD *)&v147[24] + a3)) {
            goto LABEL_217;
          }
          __int16 v83 = *(_WORD *)&v147[34];
          while (1)
          {
            LOWORD(v84) = *(_WORD *)&v147[30];
            if (*(unsigned char *)(a1 + 1428)) {
              break;
            }
            unsigned __int16 v148 = -2;
            __int16 v85 = *(_WORD *)&v147[30] + *(unsigned __int8 *)(*(__int16 *)&v147[30] + *v28 - 1);
            *(_WORD *)&v147[28] = v85;
            if (*(__int16 *)&v147[30] > v85) {
              goto LABEL_101;
            }
            __int16 v86 = v85;
            do
            {
              uint64_t v87 = (__int16)v84 - 1;
              if (*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 160) + v87) + 36])
              {
                *(void *)(a1 + 1456) = *(void *)(a1 + 176) + *(unsigned int *)(*(void *)(a1 + 112) + 4 * v87);
                *(_WORD *)(a1 + 1470) = 0;
                EXEC_RULE(a1, (__int16)v84, *(__int16 *)&v147[32], (uint64_t)v147, v30, v31, v32, v33);
                __int16 v86 = *(_WORD *)&v147[28];
              }
              int v84 = (__int16)(v84 + 1);
            }
            while (v84 <= v86);
            int v81 = *(unsigned __int16 *)&v147[32];
            __int16 v83 = *(_WORD *)&v147[34];
            __int16 v82 = *(_WORD *)&v147[26];
            if (v148 == 65534) {
LABEL_101:
            }
              int v88 = 1;
            else {
              int v88 = v148 + 1;
            }
            v81 += v88;
            *(_WORD *)&v147[32] = v81;
            if (v83 - v82 < (__int16)v81)
            {
              LOWORD(v34) = *(_WORD *)&v147[30];
              goto LABEL_217;
            }
          }
          LOWORD(v34) = *(_WORD *)&v147[30];
          goto LABEL_217;
        case 0xAu:
          int v89 = *(unsigned __int16 *)&v147[34] - *(unsigned __int16 *)&v147[26];
          *(_WORD *)&v147[32] = *(_WORD *)&v147[34] - *(_WORD *)&v147[26];
          if (*(__int16 *)&v147[24] + a3 > (__int16)(*(_WORD *)&v147[34] - *(_WORD *)&v147[26])) {
            goto LABEL_222;
          }
          __int16 v90 = *(_WORD *)&v147[24];
          while (1)
          {
            LOWORD(v91) = *(_WORD *)&v147[30];
            if (*(unsigned char *)(a1 + 1428)) {
              break;
            }
            __int16 v92 = *(_WORD *)&v147[30] + *(unsigned __int8 *)(*(__int16 *)&v147[30] + *v28 - 1);
            *(_WORD *)&v147[28] = v92;
            if (*(__int16 *)&v147[30] <= v92)
            {
              __int16 v93 = v92;
              do
              {
                if (*(unsigned char *)(a1 + 1428)) {
                  break;
                }
                uint64_t v94 = (__int16)v91 - 1;
                if (*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 160) + v94) + 36])
                {
                  *(void *)(a1 + 1456) = *(void *)(a1 + 176) + *(unsigned int *)(*(void *)(a1 + 112) + 4 * v94);
                  *(_WORD *)(a1 + 1470) = 0;
                  EXEC_RULE(a1, (__int16)v91, *(__int16 *)&v147[32], (uint64_t)v147, v30, v31, v32, v33);
                  __int16 v93 = *(_WORD *)&v147[28];
                }
                int v91 = (__int16)(v91 + 1);
              }
              while (v91 <= v93);
              int v89 = *(unsigned __int16 *)&v147[32];
              __int16 v90 = *(_WORD *)&v147[24];
            }
            *(_WORD *)&v147[32] = --v89;
            if (a3 + v90 > (__int16)v89)
            {
              LOWORD(v34) = *(_WORD *)&v147[30];
              goto LABEL_222;
            }
          }
          LOWORD(v34) = *(_WORD *)&v147[30];
LABEL_222:
          __int16 v131 = v34 + *(unsigned __int8 *)(*v28 + (__int16)v34 - 1);
          goto LABEL_199;
        case 0xBu:
          int v95 = *(unsigned __int16 *)&v147[24] + a3;
          *(_WORD *)&v147[32] = *(_WORD *)&v147[24] + a3;
          *(_DWORD *)(a1 + 1384) = 0;
          __int16 v96 = v34 + *(unsigned __int8 *)(*(void *)(a1 + 152) + (__int16)v34 - 1);
          *(_WORD *)&v147[28] = v96;
          __int16 v97 = *(_WORD *)&v147[34];
          __int16 v98 = *(_WORD *)&v147[26];
          if (*(__int16 *)&v147[34] - *(__int16 *)&v147[26] < (__int16)v95) {
            goto LABEL_129;
          }
          while (!*(_DWORD *)(a1 + 1384))
          {
            if (*(unsigned char *)(a1 + 1428)) {
              goto LABEL_129;
            }
            LOWORD(v99) = *(_WORD *)&v147[30];
            if (*(__int16 *)&v147[30] <= v96)
            {
              do
              {
                if (*(unsigned char *)(a1 + 1428)) {
                  break;
                }
                uint64_t v100 = (__int16)v99 - 1;
                if (*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 160) + v100) + 36])
                {
                  *(void *)(a1 + 1456) = *(void *)(a1 + 176) + *(unsigned int *)(*(void *)(a1 + 112) + 4 * v100);
                  *(_WORD *)(a1 + 1470) = 0;
                  EXEC_RULE(a1, (__int16)v99, *(__int16 *)&v147[32], (uint64_t)v147, v30, v31, v32, v33);
                  __int16 v96 = *(_WORD *)&v147[28];
                }
                int v99 = (__int16)(v99 + 1);
              }
              while (v99 <= v96);
              int v95 = *(unsigned __int16 *)&v147[32];
              __int16 v97 = *(_WORD *)&v147[34];
              __int16 v98 = *(_WORD *)&v147[26];
            }
            *(_WORD *)&v147[32] = ++v95;
            if (v97 - v98 < (__int16)v95) {
              goto LABEL_182;
            }
          }
          goto LABEL_214;
        case 0xCu:
          int v101 = *(unsigned __int16 *)&v147[34] - *(unsigned __int16 *)&v147[26];
          *(_WORD *)&v147[32] = *(_WORD *)&v147[34] - *(_WORD *)&v147[26];
          *(_DWORD *)(a1 + 1384) = 0;
          __int16 v102 = v34 + *(unsigned __int8 *)(*(void *)(a1 + 152) + (__int16)v34 - 1);
          *(_WORD *)&v147[28] = v102;
          __int16 v103 = *(_WORD *)&v147[24];
          if (*(__int16 *)&v147[24] + a3 > (__int16)v101) {
            goto LABEL_129;
          }
          do
          {
            if (*(_DWORD *)(a1 + 1384))
            {
LABEL_214:
              uint64_t v104 = (uint64_t *)(a1 + 144);
              goto LABEL_130;
            }
            if (*(unsigned char *)(a1 + 1428)) {
              goto LABEL_129;
            }
            LOWORD(v124) = *(_WORD *)&v147[30];
            if (*(__int16 *)&v147[30] <= v102)
            {
              do
              {
                if (*(unsigned char *)(a1 + 1428)) {
                  break;
                }
                uint64_t v125 = (__int16)v124 - 1;
                if (*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 160) + v125) + 36])
                {
                  *(void *)(a1 + 1456) = *(void *)(a1 + 176) + *(unsigned int *)(*(void *)(a1 + 112) + 4 * v125);
                  *(_WORD *)(a1 + 1470) = 0;
                  EXEC_RULE(a1, (__int16)v124, *(__int16 *)&v147[32], (uint64_t)v147, v30, v31, v32, v33);
                  __int16 v102 = *(_WORD *)&v147[28];
                }
                int v124 = (__int16)(v124 + 1);
              }
              while (v124 <= v102);
              int v101 = *(unsigned __int16 *)&v147[32];
              __int16 v103 = *(_WORD *)&v147[24];
            }
            *(_WORD *)&v147[32] = --v101;
          }
          while (a3 + v103 <= (__int16)v101);
LABEL_182:
          uint64_t v104 = (uint64_t *)(a1 + 144);
          if (!*(_DWORD *)(a1 + 1384)) {
LABEL_129:
          }
            uint64_t v104 = (uint64_t *)(a1 + 152);
LABEL_130:
          uint64_t v80 = *(__int16 *)&v147[30];
          uint64_t v79 = *v104;
LABEL_131:
          uint64_t v105 = v80 + v79;
          goto LABEL_198;
        case 0xDu:
          LODWORD(v149) = 1;
          __int16 v106 = *(_WORD *)&v147[24] + a3;
          *(_WORD *)&v147[32] = *(_WORD *)&v147[24] + a3;
          do
          {
            if (*(__int16 *)&v147[34] - *(__int16 *)&v147[26] < v106 || *(unsigned char *)(a1 + 1428)) {
              break;
            }
            __int16 v107 = 0;
            unsigned __int16 v148 = -2;
            *(_DWORD *)(a1 + 1384) = 0;
            while (1)
            {
              int v108 = v107;
              uint64_t v109 = (__int16)v34 - 1;
              int v110 = *(_DWORD *)(a1 + 1384);
              BOOL v111 = v108 <= *(unsigned __int8 *)(*(void *)(a1 + 152) + v109) && v110 == 0;
              if (!v111 || *(unsigned char *)(a1 + 1428)) {
                break;
              }
              int v112 = v109 + v108;
              if (*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 160) + v112) + 36])
              {
                *(void *)(a1 + 1456) = *(void *)(a1 + 176) + *(unsigned int *)(*(void *)(a1 + 112) + 4 * v112);
                *(_WORD *)(a1 + 1470) = 0;
                EXEC_RULE(a1, (__int16)(v34 + v108), *(__int16 *)&v147[32], (uint64_t)v147, v30, v31, v32, v33);
                LOWORD(v34) = *(_WORD *)&v147[30];
              }
              __int16 v107 = v108 + 1;
              int v113 = *(__int16 *)(a1 + 44);
              if (v113 < (__int16)v34)
              {
                int v110 = *(_DWORD *)(a1 + 1384);
                goto LABEL_147;
              }
            }
            LOWORD(v113) = *(_WORD *)(a1 + 44);
LABEL_147:
            __int16 v114 = v110 ? v148 + 1 : 1;
            __int16 v106 = v114 + *(_WORD *)&v147[32];
            *(_WORD *)&v147[32] = v106;
          }
          while ((__int16)v34 <= (__int16)v113);
          if (*(__int16 *)(a1 + 44) > (__int16)v34) {
LABEL_217:
          }
            *(_WORD *)&v147[30] = v34 + *(unsigned __int8 *)(*v28 + (__int16)v34 - 1);
          LODWORD(v149) = 0;
          goto LABEL_219;
        case 0xEu:
          *(_WORD *)&v147[32] = *(_WORD *)&v147[34] - *(_WORD *)&v147[26];
          if (*(__int16 *)&v147[24] + a3 > (__int16)(*(_WORD *)&v147[34] - *(_WORD *)&v147[26]))
          {
            LOWORD(v80) = v34;
            goto LABEL_196;
          }
          uint64_t v80 = v34;
          do
          {
            int v126 = *(unsigned __int8 *)(a1 + 1428);
            if (*(unsigned char *)(a1 + 1428)) {
              break;
            }
            __int16 v127 = 0;
            *(_DWORD *)(a1 + 1384) = 0;
            int v128 = (__int16)v34;
            while (1)
            {
              if (*(unsigned char *)(a1 + 1428))
              {
                uint64_t v130 = v34;
                goto LABEL_195;
              }
              int v129 = v128 + v126 - 1;
              if (*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 160) + v129) + 36])
              {
                *(void *)(a1 + 1456) = *(void *)(a1 + 176) + *(unsigned int *)(*(void *)(a1 + 112) + 4 * v129);
                *(_WORD *)(a1 + 1470) = 0;
                EXEC_RULE(a1, (__int16)(v34 + v127), *(__int16 *)&v147[32], (uint64_t)v147, v30, v31, v32, v33);
                uint64_t v80 = *(unsigned __int16 *)&v147[30];
              }
              int v126 = ++v127;
              if (v127 > (int)*(unsigned __int8 *)(*v28 + (__int16)v80 - 1)) {
                break;
              }
              int v128 = (__int16)v80;
              uint64_t v34 = v80;
              uint64_t v130 = v80;
              if (*(_DWORD *)(a1 + 1384)) {
                goto LABEL_195;
              }
            }
            uint64_t v130 = v80;
LABEL_195:
            --*(_WORD *)&v147[32];
            uint64_t v34 = v130;
          }
          while (*(__int16 *)&v147[24] + a3 <= *(__int16 *)&v147[32]);
LABEL_196:
          uint64_t v123 = *v28;
          goto LABEL_197;
        case 0xFu:
          __int16 v115 = *(_WORD *)&v147[24] + a3;
          *(_WORD *)&v147[32] = *(_WORD *)&v147[24] + a3;
          *(_DWORD *)(a1 + 1384) = 0;
          if (*(__int16 *)&v147[34] - *(__int16 *)&v147[26] < v115) {
            goto LABEL_170;
          }
          uint64_t v80 = v34;
          while (!*(_DWORD *)(a1 + 1384))
          {
            int v116 = *(unsigned __int8 *)(a1 + 1428);
            if (*(unsigned char *)(a1 + 1428)) {
              goto LABEL_171;
            }
            __int16 v117 = 0;
            int v118 = (__int16)v34;
            while (!*(_DWORD *)(a1 + 1384) && !*(unsigned char *)(a1 + 1428))
            {
              int v119 = v118 + v116 - 1;
              if (*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 160) + v119) + 36])
              {
                *(void *)(a1 + 1456) = *(void *)(a1 + 176) + *(unsigned int *)(*(void *)(a1 + 112) + 4 * v119);
                *(_WORD *)(a1 + 1470) = 0;
                EXEC_RULE(a1, (__int16)(v34 + v117), *(__int16 *)&v147[32], (uint64_t)v147, v30, v31, v32, v33);
                uint64_t v80 = *(unsigned __int16 *)&v147[30];
              }
              int v116 = ++v117;
              int v118 = (__int16)v80;
              uint64_t v34 = v80;
              uint64_t v120 = v80;
              if (v117 > (int)*(unsigned __int8 *)(*v28 + (__int16)v80 - 1)) {
                goto LABEL_167;
              }
            }
            uint64_t v120 = v34;
LABEL_167:
            ++*(_WORD *)&v147[32];
            uint64_t v34 = v120;
            if (*(__int16 *)&v147[34] - *(__int16 *)&v147[26] < *(__int16 *)&v147[32]) {
              goto LABEL_212;
            }
          }
          goto LABEL_215;
        case 0x10u:
          __int16 v121 = *(_WORD *)&v147[34] - *(_WORD *)&v147[26];
          *(_WORD *)&v147[32] = *(_WORD *)&v147[34] - *(_WORD *)&v147[26];
          *(_DWORD *)(a1 + 1384) = 0;
          if (*(__int16 *)&v147[24] + a3 > v121)
          {
LABEL_170:
            LOWORD(v80) = v34;
            goto LABEL_171;
          }
          uint64_t v80 = v34;
          break;
        default:
          if (v37 == 99)
          {
            uint64_t v46 = *(void *)(a1 + 1504);
            *(void *)&v147[8] = *(void *)(v46 + 8 * *(unsigned __int8 *)(v35 + v36) - 8);
            *(void *)(a1 + 1440) = *(void *)&v147[8];
            unsigned int v47 = v36 + 1;
            *(void *)&v147[16] = *(void *)(v46 + 8 * *(unsigned __int8 *)(v35 + v47) - 8);
            *(void *)(a1 + 1448) = *(void *)&v147[16];
            LOWORD(v46) = *(unsigned __int8 *)(v35 + v47) - 1;
            *(_WORD *)(a1 + 1410) = v46;
            __int16 v151 = v46;
          }
          goto LABEL_219;
      }
      do
      {
        if (*(_DWORD *)(a1 + 1384))
        {
LABEL_215:
          v122 = (uint64_t *)(a1 + 144);
          goto LABEL_172;
        }
        int v132 = *(unsigned __int8 *)(a1 + 1428);
        if (*(unsigned char *)(a1 + 1428)) {
          goto LABEL_171;
        }
        __int16 v133 = 0;
        int v134 = (__int16)v34;
        while (!*(_DWORD *)(a1 + 1384) && !*(unsigned char *)(a1 + 1428))
        {
          int v135 = v134 + v132 - 1;
          if (*(_WORD *)&v147[2 * *(unsigned __int8 *)(*(void *)(a1 + 160) + v135) + 36])
          {
            *(void *)(a1 + 1456) = *(void *)(a1 + 176) + *(unsigned int *)(*(void *)(a1 + 112) + 4 * v135);
            *(_WORD *)(a1 + 1470) = 0;
            EXEC_RULE(a1, (__int16)(v34 + v133), *(__int16 *)&v147[32], (uint64_t)v147, v30, v31, v32, v33);
            uint64_t v80 = *(unsigned __int16 *)&v147[30];
          }
          int v132 = ++v133;
          int v134 = (__int16)v80;
          uint64_t v34 = v80;
          uint64_t v136 = v80;
          if (v133 > (int)*(unsigned __int8 *)(*v28 + (__int16)v80 - 1)) {
            goto LABEL_211;
          }
        }
        uint64_t v136 = v34;
LABEL_211:
        --*(_WORD *)&v147[32];
        uint64_t v34 = v136;
      }
      while (*(__int16 *)&v147[24] + a3 <= *(__int16 *)&v147[32]);
LABEL_212:
      v122 = (uint64_t *)(a1 + 144);
      if (!*(_DWORD *)(a1 + 1384)) {
LABEL_171:
      }
        v122 = (uint64_t *)(a1 + 152);
LABEL_172:
      uint64_t v123 = *v122;
LABEL_197:
      uint64_t v105 = v123 + (__int16)v80;
LABEL_198:
      __int16 v131 = v80 + *(unsigned __int8 *)(v105 - 1);
LABEL_199:
      *(_WORD *)&v147[30] = v131;
LABEL_219:
      LOWORD(v27) = *(_WORD *)&v147[30];
    }
    while (*(__int16 *)&v147[30] < *(__int16 *)(*(void *)(a1 + 72) + 2 * v26));
  }
  uint64_t v137 = *(__int16 *)&v147[34];
  *uint64_t v5 = *(_WORD *)&v147[34];
  uint64_t v138 = a3 - 1;
  if (*(__int16 *)(a1 + 24) >= 1)
  {
    uint64_t v139 = 0;
    do
    {
      uint64_t v140 = *(void *)(*(void *)(a1 + 1504) + 8 * v139);
      memmove((void *)(v140 + 4 * v138), (const void *)(v140 + 4 * a3), 4 * (unsigned __int16)(v137 - a3 + 1));
      ++v139;
    }
    while (v139 < *(__int16 *)(a1 + 24));
  }
  *(unsigned char *)(*(void *)(a1 + 1560) + a3) += *(unsigned char *)(*(void *)(a1 + 1560) + v138);
  *(unsigned char *)(*(void *)(a1 + 1560) + v137 - 1) += *(unsigned char *)(*(void *)(a1 + 1560) + v137);
  memmove((void *)(*(void *)(a1 + 1560) + v138), (const void *)(*(void *)(a1 + 1560) + a3), (unsigned __int16)(v137 - a3));
  *(unsigned char *)(*(void *)(a1 + 1560) + v137 - 1) = 0;
  __int16 v144 = *v5 - 1;
  *uint64_t v5 = v144;
  if (!*(_WORD *)(a1 + 1430) && v144) {
    *(unsigned char *)(*(void *)(a1 + 1560) + v144 - 1) += *(unsigned char *)(*(void *)(a1 + 1560) + v144);
  }
  *(_DWORD *)(a1 + 1432) = 1;
  log_OutText(*(void *)(*(void *)(a1 + 2080) + 32), (uint64_t)"FE_DEPES", 6, 0, (uint64_t)"End gram number %d", v141, v142, v143, a2);
  if (*(unsigned char *)(a1 + 1428)) {
    *uint64_t v5 = a3 - 1;
  }
  return HIDWORD(v149);
}

uint64_t EXEC_RULE(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a3;
  int v292 = a2;
  uint64_t v9 = result;
  LOWORD(v10) = 0;
  unsigned int v12 = *(unsigned __int16 *)(a4 + 34);
  uint64_t v11 = a4 + 34;
  unsigned int v295 = v12;
  *(_WORD *)(result + 1476) = 0;
  uint64_t v13 = (unsigned int **)(result + 2096);
  size_t v14 = (unsigned __int8 *)(result + 1400);
  v293 = (__int16 *)v11;
  __s = (char *)(result + 1484);
  __int16 i = *(char **)(result + 1456);
  while (2)
  {
    switch(*i)
    {
      case 0:
        if (!(_WORD)v8) {
          goto LABEL_431;
        }
        __int16 v190 = *(_WORD *)(a4 + 32);
        *(_WORD *)(v9 + 1474) = v8 - v190;
        *(_WORD *)(v9 + 1468) = -1;
        *(_WORD *)(v9 + 1466) = v190 - 1;
        uint64_t result = CTXT(v9, a2, a3, v11, a5, a6, a7, a8);
        if (!result) {
          goto LABEL_431;
        }
        *(_WORD *)(v9 + 1468) = 1;
        *(_WORD *)(v9 + 1466) = v8;
        uint64_t result = CTXT(v9, v191, v192, v193, v194, v195, v196, v197);
        if (!result) {
          goto LABEL_431;
        }
        int v298 = 0;
        uint64_t v201 = a4;
        uint64_t v202 = *(__int16 *)(a4 + 32);
        __int16 v203 = *(_WORD *)(v9 + 1474);
        uint64_t v204 = (__int16)(v203 + v202);
        *(void *)(v9 + 1448) = *(void *)(a4 + 16);
        *(_DWORD *)(v9 + 1384) = 1;
        *(_WORD *)(v9 + 1410) = *(_WORD *)(a4 + 562);
        LOWORD(v205) = *(_WORD *)(a4 + 34);
        uint64_t v206 = *(void *)(v9 + 1456);
        uint64_t result = v206 + 1;
        *(void *)(v9 + 1456) = v206 + 1;
        int v207 = *(unsigned __int8 *)(v206 + 1);
        uint64_t v287 = v202;
        if (v207 == 22)
        {
          int v210 = *(unsigned __int8 *)(*(void *)(v9 + 136) + v292 - 1);
          if ((int)v204 - (int)v202 <= v210) {
            int v211 = 0;
          }
          else {
            int v211 = v204 - v202 - v210;
          }
          uint64_t result = v206 + 2;
          *(void *)(v9 + 1456) = v206 + 2;
        }
        else
        {
          if (v207 == 1)
          {
            *(void *)(v9 + 1456) = v206 + 2;
            int v208 = *(unsigned __int8 *)(v206 + 2);
            if (v208 == 1)
            {
              __int16 v209 = v203 - 1;
            }
            else if (v208 == 2)
            {
              __int16 v209 = v203 - 1;
              *(_WORD *)(a4 + 32) = **(_WORD **)(v9 + 184);
              *(_WORD *)(a4 + 30) = *(_WORD *)(v9 + 44);
            }
            else
            {
              int v241 = (__int16)(v203 + v202);
              if ((int)v202 < (int)v204)
              {
                do
                {
                  Utf32SymToUtf8Sym(*(_DWORD *)(**(void **)(v9 + 1504) + 4 * v202), v299, 5u);
                  unsigned int v242 = v299[0];
                  if (v299[0])
                  {
                    int v243 = 0;
                    do
                    {
                      --*(_WORD *)(a4 + 2 * v242 + 36);
                      unsigned int v242 = v299[(__int16)++v243];
                    }
                    while (v299[(__int16)v243]);
                  }
                  ++v202;
                }
                while (v202 != v241);
              }
              uint64_t v244 = *(__int16 *)(v9 + 24);
              uint64_t v245 = v241;
              if (v244 <= 0)
              {
                unsigned __int16 v247 = v205 - v241 + 1;
              }
              else
              {
                uint64_t v246 = 0;
                unsigned __int16 v247 = v205 - v241 + 1;
                do
                {
                  uint64_t v248 = *(void *)(v9 + 1416);
                  __int16 v249 = *(_WORD *)(v248 + 2 * v246) - v247;
                  *(_WORD *)(v248 + 2 * v246) = v249;
                  uint64_t v250 = *(void *)(*(void *)(v9 + 1504) + 8 * v246);
                  memmove((void *)(v250 + 4 * v249), (const void *)(v250 + 4 * v241), 4 * v247);
                  ++v246;
                  uint64_t v244 = *(__int16 *)(v9 + 24);
                }
                while (v246 < v244);
              }
              uint64_t v251 = *(void *)(v9 + 1416);
              *(_WORD *)(v251 + 2 * v244) -= v247;
              memmove((void *)(*(void *)(v9 + 1560) + *(__int16 *)(v251 + 2 * *(__int16 *)(v9 + 24))), (const void *)(*(void *)(v9 + 1560) + v241), v247);
              bzero((void *)(*(void *)(v9 + 1560) + v241), v247);
              __int16 *v293 = v241;
              *(_DWORD *)(v9 + 1432) = 0;
              ++*(_WORD *)(v9 + 1430);
              __int16 v252 = *(_WORD *)(v9 + 1476);
              uint64_t v253 = **(unsigned __int8 **)(v9 + 1456) - 1;
              switch(*(unsigned char *)(*(void *)(v9 + 56) + v253))
              {
                case 0:
                  INFERENCE(v9);
                  uint64_t result = 1;
                  break;
                case 1:
                  INFERENCE(v9);
                  uint64_t result = 0;
                  break;
                case 2:
                  uint64_t result = INFERENCE(v9);
                  break;
                case 3:
                  uint64_t result = DCT_LKP(v9, *(void *)(*(void *)(v9 + 1520) + 8 * v253), v287, v293);
                  break;
                default:
                  uint64_t result = pfExt[*(unsigned __int8 *)(*(void *)(v9 + 56) + v253)](v9, v287, v293);
                  break;
              }
              *(_DWORD *)(v9 + 1384) = result;
              *(_WORD *)(v9 + 1476) = v252;
              --*(_WORD *)(v9 + 1430);
              if (*(unsigned __int8 *)(v9 + 1428) == 156)
              {
LABEL_421:
                if (*(unsigned __int8 *)(v9 + 1428) == 156)
                {
                  *(_DWORD *)(v9 + 1384) = 1;
                  *(_WORD *)(v201 + 548) = *(_WORD *)(v201 + 34) - *(_WORD *)(v201 + 32);
                  *(_WORD *)(v201 + 32) = **(_WORD **)(v9 + 184);
                  *(_WORD *)(v201 + 30) = *(_WORD *)(v9 + 44);
                  const char *v13 = 0;
                  v13[1] = 0;
                }
                else
                {
                  int v266 = *(_DWORD *)(v9 + 1384);
                  const char *v13 = 0;
                  v13[1] = 0;
                  if (!v266)
                  {
LABEL_425:
                    uint64_t v267 = *(void *)(v201 + 8);
                    if (*(void *)(v9 + 1440) != v267) {
                      *(void *)(v9 + 1440) = v267;
                    }
                    if (*(__int16 *)(v9 + 2088) >= 6)
                    {
                      int v268 = *(__int16 *)(v9 + 2 * *(__int16 *)(v9 + 1430) + 1568);
                      int v269 = *v293;
                      Utf32LayersToUtf8Layers(v9, *v293);
                      uint64_t result = log_OutText(*(void *)(*(void *)(v9 + 2080) + 32), (uint64_t)"FE_DEPES", 6, 0, (uint64_t)"Rule number %d", v270, v271, v272, (v292 - *(__int16 *)(v9 + 2 * *(__int16 *)(v9 + 1430) + 1824)));
                      if (*(__int16 *)(v9 + 24) >= 1)
                      {
                        uint64_t v273 = 0;
                        do
                        {
                          v274 = *(unsigned __int8 **)(*(void *)(v9 + 1496) + 8 * v273);
                          uint64_t v275 = (uint64_t)&v274[(int)Utf8_LengthInBytes(v274, v268)];
                          v276 = *(unsigned __int8 **)(*(void *)(v9 + 1496) + 8 * v273);
                          unsigned __int8 v277 = v276[(int)Utf8_LengthInBytes(v276, v269)];
                          v278 = *(unsigned __int8 **)(*(void *)(v9 + 1496) + 8 * v273);
                          v278[(int)Utf8_LengthInBytes(v278, v269)] = 0;
                          log_OutText(*(void *)(*(void *)(v9 + 2080) + 32), (uint64_t)"FE_DEPES", 6, 0, (uint64_t)"%s", v279, v280, v281, v275);
                          v282 = *(unsigned __int8 **)(*(void *)(v9 + 1496) + 8 * v273);
                          uint64_t result = Utf8_LengthInBytes(v282, v269);
                          v282[(int)result] = v277;
                          ++v273;
                        }
                        while (v273 < *(__int16 *)(v9 + 24));
                      }
                    }
                    goto LABEL_431;
                  }
                }
                *(_DWORD *)(v201 + 556) = 1;
                goto LABEL_425;
              }
              uint64_t v257 = *v293;
              if (*(_DWORD *)(v9 + 1432))
              {
                uint64_t v258 = v287;
              }
              else
              {
                if (v241 >= (int)v257)
                {
                  __int16 v260 = *v293;
                  LOWORD(v261) = v241;
                  v259 = v293;
                  do
                  {
                    uint64_t v262 = *(void *)(v9 + 1560);
                    if (*(unsigned char *)(v262 + (__int16)v261))
                    {
                      *(unsigned char *)(v257 + v262 - 1) += *(unsigned char *)(v262 + (__int16)v261);
                      __int16 v260 = *v293;
                    }
                    int v261 = (__int16)(v261 - 1);
                    uint64_t v257 = v260;
                  }
                  while (v261 >= v260);
                }
                else
                {
                  v259 = v293;
                }
                *(unsigned char *)(*(void *)(v9 + 1560) + v257) = 0;
                LODWORD(v257) = *v259;
                uint64_t v201 = a4;
                uint64_t v258 = v287;
                if (v241 < (int)v257)
                {
                  do
                  {
                    *(unsigned char *)(*(void *)(v9 + 1560) + v245++) = 0;
                    uint64_t v257 = *v293;
                  }
                  while (v245 < v257);
                  uint64_t v201 = a4;
                  uint64_t v258 = v287;
                }
              }
              if ((int)v258 < (__int16)v257)
              {
                uint64_t v263 = (__int16)v257;
                do
                {
                  Utf32SymToUtf8Sym(*(_DWORD *)(**(void **)(v9 + 1504) + 4 * v258), v299, 5u);
                  unsigned int v264 = v299[0];
                  if (v299[0])
                  {
                    int v265 = 0;
                    do
                    {
                      ++*(_WORD *)(v201 + 2 * v264 + 36);
                      unsigned int v264 = v299[(__int16)++v265];
                    }
                    while (v299[(__int16)v265]);
                  }
                  ++v258;
                }
                while (v258 != v263);
                LOWORD(v257) = *v293;
              }
              if (*(_DWORD *)(v9 + 1384)) {
                __int16 v209 = v257 + *(_WORD *)(v9 + 1476) + ~*(_WORD *)(v201 + 32);
              }
              else {
                __int16 v209 = 0;
              }
              uint64_t result = RESTORE_SUBSTITUTION(v9, (__int16)v257);
              __int16 *v293 = result;
            }
LABEL_418:
            if (!*(_DWORD *)(v201 + 552) || *(__int16 *)(v201 + 548) < v209) {
              *(_WORD *)(v201 + 548) = v209;
            }
            goto LABEL_421;
          }
          int v211 = 0;
        }
        if ((int)v202 < (int)v204)
        {
          do
          {
            Utf32SymToUtf8Sym(*(_DWORD *)(**(void **)(v9 + 1504) + 4 * v202), v299, 5u);
            unsigned int v212 = v299[0];
            if (v299[0])
            {
              int v213 = 0;
              do
              {
                --*(_WORD *)(a4 + 2 * v212 + 36);
                unsigned int v212 = v299[(__int16)++v213];
              }
              while (v299[(__int16)v213]);
            }
            ++v202;
          }
          while (v202 != (int)v204);
          uint64_t result = *(void *)(v9 + 1456);
          uint64_t v202 = v287;
        }
        int v286 = v211 << 16;
        int v290 = (__int16)v211;
        int v214 = v202;
        uint64_t v205 = (unsigned __int16)v205;
        uint64_t v215 = (unsigned __int16)v205;
        uint64_t v216 = v202;
        while (1)
        {
          LOBYTE(v217) = *(unsigned char *)result;
          switch(*(unsigned char *)result)
          {
            case 0:
              if ((__int16)v214 < (__int16)v204) {
                memmove((void *)(*(void *)(v9 + 1448) + 4 * (__int16)v214), (const void *)(*(void *)(v9 + 1448) + 4 * (__int16)v204), 4 * (unsigned __int16)(v215 - v204 + 1));
              }
              uint64_t result = MOVE_FOR_SUBSTITUTION(v9, (__int16)v204, (__int16)v205, (__int16)(v202 - v204));
              if (result)
              {
                *(_WORD *)(v201 + 34) = v202 + v205 - v204;
                __int16 v209 = v202 + ~*(_WORD *)(v201 + 32);
                if ((int)v287 >= (__int16)v202)
                {
                  uint64_t v201 = a4;
                }
                else
                {
                  uint64_t v254 = v287;
                  uint64_t v201 = a4;
                  do
                  {
                    uint64_t result = Utf32SymToUtf8Sym(*(_DWORD *)(**(void **)(v9 + 1504) + 4 * v254), v299, 5u);
                    unsigned int v255 = v299[0];
                    if (v299[0])
                    {
                      int v256 = 0;
                      do
                      {
                        ++*(_WORD *)(a4 + 2 * v255 + 36);
                        unsigned int v255 = v299[(__int16)++v256];
                      }
                      while (v299[(__int16)v256]);
                    }
                    ++v254;
                  }
                  while (v254 != (__int16)v202);
                }
                goto LABEL_418;
              }
              goto LABEL_421;
            case 2:
              uint64_t v291 = v216;
              *(void *)(v9 + 1456) = result + 1;
              int v222 = *(unsigned __int8 *)(result + 1);
              int v223 = *(__int16 *)(v9 + 46);
              if (v222 > v223)
              {
                uint64_t result = log_OutText(*(void *)(*(void *)(v9 + 2080) + 32), (uint64_t)"FE_DEPES", 3, 0, (uint64_t)"warning: pActRule > nr_vars (3)", v198, v199, v200, v285);
                int v222 = **(unsigned __int8 **)(v9 + 1456);
                int v223 = *(__int16 *)(v9 + 46);
              }
              uint64_t v296 = v202;
              unsigned int v288 = v205;
              if (v222 > v223) {
                goto LABEL_366;
              }
              uint64_t v224 = *(void *)(v9 + 1512);
              uint64_t v225 = (5 * v222);
              uint64_t result = strlen((const char *)(v224 + v225));
              if ((int)(result << 16) < 1) {
                goto LABEL_345;
              }
              int v226 = 0;
              int v227 = 0;
              while (2)
              {
                if ((__int16)v214 < (__int16)v204) {
                  goto LABEL_341;
                }
                if ((__int16)v215 + 1 < *(__int16 *)(*(void *)(v9 + 1416) + 2 * *(__int16 *)(v9 + 1410)) - 1)
                {
                  if (*(char *)(v224 + (int)v225 + (uint64_t)v226) >= -64)
                  {
                    uint64_t v228 = *(void *)(v9 + 1448) + 4 * (__int16)v214;
                    memmove((void *)(v228 + 4), (const void *)v228, 4 * (unsigned __int16)(v215 - v214 + 1));
                    uint64_t v215 = (v215 + 1);
                    uint64_t v224 = *(void *)(v9 + 1512);
                    int v222 = **(unsigned __int8 **)(v9 + 1456);
                  }
LABEL_341:
                  uint64_t v225 = 5 * v222;
                  __int16 v229 = (unsigned __int8 *)(v224 + v225 + v226);
                  if ((char)*v229 >= -64)
                  {
                    uint64_t v296 = (v296 + 1);
                    uint64_t v291 = (v291 + 1);
                    FirstUtf8SymToUtf32(v229, &v298);
                    __int16 v230 = v214++;
                    *(_DWORD *)(*(void *)(v9 + 1448) + 4 * v230) = v298;
                    uint64_t v224 = *(void *)(v9 + 1512);
                    int v222 = **(unsigned __int8 **)(v9 + 1456);
                    LODWORD(v225) = 5 * v222;
                  }
                  int v226 = (__int16)++v227;
                  uint64_t result = strlen((const char *)(v224 + v225));
                  if ((__int16)v227 >= (__int16)result)
                  {
                    uint64_t v201 = a4;
LABEL_345:
                    uint64_t v205 = v288;
                    uint64_t v202 = v296;
                    uint64_t v216 = v291;
                    goto LABEL_325;
                  }
                  continue;
                }
                break;
              }
              *(unsigned char *)(v9 + 1428) = -100;
              uint64_t v201 = a4;
              goto LABEL_421;
            case 7:
              *(void *)(v9 + 1456) = result + 1;
              uint64_t result = strlen(__s);
              if ((int)(result << 16) < 1) {
                goto LABEL_325;
              }
              unsigned int v289 = v205;
              __int16 v231 = 0;
              uint64_t v232 = v204;
              do
              {
                if ((__int16)v214 >= (__int16)v204)
                {
                  if ((__int16)v215 + 1 >= *(__int16 *)(*(void *)(v9 + 1416) + 2 * *(__int16 *)(v9 + 1410)) - 1) {
                    goto LABEL_366;
                  }
                  uint64_t v233 = v231;
                  if (*(char *)(v9 + v231 + 1484) >= -64)
                  {
                    uint64_t v234 = *(void *)(v9 + 1448) + 4 * (__int16)v214;
                    memmove((void *)(v234 + 4), (const void *)v234, 4 * (unsigned __int16)(v215 - v214 + 1));
                    uint64_t v215 = (v215 + 1);
                  }
                }
                else
                {
                  uint64_t v233 = v231;
                }
                if (*(char *)(v9 + v233 + 1484) >= -64)
                {
                  uint64_t v202 = (v202 + 1);
                  uint64_t v216 = (v216 + 1);
                  FirstUtf8SymToUtf32((unsigned __int8 *)(v9 + v233 + 1484), &v298);
                  __int16 v235 = v214++;
                  *(_DWORD *)(*(void *)(v9 + 1448) + 4 * v235) = v298;
                }
                uint64_t v204 = v232;
                ++v231;
                uint64_t result = strlen(__s);
              }
              while ((__int16)result > v231);
              goto LABEL_365;
            case 0xE:
            case 0x10:
              *(void *)(v9 + 1456) = result + 1;
              if ((__int16)v214 < (__int16)v216) {
                memmove((void *)(*(void *)(v9 + 1448) + 4 * (__int16)v214), (const void *)(*(void *)(v9 + 1448) + 4 * (__int16)v216), 4 * (unsigned __int16)(v215 - v216 + 1));
              }
              if ((__int16)v202 <= (__int16)v204) {
                goto LABEL_317;
              }
              uint64_t result = MOVE_FOR_SUBSTITUTION(v9, (__int16)v204, (__int16)v205, (__int16)(v202 - v204));
              if (!result) {
                goto LABEL_421;
              }
              uint64_t v205 = (v202 + v205 - v204);
              uint64_t v204 = v202;
LABEL_317:
              uint64_t v218 = *(unsigned __int8 **)(v9 + 1456);
              *(void *)(v9 + 1448) = *(void *)(*(void *)(v9 + 1504) + 8 * *v218 - 8);
              __int16 v219 = *v218 - 1;
              goto LABEL_324;
            case 0xF:
            case 0x11:
              *(void *)(v9 + 1456) = result + 1;
              if ((__int16)v214 < (__int16)v216) {
                memmove((void *)(*(void *)(v9 + 1448) + 4 * (__int16)v214), (const void *)(*(void *)(v9 + 1448) + 4 * (__int16)v216), 4 * (unsigned __int16)(v215 - v216 + 1));
              }
              if ((__int16)v202 <= (__int16)v204) {
                goto LABEL_323;
              }
              uint64_t result = MOVE_FOR_SUBSTITUTION(v9, (__int16)v204, (__int16)v205, (__int16)(v202 - v204));
              if (!result) {
                goto LABEL_421;
              }
              uint64_t v205 = (v202 + v205 - v204);
              __int16 *v293 = v205;
              uint64_t v204 = v202;
LABEL_323:
              *(void *)(v9 + 1448) = *(void *)(v201 + 16);
              __int16 v219 = *(_WORD *)(v201 + 562);
LABEL_324:
              *(_WORD *)(v9 + 1410) = v219;
              int v214 = v202;
              uint64_t v215 = v205;
              uint64_t v216 = v202;
              goto LABEL_325;
            case 0x13:
              if (v286 < 1) {
                goto LABEL_325;
              }
              unsigned int v289 = v205;
              uint64_t v236 = v215;
              int v237 = 0;
              break;
            default:
              int v217 = (char)v217;
              if ((__int16)v214 < (__int16)v204) {
                goto LABEL_330;
              }
              if ((__int16)v215 + 1 >= *(__int16 *)(*(void *)(v9 + 1416) + 2 * *(__int16 *)(v9 + 1410)) - 1) {
                goto LABEL_366;
              }
              if (v217 >= -64)
              {
                uint64_t v220 = *(void *)(v9 + 1448) + 4 * (__int16)v214;
                memmove((void *)(v220 + 4), (const void *)v220, 4 * (unsigned __int16)(v215 - v214 + 1));
                uint64_t v215 = (v215 + 1);
                uint64_t result = *(void *)(v9 + 1456);
                LOBYTE(v217) = *(unsigned char *)result;
LABEL_330:
                if ((char)v217 >= -64)
                {
                  uint64_t v202 = (v202 + 1);
                  uint64_t v216 = (v216 + 1);
                  FirstUtf8SymToUtf32((unsigned __int8 *)result, &v298);
                  __int16 v221 = v214++;
                  *(_DWORD *)(*(void *)(v9 + 1448) + 4 * v221) = v298;
                }
              }
              goto LABEL_325;
          }
          do
          {
            if ((__int16)v214 >= (__int16)v204)
            {
              int v239 = v236;
              if ((__int16)v236 + 1 >= *(__int16 *)(*(void *)(v9 + 1416) + 2 * *(__int16 *)(v9 + 1410)) - 1)
              {
LABEL_366:
                *(unsigned char *)(v9 + 1428) = -100;
                goto LABEL_421;
              }
              uint64_t v238 = (__int16)v214;
              uint64_t v240 = *(void *)(v9 + 1448) + 4 * (__int16)v214;
              uint64_t result = (uint64_t)memmove((void *)(v240 + 4), (const void *)v240, 4 * (unsigned __int16)(v236 - v214 + 1));
              uint64_t v236 = (v239 + 1);
            }
            else
            {
              uint64_t v238 = (__int16)v214;
            }
            uint64_t v202 = (v202 + 1);
            uint64_t v216 = (v216 + 1);
            ++v214;
            *(_DWORD *)(*(void *)(v9 + 1448) + 4 * v238) = 126;
            ++v237;
          }
          while (v290 > (__int16)v237);
          uint64_t v215 = v236;
LABEL_365:
          uint64_t v205 = v289;
LABEL_325:
          uint64_t result = *(void *)(v9 + 1456) + 1;
          *(void *)(v9 + 1456) = result;
        }
      case 2:
        uint64_t v23 = *(void *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          int v24 = v8;
          do
          {
            LODWORD(v8) = v24;
            uint64_t v25 = (__int16)v24;
            int v26 = *(_DWORD *)(v23 + 4 * (__int16)v24);
            v24 += *(unsigned __int16 *)(v9 + 1470);
          }
          while (v26 == 126);
        }
        else
        {
          uint64_t v25 = (__int16)v8;
        }
        uint64_t v80 = (unsigned int *)(v23 + 4 * v25);
        if (*v13 != v80)
        {
          uint64_t result = Utf32SymToUtf8Sym(*v80, v14, 5u);
          int v81 = (_DWORD *)(*(void *)(v9 + 1440) + 4 * v25);
          *(unsigned char *)(v9 + 1405) = *v81 & 0x3F;
          *(void *)(v9 + 2096) = v81;
        }
        int v82 = *v14;
        if (*v14) {
          BOOL v83 = v82 == 31;
        }
        else {
          BOOL v83 = 1;
        }
        if (v83) {
          goto LABEL_431;
        }
        uint64_t v84 = *(void *)(v9 + 1512);
        __int16 v85 = (unsigned __int8 *)(*(void *)(v9 + 1456) + 1);
        *(void *)(v9 + 1456) = v85;
        a2 = *v85;
        __int16 v86 = (unsigned char *)(v84 + 5 * a2);
        if (!*v86)
        {
          uint64_t result = VAR_APPEARENCE(v9, a2);
          if (!result) {
            goto LABEL_431;
          }
          *(_DWORD *)(v9 + 1480) = 1;
          uint64_t result = SETUTF8CHAR((uint64_t)v86, v14);
          __int16 v85 = *(unsigned __int8 **)(v9 + 1456);
LABEL_219:
          *(_WORD *)(v9 + 1470) = 1;
          uint64_t v8 = (v8 + 1);
LABEL_220:
          __int16 i = (char *)(v85 + 1);
          *(void *)(v9 + 1456) = v85 + 1;
          continue;
        }
        uint64_t v87 = 0;
        int v88 = 0;
        while (v82 == v86[v87])
        {
          uint64_t v87 = (__int16)++v88;
          int v82 = v14[(__int16)v88];
          if (!v14[(__int16)v88]) {
            goto LABEL_219;
          }
        }
LABEL_431:
        if (*(_DWORD *)(v9 + 1480))
        {
          if ((*(__int16 *)(v9 + 46) & 0x80000000) == 0)
          {
            int v283 = 0;
            do
            {
              *(unsigned char *)(*(void *)(v9 + 1512) + (__int16)v283) = 0;
              v283 += 5;
            }
            while (5 * *(__int16 *)(v9 + 46) + 5 > (__int16)v283);
          }
          *(_DWORD *)(v9 + 1480) = 0;
        }
        uint64_t v284 = *(void *)(a4 + 8);
        if (*(void *)(v9 + 1440) != v284) {
          *(void *)(v9 + 1440) = v284;
        }
        return result;
      case 3:
        uint64_t v27 = *(void *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            int v28 = v8;
            uint64_t v29 = (__int16)v8;
            int v30 = *(_DWORD *)(v27 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v30 == 126);
          LODWORD(v8) = v28;
        }
        else
        {
          uint64_t v29 = (__int16)v8;
        }
        int v89 = (unsigned int *)(v27 + 4 * v29);
        if (*v13 != v89)
        {
          uint64_t result = Utf32SymToUtf8Sym(*v89, v14, 5u);
          __int16 v90 = (_DWORD *)(*(void *)(v9 + 1440) + 4 * v29);
          *(unsigned char *)(v9 + 1405) = *v90 & 0x3F;
          *(void *)(v9 + 2096) = v90;
        }
        if (*v14) {
          BOOL v91 = *v14 == 31;
        }
        else {
          BOOL v91 = 1;
        }
        if (v91) {
          goto LABEL_431;
        }
        uint64_t v92 = *(void *)(v9 + 2120);
        goto LABEL_97;
      case 4:
        uint64_t v31 = *(void *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            int v32 = v8;
            uint64_t v33 = (__int16)v8;
            int v34 = *(_DWORD *)(v31 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v34 == 126);
          LODWORD(v8) = v32;
        }
        else
        {
          uint64_t v33 = (__int16)v8;
        }
        __int16 v93 = (unsigned int *)(v31 + 4 * v33);
        if (*v13 != v93)
        {
          uint64_t result = Utf32SymToUtf8Sym(*v93, v14, 5u);
          uint64_t v94 = (_DWORD *)(*(void *)(v9 + 1440) + 4 * v33);
          *(unsigned char *)(v9 + 1405) = *v94 & 0x3F;
          *(void *)(v9 + 2096) = v94;
        }
        if (*v14) {
          BOOL v95 = *v14 == 31;
        }
        else {
          BOOL v95 = 1;
        }
        if (v95) {
          goto LABEL_431;
        }
        uint64_t v96 = *(void *)(v9 + 2120);
        goto LABEL_107;
      case 5:
        uint64_t v35 = *(void *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            int v36 = v8;
            uint64_t v37 = (__int16)v8;
            int v38 = *(_DWORD *)(v35 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v38 == 126);
          LODWORD(v8) = v36;
        }
        else
        {
          uint64_t v37 = (__int16)v8;
        }
        __int16 v97 = (unsigned int *)(v35 + 4 * v37);
        if (*v13 != v97)
        {
          uint64_t result = Utf32SymToUtf8Sym(*v97, v14, 5u);
          __int16 v98 = (_DWORD *)(*(void *)(v9 + 1440) + 4 * v37);
          *(unsigned char *)(v9 + 1405) = *v98 & 0x3F;
          *(void *)(v9 + 2096) = v98;
        }
        if (*v14) {
          BOOL v99 = *v14 == 31;
        }
        else {
          BOOL v99 = 1;
        }
        if (v99) {
          goto LABEL_431;
        }
        uint64_t v92 = *(void *)(v9 + 2128);
LABEL_97:
        uint64_t v100 = *(void *)(v9 + 1456);
        *(void *)(v9 + 1456) = v100 + 1;
        uint64_t result = (uint64_t)strstr(*(char **)(*(void *)(v92 + 8 * (*(unsigned char *)(v100 + 1) - 1))+ 8 * *(unsigned __int8 *)(v9 + 1405)), (const char *)v14);
        if (!result) {
          goto LABEL_431;
        }
        goto LABEL_108;
      case 6:
        uint64_t v39 = *(void *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            int v40 = v8;
            uint64_t v41 = (__int16)v8;
            int v42 = *(_DWORD *)(v39 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v42 == 126);
          LODWORD(v8) = v40;
        }
        else
        {
          uint64_t v41 = (__int16)v8;
        }
        int v101 = (unsigned int *)(v39 + 4 * v41);
        if (*v13 != v101)
        {
          uint64_t result = Utf32SymToUtf8Sym(*v101, v14, 5u);
          __int16 v102 = (_DWORD *)(*(void *)(v9 + 1440) + 4 * v41);
          *(unsigned char *)(v9 + 1405) = *v102 & 0x3F;
          *(void *)(v9 + 2096) = v102;
        }
        if (*v14) {
          BOOL v103 = *v14 == 31;
        }
        else {
          BOOL v103 = 1;
        }
        if (v103) {
          goto LABEL_431;
        }
        uint64_t v96 = *(void *)(v9 + 2128);
LABEL_107:
        uint64_t v100 = *(void *)(v9 + 1456);
        *(void *)(v9 + 1456) = v100 + 1;
        uint64_t result = (uint64_t)strstr(*(char **)(*(void *)(v96 + 8 * (*(unsigned char *)(v100 + 1) - 1))+ 8 * *(unsigned __int8 *)(v9 + 1405)), (const char *)v14);
        if (result) {
          goto LABEL_431;
        }
LABEL_108:
        *(_WORD *)(v9 + 1470) = 1;
        uint64_t v8 = (v8 + 1);
        __int16 i = (char *)(v100 + 2);
        *(void *)(v9 + 1456) = v100 + 2;
        continue;
      case 7:
        uint64_t v43 = *(void *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            int v44 = v8;
            uint64_t v45 = (__int16)v8;
            int v46 = *(_DWORD *)(v43 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v46 == 126);
          LODWORD(v8) = v44;
        }
        else
        {
          uint64_t v45 = (__int16)v8;
        }
        uint64_t v104 = (unsigned int *)(v43 + 4 * v45);
        if (*v13 != v104)
        {
          uint64_t result = Utf32SymToUtf8Sym(*v104, v14, 5u);
          uint64_t v105 = (_DWORD *)(*(void *)(v9 + 1440) + 4 * v45);
          *(unsigned char *)(v9 + 1405) = *v105 & 0x3F;
          *(void *)(v9 + 2096) = v105;
        }
        if (*v14) {
          BOOL v106 = *v14 == 31;
        }
        else {
          BOOL v106 = 1;
        }
        if (v106) {
          goto LABEL_431;
        }
        uint64_t v107 = *(void *)(v9 + 1456);
        *(void *)(v9 + 1456) = v107 + 1;
        uint64_t v108 = *(unsigned __int8 *)(v107 + 1);
        uint64_t v109 = v108 - 1;
        uint64_t result = (uint64_t)strstr(*(char **)(*(void *)(*(void *)(v9 + 2128) + 8 * (v108 - 1))+ 8 * *(unsigned __int8 *)(v9 + 1405)), (const char *)v14);
        if (!result) {
          goto LABEL_431;
        }
        uint64_t v110 = *(void *)(v9 + 88);
        uint64_t result = (uint64_t)strstr((char *)(v110 + (v109 << 8)), (const char *)v14);
        if (!result) {
          goto LABEL_431;
        }
        if (v109)
        {
          v108 -= 2;
          BOOL v111 = (unsigned __int8 *)(*(void *)(v9 + 96) + (v109 << 8) + result - (v110 + (v109 << 8)));
        }
        else
        {
          BOOL v111 = (unsigned __int8 *)(*(void *)(v9 + 96)
                                   + ((unint64_t)v109 << 8)
                                   + result
                                   - (v110
                                    + ((unint64_t)v109 << 8)));
        }
        uint64_t result = SETUTF8CHAR((uint64_t)__s, (unsigned __int8 *)(v110 + (v108 << 8) + *v111));
LABEL_126:
        *(_WORD *)(v9 + 1470) = 1;
        uint64_t v8 = (v8 + 1);
        __int16 v85 = *(unsigned __int8 **)(v9 + 1456);
        goto LABEL_220;
      case 8:
        uint64_t v47 = *(void *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            int v48 = v8;
            uint64_t v49 = (__int16)v8;
            int v50 = *(_DWORD *)(v47 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v50 == 126);
          LODWORD(v8) = v48;
        }
        else
        {
          uint64_t v49 = (__int16)v8;
        }
        int v112 = (unsigned int *)(v47 + 4 * v49);
        if (*v13 != v112)
        {
          Utf32SymToUtf8Sym(*v112, v14, 5u);
          int v113 = (_DWORD *)(*(void *)(v9 + 1440) + 4 * v49);
          *(unsigned char *)(v9 + 1405) = *v113 & 0x3F;
          *(void *)(v9 + 2096) = v113;
          __int16 i = *(char **)(v9 + 1456);
        }
        *(void *)(v9 + 1456) = i + 1;
        uint64_t result = CHECK_OF_LIST(v9, 8u, (__int16)v8, v11, a5, a6, a7, a8);
        if (result) {
          goto LABEL_126;
        }
        goto LABEL_431;
      case 11:
        *(_WORD *)(v9 + 1472) = v8;
        uint64_t v51 = *(void *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            __int16 v52 = v8;
            uint64_t v53 = (__int16)v8;
            int v54 = *(_DWORD *)(v51 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v54 == 126);
          LOWORD(v8) = v52;
        }
        else
        {
          uint64_t v53 = (__int16)v8;
        }
        __int16 v114 = (unsigned int *)(v51 + 4 * v53);
        if (*v13 != v114)
        {
          Utf32SymToUtf8Sym(*v114, v14, 5u);
          __int16 v115 = (_DWORD *)(*(void *)(v9 + 1440) + 4 * v53);
          *(unsigned char *)(v9 + 1405) = *v115 & 0x3F;
          *(void *)(v9 + 2096) = v115;
          __int16 i = *(char **)(v9 + 1456);
        }
        int v116 = i[2];
        if (v116 == 220) {
          int v116 = 5000;
        }
        *(_WORD *)(v9 + 1406) = v116;
        if (v116
          && (*(void *)(v9 + 1456) = i + 3, CHECK_OF_LIST(v9, 0xBu, (__int16)v8, v11, a5, a6, a7, a8)))
        {
          LOWORD(v10) = 0;
          do
          {
            uint64_t v118 = *(void *)(v9 + 1456);
            *(_WORD *)(v9 + 1472) = v8 + 1;
            int v119 = TOKEN1(v9, (__int16)(v8 + 1), v117, v11, a5, a6, a7, a8);
            int v10 = (__int16)(v10 + 1);
            if (v10 >= *(__int16 *)(v9 + 1406)) {
              break;
            }
            LOWORD(v8) = v119;
            *(void *)(v9 + 1456) = i + 3;
          }
          while (CHECK_OF_LIST(v9, 0xBu, v119, v11, a5, a6, a7, a8));
        }
        else
        {
          int v10 = 0;
          uint64_t v118 = 0;
        }
        uint64_t result = LOG_WARNING_ON_MAX_NUMBER(v9, v10, 1u, v11, a5, a6, a7, a8);
        if (v10 < i[1]) {
          goto LABEL_431;
        }
        if (v118) {
          *(void *)(v9 + 1456) = v118;
        }
        else {
          uint64_t v118 = *(void *)(v9 + 1456);
        }
        uint64_t v8 = *(unsigned __int16 *)(v9 + 1472);
        for (__int16 i = (char *)(v118 + 1); ; ++i)
        {
          if (*(i - 1) == 11)
          {
            unsigned int v161 = *(i - 2);
            BOOL v162 = v161 > 0x15;
            int v163 = (1 << v161) & 0x20067C;
            if (v162 || v163 == 0) {
              break;
            }
            unsigned int v165 = *(i - 3);
            BOOL v162 = v165 > 0x15;
            int v166 = (1 << v165) & 0x20C67C;
            if (!v162 && v166 != 0) {
              break;
            }
          }
          *(void *)(v9 + 1456) = i;
        }
        goto LABEL_290;
      case 12:
        uint64_t v55 = *(void *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            int v56 = v8;
            uint64_t v57 = (__int16)v8;
            int v58 = *(_DWORD *)(v55 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v58 == 126);
          LODWORD(v8) = v56;
        }
        else
        {
          uint64_t v57 = (__int16)v8;
        }
        uint64_t v120 = (unsigned int *)(v55 + 4 * v57);
        if (*v13 != v120)
        {
          uint64_t result = Utf32SymToUtf8Sym(*v120, v14, 5u);
          __int16 v121 = (_DWORD *)(*(void *)(v9 + 1440) + 4 * v57);
          *(unsigned char *)(v9 + 1405) = *v121 & 0x3F;
          *(void *)(v9 + 2096) = v121;
        }
        int v122 = *v14;
        if (*v14) {
          BOOL v123 = v122 == 31;
        }
        else {
          BOOL v123 = 1;
        }
        if (v123) {
          goto LABEL_431;
        }
        uint64_t v124 = 0;
        int v125 = 0;
        uint64_t v126 = *(void *)(v9 + 1456) + 1;
        *(void *)(v9 + 1456) = v126;
        do
        {
          if (v122 != *(unsigned __int8 *)(v126 + v124)) {
            goto LABEL_431;
          }
          uint64_t v124 = (__int16)++v125;
          int v122 = v14[(__int16)v125];
        }
        while (v14[(__int16)v125]);
        *(_WORD *)(v9 + 1470) = 1;
        uint64_t v8 = (v8 + 1);
        uint64_t result = strlen((const char *)v14);
        __int16 i = (char *)(v126 + result);
        *(void *)(v9 + 1456) = v126 + result;
        continue;
      case 13:
        uint64_t v59 = *(void *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            int v60 = v8;
            uint64_t v61 = (__int16)v8;
            int v62 = *(_DWORD *)(v59 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v62 == 126);
          LODWORD(v8) = v60;
        }
        else
        {
          uint64_t v61 = (__int16)v8;
        }
        __int16 v127 = (unsigned int *)(v59 + 4 * v61);
        if (*v13 != v127)
        {
          uint64_t result = Utf32SymToUtf8Sym(*v127, v14, 5u);
          int v128 = (_DWORD *)(*(void *)(v9 + 1440) + 4 * v61);
          *(unsigned char *)(v9 + 1405) = *v128 & 0x3F;
          *(void *)(v9 + 2096) = v128;
        }
        int v129 = *v14;
        if (*v14) {
          BOOL v130 = v129 == 31;
        }
        else {
          BOOL v130 = 1;
        }
        if (v130) {
          goto LABEL_431;
        }
        uint64_t v131 = 0;
        int v132 = 0;
        uint64_t v133 = *(void *)(v9 + 1456);
        *(void *)(v9 + 1456) = v133 + 1;
        while (v129 == *(unsigned __int8 *)(v133 + 1 + v131))
        {
          uint64_t v131 = (__int16)++v132;
          int v129 = v14[(__int16)v132];
          if (!v14[(__int16)v132]) {
            goto LABEL_431;
          }
        }
        int v134 = (char *)(v133 + 2);
        do
        {
          *(void *)(v9 + 1456) = v134;
          int v135 = *v134++;
        }
        while (v135 < -64);
        *(_WORD *)(v9 + 1470) = 1;
        uint64_t v8 = (v8 + 1);
        __int16 i = v134 - 1;
        continue;
      case 14:
      case 16:
        uint64_t v16 = *(void *)(v9 + 1440);
        *(void *)(v9 + 1368) = v16;
        uint64_t v17 = v16 + 4 * (__int16)v8;
        if (*(void *)(v9 + 2104) == v17)
        {
          uint64_t v8 = *(unsigned __int16 *)(v9 + 2112);
        }
        else
        {
          *(void *)(v9 + 2104) = v17;
          *(_WORD *)(v9 + 2112) = v8;
        }
        uint64_t v18 = *(void *)(*(void *)(v9 + 1504) + 8 * i[1] - 8);
        goto LABEL_52;
      case 15:
      case 17:
        uint64_t v18 = *(void *)(v9 + 1368);
LABEL_52:
        *(void *)(v9 + 1440) = v18;
        *(_WORD *)(v9 + 1470) = 0;
        i += 2;
        *(void *)(v9 + 1456) = i;
        continue;
      case 18:
        *(_WORD *)(v9 + 1472) = v8;
        uint64_t v63 = *(void *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            __int16 v64 = v8;
            uint64_t v65 = (__int16)v8;
            int v66 = *(_DWORD *)(v63 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v66 == 126);
          LOWORD(v8) = v64;
        }
        else
        {
          uint64_t v65 = (__int16)v8;
        }
        uint64_t v136 = (unsigned int *)(v63 + 4 * v65);
        if (*v13 != v136)
        {
          uint64_t result = Utf32SymToUtf8Sym(*v136, v14, 5u);
          uint64_t v137 = (_DWORD *)(*(void *)(v9 + 1440) + 4 * v65);
          *(unsigned char *)(v9 + 1405) = *v137 & 0x3F;
          *(void *)(v9 + 2096) = v137;
          __int16 i = *(char **)(v9 + 1456);
        }
        int v138 = i[2];
        if (v138 == 220) {
          int v138 = 5000;
        }
        *(_WORD *)(v9 + 1406) = v138;
        *(void *)(v9 + 1392) = i + 4;
        switch(i[3])
        {
          case 2:
            LOWORD(v10) = 0;
            if (!v138) {
              goto LABEL_186;
            }
            while (1)
            {
              int v139 = *v14;
              if (*v14) {
                BOOL v140 = v139 == 31;
              }
              else {
                BOOL v140 = 1;
              }
              if (v140) {
                goto LABEL_186;
              }
              uint64_t v141 = *(void *)(v9 + 1512);
              uint64_t v142 = *(unsigned __int8 **)(v9 + 1392);
              uint64_t v143 = *v142;
              __int16 v144 = (unsigned char *)(v141 + 5 * v143);
              if (*v144) {
                break;
              }
              if (VAR_APPEARENCE(v9, v143))
              {
                *(_DWORD *)(v9 + 1480) = 1;
                SETUTF8CHAR(v141 + 5 * *v142, v14);
LABEL_185:
                *(_WORD *)(v9 + 1472) = v8 + 1;
                LOWORD(v8) = TOKEN1(v9, (__int16)(v8 + 1), a3, v11, a5, a6, a7, a8);
                int v10 = (__int16)(v10 + 1);
                if (v10 < *(__int16 *)(v9 + 1406)) {
                  continue;
                }
              }
              goto LABEL_186;
            }
            uint64_t v145 = 0;
            int v146 = 0;
            while (v139 == v144[v145])
            {
              uint64_t v145 = (__int16)++v146;
              int v139 = v14[(__int16)v146];
              if (!v14[(__int16)v146]) {
                goto LABEL_185;
              }
            }
LABEL_186:
            int v147 = (__int16)v10;
            uint64_t v148 = v9;
            unsigned int v149 = 7;
            goto LABEL_286;
          case 3:
            LOWORD(v10) = 0;
            if (v138)
            {
              do
              {
                if (*v14) {
                  BOOL v168 = *v14 == 31;
                }
                else {
                  BOOL v168 = 1;
                }
                if (v168) {
                  break;
                }
                if (!strstr(*(char **)(*(void *)(*(void *)(v9 + 2120)+ 8 * (**(unsigned char **)(v9 + 1392) - 1))+ 8 * *(unsigned __int8 *)(v9 + 1405)), (const char *)v14))break; {
                *(_WORD *)(v9 + 1472) = v8 + 1;
                }
                LOWORD(v8) = TOKEN1(v9, (__int16)(v8 + 1), v169, v11, a5, a6, a7, a8);
                int v10 = (__int16)(v10 + 1);
              }
              while (v10 < *(__int16 *)(v9 + 1406));
            }
            int v147 = (__int16)v10;
            uint64_t v148 = v9;
            unsigned int v149 = 2;
            goto LABEL_286;
          case 4:
            LOWORD(v10) = 0;
            if (v138)
            {
              do
              {
                if (*v14) {
                  BOOL v170 = *v14 == 31;
                }
                else {
                  BOOL v170 = 1;
                }
                if (v170) {
                  break;
                }
                if (strstr(*(char **)(*(void *)(*(void *)(v9 + 2120)+ 8 * (**(unsigned char **)(v9 + 1392) - 1))+ 8 * *(unsigned __int8 *)(v9 + 1405)), (const char *)v14))
                {
                  break;
                }
                *(_WORD *)(v9 + 1472) = v8 + 1;
                LOWORD(v8) = TOKEN1(v9, (__int16)(v8 + 1), v171, v11, a5, a6, a7, a8);
                int v10 = (__int16)(v10 + 1);
              }
              while (v10 < *(__int16 *)(v9 + 1406));
            }
            int v147 = (__int16)v10;
            uint64_t v148 = v9;
            unsigned int v149 = 3;
            goto LABEL_286;
          case 5:
            LOWORD(v10) = 0;
            if (v138)
            {
              do
              {
                if (*v14) {
                  BOOL v172 = *v14 == 31;
                }
                else {
                  BOOL v172 = 1;
                }
                if (v172) {
                  break;
                }
                uint64_t result = (uint64_t)strstr(*(char **)(*(void *)(*(void *)(v9 + 2128)+ 8 * (**(unsigned char **)(v9 + 1392) - 1))+ 8 * *(unsigned __int8 *)(v9 + 1405)), (const char *)v14);
                if (!result) {
                  break;
                }
                *(_WORD *)(v9 + 1472) = v8 + 1;
                uint64_t result = TOKEN1(v9, (__int16)(v8 + 1), a3, v11, a5, a6, a7, a8);
                LOWORD(v8) = result;
                int v10 = (__int16)(v10 + 1);
              }
              while (v10 < *(__int16 *)(v9 + 1406));
            }
            goto LABEL_287;
          case 6:
            LOWORD(v10) = 0;
            if (v138)
            {
              do
              {
                if (*v14) {
                  BOOL v173 = *v14 == 31;
                }
                else {
                  BOOL v173 = 1;
                }
                if (v173) {
                  break;
                }
                if (strstr(*(char **)(*(void *)(*(void *)(v9 + 2128)+ 8 * (**(unsigned char **)(v9 + 1392) - 1))+ 8 * *(unsigned __int8 *)(v9 + 1405)), (const char *)v14))
                {
                  break;
                }
                *(_WORD *)(v9 + 1472) = v8 + 1;
                LOWORD(v8) = TOKEN1(v9, (__int16)(v8 + 1), v174, v11, a5, a6, a7, a8);
                int v10 = (__int16)(v10 + 1);
              }
              while (v10 < *(__int16 *)(v9 + 1406));
            }
            int v147 = (__int16)v10;
            uint64_t v148 = v9;
            unsigned int v149 = 4;
            goto LABEL_286;
          case 12:
            LOWORD(v10) = 0;
            if (!v138) {
              goto LABEL_262;
            }
LABEL_254:
            int v175 = *v14;
            if (*v14) {
              BOOL v176 = v175 == 31;
            }
            else {
              BOOL v176 = 1;
            }
            if (v176) {
              goto LABEL_262;
            }
            uint64_t v177 = 0;
            int v178 = 0;
            while (v175 == *(unsigned __int8 *)(*(void *)(v9 + 1392) + v177))
            {
              uint64_t v177 = (__int16)++v178;
              int v175 = v14[(__int16)v178];
              if (!v14[(__int16)v178])
              {
                *(_WORD *)(v9 + 1472) = v8 + 1;
                LOWORD(v8) = TOKEN1(v9, (__int16)(v8 + 1), a3, v11, a5, a6, a7, a8);
                int v10 = (__int16)(v10 + 1);
                if (v10 < *(__int16 *)(v9 + 1406)) {
                  goto LABEL_254;
                }
                break;
              }
            }
LABEL_262:
            int v147 = (__int16)v10;
            uint64_t v148 = v9;
            unsigned int v149 = 5;
            goto LABEL_286;
          case 13:
            LOWORD(v10) = 0;
            if (!v138) {
              goto LABEL_273;
            }
            do
            {
              int v179 = *v14;
              if (*v14) {
                BOOL v180 = v179 == 31;
              }
              else {
                BOOL v180 = 1;
              }
              if (v180) {
                break;
              }
              uint64_t v181 = 0;
              int v182 = 0;
              while (v179 == *(unsigned __int8 *)(*(void *)(v9 + 1392) + v181))
              {
                uint64_t v181 = (__int16)++v182;
                int v179 = v14[(__int16)v182];
                if (!v14[(__int16)v182]) {
                  goto LABEL_273;
                }
              }
              *(_WORD *)(v9 + 1472) = v8 + 1;
              LOWORD(v8) = TOKEN1(v9, (__int16)(v8 + 1), a3, v11, a5, a6, a7, a8);
              int v10 = (__int16)(v10 + 1);
            }
            while (v10 < *(__int16 *)(v9 + 1406));
LABEL_273:
            int v147 = (__int16)v10;
            uint64_t v148 = v9;
            unsigned int v149 = 6;
            goto LABEL_286;
          case 21:
            LOWORD(v10) = 0;
            if (!v138) {
              goto LABEL_285;
            }
            break;
          default:
            goto LABEL_287;
        }
        do
        {
          int v183 = *v14;
          if (*v14) {
            BOOL v184 = v183 == 31;
          }
          else {
            BOOL v184 = 1;
          }
          if (v184) {
            break;
          }
          v185 = (unsigned char *)(*(void *)(v9 + 1512) + 5 * **(unsigned __int8 **)(v9 + 1392));
          if (*v185)
          {
            uint64_t v186 = 0;
            int v187 = 0;
            while (v183 == v185[v186])
            {
              uint64_t v186 = (__int16)++v187;
              int v183 = v14[(__int16)v187];
              if (!v14[(__int16)v187]) {
                goto LABEL_285;
              }
            }
          }
          *(_WORD *)(v9 + 1472) = v8 + 1;
          LOWORD(v8) = TOKEN1(v9, (__int16)(v8 + 1), a3, v11, a5, a6, a7, a8);
          int v10 = (__int16)(v10 + 1);
        }
        while (v10 < *(__int16 *)(v9 + 1406));
LABEL_285:
        int v147 = (__int16)v10;
        uint64_t v148 = v9;
        unsigned int v149 = 8;
LABEL_286:
        uint64_t result = LOG_WARNING_ON_MAX_NUMBER(v148, v147, v149, v11, a5, a6, a7, a8);
LABEL_287:
        uint64_t v188 = *(void *)(v9 + 1456);
        if (*(unsigned __int8 *)(v188 + 1) > (unsigned __int16)v10) {
          goto LABEL_431;
        }
        uint64_t v8 = *(unsigned __int16 *)(v9 + 1472);
        __int16 i = (char *)(v188 + 5);
        do
        {
          *(void *)(v9 + 1456) = i;
          int v189 = *i++;
        }
        while (v189 < -64);
LABEL_290:
        *(_WORD *)(v9 + 1470) = 1;
        *(void *)(v9 + 1456) = i;
        continue;
      case 19:
        uint64_t v67 = *(void *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            uint64_t v68 = v8;
            uint64_t v69 = (__int16)v8;
            int v70 = *(_DWORD *)(v67 + 4 * (__int16)v8);
            uint64_t v8 = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v70 == 126);
          uint64_t v8 = v68;
        }
        else
        {
          uint64_t v69 = (__int16)v8;
        }
        unsigned __int8 v150 = (unsigned int *)(v67 + 4 * v69);
        if (*v13 != v150)
        {
          uint64_t result = Utf32SymToUtf8Sym(*v150, v14, 5u);
          __int16 v151 = (_DWORD *)(*(void *)(v9 + 1440) + 4 * v69);
          *(unsigned char *)(v9 + 1405) = *v151 & 0x3F;
          *(void *)(v9 + 2096) = v151;
          __int16 i = *(char **)(v9 + 1456);
        }
        *(_WORD *)(v9 + 1470) = 1;
        *(void *)(v9 + 1456) = ++i;
        continue;
      case 20:
        *(_WORD *)(v9 + 1476) = 1;
        *(_WORD *)(v9 + 1470) = 1;
        *(void *)(v9 + 1456) = ++i;
        uint64_t v8 = v295;
        continue;
      case 21:
        uint64_t v71 = *(void *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            int v72 = v8;
            uint64_t v73 = (__int16)v8;
            int v74 = *(_DWORD *)(v71 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v74 == 126);
          LODWORD(v8) = v72;
        }
        else
        {
          uint64_t v73 = (__int16)v8;
        }
        int v152 = (unsigned int *)(v71 + 4 * v73);
        if (*v13 != v152)
        {
          uint64_t result = Utf32SymToUtf8Sym(*v152, v14, 5u);
          size_t v153 = (_DWORD *)(*(void *)(v9 + 1440) + 4 * v73);
          *(unsigned char *)(v9 + 1405) = *v153 & 0x3F;
          *(void *)(v9 + 2096) = v153;
        }
        int v154 = *v14;
        if (*v14) {
          BOOL v155 = v154 == 31;
        }
        else {
          BOOL v155 = 1;
        }
        if (v155) {
          goto LABEL_431;
        }
        uint64_t v156 = *(void *)(v9 + 1512);
        uint64_t v157 = *(void *)(v9 + 1456);
        *(void *)(v9 + 1456) = v157 + 1;
        int v158 = (unsigned char *)(v156 + 5 * *(unsigned __int8 *)(v157 + 1));
        if (!*v158) {
          goto LABEL_203;
        }
        uint64_t v159 = 0;
        int v160 = 0;
        while (v154 == v158[v159])
        {
          uint64_t v159 = (__int16)++v160;
          int v154 = v14[(__int16)v160];
          if (!v14[(__int16)v160]) {
            goto LABEL_431;
          }
        }
LABEL_203:
        *(_WORD *)(v9 + 1470) = 1;
        uint64_t v8 = (v8 + 1);
        __int16 i = (char *)(v157 + 2);
        *(void *)(v9 + 1456) = v157 + 2;
        continue;
      default:
        uint64_t v19 = *(void *)(v9 + 1440);
        if (*(_WORD *)(v9 + 1470))
        {
          do
          {
            int v20 = v8;
            uint64_t v21 = (__int16)v8;
            int v22 = *(_DWORD *)(v19 + 4 * (__int16)v8);
            LODWORD(v8) = v8 + *(unsigned __int16 *)(v9 + 1470);
          }
          while (v22 == 126);
          LODWORD(v8) = v20;
        }
        else
        {
          uint64_t v21 = (__int16)v8;
        }
        __int16 v75 = (unsigned int *)(v19 + 4 * v21);
        if (*v13 != v75)
        {
          uint64_t result = Utf32SymToUtf8Sym(*v75, v14, 5u);
          int v76 = (_DWORD *)(*(void *)(v9 + 1440) + 4 * v21);
          *(unsigned char *)(v9 + 1405) = *v76 & 0x3F;
          *(void *)(v9 + 2096) = v76;
          __int16 i = *(char **)(v9 + 1456);
        }
        int v77 = *v14;
        if (!*v14) {
          goto LABEL_431;
        }
        uint64_t v78 = 0;
        int v79 = 0;
        do
        {
          if (v77 != i[v78]) {
            goto LABEL_431;
          }
          uint64_t v78 = (__int16)++v79;
          int v77 = v14[(__int16)v79];
        }
        while (v14[(__int16)v79]);
        *(_WORD *)(v9 + 1470) = 1;
        uint64_t result = strlen((const char *)v14);
        i += result;
        *(void *)(v9 + 1456) = i;
        uint64_t v8 = (v8 + 1);
        continue;
    }
  }
}

uint64_t INFERENCE_MAIN(uint64_t a1, uint64_t a2, int a3, __int16 *a4)
{
  if (*(__int16 *)(a1 + 24) >= 1)
  {
    uint64_t v8 = 0;
    int v9 = 0;
    int v10 = *a4;
    int v22 = 0;
    int v11 = v10 + 1;
    while (1)
    {
      unsigned int v12 = (unsigned __int16)Utf8_LengthInBytes(*(unsigned __int8 **)(*(void *)(a1 + 1496) + 8 * v8), v11);
      int v13 = utf8_CheckValid(*(void *)(*(void *)(a1 + 1496) + 8 * v8), v12);
      uint64_t v14 = utf8_Utf8ToUtf32_Tolerant(*(void *)(*(void *)(a1 + 1496) + 8 * v8), v12, *(void *)(*(void *)(a1 + 1504) + 8 * v8), **(unsigned __int16 **)(a1 + 184), &v22);
      if ((v14 & 0x80000000) != 0) {
        return v14;
      }
      if (!v13) {
        int v9 = 1;
      }
      if (++v8 >= *(__int16 *)(a1 + 24))
      {
        if (v9) {
          log_OutText(*(void *)(*(void *)(a1 + 2080) + 32), (uint64_t)"FE_DEPES", 1, 0, (uint64_t)"Invalid utf8 layer string found", v15, v16, v17, v21);
        }
        break;
      }
    }
  }
  uint64_t v18 = 2305826816;
  INFERENCE(a1, a2, a3, a4);
  int v19 = *(unsigned __int8 *)(a1 + 1428);
  if (v19 == 155) {
    return 2305826826;
  }
  if (v19 != 156) {
    return Utf32LayersToUtf8Layers(a1, *a4);
  }
  return v18;
}

uint64_t Utf32LayersToUtf8Layers(uint64_t a1, __int16 a2)
{
  if (*(__int16 *)(a1 + 24) < 1) {
    return 0;
  }
  uint64_t v3 = 0;
  int v6 = 0;
  int v4 = (unsigned __int16)(a2 + 1);
  do
  {
    uint64_t result = utf8_Utf32ToUtf8(*(void *)(*(void *)(a1 + 1504) + 8 * v3), v4, *(void *)(*(void *)(a1 + 1496) + 8 * v3), **(unsigned __int16 **)(a1 + 184), &v6);
    if ((result & 0x80000000) != 0) {
      break;
    }
    ++v3;
  }
  while (*(__int16 *)(a1 + 24) > (__int16)v3);
  return result;
}

uint64_t CTXT(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 1456);
  *(void *)(a1 + 1456) = v9 + 1;
  *(_WORD *)(a1 + 1470) = *(_WORD *)(a1 + 1468);
  *(_WORD *)(a1 + 1464) = 0;
  uint64_t result = 1;
  *(_DWORD *)(a1 + 1352) = 1;
  if (*(unsigned char *)(v9 + 1))
  {
    do
    {
      int v11 = CONTEXT_CHOICE(a1, a2, a3, a4, a5, a6, a7, a8);
      if (**(unsigned char **)(a1 + 1456)) {
        BOOL v12 = v11 == 0;
      }
      else {
        BOOL v12 = 1;
      }
    }
    while (!v12);
    if (v11) {
      return 1;
    }
    while (1)
    {
      if (*(__int16 *)(a1 + 1464) < 1) {
        return 0;
      }
      uint64_t v13 = *(unsigned __int16 *)(a1 + 1464);
      *(void *)(a1 + 1456) = *(void *)(a1 + 8 * v13 + 248);
      *(_WORD *)(a1 + 1466) = *(_WORD *)(a1 + 2 * v13 + 648);
      ++*(unsigned char *)(a1 + v13 + 192);
      uint64_t v14 = *(__int16 *)(a1 + 1464);
      __int16 v15 = *(_WORD *)(a1 + 1464);
      uint64_t v16 = a1 + 2 * v14;
      *(_WORD *)(a1 + 1470) = *(_WORD *)(v16 + 748);
      *(void *)(a1 + 1440) = *(void *)(a1 + 8 * v14 + 952);
      int v17 = *(__int16 *)(v16 + 848);
      if (v17 == 10)
      {
        *(_WORD *)(a1 + 1464) = v15 - 1;
        if (!**(unsigned char **)(a1 + 1456)) {
          return 1;
        }
        do
        {
          int v20 = CONTEXT_CHOICE(a1, a2, a3, a4, a5, a6, a7, a8);
          if (**(unsigned char **)(a1 + 1456)) {
            BOOL v22 = v20 == 0;
          }
          else {
            BOOL v22 = 1;
          }
        }
        while (!v22);
        goto LABEL_42;
      }
      if (v17 == 9) {
        break;
      }
      if (v17 == 8)
      {
        unsigned int v18 = *(unsigned __int8 *)(a1 + v14 + 192);
        int v19 = *(unsigned char **)(a1 + 1456);
        if (v18 <= v19[2])
        {
          *(_DWORD *)(a1 + 1352) = 0;
          if (!*v19) {
            return 1;
          }
          do
          {
            int v20 = CONTEXT_CHOICE(a1, a2, a3, a4, a5, a6, a7, a8);
            if (**(unsigned char **)(a1 + 1456)) {
              BOOL v21 = v20 == 0;
            }
            else {
              BOOL v21 = 1;
            }
          }
          while (!v21);
          goto LABEL_42;
        }
LABEL_45:
        *(_WORD *)(a1 + 1464) = v15 - 1;
      }
      else
      {
        int v20 = 0;
LABEL_42:
        if (v20) {
          return 1;
        }
      }
    }
    uint64_t v23 = *(unsigned char **)(a1 + 1456);
    if (*v23 == 9
      && v23[1] != 1
      && (*(v23 - 2) != 9 || *(unsigned __int8 *)(a1 + v14 + 192) - 1 != *(v23 - 1)))
    {
      *(void *)(a1 + 1456) = v23 + 2;
    }
    int v24 = SKIP_DATA(a1, 9, *(unsigned __int8 *)(a1 + v14 + 192));
    uint64_t v25 = *(void *)(a1 + 1456);
    if (v24)
    {
      *(void *)(a1 + 8 * *(__int16 *)(a1 + 1464) + 248) = v25;
      int v26 = (unsigned char *)(*(void *)(a1 + 1456) + 2);
      *(void *)(a1 + 1456) = v26;
      if (!*v26) {
        return 1;
      }
      do
      {
        int v20 = CONTEXT_CHOICE(a1, a2, a3, a4, a5, a6, a7, a8);
        if (**(unsigned char **)(a1 + 1456)) {
          BOOL v27 = v20 == 0;
        }
        else {
          BOOL v27 = 1;
        }
      }
      while (!v27);
      goto LABEL_42;
    }
    *(void *)(a1 + 1456) = v25 + 2;
    __int16 v15 = *(_WORD *)(a1 + 1464);
    goto LABEL_45;
  }
  return result;
}

uint64_t VAR_APPEARENCE(uint64_t a1, unsigned __int16 a2)
{
  uint64_t v2 = *(void *)(a1 + 104);
  uint64_t v3 = a2 - 1;
  int v4 = *(unsigned __int8 *)(v2 + 2 * v3);
  if (v4 == 5)
  {
    uint64_t v5 = *(void *)(a1 + 2128);
LABEL_5:
    uint64_t result = (uint64_t)strstr(*(char **)(*(void *)(v5 + 8 * *(unsigned __int8 *)(v2 + 2 * v3 + 1))+ 8 * *(unsigned __int8 *)(a1 + 1405)), (const char *)(a1 + 1400));
    if (!result) {
      return result;
    }
    return 1;
  }
  if (v4 == 4)
  {
    uint64_t v5 = *(void *)(a1 + 2120);
    goto LABEL_5;
  }
  return 1;
}

uint64_t SETUTF8CHAR(uint64_t result, unsigned __int8 *a2)
{
  uint64_t v2 = result;
  if ((char)*a2 < -64 || (uint64_t result = utf8_determineUTF8CharLength(*a2), (int)(result << 16) < 1))
  {
    uint64_t v4 = 0;
  }
  else
  {
    LOWORD(v4) = 0;
    do
    {
      *(unsigned char *)(v2 + (__int16)v4) = a2[(__int16)v4];
      LOWORD(v4) = v4 + 1;
    }
    while ((__int16)result > (__int16)v4);
    uint64_t v4 = (__int16)v4;
  }
  *(unsigned char *)(v2 + v4) = 0;
  return result;
}

uint64_t CHECK_OF_LIST(uint64_t a1, unsigned __int16 a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)(a1 + 1360) = 0;
  uint64_t v9 = *(char **)(a1 + 1456);
  int v10 = *v9;
  uint64_t result = 1;
  if (v10 != a2)
  {
    int v12 = a2;
    uint64_t v13 = (unsigned char *)(a1 + 1400);
    uint64_t v14 = a3;
    __int16 v15 = "FE_DEPES";
    uint64_t v16 = "warning: pActRule > nr_vars (1)";
LABEL_3:
    int v17 = v9 + 1;
    *(void *)(a1 + 1456) = v9 + 1;
    switch((char)v10)
    {
      case 2:
        signed int v21 = *v17;
        int v22 = *(__int16 *)(a1 + 46);
        if (v21 > v22)
        {
          log_OutText(*(void *)(*(void *)(a1 + 2080) + 32), (uint64_t)v15, 3, 0, (uint64_t)v16, a6, a7, a8, v59);
          int v17 = *(unsigned char **)(a1 + 1456);
          signed int v21 = *v17;
          int v22 = *(__int16 *)(a1 + 46);
        }
        if (v21 > v22) {
          return 0;
        }
        uint64_t v23 = *(void *)(a1 + 1512);
        int v24 = (unsigned char *)(v23 + 5 * v21);
        if (*v24)
        {
          int v25 = *v13;
          if (!*v13) {
            goto LABEL_87;
          }
          uint64_t v26 = 0;
          int v27 = 0;
          do
          {
            if (v25 != v24[v26]) {
              goto LABEL_87;
            }
            uint64_t v26 = (__int16)++v27;
            int v25 = v13[(__int16)v27];
          }
          while (v13[(__int16)v27]);
        }
        else
        {
          if (!VAR_APPEARENCE(a1, v21)) {
            goto LABEL_87;
          }
          *(_DWORD *)(a1 + 1480) = 1;
          SETUTF8CHAR(v23 + 5 * *v17, (unsigned __int8 *)(a1 + 1400));
        }
        goto LABEL_83;
      case 3:
        if (*v13) {
          BOOL v28 = *v13 == 31;
        }
        else {
          BOOL v28 = 1;
        }
        if (v28) {
          goto LABEL_87;
        }
        uint64_t v29 = *(void *)(a1 + 2120);
        goto LABEL_36;
      case 4:
        if (*v13) {
          BOOL v30 = *v13 == 31;
        }
        else {
          BOOL v30 = 1;
        }
        if (v30) {
          goto LABEL_87;
        }
        uint64_t v31 = *(void *)(a1 + 2120);
        goto LABEL_43;
      case 5:
        if (*v13) {
          BOOL v32 = *v13 == 31;
        }
        else {
          BOOL v32 = 1;
        }
        if (v32) {
          goto LABEL_87;
        }
        uint64_t v29 = *(void *)(a1 + 2128);
LABEL_36:
        if (!strstr(*(char **)(*(void *)(v29 + 8 * (*v17 - 1)) + 8 * *(unsigned __int8 *)(a1 + 1405)), (const char *)(a1 + 1400)))goto LABEL_87; {
        goto LABEL_83;
        }
      case 6:
        if (*v13) {
          BOOL v33 = *v13 == 31;
        }
        else {
          BOOL v33 = 1;
        }
        if (v33) {
          goto LABEL_87;
        }
        uint64_t v31 = *(void *)(a1 + 2128);
LABEL_43:
        if (strstr(*(char **)(*(void *)(v31 + 8 * (*v17 - 1)) + 8 * *(unsigned __int8 *)(a1 + 1405)), (const char *)(a1 + 1400)))
        {
          goto LABEL_87;
        }
        goto LABEL_83;
      case 7:
        int v60 = v12;
        uint64_t v34 = v14;
        uint64_t v35 = v16;
        int v36 = v15;
        uint64_t v37 = *v17;
        uint64_t v38 = v37 - 1;
        if (!strstr(*(char **)(*(void *)(*(void *)(a1 + 2128) + 8 * (v37 - 1))+ 8 * *(unsigned __int8 *)(a1 + 1405)), (const char *)(a1 + 1400)))goto LABEL_87; {
        uint64_t v39 = *(void *)(a1 + 88);
        }
        int v40 = strstr((char *)(v39 + (v38 << 8)), (const char *)(a1 + 1400));
        if (!v40 || !*v13 || *v13 == 31) {
          goto LABEL_87;
        }
        if (v38) {
          uint64_t v41 = (unsigned __int8 *)(v39
        }
                                  + (v37 << 8)
                                  + v40[256 * v38 + *(void *)(a1 + 96) - v39 + -256 * v38]
                                  - 512);
        else {
          uint64_t v41 = (unsigned __int8 *)(v39
        }
                                  + (v37 << 8)
                                  + v40[256 * (unint64_t)v38
                                                       + *(void *)(a1 + 96)
                                                       - v39
                                                       + -256 * (unint64_t)v38]);
        SETUTF8CHAR(a1 + 1484, v41);
        __int16 v15 = v36;
        uint64_t v16 = v35;
        uint64_t v14 = v34;
        int v12 = v60;
        goto LABEL_83;
      case 12:
        int v42 = *v13;
        if (*v13) {
          BOOL v43 = v42 == 31;
        }
        else {
          BOOL v43 = 1;
        }
        if (v43) {
          goto LABEL_87;
        }
        uint64_t v44 = 0;
        int v45 = 0;
        do
        {
          if (v42 != v17[v44]) {
            goto LABEL_87;
          }
          uint64_t v44 = (__int16)++v45;
          int v42 = v13[(__int16)v45];
        }
        while (v13[(__int16)v45]);
        uint64_t v9 = &v17[strlen((const char *)(a1 + 1400))];
        goto LABEL_84;
      case 13:
        int v46 = *v13;
        if (*v13) {
          BOOL v47 = v46 == 31;
        }
        else {
          BOOL v47 = 1;
        }
        if (v47) {
          goto LABEL_87;
        }
        uint64_t v48 = 0;
        int v49 = 0;
        while (v46 == v17[v48])
        {
          uint64_t v48 = (__int16)++v49;
          int v46 = v13[(__int16)v49];
          if (!v13[(__int16)v49]) {
            goto LABEL_87;
          }
        }
        int v56 = v9 + 2;
        do
        {
          *(void *)(a1 + 1456) = v56;
          int v57 = *v56++;
        }
        while (v57 <= -65);
        uint64_t v9 = v56 - 1;
        goto LABEL_85;
      case 14:
      case 16:
        *(void *)(a1 + 1360) = *(void *)(a1 + 1440);
        uint64_t v18 = *(void *)(*(void *)(a1 + 1504) + 8 * *v17 - 8);
        *(void *)(a1 + 1440) = v18;
        goto LABEL_7;
      case 15:
      case 17:
        uint64_t v18 = *(void *)(a1 + 1360);
        if (!v18) {
          return 0;
        }
        *(void *)(a1 + 1440) = v18;
        *(void *)(a1 + 1360) = 0;
LABEL_7:
        int v19 = (unsigned int *)(v18 + 4 * v14);
        if (*(unsigned int **)(a1 + 2096) != v19)
        {
          Utf32SymToUtf8Sym(*v19, (unsigned char *)(a1 + 1400), 5u);
          int v20 = (_DWORD *)(*(void *)(a1 + 1440) + 4 * v14);
          *(unsigned char *)(a1 + 1405) = *v20 & 0x3F;
          *(void *)(a1 + 2096) = v20;
        }
        uint64_t result = 0;
        if (!*v13 || *v13 == 31) {
          return result;
        }
        goto LABEL_83;
      case 21:
        signed int v50 = *v17;
        int v51 = *(__int16 *)(a1 + 46);
        if (v50 > v51)
        {
          log_OutText(*(void *)(*(void *)(a1 + 2080) + 32), (uint64_t)v15, 3, 0, (uint64_t)"warning: pActRule > nr_vars (2)", a6, a7, a8, v59);
          signed int v50 = **(unsigned __int8 **)(a1 + 1456);
          int v51 = *(__int16 *)(a1 + 46);
        }
        if (v50 > v51) {
          return 0;
        }
        __int16 v52 = (unsigned char *)(*(void *)(a1 + 1512) + 5 * v50);
        if (!*v52) {
          goto LABEL_83;
        }
        int v53 = *v13;
        if (!*v13) {
          goto LABEL_83;
        }
        uint64_t v54 = 0;
        int v55 = 0;
        break;
      default:
        goto LABEL_83;
    }
    do
    {
      if (v53 != v52[v54])
      {
LABEL_83:
        uint64_t v9 = (char *)(*(void *)(a1 + 1456) + 1);
LABEL_84:
        *(void *)(a1 + 1456) = v9;
LABEL_85:
        int v10 = *v9;
        if (v10 == v12) {
          return 1;
        }
        goto LABEL_3;
      }
      uint64_t v54 = (__int16)++v55;
      int v53 = v13[(__int16)v55];
    }
    while (v13[(__int16)v55]);
LABEL_87:
    uint64_t v58 = *(void *)(a1 + 1360);
    if (v58)
    {
      uint64_t result = 0;
      *(void *)(a1 + 1440) = v58;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t TOKEN1(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (a2 < 0) {
    log_OutText(*(void *)(*(void *)(a1 + 2080) + 32), (uint64_t)"FE_DEPES", 3, 0, (uint64_t)"warning: nr < 0 (2)", a6, a7, a8, v15);
  }
  uint64_t v10 = *(void *)(a1 + 1440);
  do
  {
    uint64_t v11 = (__int16)v8;
    unsigned int v12 = *(_DWORD *)(v10 + 4 * (__int16)v8++);
  }
  while (v12 == 126);
  if (*(void *)(a1 + 2096) != v10 + 4 * v11)
  {
    Utf32SymToUtf8Sym(v12, (unsigned char *)(a1 + 1400), 5u);
    uint64_t v13 = (_DWORD *)(*(void *)(a1 + 1440) + 4 * v11);
    *(unsigned char *)(a1 + 1405) = *v13 & 0x3F;
    *(void *)(a1 + 2096) = v13;
  }
  return v11;
}

uint64_t LOG_WARNING_ON_MAX_NUMBER(uint64_t result, int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 >= 5000 && *(__int16 *)(result + 2088) >= 3) {
    return log_OutText(*(void *)(*(void *)(result + 2080) + 32), (uint64_t)"FE_DEPES", 3, 0, (uint64_t)"warning: number of iterations >= MAX_NUMBER_UPPER_BOUND, output might be incorrect (%u)", a6, a7, a8, a3);
  }
  return result;
}

uint64_t CONTEXT_CHOICE(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(unsigned char **)(a1 + 1456);
  switch(*v9)
  {
    case 2:
      int v12 = *(__int16 *)(a1 + 1466);
      if (v12 < 0) {
        return 0;
      }
      __int16 v13 = TOKEN(a1, v12, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      uint64_t v14 = 0;
      *(_WORD *)(a1 + 1466) = v13;
      uint64_t v15 = *(void *)(a1 + 1456);
      *(void *)(a1 + 1456) = v15 + 1;
      uint64_t v16 = *(unsigned __int8 *)(v15 + 1);
      __int16 v17 = *(_WORD *)(a1 + 1468);
      *(_WORD *)(a1 + 1470) = v17;
      *(void *)(a1 + 1456) = v15 + 2;
      *(_WORD *)(a1 + 1466) = v17 + v13;
      int v18 = *(unsigned __int8 *)(a1 + 1400);
      if (!*(unsigned char *)(a1 + 1400) || v18 == 31) {
        return v14;
      }
      uint64_t v19 = a1 + 1400;
      int v20 = (unsigned char *)(*(void *)(a1 + 1512) + 5 * v16);
      if (*v20)
      {
        uint64_t v21 = 0;
        int v22 = 0;
        uint64_t v14 = 1;
        do
        {
          if (v18 != v20[v21]) {
            return 0;
          }
          uint64_t v21 = (__int16)++v22;
          int v18 = *(unsigned __int8 *)(v19 + (__int16)v22);
        }
        while (*(unsigned char *)(v19 + (__int16)v22));
      }
      else
      {
        if (!VAR_APPEARENCE(a1, v16)) {
          return 0;
        }
        uint64_t v14 = 1;
        *(_DWORD *)(a1 + 1480) = 1;
        SETUTF8CHAR((uint64_t)v20, (unsigned __int8 *)(a1 + 1400));
      }
      return v14;
    case 3:
      int v23 = *(__int16 *)(a1 + 1466);
      if (v23 < 0) {
        return 0;
      }
      __int16 v24 = TOKEN(a1, v23, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      uint64_t v14 = 0;
      *(_WORD *)(a1 + 1466) = v24;
      uint64_t v25 = *(void *)(a1 + 1456);
      *(void *)(a1 + 1456) = v25 + 1;
      char v26 = *(unsigned char *)(v25 + 1);
      __int16 v27 = *(_WORD *)(a1 + 1468);
      *(_WORD *)(a1 + 1470) = v27;
      *(void *)(a1 + 1456) = v25 + 2;
      *(_WORD *)(a1 + 1466) = v27 + v24;
      if (!*(unsigned char *)(a1 + 1400) || *(unsigned char *)(a1 + 1400) == 31) {
        return v14;
      }
      BOOL v28 = (const char *)(a1 + 1400);
      uint64_t v29 = *(void *)(a1 + 2120);
      return strstr(*(char **)(*(void *)(v29 + 8 * (v26 - 1)) + 8 * *(unsigned __int8 *)(a1 + 1405)), v28) != 0;
    case 4:
      int v30 = *(__int16 *)(a1 + 1466);
      if (v30 < 0) {
        return 0;
      }
      __int16 v31 = TOKEN(a1, v30, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      uint64_t v14 = 0;
      *(_WORD *)(a1 + 1466) = v31;
      uint64_t v32 = *(void *)(a1 + 1456);
      *(void *)(a1 + 1456) = v32 + 1;
      char v33 = *(unsigned char *)(v32 + 1);
      __int16 v34 = *(_WORD *)(a1 + 1468);
      *(_WORD *)(a1 + 1470) = v34;
      *(void *)(a1 + 1456) = v32 + 2;
      *(_WORD *)(a1 + 1466) = v34 + v31;
      if (!*(unsigned char *)(a1 + 1400) || *(unsigned char *)(a1 + 1400) == 31) {
        return v14;
      }
      uint64_t v35 = (const char *)(a1 + 1400);
      uint64_t v36 = *(void *)(a1 + 2120);
      return strstr(*(char **)(*(void *)(v36 + 8 * (v33 - 1)) + 8 * *(unsigned __int8 *)(a1 + 1405)), v35) == 0;
    case 5:
      int v37 = *(__int16 *)(a1 + 1466);
      if (v37 < 0) {
        return 0;
      }
      __int16 v38 = TOKEN(a1, v37, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      uint64_t v14 = 0;
      *(_WORD *)(a1 + 1466) = v38;
      uint64_t v39 = *(void *)(a1 + 1456);
      *(void *)(a1 + 1456) = v39 + 1;
      char v26 = *(unsigned char *)(v39 + 1);
      __int16 v40 = *(_WORD *)(a1 + 1468);
      *(_WORD *)(a1 + 1470) = v40;
      *(void *)(a1 + 1456) = v39 + 2;
      *(_WORD *)(a1 + 1466) = v40 + v38;
      if (!*(unsigned char *)(a1 + 1400) || *(unsigned char *)(a1 + 1400) == 31) {
        return v14;
      }
      BOOL v28 = (const char *)(a1 + 1400);
      uint64_t v29 = *(void *)(a1 + 2128);
      return strstr(*(char **)(*(void *)(v29 + 8 * (v26 - 1)) + 8 * *(unsigned __int8 *)(a1 + 1405)), v28) != 0;
    case 6:
      int v41 = *(__int16 *)(a1 + 1466);
      if (v41 < 0) {
        return 0;
      }
      __int16 v42 = TOKEN(a1, v41, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      uint64_t v14 = 0;
      *(_WORD *)(a1 + 1466) = v42;
      uint64_t v43 = *(void *)(a1 + 1456);
      *(void *)(a1 + 1456) = v43 + 1;
      char v33 = *(unsigned char *)(v43 + 1);
      __int16 v44 = *(_WORD *)(a1 + 1468);
      *(_WORD *)(a1 + 1470) = v44;
      *(void *)(a1 + 1456) = v43 + 2;
      *(_WORD *)(a1 + 1466) = v44 + v42;
      if (!*(unsigned char *)(a1 + 1400) || *(unsigned char *)(a1 + 1400) == 31) {
        return v14;
      }
      uint64_t v35 = (const char *)(a1 + 1400);
      uint64_t v36 = *(void *)(a1 + 2128);
      return strstr(*(char **)(*(void *)(v36 + 8 * (v33 - 1)) + 8 * *(unsigned __int8 *)(a1 + 1405)), v35) == 0;
    case 8:
      *(void *)(a1 + 1456) = v9 + 3;
      if (*(_DWORD *)(a1 + 1352))
      {
        __int16 v53 = *(_WORD *)(a1 + 1464) + 1;
        *(_WORD *)(a1 + 1464) = v53;
        *(_WORD *)(a1 + 2 * v53 + 848) = 8;
        uint64_t v54 = *(__int16 *)(a1 + 1464);
        *(void *)(a1 + 8 * v54 + 952) = *(void *)(a1 + 1440);
        *(void *)(a1 + 248 + 8 * v54) = *(void *)(a1 + 1456) - 3;
        *(unsigned char *)(a1 + 192 + v54) = 0;
        uint64_t v55 = *(__int16 *)(a1 + 1464);
        if (*(unsigned __int8 *)(a1 + 192 + v55) >= *(unsigned __int8 *)(*(void *)(a1 + 248 + 8 * v55)
                                                                                      + 1))
        {
          __int16 v63 = *(_WORD *)(a1 + 1470);
          uint64_t v14 = 1;
          BOOL v64 = 1;
        }
        else
        {
          __int16 v56 = *(_WORD *)(a1 + 1466);
          do
          {
            if (v56 < 0) {
              return 0;
            }
            *(_WORD *)(a1 + 1466) = TOKEN(a1, v56, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
            ++*(unsigned char *)(a1 + 192 + *(__int16 *)(a1 + 1464));
            *(void *)(a1 + 1456) = *(void *)(a1 + 248 + 8 * *(__int16 *)(a1 + 1464)) + 3;
            uint64_t v62 = CHECK_OF_LIST(a1, 8u, *(__int16 *)(a1 + 1466), v57, v58, v59, v60, v61);
            __int16 v63 = *(_WORD *)(a1 + 1468);
            *(_WORD *)(a1 + 1470) = v63;
            __int16 v56 = *(_WORD *)(a1 + 1466) + v63;
            *(_WORD *)(a1 + 1466) = v56;
            uint64_t v55 = *(__int16 *)(a1 + 1464);
            BOOL v64 = v62 != 0;
          }
          while (*(unsigned __int8 *)(a1 + 192 + v55) < *(unsigned __int8 *)(*(void *)(a1 + 248 + 8 * v55)
                                                                                          + 1)
               && v62 != 0);
          uint64_t v14 = v62;
        }
        *(_WORD *)(a1 + 2 * v55 + 748) = v63;
        uint64_t v148 = *(__int16 *)(a1 + 1464);
        if (!*(unsigned char *)(a1 + v148 + 192))
        {
          unsigned int v149 = *(unsigned char **)(a1 + 1456);
          if (*v149 != 8)
          {
            unsigned __int8 v150 = v149 + 1;
            do
            {
              *(void *)(a1 + 1456) = v150;
              int v151 = *v150++;
            }
            while (v151 != 8);
          }
        }
        *(_WORD *)(a1 + 2 * v148 + 648) = *(_WORD *)(a1 + 1466);
        if (!v64) {
LABEL_117:
        }
          --*(_WORD *)(a1 + 1464);
      }
      else
      {
        int v139 = *(__int16 *)(a1 + 1466);
        if (v139 < 0) {
          return 0;
        }
        int v140 = TOKEN(a1, v139, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
        *(_WORD *)(a1 + 1466) = v140;
        *(_DWORD *)(a1 + 1352) = 1;
        uint64_t v14 = CHECK_OF_LIST(a1, 8u, v140, v141, v142, v143, v144, v145);
        *(_WORD *)(a1 + 2 * *(__int16 *)(a1 + 1464) + 748) = *(_WORD *)(a1 + 1468);
        __int16 v146 = *(_WORD *)(a1 + 1468);
        *(_WORD *)(a1 + 1470) = v146;
        __int16 v147 = *(_WORD *)(a1 + 1466) + v146;
        *(_WORD *)(a1 + 1466) = v147;
        *(_WORD *)(a1 + 2 * *(__int16 *)(a1 + 1464) + 648) = v147;
        if (!v14) {
          goto LABEL_117;
        }
      }
      ++*(void *)(a1 + 1456);
      return v14;
    case 9:
      uint64_t v66 = (uint64_t)(v9 + 1);
      *(void *)(a1 + 1456) = v9 + 1;
      int v67 = v9[1];
      if (v67)
      {
        if (v67 == 1)
        {
          __int16 v68 = *(_WORD *)(a1 + 1464) + 1;
          *(_WORD *)(a1 + 1464) = v68;
          *(_WORD *)(a1 + 2 * v68 + 748) = *(_WORD *)(a1 + 1470);
          uint64_t v69 = *(__int16 *)(a1 + 1464);
          *(void *)(a1 + 8 * v69 + 952) = *(void *)(a1 + 1440);
          *(_WORD *)(a1 + 2 * v69 + 848) = 9;
          *(_WORD *)(a1 + 2 * *(__int16 *)(a1 + 1464) + 648) = *(_WORD *)(a1 + 1466);
          *(unsigned char *)(a1 + *(__int16 *)(a1 + 1464) + 192) = **(unsigned char **)(a1 + 1456);
          *(void *)(a1 + 8 * *(__int16 *)(a1 + 1464) + 248) = *(void *)(a1 + 1456) + 1;
          uint64_t v66 = *(void *)(a1 + 1456);
        }
        else
        {
          SKIP_DATA(a1, 9, 0);
          uint64_t v66 = *(void *)(a1 + 1456) + 1;
        }
      }
      goto LABEL_237;
    case 0xA:
      *(void *)(a1 + 1456) = v9 + 1;
      if (v9[1])
      {
        __int16 v70 = *(_WORD *)(a1 + 1464) + 1;
        *(_WORD *)(a1 + 1464) = v70;
        *(_WORD *)(a1 + 2 * v70 + 748) = *(_WORD *)(a1 + 1470);
        uint64_t v71 = *(__int16 *)(a1 + 1464);
        *(void *)(a1 + 8 * v71 + 952) = *(void *)(a1 + 1440);
        *(_WORD *)(a1 + 2 * v71 + 848) = 10;
        *(_WORD *)(a1 + 2 * *(__int16 *)(a1 + 1464) + 648) = *(_WORD *)(a1 + 1466);
        uint64_t v72 = *(__int16 *)(a1 + 1464);
        *(void *)(a1 + 8 * v72 + 248) = *(void *)(a1 + 1456) + 1;
        *(unsigned char *)(a1 + v72 + 192) = 0;
        SKIP_DATA(a1, 10, 0);
        uint64_t v9 = *(unsigned char **)(a1 + 1456);
      }
      goto LABEL_5;
    case 0xB:
      int v73 = *(__int16 *)(a1 + 1466);
      *(_WORD *)(a1 + 1472) = *(_WORD *)(a1 + 1466);
      if (v73 < 0) {
        return 0;
      }
      int v74 = TOKEN(a1, v73, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      *(_WORD *)(a1 + 1466) = v74;
      uint64_t v80 = *(void *)(a1 + 1456);
      int v81 = *(unsigned __int8 *)(v80 + 2);
      if (v81 == 220) {
        int v81 = 5000;
      }
      *(_WORD *)(a1 + 1406) = v81;
      if (v81
        && (*(void *)(a1 + 1456) = v80 + 3, CHECK_OF_LIST(a1, 0xBu, v74, v75, v76, v77, v78, v79)))
      {
        LOWORD(v82) = 0;
        do
        {
          uint64_t v83 = *(void *)(a1 + 1456);
          __int16 v84 = *(_WORD *)(a1 + 1468);
          __int16 v85 = v84 + *(_WORD *)(a1 + 1466);
          *(_WORD *)(a1 + 1466) = v85;
          *(_WORD *)(a1 + 1472) = v85;
          if (v85 < 0) {
            return 0;
          }
          int v86 = TOKEN(a1, v85, v84, v75, v76, v77, v78, v79);
          *(_WORD *)(a1 + 1466) = v86;
          int v82 = (__int16)(v82 + 1);
          if (v82 >= *(__int16 *)(a1 + 1406)) {
            break;
          }
          *(void *)(a1 + 1456) = v80 + 3;
        }
        while (CHECK_OF_LIST(a1, 0xBu, v86, v75, v76, v77, v78, v79));
      }
      else
      {
        int v82 = 0;
        uint64_t v83 = 0;
      }
      LOG_WARNING_ON_MAX_NUMBER(a1, v82, 9u, v75, v76, v77, v78, v79);
      *(_WORD *)(a1 + 1466) = *(_WORD *)(a1 + 1472);
      if (v83) {
        *(void *)(a1 + 1456) = v83;
      }
      else {
        uint64_t v83 = *(void *)(a1 + 1456);
      }
      for (uint64_t i = v83 + 1; ; ++i)
      {
        if (*(unsigned char *)(i - 1) == 11)
        {
          unsigned int v158 = *(unsigned __int8 *)(i - 2);
          BOOL v159 = v158 > 0x15;
          int v160 = (1 << v158) & 0x20067C;
          if (v159 || v160 == 0) {
            break;
          }
          unsigned int v162 = *(unsigned __int8 *)(i - 3);
          BOOL v159 = v162 > 0x15;
          int v163 = (1 << v162) & 0x20C67C;
          if (!v159 && v163 != 0) {
            break;
          }
        }
        *(void *)(a1 + 1456) = i;
      }
      *(_WORD *)(a1 + 1470) = *(_WORD *)(a1 + 1468);
      *(void *)(a1 + 1456) = i;
      return v82 >= *(unsigned __int8 *)(v80 + 1);
    case 0xC:
      int v87 = *(__int16 *)(a1 + 1466);
      if (v87 < 0) {
        return 0;
      }
      __int16 v88 = TOKEN(a1, v87, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      uint64_t v89 = *(void *)(a1 + 1456);
      __int16 v90 = *(_WORD *)(a1 + 1468);
      *(_WORD *)(a1 + 1470) = v90;
      *(_WORD *)(a1 + 1466) = v90 + v88;
      *(void *)(a1 + 1456) = v89 + 2;
      int v91 = *(unsigned __int8 *)(a1 + 1400);
      if (*(unsigned char *)(a1 + 1400))
      {
        uint64_t v92 = 0;
        int v93 = 0;
        uint64_t v94 = a1 + 1400;
        int v95 = *(unsigned __int8 *)(a1 + 1400);
        do
        {
          BOOL v96 = v95 == *(unsigned __int8 *)(v89 + 1 + v92);
          if (v95 != *(unsigned __int8 *)(v89 + 1 + v92)) {
            break;
          }
          uint64_t v92 = (__int16)++v93;
          int v95 = *(unsigned __int8 *)(v94 + (__int16)v93);
        }
        while (*(unsigned char *)(v94 + (__int16)v93));
      }
      else
      {
        BOOL v96 = 0;
      }
      if (*(char *)(v89 + 2) <= -65)
      {
        int v152 = (char *)(v89 + 3);
        do
        {
          *(void *)(a1 + 1456) = v152;
          int v153 = *v152++;
        }
        while (v153 < -64);
      }
      if (v91) {
        unsigned int v154 = v96;
      }
      else {
        unsigned int v154 = 0;
      }
      goto LABEL_132;
    case 0xD:
      int v97 = *(__int16 *)(a1 + 1466);
      if (v97 < 0) {
        return 0;
      }
      __int16 v98 = TOKEN(a1, v97, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      uint64_t v99 = *(void *)(a1 + 1456);
      __int16 v100 = *(_WORD *)(a1 + 1468);
      *(_WORD *)(a1 + 1470) = v100;
      *(_WORD *)(a1 + 1466) = v100 + v98;
      *(void *)(a1 + 1456) = v99 + 2;
      int v91 = *(unsigned __int8 *)(a1 + 1400);
      if (*(unsigned char *)(a1 + 1400))
      {
        uint64_t v101 = 0;
        int v102 = 0;
        uint64_t v103 = a1 + 1400;
        int v104 = *(unsigned __int8 *)(a1 + 1400);
        do
        {
          BOOL v105 = v104 == *(unsigned __int8 *)(v99 + 1 + v101);
          if (v104 != *(unsigned __int8 *)(v99 + 1 + v101)) {
            break;
          }
          uint64_t v101 = (__int16)++v102;
          int v104 = *(unsigned __int8 *)(v103 + (__int16)v102);
        }
        while (*(unsigned char *)(v103 + (__int16)v102));
      }
      else
      {
        BOOL v105 = 0;
      }
      if (*(char *)(v99 + 2) <= -65)
      {
        BOOL v155 = (char *)(v99 + 3);
        do
        {
          *(void *)(a1 + 1456) = v155;
          int v156 = *v155++;
        }
        while (v156 < -64);
      }
      unsigned int v154 = !v105;
      if (!v91) {
        unsigned int v154 = 0;
      }
LABEL_132:
      if (v91 == 31) {
        return 0;
      }
      else {
        return v154;
      }
    case 0xE:
    case 0x10:
      *(void *)(a1 + 1456) = v9 + 1;
      *(void *)(a1 + 1376) = *(void *)(a1 + 1440);
      uint64_t v10 = *(void *)(*(void *)(a1 + 1504) + 8 * v9[1] - 8);
      goto LABEL_4;
    case 0xF:
    case 0x11:
      uint64_t v10 = *(void *)(a1 + 1376);
LABEL_4:
      *(void *)(a1 + 1440) = v10;
      *(_WORD *)(a1 + 1470) = 0;
LABEL_5:
      uint64_t v11 = (uint64_t)(v9 + 2);
      goto LABEL_238;
    case 0x12:
      int v106 = *(__int16 *)(a1 + 1466);
      *(_WORD *)(a1 + 1472) = *(_WORD *)(a1 + 1466);
      if (v106 < 0) {
        return 0;
      }
      __int16 v107 = TOKEN(a1, v106, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      LOWORD(v113) = 0;
      *(_WORD *)(a1 + 1466) = v107;
      uint64_t v114 = *(void *)(a1 + 1456);
      int v115 = *(unsigned __int8 *)(v114 + 2);
      if (v115 == 220) {
        int v115 = 5000;
      }
      *(_WORD *)(a1 + 1406) = v115;
      *(void *)(a1 + 1392) = v114 + 4;
      __int16 v116 = v107;
      switch(*(unsigned char *)(v114 + 3))
      {
        case 2:
          LOWORD(v113) = 0;
          if (!v115) {
            goto LABEL_91;
          }
          uint64_t v117 = (unsigned char *)(a1 + 1400);
          while (1)
          {
            uint64_t v118 = *(void *)(a1 + 1512);
            int v119 = *(unsigned __int8 **)(a1 + 1392);
            uint64_t v120 = 5 * *v119;
            if (*(unsigned char *)(v118 + v120)) {
              break;
            }
            if (VAR_APPEARENCE(a1, v120))
            {
              *(_DWORD *)(a1 + 1480) = 1;
              SETUTF8CHAR(v118 + 5 * *v119, (unsigned __int8 *)(a1 + 1400));
              __int16 v116 = *(_WORD *)(a1 + 1466);
LABEL_89:
              __int16 v124 = *(_WORD *)(a1 + 1468);
              *(_WORD *)(a1 + 1466) = v124 + v116;
              *(_WORD *)(a1 + 1472) = v124 + v116;
              if (((v124 + v116) & 0x8000) != 0) {
                return 0;
              }
              __int16 v116 = TOKEN(a1, (__int16)(v124 + v116), v124, v108, v109, v110, v111, v112);
              *(_WORD *)(a1 + 1466) = v116;
              int v113 = (__int16)(v113 + 1);
              if (v113 < *(__int16 *)(a1 + 1406)) {
                continue;
              }
            }
            goto LABEL_91;
          }
          int v121 = *v117;
          if (*v117)
          {
            uint64_t v122 = 0;
            int v123 = 0;
            while (v121 == *(unsigned __int8 *)(v118 + v120 + v122))
            {
              uint64_t v122 = (__int16)++v123;
              int v121 = v117[(__int16)v123];
              if (!v117[(__int16)v123]) {
                goto LABEL_89;
              }
            }
          }
LABEL_91:
          int v125 = (__int16)v113;
          uint64_t v126 = a1;
          unsigned int v127 = 15;
          goto LABEL_230;
        case 3:
          LOWORD(v113) = 0;
          if (!v115) {
            goto LABEL_160;
          }
          unsigned int v165 = (unsigned char *)(a1 + 1400);
          do
          {
            if (*v165) {
              BOOL v166 = *v165 == 31;
            }
            else {
              BOOL v166 = 1;
            }
            if (v166
              || !strstr(*(char **)(*(void *)(*(void *)(a1 + 2120) + 8 * (**(unsigned char **)(a1 + 1392) - 1))+ 8 * *(unsigned __int8 *)(a1 + 1405)), (const char *)(a1 + 1400)))
            {
              break;
            }
            __int16 v167 = *(_WORD *)(a1 + 1468);
            *(_WORD *)(a1 + 1466) = v167 + v116;
            *(_WORD *)(a1 + 1472) = v167 + v116;
            if (((v167 + v116) & 0x8000) != 0) {
              return 0;
            }
            __int16 v116 = TOKEN(a1, (__int16)(v167 + v116), v167, v108, v109, v110, v111, v112);
            *(_WORD *)(a1 + 1466) = v116;
            int v113 = (__int16)(v113 + 1);
          }
          while (v113 < *(__int16 *)(a1 + 1406));
LABEL_160:
          int v125 = (__int16)v113;
          uint64_t v126 = a1;
          unsigned int v127 = 10;
          goto LABEL_230;
        case 4:
          LOWORD(v113) = 0;
          if (!v115) {
            goto LABEL_170;
          }
          BOOL v168 = (unsigned char *)(a1 + 1400);
          do
          {
            if (*v168) {
              BOOL v169 = *v168 == 31;
            }
            else {
              BOOL v169 = 1;
            }
            if (v169
              || strstr(*(char **)(*(void *)(*(void *)(a1 + 2120) + 8 * (**(unsigned char **)(a1 + 1392) - 1))+ 8 * *(unsigned __int8 *)(a1 + 1405)), (const char *)(a1 + 1400)))
            {
              break;
            }
            __int16 v170 = *(_WORD *)(a1 + 1468);
            *(_WORD *)(a1 + 1466) = v170 + v116;
            *(_WORD *)(a1 + 1472) = v170 + v116;
            if (((v170 + v116) & 0x8000) != 0) {
              return 0;
            }
            __int16 v116 = TOKEN(a1, (__int16)(v170 + v116), v170, v108, v109, v110, v111, v112);
            *(_WORD *)(a1 + 1466) = v116;
            int v113 = (__int16)(v113 + 1);
          }
          while (v113 < *(__int16 *)(a1 + 1406));
LABEL_170:
          int v125 = (__int16)v113;
          uint64_t v126 = a1;
          unsigned int v127 = 11;
          goto LABEL_230;
        case 5:
          LOWORD(v113) = 0;
          if (!v115) {
            goto LABEL_231;
          }
          uint64_t v171 = (unsigned char *)(a1 + 1400);
          do
          {
            if (*v171) {
              BOOL v172 = *v171 == 31;
            }
            else {
              BOOL v172 = 1;
            }
            if (v172
              || !strstr(*(char **)(*(void *)(*(void *)(a1 + 2128) + 8 * (**(unsigned char **)(a1 + 1392) - 1))+ 8 * *(unsigned __int8 *)(a1 + 1405)), (const char *)(a1 + 1400)))
            {
              break;
            }
            __int16 v178 = *(_WORD *)(a1 + 1468);
            *(_WORD *)(a1 + 1466) = v178 + v116;
            *(_WORD *)(a1 + 1472) = v178 + v116;
            if (((v178 + v116) & 0x8000) != 0) {
              return 0;
            }
            __int16 v116 = TOKEN(a1, (__int16)(v178 + v116), v178, v173, v174, v175, v176, v177);
            *(_WORD *)(a1 + 1466) = v116;
            int v113 = (__int16)(v113 + 1);
          }
          while (v113 < *(__int16 *)(a1 + 1406));
          goto LABEL_231;
        case 6:
          LOWORD(v113) = 0;
          if (!v115) {
            goto LABEL_190;
          }
          int v179 = (unsigned char *)(a1 + 1400);
          do
          {
            if (*v179) {
              BOOL v180 = *v179 == 31;
            }
            else {
              BOOL v180 = 1;
            }
            if (v180
              || strstr(*(char **)(*(void *)(*(void *)(a1 + 2128) + 8 * (**(unsigned char **)(a1 + 1392) - 1))+ 8 * *(unsigned __int8 *)(a1 + 1405)), (const char *)(a1 + 1400)))
            {
              break;
            }
            __int16 v181 = *(_WORD *)(a1 + 1468);
            *(_WORD *)(a1 + 1466) = v181 + v116;
            *(_WORD *)(a1 + 1472) = v181 + v116;
            if (((v181 + v116) & 0x8000) != 0) {
              return 0;
            }
            __int16 v116 = TOKEN(a1, (__int16)(v181 + v116), v181, v108, v109, v110, v111, v112);
            *(_WORD *)(a1 + 1466) = v116;
            int v113 = (__int16)(v113 + 1);
          }
          while (v113 < *(__int16 *)(a1 + 1406));
LABEL_190:
          int v125 = (__int16)v113;
          uint64_t v126 = a1;
          unsigned int v127 = 12;
          goto LABEL_230;
        case 0xC:
          LOWORD(v113) = 0;
          if (!v115) {
            goto LABEL_202;
          }
          int v182 = (unsigned char *)(a1 + 1400);
LABEL_193:
          int v183 = *v182;
          if (*v182) {
            BOOL v184 = v183 == 31;
          }
          else {
            BOOL v184 = 1;
          }
          if (v184) {
            goto LABEL_202;
          }
          uint64_t v185 = 0;
          int v186 = 0;
          while (v183 == *(unsigned __int8 *)(*(void *)(a1 + 1392) + v185))
          {
            uint64_t v185 = (__int16)++v186;
            int v183 = v182[(__int16)v186];
            if (!v182[(__int16)v186])
            {
              __int16 v187 = *(_WORD *)(a1 + 1468);
              *(_WORD *)(a1 + 1466) = v187 + v116;
              *(_WORD *)(a1 + 1472) = v187 + v116;
              if (((v187 + v116) & 0x8000) != 0) {
                return 0;
              }
              __int16 v116 = TOKEN(a1, (__int16)(v187 + v116), v187, v108, v109, v110, v111, v112);
              *(_WORD *)(a1 + 1466) = v116;
              int v113 = (__int16)(v113 + 1);
              if (v113 < *(__int16 *)(a1 + 1406)) {
                goto LABEL_193;
              }
              break;
            }
          }
LABEL_202:
          int v125 = (__int16)v113;
          uint64_t v126 = a1;
          unsigned int v127 = 13;
          goto LABEL_230;
        case 0xD:
          LOWORD(v113) = 0;
          if (!v115) {
            goto LABEL_215;
          }
          uint64_t v188 = (unsigned char *)(a1 + 1400);
          do
          {
            int v189 = *v188;
            if (*v188) {
              BOOL v190 = v189 == 31;
            }
            else {
              BOOL v190 = 1;
            }
            if (v190) {
              break;
            }
            uint64_t v191 = 0;
            int v192 = 0;
            while (v189 == *(unsigned __int8 *)(*(void *)(a1 + 1392) + v191))
            {
              uint64_t v191 = (__int16)++v192;
              int v189 = v188[(__int16)v192];
              if (!v188[(__int16)v192]) {
                goto LABEL_215;
              }
            }
            __int16 v193 = *(_WORD *)(a1 + 1468);
            *(_WORD *)(a1 + 1466) = v193 + v116;
            *(_WORD *)(a1 + 1472) = v193 + v116;
            if (((v193 + v116) & 0x8000) != 0) {
              return 0;
            }
            __int16 v116 = TOKEN(a1, (__int16)(v193 + v116), v193, v108, v109, v110, v111, v112);
            *(_WORD *)(a1 + 1466) = v116;
            int v113 = (__int16)(v113 + 1);
          }
          while (v113 < *(__int16 *)(a1 + 1406));
LABEL_215:
          int v125 = (__int16)v113;
          uint64_t v126 = a1;
          unsigned int v127 = 14;
          goto LABEL_230;
        case 0x15:
          LOWORD(v113) = 0;
          if (!v115) {
            goto LABEL_229;
          }
          uint64_t v194 = (unsigned char *)(a1 + 1400);
          break;
        default:
          goto LABEL_231;
      }
      while (2)
      {
        int v195 = *v194;
        if (*v194) {
          BOOL v196 = v195 == 31;
        }
        else {
          BOOL v196 = 1;
        }
        if (!v196)
        {
          uint64_t v197 = (unsigned char *)(*(void *)(a1 + 1512) + 5 * **(unsigned __int8 **)(a1 + 1392));
          if (*v197)
          {
            uint64_t v198 = 0;
            int v199 = 0;
            while (v195 == v197[v198])
            {
              uint64_t v198 = (__int16)++v199;
              int v195 = v194[(__int16)v199];
              if (!v194[(__int16)v199]) {
                goto LABEL_229;
              }
            }
          }
          __int16 v200 = *(_WORD *)(a1 + 1468);
          *(_WORD *)(a1 + 1466) = v200 + v116;
          *(_WORD *)(a1 + 1472) = v200 + v116;
          if (((v200 + v116) & 0x8000) == 0)
          {
            __int16 v116 = TOKEN(a1, (__int16)(v200 + v116), v200, v108, v109, v110, v111, v112);
            *(_WORD *)(a1 + 1466) = v116;
            int v113 = (__int16)(v113 + 1);
            if (v113 >= *(__int16 *)(a1 + 1406)) {
              break;
            }
            continue;
          }
          return 0;
        }
        break;
      }
LABEL_229:
      int v125 = (__int16)v113;
      uint64_t v126 = a1;
      unsigned int v127 = 16;
LABEL_230:
      LOG_WARNING_ON_MAX_NUMBER(v126, v125, v127, v108, v109, v110, v111, v112);
LABEL_231:
      uint64_t v201 = *(void *)(a1 + 1456);
      if (*(unsigned __int8 *)(v201 + 1) > (unsigned __int16)v113) {
        return 0;
      }
      *(_WORD *)(a1 + 1466) = *(_WORD *)(a1 + 1472);
      uint64_t v66 = v201 + 5;
      *(void *)(a1 + 1456) = v201 + 5;
      *(_WORD *)(a1 + 1470) = *(_WORD *)(a1 + 1468);
      if (*(char *)(v201 + 5) <= -65)
      {
        uint64_t v202 = (char *)(v201 + 6);
        do
        {
          *(void *)(a1 + 1456) = v202;
          int v203 = *v202++;
        }
        while (v203 < -64);
        uint64_t v66 = (uint64_t)(v202 - 1);
      }
LABEL_237:
      uint64_t v11 = v66 + 1;
LABEL_238:
      *(void *)(a1 + 1456) = v11;
      return 1;
    case 0x13:
      int v128 = *(__int16 *)(a1 + 1466);
      if (v128 < 0) {
        return 0;
      }
      *(_WORD *)(a1 + 1466) = TOKEN(a1, v128, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      *(_WORD *)(a1 + 1470) = *(_WORD *)(a1 + 1468);
      uint64_t v11 = *(void *)(a1 + 1456) + 1;
      goto LABEL_238;
    case 0x15:
      int v129 = *(__int16 *)(a1 + 1466);
      if (v129 < 0) {
        return 0;
      }
      __int16 v130 = TOKEN(a1, v129, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      uint64_t v14 = 0;
      *(_WORD *)(a1 + 1466) = v130;
      uint64_t v131 = *(void *)(a1 + 1456);
      *(void *)(a1 + 1456) = v131 + 1;
      uint64_t v132 = *(unsigned __int8 *)(v131 + 1);
      __int16 v133 = *(_WORD *)(a1 + 1468);
      *(_WORD *)(a1 + 1470) = v133;
      *(void *)(a1 + 1456) = v131 + 2;
      *(_WORD *)(a1 + 1466) = v133 + v130;
      int v134 = *(unsigned __int8 *)(a1 + 1400);
      if (!*(unsigned char *)(a1 + 1400) || v134 == 31) {
        return v14;
      }
      int v135 = (unsigned char *)(*(void *)(a1 + 1512) + 5 * v132);
      if (!*v135) {
        return 1;
      }
      uint64_t v136 = 0;
      int v137 = 0;
      uint64_t v138 = a1 + 1400;
      while (v134 == v135[v136])
      {
        uint64_t v14 = 0;
        uint64_t v136 = (__int16)++v137;
        int v134 = *(unsigned __int8 *)(v138 + (__int16)v137);
        if (!*(unsigned char *)(v138 + (__int16)v137)) {
          return v14;
        }
      }
      return 1;
    default:
      int v45 = *(__int16 *)(a1 + 1466);
      if (v45 < 0) {
        return 0;
      }
      __int16 v46 = TOKEN(a1, v45, *(__int16 *)(a1 + 1470), a4, a5, a6, a7, a8);
      *(_WORD *)(a1 + 1466) = v46;
      __int16 v47 = *(_WORD *)(a1 + 1468);
      *(_WORD *)(a1 + 1470) = v47;
      uint64_t v48 = (const char *)(a1 + 1400);
      uint64_t v49 = *(void *)(a1 + 1456);
      int v50 = *(unsigned __int8 *)(a1 + 1400);
      if (!*(unsigned char *)(a1 + 1400)) {
        goto LABEL_102;
      }
      uint64_t v51 = 0;
      int v52 = 0;
      while (v50 == *(unsigned __int8 *)(v49 + v51))
      {
        uint64_t v51 = (__int16)++v52;
        int v50 = v48[(__int16)v52];
        if (!v48[(__int16)v52])
        {
          uint64_t v14 = 1;
          goto LABEL_103;
        }
      }
LABEL_102:
      uint64_t v14 = 0;
LABEL_103:
      *(void *)(a1 + 1456) = v49 + strlen(v48);
      *(_WORD *)(a1 + 1466) = v47 + v46;
      return v14;
  }
}

uint64_t SKIP_DATA(uint64_t a1, uint64_t a2, int a3)
{
  int v6 = 0;
  uint64_t v7 = *(unsigned char **)(a1 + 1456);
  LOBYTE(v8) = *v7;
  while (1)
  {
    if (a2 != v8)
    {
LABEL_11:
      if (a2 != 10 || v8 != 10 || !v6) {
        goto LABEL_21;
      }
      goto LABEL_14;
    }
    int v6 = v7[1];
    if (v6 == a3)
    {
      unsigned int v9 = *(v7 - 1);
      BOOL v10 = v9 > 0x15;
      int v11 = (1 << v9) & 0x20067C;
      if (v10 || v11 == 0) {
        return 1;
      }
      unsigned int v13 = *(v7 - 2) - 2;
      if (v13 < 0x14 && ((0x8319Fu >> v13) & 1) != 0) {
        return 1;
      }
    }
    if (v6 != 1) {
      goto LABEL_11;
    }
LABEL_14:
    unsigned int v14 = *(v7 - 1);
    BOOL v10 = v14 > 0x15;
    int v15 = (1 << v14) & 0x20067C;
    BOOL v16 = v10 || v15 == 0;
    if (v16 || (unsigned int v17 = *(v7 - 2), v17 <= 0x15) && ((1 << v17) & 0x20C67C) != 0)
    {
      *(void *)(a1 + 1456) = v7 + 1;
      SKIP_DATA(a1, a2, 0);
      uint64_t v18 = *(void *)(a1 + 1456) + 1;
      goto LABEL_22;
    }
LABEL_21:
    uint64_t v18 = (uint64_t)v7;
LABEL_22:
    uint64_t v7 = (unsigned char *)(v18 + 1);
    *(void *)(a1 + 1456) = v18 + 1;
    int v8 = *(unsigned __int8 *)(v18 + 1);
    if (v8 == a2 && !*(unsigned char *)(v18 + 2)) {
      return 0;
    }
  }
}

uint64_t TOKEN(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a2;
  if (a2 < 0) {
    log_OutText(*(void *)(*(void *)(a1 + 2080) + 32), (uint64_t)"FE_DEPES", 3, 0, (uint64_t)"warning: nr < 0 (1)", a6, a7, a8, v18);
  }
  uint64_t v11 = *(void *)(a1 + 1440);
  if (a3)
  {
    do
    {
      __int16 v12 = v9;
      int v13 = *(_DWORD *)(v11 + 4 * (__int16)v9);
      v9 += a3;
    }
    while (v13 == 126);
  }
  else
  {
    __int16 v12 = v9;
  }
  uint64_t v14 = v12;
  int v15 = (unsigned int *)(v11 + 4 * v12);
  if (*(unsigned int **)(a1 + 2096) != v15)
  {
    Utf32SymToUtf8Sym(*v15, (unsigned char *)(a1 + 1400), 5u);
    BOOL v16 = (_DWORD *)(*(void *)(a1 + 1440) + 4 * v14);
    *(unsigned char *)(a1 + 1405) = *v16 & 0x3F;
    *(void *)(a1 + 2096) = v16;
  }
  return v14;
}

uint64_t DCT_LKP(uint64_t a1, uint64_t a2, int a3, __int16 *a4)
{
  *(_WORD *)&__c[1] = -1;
  __c[0] = 0;
  unsigned __int16 v8 = 5 * (*a4 - a3) + 1;
  uint64_t v9 = heap_Alloc(*(void *)(a1 + 1528), v8);
  if (!v9)
  {
    uint64_t v27 = 0;
    *(unsigned char *)(a1 + 1428) = -101;
    return v27;
  }
  uint64_t v10 = v9;
  *(void *)&__c[3] = 0;
  unsigned int v30 = 0;
  utf8_Utf32ToUtf8(**(void **)(a1 + 1504) + 4 * a3, (unsigned __int16)(*a4 - a3), v9, v8, &v30);
  *(unsigned char *)(v10 + v30) = 0;
  (*(void (**)(void, void, uint64_t, uint64_t, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 1552) + 96))(*(void *)(a1 + 1536), *(void *)(a1 + 1544), a2, v10, &__c[3], &__c[1], __c);
  if (*(unsigned __int16 *)&__c[1] != 1)
  {
LABEL_30:
    heap_Free(*(void **)(a1 + 1528), v10);
    return 0;
  }
  uint64_t v11 = heap_Alloc(*(void *)(a1 + 1528), 2 * *(unsigned __int16 *)(a1 + 24));
  if (!v11)
  {
    *(unsigned char *)(a1 + 1428) = -101;
    goto LABEL_30;
  }
  uint64_t v12 = v11;
  if (*(__int16 *)(a1 + 24) < 1) {
    goto LABEL_26;
  }
  uint64_t v13 = 0;
  uint64_t v14 = **(char ***)&__c[3];
  do
  {
    *(_WORD *)(v11 + 2 * v13++) = *a4;
    uint64_t v15 = *(__int16 *)(a1 + 24);
  }
  while (v13 < v15);
  if ((int)v15 < 1)
  {
LABEL_26:
    __int16 v17 = 0;
  }
  else
  {
    uint64_t v29 = v10;
    uint64_t v16 = 0;
    __int16 v17 = 0;
    do
    {
      uint64_t v18 = strchr(v14, __c[0]);
      uint64_t v19 = v18;
      if (v18) {
        *uint64_t v18 = 0;
      }
      size_t v20 = strlen(v14);
      if (v20)
      {
        unsigned int v21 = (unsigned __int16)v20;
        __int16 v22 = Utf8_LengthInUtf8chars((unint64_t)v14, (unsigned __int16)v20);
        int v23 = a3 + v22;
        if (v23 >= *(__int16 *)(*(void *)(a1 + 1416) + 2 * v16) - 1)
        {
          uint64_t v27 = 0;
          *(unsigned char *)(a1 + 1428) = -100;
          uint64_t v10 = v29;
          goto LABEL_28;
        }
        utf8_Utf8ToUtf32((uint64_t)v14, v21, 0, *(void *)(*(void *)(a1 + 1504) + 8 * v16) + 4 * a3, (unsigned __int16)(v22 + a3), &v30, 0);
        *(_WORD *)(v12 + 2 * v16) = v23;
      }
      else
      {
        LOWORD(v23) = *(_WORD *)(v12 + 2 * v16);
      }
      if (v17 <= (__int16)v23) {
        __int16 v17 = v23;
      }
      uint64_t v24 = *(__int16 *)(a1 + 24);
      if (!v19) {
        break;
      }
      uint64_t v14 = v19 + 1;
      ++v16;
    }
    while (v16 < v24);
    uint64_t v25 = *(unsigned __int16 *)(a1 + 24);
    if ((__int16)v24 < 1)
    {
      uint64_t v10 = v29;
    }
    else
    {
      uint64_t v26 = 0;
      uint64_t v10 = v29;
      do
      {
        if (*(__int16 *)(v12 + 2 * v26) < v17) {
          memset_pattern16((void *)(*(void *)(*(void *)(a1 + 1504) + 8 * v26) + 4 * *(__int16 *)(v12 + 2 * v26)), &unk_20D62D4F0, 4 * (unsigned __int16)(v17 + ~*(_WORD *)(v12 + 2 * v26)) + 4);
        }
        ++v26;
      }
      while (v25 != v26);
    }
  }
  *a4 = v17;
  uint64_t v27 = 1;
LABEL_28:
  heap_Free(*(void **)(a1 + 1528), v10);
  heap_Free(*(void **)(a1 + 1528), v12);
  return v27;
}

uint64_t RESTORE_SUBSTITUTION(uint64_t a1, int a2)
{
  uint64_t v4 = *(__int16 *)(a1 + 24);
  if (v4 <= 0)
  {
    __int16 v6 = 0;
    uint64_t v8 = *(void *)(a1 + 1416);
    uint64_t v7 = a2;
  }
  else
  {
    uint64_t v5 = 0;
    __int16 v6 = 0;
    uint64_t v7 = a2;
    uint64_t v8 = *(void *)(a1 + 1416);
    do
    {
      __int16 v9 = *(_WORD *)(v8 + 2 * v5);
      uint64_t v10 = *(void *)(*(void *)(a1 + 1504) + 8 * v5);
      for (__int16 i = v9; ; ++i)
      {
        int v12 = *(_DWORD *)(v10 + 4 * i);
        if (!v12) {
          break;
        }
        if (v12 == 31)
        {
          __int16 v6 = i - v9;
          unsigned __int16 v13 = i - v9 + 1;
          memmove((void *)(v10 + 4 * a2), (const void *)(v10 + 4 * *(__int16 *)(v8 + 2 * v5)), 4 * v13);
          uint64_t v8 = *(void *)(a1 + 1416);
          *(_WORD *)(v8 + 2 * v5) += v13;
          LOWORD(v4) = *(_WORD *)(a1 + 24);
          break;
        }
      }
      ++v5;
    }
    while (v5 < (__int16)v4);
    uint64_t v4 = (__int16)v4;
  }
  memmove((void *)(*(void *)(a1 + 1560) + v7), (const void *)(*(void *)(a1 + 1560) + *(__int16 *)(v8 + 2 * v4)), (unsigned __int16)(v6 + 1));
  *(_WORD *)(*(void *)(a1 + 1416) + 2 * *(__int16 *)(a1 + 24)) += v6 + 1;
  return (__int16)(v6 + a2);
}

uint64_t FirstUtf8SymToUtf32(unsigned __int8 *a1, _DWORD *a2)
{
  int v6 = 0;
  *a2 = 0;
  unsigned int v4 = utf8_determineUTF8CharLength(*a1);
  uint64_t result = utf8_Utf8ToUtf32((uint64_t)a1, v4, 0, (uint64_t)a2, 1u, &v6, 0);
  if ((result & 0x80000000) == 0 && v6 != 1) {
    *a2 = 0;
  }
  return result;
}

uint64_t MOVE_FOR_SUBSTITUTION(uint64_t a1, int a2, int a3, int a4)
{
  if (a4)
  {
    int v5 = a2;
    LODWORD(v7) = *(__int16 *)(a1 + 24);
    if ((int)v7 > 0)
    {
      uint64_t v8 = 0;
      int v9 = a4 + a3 + 1;
      uint64_t v10 = (__int16)(a4 + a2);
      int v23 = a4;
      size_t v11 = 4 * (unsigned __int16)a4;
      do
      {
        uint64_t v12 = *(void *)(*(void *)(a1 + 1504) + 8 * v8);
        if (v12 != *(void *)(a1 + 1448))
        {
          if (v9 >= *(__int16 *)(*(void *)(a1 + 1416) + 2 * v8)) {
            goto LABEL_24;
          }
          memmove((void *)(v12 + 4 * v10), (const void *)(v12 + 4 * v5), 4 * (unsigned __int16)(a3 - v5 + 1));
          if ((int)v10 > v5) {
            memset_pattern16((void *)(*(void *)(*(void *)(a1 + 1504) + 8 * v8) + 4 * v5), &unk_20D62D4F0, v11);
          }
        }
        ++v8;
        uint64_t v7 = *(__int16 *)(a1 + 24);
      }
      while (v8 < v7);
      a4 = v23;
    }
    if (a4 < 0)
    {
      uint64_t v7 = *(void *)(a1 + 1560);
      if ((__int16)(a4 + v5) >= v5)
      {
        char v13 = 0;
        uint64_t v14 = v5;
      }
      else
      {
        char v13 = 0;
        uint64_t v14 = v5;
        uint64_t v15 = (char *)(v7 + (__int16)(a4 + v5));
        uint64_t v16 = v5 - (uint64_t)(__int16)(a4 + v5);
        do
        {
          char v17 = *v15++;
          v13 += v17;
          --v16;
        }
        while (v16);
      }
      *(unsigned char *)(v7 + v14) += v13;
      LOWORD(v7) = *(_WORD *)(a1 + 24);
    }
    __int16 v18 = a4 + a3;
    if (a4 + a3 >= *(__int16 *)(*(void *)(a1 + 1416) + 2 * (__int16)v7) - 1)
    {
LABEL_24:
      __int16 v18 = 0;
      *(unsigned char *)(a1 + 1428) = -100;
    }
    else
    {
      int v19 = a4;
      uint64_t v20 = a4 + (uint64_t)v5;
      memmove((void *)(*(void *)(a1 + 1560) + v20), (const void *)(*(void *)(a1 + 1560) + v5), (unsigned __int16)(a3 - v5 + 1));
      if (v19 >= 1)
      {
        do
          *(unsigned char *)(*(void *)(a1 + 1560) + (__int16)v5++) = 0;
        while ((int)v20 > (__int16)v5);
      }
      for (__int16 i = v18 + 1; i <= a3; ++i)
        *(unsigned char *)(*(void *)(a1 + 1560) + i) = 0;
    }
  }
  else
  {
    return (__int16)a3;
  }
  return v18;
}

uint64_t COUNTSYL(uint64_t a1, int a2, _WORD *a3)
{
  LODWORD(v3) = (__int16)(*a3 - 1);
  if ((int)v3 >= a2)
  {
    unsigned int v4 = *(uint64_t **)(a1 + 1504);
    uint64_t v5 = *v4;
    __int16 v6 = 1;
    do
    {
      uint64_t v3 = (__int16)v3;
      if (*(_DWORD *)(v5 + 4 * (__int16)v3) == 45)
      {
        if (v6 <= 9) {
          *(_DWORD *)(v4[3] + 4 * v3) = (unsigned __int16)(v6 + 48);
        }
        ++v6;
      }
      LODWORD(v3) = (__int16)(v3 - 1);
    }
    while ((int)v3 >= a2);
  }
  return 1;
}

uint64_t COPY_L1_TO_L2(uint64_t a1, int a2, __int16 *a3)
{
  int v3 = *a3;
  if (*(__int16 *)(*(void *)(a1 + 1416) + 2) - 1 <= v3)
  {
    uint64_t v4 = 0;
    *(unsigned char *)(a1 + 1428) = -100;
  }
  else
  {
    memmove((void *)(*(void *)(*(void *)(a1 + 1504) + 8) + 4 * a2), (const void *)(**(void **)(a1 + 1504) + 4 * a2), 4 * (unsigned __int16)(v3 - a2));
    return 1;
  }
  return v4;
}

uint64_t TAGTQ(uint64_t a1, int a2, __int16 *a3)
{
  int v5 = *a3;
  int v6 = (__int16)(*a3 - 1);
  uint64_t v7 = *(uint64_t **)(a1 + 1504);
  uint64_t v8 = v7[1];
  if (v6 >= a2)
  {
    LOWORD(v22) = *a3 - 1;
    do
    {
      int v23 = *(_DWORD *)(v8 + 4 * (__int16)v22);
      if (v23 != 126 && v23 != 32) {
        break;
      }
      int v22 = (__int16)(v22 - 1);
    }
    while (v22 >= a2);
    if (*(_DWORD *)(v8 + 4 * (__int16)v22) == 63)
    {
      uint64_t v9 = *v7;
      while (v6 >= a2)
      {
        int v24 = *(_DWORD *)(v9 + 4 * (__int16)v6);
        if (v24 != 20 && v24 != 126 && v24 != 32) {
          break;
        }
        int v6 = (__int16)(v6 - 1);
      }
      goto LABEL_4;
    }
    return 1;
  }
  if (*(_DWORD *)(v8 + 4 * (__int16)(*a3 - 1)) != 63) {
    return 1;
  }
  uint64_t v9 = *v7;
LABEL_4:
  if (a2 <= (__int16)v6)
  {
    __int16 v25 = 0;
    int v10 = v6;
    do
    {
      int v26 = *(_DWORD *)(v9 + 4 * (__int16)v10);
      if (v26 == 45 || v26 == 32) {
        ++v25;
      }
      if (v26 == 35) {
        break;
      }
      int v10 = (__int16)(v10 - 1);
      if (v10 < a2) {
        break;
      }
    }
    while (v25 < 3);
  }
  else
  {
    int v10 = v6;
  }
  do
  {
    unsigned int v11 = *(_DWORD *)(v9 + 4 * (__int16)++v10);
    BOOL v12 = v11 > 0x23 || ((1 << v11) & 0x900100000) == 0;
  }
  while (!v12 || v11 == 126);
  if (v5 + 4 >= **(__int16 **)(a1 + 1416) - 1
    || (uint64_t v13 = (__int16)v10 + 4,
        memmove((void *)(v9 + 4 * v13), (const void *)(v9 + 4 * (__int16)v10), 4 * (unsigned __int16)(v5 - v10)),
        int v14 = *a3,
        v14 + 4 >= *(__int16 *)(*(void *)(a1 + 1416) + 2) - 1)
    || (memmove((void *)(*(void *)(*(void *)(a1 + 1504) + 8) + 4 * v13), (const void *)(*(void *)(*(void *)(a1 + 1504) + 8) + 4 * (__int16)v10), 4 * (unsigned __int16)(v14 - v10)), int v15 = *a3, v15 + 4 >= *(__int16 *)(*(void *)(a1 + 1416) + 4) - 1)|| (memmove((void *)(*(void *)(*(void *)(a1 + 1504) + 16) + 4 * v13), (const void *)(*(void *)(*(void *)(a1 + 1504) + 16) + 4 * (__int16)v10), 4 * (unsigned __int16)(v15 - v10)), v16 = *a3, v16 + 4 >= *(__int16 *)(*(void *)(a1 + 1416) + 6) - 1))
  {
    uint64_t result = 0;
    *(unsigned char *)(a1 + 1428) = -100;
  }
  else
  {
    memmove((void *)(*(void *)(*(void *)(a1 + 1504) + 24) + 4 * v13), (const void *)(*(void *)(*(void *)(a1 + 1504) + 24) + 4 * (__int16)v10), 4 * (unsigned __int16)(v16 - v10));
    *a3 += 4;
    char v17 = *(void **)(a1 + 1504);
    uint64_t v18 = v17[1];
    *(_OWORD *)(*v17 + 4 * (__int16)v10) = xmmword_20D62D500;
    uint64_t v19 = v17[2];
    uint64_t v20 = v17[3];
    uint64_t result = 1;
    do
    {
      *(_DWORD *)(v18 + 4 * (__int16)v10) = 126;
      *(_DWORD *)(v19 + 4 * (__int16)v10) = 126;
      *(_DWORD *)(v20 + 4 * (__int16)v10++) = 126;
    }
    while ((int)v13 > (__int16)v10);
  }
  return result;
}

uint64_t fe_depes_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  uint64_t v5 = 2305826826;
  HIWORD(v41) = 0;
  __src[0] = 0;
  if (!a5) {
    return 2305826823;
  }
  *a5 = 0;
  *((_DWORD *)a5 + 2) = 0;
  uint64_t inited = InitRsrcFunction(a3, a4, &v43);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  log_OutText(*(void *)(v43 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_ObjOpen", v12, v13, v14, v41);
  uint64_t inited = objc_GetObject(*(void *)(v43 + 48), (uint64_t)"FE_DCTLKP", &v42);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t v15 = heap_Calloc(*(void **)(v43 + 8), 1, 712);
  if (v15)
  {
    uint64_t v20 = v15;
    *a5 = v15;
    *((_DWORD *)a5 + 2) = 62334;
    uint64_t v21 = v43;
    *(void *)(v20 + 16) = a3;
    *(void *)(v20 + 24) = a4;
    *(void *)(v20 + 32) = a1;
    *(void *)(v20 + 40) = a2;
    *(void *)uint64_t v20 = v21;
    *(void *)(v20 + 8) = a1;
    uint64_t v22 = v42;
    *(void *)(v20 + 64) = *(void *)(v42 + 8);
    long long v23 = *(_OWORD *)(v22 + 16);
    *(_OWORD *)(v20 + 144) = 0u;
    *(_OWORD *)(v20 + 48) = v23;
    *(_OWORD *)(v20 + 170) = 0u;
    *(_OWORD *)(v20 + 160) = 0u;
    *(void *)(v20 + 72) = 0;
    *(_DWORD *)(v20 + 186) = 3172;
    *(void *)(v20 + 80) = 0;
    int v24 = (void *)(v20 + 80);
    *(void *)(v20 + 192) = 0;
    if (((hlp_CreateLngBrokerString(v21, __src, 0) & 0x80000000) != 0
       || (hlp_OpenData(*(void *)v20, (uint64_t)__src, (uint64_t *)(v20 + 72), (_DWORD *)(v20 + 136)) & 0x80000000) != 0
       || !*(void *)(v20 + 72))
      && ((Lnguint64_t BrokerString = hlp_CreateLngBrokerString(*(void *)v20, __src, 1), (LngBrokerString & 0x80000000) != 0)
       || (Lnguint64_t BrokerString = hlp_OpenData(*(void *)v20, (uint64_t)__src, (uint64_t *)(v20 + 72), (_DWORD *)(v20 + 136)),
           (LngBrokerString & 0x80000000) != 0))
      || ((__strcpy_chk(), (hlp_CreateVoiceBrokerString_0(*(void *)v20, __src, 0, 0) & 0x80000000) != 0)
       || (hlp_OpenData(*(void *)v20, (uint64_t)__src, (uint64_t *)(v20 + 80), (_DWORD *)(v20 + 140)) & 0x80000000) != 0
       || !*v24)
      && ((hlp_CreateVoiceBrokerString_0(*(void *)v20, __src, 1, 1) & 0x80000000) != 0
       || (hlp_OpenData(*(void *)v20, (uint64_t)__src, (uint64_t *)(v20 + 80), (_DWORD *)(v20 + 140)) & 0x80000000) != 0
       || !*v24)
      && ((Lnguint64_t BrokerString = hlp_CreateVoiceBrokerString_0(*(void *)v20, __src, 1, 0),
           (LngBrokerString & 0x80000000) != 0)
       || (Lnguint64_t BrokerString = hlp_OpenData(*(void *)v20, (uint64_t)__src, (uint64_t *)(v20 + 80), (_DWORD *)(v20 + 140)),
           (LngBrokerString & 0x80000000) != 0)))
    {
      uint64_t v5 = LngBrokerString;
      goto LABEL_34;
    }
    strcpy((char *)(v20 + 456), __src);
    if (*(void *)(v20 + 72))
    {
      uint64_t v30 = heap_Calloc(*(void **)(*(void *)v20 + 8), 1, 2136);
      *(void *)(v20 + 144) = v30;
      if (!v30)
      {
LABEL_31:
        uint64_t v39 = 42000;
LABEL_33:
        log_OutPublic(*(void *)(*(void *)v20 + 32), (uint64_t)"FE_DEPES", v39, 0, v26, v27, v28, v29, v41);
        goto LABEL_34;
      }
      *(void *)(v30 + 1560) = 0;
      *(_OWORD *)(v30 + 1496) = 0u;
      *(_OWORD *)(v30 + 1512) = 0u;
      *(void *)(v30 + 1528) = *(void *)(v43 + 8);
      uint64_t v31 = v42;
      *(_OWORD *)(v30 + 1536) = *(_OWORD *)(v42 + 16);
      uint64_t v32 = *(void *)(v20 + 144);
      *(void *)(v32 + 1552) = *(void *)(v31 + 8);
      *(void *)uint64_t v32 = 0;
      *(_OWORD *)(v32 + 2120) = 0u;
      if (!*v24)
      {
LABEL_29:
        uint64_t v5 = fe_depes_InitModule((uint64_t **)*a5, a5[1], "fe_depes", (_WORD *)&v41 + 3);
        if ((v5 & 0x80000000) == 0)
        {
LABEL_35:
          log_OutText(*(void *)(v43 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_ObjOpen", v36, v37, v38, v41);
          return v5;
        }
LABEL_34:
        fe_depes_ObjClose((void *)*a5, a5[1]);
        *a5 = 0;
        *((_DWORD *)a5 + 2) = 0;
        goto LABEL_35;
      }
    }
    else if (!*v24)
    {
      uint64_t v5 = 2305826819;
      uint64_t v39 = 42002;
      goto LABEL_33;
    }
    uint64_t v33 = heap_Calloc(*(void **)(*(void *)v20 + 8), 1, 2136);
    *(void *)(v20 + 152) = v33;
    if (v33)
    {
      *(void *)(v33 + 1560) = 0;
      *(_OWORD *)(v33 + 1496) = 0u;
      *(_OWORD *)(v33 + 1512) = 0u;
      *(void *)(v33 + 1528) = *(void *)(v43 + 8);
      uint64_t v34 = v42;
      *(_OWORD *)(v33 + 1536) = *(_OWORD *)(v42 + 16);
      uint64_t v35 = *(void *)(v20 + 152);
      *(void *)(v35 + 1552) = *(void *)(v34 + 8);
      *(void *)uint64_t v35 = 0;
      *(_OWORD *)(v35 + 2120) = 0u;
      goto LABEL_29;
    }
    goto LABEL_31;
  }
  log_OutPublic(*(void *)(v43 + 32), (uint64_t)"FE_DEPES", 42000, 0, v16, v17, v18, v19, v41);
  objc_ReleaseObject(*(void *)(v43 + 48), (uint64_t)"FE_DCTLKP");
  return v5;
}

uint64_t hlp_CreateLngBrokerString(uint64_t a1, char *a2, int a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v7 = &byte_20D5A22AE;
  *(void *)uint64_t v8 = 0;
  memset(v16, 0, sizeof(v16));
  long long v15 = 0u;
  long long v14 = 0u;
  long long v13 = 0u;
  long long v12 = 0u;
  long long v11 = 0u;
  long long v10 = 0u;
  uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"langcode", v8);
  if ((result & 0x80000000) == 0)
  {
    strcpy(v9, "depes/");
    __strcat_chk();
    if (!a3)
    {
      uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"fecfg", &v7);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      __strcat_chk();
      __strcat_chk();
    }
    return brokeraux_ComposeBrokerString(a1, v9, 1, 1, *(char **)v8, 0, 0, a2, 0x100uLL);
  }
  return result;
}

uint64_t hlp_OpenData(uint64_t a1, uint64_t a2, uint64_t *a3, _DWORD *a4)
{
  uint64_t v15 = 0;
  if ((brk_DataOpenEx(*(void *)(a1 + 24), a2, 1, (uint64_t)a3) & 0x80000000) != 0)
  {
    uint64_t v11 = 0;
LABEL_10:
    *a3 = 0;
    return v11;
  }
  uint64_t v11 = brk_DataMap(*(void *)(a1 + 24), *a3, 0, 72, (uint64_t)&v15);
  if ((v11 & 0x80000000) != 0)
  {
    brk_DataClose(*(void *)(a1 + 24), *a3);
    goto LABEL_10;
  }
  if ((v15 & 3) != 0
    || *(_DWORD *)v15 != 65279
    || LH_strnicmp(v15 + 4, (uint64_t)"SCANSOFT", 8uLL)
    || LH_strnicmp(v15 + 12, (uint64_t)"depes", 5uLL))
  {
    uint64_t v11 = 2305826841;
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_DEPES", 42006, 0, v7, v8, v9, v10, v14);
  }
  else
  {
    int v13 = *(_DWORD *)(v15 + 20);
    brk_DataUnmap(*(void *)(a1 + 24), *a3, v15);
    *a4 = v13 - 72;
  }
  return v11;
}

uint64_t hlp_CreateVoiceBrokerString_0(uint64_t a1, char *a2, int a3, int a4)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  long long v12 = 0;
  int v13 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = &byte_20D5A22AE;
  memset(v21, 0, sizeof(v21));
  long long v20 = 0u;
  long long v19 = 0u;
  long long v18 = 0u;
  long long v17 = 0u;
  long long v16 = 0u;
  long long v15 = 0u;
  uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"langcode", &v13);
  if ((result & 0x80000000) == 0)
  {
    if ((paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"fevoice", &v12) & 0x80000000) == 0
      || (uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"voice", &v12), (result & 0x80000000) == 0))
    {
      strcpy(v14, "depes/");
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      if (a3)
      {
        if (a4)
        {
LABEL_6:
          if ((paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"voicemodel", &v10) & 0x80000000) != 0)
          {
            uint64_t v9 = 0;
            uint64_t v10 = 0;
          }
          else
          {
            uint64_t v9 = v10;
          }
          return brokeraux_ComposeBrokerString(a1, v14, 1, 1, v13, v12, v9, a2, 0x100uLL);
        }
      }
      else
      {
        uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"fecfg", &v11);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        __strcat_chk();
        __strcat_chk();
        if (a4) {
          goto LABEL_6;
        }
      }
      uint64_t v9 = 0;
      return brokeraux_ComposeBrokerString(a1, v14, 1, 1, v13, v12, v9, a2, 0x100uLL);
    }
  }
  return result;
}

uint64_t fe_depes_InitModule(uint64_t **a1, int a2, char *a3, _WORD *a4)
{
  uint64_t v8 = 2305826826;
  uint64_t v9 = safeh_HandleCheck((uint64_t)a1, a2, 62334, 712);
  if ((v9 & 0x80000000) == 0)
  {
    uint64_t inited = v9;
    log_OutText((*a1)[4], (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_InitModule", v10, v11, v12, v37);
    *a4 = 0;
    uint64_t v14 = (uint64_t)a1[9];
    if (v14)
    {
      uint64_t v15 = (uint64_t)a1[18];
      if (!v15) {
        goto LABEL_18;
      }
      uint64_t inited = hlp_InitData((uint64_t)a1, *a1, a3, 1, (uint64_t)(a1 + 25), v14, *((unsigned int *)a1 + 34), v15);
      if ((inited & 0x80000000) != 0) {
        goto LABEL_45;
      }
      long long v20 = a1[18];
      if (*a4)
      {
        if ((unsigned __int16)*a4 != *((__int16 *)v20 + 12)) {
          goto LABEL_19;
        }
        unsigned int v21 = *((unsigned __int16 *)v20 + 12);
      }
      else
      {
        unsigned int v21 = *((unsigned __int16 *)v20 + 12);
      }
      *a4 = v21;
      v20[23] = (uint64_t)a1 + 186;
    }
    else
    {
      unsigned int v21 = 0;
    }
    uint64_t v22 = (uint64_t)a1[10];
    if (!v22)
    {
LABEL_22:
      uint64_t v26 = heap_Calloc((void *)(*a1)[1], v21, 8);
      a1[20] = (uint64_t *)v26;
      uint64_t v27 = *a1;
      if (!v26)
      {
        uint64_t v25 = 42000;
LABEL_44:
        log_OutPublic(v27[4], (uint64_t)"FE_DEPES", v25, 0, v16, v17, v18, v19, v38);
        uint64_t inited = v8;
        goto LABEL_45;
      }
      uint64_t v28 = heap_Calloc((void *)v27[1], (unsigned __int16)*a4, 8);
      a1[21] = (uint64_t *)v28;
      if (v28)
      {
        int v29 = (__int16)*a4;
        *((_WORD *)a1 + 92) = *a4;
        if (v29 >= 1)
        {
          uint64_t v30 = 0;
          do
          {
            a1[20][v30] = 0;
            a1[20][v30] = heap_Alloc((*a1)[1], 3172);
            if (!a1[20][v30]) {
              goto LABEL_41;
            }
            a1[21][v30] = 0;
            a1[21][v30] = heap_Alloc((*a1)[1], 12688);
            if (!a1[21][v30]) {
              goto LABEL_41;
            }
            if (a1[9])
            {
              *(void *)(a1[18][187] + 8 * v30) = a1[20][v30];
              *(void *)(a1[18][188] + 8 * v30) = a1[21][v30];
            }
            if (a1[10])
            {
              *(void *)(a1[19][187] + 8 * v30) = a1[20][v30];
              *(void *)(a1[19][188] + 8 * v30) = a1[21][v30];
            }
          }
          while (++v30 < *((__int16 *)a1 + 92));
        }
        uint64_t v35 = heap_Calloc((void *)(*a1)[1], 3172, 1);
        a1[22] = (uint64_t *)v35;
        if (!v35)
        {
LABEL_41:
          log_OutPublic((*a1)[4], (uint64_t)"FE_DEPES", 42000, 0, v31, v32, v33, v34, v38);
          return v8;
        }
        if (a1[9]) {
          a1[18][195] = v35;
        }
        if (a1[10]) {
          a1[19][195] = v35;
        }
        if ((inited & 0x80000000) == 0)
        {
LABEL_46:
          log_OutText((*a1)[4], (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_InitModule", v32, v33, v34, v38);
          return inited;
        }
LABEL_45:
        fe_depes_ExitModule(a1, a2);
        goto LABEL_46;
      }
      uint64_t v25 = 42000;
LABEL_43:
      uint64_t v27 = *a1;
      goto LABEL_44;
    }
    uint64_t v23 = (uint64_t)a1[19];
    if (v23)
    {
      uint64_t inited = hlp_InitData((uint64_t)a1, *a1, a3, 0, (uint64_t)(a1 + 57), v22, *((unsigned int *)a1 + 35), v23);
      if ((inited & 0x80000000) != 0) {
        goto LABEL_45;
      }
      int v24 = a1[19];
      if (!*a4)
      {
        unsigned int v21 = *((unsigned __int16 *)v24 + 12);
        goto LABEL_21;
      }
      if ((unsigned __int16)*a4 == *((__int16 *)v24 + 12))
      {
        unsigned int v21 = *((unsigned __int16 *)v24 + 12);
LABEL_21:
        *a4 = v21;
        v24[23] = (uint64_t)a1 + 186;
        goto LABEL_22;
      }
LABEL_19:
      uint64_t v8 = 2305826841;
      uint64_t v25 = 42003;
      goto LABEL_43;
    }
LABEL_18:
    uint64_t inited = 2305826823;
    goto LABEL_45;
  }
  return 2305826824;
}

uint64_t fe_depes_ObjClose(void *a1, int a2)
{
  uint64_t result = safeh_HandleCheck((uint64_t)a1, a2, 62334, 712);
  if ((result & 0x80000000) != 0) {
    return 2305826824;
  }
  if (a1)
  {
    log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_ObjClose", v5, v6, v7, v15);
    objc_ReleaseObject(*(void *)(*a1 + 48), (uint64_t)"FE_DCTLKP");
    fe_depes_ExitModule(a1, a2);
    uint64_t v11 = a1[18];
    if (v11)
    {
      heap_Free(*(void **)(*a1 + 8), v11);
      a1[18] = 0;
    }
    uint64_t v12 = a1[19];
    if (v12)
    {
      heap_Free(*(void **)(*a1 + 8), v12);
      a1[19] = 0;
    }
    uint64_t v13 = a1[9];
    if (v13)
    {
      brk_DataClose(*(void *)(*a1 + 24), v13);
      a1[9] = 0;
    }
    uint64_t v14 = a1[10];
    if (v14)
    {
      brk_DataClose(*(void *)(*a1 + 24), v14);
      a1[10] = 0;
    }
    log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_ObjClose", v8, v9, v10, v16);
    heap_Free(*(void **)(*a1 + 8), (uint64_t)a1);
    return 0;
  }
  return result;
}

uint64_t fe_depes_ObjReopen(uint64_t a1, int a2)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  uint64_t inited = 2305826826;
  HIWORD(v31) = 0;
  __src[0] = 0;
  Lnguint64_t BrokerString = safeh_HandleCheck(a1, a2, 62334, 712);
  if ((LngBrokerString & 0x80000000) != 0) {
    return 2305826824;
  }
  if (!a1) {
    return LngBrokerString;
  }
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_ObjReopen", v6, v7, v8, v31);
  fe_depes_ExitModule((void *)a1, a2);
  uint64_t v9 = *(void *)(a1 + 144);
  if (v9)
  {
    heap_Free(*(void **)(*(void *)a1 + 8), v9);
    *(void *)(a1 + 144) = 0;
  }
  uint64_t v10 = *(void *)(a1 + 152);
  if (v10)
  {
    heap_Free(*(void **)(*(void *)a1 + 8), v10);
    *(void *)(a1 + 152) = 0;
  }
  uint64_t v12 = (void *)(a1 + 72);
  uint64_t v11 = *(void *)(a1 + 72);
  if (v11)
  {
    brk_DataClose(*(void *)(*(void *)a1 + 24), v11);
    *(void *)(a1 + 72) = 0;
  }
  uint64_t v14 = (void *)(a1 + 80);
  uint64_t v13 = *(void *)(a1 + 80);
  if (v13) {
    brk_DataClose(*(void *)(*(void *)a1 + 24), v13);
  }
  *(_WORD *)(a1 + 184) = 0;
  *(void *)(a1 + 176) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = 0;
  *(_DWORD *)(a1 + 186) = 3172;
  *(void *)(a1 + 192) = 0;
  *uint64_t v12 = 0;
  *(void *)(a1 + 80) = 0;
  if ((hlp_CreateLngBrokerString(*(void *)a1, __src, 0) & 0x80000000) != 0
    || (hlp_OpenData(*(void *)a1, (uint64_t)__src, (uint64_t *)(a1 + 72), (_DWORD *)(a1 + 136)) & 0x80000000) != 0
    || !*v12)
  {
    Lnguint64_t BrokerString = hlp_CreateLngBrokerString(*(void *)a1, __src, 1);
    if ((LngBrokerString & 0x80000000) != 0) {
      return LngBrokerString;
    }
    Lnguint64_t BrokerString = hlp_OpenData(*(void *)a1, (uint64_t)__src, (uint64_t *)(a1 + 72), (_DWORD *)(a1 + 136));
    if ((LngBrokerString & 0x80000000) != 0) {
      return LngBrokerString;
    }
  }
  __strcpy_chk();
  if ((hlp_CreateVoiceBrokerString_0(*(void *)a1, __src, 0, 0) & 0x80000000) != 0
    || (hlp_OpenData(*(void *)a1, (uint64_t)__src, (uint64_t *)(a1 + 80), (_DWORD *)(a1 + 140)) & 0x80000000) != 0
    || !*v14)
  {
    Lnguint64_t BrokerString = hlp_CreateVoiceBrokerString_0(*(void *)a1, __src, 1, 1);
    if ((LngBrokerString & 0x80000000) != 0) {
      return LngBrokerString;
    }
    if ((hlp_OpenData(*(void *)a1, (uint64_t)__src, (uint64_t *)(a1 + 80), (_DWORD *)(a1 + 140)) & 0x80000000) != 0
      || !*v14)
    {
      Lnguint64_t BrokerString = hlp_CreateVoiceBrokerString_0(*(void *)a1, __src, 1, 0);
      if ((LngBrokerString & 0x80000000) != 0) {
        return LngBrokerString;
      }
      Lnguint64_t BrokerString = hlp_OpenData(*(void *)a1, (uint64_t)__src, (uint64_t *)(a1 + 80), (_DWORD *)(a1 + 140));
      if ((LngBrokerString & 0x80000000) != 0) {
        return LngBrokerString;
      }
    }
  }
  strcpy((char *)(a1 + 456), __src);
  if (!*(void *)(a1 + 72))
  {
    if (!*v14)
    {
      log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 42002, 0, v15, v16, v17, v18, v31);
      return 2305826819;
    }
    goto LABEL_32;
  }
  uint64_t v19 = heap_Calloc(*(void **)(*(void *)a1 + 8), 1, 2136);
  *(void *)(a1 + 144) = v19;
  if (!v19) {
    goto LABEL_36;
  }
  *(void *)(v19 + 1560) = 0;
  *(_OWORD *)(v19 + 1496) = 0u;
  *(_OWORD *)(v19 + 1512) = 0u;
  *(void *)(v19 + 1528) = *(void *)(*(void *)a1 + 8);
  *(_OWORD *)(v19 + 1536) = *(_OWORD *)(a1 + 48);
  uint64_t v24 = *(void *)(a1 + 144);
  *(void *)(v24 + 1552) = *(void *)(a1 + 64);
  *(void *)uint64_t v24 = 0;
  *(_OWORD *)(v24 + 2120) = 0u;
  if (*(void *)(a1 + 80))
  {
LABEL_32:
    uint64_t v26 = heap_Calloc(*(void **)(*(void *)a1 + 8), 1, 2136);
    *(void *)(a1 + 152) = v26;
    if (v26)
    {
      *(void *)(v26 + 1560) = 0;
      *(_OWORD *)(v26 + 1496) = 0u;
      *(_OWORD *)(v26 + 1512) = 0u;
      *(void *)(v26 + 1528) = *(void *)(*(void *)a1 + 8);
      *(_OWORD *)(v26 + 1536) = *(_OWORD *)(a1 + 48);
      uint64_t v27 = *(void *)(a1 + 152);
      *(void *)(v27 + 1552) = *(void *)(a1 + 64);
      *(void *)uint64_t v27 = 0;
      *(_OWORD *)(v27 + 2120) = 0u;
      goto LABEL_34;
    }
LABEL_36:
    log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 42000, 0, v20, v21, v22, v23, v31);
    return inited;
  }
LABEL_34:
  uint64_t inited = fe_depes_InitModule((uint64_t **)a1, a2, "fe_depes", (_WORD *)&v31 + 3);
  if ((inited & 0x80000000) == 0) {
    log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_ObjReopen", v28, v29, v30, v31);
  }
  return inited;
}

uint64_t fe_depes_ExitModule(void *a1, int a2)
{
  if ((safeh_HandleCheck((uint64_t)a1, a2, 62334, 712) & 0x80000000) != 0) {
    return 2305826824;
  }
  log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_ExitModule", v3, v4, v5, v19);
  uint64_t v9 = a1[20];
  if (v9)
  {
    if (*((__int16 *)a1 + 92) >= 1)
    {
      uint64_t v10 = 0;
      do
      {
        uint64_t v11 = *(void *)(a1[20] + 8 * v10);
        if (v11)
        {
          heap_Free(*(void **)(*a1 + 8), v11);
          *(void *)(a1[20] + 8 * v10) = 0;
        }
        if (a1[9]) {
          *(void *)(*(void *)(a1[18] + 1496) + 8 * v10) = 0;
        }
        if (a1[10]) {
          *(void *)(*(void *)(a1[19] + 1496) + 8 * v10) = 0;
        }
        ++v10;
      }
      while (v10 < *((__int16 *)a1 + 92));
      uint64_t v9 = a1[20];
    }
    heap_Free(*(void **)(*a1 + 8), v9);
    a1[20] = 0;
  }
  uint64_t v12 = a1[21];
  if (v12)
  {
    if (*((__int16 *)a1 + 92) >= 1)
    {
      uint64_t v13 = 0;
      do
      {
        uint64_t v14 = *(void *)(a1[21] + 8 * v13);
        if (v14)
        {
          heap_Free(*(void **)(*a1 + 8), v14);
          *(void *)(a1[21] + 8 * v13) = 0;
        }
        if (a1[9]) {
          *(void *)(*(void *)(a1[18] + 1504) + 8 * v13) = 0;
        }
        if (a1[10]) {
          *(void *)(*(void *)(a1[19] + 1504) + 8 * v13) = 0;
        }
        ++v13;
      }
      while (v13 < *((__int16 *)a1 + 92));
      uint64_t v12 = a1[21];
    }
    heap_Free(*(void **)(*a1 + 8), v12);
    a1[21] = 0;
  }
  uint64_t v15 = a1[22];
  if (v15)
  {
    heap_Free(*(void **)(*a1 + 8), v15);
    a1[22] = 0;
  }
  if (a1[9])
  {
    hlp_ExitData((_WORD *)a1[2], a1[3], (_WORD *)a1[4], a1[5], a1[18], a1[11], a1[14], a1[13]);
    uint64_t v16 = (void *)a1[18];
    if (v16) {
      *uint64_t v16 = 0;
    }
    a1[13] = 0;
    a1[14] = 0;
  }
  if (a1[10])
  {
    hlp_ExitData((_WORD *)a1[2], a1[3], (_WORD *)a1[4], a1[5], a1[19], a1[12], a1[16], a1[15]);
    uint64_t v17 = (void *)a1[19];
    if (v17) {
      void *v17 = 0;
    }
    a1[15] = 0;
    a1[16] = 0;
  }
  log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_ExitModule", v6, v7, v8, v20);
  return 0;
}

uint64_t hlp_InitData(uint64_t a1, uint64_t *a2, char *a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = a7;
  uint64_t v177 = *MEMORY[0x263EF8340];
  uint64_t v174 = 0;
  uint64_t v175 = 0;
  uint64_t v173 = 0;
  int v171 = 0;
  *(void *)(a8 + 2080) = a2;
  uint64_t U32 = brk_DataMap(a2[3], a6, 72, a7, (uint64_t)&v175);
  if ((U32 & 0x80000000) != 0) {
    return U32;
  }
  int v170 = a4;
  int v17 = LH_stricmp(v175, a3);
  uint64_t v18 = 0;
  unsigned int v19 = 0;
  BOOL v20 = v9 != 0;
  if (v9 && v17)
  {
    uint64_t v18 = 0;
    unsigned int v19 = 0;
    do
    {
      int v21 = strlen(&v175[v18]);
      v19 += v21 + ((~(_BYTE)v21 - (_BYTE)v19) & 3) + 9;
      uint64_t v18 = v19;
      int v22 = LH_stricmp(&v175[v19], a3);
      BOOL v20 = v19 < v9;
    }
    while (v19 < v9 && v22 != 0);
  }
  if (!v20)
  {
    brk_DataUnmap(a2[3], a6, (uint64_t)v175);
    return 2305826820;
  }
  int v24 = strlen(&v175[v18]);
  unsigned int v25 = (v19 + v24 + ((~(_BYTE)v24 - (_BYTE)v19) & 3) + 1) >> 2;
  int v171 = *(_DWORD *)&v175[4 * v25];
  unsigned int v26 = *(_DWORD *)&v175[4 * v25 + 4];
  brk_DataUnmap(a2[3], a6, (uint64_t)v175);
  uint64_t U32 = brk_DataMapRefCnt(*(_WORD **)(a1 + 16), *(void *)(a1 + 24), *(_WORD **)(a1 + 32), *(void *)(a1 + 40), a5, v171, v26, &v174);
  if ((U32 & 0x80000000) != 0) {
    return U32;
  }
  uint64_t v30 = v174;
  uint64_t v31 = 88;
  if (!v170) {
    uint64_t v31 = 96;
  }
  *(void *)(a1 + v31) = v174;
  uint64_t v32 = *(char **)(v30 + 264);
  uint64_t v175 = v32;
  *(void *)a8 = v32;
  unsigned int v172 = 0;
  uint64_t U32 = hlp_GetU32((uint64_t)a2, (uint64_t)v32, v26, &v172, (_DWORD *)(a8 + 8), v27, v28, v29);
  if ((U32 & 0x80000000) != 0) {
    return U32;
  }
  uint64_t v36 = 2305826825;
  uint64_t v37 = v175;
  unsigned int v38 = *(_DWORD *)(a8 + 8);
  uint64_t v39 = v172;
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v33, v34, v35, v38);
  if (v39 + v38 > v26) {
    return v36;
  }
  *(void *)(a8 + 16) = &v37[v39];
  unsigned int v172 = v39 + v38;
  uint64_t U32 = hlp_GetU32((uint64_t)a2, (uint64_t)v175, v26, &v172, &v171, v40, v41, v42);
  if ((U32 & 0x80000000) != 0) {
    return U32;
  }
  *(_WORD *)(a8 + 24) = v171;
  __int16 v46 = (unsigned int *)(a8 + 28);
  uint64_t U32 = hlp_GetU32((uint64_t)a2, (uint64_t)v175, v26, &v172, (_DWORD *)(a8 + 28), v43, v44, v45);
  if ((U32 & 0x80000000) != 0) {
    return U32;
  }
  uint64_t U32 = hlp_GetU32((uint64_t)a2, (uint64_t)v175, v26, &v172, (_DWORD *)(a8 + 32), v47, v48, v49);
  if ((U32 & 0x80000000) != 0) {
    return U32;
  }
  uint64_t U32 = hlp_GetU32((uint64_t)a2, (uint64_t)v175, v26, &v172, (_DWORD *)(a8 + 36), v50, v51, v52);
  if ((U32 & 0x80000000) != 0) {
    return U32;
  }
  uint64_t U32 = hlp_GetU32((uint64_t)a2, (uint64_t)v175, v26, &v172, (_DWORD *)(a8 + 40), v53, v54, v55);
  if ((U32 & 0x80000000) != 0) {
    return U32;
  }
  uint64_t U32 = hlp_GetU32((uint64_t)a2, (uint64_t)v175, v26, &v172, &v171, v56, v57, v58);
  if ((U32 & 0x80000000) != 0) {
    return U32;
  }
  *(_WORD *)(a8 + 46) = v171;
  uint64_t U32 = hlp_GetU32((uint64_t)a2, (uint64_t)v175, v26, &v172, &v171, v59, v60, v61);
  if ((U32 & 0x80000000) != 0) {
    return U32;
  }
  *(_WORD *)(a8 + 44) = v171;
  uint64_t U32 = hlp_GetU32((uint64_t)a2, (uint64_t)v175, v26, &v172, (_DWORD *)(a8 + 48), v62, v63, v64);
  if ((U32 & 0x80000000) != 0) {
    return U32;
  }
  __int16 v68 = v175;
  int v69 = *v46;
  uint64_t v70 = v172;
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v65, v66, v67, *v46);
  unsigned int v71 = v70 + v69;
  if (v71 > v26) {
    return v36;
  }
  *(void *)(a8 + 56) = &v68[v70];
  uint64_t v72 = heap_Alloc(a2[1], 8 * *(unsigned int *)(a8 + 28));
  *(void *)(a8 + 1520) = v72;
  if (!v72)
  {
LABEL_61:
    uint64_t v163 = a2[4];
    goto LABEL_62;
  }
  int v77 = *v46;
  if ((int)(*v46 << 16) >= 1)
  {
    __int16 v78 = 0;
    do
    {
      uint64_t v169 = v72;
      uint64_t v79 = v175;
      uint64_t v80 = v78;
      log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v74, v75, v76, 1);
      if (v71 + 1 <= v26) {
        *(void *)(v169 + 8 * v80) = &v79[v71++];
      }
      uint64_t v72 = *(void *)(a8 + 1520);
      if (**(unsigned char **)(v72 + 8 * v80))
      {
        while (v175[v71++])
          ;
      }
      __int16 v78 = v80 + 1;
      int v77 = *v46;
    }
    while ((__int16)*v46 > (__int16)(v80 + 1));
  }
  unsigned int v172 = v71;
  uint64_t U32 = hlp_GetU16Ptr((uint64_t)a2, (uint64_t)v175, v26, &v172, (2 * v77), (void *)(a8 + 64), v75, v76);
  if ((U32 & 0x80000000) != 0) {
    return U32;
  }
  uint64_t U32 = hlp_GetU16Ptr((uint64_t)a2, (uint64_t)v175, v26, &v172, (2 * *(_DWORD *)(a8 + 28)), (void *)(a8 + 72), v82, v83);
  if ((U32 & 0x80000000) != 0) {
    return U32;
  }
  int v87 = v175;
  int v88 = *(_DWORD *)(a8 + 32);
  uint64_t v89 = v172;
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v84, v85, v86, (v88 << 8));
  unsigned int v93 = v89 + (v88 << 8);
  if (v93 > v26) {
    return v36;
  }
  *(void *)(a8 + 80) = &v87[v89];
  uint64_t v94 = v175;
  int v95 = *(_DWORD *)(a8 + 36);
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v90, v91, v92, (v95 << 8));
  unsigned int v99 = v93 + (v95 << 8);
  if (v99 > v26) {
    return v36;
  }
  *(void *)(a8 + 88) = &v94[v93];
  __int16 v100 = v175;
  int v101 = *(_DWORD *)(a8 + 36);
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v96, v97, v98, (v101 << 8));
  unsigned int v105 = v99 + (v101 << 8);
  if (v105 > v26) {
    return v36;
  }
  *(void *)(a8 + 96) = &v100[v99];
  int v106 = v175;
  __int16 v107 = *(_WORD *)(a8 + 46);
  int v108 = 2 * (v107 & 0x7FFF);
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v102, v103, v104, 2 * (v107 & 0x7FFF));
  if (v105 + v108 > v26) {
    return v36;
  }
  *(void *)(a8 + 104) = &v106[v105];
  unsigned int v172 = v105 + v108;
  uint64_t U32 = hlp_GetU32Ptr((uint64_t)a2, (uint64_t)v175, v26, &v172, 4 * (*(_WORD *)(a8 + 44) & 0x3FFFu), (void *)(a8 + 112), v109, v110);
  if ((U32 & 0x80000000) != 0) {
    return U32;
  }
  uint64_t v114 = v175;
  int v115 = *(unsigned __int16 *)(a8 + 44);
  uint64_t v116 = v172;
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v111, v112, v113, *(unsigned __int16 *)(a8 + 44));
  unsigned int v120 = v116 + v115;
  if (v120 > v26) {
    return v36;
  }
  *(void *)(a8 + 120) = &v114[v116];
  int v121 = v175;
  int v122 = *(unsigned __int16 *)(a8 + 44);
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v117, v118, v119, *(unsigned __int16 *)(a8 + 44));
  unsigned int v126 = v120 + v122;
  if (v126 > v26) {
    return v36;
  }
  *(void *)(a8 + 128) = &v121[v120];
  unsigned int v127 = v175;
  int v128 = *(unsigned __int16 *)(a8 + 44);
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v123, v124, v125, *(unsigned __int16 *)(a8 + 44));
  unsigned int v132 = v126 + v128;
  if (v132 > v26) {
    return v36;
  }
  *(void *)(a8 + 136) = &v127[v126];
  __int16 v133 = v175;
  int v134 = *(unsigned __int16 *)(a8 + 44);
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v129, v130, v131, *(unsigned __int16 *)(a8 + 44));
  unsigned int v138 = v132 + v134;
  if (v138 > v26) {
    return v36;
  }
  *(void *)(a8 + 144) = &v133[v132];
  int v139 = v175;
  int v140 = *(unsigned __int16 *)(a8 + 44);
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v135, v136, v137, *(unsigned __int16 *)(a8 + 44));
  unsigned int v144 = v138 + v140;
  if (v144 > v26) {
    return v36;
  }
  *(void *)(a8 + 152) = &v139[v138];
  uint64_t v145 = v175;
  int v146 = *(unsigned __int16 *)(a8 + 44);
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v141, v142, v143, *(unsigned __int16 *)(a8 + 44));
  unsigned int v150 = v144 + v146;
  if (v150 > v26) {
    return v36;
  }
  *(void *)(a8 + 160) = &v145[v144];
  int v151 = v175;
  int v152 = *(unsigned __int16 *)(a8 + 44);
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v147, v148, v149, *(unsigned __int16 *)(a8 + 44));
  unsigned int v156 = v150 + v152;
  if (v156 > v26) {
    return v36;
  }
  *(void *)(a8 + 168) = &v151[v150];
  uint64_t v157 = v175;
  unsigned int v158 = *(_DWORD *)(a8 + 48);
  log_OutText(a2[4], (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U8 buffer of size %u at offset %u", v153, v154, v155, v158);
  if (v158 + v156 > v26) {
    return v36;
  }
  *(void *)(a8 + 176) = &v157[v156];
  uint64_t v159 = heap_Calloc((void *)a2[1], *(__int16 *)(a8 + 24), 8);
  *(void *)(a8 + 1496) = v159;
  if (!v159) {
    goto LABEL_61;
  }
  uint64_t v160 = heap_Calloc((void *)a2[1], *(__int16 *)(a8 + 24), 8);
  *(void *)(a8 + 1504) = v160;
  if (!v160) {
    goto LABEL_61;
  }
  uint64_t v161 = heap_Calloc((void *)a2[1], (*(__int16 *)(a8 + 24) + 1), 2);
  *(void *)(a8 + 1416) = v161;
  if (!v161) {
    goto LABEL_61;
  }
  uint64_t v162 = heap_Alloc(a2[1], 5 * (unsigned __int16)(*(_WORD *)(a8 + 46) + 1));
  *(void *)(a8 + 1512) = v162;
  uint64_t v163 = a2[4];
  if (!v162)
  {
LABEL_62:
    log_OutPublic(v163, (uint64_t)"FE_DEPES", 42000, 0, v73, v74, v75, v76, v168);
    return 2305826826;
  }
  *(_WORD *)(a8 + 2088) = log_GetLogLevel(v163);
  __strcpy_chk();
  __strcat_chk();
  uint64_t U32 = hlp_SetupNewFeatRefCnt(*(_WORD **)(a1 + 16), *(void *)(a1 + 24), *(_WORD **)(a1 + 32), *(void *)(a1 + 40), (uint64_t)v176, *(void *)(a8 + 80), *(_DWORD *)(a8 + 32), &v173);
  if ((U32 & 0x80000000) != 0) {
    return U32;
  }
  uint64_t v164 = v173;
  *(void *)(a8 + 2120) = *(void *)(v173 + 272);
  uint64_t v165 = 112;
  if (!v170) {
    uint64_t v165 = 128;
  }
  *(void *)(a1 + v165) = v164;
  __strcpy_chk();
  __strcat_chk();
  uint64_t v36 = hlp_SetupNewFeatRefCnt(*(_WORD **)(a1 + 16), *(void *)(a1 + 24), *(_WORD **)(a1 + 32), *(void *)(a1 + 40), (uint64_t)v176, *(void *)(a8 + 88), *(_DWORD *)(a8 + 36), &v173);
  if ((v36 & 0x80000000) == 0)
  {
    uint64_t v166 = v173;
    *(void *)(a8 + 2128) = *(void *)(v173 + 272);
    if (v170) {
      *(void *)(a1 + 104) = v166;
    }
    else {
      *(void *)(a1 + 120) = v166;
    }
  }
  return v36;
}

uint64_t fe_depes_SetLayerUtf8(__int16 *a1, int a2, signed int a3, const void *a4, int a5)
{
  uint64_t v10 = 2305826823;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 62334, 712) & 0x80000000) != 0) {
    return 2305826824;
  }
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_SetLayer", v11, v12, v13, v22);
  if (a4 && a3 < a1[92])
  {
    uint64_t v10 = fe_depes_SetLayerExUtf8(a1, a2, a3, a4, a5);
    if ((v10 & 0x80000000) == 0) {
      log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_SetLayer", v18, v19, v20, v23);
    }
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 42001, 0, v14, v15, v16, v17, v23);
  }
  return v10;
}

uint64_t fe_depes_SetLayerExUtf8(__int16 *a1, int a2, unsigned int a3, const void *a4, int a5)
{
  LODWORD(v5) = a5;
  uint64_t v9 = safeh_HandleCheck((uint64_t)a1, a2, 62334, 712);
  if ((v9 & 0x80000000) != 0) {
    return 2305826824;
  }
  uint64_t v13 = v9;
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_SetLayerEx", v10, v11, v12, v36);
  if (a4)
  {
    int v17 = a1[92];
    if ((int)a3 < v17)
    {
      if (v5 >= 0x2710) {
        size_t v5 = 10000;
      }
      else {
        size_t v5 = v5;
      }
      uint64_t v18 = (3 * v5);
      if ((int)v18 > a1[93])
      {
        if (v17 > 0)
        {
          uint64_t v19 = 0;
          do
          {
            uint64_t v20 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(*((void *)a1 + 20) + 8 * v19), (3 * v5));
            if (!v20) {
              goto LABEL_40;
            }
            *(void *)(*((void *)a1 + 20) + 8 * v19) = v20;
            if (*((void *)a1 + 9)) {
              *(void *)(*(void *)(*((void *)a1 + 18) + 1496) + 8 * v19) = *(void *)(*((void *)a1 + 20)
            }
                                                                                            + 8 * v19);
            if (*((void *)a1 + 10)) {
              *(void *)(*(void *)(*((void *)a1 + 19) + 1496) + 8 * v19) = *(void *)(*((void *)a1 + 20)
            }
                                                                                            + 8 * v19);
            if ((int)v18 > a1[93])
            {
              uint64_t v25 = a1[93];
              do
                *(unsigned char *)(*(void *)(*((void *)a1 + 20) + 8 * v19) + v25++) = 32;
              while (v18 != v25);
            }
            uint64_t v26 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(*((void *)a1 + 21) + 8 * v19), 4 * (3 * v5));
            if (!v26) {
              goto LABEL_40;
            }
            *(void *)(*((void *)a1 + 21) + 8 * v19) = v26;
            if (*((void *)a1 + 9)) {
              *(void *)(*(void *)(*((void *)a1 + 18) + 1504) + 8 * v19) = *(void *)(*((void *)a1 + 21)
            }
                                                                                            + 8 * v19);
            if (*((void *)a1 + 10)) {
              *(void *)(*(void *)(*((void *)a1 + 19) + 1504) + 8 * v19) = *(void *)(*((void *)a1 + 21)
            }
                                                                                            + 8 * v19);
            if ((int)v18 > a1[93]) {
              memset_pattern16((void *)(*(void *)(*((void *)a1 + 21) + 8 * v19) + 4 * a1[93]), &unk_20D62D560, 4 * (v18 + ~a1[93]) + 4);
            }
          }
          while (++v19 < a1[92]);
        }
        uint64_t v27 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *((void *)a1 + 22), (3 * v5));
        if (!v27)
        {
LABEL_40:
          log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 42000, 0, v21, v22, v23, v24, v37);
          return 2305826826;
        }
        *((void *)a1 + 22) = v27;
        if (*((void *)a1 + 9)) {
          *(void *)(*((void *)a1 + 18) + 1560) = v27;
        }
        if (*((void *)a1 + 10)) {
          *(void *)(*((void *)a1 + 19) + 1560) = v27;
        }
        if ((int)v18 > a1[93])
        {
          uint64_t v28 = a1[93];
          do
            *(unsigned char *)(*((void *)a1 + 22) + v28++) = 0;
          while (v18 != v28);
        }
        a1[93] = 3 * v5;
      }
      uint64_t v29 = a3;
      memcpy(*(void **)(*((void *)a1 + 20) + 8 * a3), a4, v5);
      memset((void *)(*(void *)(*((void *)a1 + 20) + 8 * a3) + v5), 32, (unsigned __int16)a1[93] - (unint64_t)v5);
      if (a3)
      {
        int v30 = a1[94];
        if (v30 >= (__int16)Utf8_LengthInUtf8chars(*(void *)(*((void *)a1 + 20) + 8 * v29), v5)) {
          goto LABEL_45;
        }
      }
      else if ((unsigned __int16)a1[92] >= 2u)
      {
        unint64_t v34 = 1;
        do
          memset(*(void **)(*((void *)a1 + 20) + 8 * v34++), 32, (unsigned __int16)a1[93]);
        while (v34 < (unsigned __int16)a1[92]);
      }
      a1[94] = Utf8_LengthInUtf8chars(*(void *)(*((void *)a1 + 20) + 8 * v29), v5);
LABEL_45:
      log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_SetLayerEx", v31, v32, v33, v37);
      return v13;
    }
  }
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Layer %d not defined in depes grammar", v14, v15, v16, a3 + 1);
  return v13;
}

uint64_t fe_depes_SetMarker(uint64_t a1, int a2, const void *a3, int a4)
{
  LODWORD(v4) = a4;
  uint64_t v7 = 2305826823;
  uint64_t v8 = safeh_HandleCheck(a1, a2, 62334, 712);
  if ((v8 & 0x80000000) != 0) {
    return 2305826824;
  }
  uint64_t v12 = v8;
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_SetMarker", v9, v10, v11, v21);
  if (v4 >= 0x2710) {
    size_t v4 = 10000;
  }
  else {
    size_t v4 = v4;
  }
  if (a3 && *(__int16 *)(a1 + 188) >= (__int16)v4)
  {
    memcpy(*(void **)(a1 + 176), a3, v4);
    bzero((void *)(*(void *)(a1 + 176) + v4), *(unsigned __int16 *)(a1 + 186) - (unint64_t)v4);
    log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_SetMarker", v17, v18, v19, v22);
    return v12;
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 42001, 0, v13, v14, v15, v16, v22);
  }
  return v7;
}

uint64_t fe_depes_GetLayerUtf8(uint64_t a1, int a2, unsigned int a3, void *a4, _WORD *a5)
{
  uint64_t v9 = 2305826823;
  uint64_t v10 = safeh_HandleCheck(a1, a2, 62334, 712);
  if ((v10 & 0x80000000) != 0) {
    return 2305826824;
  }
  uint64_t v14 = v10;
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_GetLayer", v11, v12, v13, v23);
  if (a4 && (int)a3 < *(__int16 *)(a1 + 184))
  {
    *a5 = Utf8_LengthInBytes(*(unsigned __int8 **)(*(void *)(a1 + 160) + 8 * a3), *(__int16 *)(a1 + 188));
    *a4 = *(void *)(*(void *)(a1 + 160) + 8 * a3);
    log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_GetLayer", v19, v20, v21, v24);
    return v14;
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 42001, 0, v15, v16, v17, v18, v24);
  }
  return v9;
}

uint64_t fe_depes_GetNrLayers(_WORD *a1, int a2, _WORD *a3)
{
  uint64_t v5 = safeh_HandleCheck((uint64_t)a1, a2, 62334, 712);
  if ((v5 & 0x80000000) != 0) {
    return 2305826824;
  }
  uint64_t v9 = v5;
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_GetNrLayers", v6, v7, v8, v14);
  *a3 = a1[92];
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_GetNrLayers", v10, v11, v12, v15);
  return v9;
}

uint64_t fe_depes_GetMarker(uint64_t a1, int a2, void *a3, _WORD *a4)
{
  uint64_t v7 = 2305826823;
  uint64_t v8 = safeh_HandleCheck(a1, a2, 62334, 712);
  if ((v8 & 0x80000000) != 0) {
    return 2305826824;
  }
  uint64_t v12 = v8;
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_GetMarker", v9, v10, v11, v18);
  if (a3)
  {
    *a4 = *(_WORD *)(a1 + 188);
    *a3 = *(void *)(a1 + 176);
    log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_GetMarker", v14, v15, v16, v19);
    return v12;
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 42001, 0, v13, v14, v15, v16, v19);
  }
  return v7;
}

double hlp_ExitData(_WORD *a1, int a2, _WORD *a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  if (a5 && (InitRsrcFunction(a1, a2, &v23) & 0x80000000) == 0 && (InitRsrcFunction(a3, a4, &v22) & 0x80000000) == 0)
  {
    if (*(void *)a5) {
      brk_DataMapDeRefCnt(a1, a2, a3, a4, a6);
    }
    uint64_t v17 = *(void *)(a5 + 1496);
    if (v17)
    {
      heap_Free(*(void **)(v23 + 8), v17);
      *(void *)(a5 + 1496) = 0;
    }
    uint64_t v18 = *(void *)(a5 + 1504);
    if (v18)
    {
      heap_Free(*(void **)(v23 + 8), v18);
      *(void *)(a5 + 1504) = 0;
    }
    uint64_t v19 = *(void *)(a5 + 1416);
    if (v19)
    {
      heap_Free(*(void **)(v23 + 8), v19);
      *(void *)(a5 + 1416) = 0;
    }
    uint64_t v20 = *(void *)(a5 + 1512);
    if (v20)
    {
      heap_Free(*(void **)(v23 + 8), v20);
      *(void *)(a5 + 1512) = 0;
    }
    uint64_t v21 = *(void *)(a5 + 1520);
    if (v21)
    {
      heap_Free(*(void **)(v23 + 8), v21);
      *(void *)(a5 + 1520) = 0;
    }
    hlp_SetupNewFeatDeRefCnt(a1, a2, a3, a4, a7);
    hlp_SetupNewFeatDeRefCnt(a1, a2, a3, a4, a8);
    double result = 0.0;
    *(_OWORD *)(a5 + 2120) = 0u;
  }
  return result;
}

uint64_t fe_depes_ExistModule(void *a1, int a2, char *a3)
{
  unsigned int v15 = 0;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 62334, 712) & 0x80000000) == 0)
  {
    log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_ExistModule for %s", v5, v6, v7, (uint64_t)a3);
    if (a1[10])
    {
      BOOL exist = hlp_ExistModule(a3, a1[19], &v15);
      if (exist || !a1[9])
      {
        if (exist)
        {
          uint64_t v12 = 1;
LABEL_12:
          log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_ExistModule", v8, v9, v10, v14);
          return v12;
        }
        goto LABEL_11;
      }
    }
    else if (!a1[9])
    {
      goto LABEL_11;
    }
    if (hlp_ExistModule(a3, a1[18], &v15))
    {
      uint64_t v12 = 2;
      goto LABEL_12;
    }
LABEL_11:
    log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Module sequence not found", v8, v9, v10, v14);
    uint64_t v12 = 0;
    goto LABEL_12;
  }
  return 0;
}

BOOL hlp_ExistModule(char *a1, uint64_t a2, unsigned int *a3)
{
  *a3 = 0;
  for (__int16 i = *(char **)(a2 + 16); LH_stricmp(i, a1); __int16 i = (char *)(v8 + v11))
  {
    uint64_t v7 = *a3;
    if (v7 >= *(_DWORD *)(a2 + 8)) {
      break;
    }
    uint64_t v8 = *(void *)(a2 + 16);
    int v9 = strlen((const char *)(v8 + v7));
    unsigned int v10 = v7 + v9 + ((~(_BYTE)v9 - (_BYTE)v7) & 3) + 1;
    *a3 = v10;
    uint64_t v11 = v10 + *(_DWORD *)(v8 + v10) + 4;
    *a3 = v11;
  }
  return *a3 < *(_DWORD *)(a2 + 8);
}

uint64_t fe_depes_ExecModule(uint64_t a1, int a2, char *a3)
{
  uint64_t v5 = 2305826820;
  if ((safeh_HandleCheck(a1, a2, 62334, 712) & 0x80000000) != 0) {
    return 2305826824;
  }
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Entering fe_depes_ExecModule for %s", v6, v7, v8, (uint64_t)a3);
  if (*(void *)(a1 + 80)) {
    uint64_t v5 = hlp_ExecModule(a3, *(void *)(a1 + 152), (__int16 *)(a1 + 188));
  }
  if (*(void *)(a1 + 72) && (v5 & 0x1FFF) == 4) {
    uint64_t v5 = hlp_ExecModule(a3, *(void *)(a1 + 144), (__int16 *)(a1 + 188));
  }
  if ((v5 & 0x80000000) != 0)
  {
    if ((v5 & 0x1FFF) == 4)
    {
      log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Module sequence not found", v10, v11, v12, v15);
    }
    else
    {
      if ((v5 & 0x1FFF) == 0xA) {
        uint64_t v13 = 42000;
      }
      else {
        uint64_t v13 = 42005;
      }
      log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", v13, 0, v9, v10, v11, v12, v15);
    }
  }
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_DEPES", 4, 0, (uint64_t)"Leaving fe_depes_ExecModule", v10, v11, v12, v15);
  return v5;
}

uint64_t hlp_ExecModule(char *a1, uint64_t a2, __int16 *a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  unsigned int v20 = 0;
  if (!hlp_ExistModule(a1, a2, &v20)) {
    return 2305826820;
  }
  uint64_t v5 = *(void *)(a2 + 16);
  int v6 = strlen((const char *)(v5 + v20));
  unsigned int v7 = v20 + v6 + ((~(_BYTE)v6 - (_BYTE)v20) & 3);
  uint64_t v8 = *(unsigned int *)(v5 + v7 + 1);
  if (v8)
  {
    unsigned int v9 = v7 + 5;
    uint64_t v10 = v21;
    uint64_t v11 = v8;
    do
    {
      *v10++ = *(unsigned char *)(v5 + v9++);
      --v11;
    }
    while (v11);
  }
  *(_WORD *)(a2 + 1430) = 0;
  *(unsigned char *)(a2 + 1428) = 0;
  uint64_t v12 = *(_WORD **)(a2 + 184);
  *(_WORD *)(a2 + 1410) = *v12;
  if ((*(__int16 *)(a2 + 24) & 0x80000000) == 0)
  {
    __int16 v13 = 0;
    uint64_t v14 = *(void *)(a2 + 1416);
    do
      *(_WORD *)(v14 + 2 * v13++) = *v12;
    while (*(__int16 *)(a2 + 24) >= v13);
  }
  bzero(*(void **)(a2 + 1512), (5 * *(__int16 *)(a2 + 46) + 5));
  *(_DWORD *)(a2 + 1480) = 1;
  if (!v8) {
    return 0;
  }
  uint64_t v15 = v8 - 1;
  uint64_t v16 = v21;
  do
  {
    uint64_t v17 = v15;
    unsigned int v18 = *v16++;
    uint64_t result = INFERENCE_MAIN(a2, v18, 1, a3);
    if ((result & 0x80000000) != 0) {
      break;
    }
    uint64_t v15 = v17 - 1;
  }
  while (v17);
  return result;
}

uint64_t fe_depes_SetcbInsMrk(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t result = safeh_HandleCheck(a1, a2, 62334, 712);
  if ((result & 0x80000000) != 0) {
    return 2305826824;
  }
  if (a4 == 1) {
    *(_DWORD *)(a1 + 192) = a3;
  }
  else {
    *(_DWORD *)(a1 + 196) = a3;
  }
  return result;
}

uint64_t fe_depes_GetcbInsMrk(uint64_t a1, int a2, _DWORD *a3, int a4)
{
  uint64_t result = safeh_HandleCheck(a1, a2, 62334, 712);
  if ((result & 0x80000000) != 0) {
    return 2305826824;
  }
  uint64_t v8 = 196;
  if (a4 == 1) {
    uint64_t v8 = 192;
  }
  *a3 = *(_DWORD *)(a1 + v8);
  return result;
}

uint64_t hlp_Utf8HashCode(const char *a1, _WORD *a2)
{
  uint64_t v6 = 0;
  unsigned int v4 = strlen(a1);
  uint64_t result = utf8_Utf8ToUtf32((uint64_t)a1, v4, 0, (uint64_t)&v6 + 4, 1u, &v6, 0);
  if ((result & 0x80000000) == 0) {
    *a2 = BYTE4(v6) & 0x3F;
  }
  return result;
}

uint64_t hlp_SetupNewFeatDeRefCnt(_WORD *a1, int a2, _WORD *a3, int a4, uint64_t a5)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v11);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = InitRsrcFunction(a3, a4, &v10);
    if (a5)
    {
      if ((result & 0x80000000) == 0)
      {
        ObjcForThisAp__int16 i = getObjcForThisApi(v11, v10);
        return objc_ReleaseObject(ObjcForThisApi, a5);
      }
    }
  }
  return result;
}

uint64_t fe_depes_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2305826817;
  }
  uint64_t result = 0;
  *a2 = &IFeDepes;
  return result;
}

uint64_t hlp_GetU32(uint64_t a1, uint64_t a2, unsigned int a3, _DWORD *a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v13 = hlp_AlignOffset(a1, *a4, 4, (uint64_t)a4, (uint64_t)a5, a6, a7, a8);
  *a4 = v13;
  log_OutText(*(void *)(a1 + 32), (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U32 at offset %u", v14, v15, v16, v13);
  uint64_t v17 = *a4;
  if ((int)v17 + 4 > a3) {
    return 2305826825;
  }
  uint64_t result = 0;
  *a5 = *(_DWORD *)(a2 + v17);
  *a4 += 4;
  return result;
}

uint64_t hlp_GetU16Ptr(uint64_t a1, uint64_t a2, unsigned int a3, _DWORD *a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8)
{
  *a4 = hlp_AlignOffset(a1, *a4, 2, (uint64_t)a4, a5, (uint64_t)a6, a7, a8);
  log_OutText(*(void *)(a1 + 32), (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U16 buffer of size %u at offset %u", v14, v15, v16, a5);
  uint64_t v17 = *a4;
  if ((int)v17 + (int)a5 > a3) {
    return 2305826825;
  }
  uint64_t result = 0;
  *a6 = a2 + v17;
  *a4 = v17 + a5;
  return result;
}

uint64_t hlp_GetU32Ptr(uint64_t a1, uint64_t a2, unsigned int a3, _DWORD *a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8)
{
  *a4 = hlp_AlignOffset(a1, *a4, 4, (uint64_t)a4, a5, (uint64_t)a6, a7, a8);
  log_OutText(*(void *)(a1 + 32), (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Reading U32 buffer of size %u at offset %u", v14, v15, v16, a5);
  uint64_t v17 = *a4;
  if ((int)v17 + (int)a5 > a3) {
    return 2305826825;
  }
  uint64_t result = 0;
  *a6 = a2 + v17;
  *a4 = v17 + a5;
  return result;
}

uint64_t hlp_SetupNewFeatRefCnt(_WORD *a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, void *a8)
{
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v20 = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v22);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = InitRsrcFunction(a3, a4, &v21);
    if ((result & 0x80000000) == 0)
    {
      v19[0] = a1;
      v19[1] = a2;
      v19[2] = a3;
      void v19[3] = a4;
      v19[4] = a6;
      v19[5] = a7;
      ObjcForThisAp__int16 i = getObjcForThisApi(v22, v21);
      uint64_t result = objc_GetAddRefCountedObject(ObjcForThisApi, a5, (uint64_t (*)(void, void, uint64_t, long long *, uint64_t))hlp_SetupNewFeat_ObjcLoad, (void (*)(void, void, long long *))hlp_SetupNewFeat_ObjcClose, (uint64_t)v19, &v20);
      if ((result & 0x80000000) != 0) {
        uint64_t v18 = 0;
      }
      else {
        uint64_t v18 = *(void *)(v20 + 32);
      }
      *a8 = v18;
    }
  }
  return result;
}

uint64_t hlp_AlignOffset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a2;
  log_OutText(*(void *)(a1 + 32), (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Offset before alignment is %u", a6, a7, a8, a2);
  log_OutText(*(void *)(a1 + 32), (uint64_t)"FE_DEPES", 5, 0, (uint64_t)"Offset after alignment to %u bytes is %u", v11, v12, v13, a3);
  return (v9 + a3 - 1) & -(int)a3;
}

uint64_t hlp_SetupNewFeat_ObjcLoad(_WORD *a1, int a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v50 = *MEMORY[0x263EF8340];
  uint64_t v45 = 0;
  uint64_t v46 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v45);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t inited = InitRsrcFunction(*(_WORD **)(a5 + 16), *(void *)(a5 + 24), &v46);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t v9 = v45;
  uint64_t v10 = *(void *)(a5 + 32);
  uint64_t v11 = *(unsigned int *)(a5 + 40);
  uint64_t v12 = heap_Calloc(*(void **)(v45 + 8), 1, 280);
  *(void *)(a4 + 32) = v12;
  if (!v12
    || (*(void *)(*(void *)(a4 + 32) + 272) = heap_Alloc(*(void *)(v9 + 8), 8 * v11),
        uint64_t v17 = *(void *)(a4 + 32),
        !*(void *)(v17 + 272)))
  {
LABEL_27:
    uint64_t v29 = 2305826826;
    log_OutPublic(*(void *)(v9 + 32), (uint64_t)"FE_DEPES", 42000, 0, v13, v14, v15, v16, v40);
    return v29;
  }
  if (v11)
  {
    unsigned int v40 = a3;
    unsigned __int16 v18 = 0;
    unsigned int v43 = v11;
LABEL_7:
    uint64_t v19 = heap_Alloc(*(void *)(v9 + 8), 512);
    if (v19)
    {
      uint64_t v11 = v19;
      uint64_t v44 = v18;
      uint64_t v20 = (char *)(v10 + ((unint64_t)v18 << 8));
      memset(v49, 0, sizeof(v49));
      unsigned __int16 v21 = strlen(v20);
      uint64_t v22 = 0;
      unsigned int v23 = v21;
      uint64_t v24 = (unsigned __int16)(v21 + 65);
      while (1)
      {
        uint64_t v25 = (unsigned char *)heap_Alloc(*(void *)(v9 + 8), v24);
        *(void *)((char *)v49 + v22) = v25;
        if (!v25) {
          break;
        }
        unsigned char *v25 = 0;
        v22 += 8;
        if (v22 == 512)
        {
          uint64_t v41 = v10;
          uint64_t v42 = a4;
          unsigned __int16 v48 = 64;
          unsigned int Utf8Symbol = utf8_GetUtf8Symbol(v20, 0, v23, __s2);
          if (Utf8Symbol)
          {
            unsigned int v27 = Utf8Symbol;
            unsigned int v28 = 0;
            while (1)
            {
              uint64_t v29 = hlp_Utf8HashCode(__s2, &v48);
              if ((v29 & 0x80000000) != 0) {
                return v29;
              }
              strcat(*((char **)v49 + v48), __s2);
              v28 += v27;
              unsigned int v27 = utf8_GetUtf8Symbol(v20, v28, v23, __s2);
              if (!v27) {
                goto LABEL_17;
              }
            }
          }
          uint64_t v29 = 0;
LABEL_17:
          int v30 = (unsigned char *)heap_Alloc(*(void *)(v9 + 8), v24);
          a4 = v42;
          if (v30)
          {
            uint64_t v31 = v30;
            uint64_t v32 = 0;
            int v33 = 0;
            *int v30 = 0;
            do
            {
              unint64_t v34 = &v31[(unsigned __int16)v33];
              *(void *)(v11 + v32) = v34;
              uint64_t v35 = *(const char **)((char *)v49 + v32);
              strcpy(v34, v35);
              int v36 = strlen(v35);
              v31[(unsigned __int16)(v33 + v36)] = 0;
              v33 += v36 + 1;
              v32 += 8;
            }
            while (v32 != 512);
            uint64_t v37 = 0;
            uint64_t v10 = v41;
            do
            {
              uint64_t v38 = *(void *)((char *)v49 + v37);
              if (v38)
              {
                heap_Free(*(void **)(v9 + 8), v38);
                *(void *)((char *)v49 + v37) = 0;
              }
              v37 += 8;
            }
            while (v37 != 512);
            *(void *)(*(void *)(*(void *)(v42 + 32) + 272) + 8 * v44) = v11;
            unsigned __int16 v18 = v44 + 1;
            LODWORD(v11) = v43;
            if (v43 <= (unsigned __int16)(v44 + 1))
            {
              uint64_t v17 = *(void *)(v42 + 32);
              goto LABEL_30;
            }
            goto LABEL_7;
          }
          goto LABEL_27;
        }
      }
    }
    goto LABEL_27;
  }
  uint64_t v29 = 0;
LABEL_30:
  *(void *)(v17 + 256) = v10;
  *(_DWORD *)(*(void *)(a4 + 32) + 264) = v11;
  __strcpy_chk();
  return v29;
}

uint64_t hlp_SetupNewFeat_ObjcClose(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t v14 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v14);
  if ((inited & 0x80000000) == 0)
  {
    uint64_t v5 = *(void *)(a3 + 32);
    uint64_t v6 = v14;
    uint64_t v7 = *(void *)(v5 + 272);
    if (v7)
    {
      unsigned int v8 = *(_DWORD *)(v5 + 264);
      if (v8)
      {
        for (unsigned __int16 i = 0; i < v8; ++i)
        {
          uint64_t v10 = *(void *)(v7 + 8 * i);
          if (v10)
          {
            uint64_t v11 = 0;
            while (1)
            {
              uint64_t v12 = *(void *)(v10 + v11);
              if (v12) {
                break;
              }
              v11 += 8;
              if (v11 == 512) {
                goto LABEL_11;
              }
            }
            heap_Free(*(void **)(v6 + 8), v12);
            *(void *)(v10 + v11) = 0;
LABEL_11:
            heap_Free(*(void **)(v6 + 8), v10);
          }
        }
      }
      heap_Free(*(void **)(v6 + 8), v7);
      uint64_t v6 = v14;
    }
    heap_Free(*(void **)(v6 + 8), v5);
  }
  return inited;
}

uint64_t fe_depes_ClassOpen(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0;
  if (!a3) {
    return 2305826823;
  }
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *(void *)a3 = a1;
    *(void *)(a3 + 8) = a2;
  }
  return result;
}

uint64_t fe_depes_ClassClose()
{
  return 0;
}

unsigned __int8 **m2__fix__carray__len(unsigned __int8 **result, int *a2)
{
  if (*a2 <= 0)
  {
    uint64_t v2 = *result;
    int v3 = -1;
    do
    {
      int v4 = *v2++;
      ++v3;
    }
    while (v4);
    *a2 = v3;
  }
  return result;
}

unsigned __int8 *m2__cp__str(unsigned __int8 *result, unsigned char *a2, int a3)
{
  if (a3 >= 1)
  {
    uint64_t v3 = a3;
    while (1)
    {
      int v5 = *result++;
      char v4 = v5;
      if (!v5) {
        break;
      }
      *a2++ = v4;
      if (!--v3) {
        return result;
      }
    }
    *a2 = 0;
  }
  return result;
}

char *m2__cp__arr(char *result, unsigned char *a2, int a3)
{
  if (a3 >= 1)
  {
    uint64_t v3 = a3;
    do
    {
      char v4 = *result++;
      *a2++ = v4;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t mosyntkbsymtab_KnownGraphId(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  return kbsymtab_KnownGraphId(a2, a3);
}

uint64_t mosyntkbsymtab_KnownPhonId(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  return kbsymtab_KnownPhonId(a2, a3);
}

uint64_t mosyntkbsymtab_KnownAtomId(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  return kbsymtab_KnownAtomId(a2, a3);
}

uint64_t mosyntkbsymtab_KnownConsId(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  return kbsymtab_KnownConsId(a2, a3);
}

uint64_t mosyntkbsymtab_GraphSymString(int a1, uint64_t a2, signed int a3, char *__dst, int a5)
{
  return 0;
}

uint64_t mosyntkbsymtab_AtomSymString(uint64_t a1, uint64_t *a2, unsigned int a3, char *a4, int a5)
{
  return 0;
}

uint64_t mosyntkbsymtab_ConsToString(uint64_t a1, uint64_t *a2, unsigned int a3, char *a4, int a5)
{
  return 0;
}

uint64_t mosyntkbsymtab_PhonSymString(uint64_t a1, uint64_t *a2, unsigned int a3, char *a4, int a5)
{
  return 0;
}

uint64_t mosyntkbsymtab_WriteGraphSym(uint64_t a1, uint64_t a2, signed int a3)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  kbsymtab_GraphSymString(a2, a3, (char *)v5, 0xC8uLL);
  return mosyntbase_WString(a1, (unsigned __int8 *)v5, 200);
}

uint64_t mosyntkbsymtab_WritePhonSym(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  kbsymtab_PhonSymString(a2, a3, (char *)v5, 200);
  return mosyntbase_WString(a1, (unsigned __int8 *)v5, 200);
}

uint64_t mosyntkbsymtab_WriteCons(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  kbsymtab_ConsSymString(a2, a3, (char *)v5, 200);
  return mosyntbase_WString(a1, (unsigned __int8 *)v5, 200);
}

uint64_t mosyntkbsymtab_ConsFeatToComprConsFeatStr(uint64_t a1, int a2)
{
  if (a2 >= 1)
  {
    for (uint64_t i = 0; i != a2; ++i)
    {
      int v3 = *(unsigned __int8 *)(a1 + i);
      if ((v3 - 40) < 2 || v3 == 44)
      {
        *(unsigned char *)(a1 + i) = 58;
      }
      else if (!*(unsigned char *)(a1 + i))
      {
        goto LABEL_10;
      }
    }
    LODWORD(i) = a2;
LABEL_10:
    uint64_t v4 = (i - 2);
    if (i >= 2 && *(unsigned char *)(a1 + v4) == 40 && *(unsigned char *)(a1 + (i - 1)) == 41) {
      *(unsigned char *)(a1 + v4) = 0;
    }
  }
  return 0;
}

uint64_t mosyntkbsymtab_ComprConsFeatToConsFeatStr(uint64_t a1, int a2)
{
  if (a2 >= 1)
  {
    uint64_t v2 = 0;
    int v3 = 1;
    unsigned int v4 = -1;
    LODWORD(v5) = a2;
    while (1)
    {
      if (*(unsigned char *)(a1 + v2) == 58)
      {
        if (v3) {
          char v6 = 40;
        }
        else {
          char v6 = 44;
        }
        *(unsigned char *)(a1 + v2) = v6;
        unsigned int v4 = v2;
        int v3 = 0;
      }
      else if (!*(unsigned char *)(a1 + v2))
      {
        LODWORD(v5) = v2;
        if ((v4 & 0x80000000) != 0) {
          goto LABEL_16;
        }
LABEL_15:
        uint64_t v5 = v4;
        char v7 = 41;
LABEL_20:
        *(unsigned char *)(a1 + v5) = v7;
        return 0;
      }
      if (a2 == ++v2)
      {
        if ((v4 & 0x80000000) != 0) {
          goto LABEL_16;
        }
        goto LABEL_15;
      }
    }
  }
  LODWORD(v5) = 0;
LABEL_16:
  if ((int)v5 + 2 < a2)
  {
    *(_WORD *)(a1 + v5) = 10536;
    LODWORD(v5) = v5 + 2;
  }
  if ((int)v5 < a2)
  {
    char v7 = 0;
    uint64_t v5 = (int)v5;
    goto LABEL_20;
  }
  return 0;
}

uint64_t mosyntkbsymtab_AppDecomprConsToString(uint64_t a1, uint64_t *a2, unsigned int a3, uint64_t a4, int a5, int *a6)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v12 = 0;
  memset(v11, 0, sizeof(v11));
  BOOL v10 = 0;
  kbsymtab_ConsSymString(a2, a3, (char *)v11, 200);
  mosyntkbsymtab_ComprConsFeatToConsFeatStr((uint64_t)v11, 200);
  return mosyntbase_App(a4, a5, a6, (uint64_t)v11, 200, &v10);
}

uint64_t mosyntkbsymtab_AppConsFeatToString(uint64_t a1, uint64_t *a2, unsigned int a3, __int16 *a4, uint64_t a5, int a6, int *a7)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  BOOL v13 = 0;
  uint64_t v15 = 0;
  memset(v14, 0, sizeof(v14));
  kbsymtab_ConsSymString(a2, a3, (char *)v14, 200);
  uint64_t result = mosyntbase_App(a5, a6, a7, (uint64_t)v14, 200, &v13);
  if ((result & 0x80000000) == 0) {
    return AppFeatListToString(a2, a4, a5, a6, a7);
  }
  return result;
}

uint64_t AppFeatListToString(uint64_t *a1, __int16 *a2, uint64_t a3, int a4, int *a5)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  BOOL v14 = 0;
  uint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  uint64_t result = mosyntbase_CApp(a3, a4, a5, "(", 0, &v14);
  if ((result & 0x80000000) == 0)
  {
    if (*a2 < 1)
    {
      return mosyntbase_CApp(a3, a4, a5, ")", 0, &v14);
    }
    else
    {
      uint64_t v11 = 0;
      while (1)
      {
        if (v11)
        {
          uint64_t result = mosyntbase_CApp(a3, a4, a5, ",", 0, &v14);
          if ((result & 0x80000000) != 0) {
            break;
          }
        }
        uint64_t v12 = &a2[v11];
        int v13 = v12[1];
        if (v13 < 0)
        {
          kbsymtab_AtomSymString(a1, -v13, (char *)v15, 200);
        }
        else
        {
          uint64_t result = mosyntbase_CApp(a3, a4, a5, "?", 0, &v14);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t result = mosyntpal_IntToString(v12[1], 0, v15, 200);
          if ((result & 0x80000000) != 0) {
            return result;
          }
        }
        uint64_t result = mosyntbase_App(a3, a4, a5, (uint64_t)v15, 200, &v14);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        if (++v11 >= *a2) {
          return mosyntbase_CApp(a3, a4, a5, ")", 0, &v14);
        }
      }
    }
  }
  return result;
}

uint64_t mosyntkbsymtab_WriteFeatList(uint64_t a1, uint64_t *a2, __int16 *a3)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  int v5 = 0;
  uint64_t result = AppFeatListToString(a2, a3, (uint64_t)v6, 200, &v5);
  if ((result & 0x80000000) == 0) {
    return mosyntbase_WString(a1, (unsigned __int8 *)v6, 200);
  }
  return result;
}

uint64_t mosyntkbsymtab_WriteConsAndFeat(uint64_t a1, uint64_t *a2, unsigned int a3, __int16 *a4)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  kbsymtab_ConsSymString(a2, a3, (char *)v8, 200);
  uint64_t result = mosyntbase_WString(a1, (unsigned __int8 *)v8, 200);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = mosyntbase_WString(a1, " ", 0);
    if ((result & 0x80000000) == 0) {
      return mosyntkbsymtab_WriteFeatList(a1, a2, a4);
    }
  }
  return result;
}

uint64_t mosyntkbsymtab_GetConsFeatFromString(uint64_t a1, uint64_t *a2, int a3, unsigned __int8 *a4, int a5, signed int *a6, _DWORD *a7, __int16 *a8)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  int v26 = 0;
  memset(v25, 0, sizeof(v25));
  signed int v24 = 0;
  uint64_t result = mosyntutils_GetIdentFromString(a1, a4, a5, a6, v25, 100);
  if ((result & 0x80000000) == 0)
  {
    int v17 = kbsymtab_KnownConsId(a2, (uint64_t)v25);
    *a7 = v17;
    if (v17 < 0)
    {
      uint64_t result = mosyntbase_WString3Ln(a1, "*** error: unknown constituent symbol '", 0, (unsigned __int8 *)v25, 100, "'", 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      *a7 = 0;
    }
    uint64_t result = mosyntutils_SkipBlanksInString((uint64_t)a4, a5, a6);
    if ((result & 0x80000000) == 0)
    {
      *a8 = 0;
      uint64_t v18 = *a6;
      if ((int)v18 >= a5 || a4[v18] != 40) {
        return mosyntutils_SkipBlanksInString((uint64_t)a4, a5, a6);
      }
      uint64_t result = mosyntutils_CheckSkipCharInString(a1, a4, a5, a6, 0x28u);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = mosyntutils_SkipBlanksInString((uint64_t)a4, a5, a6);
        if ((result & 0x80000000) == 0)
        {
          uint64_t v19 = *a6;
          if ((int)v19 >= a5 || a4[v19] == 41)
          {
LABEL_12:
            uint64_t result = mosyntutils_CheckSkipCharInString(a1, a4, a5, a6, 0x29u);
            if ((result & 0x80000000) != 0) {
              return result;
            }
            return mosyntutils_SkipBlanksInString((uint64_t)a4, a5, a6);
          }
          while (1)
          {
            uint64_t result = mosyntutils_SkipBlanksInString((uint64_t)a4, a5, a6);
            if ((result & 0x80000000) != 0) {
              return result;
            }
            if (a4[*a6] != 63)
            {
              uint64_t result = mosyntutils_GetIdentFromString(a1, a4, a5, a6, v25, 100);
              if ((result & 0x80000000) != 0) {
                return result;
              }
              int v21 = kbsymtab_KnownAtomId(a2, (uint64_t)v25);
              if ((v21 & 0x80000000) == 0)
              {
                int v20 = -v21;
                goto LABEL_28;
              }
              uint64_t result = mosyntbase_WString3Ln(a1, "*** error: unknown feature value '", 0, (unsigned __int8 *)v25, 100, "'", 0);
              goto LABEL_27;
            }
            if (!a3) {
              break;
            }
            uint64_t result = mosyntutils_CheckSkipCharInString(a1, a4, a5, a6, 0x3Fu);
            if ((result & 0x80000000) != 0) {
              return result;
            }
            uint64_t result = mosyntutils_GetCardFromString(a1, a4, a5, a6, &v24);
            if ((result & 0x80000000) != 0) {
              return result;
            }
            LOWORD(v20) = v24;
            if (v24 >= 50)
            {
              uint64_t result = mosyntbase_WInt3Ln(a1, "*** error: illegal variable number '", 0, v24, "'", 0);
              goto LABEL_27;
            }
LABEL_28:
            uint64_t result = mosyntutils_SkipBlanksInString((uint64_t)a4, a5, a6);
            if ((result & 0x80000000) != 0) {
              return result;
            }
            uint64_t v22 = *a8;
            if (v22 > 8)
            {
              uint64_t result = mosyntbase_WString3Ln(a1, "*** error: too many features in '", 0, a4, a5, "'", 0);
              if ((result & 0x80000000) != 0) {
                return result;
              }
            }
            else
            {
              a8[v22 + 1] = v20;
              ++*a8;
            }
            uint64_t v23 = *a6;
            if ((int)v23 >= a5 || a4[v23] != 44) {
              goto LABEL_12;
            }
            uint64_t result = mosyntutils_CheckSkipCharInString(a1, a4, a5, a6, 0x2Cu);
            if ((result & 0x80000000) != 0) {
              return result;
            }
          }
          uint64_t result = mosyntbase_WStringLn(a1, "*** error: variables are not allowed as features'", 0);
LABEL_27:
          LOWORD(v20) = 0;
          if ((result & 0x80000000) != 0) {
            return result;
          }
          goto LABEL_28;
        }
      }
    }
  }
  return result;
}

uint64_t mosyntkbsymtab_DecompressCons(uint64_t a1, uint64_t *a2, unsigned int a3, _DWORD *a4, __int16 *a5)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  kbsymtab_ConsSymString(a2, a3, (char *)v15, 200);
  signed int v14 = 0;
  int v18 = 0;
  memset(v17, 0, sizeof(v17));
  uint64_t IdentFromString = mosyntutils_GetIdentFromString(a1, (unsigned __int8 *)v15, 200, &v14, v17, 100);
  if ((IdentFromString & 0x80000000) == 0)
  {
    int v10 = kbsymtab_KnownConsId(a2, (uint64_t)v17);
    *a4 = v10;
    if (v10 < 0)
    {
      uint64_t IdentFromString = mosyntbase_WString3Ln(a1, "*** error: unknown constituent symbol '", 0, v17, 100, "'", 0);
      if ((IdentFromString & 0x80000000) != 0) {
        return IdentFromString;
      }
      *a4 = 0;
    }
    *a5 = 0;
    if (v14 <= 199 && *((unsigned char *)v15 + v14) == 58)
    {
      uint64_t IdentFromString = mosyntutils_CheckSkipCharInString(a1, (unsigned __int8 *)v15, 200, &v14, 0x3Au);
      if ((IdentFromString & 0x80000000) == 0 && v14 <= 199 && *((unsigned char *)v15 + v14))
      {
        while (1)
        {
          uint64_t v11 = mosyntutils_GetIdentFromString(a1, (unsigned __int8 *)v15, 200, &v14, v17, 100);
          if ((v11 & 0x80000000) != 0) {
            break;
          }
          uint64_t IdentFromString = mosyntutils_CheckSkipCharInString(a1, (unsigned __int8 *)v15, 200, &v14, 0x3Au);
          if ((IdentFromString & 0x80000000) != 0) {
            return IdentFromString;
          }
          if (*a5 > 8)
          {
            uint64_t IdentFromString = mosyntbase_WString3Ln(a1, "*** error: too many features in '", 0, (unsigned __int8 *)v15, 200, "'", 0);
            if ((IdentFromString & 0x80000000) != 0) {
              return IdentFromString;
            }
          }
          else
          {
            int v12 = kbsymtab_KnownAtomId(a2, (uint64_t)v17);
            if (v12 < 0)
            {
              uint64_t IdentFromString = mosyntbase_WString3Ln(a1, "*** error: unknown feature value '", 0, v17, 100, "'", 0);
              LOWORD(v12) = 0;
              if ((IdentFromString & 0x80000000) != 0) {
                return IdentFromString;
              }
            }
            a5[++*a5] = -(__int16)v12;
          }
          if (v14 >= 200 || !*((unsigned char *)v15 + v14)) {
            return IdentFromString;
          }
        }
        return v11;
      }
    }
  }
  return IdentFromString;
}

BOOL mosyntkbsymtab_PropTabAvailable(uint64_t a1)
{
  return kbsymtab_PropTabAvailable(a1);
}

uint64_t mosyntkbsymtab_IntPropValue(uint64_t a1, uint64_t *a2, unsigned int a3, unsigned int a4)
{
  return kbsymtab_IntPropValue(a2, a3, a4);
}

BOOL mosyntkbsymtab_HasIntPropValue(uint64_t a1, uint64_t *a2, unsigned int a3, unsigned int a4, int a5)
{
  return kbsymtab_HasIntPropValue(a2, a3, a4, a5);
}

uint64_t mosyntkbsymtab_GetFirstAccPatVal(uint64_t a1, uint64_t **a2, int a3, int a4, uint64_t a5, void *a6)
{
  return 0;
}

uint64_t mosyntkbsymtab_GetNextAccPatVal(uint64_t **a1, void *a2)
{
  return 0;
}

uint64_t mosyntkbsymtab_DisposeAccPat(void *a1, void **a2)
{
  return 0;
}

uint64_t mosyntkbsymtab_GetFeatMatchedFirstIntPropVal(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, int *a7)
{
  return 0;
}

uint64_t mosyntkbsymtab_GetFeatMatchedNextIntPropVal(uint64_t a1, uint64_t a2, int *a3)
{
  return 0;
}

uint64_t mosyntkbsymtab_GetLhPlusPhone(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, int *a5, char *a6, int a7, unsigned char *a8)
{
  return 0;
}

uint64_t mosyntwordana_ParseWord(uint64_t a1, int a2, uint64_t a3, int a4, char *a5, int a6, char *a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, int a13, char a14, char a15, char a16, BOOL *a17, void *a18)
{
  uint64_t v131 = *MEMORY[0x263EF8340];
  uint64_t v115 = 0;
  memset(v126, 0, 512);
  uint64_t v25 = *(void *)(a9 + 8);
  uint64_t result = mosyntpal_ALLOCATE(a1, &v115, 0x8A8u);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  uint64_t v27 = 0;
  uint64_t v28 = v115;
  *(_DWORD *)uint64_t v115 = a2;
  *(void *)(v28 + 8) = a3;
  do
  {
    *(void *)(v115 + 8 * v27 + 16) = mosyntkblex_NilLexicon();
    *(unsigned char *)(v115 + v27 + 104) = 0;
    *(void *)(v115 + 8 * v27 + 120) = mosyntkblex_NilLexicon();
    *(unsigned char *)(v115 + v27++ + 208) = 0;
  }
  while (v27 != 11);
  uint64_t v29 = v115;
  *(_DWORD *)(v115 + 220) = 0;
  *(_DWORD *)(v29 + 224) = a4;
  m2__cp__arr(a5, (unsigned char *)(v29 + 232), 80);
  uint64_t v30 = v115;
  *(_DWORD *)(v115 + 312) = a6;
  m2__cp__arr(a7, (unsigned char *)(v30 + 320), 80);
  uint64_t v32 = a1;
  uint64_t v31 = (void *)v115;
  *(void *)(v115 + 400) = a8;
  v31[51] = v25;
  v31[52] = a10;
  uint64_t result = mosyntdata_StartPhonList(a1, v31 + 62, v31 + 63);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  uint64_t v33 = v115;
  LODWORD(v120) = 0;
  if (a13 < 1)
  {
    int v35 = 0;
  }
  else
  {
    int v34 = 0;
    int v35 = 0;
    LODWORD(v116) = 0;
    LODWORD(__dst[0]) = 0;
    BYTE4(__dst[0]) = 0;
    LOBYTE(v129) = 0;
    do
    {
      if (!*(unsigned char *)(a12 + v34)) {
        break;
      }
      uint64_t result = mosyntutils_GetUTF8Char(a1, a12, a13, (int *)&v120, &v116);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      if ((_BYTE)v116)
      {
        uint64_t result = mosyntbase_Copy((uint64_t)&v116, 4, (uint64_t)__dst, 5, (BOOL *)&v129);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        __int16 v36 = mosyntkbsymtab_KnownGraphId(a1, *(void *)(v33 + 8), (unsigned __int8 *)__dst);
        if (v35 < 499)
        {
          v126[v35++] = v36;
        }
        else
        {
          uint64_t result = mosyntbase_WStringLn(a1, "*** token too long; character ignored", 0);
          if ((result & 0x80000000) != 0) {
            return result;
          }
        }
      }
      int v34 = v120;
    }
    while ((int)v120 < a13);
    if (v35 > 499) {
      goto LABEL_20;
    }
  }
  v126[v35] = 0;
LABEL_20:
  uint64_t v37 = v115;
  uint64_t v38 = (void *)(v115 + 424);
  uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)(v115 + 424), 0x9C48u);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  uint64_t v118 = 0;
  uint64_t v119 = 0;
  long long v116 = 0u;
  long long v117 = 0u;
  *(void *)&__dst[0] = 0;
  *(_DWORD *)(v37 + 432) = 0;
  uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)__dst, 0x80u);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  uint64_t v39 = *(void *)&__dst[0];
  **(_WORD **)&__dst[0] = 0;
  *(_DWORD *)(v39 + 4) = 3;
  *(void *)(v39 + 8) = 0;
  for (uint64_t i = 16; i != 120; i += 8)
    *(void *)(*(void *)&__dst[0] + i) = 0;
  uint64_t v41 = 0;
  uint64_t v42 = *(void *)&__dst[0];
  *(void *)(*(void *)&__dst[0] + 120) = 0;
  **(void **)(v37 + 424) = v42;
  *(void *)(v37 + 440) = 0;
  *(_DWORD *)(v37 + 448) = 0;
  *(void *)(v37 + 456) = 0;
  *(void *)(v37 + 464) = 0;
  do
  {
    if (!v126[v41]) {
      break;
    }
    ++v41;
  }
  while (v41 != 500);
  LODWORD(v43) = *(_DWORD *)(v37 + 432);
  if ((int)v43 + (int)v41 >= 5001)
  {
    uint64_t result = mosyntbase_WriteDevelMessage(a1, "token too long; truncated",
               0,
               (unsigned __int8 *)&byte_20D5A22AE,
               0,
               (unsigned __int8 *)&byte_20D5A22AE,
               0,
               (unsigned __int8 *)&byte_20D5A22AE,
               0,
               0,
               0,
               0);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    LODWORD(v43) = *(_DWORD *)(v37 + 432);
    LODWORD(v41) = 5000 - v43;
  }
  if ((int)v41 <= 0)
  {
    uint64_t v49 = (int)v43;
  }
  else
  {
    uint64_t v44 = 0;
    uint64_t v45 = v41;
    do
    {
      **(_WORD **)(*(void *)(v37 + 424) + 8 * (int)v43) = v126[v44];
      int v46 = *(_DWORD *)(v37 + 220);
      uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v119, 0x80u);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t v47 = v119;
      *uint64_t v119 = 0;
      *((_DWORD *)v47 + 1) = v46 == 1;
      *((void *)v47 + 1) = 0;
      for (uint64_t j = 8; j != 60; j += 4)
        *(void *)&v119[j] = 0;
      uint64_t v43 = *(int *)(v37 + 432) + 1;
      *(_DWORD *)(v37 + 432) = v43;
      *(void *)(*(void *)(v37 + 424) + 8 * v43) = v119;
      ++v44;
    }
    while (v44 != v45);
    uint64_t v49 = v43;
  }
  *(_DWORD *)(*(void *)(*(void *)(v37 + 424) + 8 * v49) + 4) = 3;
  *(_DWORD *)(v37 + 436) = 0;
  if ((int)v43 < 1)
  {
LABEL_157:
    DWORD2(v116) = 0;
    *(void *)&long long v117 = -1;
    DWORD2(v117) = -1;
    uint64_t v118 = 0;
    uint64_t result = mosyntdata_AddOutItem(v32, (void *)(v37 + 496), (uint64_t *)(v37 + 504), (uint64_t)&v116);
    if ((result & 0x80000000) == 0)
    {
      uint64_t v96 = v115;
      *a17 = *(_DWORD *)(v115 + 488) > 0;
      *a18 = *(void *)(v96 + 496);
      if (a11 && *(int *)v96 >= 1)
      {
        uint64_t v97 = (void *)(v96 + 496);
        while (1)
        {
          uint64_t v97 = (void *)*v97;
          uint64_t v96 = v115;
          if (!v97) {
            break;
          }
          uint64_t result = mosyntdata_WriteReadingList(v32, *(uint64_t **)(v115 + 8), (uint64_t)(v97 + 2));
          if ((result & 0x80000000) != 0) {
            return result;
          }
        }
      }
      uint64_t v98 = *(void **)(v96 + 440);
      if (v98)
      {
        while (1)
        {
          *(void *)&__dst[0] = v98;
          uint64_t v98 = (void *)*v98;
          uint64_t result = mosyntpal_DEALLOCATE(v32, (uint64_t *)__dst);
          if ((result & 0x80000000) != 0) {
            break;
          }
          if (!v98) {
            goto LABEL_167;
          }
        }
      }
      else
      {
LABEL_167:
        *(void *)(v96 + 440) = 0;
        *(_DWORD *)(v96 + 448) = 0;
        *(void *)(v96 + 456) = 0;
        if ((*(_DWORD *)(v96 + 432) & 0x80000000) != 0)
        {
LABEL_177:
          uint64_t result = mosyntpal_DEALLOCATE(v32, (uint64_t *)(v96 + 424));
          if ((result & 0x80000000) == 0)
          {
            uint64_t v102 = *(void **)(v96 + 464);
            if (v102)
            {
              while (1)
              {
                *(void *)&__dst[0] = v102;
                uint64_t v102 = (void *)*v102;
                uint64_t result = mosyntpal_DEALLOCATE(v32, (uint64_t *)__dst);
                if ((result & 0x80000000) != 0) {
                  break;
                }
                if (!v102) {
                  goto LABEL_181;
                }
              }
            }
            else
            {
LABEL_181:
              *(void *)(v96 + 464) = 0;
              return mosyntpal_DEALLOCATE(v32, &v115);
            }
          }
        }
        else
        {
          uint64_t v99 = 0;
          while (1)
          {
            uint64_t v100 = *(void *)(*(void *)(v96 + 424) + 8 * v99);
            uint64_t result = mosyntdata_SetLexEleRefCounts(v32, *(void **)(v100 + 120));
            if ((result & 0x80000000) != 0) {
              break;
            }
            int v101 = *(void **)(v100 + 120);
            if (v101)
            {
              *(void *)&__dst[0] = 0;
              do
              {
                uint64_t result = mosyntdata_PruneLexEleBranch(v32, v101 + 2);
                if ((result & 0x80000000) != 0) {
                  return result;
                }
                *(void *)&__dst[0] = v101;
                int v101 = (void *)*v101;
                uint64_t result = mosyntpal_DEALLOCATE(v32, (uint64_t *)__dst);
                if ((result & 0x80000000) != 0) {
                  return result;
                }
              }
              while (v101);
            }
            *(void *)(v100 + 120) = 0;
            uint64_t result = mosyntpal_DEALLOCATE(v32, (uint64_t *)(*(void *)(v96 + 424) + 8 * v99));
            if ((result & 0x80000000) != 0) {
              return result;
            }
            BOOL v75 = v99++ < *(int *)(v96 + 432);
            if (!v75) {
              goto LABEL_177;
            }
          }
        }
      }
    }
    return result;
  }
  uint64_t v50 = 0;
  unint64_t v51 = 0;
  uint64_t v52 = (uint64_t *)(v37 + 480);
  uint64_t v110 = (void *)(v37 + 496);
  __src = (void *)(v37 + 320);
  uint64_t v109 = (uint64_t *)(v37 + 504);
  int v53 = 2;
  long long v54 = 0uLL;
  int v55 = 1;
  while (*(_DWORD *)(*(void *)(*v38 + 8 * v51) + 4) < 2u)
  {
LABEL_156:
    ++v51;
    ++v55;
    --v53;
    v50 += 8;
    if ((uint64_t)v51 >= (int)v43) {
      goto LABEL_157;
    }
  }
  int64_t v56 = (int)v43;
  if ((int)v43 <= v55) {
    LODWORD(v57) = v55;
  }
  else {
    LODWORD(v57) = v43;
  }
  unsigned int v58 = v57 - 1;
  unint64_t v59 = v51;
  while (1)
  {
    int v60 = v59 + 1;
    if ((uint64_t)(v59 + 1) >= v56) {
      break;
    }
    unsigned int v61 = *(_DWORD *)(*(void *)(*v38 + 8 + 8 * v59++) + 4);
    if (v61 >= 3)
    {
      unsigned int v58 = v60 - 1;
      LODWORD(v57) = v60;
      break;
    }
  }
  *(_DWORD *)(v37 + 2212) = v51;
  uint64_t v128 = 0;
  __dst[10] = v54;
  __dst[9] = v54;
  __dst[8] = v54;
  __dst[7] = v54;
  __dst[6] = v54;
  __dst[5] = v54;
  __dst[4] = v54;
  __dst[3] = v54;
  __dst[2] = v54;
  __dst[0] = v54;
  __dst[1] = v54;
  uint64_t result = mosyntpal_ALLOCATE(a1, v52, 0x18u);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  uint64_t v122 = 0;
  long long v120 = 0u;
  long long v121 = 0u;
  uint64_t v62 = (void *)*v52;
  v62[1] = 0;
  v62[2] = 0;
  *uint64_t v62 = 0;
  if (v51 <= v57)
  {
    unsigned int v63 = v58 + v53;
    uint64_t v64 = (uint64_t *)(*v38 + v50);
    do
    {
      uint64_t v65 = *v64++;
      *(void *)(v65 + 120) = 0;
      --v63;
    }
    while (v63);
  }
  *(_DWORD *)(v37 + 488) = 0;
  if (!a14) {
    goto LABEL_61;
  }
  if (*(int *)v37 > 1)
  {
    uint64_t result = mosyntknowl_WriteTraceHeader(a1, 1u);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    uint64_t result = mosyntbase_WInt3Ln(a1, "analyzing as internal full-form starting at position ", 0, v51, (unsigned __int8 *)&byte_20D5A22AE, 0);
    if ((result & 0x80000000) != 0) {
      return result;
    }
  }
  if (*(int *)(v37 + 224) < 1)
  {
LABEL_61:
    int v68 = *(_DWORD *)(v37 + 488);
    if (a15 && !v68)
    {
      if (*(int *)v37 > 1)
      {
        uint64_t result = mosyntknowl_WriteTraceHeader(a1, 1u);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t result = mosyntbase_WInt3Ln(a1, "analyzing as morpheme sequence starting at position ", 0, v51, (unsigned __int8 *)&byte_20D5A22AE, 0);
        if ((result & 0x80000000) != 0) {
          return result;
        }
      }
      uint64_t v69 = v50;
      uint64_t v70 = *(unsigned int *)(v37 + 312);
      if ((int)v70 < 1) {
        LODWORD(v70) = 0;
      }
      else {
        memcpy(__dst, __src, 8 * v70);
      }
      for (uint64_t k = 0; k != 11; ++k)
      {
        if (*(unsigned char *)(v37 + k + 208))
        {
          *((void *)__dst + (int)v70) = *(void *)(v37 + 8 * k + 120);
          LODWORD(v70) = v70 + 1;
        }
      }
      uint64_t result = AnalyzeInParts(a1, v37, v51, v57, __dst, v70);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      int v68 = *(_DWORD *)(v37 + 488);
      uint64_t v50 = v69;
    }
    uint64_t v113 = v50;
    if (a16)
    {
      uint64_t v52 = (uint64_t *)(v37 + 480);
      if (v68) {
        goto LABEL_94;
      }
      if ((int)v57 <= (int)v51) {
        signed int v72 = v51;
      }
      else {
        signed int v72 = v57;
      }
      if (v51 > v58) {
        goto LABEL_149;
      }
      if (*(int *)v37 > 1)
      {
        uint64_t result = mosyntknowl_WriteTraceHeader(a1, 1u);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t result = mosyntbase_WInt3Ln(a1, "analyzing as submorpheme sequence starting at position ", 0, v51, (unsigned __int8 *)&byte_20D5A22AE, 0);
        if ((result & 0x80000000) != 0) {
          return result;
        }
      }
      uint64_t v73 = *(unsigned int *)(v37 + 312);
      if ((int)v73 < 1) {
        LODWORD(v73) = 0;
      }
      else {
        memcpy(__dst, __src, 8 * v73);
      }
      for (uint64_t m = 0; m != 11; ++m)
      {
        if (*(unsigned char *)(v37 + m + 208))
        {
          *((void *)__dst + (int)v73) = *(void *)(v37 + 8 * m + 120);
          LODWORD(v73) = v73 + 1;
        }
      }
      *((void *)__dst + (int)v73) = *(void *)(v37 + 400);
      uint64_t result = AnalyzeInParts(a1, v37, v51, v72, __dst, (int)v73 + 1);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      int v68 = *(_DWORD *)(v37 + 488);
    }
    uint64_t v52 = (uint64_t *)(v37 + 480);
LABEL_94:
    if (v68)
    {
      if (*(void *)(*(void *)(*v38 + 8 * v51) + 120))
      {
        uint64_t result = mosyntbase_WriteDevelMessage(a1, "*** error: empty reading detected; check word grammar\\n",
                   0,
                   (unsigned __int8 *)&byte_20D5A22AE,
                   0,
                   (unsigned __int8 *)&byte_20D5A22AE,
                   0,
                   (unsigned __int8 *)&byte_20D5A22AE,
                   0,
                   0,
                   0,
                   0);
        if ((result & 0x80000000) != 0) {
          return result;
        }
      }
      BOOL v75 = v51 > v58;
      uint64_t v32 = a1;
      uint64_t v50 = v113;
      if (!v75)
      {
        uint64_t v57 = v57;
        unint64_t v76 = v51;
        uint64_t v104 = v57;
        unsigned int v105 = v38;
        while (1)
        {
          ++v76;
          uint64_t v77 = *(void *)(*v38 + 8 * v76);
          __int16 v78 = *(void **)(v77 + 120);
          if (v78)
          {
            unint64_t v106 = v76;
            uint64_t result = mosyntdata_SetLexEleRefCounts(v32, v78);
            if ((result & 0x80000000) != 0) {
              return result;
            }
            uint64_t v79 = *(uint64_t **)(v77 + 120);
            if (v79)
            {
              int v80 = -1;
              int v81 = *(uint64_t **)(v77 + 120);
              do
              {
                if (*((_DWORD *)v81 + 3) < v80 || v80 == -1) {
                  int v80 = *((_DWORD *)v81 + 3);
                }
                int v81 = (uint64_t *)*v81;
              }
              while (v81);
              uint64_t v83 = 0;
              *(void *)&long long v129 = *(void *)(v77 + 120);
              int v84 = v80 + 20;
              do
              {
                uint64_t v85 = (uint64_t *)*v79;
                if (*((_DWORD *)v79 + 3) <= v84)
                {
                  *uint64_t v79 = v83;
                  uint64_t v83 = v129;
                }
                else
                {
                  uint64_t result = mosyntdata_PruneLexEleBranch(v32, v79 + 2);
                  if ((result & 0x80000000) != 0) {
                    return result;
                  }
                  uint64_t result = mosyntpal_DEALLOCATE(v32, (uint64_t *)&v129);
                  if ((result & 0x80000000) != 0) {
                    return result;
                  }
                }
                *(void *)&long long v129 = v85;
                uint64_t v79 = v85;
              }
              while (v85);
              *(void *)(v77 + 120) = v83;
              uint64_t v57 = v104;
              uint64_t v38 = v105;
              uint64_t v50 = v113;
              unint64_t v76 = v106;
              if ((result & 0x80000000) != 0) {
                return result;
              }
            }
            else
            {
              *(void *)(v77 + 120) = 0;
              unint64_t v76 = v106;
            }
            if (*(int *)(v37 + 220) <= 1)
            {
              DWORD2(v120) = 0;
              uint64_t v122 = *(void *)(*(void *)(*(void *)(v37 + 424) + 8 * v76) + 120);
              LODWORD(v121) = *(_DWORD *)(v37 + 2212);
              *(void *)((char *)&v121 + 4) = __PAIR64__(v76, v51);
              uint64_t result = mosyntdata_AddOutItem(v32, v110, v109, (uint64_t)&v120);
              goto LABEL_121;
            }
            uint64_t v86 = *(void *)(*(void *)(*v38 + 8 * v76) + 120);
            uint64_t v125 = 0;
            if (v86)
            {
              *(void *)&long long v123 = 0;
              *(void *)&long long v129 = 0;
              WORD4(v129) = 0;
              do
              {
                int v107 = *(_DWORD *)(v86 + 12);
                int v108 = *(_DWORD *)(v86 + 8);
                int v87 = *(uint64_t **)(v86 + 16);
                uint64_t v103 = (uint64_t *)v86;
                if (v87)
                {
                  int v88 = 0;
                  uint64_t v112 = 0;
                  uint64_t v89 = 0;
                  unint64_t v90 = v76;
                  while (1)
                  {
                    uint64_t result = mosyntkblex_GetEntryPhon(a1, v87 + 1, &v129, 10);
                    if ((result & 0x80000000) != 0) {
                      return result;
                    }
                    if ((_BYTE)v129)
                    {
                      uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v123, 0x38u);
                      if ((result & 0x80000000) != 0) {
                        return result;
                      }
                      *(void *)long long v123 = 0;
                      uint64_t v91 = v123;
                      long long v92 = *(_OWORD *)(v87 + 3);
                      *(_OWORD *)(v123 + 8) = *(_OWORD *)(v87 + 1);
                      *(_OWORD *)(v91 + 24) = v92;
                      *(_WORD *)(v91 + 40) = *((_WORD *)v87 + 20);
                      v88 += *((__int16 *)v87 + 20);
                      if (v89)
                      {
                        void *v89 = v91;
                        uint64_t v91 = v123;
                      }
                      else
                      {
                        uint64_t v112 = v91;
                      }
                      unint64_t v93 = v90;
                    }
                    else
                    {
                      unint64_t v93 = (v90 - v88);
                      if (v112)
                      {
                        if (v88 >= 1)
                        {
                          uint64_t result = PutOutReadingItem(a1, v37, v108, v107, (int)v90 - v88, v90, v112, &v125);
                          if ((result & 0x80000000) != 0) {
                            return result;
                          }
                        }
                      }
                      uint64_t v91 = 0;
                      uint64_t v112 = 0;
                      int v88 = 0;
                      int v107 = 0;
                      int v108 = *((_DWORD *)v87 + 8);
                    }
                    int v87 = (uint64_t *)*v87;
                    unint64_t v90 = v93;
                    uint64_t v89 = (void *)v91;
                    if (!v87) {
                      goto LABEL_141;
                    }
                  }
                }
                uint64_t v112 = 0;
                int v88 = 0;
                LODWORD(v93) = v76;
LABEL_141:
                uint64_t result = PutOutReadingItem(a1, v37, v108, v107, (int)v93 - v88, v93, v112, &v125);
                uint64_t v38 = v105;
                uint64_t v50 = v113;
                if ((result & 0x80000000) != 0) {
                  return result;
                }
                uint64_t v86 = *v103;
                unint64_t v76 = v106;
              }
              while (*v103);
              uint64_t v94 = v125;
              uint64_t v32 = a1;
              uint64_t v57 = v104;
              if (!v125) {
                goto LABEL_147;
              }
              do
              {
                int v95 = v94;
                uint64_t v94 = (void *)*v94;
                *int v95 = 0;
                uint64_t result = mosyntdata_AppendItem(a1, v110, (void **)v109, v95);
              }
              while ((result & 0x80000000) == 0 && v94);
LABEL_121:
              unint64_t v76 = v106;
              if ((result & 0x80000000) != 0) {
                return result;
              }
            }
          }
LABEL_147:
          uint64_t v52 = (uint64_t *)(v37 + 480);
          if (v76 == v57) {
            goto LABEL_154;
          }
        }
      }
      goto LABEL_154;
    }
LABEL_149:
    uint64_t v32 = a1;
    uint64_t v50 = v113;
    if ((uint64_t)v51 >= *(int *)(v37 + 436)
      && !kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)result)
      && (a16 || *(int *)v37 >= 1))
    {
      uint64_t result = mosyntbase_WriteDevelMessage(a1, "*** no word analysis found starting at token position %d\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, v51, 0, 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
    }
LABEL_154:
    uint64_t result = DisposeLexEleTreeList(v32, v52);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    LODWORD(v43) = *(_DWORD *)(v37 + 432);
    long long v54 = 0uLL;
    goto LABEL_156;
  }
  uint64_t v66 = 0;
  while (1)
  {
    uint64_t v67 = *(void *)(v37 + 8 * v66 + 232);
    long long v129 = 0uLL;
    uint64_t v130 = 0;
    uint64_t result = mosyntkblex_StartLookup(v67, &v129);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    long long v123 = v129;
    uint64_t v124 = v130;
    uint64_t result = GetAndTreatEntries(a1, v37, 1, 1, v51, v51, v57, 1, 1u, &v123, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t, int))GenFullFormReading);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    if (++v66 >= *(int *)(v37 + 224)) {
      goto LABEL_61;
    }
  }
}

uint64_t AnalyzeInParts(uint64_t a1, uint64_t a2, uint64_t a3, signed int a4, void *a5, int a6)
{
  uint64_t v9 = a3;
  long long v32 = 0uLL;
  uint64_t v33 = 0;
  long long v36 = 0u;
  long long v37 = 0u;
  if ((int)a3 <= a4)
  {
    int v12 = a4 - a3 + 1;
    uint64_t v13 = 8 * (int)a3;
    do
    {
      uint64_t v14 = *(void *)(*(void *)(a2 + 424) + v13);
      *(_OWORD *)(v14 + 104) = 0uLL;
      *(_OWORD *)(v14 + 88) = 0uLL;
      *(_OWORD *)(v14 + 72) = 0uLL;
      *(_OWORD *)(v14 + 56) = 0uLL;
      *(_OWORD *)(v14 + 40) = 0uLL;
      *(_OWORD *)(v14 + 24) = 0uLL;
      *(_OWORD *)(v14 + 8) = 0uLL;
      v13 += 8;
      --v12;
    }
    while (v12);
  }
  int v35 = 0;
  uint64_t result = mosyntdata_GetNilLexItem((uint64_t)&v36);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = mosyntkbwgram_GetNFAStartState(*(void *)(a2 + 416), &v35);
    if ((result & 0x80000000) == 0)
    {
      v34[0] = v36;
      v34[1] = v37;
      uint64_t result = InsertEntry(a1, a2, v9, v9, 1, v35, 1, 0, 0, v34);
      if ((result & 0x80000000) == 0 && (int)v9 <= a4)
      {
        uint64_t v16 = (uint64_t *)(a2 + 464);
        uint64_t v9 = (int)v9;
        int v17 = a4 + 1;
        while (1)
        {
          if (*(int *)a2 >= 2)
          {
            uint64_t result = mosyntknowl_WriteTraceHeader(a1, 1u);
            if ((result & 0x80000000) != 0) {
              break;
            }
            uint64_t result = mosyntbase_WInt3Ln(a1, "parsing at position ", 0, v9, (unsigned __int8 *)&byte_20D5A22AE, 0);
            if ((result & 0x80000000) != 0) {
              break;
            }
          }
          uint64_t v18 = *(void *)(*(void *)(a2 + 424) + 8 * v9);
          uint64_t v19 = *(void *)(a2 + 464);
          if (!v19)
          {
            uint64_t result = mosyntpal_ALLOCATE(a1, v16, 0x10u);
            if ((result & 0x80000000) != 0) {
              return result;
            }
            uint64_t v19 = *v16;
            *(void *)*uint64_t v16 = 0;
          }
          *(void *)(a2 + 472) = v19;
          while (1)
          {
            uint64_t v18 = *(void *)(v18 + 8);
            if (!v18) {
              break;
            }
            uint64_t result = AddTwolState(a1, a2, *(__int16 *)(v18 + 36));
            if ((result & 0x80000000) != 0) {
              return result;
            }
          }
          int v29 = v17;
          uint64_t v30 = v16;
          unsigned int v31 = 1;
LABEL_20:
          if (*(int *)a2 >= 3)
          {
            uint64_t result = mosyntknowl_WriteTraceHeader(a1, 1u);
            if ((result & 0x80000000) != 0) {
              break;
            }
            uint64_t result = mosyntbase_WInt3Ln(a1, "epsilon closure run number ", 0, v31, (unsigned __int8 *)&byte_20D5A22AE, 0);
            if ((result & 0x80000000) != 0) {
              break;
            }
          }
          *(unsigned char *)(a2 + 492) = 0;
          int v21 = *(uint64_t ***)(a2 + 464);
          int v20 = *(uint64_t ***)(a2 + 472);
          if (v21 != v20)
          {
            do
            {
              uint64_t v22 = a6;
              uint64_t v23 = a5;
              if (a6 >= 1)
              {
                while (1)
                {
                  uint64_t result = mosyntkblex_StartLookup(*v23, &v32);
                  if ((result & 0x80000000) != 0) {
                    return result;
                  }
                  uint64_t v24 = *((__int16 *)v21 + 4);
                  long long v36 = v32;
                  *(void *)&long long v37 = v33;
                  uint64_t result = GetAndTreatEntries(a1, a2, 1, 0, v9, v9, a4, v24, v24, &v36, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t, int))TreatLexEntryList);
                  if ((result & 0x80000000) != 0) {
                    return result;
                  }
                  ++v23;
                  if (!--v22)
                  {
                    int v20 = *(uint64_t ***)(a2 + 472);
                    break;
                  }
                }
              }
              int v21 = (uint64_t **)*v21;
            }
            while (v21 != v20);
            ++v31;
            int v21 = v20;
            if (*(unsigned char *)(a2 + 492)) {
              goto LABEL_20;
            }
          }
          if (*(int *)a2 >= 3)
          {
            uint64_t result = mosyntknowl_WriteTraceHeader(a1, 1u);
            if ((result & 0x80000000) != 0) {
              return result;
            }
            uint64_t result = mosyntbase_WInt3Ln(a1, "non-empty search run in position ", 0, v9, (unsigned __int8 *)&byte_20D5A22AE, 0);
            if ((result & 0x80000000) != 0) {
              return result;
            }
            int v21 = *(uint64_t ***)(a2 + 472);
          }
          *(unsigned char *)(a2 + 492) = 0;
          uint64_t v25 = *(uint64_t ***)(a2 + 464);
          uint64_t v28 = a5;
          if (v25 != v21)
          {
            while (1)
            {
              uint64_t v26 = a6;
              if (a6 >= 1) {
                break;
              }
LABEL_41:
              uint64_t v25 = (uint64_t **)*v25;
              a5 = v28;
              if (v25 == v21) {
                goto LABEL_42;
              }
            }
            while (1)
            {
              uint64_t result = mosyntkblex_StartLookup(*a5, &v32);
              if ((result & 0x80000000) != 0) {
                return result;
              }
              uint64_t v27 = *((__int16 *)v25 + 4);
              long long v36 = v32;
              *(void *)&long long v37 = v33;
              uint64_t result = GetAndTreatEntries(a1, a2, 0, 1, v9, v9, a4, v27, v27, &v36, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t, int))TreatLexEntryList);
              if ((result & 0x80000000) != 0) {
                return result;
              }
              ++a5;
              if (!--v26)
              {
                int v21 = *(uint64_t ***)(a2 + 472);
                goto LABEL_41;
              }
            }
          }
LABEL_42:
          if (!*(_DWORD *)(*(void *)(*(void *)(a2 + 424) + 8 * v9) + 4)
            || (uint64_t result = FindReadings(a1, a2, v9), (result & 0x80000000) == 0))
          {
            RemoveUnreferenced(a2, v9);
            uint64_t result = 0;
            ++v9;
            int v17 = v29;
            uint64_t v16 = v30;
            if (v29 != v9) {
              continue;
            }
          }
          return result;
        }
      }
    }
  }
  return result;
}

uint64_t GetAndTreatEntries(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, uint64_t a8, unsigned int a9, long long *a10, uint64_t (*a11)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t, int))
{
  v33[0] = 0;
  long long v29 = 0uLL;
  uint64_t v30 = 0;
  BOOL v28 = 0;
  uint64_t FirstSameInSymPair = mosyntkbfst_GetFirstSameInSymPair(*(__int16 **)(a2 + 408), 0, (uint64_t)v33, &v28);
  if ((FirstSameInSymPair & 0x80000000) == 0)
  {
    char v32 = 0;
    int v31 = 0;
    while (v28)
    {
      uint64_t v19 = ApplyChar(a1, a2, a3, a4, a5, a6, v33[0], a8, a9, a10, a11, &v31, (uint64_t)&v29, &v32);
      if ((v19 & 0x80000000) != 0) {
        return v19;
      }
      if (v32)
      {
        long long v26 = v29;
        uint64_t v27 = v30;
        uint64_t v19 = GetAndTreatEntries(a1, a2, a3, a4, a5, a6, a7, a8, v31, &v26, a11);
        if ((v19 & 0x80000000) != 0) {
          return v19;
        }
      }
      uint64_t FirstSameInSymPair = mosyntkbfst_GetNextSameInSymPair(*(void *)(a2 + 408), (int *)v33, &v28);
      if ((FirstSameInSymPair & 0x80000000) != 0) {
        return FirstSameInSymPair;
      }
    }
    if (*(_DWORD *)(*(void *)(*(void *)(a2 + 424) + 8 * (int)a6) + 4))
    {
      int v20 = mosyntkbsymtab_GraphTermId(*(void *)(a2 + 8));
      for (uint64_t i = mosyntkbfst_GetFirstSameInSymPair(*(__int16 **)(a2 + 408), v20, (uint64_t)v33, &v28);
            ;
            uint64_t i = mosyntkbfst_GetNextSameInSymPair(*(void *)(a2 + 408), (int *)v33, &v28))
      {
        uint64_t FirstSameInSymPair = i;
        if ((i & 0x80000000) != 0) {
          break;
        }
        if (!v28) {
          goto LABEL_18;
        }
        if (mosyntkbfst_OutSym(*(void *)(a2 + 408), v33) == v20)
        {
          if (!v28) {
            goto LABEL_18;
          }
          uint64_t v22 = ApplyChar(a1, a2, a3, a4, a5, a6, v33[0], a8, a9, a10, a11, &v31, (uint64_t)&v29, &v32);
          uint64_t FirstSameInSymPair = v22;
          if (a4 && (v22 & 0x80000000) == 0) {
            goto LABEL_19;
          }
          return FirstSameInSymPair;
        }
      }
    }
    else
    {
LABEL_18:
      if (a4)
      {
LABEL_19:
        if ((int)a6 < (int)a7)
        {
          uint64_t FirstSameInSymPair = mosyntkbfst_GetFirstSameInSymPair(*(__int16 **)(a2 + 408), **(_WORD **)(*(void *)(a2 + 424) + 8 * (int)a6), (uint64_t)v33, &v28);
          if ((FirstSameInSymPair & 0x80000000) == 0 && v28)
          {
            uint64_t v23 = (a6 + 1);
            while (1)
            {
              uint64_t v19 = ApplyChar(a1, a2, a3, a4, a5, v23, v33[0], a8, a9, a10, a11, &v31, (uint64_t)&v29, &v32);
              if ((v19 & 0x80000000) != 0) {
                break;
              }
              if (v32)
              {
                long long v26 = v29;
                uint64_t v27 = v30;
                uint64_t v19 = GetAndTreatEntries(a1, a2, a3, a4, a5, v23, a7, a8, v31, &v26, a11);
                if ((v19 & 0x80000000) != 0) {
                  break;
                }
              }
              uint64_t FirstSameInSymPair = mosyntkbfst_GetNextSameInSymPair(*(void *)(a2 + 408), (int *)v33, &v28);
              if ((FirstSameInSymPair & 0x80000000) != 0 || !v28) {
                return FirstSameInSymPair;
              }
            }
            return v19;
          }
        }
      }
    }
  }
  return FirstSameInSymPair;
}

uint64_t GenFullFormReading(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __int16 a6, uint64_t a7, int a8, unsigned int a9)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  long long v28 = 0uLL;
  uint64_t v29 = 0;
  long long v26 = 0u;
  long long v27 = 0u;
  int v34 = 0;
  memset(v33, 0, sizeof(v33));
  if (!*(_DWORD *)(*(void *)(*(void *)(a2 + 424) + 8 * a8) + 4)) {
    return 0;
  }
  uint64_t result = IsAcceptingFSTState(a1, a2, a9);
  if (result)
  {
    char v30 = 0;
    char v25 = 0;
    int v23 = 0;
    int v24 = 0;
    uint64_t result = mosyntkblex_GetFirstEntry(a5, &v30, &v28);
    if ((result & 0x80000000) == 0)
    {
      __int16 v15 = a8 - a6;
      while (v30)
      {
        uint64_t result = mosyntkblex_GetEntryCostAndConsList(a1, &v28, &v23, v33, 500);
        if ((result & 0x80000000) == 0)
        {
          uint64_t result = mosyntdata_GetFirstLexItem(a1, *(uint64_t **)(a2 + 8), &v28, (uint64_t)v33, 500, &v24, &v25, (uint64_t)&v26);
          if ((result & 0x80000000) == 0)
          {
            while (v25)
            {
              int v16 = v23;
              long long v17 = v27;
              long long v22 = v26;
              int v31 = 0;
              uint64_t v32 = 0;
              uint64_t result = mosyntpal_ALLOCATE(a1, &v32, 0x38u);
              if ((result & 0x80000000) == 0)
              {
                *(void *)uint64_t v32 = 0;
                uint64_t v18 = v32;
                *(_OWORD *)(v32 + 8) = v22;
                *(_OWORD *)(v18 + 24) = v17;
                *(_WORD *)(v18 + 40) = v15;
                *(_DWORD *)(v18 + 48) = 1;
                uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v31, 0x18u);
                if ((result & 0x80000000) == 0)
                {
                  uint64_t v19 = *(void *)(a2 + 424);
                  *int v31 = *(void *)(*(void *)(v19 + 8 * a8) + 120);
                  int v20 = v31;
                  *(void *)(*(void *)(v19 + 8 * a8) + 120) = v31;
                  *((_DWORD *)v20 + 2) = DWORD2(v17);
                  *((_DWORD *)v20 + 3) = v16;
                  v20[2] = v32;
                  if (*(_DWORD *)(a2 + 436) < a8) {
                    *(_DWORD *)(a2 + 436) = a8;
                  }
                  ++*(_DWORD *)(a2 + 488);
                  uint64_t result = mosyntdata_GetNextLexItem(a1, *(uint64_t **)(a2 + 8), &v28, (uint64_t)v33, 500, &v24, &v25, (uint64_t)&v26);
                  if ((result & 0x80000000) == 0) {
                    continue;
                  }
                }
              }
              return result;
            }
            uint64_t result = mosyntkblex_GetNextEntry(&v30, &v28);
            if ((result & 0x80000000) == 0) {
              continue;
            }
          }
        }
        return result;
      }
      uint64_t result = mosyntkblex_FinishEntrySearch(&v28);
      if ((result & 0x80000000) == 0)
      {
        uint64_t v21 = *(void *)(*(void *)(a2 + 424) + 8 * a8);
        if (*(_DWORD *)(v21 + 4) <= 1u)
        {
          uint64_t result = 0;
          *(_DWORD *)(v21 + 4) = 2;
          return result;
        }
        return 0;
      }
    }
  }
  return result;
}

uint64_t ApplyChar(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, long long *a10, uint64_t (*a11)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t, uint64_t, int), int *a12, uint64_t a13, unsigned char *a14)
{
  uint64_t v20 = 0;
  uint64_t v36 = a7;
  *a14 = 0;
  if (*(int *)a2 >= 3)
  {
    uint64_t v21 = mosyntknowl_WriteTraceHeader(a1, 1u);
    if ((v21 & 0x80000000) != 0) {
      return v21;
    }
    uint64_t v21 = mosyntbase_WString(a1, "trying pair ", 0);
    if ((v21 & 0x80000000) != 0) {
      return v21;
    }
    uint64_t v21 = mosyntkbfst_WriteGraphPair(a1, *(uint64_t **)(a2 + 8), *(void *)(a2 + 408), &v36, 2);
    if ((v21 & 0x80000000) != 0) {
      return v21;
    }
    uint64_t v20 = mosyntbase_WLn(a1);
    if ((v20 & 0x80000000) != 0) {
      return v20;
    }
  }
  int v22 = mosyntkbfst_FSTTrans(*(void *)(a2 + 408), a9, &v36);
  *a12 = v22;
  if (v22 < 1) {
    return v20;
  }
  long long v23 = *a10;
  *(void *)(a13 + 16) = *((void *)a10 + 2);
  *(_OWORD *)a13 = v23;
  if (*(int *)a2 >= 3)
  {
    uint64_t v21 = mosyntknowl_WriteTraceHeader(a1, 1u);
    if ((v21 & 0x80000000) != 0) {
      return v21;
    }
    uint64_t v21 = mosyntbase_WString(a1, "looking up ", 0);
    if ((v21 & 0x80000000) != 0) {
      return v21;
    }
    uint64_t v21 = mosyntkbfst_WriteGraphPair(a1, *(uint64_t **)(a2 + 8), *(void *)(a2 + 408), &v36, 1);
    if ((v21 & 0x80000000) != 0) {
      return v21;
    }
    uint64_t v21 = mosyntbase_WLn(a1);
    if ((v21 & 0x80000000) != 0) {
      return v21;
    }
  }
  if (!mosyntkbfst_OutSym(*(void *)(a2 + 408), &v36))
  {
    if (*(int *)a2 >= 3)
    {
      uint64_t v21 = mosyntknowl_WriteTraceHeader(a1, 1u);
      if ((v21 & 0x80000000) != 0) {
        return v21;
      }
      uint64_t v21 = mosyntbase_WString(a1, "looking up emtpy lex char", 0);
      if ((v21 & 0x80000000) != 0) {
        return v21;
      }
      uint64_t v21 = mosyntbase_WLn(a1);
      if ((v21 & 0x80000000) != 0) {
        return v21;
      }
    }
    char v35 = 1;
LABEL_34:
    *a14 = 1;
    return a11(a1, a2, a3, a4, a13, a5, a8, a6, *a12);
  }
  unsigned int v33 = a6;
  uint64_t v24 = *(void *)(a2 + 8);
  signed int v25 = mosyntkbfst_OutSym(*(void *)(a2 + 408), &v36);
  uint64_t v21 = mosyntkbsymtab_GraphSymString(a1, v24, v25, (char *)(a2 + 512), 500);
  if ((v21 & 0x80000000) != 0) {
    return v21;
  }
  if (*(int *)a2 >= 3)
  {
    uint64_t v21 = mosyntknowl_WriteTraceHeader(a1, 1u);
    if ((v21 & 0x80000000) != 0) {
      return v21;
    }
    uint64_t v21 = mosyntbase_WString(a1, "looking up ", 0);
    if ((v21 & 0x80000000) != 0) {
      return v21;
    }
    uint64_t v21 = mosyntbase_WString(a1, (unsigned __int8 *)(a2 + 512), 500);
    if ((v21 & 0x80000000) != 0) {
      return v21;
    }
    uint64_t v21 = mosyntbase_WLn(a1);
    if ((v21 & 0x80000000) != 0) {
      return v21;
    }
  }
  int v26 = mosyntbase_Length(a2 + 512, 500);
  char v35 = 1;
  a6 = a6;
  if (v26 < 1) {
    goto LABEL_34;
  }
  unsigned int v32 = a8;
  unint64_t v27 = v26;
  uint64_t v28 = 512;
  while (1)
  {
    uint64_t v20 = mosyntkblex_LookupChar(*(char *)(a2 + v28), a13, &v35);
    if ((v20 & 0x80000000) != 0) {
      return v20;
    }
    unint64_t v29 = v28 - 511;
    ++v28;
    if (v35) {
      BOOL v30 = v29 >= v27;
    }
    else {
      BOOL v30 = 1;
    }
    if (v30)
    {
      a8 = v32;
      a6 = v33;
      if (v35) {
        goto LABEL_34;
      }
      return v20;
    }
  }
}

BOOL IsAcceptingFSTState(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = 0;
  BOOL v8 = 0;
  int v6 = mosyntkbsymtab_GraphTermId(*(void *)(a2 + 8));
  mosyntkbfst_GetFirstSameInSymPair(*(__int16 **)(a2 + 408), v6, (uint64_t)&v9, &v8);
  while (v8)
  {
    if (mosyntkbfst_OutSym(*(void *)(a2 + 408), &v9) == v6)
    {
      if (v8) {
        return mosyntkbfst_FSTTrans(*(void *)(a2 + 408), a3, &v9) == 1;
      }
      break;
    }
    mosyntkbfst_GetNextSameInSymPair(*(void *)(a2 + 408), (int *)&v9, &v8);
  }
  mosyntbase_WString(a1, "*** error: termination pair not found in FST alphabet", 0);
  mosyntbase_WLn(a1);
  return 0;
}

uint64_t AddTwolState(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v4 = (void *)(a2 + 464);
  uint64_t v5 = *(void *)(a2 + 472);
  while (1)
  {
    unsigned int v4 = (void *)*v4;
    BOOL v8 = v4;
    if (v4 == (void *)v5) {
      break;
    }
    if (*((__int16 *)v4 + 4) == a3) {
      return 0;
    }
  }
  *(_WORD *)(v5 + 8) = a3;
  uint64_t v7 = *(void **)v5;
  if (v7)
  {
    uint64_t result = 0;
  }
  else
  {
    uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v8, 0x10u);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    *BOOL v8 = 0;
    uint64_t v7 = v8;
    **(void **)(a2 + 472) = v8;
  }
  *(void *)(a2 + 472) = v7;
  return result;
}

uint64_t TreatLexEntryList(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, signed int a6, unsigned int a7, uint64_t a8, unsigned int a9)
{
  v37[2] = *MEMORY[0x263EF8340];
  if (a3 && a8 == a6 || (uint64_t result = 0, a4) && (int)a8 > a6)
  {
    char v32 = 0;
    uint64_t v31 = 0;
    long long v30 = 0uLL;
    long long v28 = 0u;
    long long v29 = 0u;
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    uint64_t v25 = 0;
    v36[1] = 0;
    v37[0] = 0;
    v36[0] = 0;
    *(void *)((char *)v37 + 6) = 0;
    char v24 = 0;
    int v23 = 0;
    int v35 = 0;
    memset(v34, 0, sizeof(v34));
    uint64_t result = mosyntkblex_GetFirstEntry(a5, &v32, &v30);
    if ((result & 0x80000000) == 0)
    {
      __int16 v15 = (unsigned __int8 *)(a2 + 1012);
      int v16 = "found lex item";
      while (1)
      {
        if (!v32) {
          return mosyntkblex_FinishEntrySearch(&v30);
        }
        uint64_t result = mosyntkblex_GetEntryCostAndConsList(a1, &v30, (char *)&v25 + 4, v34, 500);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t result = mosyntdata_GetFirstLexItem(a1, *(uint64_t **)(a2 + 8), &v30, (uint64_t)v34, 500, &v23, &v24, (uint64_t)&v28);
        if ((result & 0x80000000) != 0) {
          return result;
        }
LABEL_10:
        if (v24 && !kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)result)) {
          break;
        }
        uint64_t result = mosyntkblex_GetNextEntry(&v32, &v30);
        if ((result & 0x80000000) != 0) {
          return result;
        }
      }
      if (*(int *)a2 < 2) {
        goto LABEL_53;
      }
      uint64_t result = mosyntknowl_WriteTraceHeader(a1, 1u);
      if ((result & 0x80000000) == 0)
      {
        m2__cp__str(v16, v36, 30);
        long long v21 = v28;
        long long v22 = v29;
        uint64_t result = mosyntkblex_GetEntryGraph(a1, &v21, v15, 1000);
        if ((result & 0x80000000) == 0)
        {
          uint64_t result = mosyntbase_WString(a1, (unsigned __int8 *)v36, 30);
          if ((result & 0x80000000) == 0)
          {
            uint64_t result = mosyntbase_WString(a1, " ", 0);
            if ((result & 0x80000000) == 0)
            {
              uint64_t result = mosyntbase_WString(a1, v15, 1000);
              if ((result & 0x80000000) == 0)
              {
                uint64_t result = mosyntkblex_GetEntryPhon(a1, &v21, v15, 1000);
                if ((result & 0x80000000) == 0)
                {
                  uint64_t result = mosyntbase_WString(a1, " [", 0);
                  if ((result & 0x80000000) == 0)
                  {
                    uint64_t result = mosyntbase_WString(a1, v15, 1000);
                    if ((result & 0x80000000) == 0)
                    {
                      unsigned int v33 = 0;
                      uint64_t result = mosyntkblex_GetEntryCost(a1, &v21, &v33);
                      if ((result & 0x80000000) == 0)
                      {
                        uint64_t result = mosyntbase_WString(a1, "] cons ", 0);
                        if ((result & 0x80000000) == 0)
                        {
                          uint64_t result = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), DWORD2(v22));
                          if ((result & 0x80000000) == 0)
                          {
                            if (v33 == 1
                              || (uint64_t result = mosyntbase_WString(a1, "(cost ", 0), (result & 0x80000000) == 0)
                              && (uint64_t result = mosyntbase_WInt(a1, v33, 0), (result & 0x80000000) == 0)
                              && (uint64_t result = mosyntbase_WString(a1, ") ", 0), (result & 0x80000000) == 0))
                            {
                              uint64_t result = mosyntbase_WString(a1, " from pos ", 0);
                              if ((result & 0x80000000) == 0)
                              {
                                uint64_t result = mosyntbase_WInt(a1, a6, 0);
                                if ((result & 0x80000000) == 0)
                                {
                                  uint64_t result = mosyntbase_WString(a1, " / FST state ", 0);
                                  if ((result & 0x80000000) == 0)
                                  {
                                    uint64_t result = mosyntbase_WInt(a1, a7, 0);
                                    if ((result & 0x80000000) == 0)
                                    {
                                      uint64_t result = mosyntbase_WString(a1, " to pos ", 0);
                                      if ((result & 0x80000000) == 0)
                                      {
                                        uint64_t result = mosyntbase_WInt(a1, a8, 0);
                                        if ((result & 0x80000000) == 0)
                                        {
                                          uint64_t result = mosyntbase_WString(a1, " / FST state ", 0);
                                          if ((result & 0x80000000) == 0)
                                          {
                                            uint64_t result = mosyntbase_WInt(a1, a9, 0);
                                            if ((result & 0x80000000) == 0)
                                            {
                                              uint64_t result = mosyntbase_WLn(a1);
                                              if ((result & 0x80000000) == 0)
                                              {
LABEL_53:
                                                uint64_t result = mosyntkbwgram_GetFirstNFATrans(*(void *)(a2 + 416), DWORD2(v29), &v27, (char *)&v26 + 4, &v26, &v25);
                                                if ((result & 0x80000000) == 0)
                                                {
                                                  uint64_t v20 = v15;
                                                  long long v17 = v16;
                                                  while ((v26 & 0x8000000000000000) == 0)
                                                  {
                                                    for (uint64_t i = *(void *)(*(void *)(*(void *)(a2 + 424) + 8 * a6)
                                                                        + 8 * ((int)(HIDWORD(v26) + a7) % 13)
                                                                        + 16); i; uint64_t i = *(void *)(i + 16))
                                                    {
                                                      if (__PAIR64__(*(__int16 *)(i + 36), *(_DWORD *)(i + 32)) == __PAIR64__(a7, HIDWORD(v26)))
                                                      {
                                                        int v19 = v25 + *(_DWORD *)(i + 40) + HIDWORD(v25);
                                                        long long v21 = v28;
                                                        long long v22 = v29;
                                                        uint64_t result = InsertEntry(a1, a2, a6, a8, 0, v26, a9, v19, i, &v21);
                                                        if ((result & 0x80000000) != 0) {
                                                          return result;
                                                        }
                                                      }
                                                    }
                                                    uint64_t result = mosyntkbwgram_GetNextNFATrans(*(void *)(a2 + 416), DWORD2(v29), &v27, (char *)&v26 + 4, &v26, &v25);
                                                    if ((result & 0x80000000) != 0) {
                                                      return result;
                                                    }
                                                  }
                                                  uint64_t result = mosyntdata_GetNextLexItem(a1, *(uint64_t **)(a2 + 8), &v30, (uint64_t)v34, 500, &v23, &v24, (uint64_t)&v28);
                                                  int v16 = v17;
                                                  __int16 v15 = v20;
                                                  if ((result & 0x80000000) == 0) {
                                                    goto LABEL_10;
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t FindReadings(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(*(void *)(*(void *)(a2 + 424) + 8 * a3) + 8);
  if (!v3) {
    return 0;
  }
  uint64_t v25 = a3;
  while (!*(unsigned char *)(v3 + 38) || !IsAcceptingFSTState(a1, a2, *(__int16 *)(v3 + 36)))
  {
LABEL_30:
    uint64_t v3 = *(void *)(v3 + 8);
    if (!v3) {
      return 0;
    }
  }
  uint64_t v7 = 0;
  uint64_t v26 = 0;
  uint64_t v8 = v3;
  do
  {
    uint64_t v9 = v8;
    *(void *)(v8 + 88) = v7;
    uint64_t v8 = *(void *)(v8 + 48);
    uint64_t v7 = v9;
  }
  while (v8);
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v27 = 0;
  long long v28 = 0;
  int v12 = *(void **)(a2 + 480);
  while (1)
  {
    uint64_t v13 = *(void *)(v9 + 48);
    if (v13)
    {
      if (*(unsigned __int16 *)(v13 + 30) != *(unsigned __int16 *)(v9 + 28))
      {
        uint64_t v11 = mosyntbase_WriteDevelMessage(a1, "***** inconsistent word analysis reading\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, 0, 0, 0);
        if ((v11 & 0x80000000) != 0) {
          return v11;
        }
      }
    }
    if (mosyntdata_IsValidLexItem(v9 + 56))
    {
      for (uint64_t i = (void *)*v12; ; uint64_t i = (void *)i[1])
      {
        long long v28 = i;
        if (!i) {
          break;
        }
        uint64_t v15 = i[2];
        if (v15)
        {
          BOOL v16 = mosyntdata_IdenticalLexItems(v15 + 8, v9 + 56);
          uint64_t i = v28;
          if (v16)
          {
            if (v28)
            {
              uint64_t v10 = v28[2];
              goto LABEL_23;
            }
            break;
          }
        }
      }
      uint64_t v17 = mosyntpal_ALLOCATE(a1, &v27, 0x38u);
      if ((v17 & 0x80000000) != 0) {
        return v17;
      }
      *(void *)uint64_t v27 = v12[2];
      uint64_t v18 = v27;
      long long v19 = *(_OWORD *)(v9 + 72);
      *(_OWORD *)(v27 + 8) = *(_OWORD *)(v9 + 56);
      *(_OWORD *)(v18 + 24) = v19;
      *(_WORD *)(v18 + 40) = *(_WORD *)(v9 + 30) - *(_WORD *)(v9 + 28);
      uint64_t v11 = mosyntpal_ALLOCATE(a1, (uint64_t *)&v28, 0x18u);
      if ((v11 & 0x80000000) != 0) {
        return v11;
      }
      uint64_t v20 = v28;
      v28[1] = *v12;
      *int v12 = v20;
      *long long v28 = 0;
      uint64_t v10 = v27;
      uint64_t i = v28;
      v28[2] = v27;
    }
    else
    {
      uint64_t i = v12;
    }
LABEL_23:
    uint64_t v9 = *(void *)(v9 + 88);
    int v12 = i;
    if (!v9)
    {
      if ((v11 & 0x80000000) != 0) {
        return v11;
      }
      uint64_t v17 = mosyntpal_ALLOCATE(a1, (uint64_t *)&v26, 0x18u);
      if ((v17 & 0x80000000) != 0) {
        return v17;
      }
      uint64_t v21 = *(void *)(a2 + 424);
      *uint64_t v26 = *(void *)(*(void *)(v21 + 8 * v25) + 120);
      long long v22 = v26;
      *(void *)(*(void *)(v21 + 8 * v25) + 120) = v26;
      *((_DWORD *)v22 + 2) = *(_DWORD *)(v3 + 32);
      *((_DWORD *)v22 + 3) = *(_DWORD *)(v3 + 40);
      v22[2] = v10;
      if (*(_DWORD *)(a2 + 436) < a3) {
        *(_DWORD *)(a2 + 436) = a3;
      }
      ++*(_DWORD *)(a2 + 488);
      uint64_t v23 = *(void *)(v21 + 8 * v25);
      if (*(_DWORD *)(v23 + 4) <= 1u) {
        *(_DWORD *)(v23 + 4) = 2;
      }
      goto LABEL_30;
    }
  }
}

uint64_t RemoveUnreferenced(uint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 424);
  uint64_t v3 = *(void *)(v2 + 8 * a2);
  uint64_t v4 = *(void *)(v3 + 8);
  if (v4)
  {
    do
    {
      uint64_t v5 = v4;
      do
      {
        if (*(_DWORD *)(v5 + 24)) {
          break;
        }
        uint64_t v6 = *(void *)(v5 + 48);
        if (v6) {
          --*(_DWORD *)(v6 + 24);
        }
        *(void *)(v5 + 48) = 0;
        if (*(__int16 *)(v5 + 30) < a2)
        {
          *(void *)(v5 + 8) = *(void *)(result + 456);
          *(void *)(result + 456) = v5;
        }
        uint64_t v5 = v6;
      }
      while (v6);
      uint64_t v4 = *(void *)(v4 + 8);
    }
    while (v4);
    uint64_t v3 = *(void *)(v2 + 8 * a2);
    uint64_t v7 = *(void *)(v3 + 8);
    if (v7)
    {
      do
      {
        uint64_t v8 = *(void *)(v7 + 8);
        if (!*(_DWORD *)(v7 + 24))
        {
          *(void *)(v7 + 8) = *(void *)(result + 456);
          *(void *)(result + 456) = v7;
        }
        uint64_t v7 = v8;
      }
      while (v8);
      uint64_t v3 = *(void *)(v2 + 8 * a2);
    }
  }
  *(void *)(v3 + 8) = 0;
  for (uint64_t i = 16; i != 120; i += 8)
    *(void *)(*(void *)(*(void *)(result + 424) + 8 * a2) + i) = 0;
  return result;
}

uint64_t InsertEntry(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, int a5, int a6, int a7, int a8, uint64_t a9, long long *a10)
{
  v33[4] = *MEMORY[0x263EF8340];
  memset(v33, 0, 30);
  int v16 = (a7 + a6) % 13;
  uint64_t v17 = *(void *)(a2 + 424);
  uint64_t v18 = *(void *)(*(void *)(v17 + 8 * (int)a4) + 8 * v16 + 16);
  uint64_t v32 = v18;
  if (v18)
  {
    while (*(_DWORD *)(v18 + 32) != a6 || *(__int16 *)(v18 + 36) != a7)
    {
      uint64_t v18 = *(void *)(v18 + 16);
      if (!v18)
      {
        uint64_t v32 = 0;
        goto LABEL_6;
      }
    }
    if (*(_DWORD *)(v18 + 40) <= a8)
    {
      return 0;
    }
    else
    {
      *(_DWORD *)(v18 + 40) = a8;
      uint64_t v28 = *(void *)(v18 + 48);
      if (v28) {
        --*(_DWORD *)(v28 + 24);
      }
      *(void *)(v18 + 48) = a9;
      if (a9) {
        ++*(_DWORD *)(a9 + 24);
      }
      unsigned int v29 = a3;
      *(_WORD *)(v18 + 28) = a3;
      long long v30 = *a10;
      *(_OWORD *)(v18 + 72) = a10[1];
      *(_OWORD *)(v18 + 56) = v30;
      uint64_t result = TreatEmptyTrans(a1, a2, a4, v18);
      if ((result & 0x80000000) == 0)
      {
        if (*(int *)a2 < 2
          || (uint64_t result = mosyntknowl_WriteTraceHeader(a1, 1u), (result & 0x80000000) == 0)
          && (m2__cp__str("modified edge", v33, 30),
              uint64_t result = WriteParseEntry(a1, a2, (unsigned __int8 *)v33, v18, v29, a4),
              (result & 0x80000000) == 0))
        {
          *(unsigned char *)(a2 + 492) = 1;
        }
      }
    }
  }
  else
  {
LABEL_6:
    uint64_t v19 = *(void *)(a2 + 456);
    if (v19)
    {
      uint64_t v32 = *(void *)(a2 + 456);
      *(void *)(a2 + 456) = *(void *)(v19 + 8);
    }
    else
    {
      int v31 = a5;
      unsigned int v20 = a3;
      uint64_t result = mosyntpal_ALLOCATE(a1, &v32, 0x60u);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      *(void *)uint64_t v32 = *(void *)(a2 + 440);
      uint64_t v19 = v32;
      *(void *)(a2 + 440) = v32;
      ++*(_DWORD *)(a2 + 448);
      uint64_t v17 = *(void *)(a2 + 424);
      a3 = v20;
      a5 = v31;
    }
    uint64_t v22 = *(void *)(v17 + 8 * (int)a4);
    *(void *)(v19 + 8) = *(void *)(v22 + 8);
    *(void *)(v22 + 8) = v19;
    uint64_t v23 = v22 + 8 * v16;
    *(void *)(v19 + 16) = *(void *)(v23 + 16);
    *(void *)(v23 + 16) = v19;
    uint64_t v24 = v32;
    *(_DWORD *)(v32 + 24) = 0;
    *(_WORD *)(v24 + 28) = a3;
    *(_WORD *)(v24 + 30) = a4;
    *(_DWORD *)(v24 + 32) = a6;
    *(_WORD *)(v24 + 36) = a7;
    *(unsigned char *)(v24 + 38) = 0;
    *(_DWORD *)(v24 + 40) = a8;
    *(void *)(v24 + 48) = a9;
    if (a9) {
      ++*(_DWORD *)(a9 + 24);
    }
    long long v25 = *a10;
    *(_OWORD *)(v24 + 72) = a10[1];
    *(_OWORD *)(v24 + 56) = v25;
    if (a4 != a3 || a5 || (v26 = a3, uint64_t result = AddTwolState(a1, a2, a7), a3 = v26, (result & 0x80000000) == 0))
    {
      if (*(int *)a2 < 2
        || (v27 = a3, uint64_t result = mosyntknowl_WriteTraceHeader(a1, 1u), (result & 0x80000000) == 0)
        && (m2__cp__str("inserted edge", v33, 30),
            uint64_t result = WriteParseEntry(a1, a2, (unsigned __int8 *)v33, v32, v27, a4),
            (result & 0x80000000) == 0))
      {
        *(unsigned char *)(a2 + 492) = 1;
        return TreatEmptyTrans(a1, a2, a4, v32);
      }
    }
  }
  return result;
}

uint64_t WriteParseEntry(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, unsigned int a5, unsigned int a6)
{
  uint64_t result = mosyntbase_WString(a1, a3, 30);
  if ((result & 0x80000000) == 0)
  {
    if (*(void *)(a4 + 48))
    {
      uint64_t result = mosyntbase_WString(a1, " from position ", 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntbase_WInt(a1, a5, 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntbase_WString(a1, " / state ", 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), *(_DWORD *)(*(void *)(a4 + 48) + 32));
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntbase_WString(a1, " / FST state ", 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntbase_WInt(a1, *(__int16 *)(*(void *)(a4 + 48) + 36), 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
    }
    else
    {
      uint64_t result = mosyntbase_WString(a1, " from inexistent predecessor", 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
    }
    uint64_t result = mosyntbase_WString(a1, " to position ", 0);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = mosyntbase_WInt(a1, a6, 0);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = mosyntbase_WString(a1, " / state ", 0);
        if ((result & 0x80000000) == 0)
        {
          uint64_t result = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), *(_DWORD *)(a4 + 32));
          if ((result & 0x80000000) == 0)
          {
            uint64_t result = mosyntbase_WString(a1, " / FST state ", 0);
            if ((result & 0x80000000) == 0)
            {
              uint64_t result = mosyntbase_WInt(a1, *(__int16 *)(a4 + 36), 0);
              if ((result & 0x80000000) == 0)
              {
                uint64_t result = mosyntbase_WString(a1, " cost ", 0);
                if ((result & 0x80000000) == 0)
                {
                  uint64_t result = mosyntbase_WInt(a1, *(_DWORD *)(a4 + 40), 0);
                  if ((result & 0x80000000) == 0)
                  {
                    return mosyntbase_WLn(a1);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t TreatEmptyTrans(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v13 = 0;
  int v12 = 0;
  char v11 = 0;
  int v10 = 0;
  memset(v9, 0, sizeof(v9));
  uint64_t result = mosyntdata_GetNilLexItem((uint64_t)v9);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = mosyntkbwgram_GetFirstEpsTrans(*(void *)(a2 + 416), *(_DWORD *)(a4 + 32), &v13, &v12, &v11, &v10);
    if ((result & 0x80000000) == 0 && (v12 & 0x80000000) == 0)
    {
      do
      {
        if (v11) {
          *(unsigned char *)(a4 + 38) = 1;
        }
        uint64_t result = InsertEntry(a1, a2, a3, a3, 1);
        if ((result & 0x80000000) != 0) {
          break;
        }
        uint64_t result = mosyntkbwgram_GetNextEpsTrans(*(void *)(a2 + 416), *(_DWORD *)(a4 + 32), (unsigned int *)&v13, &v12, &v11, &v10);
        if ((result & 0x80000000) != 0) {
          break;
        }
      }
      while ((v12 & 0x80000000) == 0);
    }
  }
  return result;
}

uint64_t PutOutReadingItem(uint64_t a1, uint64_t a2, int a3, int a4, unsigned int a5, int a6, uint64_t a7, void *a8)
{
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t result = mosyntpal_ALLOCATE(a1, &v19, 0x18u);
  if ((result & 0x80000000) == 0)
  {
    *(void *)uint64_t v19 = 0;
    uint64_t v17 = v19;
    *(_DWORD *)(v19 + 8) = a3;
    *(_DWORD *)(v17 + 12) = a4;
    *(void *)(v17 + 16) = a7;
    uint64_t result = mosyntpal_ALLOCATE(a1, &v20, 0x28u);
    if ((result & 0x80000000) == 0)
    {
      uint64_t v18 = v20;
      *(_DWORD *)(v20 + 8) = 0;
      *(_DWORD *)(v18 + 16) = *(_DWORD *)(a2 + 2212);
      *(_DWORD *)(v18 + 20) = a5;
      *(_DWORD *)(v18 + 24) = a6;
      *(void *)(v18 + 32) = v19;
      if ((a5 & 0x80000000) != 0)
      {
        uint64_t result = mosyntbase_WriteDevelMessage(a1, "***** erroneous reading start position %d; reading ignored\\n",
                   0,
                   (unsigned __int8 *)&byte_20D5A22AE,
                   0,
                   (unsigned __int8 *)&byte_20D5A22AE,
                   0,
                   (unsigned __int8 *)&byte_20D5A22AE,
                   0,
                   a5,
                   0,
                   0);
        if ((result & 0x80000000) == 0) {
          return mosyntdata_DisposeItem(a1, &v20);
        }
      }
      else
      {
        *(void *)uint64_t v18 = *a8;
        *a8 = v20;
      }
    }
  }
  return result;
}

uint64_t DisposeLexEleTreeList(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    uint64_t v6 = 0;
    while (1)
    {
      uint64_t result = DisposeLexEleTreeList(a1, v3);
      if ((result & 0x80000000) != 0) {
        break;
      }
      uint64_t v6 = v3;
      uint64_t v3 = *(void *)(v3 + 8);
      uint64_t result = mosyntpal_DEALLOCATE(a1, &v6);
      if ((result & 0x80000000) != 0) {
        break;
      }
      if (!v3) {
        goto LABEL_8;
      }
    }
  }
  else
  {
    uint64_t result = 0;
LABEL_8:
    *a2 = 0;
  }
  return result;
}

uint64_t mosyntknowl_GetPhraseBoundFromString(uint64_t a1, unsigned __int8 *a2, int a3, int *a4, _DWORD *a5)
{
  *a5 = -1;
  uint64_t result = mosyntutils_SkipBlanksInString((uint64_t)a2, a3, a4);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = mosyntutils_CheckSkipCharInString(a1, a2, a3, a4, 0x23u);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = mosyntutils_CheckSkipCharInString(a1, a2, a3, a4, 0x7Bu);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = mosyntutils_GetCardFromString(a1, a2, a3, a4, a5);
        if ((result & 0x80000000) == 0)
        {
          return mosyntutils_CheckSkipCharInString(a1, a2, a3, a4, 0x7Du);
        }
      }
    }
  }
  return result;
}

uint64_t mosyntknowl_GetPhraseTypeFromString(uint64_t a1, unsigned __int8 *a2, int a3, int *a4, int *a5)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  *a5 = 0;
  uint64_t result = mosyntutils_SkipBlanksInString((uint64_t)a2, a3, a4);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = mosyntutils_CheckSkipCharInString(a1, a2, a3, a4, 0x28u);
    if ((result & 0x80000000) == 0)
    {
      __int16 v12 = 0;
      uint64_t v11 = 0;
      uint64_t result = mosyntutils_GetIdent1FromString(a1, a2, a3, a4, &v11, 10);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = mosyntutils_CheckSkipCharInString(a1, a2, a3, a4, 0x29u);
        if ((result & 0x80000000) == 0) {
          return mosyntkbaccphr_StringToPhraseType(a1, (unsigned __int8 *)&v11, 10, a5);
        }
      }
    }
  }
  return result;
}

uint64_t mosyntknowl_GetAccentFromString(uint64_t a1, unsigned __int8 *a2, int a3, int *a4, _DWORD *a5)
{
  *a5 = -1;
  uint64_t result = mosyntutils_SkipBlanksInString((uint64_t)a2, a3, a4);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = mosyntutils_CheckSkipCharInString(a1, a2, a3, a4, 0x5Bu);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = mosyntutils_GetCardFromString(a1, a2, a3, a4, a5);
      if ((result & 0x80000000) == 0)
      {
        return mosyntutils_CheckSkipCharInString(a1, a2, a3, a4, 0x5Du);
      }
    }
  }
  return result;
}

uint64_t mosyntknowl_GetPhoneFromString(uint64_t a1, uint64_t *a2, unsigned __int8 *a3, int a4, int *a5, int *a6)
{
  v28[2] = *MEMORY[0x263EF8340];
  int v12 = mosyntkbsymtab_LHPlusMode(a2);
  uint64_t v13 = 0;
  *a6 = 0;
  uint64_t v14 = *a5;
  if ((int)v14 < a4)
  {
    if (!a3[v14]) {
      return 0;
    }
    int v15 = v12;
    uint64_t v13 = mosyntutils_SkipBlanksInString((uint64_t)a3, a4, a5);
    if ((v13 & 0x80000000) == 0)
    {
      uint64_t v16 = *a5;
      if ((int)v16 < a4)
      {
        unsigned int v17 = a3[v16];
        if (v17)
        {
          __int16 v25 = 0;
          memset(v28, 0, 15);
          uint64_t v26 = 0;
          __int16 v27 = 0;
          if (v17 > 0x1F)
          {
            if (v15 == 1) {
              uint64_t LhPlusPhone = mosyntkbsymtab_GetLhPlusPhone(a1, a2, (uint64_t)a3, a4, a5, (char *)v28, 15, (unsigned char *)&v25 + 1);
            }
            else {
              uint64_t LhPlusPhone = GetSVOXPAPhone(a1, (uint64_t)a3, a4, a5, v28, (char *)&v25 + 1);
            }
            uint64_t v13 = LhPlusPhone;
            if ((LhPlusPhone & 0x80000000) != 0) {
              return v13;
            }
            if (!HIBYTE(v25))
            {
              uint64_t v20 = mosyntbase_WriteDevelMessage(a1, "***** unknown phone at pos %d in '%s'\\n", 0, a3, a4, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, *a5, 0, 0);
LABEL_23:
              uint64_t v13 = v20;
              if ((v20 & 0x80000000) == 0) {
                goto LABEL_24;
              }
              return v13;
            }
            BYTE6(v28[1]) = 0;
            int v23 = mosyntkbsymtab_KnownPhonId(a1, a2, (uint64_t)v28);
            *a6 = v23;
            if (v23 > 0) {
              return v13;
            }
            return mosyntbase_WriteDevelMessage(a1, "***** unknown phone '%s'\\n", 0, (unsigned __int8 *)v28, 15, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, 0, 0, 0);
          }
          else
          {
            m2__cp__str("{c", v28, 15);
            uint64_t v18 = mosyntpal_IntToString(a3[*a5], 0, &v26, 10);
            if ((v18 & 0x80000000) == 0)
            {
              uint64_t v18 = mosyntbase_AppendTo((uint64_t)v28, 15, (uint64_t)&v26, 10, (BOOL *)&v25);
              if ((v18 & 0x80000000) == 0)
              {
                m2__cp__str("}", &v26, 10);
                uint64_t v13 = mosyntbase_AppendTo((uint64_t)v28, 15, (uint64_t)&v26, 10, (BOOL *)&v25);
                if ((v13 & 0x80000000) != 0) {
                  return v13;
                }
                BYTE6(v28[1]) = 0;
                int v19 = mosyntkbsymtab_KnownPhonId(a1, a2, (uint64_t)v28);
                *a6 = v19;
                if (v19 > 0)
                {
LABEL_24:
                  ++*a5;
                  return v13;
                }
                uint64_t v24 = a3[*a5];
                uint64_t v20 = mosyntbase_WriteDevelMessage(a1, "***** error in conversion of control character %d to symbol\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, v24, HIDWORD(v24), 0);
                goto LABEL_23;
              }
            }
          }
          return v18;
        }
      }
    }
  }
  return v13;
}

uint64_t GetSVOXPAPhone(uint64_t a1, uint64_t a2, int a3, int *a4, unsigned char *a5, char *a6)
{
  v22[2] = *MEMORY[0x263EF8340];
  memset(v22, 0, 14);
  BOOL v21 = 0;
  int v19 = 0;
  int v20 = 0;
  int v12 = *a4;
  *a5 = 0;
  *a6 = 1;
  uint64_t v13 = *a4;
  if ((int)v13 < a3 && *(unsigned char *)(a2 + v13) == 123)
  {
    uint64_t result = mosyntutils_AppChar((uint64_t)a5, 15, &v20, 123);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    uint64_t v15 = *a4 + 1;
    *a4 = v15;
    if ((int)v15 < a3)
    {
      unsigned int v16 = *(unsigned __int8 *)(a2 + v15);
      if (v16 >= 0x21)
      {
        while (v16 != 125)
        {
          uint64_t result = mosyntutils_GetUTF8Char(a1, a2, a3, a4, &v19);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t result = mosyntbase_App((uint64_t)a5, 15, &v20, (uint64_t)&v19, 4, &v21);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          LODWORD(v15) = *a4;
          if (*a4 < a3)
          {
            unsigned int v16 = *(unsigned __int8 *)(a2 + (int)v15);
            if (v16 >= 0x21) {
              continue;
            }
          }
          break;
        }
      }
    }
    if ((int)v15 >= a3 - 1 || *(unsigned char *)(a2 + (int)v15) != 125)
    {
      *a6 = 0;
LABEL_31:
      *a4 = v12;
      *a5 = 0;
      return result;
    }
    uint64_t result = mosyntutils_AppChar((uint64_t)a5, 15, &v20, 125);
    if ((result & 0x80000000) == 0)
    {
      ++*a4;
      if (!*a6) {
        goto LABEL_31;
      }
    }
  }
  else
  {
    while (1)
    {
      uint64_t result = GetSVOXPADiacPhone(a1, a2, a3, a4, v22, a6);
      if ((result & 0x80000000) != 0) {
        break;
      }
      uint64_t result = mosyntbase_App((uint64_t)a5, 15, &v20, (uint64_t)v22, 14, &v21);
      if ((result & 0x80000000) != 0) {
        break;
      }
      if (*a6) {
        BOOL v17 = !v21;
      }
      else {
        BOOL v17 = 1;
      }
      char v18 = !v17;
      *a6 = v18;
      if (v17) {
        goto LABEL_31;
      }
      if (*a4 >= a3) {
        return result;
      }
      if (*(unsigned char *)(a2 + *a4) != 95) {
        return result;
      }
      uint64_t result = mosyntutils_AppChar((uint64_t)a5, 15, &v20, 95);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      ++*a4;
    }
  }
  return result;
}

BOOL mosyntknowl_IsSentFinalPunct(uint64_t a1, unsigned int a2)
{
  return a2 > 8;
}

BOOL mosyntknowl_IsIntraSentPunct(uint64_t a1, int a2)
{
  return (a2 - 1) < 8;
}

uint64_t mosyntknowl_OrthPunctType(uint64_t a1, int a2)
{
  uint64_t result = 1;
  if (a2 > 57)
  {
    if ((a2 - 58) >= 2)
    {
      if (a2 == 63) {
        return 10;
      }
      return 0;
    }
  }
  else
  {
    if (a2 == 33) {
      return 11;
    }
    if (a2 != 44)
    {
      if (a2 == 46) {
        return 9;
      }
      return 0;
    }
  }
  return result;
}

uint64_t mosyntknowl_CopyFeatList(__int16 *a1, _WORD *a2)
{
  *a2 = *a1;
  if (*a1 >= 1)
  {
    uint64_t v2 = 1;
    do
      a2[v2] = a1[v2];
    while (v2++ < *a1);
  }
  return 0;
}

uint64_t mosyntknowl_NewBindingDesc(uint64_t a1, uint64_t *a2)
{
  uint64_t result = mosyntpal_ALLOCATE(a1, a2, 0x4B4u);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v4 = 0;
    uint64_t v5 = *a2;
    do
    {
      *(_DWORD *)(v5 + 4 * v4) = v4;
      ++v4;
    }
    while (v4 != 150);
    *(_DWORD *)(v5 + 600) = 0;
  }
  return result;
}

uint64_t mosyntknowl_DisposeBindingDesc(uint64_t a1, uint64_t *a2)
{
  if (!*a2)
  {
    uint64_t result = 0;
    goto LABEL_5;
  }
  uint64_t result = mosyntpal_DEALLOCATE(a1, a2);
  if ((result & 0x80000000) == 0) {
LABEL_5:
  }
    *a2 = 0;
  return result;
}

BOOL mosyntknowl_DiffFeat(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  int v3 = *a2;
  if (v3 != *a3) {
    return 1;
  }
  if (!(_WORD)v3 || (__int16)v3 < 1) {
    return 0;
  }
  if (a2[1] != a3[1]) {
    return 1;
  }
  uint64_t v4 = 0;
  do
  {
    uint64_t v5 = v4;
    if ((__int16)v3 - 1 == v4) {
      break;
    }
    int v6 = a2[v4 + 2];
    int v7 = a3[v4++ + 2];
  }
  while (v6 == v7);
  return v5 + 1 < (unint64_t)(unsigned __int16)v3;
}

uint64_t mosyntknowl_Unif (uint64_t a1, uint64_t *a2, int a3, uint64_t a4, unsigned __int16 *a5, unsigned __int16 *a6, __int16 *a7, __int16 *a8, char *a9)
{
  char v21 = 0;
  if (a3 < 3)
  {
    Unify(a4, a5, a6, 50, &v21);
    if (v21)
    {
      uint64_t result = GenRetFeat(a1, a4, a7, a8);
      if ((result & 0x80000000) != 0) {
        return result;
      }
LABEL_17:
      if (!a4)
      {
        char v19 = 1;
LABEL_32:
        uint64_t result = 0;
        *a9 = v19;
        return result;
      }
      BOOL v17 = (_DWORD *)(a4 + 600);
      if (*(int *)(a4 + 600) >= 1)
      {
        uint64_t v18 = 0;
        do
        {
          *(_DWORD *)(a4 + 4 * *(int *)(a4 + 604 + 4 * v18)) = *(_DWORD *)(a4 + 604 + 4 * v18);
          ++v18;
        }
        while (v18 < *(int *)(a4 + 600));
      }
      char v19 = 1;
LABEL_30:
      _DWORD *v17 = 0;
      goto LABEL_32;
    }
LABEL_25:
    if (!a4)
    {
      char v19 = 0;
      goto LABEL_32;
    }
    BOOL v17 = (_DWORD *)(a4 + 600);
    if (*(int *)(a4 + 600) >= 1)
    {
      uint64_t v20 = 0;
      do
      {
        *(_DWORD *)(a4 + 4 * *(int *)(a4 + 604 + 4 * v20)) = *(_DWORD *)(a4 + 604 + 4 * v20);
        ++v20;
      }
      while (v20 < *(int *)(a4 + 600));
    }
    char v19 = 0;
    goto LABEL_30;
  }
  uint64_t result = mosyntbase_WString(a1, "      unifying sc1A", 0);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = mosyntkbsymtab_WriteFeatList(a1, a2, (__int16 *)a5);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = mosyntbase_WString(a1, "/sc1B", 0);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = mosyntkbsymtab_WriteFeatList(a1, a2, (__int16 *)a6);
        if ((result & 0x80000000) == 0)
        {
          uint64_t result = mosyntbase_WLn(a1);
          if ((result & 0x80000000) == 0)
          {
            Unify(a4, a5, a6, 50, &v21);
            if (v21)
            {
              uint64_t result = GenRetFeat(a1, a4, a7, a8);
              if ((result & 0x80000000) != 0) {
                return result;
              }
              uint64_t result = mosyntbase_WString(a1, "      returning ", 0);
              if ((result & 0x80000000) != 0) {
                return result;
              }
              uint64_t result = mosyntkbsymtab_WriteFeatList(a1, a2, a7);
              if ((result & 0x80000000) != 0) {
                return result;
              }
              uint64_t result = mosyntbase_WString(a1, " as ", 0);
              if ((result & 0x80000000) != 0) {
                return result;
              }
              uint64_t result = mosyntkbsymtab_WriteFeatList(a1, a2, a8);
              if ((result & 0x80000000) != 0) {
                return result;
              }
              uint64_t result = mosyntbase_WLn(a1);
              if ((result & 0x80000000) != 0) {
                return result;
              }
              goto LABEL_17;
            }
            uint64_t result = mosyntbase_WString(a1, "      failed", 0);
            if ((result & 0x80000000) == 0)
            {
              uint64_t result = mosyntbase_WLn(a1);
              if ((result & 0x80000000) == 0) {
                goto LABEL_25;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t Unify(uint64_t result, unsigned __int16 *a2, unsigned __int16 *a3, int a4, char *a5)
{
  *a5 = 0;
  unint64_t v5 = *a2;
  if (v5 == *a3)
  {
    if ((__int16)v5 < 1)
    {
      char v7 = 1;
    }
    else
    {
      unint64_t v6 = 0;
      char v7 = 1;
      do
      {
        unsigned int v8 = (__int16)a2[v6 + 1];
        if ((v8 & 0x80000000) == 0)
        {
          unsigned int v9 = *(_DWORD *)(result + 4 * v8);
          do
          {
            unsigned int v8 = v9;
            if ((v9 & 0x80000000) != 0) {
              break;
            }
            unsigned int v9 = *(_DWORD *)(result + 4 * v9);
          }
          while (v9 != v8);
        }
        unsigned int v10 = (__int16)a3[v6 + 1];
        if ((v10 & 0x80000000) == 0)
        {
          unsigned int v11 = *(_DWORD *)(result + 4 * (v10 + a4));
          while (1)
          {
            unsigned int v10 = v11;
            if ((v11 & 0x80000000) != 0) {
              break;
            }
            unsigned int v11 = *(_DWORD *)(result + 4 * v11);
            if (v11 == v10)
            {
              *(_DWORD *)(result + 4 * v10) = v8;
              *(_DWORD *)(result + 4 * *(int *)(result + 600) + 604) = v10;
              goto LABEL_15;
            }
          }
        }
        if ((v8 & 0x80000000) != 0)
        {
          if (v8 != v10) {
            char v7 = 0;
          }
        }
        else
        {
          *(_DWORD *)(result + 4 * v8) = v10;
          *(_DWORD *)(result + 4 * *(int *)(result + 600) + 604) = v8;
LABEL_15:
          ++*(_DWORD *)(result + 600);
        }
        ++v6;
      }
      while (v6 < v5 && v7);
    }
    *a5 = v7;
  }
  return result;
}

uint64_t GenRetFeat(uint64_t a1, uint64_t a2, __int16 *a3, _WORD *a4)
{
  *a4 = *a3;
  if (*a3 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t result = 0;
    while (1)
    {
      int v10 = a3[v8 + 1];
      if (v10 < 0)
      {
LABEL_7:
        if (v10 >= 50)
        {
          uint64_t result = mosyntbase_WStringLn(a1, "***** internal error: returned variable exceeds scope", 0);
          LOWORD(v10) = 0;
          if ((result & 0x80000000) != 0) {
            return result;
          }
        }
      }
      else
      {
        unsigned int v11 = *(_DWORD *)(a2 + 4 * v10);
        while (1)
        {
          int v10 = v11;
          if ((v11 & 0x80000000) != 0) {
            break;
          }
          unsigned int v11 = *(_DWORD *)(a2 + 4 * v11);
          if (v11 == v10) {
            goto LABEL_7;
          }
        }
      }
      a4[++v8] = v10;
      if (v8 >= *a3) {
        return result;
      }
    }
  }
  return 0;
}

uint64_t mosyntknowl_Unif2(uint64_t a1, uint64_t *a2, int a3, uint64_t a4, __int16 *a5, __int16 *a6, __int16 *a7, __int16 *a8, __int16 *a9, __int16 *a10, char *a11)
{
  char v24 = 0;
  if (a3 < 3) {
    goto LABEL_11;
  }
  uint64_t result = mosyntbase_WString(a1, "      unifying sc1A", 0);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = mosyntkbsymtab_WriteFeatList(a1, a2, a5);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = mosyntbase_WString(a1, "/sc1B", 0);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = mosyntkbsymtab_WriteFeatList(a1, a2, a6);
        if ((result & 0x80000000) == 0)
        {
          uint64_t result = mosyntbase_WString(a1, " and sc2A", 0);
          if ((result & 0x80000000) == 0)
          {
            uint64_t result = mosyntkbsymtab_WriteFeatList(a1, a2, a7);
            if ((result & 0x80000000) == 0)
            {
              uint64_t result = mosyntbase_WString(a1, "/sc2B", 0);
              if ((result & 0x80000000) == 0)
              {
                uint64_t result = mosyntkbsymtab_WriteFeatList(a1, a2, a8);
                if ((result & 0x80000000) == 0)
                {
                  uint64_t result = mosyntbase_WLn(a1);
                  if ((result & 0x80000000) == 0)
                  {
LABEL_11:
                    char v25 = 0;
                    Unify(a4, (unsigned __int16 *)a5, (unsigned __int16 *)a6, 50, &v25);
                    if (v25 && (Unify(a4, (unsigned __int16 *)a7, (unsigned __int16 *)a8, 100, &v24), v24))
                    {
                      uint64_t result = GenRetFeat(a1, a4, a9, a10);
                      if ((result & 0x80000000) == 0)
                      {
                        if (a3 < 3
                          || (uint64_t result = mosyntbase_WString(a1, "      returning ", 0), (result & 0x80000000) == 0)
                          && (uint64_t result = mosyntkbsymtab_WriteFeatList(a1, a2, a9), (result & 0x80000000) == 0)
                          && (uint64_t result = mosyntbase_WString(a1, " as ", 0), (result & 0x80000000) == 0)
                          && (uint64_t result = mosyntkbsymtab_WriteFeatList(a1, a2, a10), (result & 0x80000000) == 0)
                          && (uint64_t result = mosyntbase_WLn(a1), (result & 0x80000000) == 0))
                        {
                          if (!a4)
                          {
                            char v22 = 1;
                            goto LABEL_36;
                          }
                          uint64_t v20 = (_DWORD *)(a4 + 600);
                          if (*(int *)(a4 + 600) >= 1)
                          {
                            uint64_t v21 = 0;
                            do
                            {
                              *(_DWORD *)(a4 + 4 * *(int *)(a4 + 604 + 4 * v21)) = *(_DWORD *)(a4 + 604 + 4 * v21);
                              ++v21;
                            }
                            while (v21 < *(int *)(a4 + 600));
                          }
                          char v22 = 1;
                          goto LABEL_33;
                        }
                      }
                    }
                    else if (a3 < 3 {
                           || (uint64_t result = mosyntbase_WString(a1, "      failed", 0), (result & 0x80000000) == 0)
                    }
                           && (uint64_t result = mosyntbase_WLn(a1), (result & 0x80000000) == 0))
                    {
                      if (!a4)
                      {
                        char v22 = 0;
                        goto LABEL_36;
                      }
                      uint64_t v20 = (_DWORD *)(a4 + 600);
                      if (*(int *)(a4 + 600) >= 1)
                      {
                        uint64_t v23 = 0;
                        do
                        {
                          *(_DWORD *)(a4 + 4 * *(int *)(a4 + 604 + 4 * v23)) = *(_DWORD *)(a4 + 604 + 4 * v23);
                          ++v23;
                        }
                        while (v23 < *(int *)(a4 + 600));
                      }
                      char v22 = 0;
LABEL_33:
                      *uint64_t v20 = 0;
LABEL_36:
                      uint64_t result = 0;
                      *a11 = v22;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mosyntknowl_CheckUnifiable(uint64_t a1, unsigned __int16 *a2, unsigned __int16 *a3, char *a4)
{
  uint64_t v11 = 0;
  *a4 = 0;
  uint64_t result = mosyntpal_ALLOCATE(a1, &v11, 0x4B4u);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v9 = 0;
    uint64_t v10 = v11;
    do
    {
      *(_DWORD *)(v10 + 4 * v9) = v9;
      ++v9;
    }
    while (v9 != 150);
    *(_DWORD *)(v10 + 600) = 0;
    if (v11)
    {
      Unify(v11, a2, a3, 50, a4);
      if (v11) {
        return mosyntpal_DEALLOCATE(a1, &v11);
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

uint64_t mosyntknowl_WriteTraceHeader(uint64_t a1, unsigned int a2)
{
  if (a2 > 7) {
    return 0;
  }
  else {
    return mosyntbase_WString(a1, (unsigned __int8 *)off_264107EF0[a2], 0);
  }
}

uint64_t GetSVOXPADiacPhone(uint64_t a1, uint64_t a2, int a3, int *a4, unsigned char *a5, char *a6)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  BOOL v19 = 0;
  *(void *)&void v22[3] = 0;
  *(void *)((char *)v22 + 1) = 0;
  *a5 = 0;
  int v18 = 0;
  uint64_t v12 = *a4;
  int v13 = *(unsigned __int8 *)(a2 + v12);
  if ((int)v12 < a3 && v13 == 94 || v13 == 126 || v13 == 61)
  {
    uint64_t result = mosyntutils_AppChar((uint64_t)a5, 14, &v18, v13);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    uint64_t v15 = *a4 + 1;
    *a4 = v15;
    int v13 = *(unsigned __int8 *)(a2 + v15);
  }
  LOBYTE(v22[0]) = 0;
  if (!v13) {
    goto LABEL_15;
  }
  uint64_t v21 = 0;
  BOOL v20 = 0;
  uint64_t result = mosyntutils_GetUTF8Char(a1, a2, a3, a4, (unsigned char *)&v21 + 4);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  uint64_t result = mosyntbase_App((uint64_t)v22, 14, (int *)&v21, (uint64_t)&v21 + 4, 4, &v20);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  if (LOBYTE(v22[0]) < 0x21u
    || LOBYTE(v22[0]) - 58 <= 0x25 && ((1 << (LOBYTE(v22[0]) - 58)) & 0x3000000009) != 0
    || (char v16 = 1, LOBYTE(v22[0]) - 123 <= 3) && LOBYTE(v22[0]) != 124)
  {
LABEL_15:
    char v16 = 0;
    v22[0] = 33;
  }
  *a6 = v16;
  uint64_t result = mosyntbase_App((uint64_t)a5, 14, &v18, (uint64_t)v22, 14, &v19);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v17 = *a4;
    if ((int)v17 < a3 && *(unsigned char *)(a2 + v17) == 58)
    {
      uint64_t result = mosyntutils_AppChar((uint64_t)a5, 14, &v18, 58);
      if ((result & 0x80000000) == 0) {
        ++*a4;
      }
    }
  }
  return result;
}

uint64_t auxkbcommondef_RecallString(uint64_t a1, uint64_t a2, signed int a3, uint64_t a4, int a5)
{
  signed int v9 = a3;
  uint64_t v27 = *MEMORY[0x263EF8340];
  if ((a3 & 0x80000000) == 0 && *(_DWORD *)(a2 + 8) > a3
    || (uint64_t result = mosyntbase_WString(a1, "*** error in dynamic array reading position: start ", 0),
        (result & 0x80000000) == 0)
    && (uint64_t result = mosyntbase_WInt(a1, v9, 0), (result & 0x80000000) == 0)
    && (uint64_t result = mosyntbase_WString(a1, ", length ", 0), (result & 0x80000000) == 0)
    && (uint64_t result = mosyntbase_WInt(a1, 1u, 0), (result & 0x80000000) == 0)
    && (uint64_t result = mosyntbase_WString(a1, ", actual data length: ", 0), (result & 0x80000000) == 0)
    && (uint64_t result = mosyntbase_WInt(a1, *(_DWORD *)(a2 + 8), 0), (result & 0x80000000) == 0)
    && (uint64_t result = mosyntbase_WLn(a1), (result & 0x80000000) == 0))
  {
    uint64_t v12 = 0;
    int v26 = 0;
    uint64_t v25 = 0;
    int v13 = v9 / 512;
    do
    {
      *(_DWORD *)((char *)&v25 + v12) = v13 - (v5 & 0xFFFFFFC0);
      v12 += 4;
      v13 /= 64;
    }
    while (v12 != 12);
    int v14 = v9 % 512;
    uint64_t v15 = *(void *)(*(void *)(*(void *)(*(void *)(a2 + 16) + 8 * v26 + 8) + 8 * SHIDWORD(v25) + 8)
                    + 8 * (int)v25
                    + 8);
    char v16 = *(unsigned char *)(v15 + v9 % 512);
    BOOL v17 = a5 > 0;
    if (v16) {
      BOOL v18 = a5 < 1;
    }
    else {
      BOOL v18 = 1;
    }
    if (v18)
    {
      uint64_t v19 = 0;
      if (*(unsigned char *)(v15 + v14)) {
        goto LABEL_31;
      }
    }
    else
    {
      unint64_t v21 = 0;
      do
      {
        *(unsigned char *)(a4 + v21) = v16;
        ++v9;
        if (v14 < 511)
        {
          ++v14;
        }
        else
        {
          uint64_t v22 = 0;
          int v26 = 0;
          uint64_t v25 = 0;
          int v23 = v9 / 512;
          do
          {
            *(_DWORD *)((char *)&v25 + v22) = v23 - (v6 & 0xFFFFFFC0);
            v22 += 4;
            v23 /= 64;
          }
          while (v22 != 12);
          int v14 = v9 % 512;
          uint64_t v15 = *(void *)(*(void *)(*(void *)(*(void *)(a2 + 16) + 8 * v26 + 8) + 8 * SHIDWORD(v25) + 8)
                          + 8 * (int)v25
                          + 8);
        }
        ++v21;
        char v16 = *(unsigned char *)(v15 + v14);
        BOOL v17 = v21 < a5;
        if (v16) {
          BOOL v24 = v21 >= a5;
        }
        else {
          BOOL v24 = 1;
        }
      }
      while (!v24);
      uint64_t v19 = v21;
      if (*(unsigned char *)(v15 + v14))
      {
LABEL_31:
        uint64_t result = mosyntbase_WStringLn(a1, "*** RecallString: output array too small", 0);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        goto LABEL_32;
      }
    }
    uint64_t result = 0;
LABEL_32:
    if (v17) {
      *(unsigned char *)(a4 + v19) = 0;
    }
  }
  return result;
}

uint64_t accphr_LoadData(_WORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v56 = *MEMORY[0x263EF8340];
  unsigned __int16 v48 = 0;
  uint64_t v49 = 0;
  memset(v55, 0, sizeof(v55));
  *a3 = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v49);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = kbaux_BuildBrokerString(v49, "accphr", (char *)v55, 0x100uLL);
    if ((result & 0x80000000) == 0)
    {
      int v7 = ssftriff_reader_ObjOpen(a1, a2, 2, (const char *)v55, "ACPH", 1031, (uint64_t *)&v48);
      if (v7 < 0)
      {
        int v17 = v7;
      }
      else
      {
        uint64_t v15 = v48;
        uint64_t v16 = v49;
        unsigned int v54 = 0;
        int v53 = 0;
        unsigned __int8 v52 = 0;
        int v51 = 0;
        int v17 = ssftriff_reader_OpenChunk((uint64_t)v48, &v51, &v54, &v53, v11, v12, v13, v14);
        if ((v17 & 0x80000000) == 0 && !(v51 ^ 0x48504341 | v52))
        {
          uint64_t v50 = 0;
          int v17 = ssftriff_reader_DetachChunkData((uint64_t)v15, (uint64_t *)&v50, &v53, v10, v11, v12, v13, v14);
          if ((v17 & 0x80000000) == 0)
          {
            int v18 = -1923080192;
            uint64_t v19 = (_OWORD *)heap_Alloc(*(void *)(v16 + 8), 176);
            *a3 = (uint64_t)v19;
            if (v19)
            {
              v19[9] = 0u;
              v19[10] = 0u;
              v19[7] = 0u;
              v19[8] = 0u;
              v19[5] = 0u;
              void v19[6] = 0u;
              void v19[3] = 0u;
              v19[4] = 0u;
              v19[1] = 0u;
              v19[2] = 0u;
              *uint64_t v19 = 0u;
              uint64_t v20 = *a3;
              *(_DWORD *)uint64_t v20 = v54;
              *(void *)(v20 + 16) = v50;
              unint64_t v21 = v53;
              *(void *)(*a3 + 8) = v53;
              uint64_t v22 = *a3;
              *(_DWORD *)(v22 + 24) = *v21;
              *(_DWORD *)(v22 + 28) = v21[1];
              v21 += 2;
              *(void *)(v22 + 64) = v21;
              int v23 = &v21[*(int *)(*a3 + 28)];
              *(void *)(*a3 + 72) = v23;
              uint64_t v24 = *a3;
              int v25 = *(_DWORD *)(*a3 + 28);
              if (v25 >= 1)
              {
                do
                {
                  v23 += *v23 + 1;
                  --v25;
                }
                while (v25);
              }
              int v27 = *v23;
              int v26 = v23 + 1;
              *(_DWORD *)(v24 + 32) = v27;
              *(void *)(v24 + 80) = v26;
              uint64_t v28 = *a3;
              unsigned int v29 = &v26[3 * *(int *)(*a3 + 32)];
              int v30 = *v29++;
              *(_DWORD *)(v28 + 36) = v30;
              *(void *)(v28 + 88) = v29;
              uint64_t v31 = *a3;
              uint64_t v32 = &v29[7 * *(int *)(*a3 + 36)];
              int v33 = *v32++;
              *(_DWORD *)(v31 + 40) = v33;
              *(void *)(v31 + 96) = v32;
              uint64_t v34 = *a3;
              int v35 = &v32[3 * *(int *)(*a3 + 40)];
              int v36 = *v35++;
              *(_DWORD *)(v34 + 44) = v36;
              *(void *)(v34 + 104) = v35;
              uint64_t v37 = *a3;
              uint64_t v38 = &v35[7 * *(int *)(*a3 + 44)];
              int v39 = *v38++;
              *(_DWORD *)(v37 + 48) = v39;
              *(void *)(v37 + 112) = v38;
              uint64_t v40 = *a3;
              uint64_t v41 = &v38[16 * (uint64_t)*(int *)(*a3 + 48)];
              int v42 = *v41++;
              *(_DWORD *)(v40 + 52) = v42;
              *(void *)(v40 + 120) = v41;
              uint64_t v43 = *a3;
              uint64_t v44 = &v41[4 * *(int *)(*a3 + 52)];
              int v45 = *v44++;
              *(_DWORD *)(v43 + 56) = v45;
              *(void *)(v43 + 128) = v44;
              uint64_t v46 = *a3;
              uint64_t v47 = &v44[16 * (uint64_t)*(int *)(*a3 + 56)];
              *(_DWORD *)(v46 + 136) = *v47;
              *(_DWORD *)(v46 + 140) = v47[1];
              *(_DWORD *)(v46 + 144) = v47[2];
              *(_DWORD *)(v46 + 148) = v47[3];
              *(_DWORD *)(v46 + 152) = v47[4];
              *(_DWORD *)(v46 + 156) = v47[5];
              *(_DWORD *)(v46 + 160) = v47[6];
              v47 += 7;
              *(void *)(v46 + 168) = v47;
              if (v47[*(int *)(*a3 + 160)] == 1234567890) {
                goto LABEL_13;
              }
            }
            else
            {
              int v18 = -1923080182;
            }
            ssftriff_reader_ReleaseChunkData(v50, v8, v9, v10, v11, v12, v13, v14);
            uint64_t v8 = *a3;
            if (*a3)
            {
              heap_Free(*(void **)(v16 + 8), v8);
              *a3 = 0;
            }
            int v17 = v18;
          }
        }
      }
LABEL_13:
      LODWORD(result) = ssftriff_reader_ObjClose(v48, v8, v9, v10, v11, v12, v13, v14);
      if (v17 >= 0) {
        return result;
      }
      else {
        return v17;
      }
    }
  }
  return result;
}

uint64_t accphr_UnloadData(_WORD *a1, int a2, uint64_t *a3)
{
  uint64_t v13 = 0;
  if (!a3) {
    return 2371887111;
  }
  uint64_t inited = InitRsrcFunction(a1, a2, &v13);
  if ((inited & 0x80000000) == 0)
  {
    if (*a3)
    {
      ssftriff_reader_ReleaseChunkData(*(void **)(*a3 + 16), v4, v5, v6, v7, v8, v9, v10);
      if (*a3)
      {
        heap_Free(*(void **)(v13 + 8), *a3);
        *a3 = 0;
      }
    }
  }
  return inited;
}

uint64_t accphr_Nil()
{
  return 0xFFFFFFFFLL;
}

uint64_t accphr_getAccPhrType(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 24);
  }
  return result;
}

uint64_t accphr_getFunctionWords(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 144);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t accphr_getHierarchy(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 148);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t accphr_getDefaultEmph(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 140);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t accphr_getScenarios(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 156);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t accphr_getDomains(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 152);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t accphr_getFeatList(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  uint64_t result = 2371887111;
  if (a1 && (a2 & 0x80000000) == 0 && *(_DWORD *)(a1 + 28) > (signed int)a2)
  {
    uint64_t v5 = *(void *)(a1 + 72);
    uint64_t v6 = *(int *)(*(void *)(a1 + 64) + 4 * a2);
    uint64_t v7 = *(unsigned int *)(v5 + 4 * v6);
    *a3 = v7;
    if ((int)v7 >= 1)
    {
      uint64_t v8 = (int *)(v5 + 4 * v6 + 4);
      uint64_t v9 = a3 + 1;
      do
      {
        int v10 = *v8++;
        *v9++ = v10;
        --v7;
      }
      while (v7);
    }
    return 0;
  }
  return result;
}

uint64_t accphr_getConsList(int a1, uint64_t a2, int a3)
{
  uint64_t result = 0;
  if (a1) {
    int v5 = -1;
  }
  else {
    int v5 = 0;
  }
  BOOL v6 = a1 == 1 || a1 == 0;
  if (a1 == 1) {
    int v7 = 1;
  }
  else {
    int v7 = v5;
  }
  char v8 = a1 == 2 || v6;
  if (a1 == 2) {
    int v9 = 2;
  }
  else {
    int v9 = v7;
  }
  if (a2 && (a3 & 0x80000000) == 0)
  {
    char v10 = v8 ^ 1;
    if (*(_DWORD *)(a2 + 32) <= a3) {
      char v10 = 1;
    }
    if (v10) {
      return 0;
    }
    else {
      return *(unsigned int *)(*(void *)(a2 + 80) + 4 * (v9 + 3 * a3));
    }
  }
  return result;
}

uint64_t accphr_getNode(int a1, uint64_t a2, int a3)
{
  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      goto LABEL_6;
    case 5:
    case 7:
      a1 = 4;
      goto LABEL_6;
    case 6:
      a1 = 5;
      goto LABEL_6;
    case 8:
      a1 = 6;
LABEL_6:
      char v3 = 1;
      break;
    default:
      char v3 = 0;
      a1 = -1;
      break;
  }
  uint64_t v4 = 0;
  if (a2 && (a3 & 0x80000000) == 0)
  {
    char v5 = v3 ^ 1;
    if (*(_DWORD *)(a2 + 36) <= a3) {
      char v5 = 1;
    }
    if (v5) {
      return 0;
    }
    else {
      return *(unsigned int *)(*(void *)(a2 + 88) + 4 * (a1 + 7 * a3));
    }
  }
  return v4;
}

uint64_t accphr_getNodeMatchOp(uint64_t a1, int a2)
{
  uint64_t result = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 36) <= a2) {
      return 0;
    }
    else {
      return *(unsigned int *)(*(void *)(a1 + 88) + 4 * (7 * a2 + 1));
    }
  }
  return result;
}

uint64_t accphr_getNodeNegated(uint64_t a1, int a2)
{
  uint64_t result = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 36) <= a2) {
      return 0;
    }
    else {
      return *(unsigned int *)(*(void *)(a1 + 88) + 28 * a2);
    }
  }
  return result;
}

uint64_t accphr_getChildren(int a1, uint64_t a2, int a3)
{
  uint64_t result = 0;
  if (a1) {
    int v5 = -1;
  }
  else {
    int v5 = 0;
  }
  BOOL v6 = a1 == 1 || a1 == 0;
  if (a1 == 1) {
    int v7 = 1;
  }
  else {
    int v7 = v5;
  }
  char v8 = a1 == 2 || v6;
  if (a1 == 2) {
    int v9 = 2;
  }
  else {
    int v9 = v7;
  }
  if (a2 && (a3 & 0x80000000) == 0)
  {
    char v10 = v8 ^ 1;
    if (*(_DWORD *)(a2 + 40) <= a3) {
      char v10 = 1;
    }
    if (v10) {
      return 0;
    }
    else {
      return *(unsigned int *)(*(void *)(a2 + 96) + 4 * (v9 + 3 * a3));
    }
  }
  return result;
}

uint64_t accphr_getChildrenOpType(uint64_t a1, int a2)
{
  uint64_t result = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 40) <= a2) {
      return 0;
    }
    else {
      return *(unsigned int *)(*(void *)(a1 + 96) + 12 * a2);
    }
  }
  return result;
}

uint64_t accphr_getInstr(int a1, uint64_t a2, int a3)
{
  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      char v3 = 1;
      break;
    default:
      char v3 = 0;
      a1 = -1;
      break;
  }
  uint64_t v4 = 0;
  if (a2 && (a3 & 0x80000000) == 0)
  {
    char v5 = v3 ^ 1;
    if (*(_DWORD *)(a2 + 44) <= a3) {
      char v5 = 1;
    }
    if (v5) {
      return 0;
    }
    else {
      return *(unsigned int *)(*(void *)(a2 + 104) + 4 * (a1 + 7 * a3));
    }
  }
  return v4;
}

uint64_t accphr_getInstrType(uint64_t a1, int a2)
{
  uint64_t result = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 44) <= a2) {
      return 0;
    }
    else {
      return *(unsigned int *)(*(void *)(a1 + 104) + 4 * (7 * a2 + 1));
    }
  }
  return result;
}

uint64_t accphr_getInstrRight(uint64_t a1, int a2)
{
  uint64_t result = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 44) <= a2) {
      return 0;
    }
    else {
      return *(unsigned int *)(*(void *)(a1 + 104) + 4 * (7 * a2 + 4));
    }
  }
  return result;
}

uint64_t accphr_getInstrTargetRange(uint64_t a1, int a2)
{
  uint64_t result = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 44) <= a2) {
      return 0;
    }
    else {
      return *(unsigned int *)(*(void *)(a1 + 104) + 4 * (7 * a2 + 3));
    }
  }
  return result;
}

uint64_t accphr_getRule(int a1, uint64_t a2, int a3)
{
  switch(a1)
  {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
      char v3 = 1;
      break;
    default:
      char v3 = 0;
      a1 = -1;
      break;
  }
  uint64_t v4 = 0;
  if (a2 && (a3 & 0x80000000) == 0)
  {
    char v5 = v3 ^ 1;
    if (*(_DWORD *)(a2 + 52) <= a3) {
      char v5 = 1;
    }
    if (v5) {
      return 0;
    }
    else {
      return *(unsigned int *)(*(void *)(a2 + 112) + 4 * (a1 + 16 * a3));
    }
  }
  return v4;
}

uint64_t accphr_getFirstRule(uint64_t a1, int a2)
{
  if (a1) {
    return *(unsigned int *)(*(void *)(a1 + 168) + 4 * (a2 % *(_DWORD *)(a1 + 160)));
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t accphr_getRuleSet(int a1, uint64_t a2, int a3)
{
  switch(a1)
  {
    case 0:
    case 1:
      goto LABEL_6;
    case 2:
      char v3 = 1;
      a1 = 1;
      break;
    case 3:
      a1 = 2;
      goto LABEL_6;
    case 4:
      a1 = 3;
LABEL_6:
      char v3 = 1;
      break;
    default:
      char v3 = 0;
      a1 = -1;
      break;
  }
  uint64_t v4 = 0;
  if (a2 && (a3 & 0x80000000) == 0)
  {
    char v5 = v3 ^ 1;
    if (*(_DWORD *)(a2 + 52) <= a3) {
      char v5 = 1;
    }
    if (v5) {
      return 0;
    }
    else {
      return *(unsigned int *)(*(void *)(a2 + 120) + 4 * (a1 + 4 * a3));
    }
  }
  return v4;
}

uint64_t accphr_getRuleSetIsSubset(uint64_t a1, int a2)
{
  uint64_t result = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 52) <= a2) {
      return 0;
    }
    else {
      return *(unsigned int *)(*(void *)(a1 + 120) + 16 * a2);
    }
  }
  return result;
}

uint64_t accphr_getScenario(int a1, uint64_t a2, int a3)
{
  switch(a1)
  {
    case 0:
      int v3 = 0;
      goto LABEL_7;
    case 1:
      int v3 = 13;
      goto LABEL_7;
    case 2:
      int v3 = 14;
      goto LABEL_7;
    case 3:
      int v3 = 15;
LABEL_7:
      char v4 = 1;
      break;
    default:
      char v4 = 0;
      int v3 = -1;
      break;
  }
  uint64_t result = 0;
  if (a2 && (a3 & 0x80000000) == 0)
  {
    char v6 = v4 ^ 1;
    if (*(_DWORD *)(a2 + 56) <= a3) {
      char v6 = 1;
    }
    if (v6) {
      return 0;
    }
    else {
      return *(unsigned int *)(*(void *)(a2 + 128) + 4 * (v3 + 16 * a3));
    }
  }
  return result;
}

uint64_t accphr_getScenarioNamePtr(uint64_t a1, int a2)
{
  uint64_t result = 0;
  if (a1 && (a2 & 0x80000000) == 0)
  {
    if (*(_DWORD *)(a1 + 56) <= a2) {
      return 0;
    }
    else {
      return *(void *)(a1 + 128) + 64 * a2;
    }
  }
  return result;
}

uint64_t mosyntutils_DetUTF8Length(uint64_t a1, unsigned int a2)
{
  if ((int)a2 > -9) {
    return 1;
  }
  if (a2 > 0xFFFFFFEF) {
    return 4;
  }
  if (a2 > 0xFFFFFFDF) {
    return 3;
  }
  if (a2 > 0xFFFFFFBF) {
    return 2;
  }
  mosyntbase_WriteDevelMessage(a1, "DetUTF8Length: malformed UTF8 string starting with %d", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, a2, 0, 0);
  return 1;
}

uint64_t mosyntutils_GetUTF8Char(uint64_t a1, uint64_t a2, int a3, int *a4, unsigned char *a5)
{
  *a5 = 0;
  uint64_t v5 = *a4;
  if ((int)v5 < a3)
  {
    unsigned int v10 = mosyntutils_DetUTF8Length(a1, *(char *)(a2 + v5));
    unint64_t v11 = 0;
    unint64_t v12 = v10;
    int v13 = *a4;
    do
    {
      unint64_t v14 = v11;
      if (v13 >= a3)
      {
        unint64_t v12 = v11;
        goto LABEL_8;
      }
      a5[v11] = *(unsigned char *)(a2 + v13);
      int v13 = *a4 + 1;
      *a4 = v13;
      ++v11;
    }
    while (v10 != v14 + 1);
    if (v14 > 2) {
      return 0;
    }
LABEL_8:
    a5[v12] = 0;
  }
  return 0;
}

uint64_t mosyntutils_AppChar(uint64_t a1, int a2, int *a3, char a4)
{
  BOOL v5 = 0;
  v6[0] = a4;
  v6[1] = 0;
  return mosyntbase_App(a1, a2, a3, (uint64_t)v6, 2, &v5);
}

uint64_t mosyntutils_SkipBlanksInString(uint64_t a1, int a2, int *a3)
{
  int v3 = *a3;
  if (*a3 < a2)
  {
    char v4 = (unsigned __int8 *)(a1 + v3);
    do
    {
      int v5 = *v4++;
      if (v5 != 32) {
        break;
      }
      *a3 = ++v3;
    }
    while (a2 != v3);
  }
  return 0;
}

uint64_t mosyntutils_CheckSkipCharInString(uint64_t a1, unsigned __int8 *a2, int a3, signed int *a4, unsigned __int8 a5)
{
  signed int v8 = *a4;
  if (*a4 >= a3 || a2[v8] == a5)
  {
    uint64_t result = 0;
  }
  else
  {
    v10[0] = a5;
    v10[1] = 0;
    uint64_t result = mosyntbase_WriteDevelMessage(a1, "***** error getting character '%s' at position %d in string '%s'\\n", 0, v10, 2, a2, a3, (unsigned __int8 *)&byte_20D5A22AE, 0, v8, 0, 0);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    signed int v8 = *a4;
  }
  if (v8 < a3)
  {
    if (a2[v8]) {
      *a4 = v8 + 1;
    }
  }
  return result;
}

uint64_t mosyntutils_GetCardFromString(uint64_t a1, unsigned __int8 *a2, int a3, signed int *a4, _DWORD *a5)
{
  signed int v9 = *a4;
  if (*a4 < a3 && a2[v9] == 32)
  {
    unsigned int v10 = &a2[v9 + 1];
    signed int v11 = v9 + 1;
    while (1)
    {
      *a4 = v11;
      if (a3 == v11) {
        break;
      }
      int v12 = *v10++;
      ++v11;
      if (v12 != 32)
      {
        signed int v9 = v11 - 1;
        goto LABEL_8;
      }
    }
    signed int v9 = a3;
  }
LABEL_8:
  if (a2[v9] - 58 > 0xFFFFFFF5)
  {
    uint64_t result = 0;
  }
  else
  {
    uint64_t result = mosyntbase_WriteDevelMessage(a1, "***** error in getting cardinal from string '%s' at position %d\\n", 0, a2, a3, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, v9, 0, 0);
    if ((result & 0x80000000) != 0) {
      return result;
    }
  }
  *a5 = 0;
  for (int i = *a4; i < a3; *a4 = i)
  {
    int v15 = a2[i];
    if ((v15 - 48) > 9) {
      break;
    }
    *a5 = v15 + 10 * *a5 - 48;
    int i = *a4 + 1;
  }
  return result;
}

uint64_t mosyntutils_GetIdentFromString(uint64_t a1, unsigned __int8 *a2, int a3, signed int *a4, unsigned char *a5, int a6)
{
  signed int v11 = *a4;
  if (*a4 < a3 && a2[v11] == 32)
  {
    int v12 = &a2[v11 + 1];
    signed int v13 = v11 + 1;
    while (1)
    {
      *a4 = v13;
      if (a3 == v13) {
        break;
      }
      int v14 = *v12++;
      ++v13;
      if (v14 != 32)
      {
        signed int v11 = v13 - 1;
        goto LABEL_8;
      }
    }
    signed int v11 = a3;
  }
LABEL_8:
  if ((a2[v11] & 0xDFu) - 91 > 0xFFFFFFE5
    || (uint64_t result = mosyntbase_WriteDevelMessage(a1, "***** error in getting identifier from string '%s' at position %d\\n", 0, a2, a3, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, v11, 0, 0), (result & 0x80000000) == 0))
  {
    *a5 = 0;
    int v21 = 0;
    unsigned __int8 v16 = a2[*a4];
    BOOL v22 = 0;
    v23[0] = v16;
    v23[1] = 0;
    uint64_t result = mosyntbase_App((uint64_t)a5, a6, &v21, (uint64_t)v23, 2, &v22);
    if ((result & 0x80000000) == 0)
    {
      int v17 = a3 - 1;
      do
      {
        uint64_t v18 = *a4;
        *a4 = v18 + 1;
        int v19 = a2[v18 + 1];
        if ((int)v18 >= v17)
        {
          if ((v19 - 48) < 0xA) {
            goto LABEL_21;
          }
        }
        else if ((v19 & 0xFFFFFFDF) - 65 < 0x1A || (v19 - 48) < 0xA)
        {
          goto LABEL_21;
        }
        if (v19 != 95 && v19 != 45) {
          return mosyntbase_UpperCase(a5, a6);
        }
LABEL_21:
        BOOL v24 = 0;
        v25[0] = v19;
        v25[1] = 0;
        uint64_t result = mosyntbase_App((uint64_t)a5, a6, &v21, (uint64_t)v25, 2, &v24);
      }
      while ((result & 0x80000000) == 0);
    }
  }
  return result;
}

uint64_t mosyntutils_GetIdent1FromString(uint64_t a1, unsigned __int8 *a2, int a3, signed int *a4, unsigned char *a5, int a6)
{
  signed int v11 = *a4;
  if (*a4 < a3 && a2[v11] == 32)
  {
    int v12 = &a2[v11 + 1];
    signed int v13 = v11 + 1;
    while (1)
    {
      *a4 = v13;
      if (a3 == v13) {
        break;
      }
      int v14 = *v12++;
      ++v13;
      if (v14 != 32)
      {
        signed int v11 = v13 - 1;
        goto LABEL_8;
      }
    }
    signed int v11 = a3;
  }
LABEL_8:
  if ((a2[v11] & 0xDFu) - 91 > 0xFFFFFFE5
    || (uint64_t result = mosyntbase_WriteDevelMessage(a1, "***** error in getting identifier from string '%s' at position %d\\n", 0, a2, a3, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, v11, 0, 0), (result & 0x80000000) == 0))
  {
    *a5 = 0;
    int v20 = 0;
    unsigned __int8 v16 = a2[*a4];
    BOOL v21 = 0;
    v22[0] = v16;
    v22[1] = 0;
    uint64_t result = mosyntbase_App((uint64_t)a5, a6, &v20, (uint64_t)v22, 2, &v21);
    if ((result & 0x80000000) == 0)
    {
      int v17 = a3 - 1;
      while (1)
      {
        uint64_t v18 = *a4;
        *a4 = v18 + 1;
        if ((int)v18 >= v17) {
          break;
        }
        int v19 = a2[v18 + 1];
        if ((v19 & 0xFFFFFFDF) - 65 > 0x19) {
          break;
        }
        BOOL v23 = 0;
        v24[0] = v19;
        v24[1] = 0;
        uint64_t result = mosyntbase_App((uint64_t)a5, a6, &v20, (uint64_t)v24, 2, &v23);
        if ((result & 0x80000000) != 0) {
          return result;
        }
      }
      return mosyntbase_UpperCase(a5, a6);
    }
  }
  return result;
}

uint64_t mosynttrans_InitTransDesc(uint64_t a1, int a2, uint64_t a3, uint64_t *a4)
{
  uint64_t result = mosyntpal_ALLOCATE(a1, a4, 0x18u);
  if ((result & 0x80000000) == 0)
  {
    *(void *)(*a4 + 8) = a3;
    uint64_t v8 = *a4;
    *(_DWORD *)uint64_t v8 = a2;
    *(void *)(v8 + 16) = 0;
  }
  return result;
}

uint64_t mosynttrans_FinishTransDesc(uint64_t a1, uint64_t *a2)
{
  char v4 = (uint64_t *)(*a2 + 16);
  int v5 = (void *)*v4;
  if (*v4)
  {
    while (1)
    {
      int v5 = (void *)*v5;
      uint64_t result = mosyntpal_DEALLOCATE(a1, v4);
      if ((result & 0x80000000) != 0) {
        break;
      }
      uint64_t *v4 = (uint64_t)v5;
      if (!v5) {
        goto LABEL_4;
      }
    }
  }
  else
  {
LABEL_4:
    return mosyntpal_DEALLOCATE(a1, a2);
  }
  return result;
}

uint64_t mosynttrans_NewTransState(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, int a6, char a7, int a8, uint64_t *a9)
{
  uint64_t TransductionMode = mosyntpal_ALLOCATE(a1, a9, 0xA0u);
  if ((TransductionMode & 0x80000000) != 0) {
    return TransductionMode;
  }
  *(void *)*a9 = 0;
  *(void *)(*a9 + 8) = 0;
  uint64_t v18 = *a9;
  *(_DWORD *)(v18 + 16) = a3;
  *(_DWORD *)(v18 + 20) = a5;
  *(unsigned char *)(v18 + 24) = 0;
  *(void *)(v18 + 32) = a4;
  uint64_t v19 = *a9;
  *(_DWORD *)(v19 + 40) = a6;
  *(unsigned char *)(v19 + 44) = a7;
  uint64_t TransductionMode = mosyntkbfst_GetTransductionMode(*(void *)(v19 + 32), (_DWORD *)(v19 + 128));
  if ((TransductionMode & 0x80000000) != 0) {
    return TransductionMode;
  }
  uint64_t TransductionMode = mosyntdata_StartPhonList(a1, (void *)(*a9 + 48), (void *)(*a9 + 56));
  if ((TransductionMode & 0x80000000) != 0) {
    return TransductionMode;
  }
  uint64_t v20 = *a9;
  if (a8 >= 0x3E8) {
    int v21 = 1000;
  }
  else {
    int v21 = a8;
  }
  if (a8 < 0) {
    int v21 = 50;
  }
  *(_DWORD *)(v20 + 64) = 0;
  *(_DWORD *)(v20 + 68) = v21;
  *(_DWORD *)(v20 + 72) = 0;
  uint64_t started = mosyntdata_StartPhonList(a1, (void *)(v20 + 80), (void *)(v20 + 88));
  if ((started & 0x80000000) == 0)
  {
    uint64_t v23 = *a9;
    *(unsigned char *)(v23 + 96) = 0;
    *(_DWORD *)(v23 + 100) = -1;
    *(void *)(v23 + 112) = 0;
    *(void *)(*a9 + 120) = 0;
    *(void *)(*a9 + 104) = 0;
    if ((a6 - 1) > 1)
    {
      *(_WORD *)(*a9 + 132) = mosyntkbsymtab_PhonStartId(*(void *)(a2 + 8));
      *(_WORD *)(*a9 + 134) = mosyntkbsymtab_PhonTermId(*(void *)(a2 + 8));
      *(_WORD *)(*a9 + 136) = mosyntkbsymtab_FSTDefaultId(*(void *)(a2 + 8));
      __int16 v28 = mosyntkbsymtab_SyllSepId(*(void *)(a2 + 8));
      uint64_t v29 = *a9;
      *(_WORD *)(v29 + 138) = v28;
      int v30 = *(_DWORD *)(v29 + 128);
      if (!v30) {
        goto LABEL_26;
      }
      if (v30 == 1)
      {
        *(_WORD *)(*a9 + 140) = mosyntkbsymtab_WordSep2Id(*(void *)(a2 + 8));
        *(_WORD *)(*a9 + 142) = mosyntkbsymtab_PhrSepPause2Id(*(void *)(a2 + 8));
        uint64_t v31 = 0;
        *(_WORD *)(*a9 + 144) = mosyntkbsymtab_PhrSepNoPause2Id(*(void *)(a2 + 8));
        do
        {
          *(_WORD *)(*a9 + 2 * v31 + 146) = mosyntkbsymtab_AccId(*(void *)(a2 + 8), v31);
          ++v31;
        }
        while (v31 != 5);
        return started;
      }
      if (*(int *)a2 < 1
        || (uint64_t started = TraceUnknownTransductionMode(a1, (unsigned int *)v29), (started & 0x80000000) == 0))
      {
LABEL_26:
        *(_WORD *)(*a9 + 140) = mosyntkbsymtab_WordSepId(*(void *)(a2 + 8));
        *(_WORD *)(*a9 + 142) = mosyntkbsymtab_PhrSepPauseId(*(void *)(a2 + 8));
        *(_WORD *)(*a9 + 144) = mosyntkbsymtab_PhrSepNoPauseId(*(void *)(a2 + 8));
        for (uint64_t i = 146; i != 156; i += 2)
          *(_WORD *)(*a9 + i) = mosyntkbsymtab_PrimAccId(*(void *)(a2 + 8));
      }
    }
    else if (!*(_DWORD *)(*a9 + 128) {
           || *(int *)a2 < 1
    }
           || (uint64_t started = TraceUnknownTransductionMode(a1, (unsigned int *)*a9), (started & 0x80000000) == 0))
    {
      *(_WORD *)(*a9 + 132) = mosyntkbsymtab_IPABeginId(*(void *)(a2 + 8));
      *(_WORD *)(*a9 + 134) = mosyntkbsymtab_IPAEndId(*(void *)(a2 + 8));
      *(_WORD *)(*a9 + 136) = mosyntkbsymtab_FSTDefaultId(*(void *)(a2 + 8));
      *(_WORD *)(*a9 + 138) = mosyntkbsymtab_IPASyllSepId(*(void *)(a2 + 8));
      __int16 v24 = mosyntkbsymtab_IPAWordSepId(*(void *)(a2 + 8));
      uint64_t v25 = *a9;
      *(_WORD *)(v25 + 140) = v24;
      *(_DWORD *)(v25 + 142) = 0;
      for (uint64_t j = 146; j != 156; j += 2)
        *(_WORD *)(*a9 + j) = mosyntkbsymtab_IPAPrimAccId(*(void *)(a2 + 8));
    }
  }
  return started;
}

uint64_t TraceUnknownTransductionMode(uint64_t a1, unsigned int *a2)
{
  uint64_t result = mosyntknowl_WriteTraceHeader(a1, a2[4]);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = mosyntbase_WString(a1, "fst: ", 0);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = mosyntbase_WInt(a1, a2[5], 1);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = mosyntbase_WString(a1, " ***** unknown transduction mode: ", 0);
        if ((result & 0x80000000) == 0)
        {
          uint64_t result = mosyntbase_WInt(a1, a2[32], 0);
          if ((result & 0x80000000) == 0)
          {
            return mosyntbase_WStringLn(a1, "; using default instead", 0);
          }
        }
      }
    }
  }
  return result;
}

uint64_t mosynttrans_NewTransStateSeq(uint64_t a1, uint64_t a2, int a3, int *a4, int a5, int a6, unsigned int a7, int a8, uint64_t *a9)
{
  *a9 = 0;
  LODWORD(v13) = *a4;
  if (*a4 <= a6 || a6 <= -1) {
    uint64_t v13 = v13;
  }
  else {
    uint64_t v13 = a6;
  }
  do
  {
    if ((int)v13 < 1)
    {
      uint64_t v20 = 0;
      goto LABEL_18;
    }
    uint64_t v15 = v13 - 1;
    uint64_t v16 = *(void *)&a4[2 * v13];
    uint64_t inited = fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::InitMatcher();
    uint64_t v13 = v15;
  }
  while (v16 == inited);
  unint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  int v21 = a4 + 2;
  uint64_t v22 = v15 + 1;
  unint64_t v23 = a7;
  do
  {
    uint64_t v24 = *(void *)&v21[2 * v18];
    if (v24 != fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::InitMatcher())
    {
      uint64_t v20 = mosynttrans_NewTransState(a1, a2, a3, *(void *)&v21[2 * v18], v18, a5, v18 < v23, a8, a9);
      if ((v20 & 0x80000000) != 0) {
        return v20;
      }
      *(void *)*a9 = v19;
      if (v19) {
        *(void *)(v19 + 8) = *a9;
      }
      uint64_t v19 = *a9;
    }
    ++v18;
  }
  while (v22 != v18);
LABEL_18:
  if (*a9) {
    return v20;
  }
  uint64_t v26 = fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::InitMatcher();
  return mosynttrans_NewTransState(a1, a2, a3, v26, -1, a5, 1, a8, a9);
}

uint64_t mosynttrans_PutPhonList(uint64_t a1, uint64_t a2, void *a3, char a4, uint64_t *a5)
{
  signed int v9 = a5;
  if (!a3) {
    return 0;
  }
  do
  {
    char v6 = a3;
    a3 = (void *)*a3;
  }
  while (a3);
  *((unsigned char *)v6 + 24) = a4;
  uint64_t result = mosyntdata_CopyPhonList(a1, &v9);
  if ((result & 0x80000000) == 0)
  {
    PhonEle = mosyntdata_LastPhonEle(a1, v9);
    return mosyntdata_AppendPhonList(a1, v6 + 6, v6 + 7, (uint64_t)v9, (uint64_t)PhonEle);
  }
  return result;
}

uint64_t mosynttrans_GetPhonList(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4, void *a5)
{
  uint64_t result = mosyntdata_StartPhonList(a1, a4, a5);
  if (a3)
  {
    if ((result & 0x80000000) == 0)
    {
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      for (uint64_t result = SingleTransducerGet(a1, a2, (uint64_t)a3, &v13, &v12); (result & 0x80000000) == 0; a3 = (uint64_t *)v11)
      {
        uint64_t v11 = a3[1];
        if (v13)
        {
          if (!v11) {
            return mosyntdata_AppendPhonList(a1, a4, a5, v13, v12);
          }
          uint64_t result = mosyntdata_AppendPhonList(a1, (void *)(v11 + 48), (void *)(v11 + 56), v13, v12);
          if ((result & 0x80000000) != 0) {
            return result;
          }
        }
        else if (!v11 || !*(unsigned char *)(v11 + 24))
        {
          uint64_t v11 = *a3;
          if (!*a3) {
            return result;
          }
        }
        uint64_t result = SingleTransducerGet(a1, a2, v11, &v13, &v12);
      }
    }
  }
  return result;
}

uint64_t SingleTransducerGet(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5)
{
  uint64_t result = mosyntdata_StartPhonList(a1, a4, a5);
  if ((result & 0x80000000) == 0)
  {
    int v33 = 0;
    uint64_t v11 = *(void *)(a3 + 32);
    if (v11 == fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::InitMatcher())
    {
      int v23 = *(_DWORD *)(a3 + 100);
      uint64_t v24 = (void *)(a3 + 48);
      if (v23 < 0)
      {
        uint64_t v27 = *(void *)(a3 + 56);
        uint64_t v26 = (void *)(a3 + 56);
        uint64_t result = mosyntdata_AppendPhonList(a1, a4, a5, *(v26 - 1), v27);
        if ((result & 0x80000000) == 0)
        {
          return mosyntdata_StartPhonList(a1, v24, v26);
        }
      }
      else
      {
        uint64_t v25 = (void *)(a3 + 56);
        do
        {
          uint64_t result = mosyntdata_PopPhonEle(a1, (void **)v24, v25, &v33);
          if ((result & 0x80000000) != 0) {
            break;
          }
          if (!v33) {
            break;
          }
          uint64_t result = mosyntdata_AppendPhonList(a1, a4, a5, (uint64_t)v33, (uint64_t)v33);
          if ((result & 0x80000000) != 0) {
            break;
          }
          --v23;
        }
        while (v23);
      }
    }
    else
    {
      if (!*(void *)(a3 + 80) && *(_DWORD *)(a3 + 64) < *(_DWORD *)(a3 + 68))
      {
        while (1)
        {
          uint64_t result = mosyntdata_PopPhonEle(a1, (void **)(a3 + 48), (void *)(a3 + 56), &v33);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t v12 = v33;
          if (!v33) {
            goto LABEL_55;
          }
          uint64_t v34 = 0;
          int v35 = v33;
          if (*v33)
          {
            *int v33 = 0;
            uint64_t result = mosyntbase_WriteDevelMessage(a1, "*** SVOXTrans.DoTransduction() expects isolated phone\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, 0, 0, 0);
            if ((result & 0x80000000) != 0) {
              return result;
            }
          }
          if (!*(unsigned char *)(a3 + 96))
          {
            uint64_t result = StartTransduction(a1, a2, a3);
            if ((result & 0x80000000) != 0) {
              return result;
            }
          }
          if (*((unsigned char *)v12 + 20)) {
            break;
          }
          int v16 = *((unsigned __int16 *)v12 + 12);
          if (v16 != *(unsigned __int16 *)(a3 + 134))
          {
            unsigned int v17 = (__int16)v16;
            unint64_t v18 = (uint64_t *)&v35;
            uint64_t v19 = a1;
            uint64_t v20 = a2;
            uint64_t v21 = a3;
            char v22 = 0;
            goto LABEL_32;
          }
LABEL_33:
          if (v35)
          {
            uint64_t result = mosyntdata_DisposePhonEleList(a1, &v35);
            if ((result & 0x80000000) != 0) {
              return result;
            }
          }
          if (*(void *)(a3 + 104))
          {
            uint64_t result = GetTransduction(a1, a2, a3);
            if ((result & 0x80000000) != 0) {
              return result;
            }
          }
          if (*(void *)(a3 + 80) || *(_DWORD *)(a3 + 64) >= *(_DWORD *)(a3 + 68))
          {
            int v33 = 0;
            goto LABEL_55;
          }
        }
        uint64_t v13 = *((unsigned __int16 *)v12 + 18);
        int v14 = *((_DWORD *)v12 + 6);
        switch(v14)
        {
          case 3:
            if (!*(_DWORD *)(a3 + 40))
            {
              if (*((__int16 *)v12 + 14) > 1) {
                unsigned int v15 = *(__int16 *)(a3 + 144);
              }
              else {
                unsigned int v15 = *(__int16 *)(a3 + 142);
              }
              goto LABEL_20;
            }
            break;
          case 2:
            break;
          case 1:
            unsigned int v15 = *(__int16 *)(a3 + 138);
LABEL_20:
            uint64_t result = TransduceSymbol(a1, a2, a3, v15, 0, (uint64_t *)&v35);
            if ((result & 0x80000000) != 0) {
              return result;
            }
LABEL_23:
            if (*(_DWORD *)(a3 + 128) == 1)
            {
              if ((__int16)v13 <= 4)
              {
                if ((v13 & 0x8000) != 0)
                {
                  uint64_t result = mosyntbase_WriteDevelMessage(a1, "fst: %d ***** negative accent %d; using 0 instead\\n",
                             0,
                             (unsigned __int8 *)&byte_20D5A22AE,
                             0,
                             (unsigned __int8 *)&byte_20D5A22AE,
                             0,
                             (unsigned __int8 *)&byte_20D5A22AE,
                             0,
                             *(_DWORD *)(a3 + 20),
                             0,
                             0);
                  uint64_t v13 = 0;
                  if ((result & 0x80000000) != 0) {
                    return result;
                  }
                }
              }
              else
              {
                uint64_t v13 = 4;
              }
              unsigned int v17 = *(__int16 *)(a3 + 2 * v13 + 146);
LABEL_31:
              unint64_t v18 = &v34;
              uint64_t v19 = a1;
              uint64_t v20 = a2;
              uint64_t v21 = a3;
              char v22 = 1;
LABEL_32:
              uint64_t result = TransduceSymbol(v19, v20, v21, v17, v22, v18);
              if ((result & 0x80000000) != 0) {
                return result;
              }
              goto LABEL_33;
            }
            if ((__int16)v13 >= 1)
            {
              unsigned int v17 = *(__int16 *)(a3 + 146);
              goto LABEL_31;
            }
            goto LABEL_33;
          default:
            uint64_t result = mosyntbase_WriteDevelMessage(a1, "*** unexpected NILBOUNDARY boundary phone\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, 0, 0, 0);
            if ((result & 0x80000000) != 0) {
              return result;
            }
            goto LABEL_23;
        }
        unsigned int v15 = *(__int16 *)(a3 + 140);
        goto LABEL_20;
      }
LABEL_55:
      int v28 = *(_DWORD *)(a3 + 100);
      if (v28 < 0)
      {
        uint64_t result = mosyntdata_AppendPhonList(a1, a4, a5, *(void *)(a3 + 80), *(void *)(a3 + 88));
        if ((result & 0x80000000) == 0)
        {
          uint64_t result = mosyntdata_StartPhonList(a1, (void *)(a3 + 80), (void *)(a3 + 88));
          if ((result & 0x80000000) == 0)
          {
LABEL_63:
            signed int v29 = *(_DWORD *)(a3 + 64);
            signed int v30 = *(_DWORD *)(a3 + 68);
            if (v29 >= v30)
            {
              uint64_t result = mosyntbase_WriteDevelMessage(a1, "---- forced emission %d >= %d\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, v29, v30, 0);
              if ((result & 0x80000000) != 0) {
                return result;
              }
              char v31 = 1;
              *(unsigned char *)(a3 + 24) = 1;
            }
            else
            {
              if (!*(unsigned char *)(a3 + 24)) {
                return result;
              }
              char v31 = 0;
            }
            if (!*a4)
            {
              uint64_t result = TerminateTransduction(a1, a2, a3);
              if ((result & 0x80000000) == 0)
              {
                *(unsigned char *)(a3 + 24) = v31;
                uint64_t v32 = *(void *)(a3 + 8);
                if (v32) {
                  *(unsigned char *)(v32 + 24) = v29 < v30;
                }
                return SingleTransducerGet(a1, a2, a3, a4, a5);
              }
            }
          }
        }
      }
      else
      {
        while (1)
        {
          uint64_t result = mosyntdata_PopPhonEle(a1, (void **)(a3 + 80), (void *)(a3 + 88), &v33);
          if ((result & 0x80000000) != 0) {
            break;
          }
          if (!v33) {
            goto LABEL_63;
          }
          uint64_t result = mosyntdata_AppendPhonList(a1, a4, a5, (uint64_t)v33, (uint64_t)v33);
          if ((result & 0x80000000) != 0) {
            break;
          }
          if (!--v28)
          {
            int v33 = 0;
            goto LABEL_63;
          }
        }
      }
    }
  }
  return result;
}

uint64_t mosynttrans_TransducePhonList(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t *a6, int a7, char a8, void *a9, void *a10)
{
  uint64_t result = mosyntdata_StartPhonList(a1, a9, a10);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v23 = 0;
    uint64_t v24 = 0;
    char v22 = 0;
    uint64_t result = mosynttrans_NewTransState(a1, a2, a3, a4, a5, a7, a8, 1000, (uint64_t *)&v22);
    if ((result & 0x80000000) == 0)
    {
      uint64_t v20 = v22;
      *((_DWORD *)v22 + 25) = -1;
      for (uint64_t result = mosynttrans_PutPhonList(a1, v19, v20, 1, a6);
            (result & 0x80000000) == 0;
            uint64_t result = mosyntdata_AppendPhonList(a1, a9, a10, v24, v23))
      {
        uint64_t result = mosynttrans_GetPhonList(a1, a2, v22, &v24, &v23);
        if ((result & 0x80000000) != 0) {
          break;
        }
        if (!v24)
        {
          uint64_t v21 = v22;
          if (!v22) {
            return 0;
          }
          do
          {
            uint64_t v21 = (uint64_t *)*v21;
            uint64_t result = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v22);
            if ((result & 0x80000000) != 0) {
              break;
            }
            char v22 = v21;
          }
          while (v21);
          return result;
        }
      }
    }
  }
  return result;
}

uint64_t mosynttrans_SeqTransducePhonList(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t *a4, uint64_t **a5, uint64_t a6, int a7, int a8, unsigned int a9, unsigned __int8 *a10, int a11)
{
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t result = mosyntdata_StartPhonList(a1, a5, &v29);
  if ((result & 0x80000000) == 0)
  {
    long long v20 = *(_OWORD *)(a6 + 48);
    unsigned char v24[2] = *(_OWORD *)(a6 + 32);
    v24[3] = v20;
    v24[4] = *(_OWORD *)(a6 + 64);
    uint64_t v25 = *(void *)(a6 + 80);
    long long v21 = *(_OWORD *)(a6 + 16);
    v24[0] = *(_OWORD *)a6;
    v24[1] = v21;
    uint64_t result = mosynttrans_NewTransStateSeq(a1, a2, a3, (int *)v24, a7, a8, a9, 1000, (uint64_t *)&v26);
    if ((result & 0x80000000) == 0)
    {
      if (*(int *)a2 < 2
        || (uint64_t result = mosyntknowl_WriteTraceHeader(a1, a3), (result & 0x80000000) == 0)
        && (uint64_t result = mosyntbase_WString(a1, "before ", 0), (result & 0x80000000) == 0)
        && (uint64_t result = mosyntbase_WString(a1, a10, a11), (result & 0x80000000) == 0)
        && (uint64_t result = mosyntbase_WString(a1, " ", 0), (result & 0x80000000) == 0)
        && (uint64_t result = mosyntdata_WritePhonList(a1, *(uint64_t **)(a2 + 8), a4), (result & 0x80000000) == 0)
        && (uint64_t result = mosyntbase_WLn(a1), (result & 0x80000000) == 0))
      {
        if (v26)
        {
          for (uint64_t result = mosynttrans_PutPhonList(a1, v22, v26, 1, a4);
                (result & 0x80000000) == 0;
                uint64_t result = mosyntdata_AppendPhonList(a1, a5, &v29, v28, v27))
          {
            uint64_t result = mosynttrans_GetPhonList(a1, a2, v26, &v28, &v27);
            if ((result & 0x80000000) != 0) {
              break;
            }
            if (!v28) {
              goto LABEL_17;
            }
          }
        }
        else
        {
          *a5 = a4;
          uint64_t result = mosyntdata_CopyPhonList(a1, a5);
          if ((result & 0x80000000) == 0)
          {
LABEL_17:
            if (*(int *)a2 < 2
              || (uint64_t result = mosyntknowl_WriteTraceHeader(a1, a3), (result & 0x80000000) == 0)
              && (uint64_t result = mosyntbase_WString(a1, "after ", 0), (result & 0x80000000) == 0)
              && (uint64_t result = mosyntbase_WString(a1, a10, a11), (result & 0x80000000) == 0)
              && (uint64_t result = mosyntbase_WString(a1, " ", 0), (result & 0x80000000) == 0)
              && (uint64_t result = mosyntdata_WritePhonList(a1, *(uint64_t **)(a2 + 8), *a5), (result & 0x80000000) == 0)
              && (uint64_t result = mosyntbase_WLn(a1), (result & 0x80000000) == 0)
              && (uint64_t result = mosyntbase_WLn(a1), (result & 0x80000000) == 0))
            {
              uint64_t v23 = v26;
              if (v26)
              {
                do
                {
                  uint64_t v23 = (uint64_t *)*v23;
                  uint64_t result = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v26);
                  if ((result & 0x80000000) != 0) {
                    break;
                  }
                  uint64_t v26 = v23;
                }
                while (v23);
              }
              else
              {
                return 0;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t TerminateTransduction(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = 0;
  if (*(unsigned char *)(a3 + 96) || (uint64_t result = StartTransduction(a1, a2, a3), (result & 0x80000000) == 0))
  {
    uint64_t result = TransduceSymbol(a1, a2, a3, *(__int16 *)(a3 + 134), 0, &v9);
    if ((result & 0x80000000) == 0)
    {
      *(unsigned char *)(a3 + 96) = 0;
      uint64_t v7 = *(void *)(a3 + 120);
      if (!v7) {
        goto LABEL_9;
      }
      uint64_t v8 = (uint64_t *)(v7 + 32);
      do
        uint64_t v8 = (uint64_t *)*v8;
      while (v8 && *((_WORD *)v8 + 8) != 1);
      *(void *)(a3 + 104) = v8;
      uint64_t result = GetTransduction(a1, a2, a3);
      if ((result & 0x80000000) == 0)
      {
LABEL_9:
        return DisposePositionList(a1, a2, a3);
      }
    }
  }
  return result;
}

uint64_t StartTransduction(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0;
  if (!*(void *)(a3 + 112)
    || (uint64_t result = mosyntbase_WriteDevelMessage(a1, "*** position list not empty at transduction start\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, 0, 0, 0), (result & 0x80000000) == 0)&& (uint64_t result = DisposePositionList(a1, a2, a3), (result & 0x80000000) == 0))
  {
    uint64_t result = AddPosition(a1, a3, 0);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = AddPosState(a1, a2, a3, *(void *)(a3 + 112), 1, 0, 0, 0, 0, 0);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = TransduceSymbol(a1, a2, a3, *(__int16 *)(a3 + 132), 0, &v7);
        if ((result & 0x80000000) == 0) {
          *(unsigned char *)(a3 + 96) = 1;
        }
      }
    }
  }
  return result;
}

uint64_t TransduceSymbol(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, char a5, uint64_t *a6)
{
  if (*(int *)a2 < 3
    || (uint64_t result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16)), (result & 0x80000000) == 0)
    && (uint64_t result = mosyntbase_WString(a1, "fst: ", 0), (result & 0x80000000) == 0)
    && (uint64_t result = mosyntbase_WInt(a1, *(_DWORD *)(a3 + 20), 1), (result & 0x80000000) == 0)
    && (uint64_t result = mosyntbase_WString(a1, " --- treating input symbol ", 0), (result & 0x80000000) == 0)
    && (uint64_t result = mosyntkbsymtab_WritePhonSym(a1, *(uint64_t **)(a2 + 8), a4), (result & 0x80000000) == 0)
    && (uint64_t result = mosyntbase_WLn(a1), (result & 0x80000000) == 0))
  {
    uint64_t v13 = *(void *)(a3 + 120);
    uint64_t v14 = *a6;
    uint64_t result = AddPosition(a1, a3, *a6);
    if ((result & 0x80000000) == 0)
    {
      uint64_t v26 = 0;
      uint64_t v27 = 0;
      BOOL v25 = 0;
      *a6 = 0;
      uint64_t result = mosyntkbfst_GetFirstSameInSymPair(*(__int16 **)(a3 + 32), *(_WORD *)(a3 + 136), (uint64_t)&v26, &v25);
      if ((result & 0x80000000) == 0)
      {
        uint64_t v15 = *(void *)(v13 + 32);
        if (v15)
        {
          while (1)
          {
            uint64_t result = mosyntkbfst_GetFirstSameInSymPair(*(__int16 **)(a3 + 32), 0, (uint64_t)&v27, &v25);
            if ((result & 0x80000000) != 0) {
              break;
            }
            while (v25)
            {
              if (*(int *)a2 < 3) {
                goto LABEL_67;
              }
              uint64_t result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
              if ((result & 0x80000000) == 0)
              {
                uint64_t result = mosyntbase_WString(a1, "trying pos/state ", 0);
                if ((result & 0x80000000) == 0)
                {
                  uint64_t result = mosyntbase_WInt(a1, *(__int16 *)(v13 + 16), 0);
                  if ((result & 0x80000000) == 0)
                  {
                    uint64_t result = mosyntbase_WString(a1, "/", 0);
                    if ((result & 0x80000000) == 0)
                    {
                      uint64_t result = mosyntbase_WInt(a1, *(__int16 *)(v15 + 16), 0);
                      if ((result & 0x80000000) == 0)
                      {
                        uint64_t result = mosyntbase_WString(a1, " and pair ", 0);
                        if ((result & 0x80000000) == 0)
                        {
                          uint64_t result = mosyntkbfst_WritePhonPair(a1, *(uint64_t **)(a2 + 8), *(void *)(a3 + 32), &v27, 2);
                          if ((result & 0x80000000) == 0)
                          {
                            uint64_t result = mosyntbase_WLn(a1);
                            if ((result & 0x80000000) == 0)
                            {
LABEL_67:
                              int v16 = mosyntkbfst_FSTTrans(*(void *)(a3 + 32), *(__int16 *)(v15 + 16), &v27);
                              if (v16 < 1
                                || (int v17 = v16,
                                    __int16 v18 = mosyntkbfst_OutSym(*(void *)(a3 + 32), &v27),
                                    uint64_t result = AddPosState(a1, a2, a3, v13, v17, v15, 0, v18, a5, 0),
                                    (result & 0x80000000) == 0))
                              {
                                uint64_t result = mosyntkbfst_GetNextSameInSymPair(*(void *)(a3 + 32), (int *)&v27, &v25);
                                if ((result & 0x80000000) == 0) {
                                  continue;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              return result;
            }
            uint64_t result = mosyntkbfst_GetFirstSameInSymPair(*(__int16 **)(a3 + 32), a4, (uint64_t)&v27, &v25);
            if ((result & 0x80000000) != 0) {
              break;
            }
            int v19 = 0;
            while (v25)
            {
              if (*(int *)a2 < 3) {
                goto LABEL_68;
              }
              uint64_t result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
              if ((result & 0x80000000) == 0)
              {
                uint64_t result = mosyntbase_WString(a1, "trying pos/state ", 0);
                if ((result & 0x80000000) == 0)
                {
                  uint64_t result = mosyntbase_WInt(a1, *(__int16 *)(v13 + 16), 0);
                  if ((result & 0x80000000) == 0)
                  {
                    uint64_t result = mosyntbase_WString(a1, "/", 0);
                    if ((result & 0x80000000) == 0)
                    {
                      uint64_t result = mosyntbase_WInt(a1, *(__int16 *)(v15 + 16), 0);
                      if ((result & 0x80000000) == 0)
                      {
                        uint64_t result = mosyntbase_WString(a1, " and pair ", 0);
                        if ((result & 0x80000000) == 0)
                        {
                          uint64_t result = mosyntkbfst_WritePhonPair(a1, *(uint64_t **)(a2 + 8), *(void *)(a3 + 32), &v27, 2);
                          if ((result & 0x80000000) == 0)
                          {
                            uint64_t result = mosyntbase_WLn(a1);
                            if ((result & 0x80000000) == 0)
                            {
LABEL_68:
                              int v20 = mosyntkbfst_FSTTrans(*(void *)(a3 + 32), *(__int16 *)(v15 + 16), &v27);
                              if (v20 < 1
                                || (int v21 = v20,
                                    uint64_t v24 = *(void *)(v13 + 8),
                                    __int16 v22 = mosyntkbfst_OutSym(*(void *)(a3 + 32), &v27),
                                    uint64_t result = AddPosState(a1, a2, a3, v24, v21, v15, a4, v22, a5, v14),
                                    (result & 0x80000000) == 0))
                              {
                                uint64_t result = mosyntkbfst_GetNextSameInSymPair(*(void *)(a3 + 32), (int *)&v27, &v25);
                                --v19;
                                if ((result & 0x80000000) == 0) {
                                  continue;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
              return result;
            }
            if (!v19)
            {
              if (mosyntkbfst_IsValidPair(&v26))
              {
                uint64_t v27 = v26;
                if (*(int *)a2 >= 3)
                {
                  uint64_t result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
                  if ((result & 0x80000000) != 0) {
                    return result;
                  }
                  uint64_t result = mosyntbase_WString(a1, "trying pos/state ", 0);
                  if ((result & 0x80000000) != 0) {
                    return result;
                  }
                  uint64_t result = mosyntbase_WInt(a1, *(__int16 *)(v13 + 16), 0);
                  if ((result & 0x80000000) != 0) {
                    return result;
                  }
                  uint64_t result = mosyntbase_WString(a1, "/", 0);
                  if ((result & 0x80000000) != 0) {
                    return result;
                  }
                  uint64_t result = mosyntbase_WInt(a1, *(__int16 *)(v15 + 16), 0);
                  if ((result & 0x80000000) != 0) {
                    return result;
                  }
                  uint64_t result = mosyntbase_WString(a1, " and pair ", 0);
                  if ((result & 0x80000000) != 0) {
                    return result;
                  }
                  uint64_t result = mosyntkbfst_WritePhonPair(a1, *(uint64_t **)(a2 + 8), *(void *)(a3 + 32), &v27, 2);
                  if ((result & 0x80000000) != 0) {
                    return result;
                  }
                  uint64_t result = mosyntbase_WLn(a1);
                  if ((result & 0x80000000) != 0) {
                    return result;
                  }
                }
                int v23 = mosyntkbfst_FSTTrans(*(void *)(a3 + 32), *(__int16 *)(v15 + 16), &v27);
                if (v23 >= 1)
                {
                  uint64_t result = AddPosState(a1, a2, a3, *(void *)(v13 + 8), v23, v15, a4, a4, a5, v14);
                  if ((result & 0x80000000) != 0) {
                    return result;
                  }
                }
              }
              else if (*(int *)a2 >= 1)
              {
                uint64_t result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
                if ((result & 0x80000000) != 0) {
                  return result;
                }
                uint64_t result = mosyntbase_WString(a1, "*** no pair found with input symbol '", 0);
                if ((result & 0x80000000) != 0) {
                  return result;
                }
                uint64_t result = mosyntkbsymtab_WritePhonSym(a1, *(uint64_t **)(a2 + 8), a4);
                if ((result & 0x80000000) != 0) {
                  return result;
                }
                uint64_t result = mosyntbase_WStringLn(a1, "' and no default pair found", 0);
                if ((result & 0x80000000) != 0) {
                  return result;
                }
              }
            }
            uint64_t v15 = *(void *)v15;
            if (!v15) {
              return FindEmissionState(a1, a2, a3);
            }
          }
        }
        else
        {
          return FindEmissionState(a1, a2, a3);
        }
      }
    }
  }
  return result;
}

uint64_t GetTransduction(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  uint64_t v43 = 0;
  v45[0] = 0;
  v45[1] = 0;
  int v46 = 0;
  int v6 = *(_DWORD *)(a3 + 64);
  if (v6 > *(_DWORD *)(a3 + 72))
  {
    *(_DWORD *)(a3 + 72) = v6;
    if (*(int *)a2 >= 2)
    {
      uint64_t result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntbase_WString(a1, "fst: ", 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntbase_WInt(a1, *(_DWORD *)(a3 + 20), 1);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntbase_WInt3Ln(a1, " max transduction path length:  ", 0, *(_DWORD *)(a3 + 72), (unsigned __int8 *)&byte_20D5A22AE, 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntbase_WLn(a1);
      if ((result & 0x80000000) != 0) {
        return result;
      }
    }
  }
  uint64_t v8 = *(void *)(a3 + 104);
  int v9 = *(_DWORD *)a2;
  if (!v8)
  {
    if (v9 < 2)
    {
      uint64_t result = mosyntbase_WriteDevelMessage(a1, "*** no transduction found (use tracing to get more info)\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, 0, 0, 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
    }
    else
    {
      uint64_t result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntbase_WString(a1, "fst: ", 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntbase_WInt(a1, *(_DWORD *)(a3 + 20), 1);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntbase_WStringLn(a1, " ***** no transduction found for input ", 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntbase_WLn(a1);
      if ((result & 0x80000000) != 0) {
        return result;
      }
    }
    uint64_t v10 = *(void *)(a3 + 120);
    uint64_t result = GetInPhonList(a1, a3, v10, (void *)(a3 + 80));
    if ((result & 0x80000000) != 0) {
      return result;
    }
    *(void *)(a3 + 88) = mosyntdata_LastPhonEle(a1, *(void **)(a3 + 80));
    m2__cp__str("output", v45, 20);
    uint64_t result = TraceTransductionIO(a1, a2, (unsigned int *)a3, (unsigned __int8 *)v45, *(void **)(a3 + 80));
    if ((result & 0x80000000) != 0) {
      return result;
    }
LABEL_125:
    int v36 = *(void **)(v10 + 8);
    uint64_t v37 = *(void *)(a3 + 112);
    if (v36) {
      *int v36 = v37;
    }
    if (v37) {
      *(void *)(v37 + 8) = v36;
    }
    if (!v36) {
      goto LABEL_136;
    }
    uint64_t v38 = *(void *)(v37 + 32);
    *(_WORD *)(v38 + 20) = 0;
    int v39 = (uint64_t *)v36[4];
    if (!v39) {
      goto LABEL_136;
    }
    int v40 = 0;
    do
    {
      if (v39[1] != *(void *)(v39[3] + 8))
      {
        *((_WORD *)v39 + 9) = 1;
        v39[3] = v38;
        *(_WORD *)(v38 + 20) = ++v40;
      }
      int v39 = (uint64_t *)*v39;
    }
    while (v39);
    if (!v10)
    {
      uint64_t result = 0;
    }
    else
    {
LABEL_136:
      uint64_t v44 = (void *)v10;
      if (v37 != v10)
      {
        uint64_t v41 = (void *)v10;
        while (1)
        {
          uint64_t v41 = (void *)*v41;
          uint64_t result = DisposePosition(a1, a2, a3, (uint64_t *)&v44);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t v44 = v41;
          if (v41 == *(void **)(a3 + 112)) {
            goto LABEL_142;
          }
        }
      }
      uint64_t result = 0;
      uint64_t v41 = (void *)v10;
LABEL_142:
      if (!v36) {
        *(void *)(a3 + 120) = v41;
      }
    }
    *(void *)(a3 + 104) = 0;
    return result;
  }
  if (v9 < 3)
  {
    uint64_t result = 0;
LABEL_29:
    uint64_t v11 = 0;
    uint64_t v12 = a3 + 80;
    int v42 = (uint64_t *)(a3 + 88);
    uint64_t v13 = a3 + 146;
    while (1)
    {
      unsigned int v14 = *(__int16 *)(v8 + 34);
      if (!*(_DWORD *)(v8 + 32)) {
        goto LABEL_14;
      }
      if (*(int *)a2 >= 3)
      {
        uint64_t result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t result = mosyntbase_WString(a1, "fst: ", 0);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t result = mosyntbase_WInt(a1, *(_DWORD *)(a3 + 20), 1);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t result = mosyntbase_WString(a1, " treating output symbol '", 0);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        if (v14)
        {
          uint64_t result = mosyntkbsymtab_WritePhonSym(a1, *(uint64_t **)(a2 + 8), v14);
          if ((result & 0x80000000) != 0) {
            return result;
          }
        }
        else
        {
          uint64_t result = mosyntbase_WString(a1, "@", 0);
          if ((result & 0x80000000) != 0) {
            return result;
          }
        }
        uint64_t result = mosyntbase_WString(a1, "' with input element ", 0);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t v15 = *(void *)(v8 + 40);
        if (v15)
        {
          uint64_t result = mosyntdata_WritePhonEle(a1, *(uint64_t **)(a2 + 8), v15, 0, 0, v8 == *(void *)(a3 + 104), *(void *)v8 == 0);
          if ((result & 0x80000000) != 0) {
            return result;
          }
        }
        else
        {
          uint64_t result = mosyntbase_WString(a1, "NIL", 0);
          if ((result & 0x80000000) != 0) {
            return result;
          }
        }
        uint64_t result = mosyntbase_WLn(a1);
        if ((result & 0x80000000) != 0) {
          return result;
        }
      }
      int v16 = *(unsigned __int16 *)(a3 + 134);
      if (!v14 || v16 == (unsigned __int16)v14 || *(unsigned __int16 *)(a3 + 132) == (unsigned __int16)v14)
      {
        if (v16 == (unsigned __int16)v14)
        {
          uint64_t v17 = *(void *)(v8 + 40);
          if (v17)
          {
            if (*(unsigned char *)(v17 + 20) && *(_DWORD *)(v17 + 24) == 3)
            {
              uint64_t result = mosyntdata_AddBound(a1, (uint64_t *)(a3 + 80), v42, 0, 3, *(_WORD *)(v17 + 28), *(_DWORD *)(v17 + 32), *(_WORD *)(v17 + 36));
              if ((result & 0x80000000) != 0) {
                return result;
              }
              __int16 v18 = *(_WORD *)(v17 + 8);
              goto LABEL_89;
            }
          }
        }
      }
      else
      {
        uint64_t v19 = *(void *)(v8 + 40);
        if (v19 && *(unsigned char *)(v19 + 20))
        {
          int v20 = *(unsigned __int16 *)(a3 + 138);
          if (v20 == (unsigned __int16)v14
            || *(unsigned __int16 *)(a3 + 140) == (unsigned __int16)v14
            || *(unsigned __int16 *)(a3 + 142) == (unsigned __int16)v14
            || *(unsigned __int16 *)(a3 + 144) == (unsigned __int16)v14)
          {
            if (!v11 || *(_DWORD *)(a3 + 128) != 1) {
              goto LABEL_69;
            }
            unint64_t v21 = 0;
            int v22 = -1;
            do
            {
              if (*(unsigned __int16 *)(v13 + 2 * v21) == *(unsigned __int16 *)(v11 + 34)) {
                int v22 = v21;
              }
              if (v21 > 3) {
                break;
              }
              ++v21;
            }
            while (v22 < 0);
            if (v22 < 0) {
LABEL_69:
            }
              LOWORD(v22) = *(_WORD *)(v19 + 36);
            int v23 = *(_DWORD *)(v19 + 24);
            if (*(unsigned __int16 *)(v8 + 32) == (unsigned __int16)v14)
            {
              LOWORD(v24) = *(_WORD *)(v19 + 28);
              goto LABEL_72;
            }
            if (v23 == 3)
            {
              int v24 = *(__int16 *)(v19 + 28);
              if (v24 < 1)
              {
                int v23 = 3;
LABEL_72:
                __int16 v25 = v24;
                int v26 = *(_DWORD *)(v19 + 32);
                uint64_t v27 = a1;
                uint64_t v28 = (uint64_t *)(a3 + 80);
                uint64_t v29 = (uint64_t *)(a3 + 88);
                goto LABEL_87;
              }
            }
            if (v20 == (unsigned __int16)v14)
            {
              uint64_t v27 = a1;
              uint64_t v28 = (uint64_t *)(a3 + 80);
              uint64_t v29 = (uint64_t *)(a3 + 88);
              int v23 = 1;
              goto LABEL_86;
            }
            if (*(unsigned __int16 *)(a3 + 140) == (unsigned __int16)v14)
            {
              uint64_t v27 = a1;
              uint64_t v28 = (uint64_t *)(a3 + 80);
              uint64_t v29 = (uint64_t *)(a3 + 88);
              int v23 = 2;
LABEL_86:
              __int16 v25 = -1;
              int v26 = 0;
LABEL_87:
              uint64_t result = mosyntdata_AddBound(v27, v28, v29, 0, v23, v25, v26, v22);
              if ((result & 0x80000000) != 0) {
                return result;
              }
            }
            else if (*(unsigned __int16 *)(a3 + 144) == (unsigned __int16)v14)
            {
              int v26 = *(_DWORD *)(v19 + 32);
              uint64_t v27 = a1;
              uint64_t v28 = (uint64_t *)(a3 + 80);
              uint64_t v29 = (uint64_t *)(a3 + 88);
              int v23 = 3;
              __int16 v25 = 2;
              goto LABEL_87;
            }
            __int16 v18 = *(_WORD *)(v19 + 8);
LABEL_89:
            *(_WORD *)(*(void *)v12 + 8) = v18;
            goto LABEL_90;
          }
          unint64_t v34 = 0;
          do
          {
            int v35 = *(unsigned __int16 *)(v13 + 2 * v34);
            if (v34 > 3) {
              break;
            }
            ++v34;
          }
          while (v35 != (unsigned __int16)v14);
          if (v35 != (unsigned __int16)v14 && *(int *)a2 >= 1)
          {
            uint64_t result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
            if ((result & 0x80000000) != 0) {
              return result;
            }
            uint64_t result = mosyntbase_WString(a1, "*** transduction error: illegal attempt to change a boundary element to phone \"", 0);
            if ((result & 0x80000000) != 0) {
              return result;
            }
            uint64_t result = mosyntkbsymtab_WritePhonSym(a1, *(uint64_t **)(a2 + 8), v14);
            if ((result & 0x80000000) != 0) {
              return result;
            }
            uint64_t result = mosyntbase_WStringLn(a1, "\"; phone ignored", 0);
            if ((result & 0x80000000) != 0) {
              return result;
            }
          }
        }
        else if (!*(unsigned char *)(v8 + 36))
        {
          unsigned int v30 = *(_DWORD *)(a3 + 40);
          if (v30 > 5 || ((1 << v30) & 0x34) == 0 || v19) {
            goto LABEL_77;
          }
          unint64_t v32 = 0;
          int v33 = -1;
          do
          {
            if (*(unsigned __int16 *)(v13 + 2 * v32) == (unsigned __int16)v14) {
              int v33 = v32;
            }
            if (v32 > 3) {
              break;
            }
            ++v32;
          }
          while (v33 < 0);
          if (v33 < 0)
          {
LABEL_77:
            uint64_t result = mosyntdata_AddPhonEle(a1, (void *)(a3 + 80), v42, 0, v14);
            if ((result & 0x80000000) != 0) {
              return result;
            }
            uint64_t v31 = *(void *)(v8 + 40);
            if (v31)
            {
              *(_WORD *)(*(void *)v12 + 26) = *(_WORD *)(v31 + 26);
              __int16 v18 = *(_WORD *)(*(void *)(v8 + 40) + 8);
            }
            else
            {
              __int16 v18 = -1;
              *(_WORD *)(*(void *)v12 + 26) = -1;
            }
            goto LABEL_89;
          }
        }
      }
LABEL_90:
      if (*(__int16 *)(v8 + 18) > 1)
      {
        if (*(int *)a2 < 2)
        {
          uint64_t result = mosyntbase_WriteDevelMessage(a1, "*** ambiguous transducer solution (use tracing to get more info)\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, 0, 0, 0);
          if ((result & 0x80000000) != 0) {
            return result;
          }
        }
        else
        {
          uint64_t result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t result = mosyntbase_WString(a1, "fst: ", 0);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t result = mosyntbase_WInt(a1, *(_DWORD *)(a3 + 20), 1);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t result = mosyntbase_WStringLn(a1, " ***** ambiguous transducer solution", 0);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t result = mosyntbase_WLn(a1);
          if ((result & 0x80000000) != 0) {
            return result;
          }
        }
      }
      uint64_t v11 = v8;
      uint64_t v8 = *(void *)(v8 + 24);
      if (!v8) {
        goto LABEL_14;
      }
    }
  }
  uint64_t result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
  if ((result & 0x80000000) != 0) {
    return result;
  }
  uint64_t result = mosyntbase_WStringLn(a1, "getting transduction path", 0);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  uint64_t v8 = *(void *)(a3 + 104);
  if (v8) {
    goto LABEL_29;
  }
  uint64_t result = mosyntbase_WriteDevelMessage(a1, "***SVOXTrans.CollectTransductionPath() must not be called with emissionState = NIL\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, 0, 0, 0);
LABEL_14:
  if ((result & 0x80000000) == 0)
  {
    uint64_t v10 = *(void *)(*(void *)(a3 + 104) + 8);
    if (*(int *)a2 < 2) {
      goto LABEL_125;
    }
    uint64_t result = GetInPhonList(a1, a3, *(void *)(*(void *)(a3 + 104) + 8), &v43);
    if ((result & 0x80000000) == 0)
    {
      m2__cp__str("input ", v45, 20);
      uint64_t result = TraceTransductionIO(a1, a2, (unsigned int *)a3, (unsigned __int8 *)v45, v43);
      if ((result & 0x80000000) == 0)
      {
        m2__cp__str("output", v45, 20);
        uint64_t result = TraceTransductionIO(a1, a2, (unsigned int *)a3, (unsigned __int8 *)v45, *(void **)(a3 + 80));
        if ((result & 0x80000000) == 0)
        {
          uint64_t result = mosyntdata_DisposePhonEleList(a1, &v43);
          if ((result & 0x80000000) == 0) {
            goto LABEL_125;
          }
        }
      }
    }
  }
  return result;
}

uint64_t DisposePositionList(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = (void *)(a3 + 112);
  uint64_t v4 = *(void *)(a3 + 112);
  uint64_t v9 = v4;
  if (v4)
  {
    while (1)
    {
      uint64_t v4 = *(void *)(v4 + 8);
      uint64_t result = DisposePosition(a1, a2, a3, &v9);
      if ((result & 0x80000000) != 0) {
        break;
      }
      uint64_t v9 = v4;
      if (!v4) {
        goto LABEL_6;
      }
    }
  }
  else
  {
    uint64_t result = 0;
LABEL_6:
    *int v3 = 0;
    v3[1] = 0;
  }
  return result;
}

uint64_t AddPosition(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v10 = 0;
  uint64_t result = mosyntpal_ALLOCATE(a1, &v10, 0x30u);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v6 = *(void *)(a2 + 120);
    if (v6)
    {
      uint64_t v7 = (void *)v10;
      *(_WORD *)(v10 + 16) = *(_WORD *)(v6 + 16) + 1;
      *uint64_t v7 = v6;
      uint64_t v8 = (void *)v10;
      *(void *)(v6 + 8) = v10;
    }
    else
    {
      uint64_t v9 = (void *)v10;
      *(_WORD *)(v10 + 16) = 0;
      *uint64_t v9 = 0;
      uint64_t v8 = (void *)v10;
      *(void *)(a2 + 112) = v10;
    }
    *(void *)(a2 + 120) = v8;
    v8[1] = 0;
    v8[4] = 0;
    v8[5] = 0;
    v8[3] = a3;
    ++*(_DWORD *)(a2 + 64);
  }
  return result;
}

uint64_t AddPosState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, __int16 a7, __int16 a8, char a9, uint64_t a10)
{
  __int16 v11 = a5;
  unsigned int v14 = (void *)(a4 + 32);
  uint64_t v15 = a4 + 32;
  while (1)
  {
    uint64_t v15 = *(void *)v15;
    uint64_t v26 = v15;
    if (!v15) {
      break;
    }
    if (*(__int16 *)(v15 + 16) == a5)
    {
      ++*(_WORD *)(v15 + 18);
      if (*(int *)a2 < 3) {
        return 0;
      }
      uint64_t result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = mosyntbase_WString(a1, "added transition to pos/state element ", 0);
        if ((result & 0x80000000) == 0)
        {
          uint64_t result = mosyntbase_WInt(a1, *(__int16 *)(*(void *)(v15 + 8) + 16), 0);
          if ((result & 0x80000000) == 0)
          {
            uint64_t result = mosyntbase_WString(a1, "/", 0);
            if ((result & 0x80000000) == 0)
            {
              uint64_t result = mosyntbase_WInt(a1, *(__int16 *)(v15 + 16), 0);
              if ((result & 0x80000000) == 0)
              {
                return mosyntbase_WLn(a1);
              }
            }
          }
        }
      }
      return result;
    }
  }
  __int16 v18 = *(void **)(a2 + 16);
  if (v18)
  {
    uint64_t result = 0;
    uint64_t v26 = *(void *)(a2 + 16);
    *(void *)(a2 + 16) = *v18;
  }
  else
  {
    uint64_t v19 = a3;
    __int16 v20 = a8;
    __int16 v21 = a7;
    uint64_t result = mosyntpal_ALLOCATE(a1, &v26, 0x30u);
    a7 = v21;
    a8 = v20;
    a3 = v19;
    if ((result & 0x80000000) != 0) {
      return result;
    }
  }
  int v22 = *(void **)(a4 + 40);
  int v23 = (void *)v26;
  if (v22)
  {
    *int v22 = v26;
    int v23 = (void *)v26;
  }
  else
  {
    *unsigned int v14 = v26;
  }
  *(void *)(a4 + 40) = v23;
  *int v23 = 0;
  uint64_t v24 = v26;
  *(void *)(v26 + 8) = a4;
  *(_WORD *)(v24 + 16) = v11;
  *(_DWORD *)(v24 + 18) = 1;
  *(void *)(v24 + 24) = a6;
  if (a6) {
    ++*(_WORD *)(a6 + 20);
  }
  *(_WORD *)(v24 + 32) = a7;
  *(_WORD *)(v24 + 34) = a8;
  *(unsigned char *)(v24 + 36) = a9;
  *(void *)(v24 + 40) = a10;
  if (*(int *)a2 >= 3)
  {
    uint64_t result = mosyntknowl_WriteTraceHeader(a1, *(_DWORD *)(a3 + 16));
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = mosyntbase_WString(a1, "inserted pos/state element ", 0);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = mosyntbase_WInt(a1, *(__int16 *)(*(void *)(v26 + 8) + 16), 0);
        if ((result & 0x80000000) == 0)
        {
          uint64_t result = mosyntbase_WString(a1, "/", 0);
          if ((result & 0x80000000) == 0)
          {
            uint64_t result = mosyntbase_WInt(a1, *(__int16 *)(v26 + 16), 0);
            if ((result & 0x80000000) == 0) {
              return mosyntbase_WLn(a1);
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t DisposePosition(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v7 = *a4;
  uint64_t v8 = *(void *)(*a4 + 32);
  if (v8)
  {
    uint64_t v9 = *(void **)(*a4 + 32);
    do
    {
      uint64_t v10 = v9;
      uint64_t v9 = (void *)*v9;
    }
    while (v9);
    *uint64_t v10 = *(void *)(a2 + 16);
    *(void *)(a2 + 16) = v8;
    uint64_t v7 = *a4;
  }
  uint64_t result = mosyntdata_DisposePhonEleList(a1, (void **)(v7 + 24));
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = mosyntpal_DEALLOCATE(a1, a4);
    if ((result & 0x80000000) == 0) {
      --*(_DWORD *)(a3 + 64);
    }
  }
  return result;
}

uint64_t FindEmissionState(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = **(void ***)(a3 + 120);
  if (v3)
  {
    uint64_t v4 = (uint64_t *)v3[4];
    if (v4)
    {
      do
      {
        if (!*((_WORD *)v4 + 10))
        {
          uint64_t v8 = v4;
          while (1)
          {
            uint64_t v9 = (uint64_t *)v8[3];
            if (!v9) {
              break;
            }
            __int16 v10 = *((_WORD *)v9 + 10) - 1;
            *((_WORD *)v9 + 10) = v10;
            v8[3] = 0;
            uint64_t v8 = v9;
            if (v10) {
              goto LABEL_9;
            }
          }
          v8[3] = 0;
        }
LABEL_9:
        uint64_t v4 = (uint64_t *)*v4;
      }
      while (v4);
      uint64_t result = 0;
      *(void *)(a3 + 104) = 0;
      while (1)
      {
        uint64_t v12 = (void *)v3[4];
        if (!v12) {
          break;
        }
        int v13 = 0;
        unsigned int v14 = 0;
        uint64_t v15 = (void *)v3[4];
        do
        {
          int v16 = (void *)*v15;
          if (*((_WORD *)v15 + 10))
          {
            unsigned int v14 = v15;
          }
          else
          {
            *uint64_t v15 = *(void *)(a2 + 16);
            *(void *)(a2 + 16) = v15;
            if (v14) {
              uint64_t v17 = v14;
            }
            else {
              uint64_t v17 = v3 + 4;
            }
            if (!v14) {
              uint64_t v12 = v16;
            }
            void *v17 = v16;
            int v13 = 1;
          }
          uint64_t v15 = v16;
        }
        while (v16);
        v3[5] = v14;
        if (!v12) {
          goto LABEL_26;
        }
        if (*v12 || *(_DWORD *)(a3 + 128) == 1 && (uint64_t v18 = v3[3]) != 0 && *(unsigned char *)(v18 + 20))
        {
          uint64_t v12 = 0;
          goto LABEL_29;
        }
LABEL_28:
        *(void *)(a3 + 104) = v12;
LABEL_29:
        int v3 = (void *)*v3;
        if (!v3 || !v13 || v12) {
          return result;
        }
      }
      int v13 = 0;
      v3[5] = 0;
LABEL_26:
      uint64_t result = mosyntbase_WriteDevelMessage(a1, "*** no state left\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, 0, 0, 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t v12 = 0;
      goto LABEL_28;
    }
  }
  return 0;
}

uint64_t GetInPhonList(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v12 = 0;
  uint64_t result = mosyntdata_StartPhonList(a1, a4, &v12);
  if (a3)
  {
    if ((result & 0x80000000) == 0)
    {
      uint64_t v9 = *(void *)(a2 + 112);
      if (v9)
      {
        uint64_t v10 = *(void *)(a3 + 8);
        while (v9 != v10)
        {
          if (*(void *)(v9 + 24))
          {
            __int16 v11 = *(uint64_t **)(v9 + 24);
            uint64_t result = mosyntdata_CopyPhonList(a1, &v11);
            if ((result & 0x80000000) != 0) {
              return result;
            }
            uint64_t result = mosyntdata_AppendPhonList(a1, a4, &v12, (uint64_t)v11, (uint64_t)v11);
            if ((result & 0x80000000) != 0) {
              return result;
            }
            uint64_t v10 = *(void *)(a3 + 8);
          }
          uint64_t v9 = *(void *)(v9 + 8);
        }
      }
    }
  }
  return result;
}

uint64_t TraceTransductionIO(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned __int8 *a4, void *a5)
{
  uint64_t result = mosyntknowl_WriteTraceHeader(a1, a3[4]);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = mosyntbase_WString(a1, "fst: ", 0);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = mosyntbase_WInt(a1, a3[5], 1);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = mosyntbase_WString(a1, " transduction ", 0);
        if ((result & 0x80000000) == 0)
        {
          uint64_t result = mosyntbase_WString(a1, a4, 20);
          if ((result & 0x80000000) == 0)
          {
            if (a3[10] - 1 > 1 || (uint64_t result = mosyntbase_WString(a1, " (IPA)", 0), (result & 0x80000000) == 0))
            {
              uint64_t result = mosyntbase_WString(a1, ": ", 0);
              if ((result & 0x80000000) == 0)
              {
                unsigned int v11 = a3[32] == 1 ? 5 : 4;
                uint64_t result = mosyntdata_WriteFormattedPhonList(a1, *(uint64_t **)(a2 + 8), a5, v11, 0);
                if ((result & 0x80000000) == 0)
                {
                  return mosyntbase_WLn(a1);
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t fst_LoadData(_WORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v65 = *MEMORY[0x263EF8340];
  uint64_t v57 = 0;
  unsigned int v58 = 0;
  memset(v64, 0, sizeof(v64));
  *a3 = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v58);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = kbaux_BuildBrokerString((uint64_t)v58, "fsts", (char *)v64, 0x100uLL);
    if ((result & 0x80000000) == 0)
    {
      int v7 = ssftriff_reader_ObjOpen(a1, a2, 2, (const char *)v64, "FSTS", 1031, (uint64_t *)&v57);
      if (v7 < 0)
      {
        int v17 = v7;
      }
      else
      {
        int v16 = v57;
        uint64_t v15 = v58;
        unsigned int v63 = 0;
        uint64_t v62 = 0;
        unsigned __int8 v61 = 0;
        int v60 = 0;
        int v17 = ssftriff_reader_OpenChunk((uint64_t)v57, &v60, &v63, &v62, v11, v12, v13, v14);
        if ((v17 & 0x80000000) == 0 && !(v60 ^ 0x53545346 | v61))
        {
          unint64_t v59 = 0;
          int v17 = ssftriff_reader_DetachChunkData((uint64_t)v16, (uint64_t *)&v59, &v62, v10, v11, v12, v13, v14);
          if ((v17 & 0x80000000) == 0)
          {
            uint64_t v18 = (_OWORD *)heap_Alloc(v15[1], 48);
            *a3 = (uint64_t)v18;
            if (!v18) {
              goto LABEL_23;
            }
            v18[1] = 0u;
            v18[2] = 0u;
            *uint64_t v18 = 0u;
            uint64_t v26 = *a3;
            *(_DWORD *)uint64_t v26 = v63;
            *(void *)(v26 + 16) = v59;
            uint64_t v27 = v62;
            *(void *)(*a3 + 8) = v62;
            int v29 = *v27;
            uint64_t v28 = v27 + 1;
            uint64_t v30 = *a3;
            *(_DWORD *)(v30 + 24) = v29;
            *(void *)(v30 + 32) = v28;
            uint64_t v31 = *(int *)(*a3 + 24);
            *(void *)(*a3 + 40) = heap_Alloc(v15[1], (16 * v31));
            unint64_t v32 = *(void **)(*a3 + 40);
            if (v32)
            {
              bzero(v32, (16 * *(_DWORD *)(*a3 + 24)));
              uint64_t v33 = *a3;
              if (*(int *)(*a3 + 24) >= 1)
              {
                uint64_t v34 = 0;
                int v35 = &v28[v31];
                do
                {
                  int v36 = *v35++;
                  uint64_t v37 = *(void *)(v33 + 40) + 16 * v34;
                  *(_DWORD *)uint64_t v37 = v36;
                  *(void *)(v37 + 8) = 0;
                  uint64_t v33 = *a3;
                  int v38 = *(_DWORD *)(*(void *)(*a3 + 40) + 16 * v34);
                  if (v38 >= 1)
                  {
                    *(void *)(*(void *)(*a3 + 40) + 16 * v34 + 8) = heap_Alloc(v15[1], (v38 << 6));
                    uint64_t v39 = *(void *)(*a3 + 40);
                    int v40 = *(void **)(v39 + 16 * v34 + 8);
                    if (!v40) {
                      goto LABEL_23;
                    }
                    bzero(v40, (*(_DWORD *)(v39 + 16 * v34) << 6));
                    uint64_t v33 = *a3;
                    uint64_t v41 = *(void *)(*a3 + 40);
                    if (*(int *)(v41 + 16 * v34) >= 1)
                    {
                      uint64_t v42 = 0;
                      uint64_t v43 = *(void *)(v41 + 16 * v34 + 8);
                      uint64_t v44 = 56;
                      do
                      {
                        int v46 = *v35;
                        int v45 = v35 + 1;
                        uint64_t v47 = v43 + v44;
                        *(_DWORD *)(v47 - 56) = v46;
                        *(void *)(v47 - 48) = v45;
                        uint64_t v48 = *(void *)(*(void *)(*a3 + 40) + 16 * v34 + 8) + v44;
                        uint64_t v49 = &v45[*(_DWORD *)(v48 - 56) + 1];
                        int v50 = *v49++;
                        *(_DWORD *)(v48 - 40) = v50;
                        *(void *)(v48 - 32) = v49;
                        uint64_t v51 = *(void *)(*(void *)(*a3 + 40) + 16 * v34 + 8) + v44;
                        unsigned __int8 v52 = (int *)((char *)v49 + 6 * *(int *)(v51 - 40) + 2 * (*(_DWORD *)(v51 - 40) & 1));
                        *(_DWORD *)(v51 - 24) = *v52;
                        *(_DWORD *)(v51 - 16) = v52[1];
                        int v53 = v52 + 2;
                        *(void *)(v51 - 8) = v52 + 2;
                        uint64_t v33 = *a3;
                        unsigned int v54 = (int *)(*(void *)(*a3 + 40) + 16 * v34);
                        uint64_t v43 = *((void *)v54 + 1);
                        int v55 = (_DWORD *)((char *)v53
                                       + 2 * *(_DWORD *)(v43 + v44 - 16)
                                       + 2 * (*(_DWORD *)(v43 + v44 - 16) & 1));
                        int v56 = *v55;
                        int v35 = v55 + 1;
                        *(_DWORD *)(v43 + v44) = v56;
                        ++v42;
                        v44 += 64;
                      }
                      while (v42 < *v54);
                    }
                  }
                  ++v34;
                }
                while (v34 < *(int *)(v33 + 24));
              }
            }
            else
            {
LABEL_23:
              ssftriff_reader_ReleaseChunkData(v59, v19, v20, v21, v22, v23, v24, v25);
              free_FSTS(v15, a3);
              int v17 = -1923080182;
            }
          }
        }
      }
      LODWORD(result) = ssftriff_reader_ObjClose(v57, v8, v9, v10, v11, v12, v13, v14);
      if (v17 >= 0) {
        return result;
      }
      else {
        return v17;
      }
    }
  }
  return result;
}

uint64_t fst_UnloadData(_WORD *a1, int a2, uint64_t *a3)
{
  uint64_t v13 = 0;
  if (!a3) {
    return 2371887111;
  }
  uint64_t inited = InitRsrcFunction(a1, a2, &v13);
  if ((inited & 0x80000000) == 0)
  {
    if (*a3) {
      ssftriff_reader_ReleaseChunkData(*(void **)(*a3 + 16), v4, v5, v6, v7, v8, v9, v10);
    }
    free_FSTS(v13, a3);
  }
  return inited;
}

void *free_FSTS(void *result, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (v3)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(void *)(v3 + 40);
    if (v5)
    {
      if (*(int *)(v3 + 24) >= 1)
      {
        uint64_t v6 = 0;
        uint64_t v7 = 8;
        do
        {
          if (*(void *)(*(void *)(v3 + 40) + v7))
          {
            heap_Free((void *)v4[1], *(void *)(*(void *)(v3 + 40) + v7));
            uint64_t v3 = *a2;
          }
          ++v6;
          v7 += 16;
        }
        while (v6 < *(int *)(v3 + 24));
        uint64_t v5 = *(void *)(v3 + 40);
      }
      heap_Free((void *)v4[1], v5);
      uint64_t v3 = *a2;
    }
    uint64_t result = heap_Free((void *)v4[1], v3);
    *a2 = 0;
  }
  return result;
}

uint64_t fst_getFSTSeq(uint64_t a1, int a2, void *a3, _DWORD *a4)
{
  uint64_t result = 2371887111;
  *a4 = 0;
  *a3 = 0;
  if (a1)
  {
    uint64_t v6 = *(unsigned int *)(a1 + 24);
    uint64_t v7 = 16 * v6;
    while ((int)v6 >= 1)
    {
      uint64_t v8 = *(void *)(a1 + 32) + 4 * v6--;
      v7 -= 16;
      if (*(_DWORD *)(v8 - 4) == a2)
      {
        uint64_t result = 0;
        *a3 = *(void *)(a1 + 40) + v7;
        *a4 = *(_DWORD *)(*(void *)(a1 + 40) + v7);
        return result;
      }
    }
  }
  return result;
}

uint64_t fst_getFST(uint64_t a1, int a2, void *a3)
{
  uint64_t result = 2371887111;
  *a3 = 0;
  if (a1)
  {
    if (*(_DWORD *)a1 > a2)
    {
      uint64_t result = 0;
      *a3 = *(void *)(a1 + 8) + ((uint64_t)a2 << 6);
    }
  }
  return result;
}

uint64_t fst_Trans(uint64_t result, int a2, int *a3)
{
  if (result)
  {
    int v3 = *(__int16 *)(*(void *)(result + 24) + 6 * *a3 + 4) + *(_DWORD *)(result + 32) * (a2 - 1) - 1;
    if (v3 < 0 || v3 >= *(_DWORD *)(result + 40)) {
      return 0;
    }
    else {
      return *(__int16 *)(*(void *)(result + 48) + 2 * v3);
    }
  }
  return result;
}

BOOL fst_validPair(_DWORD *a1)
{
  int v1 = a1[1];
  return (v1 & 0x80000000) == 0 && *a1 < v1;
}

double fst_firstSamePair(__int16 *a1, int a2, uint64_t a3)
{
  if (!a1
    || (uint64_t v3 = *((void *)a1 + 1),
        uint64_t v4 = a2 % *a1,
        int v5 = *(_DWORD *)(v3 + 4 * v4),
        uint64_t v6 = v4 + 1,
        v5 >= *(_DWORD *)(v3 + 4 * v6))
    || (*(_DWORD *)a3 = v5, uint64_t v7 = *(unsigned int *)(v3 + 4 * v6), *(_DWORD *)(a3 + 4) = v7, (v7 & 0x80000000) != 0)
    || v5 >= (int)v7)
  {
LABEL_10:
    double result = NAN;
    *(void *)a3 = -1;
    return result;
  }
  uint64_t v8 = *((void *)a1 + 3);
  if (*(unsigned __int16 *)(v8 + 6 * v5) != (unsigned __int16)a2)
  {
    uint64_t v9 = v5;
    uint64_t v10 = (unsigned __int16 *)(v8 + 6 * v5 + 6);
    for (uint64_t i = v9 + 1; i < v7; ++i)
    {
      *(_DWORD *)a3 = i;
      int v12 = *v10;
      v10 += 3;
      if (v12 == (unsigned __int16)a2) {
        return result;
      }
    }
    goto LABEL_10;
  }
  return result;
}

uint64_t fst_nextSamePair(uint64_t a1, int *a2)
{
  if (!a1 || (int v2 = a2[1], v2 < 0) || (v3 = *a2, v4 = *a2 + 1, v4 >= v2))
  {
LABEL_7:
    uint64_t result = 0;
    *(void *)a2 = -1;
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 24);
    int v6 = *(unsigned __int16 *)(v5 + 6 * v3);
    uint64_t v7 = (unsigned __int16 *)(v5 + 6 * v3 + 6);
    while (1)
    {
      int v8 = *v7;
      v7 += 3;
      if (v6 == v8) {
        break;
      }
      if (v2 == ++v4) {
        goto LABEL_7;
      }
    }
    *a2 = v4;
    return 1;
  }
  return result;
}

uint64_t fst_getPair(uint64_t a1, _DWORD *a2, _WORD *a3, _WORD *a4, _WORD *a5)
{
  uint64_t result = 2371887111;
  if (a1)
  {
    int v7 = a2[1];
    if ((v7 & 0x80000000) == 0 && *a2 < v7)
    {
      uint64_t result = 0;
      uint64_t v8 = *(void *)(a1 + 24);
      int v9 = 3 * *a2;
      *a3 = *(_WORD *)(v8 + 2 * v9);
      *a4 = *(_WORD *)(v8 + 2 * (v9 + 1));
      *a5 = *(_WORD *)(v8 + 2 * (v9 + 2));
    }
  }
  return result;
}

uint64_t fst_getTransductionMode(uint64_t a1, _DWORD *a2)
{
  if (!a1) {
    return 2371887111;
  }
  uint64_t result = 0;
  *a2 = *(_DWORD *)(a1 + 56);
  return result;
}

uint64_t kblex_LoadOneLex(_WORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v5 = 2371887104;
  int v40 = 0;
  *a5 = 0;
  int v6 = *(unsigned __int16 *)(a4 + 264);
  switch(*(_WORD *)(a4 + 264))
  {
    case 0:
      char v47 = 0;
      unsigned __int16 v9 = 19526;
      goto LABEL_4;
    case 1:
      char v47 = 0;
      unsigned __int16 v9 = 19533;
LABEL_4:
      int v10 = v9 | 0x58450000;
      goto LABEL_12;
    case 2:
      char v47 = 0;
      unsigned __int16 v11 = 19795;
      goto LABEL_11;
    case 3:
      char v47 = 0;
      unsigned __int16 v11 = 21584;
      goto LABEL_11;
    case 4:
      char v47 = 0;
      unsigned __int16 v11 = 21571;
      goto LABEL_11;
    case 5:
      char v47 = 0;
      unsigned __int16 v11 = 21569;
      goto LABEL_11;
    case 6:
      char v47 = 0;
      unsigned __int16 v11 = 21575;
      goto LABEL_11;
    case 7:
      char v47 = 0;
      unsigned __int16 v11 = 21072;
LABEL_11:
      int v10 = v11 | 0x584C0000;
LABEL_12:
      int v46 = v10;
      *(_DWORD *)__s2 = v10;
      char v45 = 0;
      char v43 = 0;
      *(_DWORD *)__s1 = 0;
      uint64_t v41 = 0;
      unsigned int v39 = 0;
      int v12 = ssftriff_reader_ObjOpen(a1, a2, 2, (const char *)(a4 + 8), (char *)&v46, 1031, (uint64_t *)&v40);
      if (v12 < 0)
      {
        int v20 = v12;
        goto LABEL_28;
      }
      int v20 = ssftriff_reader_OpenChunk((uint64_t)v40, __s1, &v39, &v41, v16, v17, v18, v19);
      if (v20 < 0) {
        goto LABEL_28;
      }
      if (strcmp(__s1, __s2)) {
        goto LABEL_28;
      }
      int v38 = 0;
      int v20 = ssftriff_reader_DetachChunkData((uint64_t)v40, (uint64_t *)&v38, &v41, v15, v16, v17, v18, v19);
      if (v20 < 0) {
        goto LABEL_28;
      }
      uint64_t v21 = v41;
      if (v6 != *v41) {
        goto LABEL_35;
      }
      int v22 = *((_DWORD *)v41 + 1);
      uint64_t v23 = heap_Calloc(*(void **)(a3 + 8), 1, 296 * v22);
      if (v23)
      {
        uint64_t v24 = v23;
        if (v22 <= 0)
        {
          __strcpy_chk();
        }
        else
        {
          uint64_t v25 = 0;
          uint64_t v26 = v21 + 4;
          do
          {
            uint64_t v27 = v23 + v25;
            *(unsigned char *)(v27 + 260) = v26[1];
            *(unsigned char *)(v27 + 264) = v26[2];
            uint64_t v28 = (int)v26[3];
            *(_DWORD *)(v27 + 268) = v28;
            int v29 = v26 + 4;
            *(void *)(v27 + 272) = v29;
            uint64_t v30 = (char *)v29 + v28;
            *(_DWORD *)(v27 + 280) = -1;
            *(void *)(v27 + 288) = v38;
            BOOL v31 = -(int)v28 < 0;
            int v32 = -(int)v28 & 3;
            int v33 = v28 & 3;
            if (!v31) {
              int v33 = -v32;
            }
            uint64_t v34 = &v30[-v33];
            int v35 = *((_DWORD *)v34 + 1);
            uint64_t v26 = v34 + 4;
            if (v35 != 1234567890) {
              int v20 = -1923080192;
            }
            v25 += 296;
          }
          while (296 * v22 != v25);
          __strcpy_chk();
          if (v20 < 0)
          {
            ssftriff_reader_ReleaseChunkData(v38, v13, v14, v15, v16, v17, v18, v19);
            heap_Free(*(void **)(a3 + 8), v24);
LABEL_28:
            uint64_t v24 = 0;
          }
        }
      }
      else
      {
        LODWORD(v5) = -1923080182;
LABEL_35:
        ssftriff_reader_ReleaseChunkData(v38, v13, v14, v15, v16, v17, v18, v19);
        uint64_t v24 = 0;
        int v20 = v5;
      }
      unsigned int v36 = ssftriff_reader_ObjClose(v40, v13, v14, v15, v16, v17, v18, v19);
      if (v20 >= 0) {
        uint64_t v5 = v36;
      }
      else {
        uint64_t v5 = v20;
      }
      *a5 = v24;
      return v5;
    default:
      return v5;
  }
}

uint64_t kblex_loadLex(_WORD *a1, int a2, _WORD *a3, int a4, int a5, void *a6)
{
  v37[3] = *MEMORY[0x263EF8340];
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = 0;
  memset(v36, 0, sizeof(v36));
  __int16 v7 = a5;
  switch(a5)
  {
    case 0:
      BYTE4(v37[0]) = 0;
      unsigned __int16 v10 = 27750;
      goto LABEL_5;
    case 1:
      BYTE4(v37[0]) = 0;
      unsigned __int16 v10 = 27757;
LABEL_5:
      int v12 = v10 | 0x78650000;
      goto LABEL_7;
    case 2:
      strcpy((char *)v37 + 4, "x");
      int v12 = 1701604723;
LABEL_7:
      LODWORD(v37[0]) = v12;
      goto LABEL_14;
    case 3:
      strcpy((char *)v37 + 7, "lex");
      uint64_t v13 = "phontablex";
      goto LABEL_13;
    case 4:
      strcpy((char *)v37 + 7, "lex");
      uint64_t v13 = "constablex";
      goto LABEL_13;
    case 5:
      strcpy((char *)v37 + 7, "lex");
      uint64_t v13 = "atomtablex";
      goto LABEL_13;
    case 6:
      strcpy((char *)&v37[1], "lex");
      uint64_t v13 = "graphtablex";
      goto LABEL_13;
    case 7:
      strcpy((char *)v37 + 7, "lex");
      uint64_t v13 = "proptablex";
LABEL_13:
      v37[0] = *(void *)v13;
LABEL_14:
      uint64_t result = InitRsrcFunction(a1, a2, &v17);
      if ((result & 0x80000000) != 0) {
        goto LABEL_19;
      }
      uint64_t result = InitRsrcFunction(a3, a4, &v16);
      if ((result & 0x80000000) != 0) {
        goto LABEL_19;
      }
      uint64_t result = kbaux_BuildBrokerString(v17, (const char *)v37, v36, 0x100uLL);
      if ((result & 0x80000000) != 0) {
        goto LABEL_19;
      }
      uint64_t v35 = 0;
      long long v34 = 0u;
      long long v33 = 0u;
      long long v32 = 0u;
      long long v31 = 0u;
      long long v30 = 0u;
      long long v29 = 0u;
      long long v28 = 0u;
      long long v27 = 0u;
      long long v26 = 0u;
      long long v25 = 0u;
      long long v24 = 0u;
      long long v23 = 0u;
      long long v22 = 0u;
      long long v21 = 0u;
      long long v20 = 0u;
      long long v19 = 0u;
      uint64_t v18 = v17;
      __strcpy_chk();
      LOWORD(v35) = v7;
      ObjcForThisApuint64_t i = getObjcForThisApi(v17, v16);
      uint64_t result = objc_GetAddRefCountedObject(ObjcForThisApi, (uint64_t)v36, (uint64_t (*)(void, void, uint64_t, long long *, uint64_t))kblex_loc_ObjcLoadLex, (void (*)(void, void, long long *))kblex_loc_ObjcUnloadLex, (uint64_t)&v18, &v15);
      if ((result & 0x80000000) != 0) {
LABEL_19:
      }
        *a6 = 0;
      else {
        *a6 = *(void *)(v15 + 32);
      }
      break;
    default:
      uint64_t result = 2371887104;
      break;
  }
  return result;
}

uint64_t kblex_loc_ObjcLoadLex(_WORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v9 = *a5;
  int v12 = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v12);
  if ((result & 0x80000000) == 0)
  {
    memcpy(v11, v12, sizeof(v11));
    *(_OWORD *)&v11[32] = *(_OWORD *)(v9 + 32);
    return kblex_LoadOneLex(a1, a2, (uint64_t)v11, (uint64_t)a5, (uint64_t *)(a4 + 32));
  }
  return result;
}

uint64_t kblex_loc_ObjcUnloadLex(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t v14 = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v14);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v12 = *(void *)(a3 + 32);
    if (v12)
    {
      uint64_t v13 = v14;
      ssftriff_reader_ReleaseChunkData(*(void **)(v12 + 288), v5, v6, v7, v8, v9, v10, v11);
      heap_Free(*(void **)(v13 + 8), v12);
      return 0;
    }
    else
    {
      return 2371887111;
    }
  }
  return result;
}

uint64_t kblex_InitLex(_WORD *a1, int a2, _WORD *a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int16 a9, void *a10)
{
  LODWORD(result) = kblex_loadLex(a1, a2, a3, a4, a9, a10);
  if ((int)result < 0 && a9 == 0) {
    return 0;
  }
  else {
    return result;
  }
}

uint64_t kblex_FinishLex(_WORD *a1, int a2, _WORD *a3, int a4, uint64_t a5)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t result = InitRsrcFunction(a3, a4, &v10);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = InitRsrcFunction(a1, a2, &v11);
    if ((result & 0x80000000) == 0)
    {
      ObjcForThisApuint64_t i = getObjcForThisApi(v11, v10);
      return objc_ReleaseObject(ObjcForThisApi, a5);
    }
  }
  return result;
}

uint64_t mosyntsentana_InsertTerminalEdge(uint64_t a1, int *a2, signed int a3, signed int a4, signed int a5, uint64_t a6, uint64_t a7, int a8)
{
  __int16 v8 = a3;
  uint64_t v40 = *MEMORY[0x263EF8340];
  if (a3 < 0)
  {
    uint64_t v11 = "tried to insert terminal sentence edge starting at position ";
    a4 = a3;
    goto LABEL_33;
  }
  signed int v10 = a4;
  if (a4 >= 5001)
  {
    uint64_t v11 = "impossible to insert terminal sentence edge ending at position ";
LABEL_33:
    return mosyntbase_WInt3Ln(a1, (unsigned __int8 *)v11, 0, a4, (unsigned __int8 *)&byte_20D5A22AE, 0);
  }
  __int16 v12 = a5;
  if (a5 < 0)
  {
    uint64_t v11 = "tried to insert terminal sentence edge with constituent id < 0: ";
    a4 = a5;
    goto LABEL_33;
  }
  signed int v17 = a2[10010];
  BOOL v18 = v17 < a3;
  if (v17 <= a3) {
    signed int v17 = a3;
  }
  if (v18 || v17 < a4)
  {
    if (v17 <= a4) {
      signed int v17 = a4;
    }
    a2[10010] = v17;
  }
  long long v20 = &a2[2 * a3];
  uint64_t v22 = *((void *)v20 + 4);
  long long v21 = (uint64_t *)(v20 + 8);
  if (!v22)
  {
    uint64_t result = mosyntpal_ALLOCATE(a1, v21, 0x130u);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    long long v24 = (_OWORD *)*v21;
    v24[17] = 0u;
    v24[18] = 0u;
    v24[15] = 0u;
    v24[16] = 0u;
    v24[13] = 0u;
    v24[14] = 0u;
    v24[11] = 0u;
    v24[12] = 0u;
    v24[9] = 0u;
    v24[10] = 0u;
    v24[7] = 0u;
    v24[8] = 0u;
    _OWORD v24[5] = 0u;
    v24[6] = 0u;
    v24[3] = 0u;
    v24[4] = 0u;
    v24[1] = 0u;
    unsigned char v24[2] = 0u;
    *long long v24 = 0u;
  }
  long long v25 = &a2[2 * v10];
  uint64_t v27 = *((void *)v25 + 4);
  long long v26 = (uint64_t *)(v25 + 8);
  if (!v27)
  {
    uint64_t result = mosyntpal_ALLOCATE(a1, v26, 0x130u);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    long long v28 = (_OWORD *)*v26;
    v28[17] = 0u;
    v28[18] = 0u;
    v28[15] = 0u;
    v28[16] = 0u;
    v28[13] = 0u;
    v28[14] = 0u;
    v28[11] = 0u;
    v28[12] = 0u;
    v28[9] = 0u;
    v28[10] = 0u;
    v28[7] = 0u;
    v28[8] = 0u;
    v28[5] = 0u;
    v28[6] = 0u;
    void v28[3] = 0u;
    v28[4] = 0u;
    v28[1] = 0u;
    v28[2] = 0u;
    *long long v28 = 0u;
  }
  uint64_t v37 = 0;
  memset(v38, 0, sizeof(v38));
  int v39 = 0;
  ++a2[25026];
  uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v37, 0x78u);
  if ((result & 0x80000000) == 0)
  {
    long long v29 = v37;
    v37[12] = v8;
    v29[13] = v10;
    v29[14] = v12;
    uint64_t v30 = *(void *)(a6 + 16);
    *((_OWORD *)v29 + 2) = *(_OWORD *)a6;
    *((void *)v29 + 6) = v30;
    *((unsigned char *)v29 + 58) = 1;
    *((void *)v29 + 8) = a7;
    uint64_t result = mosyntkbsgram_NilIter((void *)v29 + 10);
    if ((result & 0x80000000) == 0)
    {
      long long v31 = v37;
      *((_DWORD *)v37 + 24) = a8;
      *((unsigned char *)v31 + 57) = 0;
      *((void *)v31 + 13) = 0;
      *((unsigned char *)v31 + 112) = 0;
      uint64_t v32 = *v26;
      uint64_t v33 = (__int16)(v31[14]
                    - 37
                    * ((((7085 * v31[14]) >> 16) >> 2)
                     + ((unsigned __int16)((7085 * v31[14]) >> 16) >> 15)));
      *(void *)long long v31 = *(void *)(*v26 + 8 * v33);
      *(void *)(v32 + 8 * v33) = v37;
      long long v34 = v37;
      *((void *)v37 + 2) = 0;
      *((unsigned char *)v34 + 56) = 0;
      uint64_t v35 = *(void *)(*v21 + 296);
      if (v35)
      {
        uint64_t v36 = *(void *)(*v21 + 296);
        while (*(unsigned __int16 *)(v36 + 28) != (unsigned __int16)v34[14])
        {
          uint64_t v36 = *(void *)(v36 + 8);
          if (!v36) {
            goto LABEL_28;
          }
        }
      }
      else
      {
LABEL_28:
        *((void *)v34 + 1) = v35;
        *(void *)(*v21 + 296) = v34;
      }
      if (*a2 >= 3)
      {
        m2__cp__str("inserted terminal edge", v38, 100);
        return WriteEdge(a1, (uint64_t)a2, (unsigned __int8 *)v38, 100, v37);
      }
    }
  }
  return result;
}

uint64_t WriteEdge(uint64_t a1, uint64_t a2, unsigned __int8 *a3, int a4, __int16 *a5)
{
  uint64_t result = mosyntbase_WString(a1, a3, a4);
  if (a5)
  {
    if ((result & 0x80000000) != 0) {
      return result;
    }
    uint64_t result = mosyntbase_WString(a1, " ", 0);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    uint64_t result = mosyntkbsymtab_WriteConsAndFeat(a1, *(uint64_t **)(a2 + 8), a5[14], a5 + 16);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    uint64_t result = mosyntbase_WString(a1, " from pos ", 0);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    uint64_t result = mosyntbase_WInt(a1, a5[12], 0);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    uint64_t result = mosyntbase_WString(a1, " to pos ", 0);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    uint64_t result = mosyntbase_WInt(a1, a5[13], 0);
    if ((result & 0x80000000) != 0) {
      return result;
    }
  }
  else
  {
    if ((result & 0x80000000) != 0) {
      return result;
    }
    uint64_t result = mosyntbase_WString(a1, " NIL", 0);
    if ((result & 0x80000000) != 0) {
      return result;
    }
  }
  return mosyntbase_WLn(a1);
}

uint64_t mosyntsentana_CreateAndInitParseDesc(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  uint64_t result = mosyntpal_ALLOCATE(a1, a6, 0x18728u);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v13 = *a6;
    *(_DWORD *)uint64_t v13 = a2;
    *(void *)(v13 + 8) = a3;
    *(void *)(*a6 + 16) = a4;
    uint64_t v14 = *a6;
    *(_DWORD *)(v14 + 24) = a5;
    *(void *)(v14 + 100112) = 0;
    *(void *)(v14 + 100120) = 0;
    *(void *)(v14 + 100104) = 0;
    uint64_t result = mosyntknowl_NewBindingDesc(a1, (uint64_t *)(v14 + 100128));
    if ((result & 0x80000000) == 0)
    {
      uint64_t v15 = 0;
      uint64_t v16 = *a6;
      uint64_t v17 = 80056;
      do
      {
        *(void *)(v16 + v15 + 32) = 0;
        *(void *)(*a6 + v15 + 40048) = 0;
        uint64_t v16 = *a6;
        *(_DWORD *)(*a6 + v17) = 0;
        v15 += 8;
        v17 += 4;
      }
      while (v15 != 40008);
      BOOL v18 = (_OWORD **)(v16 + 32);
      uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)(v16 + 32), 0x130u);
      if ((result & 0x80000000) == 0)
      {
        long long v19 = *v18;
        v19[17] = 0u;
        v19[18] = 0u;
        v19[15] = 0u;
        v19[16] = 0u;
        v19[13] = 0u;
        v19[14] = 0u;
        v19[11] = 0u;
        v19[12] = 0u;
        v19[9] = 0u;
        v19[10] = 0u;
        v19[7] = 0u;
        v19[8] = 0u;
        v19[5] = 0u;
        void v19[6] = 0u;
        void v19[3] = 0u;
        v19[4] = 0u;
        v19[1] = 0u;
        v19[2] = 0u;
        *long long v19 = 0u;
        uint64_t v20 = *a6;
        long long v22 = 0u;
        long long v23 = 0u;
        int v21 = 0;
        uint64_t v28 = 0;
        long long v27 = 0u;
        uint64_t v26 = 0;
        long long v25 = 0u;
        uint64_t v24 = 0;
        *(_OWORD *)(v20 + 100064) = 0u;
        uint64_t result = mosyntkbsgram_GetFirstEmptyRule(*(void *)(v20 + 16), (uint64_t)&v22, &v21);
        if ((result & 0x80000000) == 0)
        {
          while (v21 >= 1)
          {
            uint64_t result = mosyntkbsgram_GetRuleFeatLists((uint64_t *)&v22, &v27, &v25, &v23);
            if ((result & 0x80000000) == 0)
            {
              uint64_t result = InsertRuleEdge(a1, v20, v21, (uint64_t)&v27, 0, 0, 0, 0, &v22);
              if ((result & 0x80000000) == 0)
              {
                uint64_t result = mosyntkbsgram_GetNextEmptyRule(*(void *)(v20 + 16), &v22, &v21);
                if ((result & 0x80000000) == 0) {
                  continue;
                }
              }
            }
            return result;
          }
          uint64_t result = ParseAndOptimizePosition(a1, v20, 0, 0);
          if ((result & 0x80000000) == 0) {
            *(_DWORD *)(*a6 + 40040) = 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t mosyntsentana_DisposeParseDesc(uint64_t a1, uint64_t *a2)
{
  if (!*a2) {
    return 0;
  }
  uint64_t result = mosyntknowl_DisposeBindingDesc(a1, (uint64_t *)(*a2 + 100128));
  if ((result & 0x80000000) == 0)
  {
    signed int v10 = 0;
    uint64_t v5 = *a2;
    if ((*(_DWORD *)(*a2 + 40040) & 0x80000000) == 0)
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)(v5 + 8 * v6 + 32))
        {
          for (uint64_t i = 0; i != 37; ++i)
          {
            __int16 v8 = *(void **)(*(void *)(*a2 + 8 * v6 + 32) + 8 * i);
            while (1)
            {
              signed int v10 = v8;
              if (!v8) {
                break;
              }
              __int16 v8 = (void *)*v8;
              uint64_t result = DisposeEdge(a1, (uint64_t *)&v10);
              if ((result & 0x80000000) != 0) {
                return result;
              }
            }
          }
          uint64_t result = mosyntpal_DEALLOCATE(a1, (uint64_t *)(*a2 + 8 * v6 + 32));
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t v5 = *a2;
        }
      }
      while (v6++ < *(int *)(v5 + 40040));
    }
    return mosyntpal_DEALLOCATE(a1, a2);
  }
  return result;
}

uint64_t DisposeEdge(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  if (*(unsigned char *)(*a2 + 58) && *(void *)(v4 + 64))
  {
    uint64_t result = mosyntdata_DisposeTermInfo(a1, (uint64_t *)(v4 + 64));
    if ((result & 0x80000000) != 0) {
      return result;
    }
    uint64_t v4 = *a2;
  }
  uint64_t v6 = *(void **)(v4 + 104);
  while (1)
  {
    uint64_t v7 = v6;
    if (!v6) {
      break;
    }
    uint64_t v6 = (void *)*v6;
    uint64_t result = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v7);
    if ((result & 0x80000000) != 0) {
      return result;
    }
  }
  return mosyntpal_DEALLOCATE(a1, a2);
}

uint64_t mosyntsentana_DoParse(uint64_t a1, uint64_t a2)
{
  int v2 = (int *)(a2 + 40040);
  int v3 = *(_DWORD *)(a2 + 40040);
  if (v3 < 1) {
    return 0;
  }
  uint64_t v6 = 0;
  uint64_t result = 0;
  uint64_t v8 = a2 + 80056;
  uint64_t v9 = a2 + 80060;
  do
  {
    uint64_t v10 = v6 + 1;
    *(_DWORD *)(v9 + 4 * v6) = *(_DWORD *)(v8 + 4 * v6) + 1000;
    if (*(void *)(a2 + 8 * v6 + 40))
    {
      uint64_t result = ParseAndOptimizePosition(a1, a2, (int)v6 + 1, v10 == v3);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      int v3 = *v2;
    }
    uint64_t v6 = v10;
  }
  while (v10 < v3);
  return result;
}

uint64_t ParseAndOptimizePosition(uint64_t a1, uint64_t a2, signed int a3, int a4)
{
  int v5 = a3;
  int v8 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  v73[3] = *MEMORY[0x263EF8340];
  uint64_t v11 = a2 + 100080;
  uint64_t v12 = a2 + 80056;
  unint64_t v59 = (void *)(a2 + 40048);
  uint64_t v13 = (uint64_t *)(a2 + 100064);
  *(void *)(a2 + 100096) = 0;
  *(_OWORD *)(a2 + 100064) = 0u;
  *(_OWORD *)(a2 + 100080) = 0u;
  do
  {
    uint64_t v14 = *(uint64_t **)(*(void *)(a2 + 8 * a3 + 32) + 8 * v10);
    if (v14)
    {
      do
      {
        uint64_t v15 = v14;
        v14[2] = 0;
        if (v9) {
          uint64_t v16 = v9 + 2;
        }
        else {
          uint64_t v16 = (void *)(a2 + 100064);
        }
        *uint64_t v16 = v14;
        *(void *)(a2 + 100072) = v14;
        *((unsigned char *)v14 + 56) = 1;
        ++v8;
        uint64_t v14 = (uint64_t *)*v14;
        uint64_t v9 = v15;
      }
      while (*v15);
      *(_DWORD *)uint64_t v11 = v8;
      uint64_t v9 = v15;
    }
    ++v10;
  }
  while (v10 != 37);
  v66[0] = 0;
  v66[1] = 0;
  char v65 = 0;
  int v64 = 0;
  uint64_t v63 = 0;
  if (*(int *)a2 >= 3)
  {
    uint64_t FirstRuleSameLast = mosyntbase_WInt3Ln(a1, "treating agenda in position ", 0, a3, (unsigned __int8 *)&byte_20D5A22AE, 0);
    if ((FirstRuleSameLast & 0x80000000) != 0) {
      return FirstRuleSameLast;
    }
  }
  int v58 = a4;
  uint64_t v18 = *v13;
  if (*v13)
  {
    int v19 = 0;
    memset(v73, 0, 24);
    uint64_t v71 = 0;
    v72[0] = 0;
    uint64_t v70 = 0;
    *(void *)((char *)v72 + 6) = 0;
    memset(v69, 0, sizeof(v69));
    memset(v68, 0, sizeof(v68));
    memset(v67, 0, sizeof(v67));
    int v61 = v5;
    do
    {
      uint64_t v20 = *(void *)(v18 + 16);
      uint64_t *v13 = v20;
      if (!v20) {
        *(void *)(v12 + 20016) = 0;
      }
      *(unsigned char *)(v18 + 56) = 0;
      *(void *)(v18 + 16) = 0;
      if (*(int *)a2 >= 3)
      {
        m2__cp__str("  treating agenda edge", &v70, 30);
        uint64_t FirstRuleSameLast = WriteEdge(a1, a2, (unsigned __int8 *)&v70, 30, (__int16 *)v18);
        if ((FirstRuleSameLast & 0x80000000) != 0) {
          return FirstRuleSameLast;
        }
      }
      uint64_t FirstRuleSameLast = mosyntkbsgram_GetFirstRuleSameLast(*(void *)(a2 + 16), *(__int16 *)(v18 + 28), v66, &v64, (char *)&v63 + 4, &v63);
      if ((FirstRuleSameLast & 0x80000000) != 0) {
        return FirstRuleSameLast;
      }
      while (v64 >= 1)
      {
        uint64_t FirstRuleSameLast = mosyntkbsgram_GetRuleFeatLists(v66, v69, v68, v67);
        if ((FirstRuleSameLast & 0x80000000) != 0) {
          return FirstRuleSameLast;
        }
        if (v19 < 0)
        {
          uint64_t FirstRuleSameLast = kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)FirstRuleSameLast);
          if ((FirstRuleSameLast & 0x80000000) != 0) {
            return FirstRuleSameLast;
          }
          int v19 = 1000;
        }
        else
        {
          --v19;
        }
        int v21 = *(_DWORD *)a2;
        if (v63)
        {
          if (v21 >= 3)
          {
            uint64_t FirstRuleSameLast = mosyntbase_WString(a1, "    looking for left edge ", 0);
            if ((FirstRuleSameLast & 0x80000000) != 0) {
              return FirstRuleSameLast;
            }
            uint64_t FirstRuleSameLast = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), HIDWORD(v63));
            if ((FirstRuleSameLast & 0x80000000) != 0) {
              return FirstRuleSameLast;
            }
            uint64_t FirstRuleSameLast = mosyntbase_WString(a1, " to complete ", 0);
            if ((FirstRuleSameLast & 0x80000000) != 0) {
              return FirstRuleSameLast;
            }
            uint64_t FirstRuleSameLast = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), v64);
            if ((FirstRuleSameLast & 0x80000000) != 0) {
              return FirstRuleSameLast;
            }
            uint64_t FirstRuleSameLast = mosyntbase_WLn(a1);
            if ((FirstRuleSameLast & 0x80000000) != 0) {
              return FirstRuleSameLast;
            }
          }
          int v22 = HIDWORD(v63);
          uint64_t FirstRuleSameLast = mosyntkbsgram_GetRuleFeatLists(v66, v69, v68, v67);
          if ((FirstRuleSameLast & 0x80000000) != 0) {
            return FirstRuleSameLast;
          }
          int v23 = v22 % 37;
          if (*(__int16 *)(v18 + 24) <= 0)
          {
            uint64_t v24 = v23;
          }
          else
          {
            uint64_t v24 = v23;
            uint64_t v25 = *(void *)(*(void *)(a2 + 8 * *(unsigned __int16 *)(v18 + 24) + 32) + 8 * v23);
            if (v25)
            {
              uint64_t v56 = v23;
              while (1)
              {
                if (HIDWORD(v63) == *(__int16 *)(v25 + 28))
                {
                  int v26 = *(_DWORD *)a2;
                  if (*(int *)a2 >= 3)
                  {
                    uint64_t FirstRuleSameLast = mosyntbase_WStringLn(a1, "      found left edge; trying unification", 0);
                    if ((FirstRuleSameLast & 0x80000000) != 0) {
                      return FirstRuleSameLast;
                    }
                    int v26 = *(_DWORD *)a2;
                  }
                  uint64_t FirstRuleSameLast = mosyntknowl_Unif2(a1, *(uint64_t **)(a2 + 8), v26, *(void *)(v11 + 48), (__int16 *)v68, (__int16 *)(v25 + 32), (__int16 *)v67, (__int16 *)(v18 + 32), (__int16 *)v69, (__int16 *)v73, &v65);
                  if ((FirstRuleSameLast & 0x80000000) != 0) {
                    return FirstRuleSameLast;
                  }
                  if (v65)
                  {
                    uint64_t FirstRuleSameLast = InsertRuleEdge(a1, a2, v64, (uint64_t)v73, *(__int16 *)(v25 + 24), v61, v25, v18, v66);
                    if ((FirstRuleSameLast & 0x80000000) != 0) {
                      return FirstRuleSameLast;
                    }
                  }
                }
                uint64_t v25 = *(void *)v25;
                if (!v25)
                {
                  uint64_t v24 = v56;
                  break;
                }
              }
            }
          }
          for (uint64_t i = *(void *)(*(void *)(a2 + 32) + 8 * v24); i; uint64_t i = *(void *)i)
          {
            if (HIDWORD(v63) == *(__int16 *)(i + 28))
            {
              int v28 = *(_DWORD *)a2;
              if (*(int *)a2 >= 3)
              {
                uint64_t FirstRuleSameLast = mosyntbase_WStringLn(a1, "      found left edge; trying unification", 0);
                if ((FirstRuleSameLast & 0x80000000) != 0) {
                  return FirstRuleSameLast;
                }
                int v28 = *(_DWORD *)a2;
              }
              uint64_t FirstRuleSameLast = mosyntknowl_Unif2(a1, *(uint64_t **)(a2 + 8), v28, *(void *)(v11 + 48), (__int16 *)v68, (__int16 *)(i + 32), (__int16 *)v67, (__int16 *)(v18 + 32), (__int16 *)v69, (__int16 *)v73, &v65);
              if ((FirstRuleSameLast & 0x80000000) != 0) {
                return FirstRuleSameLast;
              }
              if (v65)
              {
                uint64_t FirstRuleSameLast = InsertRuleEdge(a1, a2, v64, (uint64_t)v73, *(__int16 *)(v18 + 24), v61, i, v18, v66);
                if ((FirstRuleSameLast & 0x80000000) != 0) {
                  return FirstRuleSameLast;
                }
              }
            }
          }
        }
        else
        {
          if (v21 >= 3)
          {
            uint64_t FirstRuleSameLast = mosyntbase_WString(a1, "    trying to directly complete ", 0);
            if ((FirstRuleSameLast & 0x80000000) != 0) {
              return FirstRuleSameLast;
            }
            uint64_t FirstRuleSameLast = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), v64);
            if ((FirstRuleSameLast & 0x80000000) != 0) {
              return FirstRuleSameLast;
            }
            uint64_t FirstRuleSameLast = mosyntbase_WLn(a1);
            if ((FirstRuleSameLast & 0x80000000) != 0) {
              return FirstRuleSameLast;
            }
            int v21 = *(_DWORD *)a2;
          }
          uint64_t FirstRuleSameLast = mosyntknowl_Unif (a1, *(uint64_t **)(a2 + 8), v21, *(void *)(v11 + 48), (unsigned __int16 *)v68, (unsigned __int16 *)(v18 + 32), (__int16 *)v69, (__int16 *)v73, &v65);
          if ((FirstRuleSameLast & 0x80000000) != 0) {
            return FirstRuleSameLast;
          }
          if (v65)
          {
            uint64_t FirstRuleSameLast = InsertRuleEdge(a1, a2, v64, (uint64_t)v73, *(__int16 *)(v18 + 24), v61, v18, 0, v66);
            if ((FirstRuleSameLast & 0x80000000) != 0) {
              return FirstRuleSameLast;
            }
          }
        }
        uint64_t FirstRuleSameLast = mosyntkbsgram_GetNextRuleSameLast(*(void *)(a2 + 16), *(__int16 *)(v18 + 28), v66, &v64, (_DWORD *)&v63 + 1, &v63);
        if ((FirstRuleSameLast & 0x80000000) != 0) {
          return FirstRuleSameLast;
        }
      }
      if (mosyntkbsgram_HasEmptyRules(*(void *)(a2 + 16)))
      {
        uint64_t FirstRuleSameLast = mosyntkbsgram_GetFirstRuleSameFirst(*(void *)(a2 + 16), *(__int16 *)(v18 + 28), v66, &v64, (char *)&v63 + 4, &v63);
        if ((FirstRuleSameLast & 0x80000000) != 0) {
          return FirstRuleSameLast;
        }
        while (v64 >= 1)
        {
          uint64_t FirstRuleSameLast = mosyntkbsgram_GetRuleFeatLists(v66, v69, v68, v67);
          if ((FirstRuleSameLast & 0x80000000) != 0) {
            return FirstRuleSameLast;
          }
          int v29 = v63;
          if ((int)v63 >= 1)
          {
            if (*(int *)a2 >= 3)
            {
              uint64_t FirstRuleSameLast = mosyntbase_WString(a1, "    looking for empty right edge ", 0);
              if ((FirstRuleSameLast & 0x80000000) != 0) {
                return FirstRuleSameLast;
              }
              uint64_t FirstRuleSameLast = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), v63);
              if ((FirstRuleSameLast & 0x80000000) != 0) {
                return FirstRuleSameLast;
              }
              uint64_t FirstRuleSameLast = mosyntbase_WString(a1, " to complete ", 0);
              if ((FirstRuleSameLast & 0x80000000) != 0) {
                return FirstRuleSameLast;
              }
              uint64_t FirstRuleSameLast = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), v64);
              if ((FirstRuleSameLast & 0x80000000) != 0) {
                return FirstRuleSameLast;
              }
              uint64_t FirstRuleSameLast = mosyntbase_WLn(a1);
              if ((FirstRuleSameLast & 0x80000000) != 0) {
                return FirstRuleSameLast;
              }
              int v29 = v63;
            }
            for (uint64_t j = *(void *)(*(void *)(a2 + 32) + 8 * (v29 % 37)); j; uint64_t j = *(void *)j)
            {
              if (v19 < 0)
              {
                uint64_t FirstRuleSameLast = kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)FirstRuleSameLast);
                if ((FirstRuleSameLast & 0x80000000) != 0) {
                  return FirstRuleSameLast;
                }
                int v19 = 1000;
              }
              else
              {
                --v19;
              }
              if (v63 == *(__int16 *)(j + 28))
              {
                int v31 = *(_DWORD *)a2;
                if (*(int *)a2 >= 3)
                {
                  uint64_t FirstRuleSameLast = mosyntbase_WStringLn(a1, "      found empty right edge; trying unification ", 0);
                  if ((FirstRuleSameLast & 0x80000000) != 0) {
                    return FirstRuleSameLast;
                  }
                  int v31 = *(_DWORD *)a2;
                }
                uint64_t FirstRuleSameLast = mosyntknowl_Unif2(a1, *(uint64_t **)(a2 + 8), v31, *(void *)(v11 + 48), (__int16 *)v68, (__int16 *)(v18 + 32), (__int16 *)v67, (__int16 *)(j + 32), (__int16 *)v69, (__int16 *)v73, &v65);
                if ((FirstRuleSameLast & 0x80000000) != 0) {
                  return FirstRuleSameLast;
                }
                if (v65)
                {
                  uint64_t FirstRuleSameLast = InsertRuleEdge(a1, a2, v64, (uint64_t)v73, *(__int16 *)(v18 + 24), v61, v18, j, v66);
                  if ((FirstRuleSameLast & 0x80000000) != 0) {
                    return FirstRuleSameLast;
                  }
                }
              }
            }
          }
          uint64_t FirstRuleSameLast = mosyntkbsgram_GetNextRuleSameFirst(*(void *)(a2 + 16), *(__int16 *)(v18 + 28), v66, &v64, (_DWORD *)&v63 + 1, &v63);
          if ((FirstRuleSameLast & 0x80000000) != 0) {
            return FirstRuleSameLast;
          }
        }
      }
      uint64_t v18 = *v13;
      int v5 = v61;
    }
    while (*v13);
  }
  uint64_t v70 = 0;
  uint64_t v71 = 0;
  LOBYTE(v69[0]) = 0;
  LODWORD(v73[0]) = 0;
  uint64_t RuleVisAndCost = mosyntkbsgram_NilIter(&v70);
  if ((RuleVisAndCost & 0x80000000) == 0)
  {
    if (v5)
    {
      if (v5 >= 1)
      {
        uint64_t v33 = 0;
        int v34 = 0;
        uint64_t v35 = 0;
        unsigned int v36 = v5;
        int v37 = 0;
        uint64_t v57 = v36;
        int v38 = (void *)(a2 + 8 * v36 + 32);
        int v60 = 0;
        uint64_t v62 = v38;
        while (1)
        {
          int v39 = *(uint64_t **)(*v38 + 8 * v33);
          if (v39) {
            break;
          }
LABEL_122:
          ++v33;
          int v38 = v62;
          if (v33 == 37)
          {
            if (v35 || (uint64_t v35 = v60, v37 = v34, v60))
            {
              *(void *)(a2 + 8 * v57 + 40048) = v35;
              *(_DWORD *)(a2 + 4 * v57 + 80056) = v37;
            }
            if (!v58 && (RuleVisAndCost & 0x80000000) == 0 && mosyntkbsgram_HasSimpleFollowRel(*(void *)(a2 + 16)))
            {
              FixEdgeAndSubEdges(*(void *)(a2 + 8 * v57 + 40048));
              for (uint64_t k = 0; k != 37; ++k)
              {
                for (uint64_t m = *(void *)(*v62 + 8 * k); m; uint64_t m = *(void *)m)
                {
                  if (!*(unsigned char *)(m + 57))
                  {
                    uint64_t v49 = *(void *)(*v62 + 296);
                    if (v49)
                    {
                      while (!mosyntkbsgram_IsFollowerCons(*(void *)(a2 + 16), *(__int16 *)(v49 + 28), *(__int16 *)(m + 28)))
                      {
                        uint64_t v49 = *(void *)(v49 + 8);
                        if (!v49) {
                          goto LABEL_132;
                        }
                      }
                      FixEdgeAndSubEdges(m);
                    }
                  }
LABEL_132:
                  ;
                }
              }
              uint64_t v50 = 0;
              uint64_t RuleVisAndCost = 0;
              uint64_t v70 = 0;
              do
              {
                uint64_t v51 = *v62;
                uint64_t v52 = *(void *)(*v62 + 8 * v50);
                uint64_t v70 = v52;
                uint64_t v53 = 0;
                if (v52)
                {
                  do
                  {
                    uint64_t v54 = *(void *)v52;
                    if (*(unsigned char *)(v52 + 57))
                    {
                      *(void *)uint64_t v52 = v53;
                      uint64_t v53 = v70;
                    }
                    else
                    {
                      ++*(_DWORD *)(v11 + 20);
                      ++*(_DWORD *)(v11 + 44);
                      if (*(unsigned char *)(v52 + 58)) {
                        --*(_DWORD *)(v11 + 24);
                      }
                      else {
                        --*(_DWORD *)(v11 + 28);
                      }
                      uint64_t RuleVisAndCost = DisposeEdge(a1, &v70);
                      if ((RuleVisAndCost & 0x80000000) != 0) {
                        return RuleVisAndCost;
                      }
                    }
                    uint64_t v70 = v54;
                    uint64_t v52 = v54;
                  }
                  while (v54);
                  uint64_t v51 = *v62;
                }
                *(void *)(v51 + 8 * v50++) = v53;
              }
              while (v50 != 37);
            }
            return RuleVisAndCost;
          }
        }
        while (1)
        {
          uint64_t RuleVisAndCost = mosyntkbsgram_GetRuleVisAndCost((_DWORD *)v39 + 20, v69, v73);
          if ((RuleVisAndCost & 0x80000000) != 0) {
            break;
          }
          if (mosyntkbsgram_IsNilIter(v39 + 10) || !LOBYTE(v69[0]))
          {
            uint64_t v40 = *((__int16 *)v39 + 12);
            int v41 = *(_DWORD *)(a2 + 4 * v40 + 80056) + *((_DWORD *)v39 + 24) + 1000;
            if (*((_WORD *)v39 + 12) && !*(void *)(a2 + 8 * v40 + 40048))
            {
              uint64_t v44 = v60;
              if (v60) {
                BOOL v45 = v41 < v34;
              }
              else {
                BOOL v45 = 1;
              }
              if (v45)
              {
                int v34 = v41;
                uint64_t v44 = v39;
              }
              int v60 = v44;
            }
            else
            {
              if (v35) {
                BOOL v42 = v41 < v37;
              }
              else {
                BOOL v42 = 1;
              }
              if (v42)
              {
                int v37 = v41;
                uint64_t v35 = v39;
              }
            }
          }
          int v39 = (uint64_t *)*v39;
          if (!v39) {
            goto LABEL_122;
          }
        }
      }
    }
    else
    {
      void *v59 = 0;
      *(_DWORD *)uint64_t v12 = 0;
    }
  }
  return RuleVisAndCost;
}

void mosyntsentana_GetOptimalTree(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  uint64_t v6 = a2 + 40040;
  uint64_t v7 = *(unsigned int *)(a2 + 40040);
  int v19 = 0;
  __n128 v20 = 0uLL;
  uint64_t v21 = 0;
  int started = mosyntkbsgram_StartCons(*(_DWORD **)(a2 + 16));
  __int16 v9 = started;
  uint64_t v10 = *(void *)(*(void *)(a2 + 8 * (int)v7 + 32) + 8 * (started % 37));
  if (!v10) {
    goto LABEL_13;
  }
  uint64_t v11 = 0;
  do
  {
    if (started == *(__int16 *)(v10 + 28)
      && !*(_WORD *)(v10 + 24)
      && (!v11 || *(_DWORD *)(v10 + 96) < *(_DWORD *)(v11 + 96)))
    {
      uint64_t v11 = v10;
    }
    uint64_t v10 = *(void *)v10;
  }
  while (v10);
  if (v11)
  {
    if ((mosyntdata_StartPhonList(a1, a3, &v19) & 0x80000000) == 0) {
      AppendTree(a1, v11, a3, (uint64_t *)&v19);
    }
  }
  else
  {
LABEL_13:
    if (*(int *)a2 < 1
      || (mosyntbase_WStringLn(a1, "no syntactic analysis found; creating artificial tree", 0) & 0x80000000) == 0)
    {
      if ((int)v7 >= 1)
      {
        uint64_t v12 = (int)v7;
        int v13 = v7;
        do
        {
          uint64_t v14 = *(void *)(a2 + 8 * v12 + 40048);
          if (v14)
          {
            uint64_t v12 = *(__int16 *)(v14 + 24);
            if ((int)v12 + 1 < v13) {
              bzero((void *)(a2 + 40056 + 8 * v12), 8 * (v13 - v12 - 2) + 8);
            }
          }
          else
          {
            *(void *)(a2 + 8 * v13 + 40048) = 0;
            uint64_t v12 = (v13 - 1);
          }
          int v13 = v12;
        }
        while ((int)v12 > 0);
      }
      if ((mosyntdata_StartPhonList(a1, a3, &v19) & 0x80000000) == 0)
      {
        v20.n128_u16[0] = 0;
        mosyntdata_AddNode(a1, a3, &v19, 1, v9, &v20);
        if ((v15 & 0x80000000) == 0)
        {
          uint64_t v16 = v19;
          void v19[6] = *(unsigned int *)(a2 + 4 * (int)v7 + 80056);
          *((_DWORD *)v16 + 14) = v7;
          int v19 = 0;
          if ((int)v7 >= 1)
          {
            uint64_t v17 = (uint64_t *)(v6 + 16);
            do
            {
              if (*v17)
              {
                AppendTree(a1, *v17, (void *)(*a3 + 8), (uint64_t *)&v19);
                if (v18 < 0) {
                  break;
                }
              }
              ++v17;
              --v7;
            }
            while (v7);
          }
        }
      }
    }
  }
}

uint64_t mosyntsentana_DisplayTree(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result = mosyntdata_WriteTree(a1, *(uint64_t **)(a2 + 8), 2, a3);
  if ((result & 0x80000000) == 0)
  {
    return mosyntbase_WLn(a1);
  }
  return result;
}

uint64_t mosyntsentana_DisposeTree(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return mosyntdata_DisposeSyntTree(a1, a3);
}

uint64_t InsertRuleEdge(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, int a6, uint64_t a7, uint64_t a8, _DWORD *a9)
{
  v49[2] = *MEMORY[0x263EF8340];
  uint64_t v9 = a2 + 100064;
  if (*(_DWORD *)(a2 + 100084) > *(_DWORD *)(a2 + 24)) {
    return 0;
  }
  int v44 = 0;
  v48[1] = 0;
  v49[0] = 0;
  v48[0] = 0;
  *(void *)((char *)v49 + 6) = 0;
  char v43 = 0;
  int v42 = 0;
  memset(v46, 0, sizeof(v46));
  __int16 v47 = 0;
  uint64_t RuleVisAndCost = mosyntkbsgram_GetRuleVisAndCost(a9, &v43, &v44);
  if ((RuleVisAndCost & 0x80000000) != 0) {
    return RuleVisAndCost;
  }
  if (a7)
  {
    v44 += *(_DWORD *)(a7 + 96);
    *(unsigned char *)(a7 + 112) = 1;
  }
  int v41 = (__int16 *)a7;
  if (a8)
  {
    v44 += *(_DWORD *)(a8 + 96);
    *(unsigned char *)(a8 + 112) = 1;
  }
  uint64_t v40 = (__int16 *)a8;
  uint64_t v19 = a2 + 8 * a6;
  uint64_t v21 = *(void *)(v19 + 32);
  __n128 v20 = (uint64_t *)(v19 + 32);
  int v39 = a3 % 37;
  for (uint64_t i = *(void *)(v21 + 8 * (a3 % 37)); ; uint64_t i = *(void *)i)
  {
    uint64_t v45 = i;
    if (!i) {
      goto LABEL_20;
    }
    if (*(__int16 *)(i + 28) == a3 && *(__int16 *)(i + 24) == a5)
    {
      BOOL v23 = mosyntknowl_DiffFeat(a1, (unsigned __int16 *)(i + 32), (unsigned __int16 *)a4);
      uint64_t i = v45;
      if (!v23) {
        break;
      }
    }
  }
  if (v45)
  {
    int v24 = v44;
    if (v44 >= *(_DWORD *)(v45 + 96)) {
      return RuleVisAndCost;
    }
    if (*(unsigned char *)(v45 + 58) && *(int *)a2 >= 1)
    {
      int v42 = 0;
      uint64_t v25 = mosyntkbsymtab_AppConsFeatToString(a1, *(uint64_t **)(a2 + 8), *(__int16 *)(v45 + 28), (__int16 *)(v45 + 32), (uint64_t)v46, 50, &v42);
      if ((v25 & 0x80000000) == 0) {
        return mosyntbase_WString3Ln(a1, "***** illegal attempt to replace terminal constituent '", 0, (unsigned __int8 *)v46, 50, "' by rule-generated identical constituent", 0);
      }
      return v25;
    }
    ++*(_DWORD *)(v9 + 32);
    ++*(_DWORD *)(v9 + 56);
    *(_OWORD *)(i + 80) = *(_OWORD *)a9;
    *(_DWORD *)(i + 96) = v24;
    *(void *)(i + 64) = v41;
    *(void *)(i + 72) = v40;
    if (!*(unsigned char *)(i + 56))
    {
      *(void *)(i + 16) = 0;
      uint64_t v37 = *(void *)(v9 + 8);
      if (v37) {
        int v38 = (uint64_t *)(v37 + 16);
      }
      else {
        int v38 = (uint64_t *)v9;
      }
      uint64_t *v38 = i;
      *(void *)(v9 + 8) = i;
      *(unsigned char *)(i + 56) = 1;
    }
    if (*(int *)a2 >= 3)
    {
      m2__cp__str("noted reparsing of edge ", v48, 30);
      uint64_t v34 = a1;
      uint64_t v35 = a2;
      uint64_t v33 = (__int16 *)i;
      goto LABEL_31;
    }
  }
  else
  {
LABEL_20:
    ++*(_DWORD *)(v9 + 20);
    ++*(_DWORD *)(v9 + 44);
    if (v41)
    {
      if (v40)
      {
        int v26 = v40[12];
        if (v41[12] < v26 && v26 < a6)
        {
          ++*(_DWORD *)(v9 + 24);
          ++*(_DWORD *)(v9 + 48);
        }
      }
    }
    uint64_t RuleVisAndCost = mosyntpal_ALLOCATE(a1, &v45, 0x78u);
    if ((RuleVisAndCost & 0x80000000) == 0)
    {
      uint64_t v27 = v45;
      *(_WORD *)(v45 + 24) = a5;
      *(_WORD *)(v27 + 26) = a6;
      *(_WORD *)(v27 + 28) = a3;
      uint64_t v28 = *(void *)(a4 + 16);
      *(_OWORD *)(v27 + 32) = *(_OWORD *)a4;
      *(void *)(v27 + 48) = v28;
      *(unsigned char *)(v27 + 58) = 0;
      *(void *)(v27 + 64) = v41;
      *(void *)(v27 + 72) = v40;
      *(_OWORD *)(v27 + 80) = *(_OWORD *)a9;
      *(_DWORD *)(v27 + 96) = v44;
      *(void *)(v27 + 104) = 0;
      *(unsigned char *)(v27 + 112) = 0;
      *(unsigned char *)(v27 + 57) = a6 == 0;
      uint64_t v29 = *v20;
      *(void *)uint64_t v27 = *(void *)(*v20 + 8 * v39);
      *(void *)(v29 + 8 * v39) = v45;
      uint64_t v30 = v45;
      *(void *)(v45 + 16) = 0;
      uint64_t v31 = *(void *)(v9 + 8);
      uint64_t v32 = (uint64_t *)(v31 ? v31 + 16 : v9);
      *uint64_t v32 = v30;
      *(void *)(v9 + 8) = v30;
      *(unsigned char *)(v30 + 56) = 1;
      if (*(int *)a2 >= 3)
      {
        m2__cp__str("inserted edge", v48, 30);
        uint64_t v33 = (__int16 *)v45;
        uint64_t v34 = a1;
        uint64_t v35 = a2;
LABEL_31:
        uint64_t v25 = WriteEdge(v34, v35, (unsigned __int8 *)v48, 30, v33);
        if ((v25 & 0x80000000) == 0)
        {
          m2__cp__str("subedge1", v48, 30);
          uint64_t v25 = WriteEdge(a1, a2, (unsigned __int8 *)v48, 30, v41);
          if ((v25 & 0x80000000) == 0)
          {
            m2__cp__str("subedge2", v48, 30);
            return WriteEdge(a1, a2, (unsigned __int8 *)v48, 30, v40);
          }
        }
        return v25;
      }
    }
  }
  return RuleVisAndCost;
}

uint64_t FixEdgeAndSubEdges(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    do
    {
      if (*(unsigned char *)(v1 + 57)) {
        break;
      }
      *(unsigned char *)(v1 + 57) = 1;
      if (*(unsigned char *)(v1 + 58)) {
        break;
      }
      uint64_t result = FixEdgeAndSubEdges(*(void *)(v1 + 64));
      uint64_t v1 = *(void *)(v1 + 72);
    }
    while (v1);
  }
  return result;
}

void AppendTree(uint64_t a1, uint64_t a2, void *a3, uint64_t *a4)
{
  if (a2)
  {
    if (!*(unsigned char *)(a2 + 58))
    {
      char v19 = 0;
      int v18 = 0;
      if ((mosyntkbsgram_GetRuleVisAndCost((_DWORD *)(a2 + 80), &v19, &v18) & 0x80000000) != 0) {
        return;
      }
      if (mosyntkbsgram_IsNilIter((void *)(a2 + 80)) || !v19)
      {
        AppendNode(a1, (__n128 *)a2, a3, (void **)a4);
        if (v15 < 0) {
          return;
        }
        uint64_t v16 = (void *)*a4;
        *((unsigned char *)v16 + 60) = 0;
        v16[8] = 0;
        uint64_t v20 = 0;
        uint64_t v17 = v16 + 1;
        if ((AppendTree(a1, *(void *)(a2 + 64), v16 + 1, &v20) & 0x80000000) != 0) {
          return;
        }
        uint64_t v11 = *(void *)(a2 + 72);
        uint64_t v14 = &v20;
        uint64_t v12 = a1;
        int v13 = v17;
      }
      else
      {
        if ((AppendTree(a1, *(void *)(a2 + 64), a3, a4) & 0x80000000) != 0) {
          return;
        }
        uint64_t v11 = *(void *)(a2 + 72);
        uint64_t v12 = a1;
        int v13 = a3;
        uint64_t v14 = a4;
      }
      AppendTree(v12, v11, v13, v14);
      return;
    }
    AppendNode(a1, (__n128 *)a2, a3, (void **)a4);
    if ((v8 & 0x80000000) == 0)
    {
      uint64_t v9 = (void *)*a4;
      *((unsigned char *)v9 + 60) = 1;
      mosyntdata_CopyTermInfo(a1, *(uint64_t **)(a2 + 64), v9 + 8);
      if ((v10 & 0x80000000) == 0) {
        v9[1] = 0;
      }
    }
  }
}

void AppendNode(uint64_t a1, __n128 *a2, void *a3, void **a4)
{
  mosyntdata_AddNode(a1, a3, a4, 1, a2[1].n128_i16[6], a2 + 2);
  if ((v6 & 0x80000000) == 0)
  {
    uint64_t v7 = *a4;
    int v8 = a2[1].n128_i16[4];
    v7[12] = a2[6].n128_u32[0];
    v7[13] = v8;
    v7[14] = a2[1].n128_i16[5];
  }
}

uint64_t com_mosynt_GetCfgParamVal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char *a5, char **a6)
{
  *a6 = a5;
  __int16 __c_1 = -1;
  unsigned __int8 __c = 0;
  uint64_t v11 = 0;
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t, char ***, __int16 *, unsigned __int8 *))(a3 + 96))(a1, a2, "fecfg", a4, &v11, &__c_1, &__c);
  if ((v7 & 0x80000000) == 0 && __c_1)
  {
    int v8 = *v11;
    uint64_t v9 = strchr(*v11, __c);
    if (v9)
    {
      *uint64_t v9 = 0;
      int v8 = *v11;
    }
    *a6 = v8;
  }
  return v7;
}

uint64_t com_mosynt_GetBacktransPOS(uint64_t a1, uint64_t a2, uint64_t a3, char *__s, _WORD *a5)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  strcpy(__sa, "backtrans_");
  if (strlen(__s) < 0x81) {
    __strcat_chk();
  }
  else {
    __strncat_chk();
  }
  int v10 = strchr(__sa, 40);
  if (v10) {
    *int v10 = 0;
  }
  uint64_t v12 = 0;
  uint64_t result = com_mosynt_GetCfgParamVal(a1, a2, a3, (uint64_t)__sa, __s, &v12);
  if ((result & 0x80000000) == 0) {
    *a5 = *v12;
  }
  return result;
}

uint64_t com_mosynt_GetBacktrans2POS(uint64_t a1, uint64_t a2, uint64_t a3, char *__s, unsigned int a5, char *a6)
{
  uint64_t v7 = __s;
  uint64_t v24 = *MEMORY[0x263EF8340];
  unsigned __int16 v11 = strlen(__s);
  *a6 = 0;
  uint64_t CfgParamVal = 0;
  uint64_t v13 = v11;
  if (v11)
  {
    uint64_t v22 = 0;
    do
    {
      int v15 = *v7++;
      char v14 = v15;
      if (v15 != 92)
      {
        strcpy(__sa, "backtrans2_");
        unsigned __int16 v16 = strlen(__sa);
        __sa[v16] = v14;
        __sa[(unsigned __int16)(v16 + 1)] = 0;
        uint64_t CfgParamVal = com_mosynt_GetCfgParamVal(a1, a2, a3, (uint64_t)__sa, a6, &v22);
        if ((CfgParamVal & 0x80000000) != 0) {
          return CfgParamVal;
        }
        uint64_t v17 = v22;
        int v18 = (unsigned __int16)strlen(v22);
        if (v18)
        {
          unsigned __int16 v19 = strlen(a6);
          if (v22 != a6 && v18 + v19 + 1 < a5)
          {
            if (v19) {
              *(_WORD *)&a6[strlen(a6)] = 92;
            }
            strcat(a6, v17);
          }
        }
      }
      --v13;
    }
    while (v13);
  }
  return CfgParamVal;
}

uint64_t com_mosynt_UseMosynt(uint64_t a1, uint64_t a2, uint64_t a3, BOOL *a4)
{
  __s1 = 0;
  uint64_t CfgParamVal = com_mosynt_GetCfgParamVal(a1, a2, a3, (uint64_t)"mosynt_usemosynt", "NO", &__s1);
  if ((CfgParamVal & 0x80000000) != 0)
  {
    BOOL v7 = 0;
  }
  else
  {
    int v6 = __s1;
    BOOL v7 = !strcmp(__s1, "YES") || strcmp(v6, "yes") == 0;
  }
  *a4 = v7;
  return CfgParamVal;
}

uint64_t mosyntbase_WInt3Ln(uint64_t a1, unsigned __int8 *a2, int a3, unsigned int a4, unsigned __int8 *a5, int a6)
{
  uint64_t v12 = a2;
  int v11 = a3;
  int v10 = a5;
  int v9 = a6;
  m2__fix__carray__len(&v12, &v11);
  m2__fix__carray__len(&v10, &v9);
  uint64_t result = mosyntpal_WriteString(a1, v12, v11);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = mosyntbase_WInt(a1, a4, 0);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = mosyntpal_WriteString(a1, v10, v9);
      if ((result & 0x80000000) == 0) {
        return mosyntpal_WriteLn(a1);
      }
    }
  }
  return result;
}

uint64_t mosyntbase_WString(uint64_t a1, unsigned __int8 *a2, int a3)
{
  int v6 = a2;
  int v5 = a3;
  m2__fix__carray__len(&v6, &v5);
  return mosyntpal_WriteString(a1, v6, v5);
}

uint64_t mosyntbase_WInt(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t result = mosyntpal_IntToString(a2, a3, v5, 100);
  if ((result & 0x80000000) == 0) {
    return mosyntpal_WriteString(a1, (unsigned __int8 *)v5, 100);
  }
  return result;
}

uint64_t mosyntbase_WStringLn(uint64_t a1, unsigned __int8 *a2, int a3)
{
  int v6 = a2;
  int v5 = a3;
  m2__fix__carray__len(&v6, &v5);
  uint64_t result = mosyntpal_WriteString(a1, v6, v5);
  if ((result & 0x80000000) == 0) {
    return mosyntpal_WriteLn(a1);
  }
  return result;
}

uint64_t mosyntbase_WString3Ln(uint64_t a1, unsigned __int8 *a2, int a3, unsigned __int8 *a4, int a5, unsigned __int8 *a6, int a7)
{
  char v14 = a2;
  int v13 = a3;
  uint64_t v12 = a4;
  int v11 = a5;
  int v10 = a6;
  int v9 = a7;
  m2__fix__carray__len(&v14, &v13);
  m2__fix__carray__len(&v12, &v11);
  m2__fix__carray__len(&v10, &v9);
  uint64_t result = mosyntpal_WriteString(a1, v14, v13);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = mosyntpal_WriteString(a1, v12, v11);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = mosyntpal_WriteString(a1, v10, v9);
      if ((result & 0x80000000) == 0) {
        return mosyntpal_WriteLn(a1);
      }
    }
  }
  return result;
}

uint64_t mosyntbase_WriteDevelMessage(uint64_t a1, unsigned __int8 *a2, int a3, unsigned __int8 *a4, int a5, unsigned __int8 *a6, int a7, unsigned __int8 *a8, unsigned int a9, unsigned int a10, unsigned int a11, unsigned int a12)
{
  unsigned int v13 = a10;
  unsigned int v14 = a11;
  unsigned int v15 = a12;
  uint64_t v24 = a2;
  int v23 = a3;
  uint64_t v22 = a4;
  int v21 = a5;
  uint64_t v20 = a6;
  int v19 = a7;
  int v18 = a8;
  m2__fix__carray__len(&v24, &v23);
  m2__fix__carray__len(&v22, &v21);
  m2__fix__carray__len(&v20, &v19);
  m2__fix__carray__len(&v18, (int *)&a9);
  *((void *)&v17 + 1) = __PAIR64__(v15, v14);
  *(void *)&long long v17 = __PAIR64__(v13, a9);
  uint64_t result = mosyntbase_WriteMessage(a1, v24, v23, v22, v21, v20, v19, v18, v17);
  if ((result & 0x80000000) == 0) {
    return kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)result);
  }
  return result;
}

uint64_t mosyntbase_WriteMessage(uint64_t a1, unsigned __int8 *a2, int a3, unsigned __int8 *a4, int a5, unsigned __int8 *a6, int a7, unsigned __int8 *a8, long long a9)
{
  uint64_t v10 = *(void *)((char *)&a9 + 4);
  unsigned int v11 = HIDWORD(a9);
  uint64_t v21 = *MEMORY[0x263EF8340];
  int v19 = a2;
  int v18 = a3;
  long long v17 = a4;
  int v16 = a5;
  unsigned int v15 = a6;
  int v14 = a7;
  unsigned int v13 = a8;
  memset(v20, 0, 512);
  m2__fix__carray__len(&v19, &v18);
  m2__fix__carray__len(&v17, &v16);
  m2__fix__carray__len(&v15, &v14);
  m2__fix__carray__len(&v13, (int *)&a9);
  uint64_t result = mosyntbase_ComposeMessage(v19, v18, v17, v16, v15, v14, v13, a9, v10, HIDWORD(v10), v11, v20, 1000);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = mosyntpal_WriteString(a1, (unsigned __int8 *)v20, 1000);
    if ((result & 0x80000000) == 0) {
      return kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)result);
    }
  }
  return result;
}

uint64_t mosyntbase_ComposeMessage(unsigned __int8 *a1, int a2, unsigned __int8 *a3, int a4, unsigned __int8 *a5, int a6, unsigned __int8 *a7, int a8, unsigned int a9, unsigned int a10, unsigned int a11, unsigned char *a12, int a13)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  uint64_t v33 = a1;
  int v32 = a2;
  uint64_t v31 = a3;
  int v30 = a4;
  uint64_t v29 = a5;
  int v28 = a6;
  uint64_t v27 = a7;
  int v26 = a8;
  v36[0] = 0;
  v36[1] = 0;
  int v37 = 0;
  m2__fix__carray__len(&v33, &v32);
  m2__fix__carray__len(&v31, &v30);
  m2__fix__carray__len(&v29, &v28);
  m2__fix__carray__len(&v27, &v26);
  int v25 = 0;
  *a12 = 0;
  int v13 = v32;
  if (v32 >= 1)
  {
    uint64_t v14 = 0;
    int v15 = 1;
    int v16 = 1;
    do
    {
      int v17 = v13 - 1;
      uint64_t result = v33[v14];
      if (result == 37)
      {
        if ((int)v14 < v17)
        {
          int v19 = v33[v14 + 1];
          if (v19 == 100 || v19 == 105)
          {
            switch(v15)
            {
              case 3:
                unsigned int v23 = a11;
                goto LABEL_25;
              case 2:
                unsigned int v23 = a10;
                goto LABEL_25;
              case 1:
                unsigned int v23 = a9;
LABEL_25:
                uint64_t result = mosyntpal_IntToString(v23, 0, v36, 20);
                if ((result & 0x80000000) != 0) {
                  return result;
                }
                break;
              default:
                mosyntbase_CCopy("%d", 0, (uint64_t)v36, 20, &v24);
                break;
            }
            mosyntbase_App((uint64_t)a12, a13, &v25, (uint64_t)v36, 20, &v24);
            ++v15;
LABEL_33:
            uint64_t v22 = 2;
            goto LABEL_34;
          }
          if (v19 == 115)
          {
            switch(v16)
            {
              case 3:
                uint64_t v20 = v27;
                int v21 = v26;
                break;
              case 2:
                uint64_t v20 = v29;
                int v21 = v28;
                break;
              case 1:
                uint64_t v20 = v31;
                int v21 = v30;
                break;
              default:
                uint64_t v35 = "%s";
                int v34 = 0;
                m2__fix__carray__len((unsigned __int8 **)&v35, &v34);
                uint64_t v20 = (unsigned __int8 *)v35;
                int v21 = v34;
                break;
            }
            mosyntbase_App((uint64_t)a12, a13, &v25, (uint64_t)v20, v21, &v24);
            ++v16;
            goto LABEL_33;
          }
        }
      }
      else if (result == 92)
      {
        if ((int)v14 < v17 && v33[v14 + 1] == 110)
        {
          LOWORD(v36[0]) = mosyntpal_EOL();
          mosyntbase_App((uint64_t)a12, a13, &v25, (uint64_t)v36, 20, &v24);
          goto LABEL_33;
        }
      }
      else if (!v33[v14])
      {
        return result;
      }
      LOWORD(v36[0]) = result;
      mosyntbase_App((uint64_t)a12, a13, &v25, (uint64_t)v36, 20, &v24);
      uint64_t v22 = 1;
LABEL_34:
      v14 += v22;
      int v13 = v32;
    }
    while ((int)v14 < v32);
  }
  return 0;
}

uint64_t mosyntbase_Length(uint64_t a1, int a2)
{
  if (a2 < 1) {
    return 0;
  }
  uint64_t result = 0;
  while (*(unsigned char *)(a1 + result))
  {
    if (a2 == ++result) {
      return a2;
    }
  }
  return result;
}

uint64_t mosyntbase_Copy(uint64_t a1, int a2, uint64_t a3, int a4, BOOL *a5)
{
  if (a2 < 1)
  {
    uint64_t v6 = 0;
LABEL_11:
    *(unsigned char *)(a3 + v6) = 0;
    BOOL v8 = 1;
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v6 = a2;
    while (*(unsigned char *)(a1 + v5) && v5 < a4 - 1)
    {
      *(unsigned char *)(a3 + v5) = *(unsigned char *)(a1 + v5);
      if (a2 == ++v5) {
        goto LABEL_11;
      }
    }
    *(unsigned char *)(a3 + v5) = 0;
    BOOL v8 = *(unsigned char *)(a1 + v5) == 0;
  }
  *a5 = v8;
  return 0;
}

uint64_t mosyntbase_CCopy(unsigned __int8 *a1, unsigned int a2, uint64_t a3, int a4, BOOL *a5)
{
  int v15 = a1;
  unsigned int v14 = a2;
  m2__fix__carray__len(&v15, (int *)&v14);
  uint64_t v8 = v14;
  if ((int)v14 < 1)
  {
    uint64_t v8 = 0;
LABEL_11:
    *(unsigned char *)(a3 + v8) = 0;
    BOOL v12 = 1;
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v10 = v15;
    while (v10[v9] && v9 < a4 - 1)
    {
      *(unsigned char *)(a3 + v9) = v10[v9];
      if (v8 == ++v9) {
        goto LABEL_11;
      }
    }
    *(unsigned char *)(a3 + v9) = 0;
    BOOL v12 = v10[v9] == 0;
  }
  *a5 = v12;
  return 0;
}

uint64_t mosyntbase_AppendTo(uint64_t a1, int a2, uint64_t a3, int a4, BOOL *a5)
{
  uint64_t v5 = (a2 - 1);
  if (a2 <= 1)
  {
    LODWORD(v6) = 0;
  }
  else
  {
    uint64_t v6 = 0;
    while (*(unsigned char *)(a1 + v6))
    {
      if (v5 == ++v6)
      {
        LODWORD(v6) = a2 - 1;
        break;
      }
    }
  }
  if (a4 < 1)
  {
LABEL_15:
    *(unsigned char *)(a1 + v6) = 0;
    BOOL v11 = 1;
  }
  else
  {
    uint64_t v7 = 0;
    int v8 = v6;
    uint64_t v9 = a1 + v6;
    while (*(unsigned char *)(a3 + v7) && (int)v5 > v8 + (int)v7)
    {
      *(unsigned char *)(v9 + v7) = *(unsigned char *)(a3 + v7);
      if (a4 == ++v7)
      {
        LODWORD(v6) = v8 + v7;
        goto LABEL_15;
      }
    }
    *(unsigned char *)(a1 + (v8 + v7)) = 0;
    BOOL v11 = *(unsigned char *)(a3 + v7) == 0;
  }
  *a5 = v11;
  return 0;
}

uint64_t mosyntbase_App(uint64_t a1, int a2, int *a3, uint64_t a4, int a5, BOOL *a6)
{
  int v6 = a2 - 1;
  int v7 = *a3;
  BOOL v8 = a5 > 0;
  if (*a3 >= a2 - 1 || a5 < 1)
  {
    LODWORD(v10) = 0;
  }
  else
  {
    unint64_t v10 = 0;
    while (*(unsigned char *)(a4 + v10))
    {
      *(unsigned char *)(a1 + v7) = *(unsigned char *)(a4 + v10);
      int v7 = *a3 + 1;
      *a3 = v7;
      BOOL v8 = ++v10 < a5;
      if (v7 >= v6 || v10 >= a5) {
        goto LABEL_15;
      }
    }
    BOOL v8 = 1;
  }
LABEL_15:
  if (v7 < a2) {
    int v6 = v7;
  }
  *(unsigned char *)(a1 + v6) = 0;
  BOOL v12 = !v8 || *(unsigned char *)(a4 + v10) == 0;
  *a6 = v12;
  return 0;
}

uint64_t mosyntbase_CApp(uint64_t a1, int a2, int *a3, unsigned __int8 *a4, int a5, BOOL *a6)
{
  BOOL v12 = a4;
  int v11 = a5;
  m2__fix__carray__len(&v12, &v11);
  mosyntbase_App(a1, a2, a3, (uint64_t)v12, v11, a6);
  return 0;
}

uint64_t mosyntbase_GetSepPartStr(uint64_t a1, int a2, int *a3, unsigned __int8 a4, unsigned char *a5, int a6, char *a7)
{
  int v7 = *a3;
  if ((*a3 & 0x80000000) == 0)
  {
    if (v7 >= a2)
    {
      int v8 = 0;
      char v9 = 1;
    }
    else
    {
      int v8 = 0;
      char v9 = 1;
      do
      {
        int v10 = *(unsigned __int8 *)(a1 + v7);
        if (v10 == a4 || v10 == 0) {
          break;
        }
        if (v8 >= a6)
        {
          char v9 = 0;
        }
        else
        {
          a5[v8++] = v10;
          int v7 = *a3;
        }
        *a3 = ++v7;
      }
      while (v7 < a2);
    }
    if (v8 < a6)
    {
      a5[v8] = 0;
      int v7 = *a3;
    }
    if (v7 >= a2) {
      goto LABEL_23;
    }
    if (*(unsigned __int8 *)(a1 + v7) == a4)
    {
      int v12 = v7 + 1;
    }
    else
    {
      if (*(unsigned char *)(a1 + v7))
      {
LABEL_23:
        *a7 = v9;
        return 0;
      }
      int v12 = -1;
    }
    *a3 = v12;
    goto LABEL_23;
  }
  *a7 = 0;
  *a5 = 0;
  return 0;
}

BOOL mosyntbase_Equal(uint64_t a1, int a2, uint64_t a3, int a4)
{
  if (a2 < 1)
  {
    LODWORD(v4) = 0;
  }
  else
  {
    uint64_t v4 = 0;
    while (v4 < a4 && *(unsigned char *)(a1 + v4))
    {
      if (!*(unsigned char *)(a3 + v4) || *(unsigned __int8 *)(a1 + v4) != *(unsigned __int8 *)(a3 + v4)) {
        break;
      }
      if (a2 == ++v4)
      {
        LODWORD(v4) = a2;
        return (int)v4 >= a4 || *(unsigned char *)(a3 + v4) == 0;
      }
    }
    if (*(unsigned char *)(a1 + v4)) {
      return 0;
    }
  }
  return (int)v4 >= a4 || *(unsigned char *)(a3 + v4) == 0;
}

BOOL mosyntbase_CEqual(unsigned __int8 *a1, int a2, unsigned __int8 *a3, int a4)
{
  int v8 = a1;
  int v7 = a2;
  int v6 = a3;
  int v5 = a4;
  m2__fix__carray__len(&v8, &v7);
  m2__fix__carray__len(&v6, &v5);
  return mosyntbase_Equal((uint64_t)v8, v7, (uint64_t)v6, v5);
}

uint64_t mosyntbase_UpperCase(unsigned char *a1, int a2)
{
  if (a2 >= 1)
  {
    uint64_t v2 = a2;
    do
    {
      int v3 = *a1;
      if (!*a1) {
        break;
      }
      if ((v3 - 97) <= 0x19) {
        *a1 = v3 - 32;
      }
      ++a1;
      --v2;
    }
    while (v2);
  }
  return 0;
}

uint64_t mosyntbase_FindSubstring(uint64_t a1, int a2, uint64_t a3, int a4, int a5, int *a6)
{
  int v6 = a5 & ~(a5 >> 31);
  if (a5 >= 1)
  {
    if (a4 < 1) {
      goto LABEL_27;
    }
    uint64_t v7 = 0;
    while (*(unsigned char *)(a3 + v7))
    {
      if (a4 == ++v7)
      {
        LODWORD(v7) = a4;
        break;
      }
    }
    if (v6 >= (int)v7) {
      goto LABEL_27;
    }
  }
  if (v6 >= a4)
  {
    int v8 = 0;
  }
  else
  {
    int v8 = 0;
    do
    {
      int v9 = *(unsigned __int8 *)(a3 + v6);
      if (*(unsigned char *)(a3 + v6)) {
        BOOL v10 = v8 < a2;
      }
      else {
        BOOL v10 = 0;
      }
      if (!v10) {
        break;
      }
      int v11 = *(unsigned __int8 *)(a1 + v8);
      if (!*(unsigned char *)(a1 + v8)) {
        break;
      }
      BOOL v12 = v11 == v9;
      int v13 = v11 == v9 ? 0 : v8;
      if (v12) {
        ++v8;
      }
      else {
        int v8 = 0;
      }
      int v6 = v6 - v13 + 1;
    }
    while (v6 < a4);
  }
  if (v8 < a2 && *(unsigned char *)(a1 + v8)) {
LABEL_27:
  }
    int v14 = -1;
  else {
    int v14 = v6 - v8;
  }
  *a6 = v14;
  return 0;
}

uint64_t mosyntbase_RemoveSubstring(int a1, int a2, uint64_t a3, int a4, unsigned char *a5)
{
  *a5 = 1;
  if (a4 < 1)
  {
    LODWORD(v5) = 0;
  }
  else
  {
    uint64_t v5 = 0;
    while (*(unsigned char *)(a3 + v5))
    {
      if (a4 == ++v5)
      {
        LODWORD(v5) = a4;
        break;
      }
    }
  }
  if ((int)v5 > a1)
  {
    uint64_t v6 = a2 + (uint64_t)a1;
    if ((int)v6 <= (int)v5)
    {
      if ((int)v6 < (int)v5)
      {
        uint64_t v7 = (unsigned char *)(a3 + a1);
        int v8 = (char *)(a3 + v6);
        int v9 = v5 - a2;
        do
        {
          char v10 = *v8++;
          *v7++ = v10;
          ++a1;
        }
        while (v9 != a1);
      }
    }
    else
    {
      *a5 = 0;
    }
    if (a1 < a4) {
      a5 = (unsigned char *)(a3 + a1);
    }
    else {
      a5 = (unsigned char *)(a3 + a4 - 1);
    }
  }
  *a5 = 0;
  return 0;
}

uint64_t mosyntaccphr_TreatSyntTree(uint64_t a1, int a2, uint64_t a3, uint64_t a4, int a5, int a6, uint64_t a7, uint64_t a8)
{
  uint64_t v296 = *MEMORY[0x263EF8340];
  uint64_t v280 = 0;
  uint64_t SentTermCommList = mosyntpal_ALLOCATE(a1, &v280, 0x60u);
  if ((SentTermCommList & 0x80000000) != 0) {
    return SentTermCommList;
  }
  uint64_t v17 = v280;
  *(_DWORD *)uint64_t v280 = a2;
  *(void *)(v17 + 8) = a3;
  *(void *)(v17 + 16) = a4;
  *(_DWORD *)(v17 + 24) = a5;
  *(_DWORD *)(v17 + 28) = a6;
  *(void *)(v17 + 32) = 0;
  *(void *)(v17 + 40) = a7;
  *(_DWORD *)(v280 + 48) = ((uint64_t (*)(void))mosyntkbaccphr_Nil)();
  *(_DWORD *)(v280 + 52) = ((uint64_t (*)(void))mosyntkbaccphr_Nil)();
  int v18 = ((uint64_t (*)(void))mosyntkbaccphr_Nil)();
  uint64_t v19 = v280;
  uint64_t v20 = v280;
  *(_DWORD *)(v280 + 56) = v18;
  int v21 = (int *)(v20 + 56);
  if (!a8) {
    goto LABEL_557;
  }
  uint64_t v22 = *(void *)(v19 + 16);
  if (v22 != fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::InitMatcher())
  {
    BOOL v24 = (int *)(v19 + 48);
    int v23 = *(_DWORD *)(v19 + 48);
    if (v23 == ((uint64_t (*)(void))mosyntkbaccphr_Nil)())
    {
      uint64_t DomainById = FindDomainById(v19, *(_DWORD *)(v19 + 28), (_DWORD *)(v19 + 48));
      int v26 = *(_DWORD *)(v19 + 48);
      if (v26 == mosyntkbaccphr_Nil(DomainById))
      {
        int v27 = mosyntkbaccphr_AccPhrDomains(*(void *)(v19 + 16));
        *(_DWORD *)(v19 + 48) = v27;
      }
      else
      {
        int v27 = *v24;
      }
      *(_DWORD *)(v19 + 52) = v27;
      *(_DWORD *)(v19 + 56) = v27;
    }
    *(void *)&long long v289 = 0;
    uint64_t SentTermCommList = mosyntdata_GetSentTermCommList(a1, *(void *)(v19 + 40), *(_DWORD *)(a8 + 52), &v289);
    if ((SentTermCommList & 0x80000000) != 0) {
      return SentTermCommList;
    }
    int v28 = (uint64_t *)v289;
    uint64_t v29 = *(void *)(v19 + 16);
    uint64_t inited = fst::Fst<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::InitMatcher();
    if (v29 == inited)
    {
      uint64_t v44 = mosyntkbaccphr_Nil(inited);
      *(_DWORD *)(v19 + 48) = v44;
      uint64_t v45 = mosyntkbaccphr_Nil(v44);
      *(_DWORD *)(v19 + 52) = v45;
      *(_DWORD *)(v19 + 56) = mosyntkbaccphr_Nil(v45);
      goto LABEL_65;
    }
    if (!v28) {
      goto LABEL_65;
    }
    uint64_t BestScenarioPathSuffix = 0;
    int v32 = (int *)(v19 + 52);
    while (1)
    {
      while (*((_DWORD *)v28 + 2) != 5)
      {
LABEL_61:
        int v28 = (uint64_t *)*v28;
        if (!v28)
        {
          if ((BestScenarioPathSuffix & 0x80000000) != 0) {
            return BestScenarioPathSuffix;
          }
          goto LABEL_65;
        }
      }
      if (*((_DWORD *)v28 + 3))
      {
        int v33 = *v24;
      }
      else
      {
        uint64_t inited = mosyntkbaccphr_Nil(inited);
        int v33 = inited;
        *BOOL v24 = inited;
      }
      uint64_t inited = mosyntkbaccphr_Nil(inited);
      if (v33 == inited)
      {
        uint64_t v34 = FindDomainById(v19, *(_DWORD *)(v19 + 28), (_DWORD *)(v19 + 48));
        int v35 = *(_DWORD *)(v19 + 48);
        if (v35 == mosyntkbaccphr_Nil(v34))
        {
          uint64_t inited = mosyntkbaccphr_AccPhrDomains(*(void *)(v19 + 16));
          *(_DWORD *)(v19 + 48) = inited;
        }
        else
        {
          uint64_t inited = *v24;
        }
        uint64_t BestScenarioPathSuffix = 0;
        *int v32 = inited;
        int *v21 = inited;
      }
      int v36 = *((_DWORD *)v28 + 3);
      if (v36 != 2) {
        break;
      }
      int v37 = *(_DWORD *)v19;
      if (!*((unsigned char *)v28 + 36))
      {
        if (v37 >= 1)
        {
          uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
          if ((SentTermCommList & 0x80000000) != 0) {
            return SentTermCommList;
          }
          uint64_t inited = mosyntbase_WriteMessage(a1, "Resetting sentence domain\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
          goto LABEL_49;
        }
LABEL_50:
        int v43 = *v32;
LABEL_60:
        int *v21 = v43;
        goto LABEL_61;
      }
      if (v37 >= 1)
      {
        uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
        if ((SentTermCommList & 0x80000000) != 0) {
          return SentTermCommList;
        }
        uint64_t SentTermCommList = mosyntbase_WriteMessage(a1, "Setting sentence domain to '%s'\\n", 0, (unsigned __int8 *)v28 + 36, 100, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
        if ((SentTermCommList & 0x80000000) != 0) {
          return SentTermCommList;
        }
      }
      uint64_t DomainByName = FindDomainByName(v19, (unsigned __int8 *)v28 + 36, v21);
      int v39 = *(_DWORD *)(v19 + 56);
      uint64_t inited = mosyntkbaccphr_Nil(DomainByName);
      if (v39 == inited)
      {
        if (*(int *)v19 >= 1)
        {
          uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
          if ((SentTermCommList & 0x80000000) != 0) {
            return SentTermCommList;
          }
          uint64_t inited = mosyntbase_WriteMessage(a1, "Didn't find sentence domain '%s'\\n", 0, (unsigned __int8 *)v28 + 36, 100, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
LABEL_49:
          uint64_t BestScenarioPathSuffix = inited;
          if ((inited & 0x80000000) != 0) {
            return BestScenarioPathSuffix;
          }
          goto LABEL_50;
        }
LABEL_45:
        uint64_t BestScenarioPathSuffix = 0;
        goto LABEL_50;
      }
      uint64_t BestScenarioPathSuffix = 0;
      int v28 = (uint64_t *)*v28;
      if (!v28) {
        goto LABEL_65;
      }
    }
    if (v36 != 1)
    {
      if (!v36 && *(int *)v19 >= 1)
      {
        uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
        if ((SentTermCommList & 0x80000000) != 0) {
          return SentTermCommList;
        }
        uint64_t inited = mosyntbase_WriteMessage(a1, "Resetting default domain\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
        uint64_t BestScenarioPathSuffix = inited;
        if ((inited & 0x80000000) != 0) {
          return BestScenarioPathSuffix;
        }
      }
      goto LABEL_61;
    }
    int v40 = *(_DWORD *)v19;
    if (*((unsigned char *)v28 + 36))
    {
      if (v40 >= 1)
      {
        uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
        if ((SentTermCommList & 0x80000000) != 0) {
          return SentTermCommList;
        }
        uint64_t SentTermCommList = mosyntbase_WriteMessage(a1, "Setting paragraph domain to '%s'\\n", 0, (unsigned __int8 *)v28 + 36, 100, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
        if ((SentTermCommList & 0x80000000) != 0) {
          return SentTermCommList;
        }
      }
      uint64_t v41 = FindDomainByName(v19, (unsigned __int8 *)v28 + 36, (int *)(v19 + 52));
      int v42 = *(_DWORD *)(v19 + 52);
      uint64_t inited = mosyntkbaccphr_Nil(v41);
      if (v42 != inited) {
        goto LABEL_45;
      }
      if (*(int *)v19 >= 1)
      {
        uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
        if ((SentTermCommList & 0x80000000) != 0) {
          return SentTermCommList;
        }
        uint64_t inited = mosyntbase_WriteMessage(a1, "Didn't find paragraph domain '%s'\\n", 0, (unsigned __int8 *)v28 + 36, 100, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
        goto LABEL_54;
      }
      uint64_t BestScenarioPathSuffix = 0;
    }
    else if (v40 >= 1)
    {
      uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
      if ((SentTermCommList & 0x80000000) != 0) {
        return SentTermCommList;
      }
      uint64_t inited = mosyntbase_WriteMessage(a1, "Resetting paragraph domain\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
LABEL_54:
      uint64_t BestScenarioPathSuffix = inited;
      if ((inited & 0x80000000) != 0) {
        return BestScenarioPathSuffix;
      }
    }
    int v43 = *v24;
    *int v32 = *v24;
    goto LABEL_60;
  }
LABEL_65:
  uint64_t v46 = v280;
  *(_DWORD *)(v280 + 60) = *(_DWORD *)(v280 + 56);
  int v47 = mosyntkbaccphr_AccPhrType(*(void *)(v46 + 16));
  uint64_t v48 = v280;
  if (!v47)
  {
    uint64_t v284 = 0;
    unsigned int v55 = mosyntkbsymtab_WildConsId(*(void *)(v280 + 8));
    uint64_t SentTermCommList = GenAccTree(a1, v48, (uint64_t *)a8, &v284);
    if ((SentTermCommList & 0x80000000) != 0) {
      return SentTermCommList;
    }
    uint64_t v56 = v284;
    LODWORD(v289) = 0;
    uint64_t SentTermCommList = Accentuation1(a1, v48, v284, (int *)&v289);
    if ((SentTermCommList & 0x80000000) != 0) {
      return SentTermCommList;
    }
    *(void *)&v287[0] = 0;
    int v283 = 0;
    *(void *)&long long v289 = 0;
    uint64_t SentTermCommList = GetInitPhrasing1(a1, v48, v56, 3, 0, &v283, (uint64_t *)&v289);
    if ((SentTermCommList & 0x80000000) != 0) {
      return SentTermCommList;
    }
    unsigned int v57 = (void)v289 ? *(_DWORD *)(v289 + 24) : 0;
    uint64_t SentTermCommList = mosyntdata_GetSentTermCommList(a1, *(void *)(v48 + 40), v57, v287);
    if ((SentTermCommList & 0x80000000) != 0) {
      return SentTermCommList;
    }
    __int16 v58 = FinalBoundaryIndex(a1, *(uint64_t **)&v287[0]);
    uint64_t SentTermCommList = AppendInitBound(a1, v48, &v283, (uint64_t *)&v289, v58, 0);
    if ((SentTermCommList & 0x80000000) != 0) {
      return SentTermCommList;
    }
    *(_DWORD *)(v289 + 16) = v57;
    if (*(int *)v48 <= 0)
    {
      int v60 = v283;
    }
    else
    {
      uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
      if ((SentTermCommList & 0x80000000) != 0) {
        return SentTermCommList;
      }
      uint64_t SentTermCommList = mosyntbase_WString(a1, "initial phrasing: ", 0);
      if ((SentTermCommList & 0x80000000) != 0) {
        return SentTermCommList;
      }
      unint64_t v59 = v283;
      uint64_t SentTermCommList = WriteBoundList(a1, v48, v283, 0);
      if ((SentTermCommList & 0x80000000) != 0) {
        return SentTermCommList;
      }
      uint64_t SentTermCommList = mosyntbase_WLn(a1);
      int v60 = v59;
      if ((SentTermCommList & 0x80000000) != 0) {
        return SentTermCommList;
      }
    }
    int v80 = *(_DWORD *)(v48 + 24);
    long long v289 = 0u;
    long long v290 = 0u;
    long long v291 = 0u;
    long long v292 = 0u;
    long long v293 = 0u;
    long long v294 = 0u;
    int v295 = 0;
    uint64_t v279 = v60;
    if (v60)
    {
      unsigned int v81 = 0;
      uint64_t BestScenarioPathSuffix = 0;
      uint64_t v82 = v60;
      do
      {
        uint64_t v83 = *((__int16 *)v82 + 4);
        if (v83 < 100)
        {
          *((unsigned char *)&v289 + v83) = 1;
        }
        else
        {
          uint64_t SentTermCommList = mosyntbase_WString(a1, "*** maximum nr of phrase boundary index levels exceeded", 0);
          if ((SentTermCommList & 0x80000000) != 0) {
            return SentTermCommList;
          }
          uint64_t BestScenarioPathSuffix = mosyntbase_WLn(a1);
          if ((BestScenarioPathSuffix & 0x80000000) != 0) {
            return BestScenarioPathSuffix;
          }
          LOWORD(v83) = *((_WORD *)v82 + 4);
          int v60 = v279;
        }
        if ((int)v81 <= (__int16)v83) {
          unsigned int v81 = (__int16)v83;
        }
        uint64_t v82 = (uint64_t *)*v82;
      }
      while (v82);
    }
    else
    {
      uint64_t BestScenarioPathSuffix = 0;
      unsigned int v81 = 0;
    }
    uint64_t v84 = v81;
    for (int i = 1; i != 3; ++i)
    {
      if ((int)v84 >= 2)
      {
        uint64_t v86 = v84;
        do
        {
          if ((unint64_t)v86 > 0x63 || *((unsigned char *)&v289 + v86))
          {
            if (v60)
            {
              int v87 = 0;
              int v88 = 0;
              uint64_t v89 = 0;
              unint64_t v90 = (__int16 *)v60;
              while (1)
              {
                int v91 = v90[4];
                if ((v91 & 0x80000000) == 0) {
                  break;
                }
LABEL_234:
                unint64_t v90 = *(__int16 **)v90;
                if (!v90) {
                  goto LABEL_235;
                }
              }
              if (!v88 || (v88[4] & 0x80000000) == 0) {
                uint64_t v89 = v88;
              }
              if (v87)
              {
                int v92 = v87[4];
                if (v86 == v92 && v89)
                {
                  if (i == 1)
                  {
                    __int16 v93 = v89[5];
                    if (v93 || v92 < v89[4])
                    {
                      if (v92 <= v91 || v87[5]) {
                        goto LABEL_232;
                      }
                    }
                    else
                    {
                      __int16 v93 = 0;
                    }
LABEL_231:
                    v87[4] = -1;
                    v89[5] = v87[5] + v93;
                    v89[6] += v87[6];
                    goto LABEL_232;
                  }
                  if (v80 > 1 || v92 >= 3)
                  {
                    int v94 = v89[6];
                    if (v94 >= 5) {
                      int v95 = v80 - 1;
                    }
                    else {
                      int v95 = v80;
                    }
                    if (v94 < 3) {
                      int v95 = v80 + 1;
                    }
                    int v96 = v87[6];
                    int v97 = v96 >= 5 ? v80 - 1 : v80;
                    int v98 = v96 >= 3 ? v97 : v80 + 1;
                    if (v92 >= v89[4])
                    {
                      if (v92 >= v91 && v95 >= v89[5])
                      {
                        __int16 v93 = v89[5];
                        goto LABEL_231;
                      }
                      if (v92 > v91 && v98 >= v87[5])
                      {
                        __int16 v93 = v89[5];
                        goto LABEL_231;
                      }
                    }
                  }
                }
LABEL_232:
                int v88 = v87;
              }
              else
              {
                int v88 = 0;
              }
              int v87 = v90;
              goto LABEL_234;
            }
LABEL_235:
            if (*(int *)v48 >= 1)
            {
              uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
              if ((SentTermCommList & 0x80000000) != 0) {
                return SentTermCommList;
              }
              uint64_t v99 = (unsigned __int8 *)(i == 1 ? "after clitic melting" : "after rhythmic melting");
              uint64_t SentTermCommList = mosyntbase_WString(a1, v99, 0);
              if ((SentTermCommList & 0x80000000) != 0) {
                return SentTermCommList;
              }
              uint64_t SentTermCommList = mosyntbase_WString(a1, ", index ", 0);
              if ((SentTermCommList & 0x80000000) != 0) {
                return SentTermCommList;
              }
              uint64_t SentTermCommList = mosyntbase_WInt(a1, v86, 0);
              if ((SentTermCommList & 0x80000000) != 0) {
                return SentTermCommList;
              }
              uint64_t SentTermCommList = mosyntbase_WString(a1, ": ", 0);
              if ((SentTermCommList & 0x80000000) != 0) {
                return SentTermCommList;
              }
              uint64_t SentTermCommList = WriteBoundList(a1, v48, v279, 0);
              if ((SentTermCommList & 0x80000000) != 0) {
                return SentTermCommList;
              }
              uint64_t BestScenarioPathSuffix = mosyntbase_WLn(a1);
              int v60 = v279;
              if ((BestScenarioPathSuffix & 0x80000000) != 0) {
                return BestScenarioPathSuffix;
              }
            }
          }
          BOOL v197 = v86-- <= 2;
        }
        while (!v197);
      }
    }
    if ((BestScenarioPathSuffix & 0x80000000) != 0) {
      return BestScenarioPathSuffix;
    }
    if (mosyntkbsymtab_PropTabAvailable(*(void *)(v48 + 8))
      && mosyntkbsymtab_HasIntPropValue(a1, *(uint64_t **)(v48 + 8), v55, 8u, 1))
    {
      goto LABEL_252;
    }
    if (v279)
    {
      int v164 = 0;
      uint64_t v165 = 0;
      uint64_t v166 = 0;
      __int16 v167 = v279;
      while (1)
      {
        if (*((unsigned __int16 *)v167 + 4) > 1u)
        {
          unsigned int v168 = (uint64_t *)v165;
          goto LABEL_421;
        }
        int v164 = 0;
        unsigned int v168 = 0;
        if (!v166 || !v165) {
          goto LABEL_419;
        }
        uint64_t v166 = v167;
        if ((uint64_t *)v165 != v167) {
          break;
        }
LABEL_421:
        if (*((__int16 *)v167 + 15) <= 0)
        {
          __int16 v167 = (uint64_t *)*v167;
        }
        else
        {
          int v169 = *((unsigned __int16 *)v167 + 15);
          __int16 v167 = (uint64_t *)*v167;
          if (v164 == 0 || v164 >= v169)
          {
            unsigned int v168 = v167;
            int v164 = v169;
          }
        }
        uint64_t v165 = (uint64_t)v168;
        if (!v167) {
          goto LABEL_427;
        }
      }
      do
      {
        if ((*(__int16 *)(v165 + 8) & 0x80000000) == 0) {
          *(_WORD *)(v165 + 8) = -1;
        }
        uint64_t v165 = *(void *)v165;
      }
      while ((uint64_t *)v165 != v167);
      unsigned int v168 = 0;
      int v164 = 0;
LABEL_419:
      uint64_t v166 = v167;
      goto LABEL_421;
    }
LABEL_427:
    if (*(int *)v48 < 1) {
      goto LABEL_436;
    }
    uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
    if ((SentTermCommList & 0x80000000) != 0) {
      return SentTermCommList;
    }
    uint64_t SentTermCommList = mosyntbase_WString(a1, "after postcyclic deletion: ", 0);
    if ((SentTermCommList & 0x80000000) != 0) {
      return SentTermCommList;
    }
    uint64_t SentTermCommList = WriteBoundList(a1, v48, v279, 0);
    if ((SentTermCommList & 0x80000000) != 0) {
      return SentTermCommList;
    }
    uint64_t SentTermCommList = mosyntbase_WLn(a1);
    if ((SentTermCommList & 0x80000000) != 0) {
      return SentTermCommList;
    }
LABEL_252:
    if (*(int *)v48 < 1)
    {
LABEL_436:
      uint64_t BestScenarioPathSuffix = 0;
    }
    else
    {
      uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
      if ((SentTermCommList & 0x80000000) != 0) {
        return SentTermCommList;
      }
      uint64_t SentTermCommList = mosyntbase_WStringLn(a1, "before setting phrase types: ", 0);
      if ((SentTermCommList & 0x80000000) != 0) {
        return SentTermCommList;
      }
      uint64_t SentTermCommList = WriteBoundList(a1, v48, v279, 1);
      if ((SentTermCommList & 0x80000000) != 0) {
        return SentTermCommList;
      }
      uint64_t BestScenarioPathSuffix = mosyntbase_WLn(a1);
      if ((BestScenarioPathSuffix & 0x80000000) != 0) {
        return BestScenarioPathSuffix;
      }
    }
    if (v279)
    {
      int v171 = 0;
      int v172 = 0;
      int v173 = 0;
      int v174 = 0;
      LODWORD(v282) = 0;
      *(void *)&long long v289 = 0;
      *(void *)&v287[0] = 0;
      uint64_t v175 = v279;
      int v176 = 1;
      do
      {
        mosyntdata_GetSentTermCommList(a1, *(void *)(v48 + 40), *((_DWORD *)v175 + 4), &v289);
        mosyntdata_GetPunctFromCommandList(a1, (uint64_t *)v289, &v282, v287);
        if (v282 == 11) {
          int v177 = 1;
        }
        else {
          int v177 = v171;
        }
        if (v282 == 10) {
          int v172 = 1;
        }
        else {
          int v171 = v177;
        }
        if (*((__int16 *)v175 + 14) >= 1)
        {
          if (mosyntkbsymtab_PropTabAvailable(*(void *)(v48 + 8))
            && mosyntkbsymtab_HasIntPropValue(a1, *(uint64_t **)(v48 + 8), *((__int16 *)v175 + 14), 6u, 2))
          {
            int v176 = 0;
            int v174 = 1;
          }
          else if (v176 || !mosyntkbsymtab_PropTabAvailable(*(void *)(v48 + 8)))
          {
            int v176 = 0;
          }
          else
          {
            int v176 = 0;
            if (mosyntkbsymtab_HasIntPropValue(a1, *(uint64_t **)(v48 + 8), *((__int16 *)v175 + 14), 6u, 3)) {
              int v173 = 1;
            }
          }
        }
        uint64_t v175 = (uint64_t *)*v175;
      }
      while (v175);
      if (v172)
      {
        if (v174)
        {
          int v178 = 5;
        }
        else
        {
          if (v173)
          {
            uint64_t v262 = v279;
            do
            {
              if (*((__int16 *)v262 + 14) >= 1
                && mosyntkbsymtab_PropTabAvailable(*(void *)(v48 + 8))
                && mosyntkbsymtab_HasIntPropValue(a1, *(uint64_t **)(v48 + 8), *((__int16 *)v262 + 14), 6u, 3))
              {
                *((_WORD *)v262 + 4) = 2;
              }
              uint64_t v262 = (uint64_t *)*v262;
            }
            while (v262);
            int v178 = 8;
            int v208 = 1;
            goto LABEL_533;
          }
          int v178 = 4;
        }
LABEL_532:
        int v208 = 0;
LABEL_533:
        if (!v279) {
          goto LABEL_572;
        }
        __int16 v209 = 0;
        int v210 = 1;
        int v211 = v279;
        while (1)
        {
          if ((__int16)v211[1] < 0)
          {
            unsigned int v212 = (uint64_t *)*v211;
          }
          else
          {
            unsigned int v212 = (uint64_t *)*v211;
            if (v209)
            {
              if (!v212)
              {
                *((_DWORD *)v209 + 8) = v178;
LABEL_572:
                if (*(int *)v48 >= 1)
                {
                  uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
                  if ((SentTermCommList & 0x80000000) != 0) {
                    return SentTermCommList;
                  }
                  uint64_t SentTermCommList = mosyntbase_WStringLn(a1, "after setting phrase types: ", 0);
                  if ((SentTermCommList & 0x80000000) != 0) {
                    return SentTermCommList;
                  }
                  uint64_t SentTermCommList = WriteBoundList(a1, v48, v279, 1);
                  if ((SentTermCommList & 0x80000000) != 0) {
                    return SentTermCommList;
                  }
                  uint64_t BestScenarioPathSuffix = mosyntbase_WLn(a1);
                }
                if ((BestScenarioPathSuffix & 0x80000000) != 0) {
                  return BestScenarioPathSuffix;
                }
                unsigned int v220 = mosyntkbsymtab_WildConsId(*(void *)(v48 + 8));
                if (mosyntkbsymtab_PropTabAvailable(*(void *)(v48 + 8))
                  && mosyntkbsymtab_HasIntPropValue(a1, *(uint64_t **)(v48 + 8), v220, 9u, 1))
                {
                  if (v279)
                  {
                    __int16 v221 = v279;
                    do
                    {
                      if (*((_WORD *)v221 + 15)) {
                        ++*((_WORD *)v221 + 15);
                      }
                      __int16 v221 = (uint64_t *)*v221;
                    }
                    while (v221);
                    goto LABEL_585;
                  }
LABEL_646:
                  uint64_t BestScenarioPathSuffix = 0;
                }
                else
                {
LABEL_585:
                  if (!v279) {
                    goto LABEL_646;
                  }
                  int v222 = 0;
                  int v223 = 0;
                  uint64_t v224 = 0;
                  uint64_t BestScenarioPathSuffix = 0;
                  uint64_t v225 = v279;
                  do
                  {
                    if (((__int16)v225[1] & 0x80000000) == 0)
                    {
                      if (v223) {
                        *((_WORD *)v223 + 15) = 1;
                      }
                      *(void *)&long long v289 = 0;
                      uint64_t SentTermCommList = mosyntpal_ALLOCATE(a1, (uint64_t *)&v289, 0x12Au);
                      if ((SentTermCommList & 0x80000000) != 0) {
                        return SentTermCommList;
                      }
                      if (v224)
                      {
                        for (uint64_t j = 0; j != 99; ++j)
                          *(unsigned char *)(v289 + j) = 0;
                        for (uint64_t k = v224; (uint64_t *)k != v225; uint64_t k = *(void *)k)
                        {
                          uint64_t v228 = *(__int16 *)(k + 30);
                          if (v228 <= 98) {
                            *(unsigned char *)(v289 + v228) = 1;
                          }
                        }
                        uint64_t v229 = 0;
                        int v230 = 1;
                        uint64_t v231 = v289;
                        do
                        {
                          if (*(unsigned char *)(v231 + v229)) {
                            *(_WORD *)(v231 + 2 * v229 + 100) = v230++;
                          }
                          ++v229;
                        }
                        while (v229 != 99);
                        while ((uint64_t *)v224 != v225)
                        {
                          uint64_t v232 = *(__int16 *)(v224 + 30);
                          if (v232 <= 98)
                          {
                            uint64_t v233 = v289;
                            if (*(int *)v48 >= 2
                              && *(unsigned __int16 *)(v289 + 2 * v232 + 100) != (unsigned __int16)v232)
                            {
                              uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
                              if ((SentTermCommList & 0x80000000) != 0) {
                                return SentTermCommList;
                              }
                              uint64_t SentTermCommList = mosyntbase_WString(a1, "accent normalization: ", 0);
                              if ((SentTermCommList & 0x80000000) != 0) {
                                return SentTermCommList;
                              }
                              uint64_t SentTermCommList = mosyntbase_WInt(a1, *(__int16 *)(v224 + 30), 0);
                              if ((SentTermCommList & 0x80000000) != 0) {
                                return SentTermCommList;
                              }
                              uint64_t SentTermCommList = mosyntbase_WString(a1, " changed to ", 0);
                              if ((SentTermCommList & 0x80000000) != 0) {
                                return SentTermCommList;
                              }
                              uint64_t SentTermCommList = mosyntbase_WInt(a1, *(__int16 *)(v289 + 2 * *(__int16 *)(v224 + 30) + 100), 0);
                              if ((SentTermCommList & 0x80000000) != 0) {
                                return SentTermCommList;
                              }
                              uint64_t SentTermCommList = mosyntbase_WLn(a1);
                              if ((SentTermCommList & 0x80000000) != 0) {
                                return SentTermCommList;
                              }
                              uint64_t v233 = v289;
                              LOWORD(v232) = *(_WORD *)(v224 + 30);
                            }
                            *(_WORD *)(v224 + 30) = *(_WORD *)(v233 + 2 * (__int16)v232 + 100);
                            if (mosyntkbsymtab_PropTabAvailable(*(void *)(v48 + 8))) {
                              int v234 = mosyntkbsymtab_IntPropValue(a1, *(uint64_t **)(v48 + 8), *(__int16 *)(v224 + 28), 2u);
                            }
                            else {
                              int v234 = 1;
                            }
                            int v235 = *(__int16 *)(v224 + 30);
                            if (v235 >= 2 && v234 > v235) {
                              *(_WORD *)(v224 + 30) = v234;
                            }
                          }
                          uint64_t v224 = *(void *)v224;
                        }
                      }
                      uint64_t BestScenarioPathSuffix = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v289);
                      if ((BestScenarioPathSuffix & 0x80000000) != 0) {
                        return BestScenarioPathSuffix;
                      }
                      int v223 = 0;
                      int v222 = 0;
                      uint64_t v224 = (uint64_t)v225;
                    }
                    if (mosyntkbsymtab_PropTabAvailable(*(void *)(v48 + 8))
                      && mosyntkbsymtab_HasIntPropValue(a1, *(uint64_t **)(v48 + 8), v220, 7u, 1))
                    {
                      int v236 = *((__int16 *)v225 + 15);
                      int v237 = *((unsigned __int16 *)v225 + 15);
                      if (v222) {
                        BOOL v238 = v222 <= v237;
                      }
                      else {
                        BOOL v238 = 0;
                      }
                      int v239 = !v238;
                      BOOL v240 = v239 == 0;
                      if (v239) {
                        int v241 = v225;
                      }
                      else {
                        int v241 = v223;
                      }
                      if (v240) {
                        int v237 = v222;
                      }
                    }
                    else
                    {
                      int v236 = *((__int16 *)v225 + 15);
                      int v237 = *((unsigned __int16 *)v225 + 15);
                      BOOL v242 = v222 != 0;
                      BOOL v243 = v222 < v237;
                      BOOL v244 = !v242 || !v243;
                      if (v242 && v243) {
                        int v241 = v223;
                      }
                      else {
                        int v241 = v225;
                      }
                      if (!v244) {
                        int v237 = v222;
                      }
                    }
                    if (v236 >= 1)
                    {
                      int v223 = v241;
                      int v222 = v237;
                    }
                    uint64_t v225 = (uint64_t *)*v225;
                  }
                  while (v225);
                }
                if (*(int *)v48 >= 1)
                {
                  uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
                  if ((SentTermCommList & 0x80000000) != 0) {
                    return SentTermCommList;
                  }
                  uint64_t SentTermCommList = mosyntbase_WString(a1, "accent normalization and accent limitation: ", 0);
                  if ((SentTermCommList & 0x80000000) != 0) {
                    return SentTermCommList;
                  }
                  uint64_t SentTermCommList = WriteBoundList(a1, v48, v279, 0);
                  if ((SentTermCommList & 0x80000000) != 0) {
                    return SentTermCommList;
                  }
                  uint64_t BestScenarioPathSuffix = mosyntbase_WLn(a1);
                }
                if ((BestScenarioPathSuffix & 0x80000000) != 0) {
                  return BestScenarioPathSuffix;
                }
                if (v279)
                {
                  uint64_t v245 = 0;
                  uint64_t v246 = v279;
                  do
                  {
                    int v247 = *((__int16 *)v246 + 4);
                    if ((v247 & 0x80000000) == 0)
                    {
                      if (v245)
                      {
                        unsigned int v248 = *((_DWORD *)v246 + 8);
                        BOOL v197 = v248 > 8;
                        int v249 = (1 << v248) & 0x1D0;
                        BOOL v250 = v197 || v249 == 0;
                        if (!v250 && v245 != v246)
                        {
                          uint64_t v252 = (uint64_t)v245;
                          do
                          {
                            if (*(_WORD *)(v252 + 30) == 2) {
                              *(_WORD *)(v252 + 30) = 3;
                            }
                            uint64_t v252 = *(void *)v252;
                          }
                          while ((uint64_t *)v252 != v246);
                        }
                      }
                      if ((unsigned __int16)v247 < 2u) {
                        uint64_t v245 = v246;
                      }
                    }
                    uint64_t v246 = (uint64_t *)*v246;
                  }
                  while (v246);
                }
                if (*(int *)v48 >= 1)
                {
                  uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
                  if ((SentTermCommList & 0x80000000) != 0) {
                    return SentTermCommList;
                  }
                  uint64_t SentTermCommList = mosyntbase_WString(a1, "reduction of pitch accents: ", 0);
                  if ((SentTermCommList & 0x80000000) != 0) {
                    return SentTermCommList;
                  }
                  uint64_t SentTermCommList = WriteBoundList(a1, v48, v279, 0);
                  if ((SentTermCommList & 0x80000000) != 0) {
                    return SentTermCommList;
                  }
                  uint64_t SentTermCommList = mosyntbase_WLn(a1);
                  if ((SentTermCommList & 0x80000000) != 0) {
                    return SentTermCommList;
                  }
                }
                if (v279)
                {
                  uint64_t v253 = *(void *)(v48 + 40);
                  if (v253)
                  {
                    uint64_t v254 = v279;
                    while (1)
                    {
                      unsigned int v255 = v254;
                      uint64_t v256 = *(void *)(v253 + 16 * *((int *)v254 + 4) + 8);
                      if (v256)
                      {
                        int v257 = *((__int16 *)v255 + 4);
                        if (v257 >= 2) {
                          int v257 = 2;
                        }
                        *(_DWORD *)(v256 + 8) = v257;
                        *(_DWORD *)(v256 + 12) = *((_DWORD *)v255 + 8);
                      }
                      uint64_t v254 = (uint64_t *)*v255;
                      if (!*v255) {
                        break;
                      }
                      uint64_t v258 = *(void *)(v253 + 16 * *((int *)v255 + 5));
                      if (v258)
                      {
                        int v259 = *((__int16 *)v255 + 15);
                        if (v259 >= 3) {
                          int v260 = 3;
                        }
                        else {
                          int v260 = v259;
                        }
                        if (v259 <= 98) {
                          int v261 = v260;
                        }
                        else {
                          int v261 = 0;
                        }
                        *(_DWORD *)(v258 + 16) = v261;
                      }
                    }
                  }
                }
                if (v279)
                {
                  do
                  {
                    *(void *)&long long v289 = v279;
                    uint64_t v279 = (uint64_t *)*v279;
                    uint64_t v263 = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v289);
                    uint64_t BestScenarioPathSuffix = v263;
                  }
                  while ((v263 & 0x80000000) == 0 && v279);
                  if ((v263 & 0x80000000) != 0) {
                    return BestScenarioPathSuffix;
                  }
                }
LABEL_557:
                uint64_t v214 = v280;
                uint64_t v215 = *(uint64_t **)(v280 + 32);
                *(void *)&long long v289 = v215;
                if (v215)
                {
                  while (2)
                  {
                    uint64_t v216 = (uint64_t *)*v215;
                    switch(*((_DWORD *)v215 + 2))
                    {
                      case 1:
                      case 4:
                        int v217 = v215 + 2;
                        uint64_t v218 = a1;
                        goto LABEL_565;
                      case 2:
                        int v217 = v215 + 2;
                        uint64_t v218 = a1;
                        goto LABEL_565;
                      case 3:
                        int v217 = v215 + 2;
                        uint64_t v218 = a1;
                        goto LABEL_565;
                      case 5:
                        int v217 = v215 + 2;
                        uint64_t v218 = a1;
                        goto LABEL_565;
                      case 6:
                      case 8:
                        int v217 = v215 + 2;
                        uint64_t v218 = a1;
                        goto LABEL_565;
                      case 7:
                        int v217 = v215 + 2;
                        uint64_t v218 = a1;
LABEL_565:
                        uint64_t SentTermCommList = mosyntpal_DEALLOCATE(v218, v217);
                        if ((SentTermCommList & 0x80000000) == 0) {
                          goto LABEL_566;
                        }
                        return SentTermCommList;
                      default:
LABEL_566:
                        uint64_t SentTermCommList = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v289);
                        if ((SentTermCommList & 0x80000000) != 0) {
                          return SentTermCommList;
                        }
                        *(void *)&long long v289 = v216;
                        uint64_t v215 = v216;
                        if (!v216) {
                          break;
                        }
                        continue;
                    }
                    break;
                  }
                }
                *(void *)(v214 + 32) = 0;
                return mosyntpal_DEALLOCATE(a1, &v280);
              }
              if (v208)
              {
                if (v210)
                {
                  int v210 = 0;
                  *((_DWORD *)v209 + 8) = 6;
                }
                else
                {
                  *((_DWORD *)v209 + 8) = 7;
                }
              }
              else
              {
                *((_DWORD *)v209 + 8) = 1;
              }
            }
            __int16 v209 = v211;
          }
          int v211 = v212;
          if (!v212) {
            goto LABEL_572;
          }
        }
      }
      if (v171)
      {
        int v178 = 9;
        goto LABEL_532;
      }
    }
    int v178 = 2;
    goto LABEL_532;
  }
  int v283 = 0;
  *(void *)(v280 + 80) = 0;
  *(void *)(v48 + 88) = 0;
  *(_DWORD *)(v48 + 72) = 0;
  NewAPVertex(a1, v48, *(_DWORD *)(a8 + 52), (uint64_t *)&v283);
  if ((SentTermCommList & 0x80000000) != 0) {
    return SentTermCommList;
  }
  *(void *)&long long v289 = 0;
  TreeToChart(a1, v48, a8, (uint64_t)v283, 0, (uint64_t *)&v289);
  if ((SentTermCommList & 0x80000000) != 0) {
    return SentTermCommList;
  }
  uint64_t v49 = (uint64_t *)&v283;
  if ((void)v289) {
    uint64_t v49 = (uint64_t *)(v289 + 24);
  }
  uint64_t v50 = (unsigned int *)*v49;
  if (v283 == (uint64_t *)*v49) {
    goto LABEL_557;
  }
  uint64_t SentTermCommList = SetFunctionWords(a1, v48, (uint64_t)v283, *v49);
  if ((SentTermCommList & 0x80000000) != 0) {
    return SentTermCommList;
  }
  uint64_t v281 = 0;
  uint64_t v51 = v283;
  if (*(int *)v48 >= 1)
  {
    uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
    if ((SentTermCommList & 0x80000000) != 0) {
      return SentTermCommList;
    }
    uint64_t SentTermCommList = mosyntbase_WriteMessage(a1, "[AccPhr] Sentence PoS and phonetic string:\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
    if ((SentTermCommList & 0x80000000) != 0) {
      return SentTermCommList;
    }
    uint64_t SentTermCommList = mosyntbase_WString(a1, "[AccPhr] ", 0);
    if ((SentTermCommList & 0x80000000) != 0) {
      return SentTermCommList;
    }
    uint64_t SentTermCommList = WriteCoverage(a1, v48, (unsigned int *)v51, v50);
    if ((SentTermCommList & 0x80000000) != 0) {
      return SentTermCommList;
    }
    uint64_t SentTermCommList = mosyntbase_WLn(a1);
    if ((SentTermCommList & 0x80000000) != 0) {
      return SentTermCommList;
    }
  }
  v282 = 0;
  if (v51 == (uint64_t *)v50)
  {
    v278 = (uint64_t *)(v48 + 16);
    goto LABEL_108;
  }
  do
  {
    uint64_t SentTermCommList = MatchEdge(a1, v48, v51[4], &v282, &v281);
    if ((SentTermCommList & 0x80000000) != 0) {
      return SentTermCommList;
    }
    for (uint64_t m = (void *)v51[6]; m; uint64_t m = (void *)*m)
    {
      uint64_t SentTermCommList = MatchEdge(a1, v48, (uint64_t)m, &v282, &v281);
      if ((SentTermCommList & 0x80000000) != 0) {
        return SentTermCommList;
      }
    }
    uint64_t v51 = (uint64_t *)v51[2];
  }
  while (v51 != (uint64_t *)v50);
  uint64_t v53 = v282;
  uint64_t v54 = *(void *)(v48 + 16);
  v278 = (uint64_t *)(v48 + 16);
  if (v282)
  {
    uint64_t BestScenarioPathSuffix = 0;
    do
    {
      if (IsMatchingRule(a1, v48, *((unsigned int *)v53 + 2), (void **)v53[3], v53[2]))
      {
        uint64_t BestScenarioPathSuffix = AddEdgeRule(a1, v48, *((_DWORD *)v53 + 2), v53[3]);
        if ((BestScenarioPathSuffix & 0x80000000) != 0) {
          return BestScenarioPathSuffix;
        }
        if ((int)mosyntkbaccphr_GetRule(0, v54, *((unsigned int *)v53 + 2)) >= 1)
        {
          uint64_t BestScenarioPathSuffix = AddRuleScenarios(a1, v48, *((unsigned int *)v53 + 2), (uint64_t *)(v53[2] + 40), &v281);
          if ((BestScenarioPathSuffix & 0x80000000) != 0) {
            return BestScenarioPathSuffix;
          }
        }
      }
      uint64_t v53 = (uint64_t *)*v53;
    }
    while (v53);
    if ((BestScenarioPathSuffix & 0x80000000) != 0) {
      return BestScenarioPathSuffix;
    }
  }
LABEL_108:
  uint64_t v61 = v281;
  uint64_t v62 = v283;
  if (v281)
  {
    uint64_t v63 = 0;
    int v295 = 0;
    long long v293 = 0u;
    long long v294 = 0u;
    long long v291 = 0u;
    long long v292 = 0u;
    long long v289 = 0u;
    long long v290 = 0u;
    do
    {
      uint64_t BestScenarioPathSuffix = mosyntkbsymtab_AtomSymString(a1, *(uint64_t **)(v48 + 8), *(_DWORD *)(v61 + 8), (char *)&v289, 100);
      if ((BestScenarioPathSuffix & 0x80000000) != 0) {
        return BestScenarioPathSuffix;
      }
      if (v62 != (uint64_t *)v50)
      {
        char v64 = 1;
        char v65 = v62;
        do
        {
          uint64_t v66 = (uint64_t)v65;
          while (1)
          {
            uint64_t v67 = *(void **)(v66 + 48);
            int v68 = *(_DWORD *)(v61 + 8);
            if (v67)
            {
              do
              {
                uint64_t v69 = v67;
                uint64_t v70 = v67[5];
                if (v70)
                {
                  while (1)
                  {
                    int v71 = *(_DWORD *)(v70 + 8);
                    if (v71 >= v68) {
                      break;
                    }
                    uint64_t v70 = *(void *)v70;
                    if (!v70) {
                      goto LABEL_120;
                    }
                  }
                  LOBYTE(v70) = v71 == v68;
                }
LABEL_120:
                if (v70) {
                  break;
                }
                uint64_t v67 = (void *)*v69;
              }
              while (*v69);
              if (v70) {
                break;
              }
            }
            uint64_t v72 = *(void *)(v66 + 32);
            uint64_t v73 = *(uint64_t **)(v72 + 40);
            if (v73)
            {
              char v65 = *(uint64_t **)(v72 + 24);
              while (1)
              {
                int v74 = *((_DWORD *)v73 + 2);
                if (v74 >= v68) {
                  break;
                }
                uint64_t v73 = (uint64_t *)*v73;
                if (!v73) {
                  goto LABEL_129;
                }
              }
              if (v74 == v68) {
                goto LABEL_134;
              }
            }
LABEL_129:
            if ((v64 & 1) == 0)
            {
              uint64_t BestScenarioPathSuffix = AddSegment(a1, v48, v68, v63, (_DWORD *)v66);
              if ((BestScenarioPathSuffix & 0x80000000) != 0) {
                return BestScenarioPathSuffix;
              }
            }
            uint64_t v66 = *(void *)(v66 + 16);
            char v64 = 1;
            if ((unsigned int *)v66 == v50) {
              goto LABEL_138;
            }
          }
          char v65 = (uint64_t *)v69[3];
LABEL_134:
          BOOL v163 = (v64 & 1) == 0;
          char v64 = 0;
          if (!v163) {
            uint64_t v63 = v66;
          }
        }
        while (v65 != (uint64_t *)v50);
        uint64_t BestScenarioPathSuffix = AddSegment(a1, v48, v68, v63, v50);
        if ((BestScenarioPathSuffix & 0x80000000) != 0) {
          return BestScenarioPathSuffix;
        }
      }
LABEL_138:
      uint64_t v61 = *(void *)v61;
    }
    while (v61);
    if ((BestScenarioPathSuffix & 0x80000000) != 0) {
      return BestScenarioPathSuffix;
    }
    uint64_t v62 = v283;
  }
  uint64_t v284 = 0;
  uint64_t v286 = 0;
  int v285 = 0;
  int v288 = 0;
  memset(v287, 0, sizeof(v287));
  uint64_t BestScenarioPathSuffix = GetBestScenarioPathSuffix(a1, (void *)v48, 0, (uint64_t)v62, (uint64_t)v50, (int *)&v286 + 1, &v286, &v285, &v284);
  if ((BestScenarioPathSuffix & 0x80000000) != 0) {
    return BestScenarioPathSuffix;
  }
  int v269 = v50;
  BOOL v75 = (void *)v284;
  if (*(int *)v48 >= 1)
  {
    uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
    if ((SentTermCommList & 0x80000000) == 0)
    {
      uint64_t BestScenarioPathSuffix = mosyntbase_WriteMessage(a1, "[AccPhr] Optimal Scenario Combination:\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
      if ((BestScenarioPathSuffix & 0x80000000) != 0) {
        return BestScenarioPathSuffix;
      }
      goto LABEL_145;
    }
    return SentTermCommList;
  }
LABEL_145:
  if (v75)
  {
    while (1)
    {
      if (*(int *)v48 >= 1 && v62 != *(uint64_t **)(v75[1] + 8))
      {
        uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
        if ((SentTermCommList & 0x80000000) != 0) {
          return SentTermCommList;
        }
        uint64_t SentTermCommList = mosyntbase_WString(a1, "[AccPhr] No scenario covering: ", 0);
        if ((SentTermCommList & 0x80000000) != 0) {
          return SentTermCommList;
        }
        uint64_t SentTermCommList = WriteCoverage(a1, v48, (unsigned int *)v62, *(unsigned int **)(v75[1] + 8));
        if ((SentTermCommList & 0x80000000) != 0) {
          return SentTermCommList;
        }
        uint64_t BestScenarioPathSuffix = mosyntbase_WLn(a1);
        if ((BestScenarioPathSuffix & 0x80000000) != 0) {
          return BestScenarioPathSuffix;
        }
      }
      uint64_t v76 = v75[1];
      uint64_t v77 = *(uint64_t **)(v76 + 8);
      if (v62 != v77)
      {
        do
        {
          *((_DWORD *)v62 + 20) = 0;
          uint64_t v62 = (uint64_t *)v62[2];
        }
        while (v62 != v77);
        uint64_t v62 = v77;
      }
      if (*(int *)v48 >= 1) {
        break;
      }
      while (v62 != *(uint64_t **)(v76 + 16))
      {
        unsigned int v79 = *(_DWORD *)(v76 + 24);
        *((_DWORD *)v62 + 20) = v79;
        uint64_t BestScenarioPathSuffix = mosyntkbsymtab_AtomSymString(a1, *(uint64_t **)(v48 + 8), v79, (char *)v287, 100);
        if ((BestScenarioPathSuffix & 0x80000000) != 0) {
          return BestScenarioPathSuffix;
        }
        uint64_t v62 = (uint64_t *)v62[2];
LABEL_163:
        uint64_t v76 = v75[1];
      }
      BOOL v75 = (void *)*v75;
      if (!v75) {
        goto LABEL_168;
      }
    }
    uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
    if ((SentTermCommList & 0x80000000) == 0)
    {
      uint64_t SentTermCommList = mosyntbase_WString(a1, "[AccPhr] Scenario '", 0);
      if ((SentTermCommList & 0x80000000) == 0)
      {
        unsigned int v78 = *(_DWORD *)(v75[1] + 24);
        int v295 = 0;
        long long v293 = 0u;
        long long v294 = 0u;
        long long v291 = 0u;
        long long v292 = 0u;
        long long v289 = 0u;
        long long v290 = 0u;
        uint64_t SentTermCommList = mosyntkbsymtab_AtomSymString(a1, *(uint64_t **)(v48 + 8), v78, (char *)&v289, 100);
        if ((SentTermCommList & 0x80000000) == 0)
        {
          uint64_t SentTermCommList = mosyntbase_WString(a1, (unsigned __int8 *)&v289, 100);
          if ((SentTermCommList & 0x80000000) == 0)
          {
            uint64_t SentTermCommList = mosyntbase_WString(a1, "' covers: ", 0);
            if ((SentTermCommList & 0x80000000) == 0)
            {
              uint64_t SentTermCommList = WriteCoverage(a1, v48, *(unsigned int **)(v75[1] + 8), *(unsigned int **)(v75[1] + 16));
              if ((SentTermCommList & 0x80000000) == 0)
              {
                uint64_t BestScenarioPathSuffix = mosyntbase_WLn(a1);
                if ((BestScenarioPathSuffix & 0x80000000) != 0) {
                  return BestScenarioPathSuffix;
                }
                goto LABEL_163;
              }
            }
          }
        }
      }
    }
    return SentTermCommList;
  }
LABEL_168:
  if (v62 != (uint64_t *)v269 && *(int *)v48 >= 1)
  {
    uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
    if ((SentTermCommList & 0x80000000) != 0) {
      return SentTermCommList;
    }
    uint64_t SentTermCommList = mosyntbase_WString(a1, "[AccPhr] No scenario covering: ", 0);
    if ((SentTermCommList & 0x80000000) != 0) {
      return SentTermCommList;
    }
    uint64_t SentTermCommList = WriteCoverage(a1, v48, (unsigned int *)v62, v269);
    if ((SentTermCommList & 0x80000000) != 0) {
      return SentTermCommList;
    }
    uint64_t BestScenarioPathSuffix = mosyntbase_WLn(a1);
    if ((BestScenarioPathSuffix & 0x80000000) != 0) {
      return BestScenarioPathSuffix;
    }
  }
  while (v62 != (uint64_t *)v269)
  {
    *((_DWORD *)v62 + 20) = 0;
    uint64_t v62 = (uint64_t *)v62[2];
  }
  if ((BestScenarioPathSuffix & 0x80000000) != 0) {
    return BestScenarioPathSuffix;
  }
  uint64_t v100 = v283;
  if (v283 == (uint64_t *)v269)
  {
    uint64_t BestScenarioPathSuffix = 0;
    goto LABEL_434;
  }
  uint64_t BestScenarioPathSuffix = 0;
  uint64_t v272 = *v278;
  int v101 = v283;
  unsigned int v264 = v283;
  do
  {
    uint64_t v102 = v101[6];
    BOOL v265 = v102 == 0;
    v276 = v101;
    if (!v102)
    {
      uint64_t v102 = v101[4];
      if (!v102) {
        goto LABEL_407;
      }
    }
    do
    {
      uint64_t v103 = *(void **)(v102 + 32);
      uint64_t v104 = v272;
      if (!v103) {
        goto LABEL_400;
      }
      do
      {
        uint64_t v270 = (void **)v103;
        unsigned int v105 = (uint64_t *)v103[2];
        if (!v105) {
          goto LABEL_399;
        }
        do
        {
          if ((int)mosyntkbaccphr_GetRule(0, v104, *((unsigned int *)v105 + 2)) < 1) {
            goto LABEL_398;
          }
          int Rule = mosyntkbaccphr_GetRule(0, v104, *((unsigned int *)v105 + 2));
          int v107 = *((_DWORD *)v276 + 20);
          uint64_t v108 = *v278;
          for (uint64_t n = mosyntkbaccphr_AccPhrScenarios(*v278); ; uint64_t n = mosyntkbaccphr_GetScenario(3, v108, v110))
          {
            uint64_t v110 = n;
            uint64_t Scenario = mosyntkbaccphr_Nil(n);
            if (v110 == Scenario) {
              break;
            }
            uint64_t Scenario = mosyntkbaccphr_GetScenario(1, v108, v110);
            if (Scenario == v107) {
              break;
            }
          }
          if (v110 == mosyntkbaccphr_Nil(Scenario)) {
            goto LABEL_398;
          }
          uint64_t RuleSet = mosyntkbaccphr_GetScenario(2, v108, v110);
          if (RuleSet == mosyntkbaccphr_Nil(RuleSet)) {
            goto LABEL_398;
          }
          do
          {
            if (mosyntkbaccphr_GetRuleSetIsSubset(v108, RuleSet)) {
              BOOL v113 = 0;
            }
            else {
              BOOL v113 = mosyntkbaccphr_GetRuleSet(1, v108, RuleSet) == Rule;
            }
            uint64_t RuleSet = mosyntkbaccphr_GetRuleSet(4, v108, RuleSet);
          }
          while (RuleSet != mosyntkbaccphr_Nil(RuleSet) && !v113);
          if (!v113) {
            goto LABEL_398;
          }
          if (*(int *)v48 >= 1)
          {
            uint64_t SentTermCommList = mosyntbase_WriteMessage(a1, "[AccPhr]\\n[AccPhr] <<<< Applying rule:\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
            if ((SentTermCommList & 0x80000000) != 0) {
              return SentTermCommList;
            }
            uint64_t SentTermCommList = mosyntbase_WString(a1, "[AccPhr] ", 0);
            if ((SentTermCommList & 0x80000000) != 0) {
              return SentTermCommList;
            }
            uint64_t SentTermCommList = mosyntkbaccphr_WriteRuleHeadline(a1, *(uint64_t **)(v48 + 8), v272, *((_DWORD *)v105 + 2));
            if ((SentTermCommList & 0x80000000) != 0) {
              return SentTermCommList;
            }
            uint64_t SentTermCommList = mosyntbase_WLn(a1);
            if ((SentTermCommList & 0x80000000) != 0) {
              return SentTermCommList;
            }
            uint64_t SentTermCommList = mosyntbase_WriteMessage(a1, "[AccPhr] Node Covers:\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
            if ((SentTermCommList & 0x80000000) != 0) {
              return SentTermCommList;
            }
            uint64_t SentTermCommList = mosyntbase_WString(a1, "[AccPhr] ", 0);
            if ((SentTermCommList & 0x80000000) != 0) {
              return SentTermCommList;
            }
            uint64_t SentTermCommList = WriteCoverage(a1, v48, *(unsigned int **)(v102 + 16), *(unsigned int **)(v102 + 24));
            if ((SentTermCommList & 0x80000000) != 0) {
              return SentTermCommList;
            }
            uint64_t SentTermCommList = mosyntbase_WLn(a1);
            uint64_t v104 = v272;
            if ((SentTermCommList & 0x80000000) != 0) {
              return SentTermCommList;
            }
          }
          uint64_t v114 = mosyntkbaccphr_GetRule(12, v104, *((unsigned int *)v105 + 2));
          *(void *)&long long v289 = 0;
          int v285 = 0;
          LODWORD(v286) = 0;
          *(void *)&v287[0] = 0;
          uint64_t v284 = 0;
          uint64_t v115 = *v278;
          if (mosyntkbaccphr_Nil(v114) == v114) {
            goto LABEL_288;
          }
          uint64_t v267 = 0;
          uint64_t BestScenarioPathSuffix = 0;
          uint64_t v274 = v115;
          do
          {
            mosyntkbaccphr_GetInstrType(v115, v114);
            if (mosyntkbaccphr_GetInstrType(v115, v114) > 6) {
              goto LABEL_379;
            }
            *(void *)&long long v289 = v102;
            uint64_t Instr = mosyntkbaccphr_GetInstr(0, v115, v114);
            if (!mosyntkbaccphr_GetNode(3, v115, Instr)) {
              goto LABEL_319;
            }
            uint64_t v125 = mosyntkbaccphr_GetInstr(0, v115, v114);
            if (mosyntkbaccphr_GetNodeMatchOp(v115, v125))
            {
              int v126 = mosyntkbaccphr_GetInstr(0, v115, v114);
              unsigned int v127 = *v270;
              HIDWORD(v286) = v126;
              if (v127)
              {
                do
                {
                  int v128 = IsMatchingNode(a1, v48, (unsigned int *)&v286 + 1, (uint64_t)v127);
                  if (v128) {
                    break;
                  }
                  unsigned int v127 = (void *)*v127;
                }
                while (v127);
                uint64_t v115 = v274;
                if (v128) {
                  goto LABEL_319;
                }
              }
              else
              {
                uint64_t v115 = v274;
              }
            }
            uint64_t v129 = mosyntkbaccphr_GetInstr(0, v115, v114);
            if ((mosyntkbaccphr_GetNodeMatchOp(v115, v129) & 2) == 0 || !*(void *)(v102 + 72))
            {
LABEL_375:
              uint64_t v115 = v274;
              goto LABEL_379;
            }
            uint64_t InstrRight = mosyntkbaccphr_GetInstrRight(v274, v114);
            if (InstrRight)
            {
              uint64_t v131 = *(void **)(v102 + 72);
              do
              {
                unsigned int v132 = v131;
                uint64_t v131 = (void *)v131[7];
              }
              while (v131);
              uint64_t v133 = mosyntkbaccphr_GetInstr(0, v274, v114);
              int v134 = IsRightMatchingTarget(a1, v48, v133, v132, &v289);
            }
            else
            {
              uint64_t v135 = mosyntkbaccphr_GetInstr(InstrRight, v274, v114);
              int v134 = IsLeftMatchingTarget(a1, v48, v135, *(void **)(v102 + 72), &v289);
            }
            uint64_t v115 = v274;
            if (v134)
            {
LABEL_319:
              if (*(int *)v48 >= 1)
              {
                uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
                if ((SentTermCommList & 0x80000000) != 0) {
                  return SentTermCommList;
                }
                uint64_t SentTermCommList = mosyntbase_WStringLn(a1, "[AccPhr]", 0);
                if ((SentTermCommList & 0x80000000) != 0) {
                  return SentTermCommList;
                }
                uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
                if ((SentTermCommList & 0x80000000) != 0) {
                  return SentTermCommList;
                }
                uint64_t SentTermCommList = mosyntbase_WString(a1, "[AccPhr] --> Instruction ", 0);
                if ((SentTermCommList & 0x80000000) != 0) {
                  return SentTermCommList;
                }
                uint64_t v115 = v274;
                uint64_t BestScenarioPathSuffix = mosyntkbaccphr_WriteInstruction(a1, *(uint64_t **)(v48 + 8), v274, v114);
                if ((BestScenarioPathSuffix & 0x80000000) != 0) {
                  return BestScenarioPathSuffix;
                }
              }
              int InstrType = mosyntkbaccphr_GetInstrType(v115, v114);
              if ((InstrType - 3) >= 3)
              {
                if (InstrType == 2)
                {
                  if (mosyntkbaccphr_GetInstrRight(v274, v114)) {
                    int v140 = (long long *)(*(void *)(v289 + 24) + 24);
                  }
                  else {
                    int v140 = &v289;
                  }
                  char v141 = 0;
                  uint64_t v143 = *(void *)(*(void *)v140 + 16);
                  uint64_t v267 = *(void *)(v143 + 32);
                  *(_DWORD *)(v143 + 84) = 1;
                }
                else if (InstrType)
                {
                  char v141 = 1;
                }
                else
                {
                  if (mosyntkbaccphr_GetInstrRight(v274, v114))
                  {
                    uint64_t v138 = *(void *)(v289 + 24);
                    int v139 = (uint64_t *)(v138 + 24);
                  }
                  else
                  {
                    uint64_t v138 = *(void *)(v289 + 16);
                    int v139 = (uint64_t *)(v138 + 32);
                  }
                  uint64_t v267 = *v139;
                  if (mosyntkbaccphr_GetInstr(2, v274, v114))
                  {
                    if (mosyntkbaccphr_GetInstr(2, v274, v114) == 1) {
                      int v142 = 5;
                    }
                    else {
                      int v142 = mosyntkbaccphr_GetInstr(2, v274, v114);
                    }
                    LODWORD(v286) = v142;
                    if (*(unsigned __int16 *)(v138 + 68) < 2u) {
                      goto LABEL_370;
                    }
                    *(_WORD *)(v138 + 68) = 1;
                    if (v142 <= *(_DWORD *)(v138 + 72)) {
                      goto LABEL_370;
                    }
                    char v141 = 0;
                    *(_DWORD *)(v138 + 72) = v142;
                  }
                  else
                  {
                    if ((*(__int16 *)(v138 + 68) & 0x80000000) == 0) {
                      goto LABEL_370;
                    }
                    char v141 = 0;
                    *(_WORD *)(v138 + 68) = 2;
                  }
                }
              }
              else
              {
                if (mosyntkbaccphr_GetInstrTargetRange(v115, v114)
                  && mosyntkbaccphr_GetInstrTargetRange(v115, v114) == 1)
                {
                  if (mosyntkbaccphr_GetInstrRight(v115, v114)) {
                    uint64_t v137 = *(void *)(*(void *)(v289 + 24) + 24);
                  }
                  else {
                    uint64_t v137 = *(void *)(*(void *)(v289 + 16) + 32);
                  }
                  *(void *)&long long v289 = v137;
                  uint64_t v115 = v274;
                }
                uint64_t v267 = v289;
                uint64_t v144 = *(void *)(v289 + 16);
                int v145 = mosyntkbaccphr_GetInstrType(v115, v114);
                if (v145 == 4) {
                  int v146 = 2;
                }
                else {
                  int v146 = 1;
                }
                if (v145 == 5) {
                  int v147 = 3;
                }
                else {
                  int v147 = v146;
                }
                int v148 = mosyntkbaccphr_GetInstr(2, v115, v114);
                uint64_t SentTermCommList = mosyntdata_EncodeSymbolicValue(a1, v148, 0, &v286);
                if ((SentTermCommList & 0x80000000) != 0) {
                  return SentTermCommList;
                }
                int v149 = mosyntkbaccphr_GetInstr(2, v274, v114);
                uint64_t BestScenarioPathSuffix = mosyntdata_EncodeSymbolicValue(a1, v149, 1, &v285);
                if ((BestScenarioPathSuffix & 0x80000000) != 0) {
                  return BestScenarioPathSuffix;
                }
                do
                {
                  uint64_t v150 = mosyntdata_SentTermBoundData(a1, *(void *)(v48 + 40), *(_DWORD *)(*(void *)(v144 + 32) + 84));
                  if (v150)
                  {
                    int v151 = (void *)v150;
                    uint64_t SentTermCommList = mosyntdata_NewCommand(a1, &v284);
                    if ((SentTermCommList & 0x80000000) != 0) {
                      return SentTermCommList;
                    }
                    uint64_t v152 = v284;
                    int v153 = v286;
                    *(_DWORD *)(v284 + 8) = v147;
                    *(_DWORD *)(v152 + 12) = v153;
                    *(void *)&v287[0] = mosyntdata_LastPhonEle(a1, (void *)*v151);
                    uint64_t BestScenarioPathSuffix = mosyntdata_AppendPhonList(a1, v151, v287, v284, v284);
                    if ((BestScenarioPathSuffix & 0x80000000) != 0) {
                      return BestScenarioPathSuffix;
                    }
                  }
                  uint64_t v144 = *(void *)(v144 + 16);
                  uint64_t v154 = mosyntdata_SentTermBoundData(a1, *(void *)(v48 + 40), *(_DWORD *)(v144 + 64));
                  if (v154)
                  {
                    uint64_t v155 = (void **)v154;
                    uint64_t SentTermCommList = mosyntdata_NewCommand(a1, &v284);
                    if ((SentTermCommList & 0x80000000) != 0) {
                      return SentTermCommList;
                    }
                    uint64_t v156 = v284;
                    int v157 = v285;
                    *(_DWORD *)(v284 + 8) = v147;
                    *(_DWORD *)(v156 + 12) = v157;
                    *(void *)&v287[0] = mosyntdata_LastPhonEle(a1, *v155);
                    uint64_t v158 = v284;
                    if (v284 && (*(void *)v284 = *v155, *uint64_t v155 = (void *)v158, !*(void *)&v287[0]))
                    {
                      uint64_t BestScenarioPathSuffix = 0;
                      *(void *)&v287[0] = v158;
                    }
                    else
                    {
                      uint64_t BestScenarioPathSuffix = 0;
                    }
                  }
                }
                while (v144 != *(void *)(v289 + 24));
LABEL_370:
                char v141 = 0;
              }
              if (*(int *)v48 < 1) {
                goto LABEL_375;
              }
              uint64_t SentTermCommList = mosyntbase_WString(a1, " : ", 0);
              if ((SentTermCommList & 0x80000000) != 0) {
                return SentTermCommList;
              }
              if (v141)
              {
                uint64_t v159 = mosyntbase_WStringLn(a1, " not implemented yet!", 0);
              }
              else
              {
                uint64_t SentTermCommList = WriteCoverage(a1, v48, *(unsigned int **)(v267 + 16), *(unsigned int **)(v267 + 24));
                if ((SentTermCommList & 0x80000000) != 0) {
                  return SentTermCommList;
                }
                uint64_t v159 = mosyntbase_WLn(a1);
              }
              uint64_t BestScenarioPathSuffix = v159;
              uint64_t v115 = v274;
              if ((v159 & 0x80000000) != 0) {
                return BestScenarioPathSuffix;
              }
            }
LABEL_379:
            uint64_t v114 = mosyntkbaccphr_GetInstr(6, v115, v114);
          }
          while (v114 != mosyntkbaccphr_Nil(v114));
          uint64_t v104 = v272;
          if ((BestScenarioPathSuffix & 0x80000000) != 0) {
            return BestScenarioPathSuffix;
          }
LABEL_288:
          uint64_t v116 = mosyntkbaccphr_GetRule(13, v104, *((unsigned int *)v105 + 2));
          uint64_t v117 = *v278;
          Childreuint64_t n = mosyntkbaccphr_Nil(v116);
          LODWORD(v119) = v116;
          if (v116 != Children)
          {
            uint64_t v119 = v116;
            do
            {
              uint64_t v120 = *(void *)(v102 + 16);
              Childreuint64_t n = mosyntkbaccphr_GetChildren(1, v117, v116);
              LODWORD(v289) = Children;
              if (v120 == *(void *)(v102 + 24)) {
                break;
              }
              uint64_t v121 = Children;
              do
              {
                Childreuint64_t n = mosyntkbaccphr_Nil(Children);
                if (v121 == Children) {
                  break;
                }
                uint64_t v122 = *(void **)(*(void *)(v120 + 32) + 32);
                do
                {
                  uint64_t v123 = (uint64_t)v122;
                  uint64_t v122 = (void *)*v122;
                }
                while (v122);
                Childreuint64_t n = IsMatchingNode(a1, v48, (unsigned int *)&v289, v123);
                if (!Children) {
                  break;
                }
                uint64_t v120 = *(void *)(v120 + 16);
                Childreuint64_t n = mosyntkbaccphr_GetNode(8, v117, v121);
                uint64_t v121 = Children;
                LODWORD(v289) = Children;
              }
              while (v120 != *(void *)(v102 + 24));
              if (v120 == *(void *)(v102 + 24)) {
                break;
              }
              uint64_t v119 = mosyntkbaccphr_GetChildren(2, v117, v119);
              Childreuint64_t n = mosyntkbaccphr_Nil(v119);
            }
            while (v119 != Children);
          }
          if (v119 == mosyntkbaccphr_Nil(Children))
          {
            uint64_t BestScenarioPathSuffix = 0;
            goto LABEL_395;
          }
          if (*(int *)v48 < 1)
          {
            uint64_t BestScenarioPathSuffix = 0;
            goto LABEL_390;
          }
          uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
          if ((SentTermCommList & 0x80000000) != 0) {
            return SentTermCommList;
          }
          uint64_t SentTermCommList = mosyntbase_WStringLn(a1, "[AccPhr]", 0);
          if ((SentTermCommList & 0x80000000) != 0) {
            return SentTermCommList;
          }
          uint64_t SentTermCommList = mosyntknowl_WriteTraceHeader(a1, 4u);
          if ((SentTermCommList & 0x80000000) != 0) {
            return SentTermCommList;
          }
          uint64_t SentTermCommList = mosyntbase_WString(a1, "[AccPhr] --> Template ", 0);
          if ((SentTermCommList & 0x80000000) != 0) {
            return SentTermCommList;
          }
          uint64_t BestScenarioPathSuffix = mosyntkbaccphr_WritePromTemplate(a1, *(uint64_t **)(v48 + 8), v117, v119);
          if ((BestScenarioPathSuffix & 0x80000000) != 0) {
            return BestScenarioPathSuffix;
          }
LABEL_390:
          uint64_t v160 = *(void *)(v102 + 16);
          uint64_t v161 = mosyntkbaccphr_GetChildren(1, v117, v116);
          if (v160 == *(void *)(v102 + 24))
          {
LABEL_395:
            uint64_t v104 = v272;
          }
          else
          {
            uint64_t Node = v161;
            do
            {
              *(_DWORD *)(v160 + 84) = mosyntkbaccphr_GetNode(2, v117, Node);
              uint64_t v160 = *(void *)(v160 + 16);
              uint64_t Node = mosyntkbaccphr_GetNode(8, v117, Node);
            }
            while (v160 != *(void *)(v102 + 24));
            uint64_t v104 = v272;
            if ((BestScenarioPathSuffix & 0x80000000) != 0) {
              return BestScenarioPathSuffix;
            }
          }
          if (*(int *)v48 >= 1)
          {
            uint64_t BestScenarioPathSuffix = mosyntbase_WriteMessage(a1, "[AccPhr] End rule.>>>>>\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
            if ((BestScenarioPathSuffix & 0x80000000) != 0) {
              return BestScenarioPathSuffix;
            }
          }
LABEL_398:
          unsigned int v105 = (uint64_t *)*v105;
        }
        while (v105);
LABEL_399:
        uint64_t v103 = *v270;
      }
      while (*v270);
LABEL_400:
      uint64_t v102 = *(void *)v102;
      if (v102) {
        BOOL v163 = 0;
      }
      else {
        BOOL v163 = !v265;
      }
      if (v163)
      {
        uint64_t v102 = v276[4];
        BOOL v265 = 1;
      }
    }
    while (v102);
LABEL_407:
    int v101 = (uint64_t *)v276[2];
    uint64_t v100 = v264;
  }
  while (v101 != (uint64_t *)v269);
LABEL_434:
  *((_WORD *)v100 + 34) = 0;
  *(void *)&long long v289 = 0;
  if (v269)
  {
    mosyntdata_GetSentTermCommList(a1, *(void *)(v48 + 40), v269[16], &v289);
    int v170 = (uint64_t *)v289;
  }
  else
  {
    int v170 = 0;
  }
  *((_WORD *)v269 + 34) = FinalBoundaryIndex(a1, v170);
  if ((BestScenarioPathSuffix & 0x80000000) != 0) {
    return BestScenarioPathSuffix;
  }
  int v266 = v283;
  if (!v283)
  {
    uint64_t BestScenarioPathSuffix = 0;
    goto LABEL_548;
  }
  uint64_t v179 = 0;
  BOOL v180 = 0;
  __int16 v181 = 0;
  uint64_t BestScenarioPathSuffix = 0;
  LODWORD(v284) = 0;
  *(void *)&long long v289 = 0;
  *(void *)&v287[0] = 0;
  int v182 = v283;
  while (2)
  {
    uint64_t v271 = v182;
    if ((*((__int16 *)v182 + 34) & 0x80000000) == 0)
    {
      if (!v180 || v179)
      {
LABEL_498:
        if (v179) {
          goto LABEL_505;
        }
        __int16 v181 = v180;
        BOOL v180 = v182;
      }
      else
      {
        if (v180 == v182) {
          goto LABEL_495;
        }
        uint64_t v179 = 0;
        int v183 = -1;
        int v268 = v180;
        do
        {
          int v275 = v183;
          uint64_t v277 = v179;
          uint64_t v273 = v180;
          BOOL v184 = *(void **)(v180[4] + 32);
          do
          {
            uint64_t v185 = v184;
            BOOL v184 = (void *)*v184;
          }
          while (v184);
          uint64_t v186 = *v278;
          uint64_t v187 = mosyntkbaccphr_AccPhrHierarchy(*v278);
          BYTE4(v286) = 0;
          uint64_t v188 = mosyntkbaccphr_Nil(v187);
          if (v187 == v188)
          {
            int v189 = 0;
          }
          else
          {
            int v189 = 0;
            do
            {
              uint64_t v190 = v185[1];
              int v191 = *(__int16 *)(v190 + 16);
              int v192 = (unsigned __int16 *)(v190 + 24);
              int ConsList = mosyntkbaccphr_GetConsList(0, v186, v187);
              unsigned int v194 = mosyntkbaccphr_GetConsList(1, v186, v187);
              uint64_t v195 = mosyntkbaccphr_CheckMatchingConsFeat3(a1, v186, v191, v192, ConsList, v194, (char *)&v286 + 4);
              if (!BYTE4(v286))
              {
                ++v189;
                uint64_t v195 = mosyntkbaccphr_GetConsList(2, v186, v187);
                uint64_t v187 = v195;
              }
              uint64_t v188 = mosyntkbaccphr_Nil(v195);
            }
            while (v187 != v188 && !BYTE4(v286));
          }
          if (v187 == mosyntkbaccphr_Nil(v188)) {
            int v196 = -1;
          }
          else {
            int v196 = v189;
          }
          int v183 = v275;
          BOOL v197 = v275 < 0 || v196 < v275;
          int v198 = v197;
          BOOL v199 = v198 == 0;
          int v182 = v271;
          uint64_t v179 = v277;
          if (v198) {
            uint64_t v200 = (uint64_t)v271;
          }
          else {
            uint64_t v200 = v277;
          }
          if (v199) {
            int v201 = v275;
          }
          else {
            int v201 = v196;
          }
          if (v196 >= 0)
          {
            uint64_t v179 = v200;
            int v183 = v201;
          }
          BOOL v180 = (uint64_t *)v273[2];
        }
        while (v180 != v271);
        BOOL v180 = v268;
        if (!v179)
        {
LABEL_495:
          uint64_t v179 = (uint64_t)v180;
          if (mosyntkbaccphr_AccPhrDefaultEmph(*v278) == 1) {
            goto LABEL_498;
          }
          if (mosyntkbaccphr_AccPhrDefaultEmph(*v278) == 2)
          {
            int v182 = v271;
            uint64_t v179 = v271[1];
            goto LABEL_498;
          }
          int v202 = *(_DWORD *)v180;
          int v182 = v271;
          int v203 = *(_DWORD *)v271 + *(_DWORD *)v180;
          if (*(_DWORD *)v271 + v202 < 0 != __OFADD__(*(_DWORD *)v271, v202)) {
            ++v203;
          }
          uint64_t v179 = (uint64_t)v180;
          if (v202 != v203 >> 1)
          {
            int v204 = v203 >> 1;
            uint64_t v179 = (uint64_t)v180;
            do
              uint64_t v179 = *(void *)(v179 + 16);
            while (*(_DWORD *)v179 != v204);
          }
        }
LABEL_505:
        *(_DWORD *)(v179 + 84) = 1;
        __int16 v181 = v180;
        BOOL v180 = v182;
        uint64_t v179 = 0;
      }
    }
    if (*((_DWORD *)v182 + 21) == 1)
    {
      if (v179)
      {
        if (mosyntkbaccphr_AccPhrDefaultEmph(*v278) == 1)
        {
          int v205 = 3;
        }
        else
        {
          *(_DWORD *)(v179 + 84) = -1;
          uint64_t BestScenarioPathSuffix = SetFunctionWords(a1, v48, v179, *(void *)(v179 + 16));
          if ((BestScenarioPathSuffix & 0x80000000) != 0) {
            return BestScenarioPathSuffix;
          }
          if (*(_DWORD *)(v179 + 84) == -1) {
            *(_DWORD *)(v179 + 84) = 3;
          }
          int v205 = 1;
          int v182 = v271;
          uint64_t v179 = (uint64_t)v271;
        }
        *((_DWORD *)v182 + 21) = v205;
      }
      else
      {
        uint64_t v179 = (uint64_t)v182;
      }
    }
    int v182 = (uint64_t *)v182[2];
    if (v182) {
      continue;
    }
    break;
  }
  if (!v180) {
    goto LABEL_548;
  }
  *((_DWORD *)v180 + 19) = 0;
  if (!v181 || *((_DWORD *)v181 + 19)) {
    goto LABEL_548;
  }
  uint64_t SentTermCommList = mosyntdata_GetSentTermCommList(a1, *(void *)(v48 + 40), *((_DWORD *)v180 + 16), v287);
  if ((SentTermCommList & 0x80000000) != 0) {
    return SentTermCommList;
  }
  uint64_t BestScenarioPathSuffix = mosyntdata_GetPunctFromCommandList(a1, *(uint64_t **)&v287[0], &v284, &v289);
  if ((BestScenarioPathSuffix & 0x80000000) == 0)
  {
    int v206 = v284 == 11 ? 9 : 2;
    int v207 = v284 == 10 ? 4 : v206;
    *((_DWORD *)v181 + 19) = v207;
LABEL_548:
    for (iint i = v266; ii != (uint64_t *)v269; iint i = (uint64_t *)ii[2])
    {
      if (*((_DWORD *)ii + 21) == -1) {
        *((_DWORD *)ii + 21) = 3;
      }
      if ((*((__int16 *)ii + 34) & 0x80000000) == 0 && !*((_DWORD *)ii + 19)) {
        *((_DWORD *)ii + 19) = 1;
      }
    }
    if ((BestScenarioPathSuffix & 0x80000000) == 0)
    {
      ChartToSentTermData(v48, (uint64_t)v283);
      goto LABEL_557;
    }
  }
  return BestScenarioPathSuffix;
}

uint64_t FindDomainById(uint64_t a1, int a2, _DWORD *a3)
{
  uint64_t v5 = *(void *)(a1 + 16);
  for (int i = mosyntkbaccphr_AccPhrDomains(v5); ; int i = mosyntkbaccphr_GetScenario(3, v5, *a3))
  {
    int v7 = i;
    *a3 = i;
    uint64_t result = mosyntkbaccphr_Nil();
    if (v7 == result) {
      break;
    }
    uint64_t result = mosyntkbaccphr_GetScenario(1, v5, *a3);
    if (result == a2) {
      break;
    }
  }
  return result;
}

uint64_t FindDomainByName(uint64_t a1, unsigned __int8 *a2, int *a3)
{
  uint64_t v5 = *(void *)(a1 + 16);
  for (uint64_t i = mosyntkbaccphr_AccPhrDomains(v5); ; uint64_t i = mosyntkbaccphr_GetScenario(3, v5, *a3))
  {
    *a3 = i;
    ScenarioNamePtr = (unsigned __int8 *)mosyntkbaccphr_GetScenarioNamePtr(v5, i);
    int v8 = *a3;
    uint64_t result = mosyntkbaccphr_Nil();
    if (v8 == result) {
      break;
    }
    uint64_t result = mosyntbase_CEqual(ScenarioNamePtr, 50, a2, 100);
    if (result) {
      break;
    }
  }
  return result;
}

uint64_t GenAccTree(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  *a4 = 0;
  int v16 = 0;
  if (!a3) {
    return 0;
  }
  uint64_t v5 = a3;
  while (1)
  {
    uint64_t v8 = AddAccNode(a1, a2, a4, &v16);
    if ((v8 & 0x80000000) != 0) {
      break;
    }
    int v9 = v16;
    _OWORD v16[2] = *(uint64_t *)((char *)v5 + 52);
    *((unsigned char *)v9 + 24) = 0;
    *((_WORD *)v9 + 13) = *((_WORD *)v5 + 8);
    if (*((unsigned char *)v5 + 60))
    {
      int v14 = 0;
      uint64_t v15 = 0;
      uint64_t v10 = AddAccNode(a1, a2, &v15, &v14);
      if ((v10 & 0x80000000) != 0) {
        return v10;
      }
      v9[1] = v15;
      int v11 = v14;
      v14[2] = *(uint64_t *)((char *)v5 + 52);
      __int16 v12 = 1;
      *((unsigned char *)v11 + 24) = 1;
      if (mosyntkbsymtab_PropTabAvailable(*(void *)(a2 + 8)))
      {
        if ((int)mosyntkbsymtab_IntPropValue(a1, *(uint64_t **)(a2 + 8), *((__int16 *)v5 + 8), 2u) >= 1) {
          __int16 v12 = 1;
        }
        else {
          __int16 v12 = 99;
        }
      }
      *((_WORD *)v11 + 13) = v12;
    }
    else
    {
      uint64_t v10 = GenAccTree(a1, a2, v5[1], v9 + 1);
      if ((v10 & 0x80000000) != 0) {
        return v10;
      }
    }
    uint64_t v5 = (uint64_t *)*v5;
    if (!v5) {
      return v10;
    }
  }
  return v8;
}

uint64_t AddAccNode(uint64_t a1, uint64_t a2, void *a3, void **a4)
{
  __int16 v12 = 0;
  uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v12, 0x20u);
  if ((result & 0x80000000) == 0)
  {
    int v9 = v12;
    int v13 = 0;
    uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v13, 0x18u);
    if ((result & 0x80000000) == 0)
    {
      void *v13 = *(void *)(a2 + 32);
      uint64_t v10 = v13;
      *(void *)(a2 + 32) = v13;
      *((_DWORD *)v10 + 2) = 1;
      unsigned __int8 v10[2] = v9;
      *__int16 v12 = 0;
      int v11 = v12;
      if (*a4)
      {
        **a4 = v12;
        int v11 = v12;
      }
      else
      {
        *a3 = v12;
      }
      *a4 = v11;
      v11[1] = 0;
    }
  }
  return result;
}

uint64_t Accentuation1(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  int v8 = mosyntkbsymtab_WildConsId(*(void *)(a2 + 8));
  *a4 = 0;
  if (!a3) {
    return 0;
  }
  if (*(unsigned char *)(a3 + 24))
  {
    if (*(_WORD *)(a3 + 26) == 1)
    {
      uint64_t FirstAccPatVal = 0;
      *a4 = 1;
      return FirstAccPatVal;
    }
    return 0;
  }
  uint64_t v10 = *(void **)(a3 + 8);
  if (!v10) {
    return 0;
  }
  int v11 = v8;
  memset(v21, 0, sizeof(v21));
  uint64_t v20 = 0;
  int v19 = 0;
  do
  {
    uint64_t FirstAccPatVal = Accentuation1(a1, a2, v10, &v19);
    if ((FirstAccPatVal & 0x80000000) != 0) {
      return FirstAccPatVal;
    }
    int v12 = v19 + *a4;
    *a4 = v12;
    uint64_t v10 = (void *)*v10;
  }
  while (v10);
  if (v12 < 2) {
    return FirstAccPatVal;
  }
  if (!mosyntkbsymtab_PropTabAvailable(*(void *)(a2 + 8)))
  {
    uint64_t v20 = 0;
    goto LABEL_30;
  }
  uint64_t FirstAccPatVal = mosyntkbsymtab_GetFirstAccPatVal(a1, *(uint64_t ***)(a2 + 8), *(__int16 *)(a3 + 26), 3, (uint64_t)v21, &v20);
  if ((FirstAccPatVal & 0x80000000) != 0) {
    return FirstAccPatVal;
  }
  int v13 = v20;
  if (!v20)
  {
LABEL_30:
    if (mosyntkbsymtab_PropTabAvailable(*(void *)(a2 + 8)))
    {
      uint64_t FirstAccPatVal = mosyntkbsymtab_GetFirstAccPatVal(a1, *(uint64_t ***)(a2 + 8), v11, 3, (uint64_t)v21, &v20);
      if ((FirstAccPatVal & 0x80000000) != 0) {
        return FirstAccPatVal;
      }
      uint64_t v17 = v20;
      if (v20)
      {
        while (1)
        {
          *(void *)(a2 + 64) = 0;
          if (*(int *)a2 >= 2)
          {
            uint64_t v14 = mosyntknowl_WriteTraceHeader(a1, 4u);
            if ((v14 & 0x80000000) != 0) {
              return v14;
            }
            uint64_t v14 = mosyntbase_WString(a1, "applying default pattern", 0);
            if ((v14 & 0x80000000) != 0) {
              return v14;
            }
            uint64_t v14 = mosyntbase_WLn(a1);
            if ((v14 & 0x80000000) != 0) {
              return v14;
            }
            uint64_t v17 = v20;
          }
          int matched = SingleTreeMatchFound(a1, a2, (uint64_t *)a3, v17);
          uint64_t v14 = mosyntkbsymtab_DisposeAccPat(*(void **)(a2 + 8), &v20);
          if ((v14 & 0x80000000) != 0) {
            return v14;
          }
          uint64_t FirstAccPatVal = mosyntkbsymtab_GetNextAccPatVal((uint64_t **)v21, &v20);
          if ((FirstAccPatVal & 0x80000000) != 0) {
            return FirstAccPatVal;
          }
          uint64_t v17 = v20;
          if (!v20 || matched)
          {
            if (v20)
            {
              uint64_t FirstAccPatVal = mosyntkbsymtab_DisposeAccPat(*(void **)(a2 + 8), &v20);
              if ((FirstAccPatVal & 0x80000000) != 0) {
                return FirstAccPatVal;
              }
            }
            if (!matched) {
              break;
            }
            goto LABEL_45;
          }
        }
      }
    }
    else
    {
      uint64_t v20 = 0;
    }
LABEL_47:
    *a4 = 1;
    if (*(int *)a2 >= 1)
    {
      uint64_t v14 = mosyntknowl_WriteTraceHeader(a1, 4u);
      if ((v14 & 0x80000000) != 0) {
        return v14;
      }
      uint64_t v14 = mosyntbase_WString(a1, "after accentuation of ", 0);
      if ((v14 & 0x80000000) != 0) {
        return v14;
      }
      uint64_t v14 = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), *(__int16 *)(a3 + 26));
      if ((v14 & 0x80000000) != 0) {
        return v14;
      }
      uint64_t v14 = mosyntbase_WString(a1, ": ", 0);
      if ((v14 & 0x80000000) != 0) {
        return v14;
      }
      uint64_t v14 = WriteAccList(a1, a2, a3);
      if ((v14 & 0x80000000) != 0) {
        return v14;
      }
      uint64_t v14 = mosyntbase_WLn(a1);
      if ((v14 & 0x80000000) != 0) {
        return v14;
      }
      uint64_t FirstAccPatVal = mosyntbase_WLn(a1);
      if ((FirstAccPatVal & 0x80000000) != 0) {
        return FirstAccPatVal;
      }
    }
    if (mosyntkbsymtab_PropTabAvailable(*(void *)(a2 + 8))
      && mosyntkbsymtab_HasIntPropValue(a1, *(uint64_t **)(a2 + 8), *(__int16 *)(a3 + 26), 4u, 1))
    {
      return FirstAccPatVal;
    }
    return RhythmicAccShift(a1, (int *)a2, a3);
  }
  while (1)
  {
    *(void *)(a2 + 64) = 0;
    if (*(int *)a2 >= 2)
    {
      uint64_t v14 = mosyntknowl_WriteTraceHeader(a1, 4u);
      if ((v14 & 0x80000000) != 0) {
        return v14;
      }
      uint64_t v14 = mosyntbase_WString(a1, "applying pattern for constituent ", 0);
      if ((v14 & 0x80000000) != 0) {
        return v14;
      }
      uint64_t v14 = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), *(__int16 *)(a3 + 26));
      if ((v14 & 0x80000000) != 0) {
        return v14;
      }
      uint64_t v14 = mosyntbase_WLn(a1);
      if ((v14 & 0x80000000) != 0) {
        return v14;
      }
      int v13 = v20;
    }
    int v15 = SingleTreeMatchFound(a1, a2, (uint64_t *)a3, v13);
    uint64_t v14 = mosyntkbsymtab_DisposeAccPat(*(void **)(a2 + 8), &v20);
    if ((v14 & 0x80000000) != 0) {
      return v14;
    }
    uint64_t FirstAccPatVal = mosyntkbsymtab_GetNextAccPatVal((uint64_t **)v21, &v20);
    if ((FirstAccPatVal & 0x80000000) != 0) {
      return FirstAccPatVal;
    }
    int v13 = v20;
    if (!v20 || v15)
    {
      if (v20)
      {
        uint64_t FirstAccPatVal = mosyntkbsymtab_DisposeAccPat(*(void **)(a2 + 8), &v20);
        if ((FirstAccPatVal & 0x80000000) != 0) {
          return FirstAccPatVal;
        }
      }
      if (!v15) {
        goto LABEL_30;
      }
LABEL_45:
      ReduceAccents(a2, a3);
      uint64_t FirstAccPatVal = 0;
      goto LABEL_47;
    }
  }
}

uint64_t SingleTreeMatchFound(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  unsigned int v8 = mosyntkbsymtab_WildConsId(*(void *)(a2 + 8));
  if (mosyntkbsymtab_PropTabAvailable(*(void *)(a2 + 8))
    && mosyntkbsymtab_HasIntPropValue(a1, *(uint64_t **)(a2 + 8), v8, 9u, 1))
  {
    uint64_t v9 = *a3;
    *a3 = 0;
    uint64_t result = MatchFound(a1, a2, a3, a4);
    *a3 = v9;
  }
  else
  {
    return MatchFound(a1, a2, a3, a4);
  }
  return result;
}

uint64_t ReduceAccents(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  if (*(unsigned char *)(a2 + 24))
  {
    if (*(void *)(result + 64) != a2) {
      ++*(_WORD *)(a2 + 26);
    }
  }
  else
  {
    for (uint64_t i = *(void **)(a2 + 8); i; uint64_t i = (void *)*i)
      uint64_t result = ReduceAccents(v2, i);
  }
  return result;
}

uint64_t WriteAccList(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v8 = 0;
  uint64_t v9 = 0;
  if (*(unsigned char *)(a3 + 24))
  {
    uint64_t result = mosyntdata_GetSentTermCommList(a1, *(void *)(a2 + 40), *(_DWORD *)(a3 + 16), &v8);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = mosyntdata_WriteCommandList(a1, v8);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = mosyntbase_WString(a1, "[", 0);
        if ((result & 0x80000000) == 0)
        {
          uint64_t result = mosyntbase_WInt(a1, *(__int16 *)(a3 + 26), 0);
          if ((result & 0x80000000) == 0)
          {
            uint64_t result = mosyntbase_WString(a1, "]", 0);
            if ((result & 0x80000000) == 0)
            {
              uint64_t result = mosyntdata_GetSentTermWordPhonList(a1, *(void *)(a2 + 40), *(_DWORD *)(a3 + 16), &v9);
              if ((result & 0x80000000) == 0) {
                return mosyntdata_WritePhonList(a1, *(uint64_t **)(a2 + 8), v9);
              }
            }
          }
        }
      }
    }
  }
  else
  {
    uint64_t result = mosyntbase_WString(a1, "( ", 0);
    if ((result & 0x80000000) == 0)
    {
      int v7 = (void *)(a3 + 8);
      while (1)
      {
        int v7 = (void *)*v7;
        if (!v7) {
          break;
        }
        uint64_t result = WriteAccList(a1, a2, v7);
        if ((result & 0x80000000) != 0) {
          return result;
        }
      }
      return mosyntbase_WString(a1, ")", 0);
    }
  }
  return result;
}

uint64_t RhythmicAccShift(uint64_t a1, int *a2, uint64_t a3)
{
  v8[3] = *MEMORY[0x263EF8340];
  char v7 = 0;
  memset(v8, 0, 24);
  AccShift(a3, v8, &v7);
  if (!v7 || *a2 < 1) {
    return 0;
  }
  uint64_t result = mosyntknowl_WriteTraceHeader(a1, 4u);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = mosyntbase_WString(a1, "accentuation after rhythmic shift: ", 0);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = WriteAccList(a1, (uint64_t)a2, a3);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = mosyntbase_WLn(a1);
        if ((result & 0x80000000) == 0)
        {
          return mosyntbase_WLn(a1);
        }
      }
    }
  }
  return result;
}

uint64_t MatchFound(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (*(int *)a2 >= 2)
  {
    mosyntknowl_WriteTraceHeader(a1, 4u);
    mosyntbase_WString(a1, "trying to match ", 0);
    if (a3)
    {
      if (*((unsigned char *)a3 + 24)) {
        mosyntbase_WInt(a1, *((__int16 *)a3 + 13), 0);
      }
      else {
        mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), *((__int16 *)a3 + 13));
      }
    }
    else
    {
      mosyntbase_WString(a1, "NIL", 0);
    }
    mosyntbase_WString(a1, "/", 0);
    if (a4)
    {
      if (*((__int16 *)a4 + 8) < 1) {
        mosyntbase_WInt(a1, *((__int16 *)a4 + 9), 0);
      }
      else {
        mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), *((unsigned __int16 *)a4 + 8));
      }
    }
    else
    {
      mosyntbase_WString(a1, "NIL", 0);
    }
    mosyntbase_WLn(a1);
  }
  uint64_t result = a3 == 0;
  if (!a4) {
    return result;
  }
  if (!a3)
  {
    if (!*a4)
    {
      int v14 = *((__int16 *)a4 + 8);
      if (mosyntkbsymtab_Star2ConsId(*(void *)(a2 + 8)) != v14)
      {
        int v15 = *((__int16 *)a4 + 8);
        return mosyntkbsymtab_StarConsId(*(void *)(a2 + 8)) == v15;
      }
      return 1;
    }
    return 0;
  }
  if (!*((_WORD *)a4 + 8))
  {
    if (*((unsigned char *)a3 + 24))
    {
      int v16 = *((unsigned __int16 *)a3 + 13);
      if (v16 == *((unsigned __int16 *)a4 + 9))
      {
        if (v16 == 1)
        {
          if (*(int *)a2 >= 2)
          {
            mosyntknowl_WriteTraceHeader(a1, 4u);
            mosyntbase_WString(a1, "=== node marked", 0);
            mosyntbase_WLn(a1);
          }
          *(void *)(a2 + 64) = a3;
        }
        return 1;
      }
    }
    return 0;
  }
  int v9 = *((__int16 *)a4 + 8);
  if (mosyntkbsymtab_Star2ConsId(*(void *)(a2 + 8)) == v9)
  {
    if (!MatchFound(a1, a2, *a3, a4) && !MatchFound(a1, a2, *a3, *a4))
    {
      uint64_t v10 = (void *)*a4;
      uint64_t v11 = a1;
      uint64_t v12 = a2;
      uint64_t v13 = (uint64_t)a3;
      return MatchFound(v11, v12, v13, v10) != 0;
    }
    return 1;
  }
  int v17 = *((__int16 *)a4 + 8);
  if (mosyntkbsymtab_StarConsId(*(void *)(a2 + 8)) == v17)
  {
    if (!MatchFound(a1, a2, a3, *a4) && !MatchFound(a1, a2, *a3, *a4))
    {
      uint64_t v13 = *a3;
      uint64_t v11 = a1;
      uint64_t v12 = a2;
      uint64_t v10 = a4;
      return MatchFound(v11, v12, v13, v10) != 0;
    }
    return 1;
  }
  int v18 = *((__int16 *)a4 + 8);
  if (mosyntkbsymtab_Wild2ConsId(*(void *)(a2 + 8)) == v18)
  {
    uint64_t result = DownMatchFound(a1, a2, a3, a4[1]);
    if (!result) {
      return result;
    }
LABEL_38:
    uint64_t v13 = *a3;
    uint64_t v10 = (void *)*a4;
    uint64_t v11 = a1;
    uint64_t v12 = a2;
    return MatchFound(v11, v12, v13, v10) != 0;
  }
  int v19 = *((__int16 *)a4 + 8);
  if (mosyntkbsymtab_WildConsId(*(void *)(a2 + 8)) != v19
    && (*((unsigned char *)a3 + 24) || *((unsigned __int16 *)a3 + 13) != *((unsigned __int16 *)a4 + 8)))
  {
    return 0;
  }
  uint64_t result = MatchFound(a1, a2, a3[1], a4[1]);
  if (result) {
    goto LABEL_38;
  }
  return result;
}

uint64_t DownMatchFound(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v8 = *a3;
  *a3 = 0;
  if (MatchFound())
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t v10 = (void *)a3[1];
    if (v10)
    {
      do
      {
        uint64_t result = DownMatchFound(a1, a2, v10, a4);
        uint64_t v10 = (void *)*v10;
        if (v10) {
          BOOL v11 = result == 0;
        }
        else {
          BOOL v11 = 0;
        }
      }
      while (v11);
    }
    else
    {
      uint64_t result = 0;
    }
  }
  *a3 = v8;
  return result;
}

uint64_t AccShift(uint64_t result, uint64_t *a2, unsigned char *a3)
{
  for (uint64_t i = *(uint64_t **)(result + 8); i; uint64_t i = (uint64_t *)*i)
  {
    if (*((unsigned char *)i + 24))
    {
      if (*((unsigned __int16 *)i + 13) - 1 > 0x61) {
        continue;
      }
      uint64_t v7 = a2[1];
      uint64_t v6 = a2[2];
      *a2 = v7;
      a2[1] = v6;
      a2[2] = (uint64_t)i;
      if (!v7 || v6 == 0) {
        continue;
      }
      int v9 = *((unsigned __int16 *)i + 13);
      if (v9 == 1 && *(_WORD *)(v6 + 26) == 2 && (*(_WORD *)(v7 + 26) & 0xFFFE) == 2)
      {
        *(_WORD *)(v6 + 26) = 3;
        uint64_t v10 = *a2;
      }
      else
      {
        if (*(_WORD *)(v7 + 26) != 1 || (v9 & 0xFFFE) != 2 || *(_WORD *)(v6 + 26) != 2) {
          continue;
        }
        *(_WORD *)(v6 + 26) = 3;
        uint64_t v10 = a2[2];
      }
      *(_WORD *)(v10 + 26) = 2;
      *a3 = 1;
    }
    else
    {
      uint64_t result = AccShift(i, a2, a3);
    }
  }
  return result;
}

uint64_t GetInitPhrasing1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t *a7)
{
  uint64_t v7 = *(unsigned char **)(a3 + 8);
  if (!v7) {
    return 0;
  }
  if (!v7[24])
  {
    uint64_t v16 = (a4 + 1);
    do
    {
      uint64_t InitPhrasing1 = GetInitPhrasing1(a1, a2, v7, v16, a5, a6, a7);
      if ((InitPhrasing1 & 0x80000000) != 0 || !*(void *)v7) {
        break;
      }
      if (!mosyntkbsymtab_PropTabAvailable(*(void *)(a2 + 8))
        || !mosyntkbsymtab_HasIntPropValue(a1, *(uint64_t **)(a2 + 8), *(__int16 *)(*(void *)v7 + 26), 5u, 0))
      {
        BOOL v17 = mosyntkbsymtab_PropTabAvailable(*(void *)(a2 + 8));
        a5 = a4;
        if (!v17) {
          continue;
        }
        BOOL HasIntPropValue = mosyntkbsymtab_HasIntPropValue(a1, *(uint64_t **)(a2 + 8), *(__int16 *)(*(void *)v7 + 26), 5u, *(__int16 *)(a3 + 26));
        a5 = a4;
        if (!HasIntPropValue) {
          continue;
        }
      }
      a5 = 2;
      uint64_t v7 = *(unsigned char **)v7;
    }
    while (v7);
    return InitPhrasing1;
  }
  return AppendInitBound(a1, a2, a6, a7, a5, a3);
}

uint64_t AppendInitBound(uint64_t a1, uint64_t a2, void *a3, uint64_t *a4, __int16 a5, uint64_t a6)
{
  int v23 = 0;
  uint64_t v24 = 0;
  int v22 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t PunctFromCommandList = mosyntpal_ALLOCATE(a1, &v24, 0x28u);
  if ((PunctFromCommandList & 0x80000000) == 0)
  {
    *(void *)uint64_t v24 = 0;
    uint64_t v13 = v24;
    if (*a3)
    {
      *(void *)*a4 = v24;
      uint64_t v13 = v24;
    }
    else
    {
      *a3 = v24;
    }
    *a4 = v13;
    *(_WORD *)(v13 + 8) = a5;
    if (a6)
    {
      uint64_t v14 = *(void *)(a6 + 8);
      *(_WORD *)(v13 + 10) = *(unsigned __int16 *)(v14 + 26) - 1 < 0x62;
      unsigned int v15 = *(_DWORD *)(v14 + 16);
      *(_DWORD *)(v13 + 16) = v15;
      uint64_t SentTermWordPhonList = mosyntdata_GetSentTermWordPhonList(a1, *(void *)(a2 + 40), v15, &v23);
      if ((SentTermWordPhonList & 0x80000000) != 0) {
        return SentTermWordPhonList;
      }
      __int16 v19 = 0;
      CountSyllsAndAccs(a2, v23, (_WORD *)(v24 + 12), &v19);
      uint64_t v17 = v24;
      *(void *)(v24 + 20) = *(void *)(v14 + 16);
      *(_WORD *)(v17 + 28) = *(_WORD *)(a6 + 26);
      *(_WORD *)(v17 + 30) = *(_WORD *)(v14 + 26);
      *(_DWORD *)(v17 + 32) = 0;
      uint64_t SentTermWordPhonList = mosyntdata_GetSentTermCommList(a1, *(void *)(a2 + 40), *(_DWORD *)(v17 + 16), &v20);
      if ((SentTermWordPhonList & 0x80000000) != 0)
      {
        return SentTermWordPhonList;
      }
      else
      {
        uint64_t PunctFromCommandList = mosyntdata_GetPunctFromCommandList(a1, v20, &v22, &v21);
        if ((PunctFromCommandList & 0x80000000) == 0
          && *(__int16 *)(v24 + 8) >= 2
          && mosyntknowl_IsIntraSentPunct(a1, v22))
        {
          *(_WORD *)(v24 + 8) = 1;
        }
      }
    }
    else
    {
      *(_DWORD *)(v13 + 10) = 0;
      *(void *)(v13 + 16) = 0;
      *(void *)(v13 + 24) = 0;
      *(_DWORD *)(v13 + 32) = 0;
    }
  }
  return PunctFromCommandList;
}

uint64_t FinalBoundaryIndex(uint64_t a1, uint64_t *a2)
{
  if (!a2) {
    return 2;
  }
  uint64_t v2 = 0;
  int v3 = 0;
  do
  {
    if (!*((_DWORD *)a2 + 2))
    {
      uint64_t v2 = a2;
      int v3 = a2;
    }
    a2 = (uint64_t *)*a2;
  }
  while (a2);
  if (v3)
  {
    unsigned int v4 = *((_DWORD *)v3 + 3);
    if (v2) {
      return !mosyntknowl_IsSentFinalPunct(a1, v4);
    }
  }
  else
  {
    unsigned int v4 = 0;
    if (v2) {
      return !mosyntknowl_IsSentFinalPunct(a1, v4);
    }
  }
  return 2;
}

uint64_t WriteBoundList(uint64_t a1, uint64_t a2, uint64_t *a3, int a4)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  BOOL v11 = 0;
  uint64_t v12 = 0;
  __int16 v13 = 0;
  if (a3)
  {
    uint64_t v6 = a3;
    do
    {
      if ((__int16)v6[1] < 0)
      {
        uint64_t v9 = a1;
        uint64_t v10 = " $";
      }
      else
      {
        uint64_t result = mosyntbase_WLn(a1);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t result = mosyntknowl_WriteTraceHeader(a1, 4u);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t result = mosyntbase_WString(a1, " #{", 0);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t result = mosyntbase_WInt(a1, *((__int16 *)v6 + 4), 0);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t result = mosyntbase_WString(a1, "}", 0);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        if (a4)
        {
          uint64_t result = mosyntbase_WString(a1, " (", 0);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t result = mosyntkbaccphr_PhraseTypeToString(*((_DWORD *)v6 + 8), (uint64_t)&v12, 10);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t result = mosyntbase_WString(a1, (unsigned __int8 *)&v12, 10);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t result = mosyntbase_WString(a1, ")", 0);
          if ((result & 0x80000000) != 0) {
            return result;
          }
        }
        uint64_t result = mosyntbase_WString(a1, " <", 0);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t result = mosyntbase_WInt(a1, *((__int16 *)v6 + 5), 0);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t result = mosyntbase_WString(a1, ",", 0);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t result = mosyntbase_WInt(a1, *((__int16 *)v6 + 6), 0);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t v9 = a1;
        uint64_t v10 = ">";
      }
      uint64_t result = mosyntbase_WString(v9, (unsigned __int8 *)v10, 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      if (!*v6) {
        break;
      }
      uint64_t result = mosyntbase_WString(a1, " [", 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntbase_WInt(a1, *((__int16 *)v6 + 15), 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntbase_WString(a1, "]", 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntdata_GetSentTermWordPhonList(a1, *(void *)(a2 + 40), *((_DWORD *)v6 + 5), &v11);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntdata_WritePhonList(a1, *(uint64_t **)(a2 + 8), v11);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t v6 = (uint64_t *)*v6;
    }
    while (v6);
  }
  return mosyntbase_WLn(a1);
}

uint64_t CountSyllsAndAccs(uint64_t result, uint64_t **a2, _WORD *a3, _WORD *a4)
{
  *a3 = 1;
  *a4 = 0;
  if (a2)
  {
    uint64_t v6 = a2;
    uint64_t v7 = result;
    __int16 v8 = 0;
    do
    {
      int v9 = *((__int16 *)v6 + 12);
      uint64_t result = mosyntkbsymtab_SyllSepId(*(void *)(v7 + 8));
      if (result == v9)
      {
        ++*a3;
        if (v8 >= 1)
        {
          __int16 v8 = 0;
          ++*a4;
        }
      }
      else
      {
        int v10 = *((__int16 *)v6 + 12);
        uint64_t result = mosyntkbsymtab_PrimAccId(*(void *)(v7 + 8));
        if (result == v10
          || (v11 = *((__int16 *)v6 + 12), uint64_t result = mosyntkbsymtab_SecAccId(*(void *)(v7 + 8)), result == v11))
        {
          ++v8;
        }
      }
      uint64_t v6 = (uint64_t **)*v6;
    }
    while (v6);
    if (v8 >= 1) {
      ++*a4;
    }
  }
  return result;
}

uint64_t SetFunctionWords(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char v17 = 0;
  if (a3 == a4) {
    return 0;
  }
  uint64_t v5 = a3;
  uint64_t v8 = 0;
  while (1)
  {
    int v9 = *(void **)(*(void *)(v5 + 32) + 32);
    do
    {
      int v10 = v9;
      int v9 = (void *)*v9;
    }
    while (v9);
    uint64_t v11 = *(void *)(a2 + 16);
    uint64_t v12 = mosyntkbaccphr_AccPhrFunctionWords(v11);
    char v17 = 0;
    if (v12 != mosyntkbaccphr_Nil() && v17 == 0) {
      break;
    }
LABEL_9:
    if (v12 != mosyntkbaccphr_Nil()) {
      *(_DWORD *)(v5 + 84) = 0;
    }
    uint64_t v5 = *(void *)(v5 + 16);
    if (v5 == a4) {
      return v8;
    }
  }
  while (1)
  {
    int ConsList = mosyntkbaccphr_GetConsList(0, v11, v12);
    unsigned int v15 = mosyntkbaccphr_GetConsList(1, v11, v12);
    uint64_t v8 = mosyntkbaccphr_CheckMatchingConsFeat2(a1, v11, ConsList, v15, *(__int16 *)(v10[1] + 16), (unsigned __int16 *)(v10[1] + 24), &v17);
    if ((v8 & 0x80000000) != 0) {
      return v8;
    }
    if (!v17) {
      uint64_t v12 = mosyntkbaccphr_GetConsList(2, v11, v12);
    }
    if (v12 == mosyntkbaccphr_Nil() || v17) {
      goto LABEL_9;
    }
  }
}

uint64_t ChartToSentTermData(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 40);
  if (v2) {
    BOOL v3 = a2 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    do
    {
      uint64_t v4 = *(void *)(a2 + 32);
      if (v4)
      {
        uint64_t v7 = (uint64_t *)(v2 + 16 * *(int *)(v4 + 84));
        uint64_t v5 = *v7;
        uint64_t v6 = v7[1];
        if (v6)
        {
          int v8 = *(__int16 *)(a2 + 68);
          if (v8 >= 2) {
            int v8 = 2;
          }
          int v9 = *(_DWORD *)(a2 + 76);
          *(_DWORD *)(v6 + 8) = v8;
          *(_DWORD *)(v6 + 12) = v9;
        }
        if (v5)
        {
          int v10 = *(_DWORD *)(a2 + 84);
          if (v10 >= 3) {
            int v11 = 3;
          }
          else {
            int v11 = *(_DWORD *)(a2 + 84);
          }
          if (v10 <= 98) {
            int v12 = v11;
          }
          else {
            int v12 = 0;
          }
          *(_DWORD *)(v5 + 16) = v12;
        }
      }
      a2 = *(void *)(a2 + 16);
    }
    while (a2);
  }
  return result;
}

double NewAPVertex(uint64_t a1, uint64_t a2, int a3, uint64_t *a4)
{
  ++*(_DWORD *)(a2 + 72);
  if ((mosyntpal_ALLOCATE(a1, a4, 0x58u) & 0x80000000) == 0)
  {
    uint64_t v9 = *a4;
    int v12 = 0;
    if ((mosyntpal_ALLOCATE(a1, (uint64_t *)&v12, 0x18u) & 0x80000000) == 0)
    {
      *int v12 = *(void *)(a2 + 32);
      int v10 = v12;
      *(void *)(a2 + 32) = v12;
      *((_DWORD *)v10 + 2) = 2;
      unsigned __int8 v10[2] = v9;
      uint64_t v11 = *a4;
      *(_DWORD *)uint64_t v11 = *(_DWORD *)(a2 + 72);
      double result = 0.0;
      *(_OWORD *)(v11 + 8) = 0u;
      *(_OWORD *)(v11 + 24) = 0u;
      *(_OWORD *)(v11 + 40) = 0u;
      *(void *)(v11 + 56) = 0;
      *(_DWORD *)(v11 + 64) = a3;
      *(_WORD *)(v11 + 68) = -1;
      *(_DWORD *)(v11 + 84) = -1;
      *(void *)(v11 + 72) = 0;
    }
  }
  return result;
}

void TreeToChart(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t *a6)
{
  uint64_t v6 = a6;
  uint64_t v7 = a4;
  uint64_t v31 = 0;
  int v30 = 0;
  int v28 = 0;
  uint64_t v29 = 0;
  int v27 = 0;
  *a6 = 0;
  unsigned int v11 = *(_DWORD *)(a3 + 52);
  *(_DWORD *)(a4 + 64) = v11;
  if (*(unsigned char *)(a3 + 60))
  {
    if ((mosyntdata_GetSentTermCommList(a1, *(void *)(a2 + 40), v11, &v28) & 0x80000000) == 0
      && (mosyntdata_GetPunctFromCommandList(a1, v28, &v30, &v29) & 0x80000000) == 0)
    {
      if (mosyntknowl_IsIntraSentPunct(a1, v30)) {
        *(_WORD *)(v7 + 68) = 1;
      }
      if ((mosyntdata_GetSentTermWordPhonList(a1, *(void *)(a2 + 40), *(_DWORD *)(a3 + 52), &v27) & 0x80000000) == 0
        && (NewAPEdge(a1, a2, a3, v6) & 0x80000000) == 0)
      {
        uint64_t v12 = *v6;
        *(_DWORD *)(v12 + 92) = 0;
        *(void *)(v12 + 16) = v7;
        NewAPVertex(a1, a2, *(_DWORD *)(a3 + 56), (uint64_t *)(*v6 + 24));
        if ((v13 & 0x80000000) == 0)
        {
          CountSyllsAndAccs(a2, v27, (_WORD *)(*v6 + 82), (_WORD *)(*v6 + 80));
          *(void *)(v7 + 16) = *(void *)(*v6 + 24);
          *(void *)(*(void *)(*v6 + 24) + 8) = v7;
          *(void *)(v7 + 32) = *v6;
          *(void *)(*(void *)(*v6 + 24) + 24) = *v6;
          *(void *)*uint64_t v6 = 0;
          *(void *)(*v6 + 8) = 0;
        }
      }
    }
  }
  else
  {
    uint64_t v14 = *(void **)(a3 + 8);
    if (v14)
    {
      uint64_t v24 = a3;
      __int16 v15 = 0;
      __int16 v16 = 0;
      int v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      uint64_t v20 = (a5 + 1);
      while ((TreeToChart(a1, a2, v14, v7, v20, &v31) & 0x80000000) == 0)
      {
        uint64_t v21 = v31;
        if (v31)
        {
          *(void *)(v31 + 64) = v19;
          if (!v18) {
            uint64_t v18 = v21;
          }
          if (v19) {
            *(void *)(v19 + 56) = v21;
          }
          ++v17;
          uint64_t v7 = *(void *)(v21 + 24);
          v16 += *(_WORD *)(v21 + 82);
          v15 += *(_WORD *)(v21 + 80);
          uint64_t v19 = v21;
        }
        uint64_t v14 = (void *)*v14;
        if (!v14)
        {
          uint64_t v6 = a6;
          if (v7 == a4) {
            goto LABEL_26;
          }
          if (v17 < 2)
          {
            *a6 = v19;
            AddAPNode(a1, a2, v24, (uint64_t *)(v19 + 32));
          }
          else if ((NewAPEdge(a1, a2, v24, a6) & 0x80000000) == 0)
          {
            uint64_t v22 = *a6;
            *(_DWORD *)(v22 + 92) = 1;
            *(void *)(v22 + 16) = a4;
            *(void *)(*a6 + 24) = v7;
            *(void *)*a6 = *(void *)(a4 + 48);
            *(void *)(a4 + 48) = *a6;
            *(void *)(*a6 + 8) = *(void *)(v7 + 40);
            *(void *)(v7 + 40) = *a6;
            uint64_t v23 = *a6;
            *(_WORD *)(v23 + 82) = v16;
            *(_WORD *)(v23 + 80) = v15;
            for (*(void *)(v23 + 72) = v18; v18; uint64_t v18 = *(void *)(v18 + 56))
              *(void *)(v18 + 48) = *a6;
          }
          return;
        }
      }
    }
    else
    {
LABEL_26:
      *uint64_t v6 = 0;
    }
  }
}

uint64_t NewAPEdge(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t result = mosyntpal_ALLOCATE(a1, a4, 0x60u);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v9 = *a4;
    uint64_t v12 = 0;
    uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v12, 0x18u);
    if ((result & 0x80000000) == 0)
    {
      *uint64_t v12 = *(void *)(a2 + 32);
      int v10 = v12;
      *(void *)(a2 + 32) = v12;
      *((_DWORD *)v10 + 2) = 3;
      unsigned __int8 v10[2] = v9;
      uint64_t v11 = *a4;
      *(void *)(v11 + 72) = 0;
      *(_OWORD *)uint64_t v11 = 0u;
      *(_OWORD *)(v11 + 16) = 0u;
      *(_OWORD *)(v11 + 48) = 0u;
      *(_OWORD *)(v11 + 32) = 0u;
      *(void *)(v11 + 84) = *(void *)(a3 + 52);
      return AddAPNode(a1, a2, a3, (uint64_t *)(v11 + 32));
    }
  }
  return result;
}

uint64_t AddAPNode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  int v13 = 0;
  uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v13, 0x18u);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v9 = (uint64_t)v13;
    uint64_t v14 = 0;
    uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v14, 0x18u);
    if ((result & 0x80000000) == 0)
    {
      *uint64_t v14 = *(void *)(a2 + 32);
      int v10 = v14;
      *(void *)(a2 + 32) = v14;
      *((_DWORD *)v10 + 2) = 5;
      unsigned __int8 v10[2] = v9;
      uint64_t v11 = v13;
      v13[1] = a3;
      *uint64_t v11 = *a4;
      uint64_t v12 = (uint64_t)v13;
      _OWORD v13[2] = 0;
      *a4 = v12;
    }
  }
  return result;
}

uint64_t WriteCoverage(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t v4 = a3;
  int v13 = 0;
  if (a3 != a4)
  {
    while (2)
    {
      HIDWORD(v11) = 0;
      LODWORD(v11) = 0;
      *(void *)((char *)&v11 + 4) = *v4;
      uint64_t result = mosyntbase_WriteMessage(a1, " (%i) ", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, v11);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t v9 = (void *)(*((void *)v4 + 4) + 32);
      do
      {
        uint64_t v9 = (void *)*v9;
        if (!v9)
        {
          uint64_t result = mosyntbase_WriteMessage(a1, "#### ERROR: didn't find terminal\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          goto LABEL_13;
        }
        uint64_t v10 = v9[1];
      }
      while (!*(unsigned char *)(v10 + 60));
      uint64_t result = mosyntkbsymtab_WriteCons(a1, *(uint64_t **)(a2 + 8), *(__int16 *)(v10 + 16));
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntbase_WString(a1, "[ ", 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntdata_GetSentTermWordPhonList(a1, *(void *)(a2 + 40), *(_DWORD *)(*((void *)v4 + 4) + 84), &v13);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntdata_WritePhonList(a1, *(uint64_t **)(a2 + 8), v13);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntbase_WString(a1, " ] ", 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
LABEL_13:
      uint64_t v4 = (unsigned int *)*((void *)v4 + 2);
      if (v4 != a4) {
        continue;
      }
      break;
    }
    uint64_t v4 = a4;
  }
  HIDWORD(v12) = 0;
  LODWORD(v12) = 0;
  *(void *)((char *)&v12 + 4) = *v4;
  return mosyntbase_WriteMessage(a1, " (%i) ", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, v12);
}

uint64_t MatchEdge(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t **a4, uint64_t *a5)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v5 = *(void **)(a3 + 32);
  if (!v5) {
    return 0;
  }
  uint64_t v10 = *(void *)(a2 + 16);
  long long v26 = 0u;
  memset(v25, 0, sizeof(v25));
  char v23 = 0;
  uint64_t v21 = (uint64_t *)(a3 + 40);
  do
  {
    uint64_t result = mosyntkbaccphr_LookupAccPhrRule(a1, *(void *)(a2 + 16), *(__int16 *)(v5[1] + 16), (__int16 *)(v5[1] + 24), &v23, (uint64_t)v25);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    while (v23)
    {
      int Rule = mosyntkbaccphr_GetRule(15, v10, DWORD2(v26));
      uint64_t v13 = DWORD2(v26);
      if (Rule < 1)
      {
        if (IsMatchingRule(a1, a2, DWORD2(v26), (void **)v5, a3))
        {
          uint64_t result = AddEdgeRule(a1, a2, SDWORD2(v26), (uint64_t)v5);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          if ((int)mosyntkbaccphr_GetRule(0, v10, DWORD2(v26)) >= 1)
          {
            uint64_t result = AddRuleScenarios(a1, a2, DWORD2(v26), v21, a5);
            if ((result & 0x80000000) != 0) {
              return result;
            }
          }
        }
      }
      else
      {
        uint64_t v24 = 0;
        uint64_t result = mosyntpal_ALLOCATE(a1, &v24, 0x20u);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t result = NoteAPRuleListAlloc(a1, a2, v24);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t v14 = (void *)v24;
        *(_DWORD *)(v24 + 8) = v13;
        v14[2] = a3;
        v14[3] = v5;
        __int16 v15 = *a4;
        if (*a4)
        {
          int v16 = mosyntkbaccphr_GetRule(15, *(void *)(a2 + 16), *((unsigned int *)v15 + 2));
          if (v16 < (int)mosyntkbaccphr_GetRule(15, *(void *)(a2 + 16), v13))
          {
            while (1)
            {
              int v17 = v15;
              __int16 v15 = (uint64_t *)*v15;
              if (!v15) {
                break;
              }
              int v18 = mosyntkbaccphr_GetRule(15, *(void *)(a2 + 16), *((unsigned int *)v15 + 2));
              if (v18 >= (int)mosyntkbaccphr_GetRule(15, *(void *)(a2 + 16), v13))
              {
                uint64_t v19 = *v17;
                goto LABEL_22;
              }
            }
            uint64_t v19 = 0;
LABEL_22:
            *(void *)uint64_t v24 = v19;
            uint64_t *v17 = v24;
            goto LABEL_23;
          }
          uint64_t v20 = *a4;
          uint64_t v14 = (void *)v24;
        }
        else
        {
          uint64_t v20 = 0;
        }
        *uint64_t v14 = v20;
        *a4 = (uint64_t *)v24;
      }
LABEL_23:
      uint64_t result = mosyntkbaccphr_GetNextAccPhrEntry(a1, v10, &v23, (uint64_t)v25);
      if ((result & 0x80000000) != 0) {
        return result;
      }
    }
    uint64_t v5 = (void *)*v5;
  }
  while (v5);
  return result;
}

uint64_t IsMatchingRule(uint64_t a1, uint64_t a2, uint64_t a3, void **a4, uint64_t a5)
{
  uint64_t v33[2] = *MEMORY[0x263EF8340];
  uint64_t v32 = 0;
  v33[0] = 0;
  *(void *)((char *)v33 + 5) = 0;
  uint64_t v10 = *(void *)(a2 + 16);
  int v11 = **(_DWORD **)(a5 + 24) - **(_DWORD **)(a5 + 16);
  if ((int)mosyntkbaccphr_GetRule(8, v10, a3) <= v11
    && v11 <= (int)mosyntkbaccphr_GetRule(9, v10, a3)
    && (int v12 = mosyntkbaccphr_GetRule(6, v10, a3), v13 = *(__int16 *)(a5 + 82), v12 <= v13)
    && (int)mosyntkbaccphr_GetRule(7, v10, a3) >= v13
    && (v14 = mosyntkbaccphr_GetRule(10, v10, a3), int v15 = *(__int16 *)(a5 + 80), v14 <= v15)
    && (int)mosyntkbaccphr_GetRule(11, v10, a3) >= v15)
  {
    if (IsMatchingNodeContext(a1, a2, a3, a4, (void *)a5, 0))
    {
      if (IsMatchingNodeContext(a1, a2, a3, a4, (void *)a5, 1))
      {
        uint64_t v16 = IsMatchingNodeContext(a1, a2, a3, a4, (void *)a5, 2);
        if (v16)
        {
          int Rule = mosyntkbaccphr_GetRule(5, v10, a3);
          if (Rule == mosyntkbaccphr_Nil())
          {
            unsigned int v17 = 0;
          }
          else
          {
            uint64_t v16 = IsMatchingNodeContext(a1, a2, a3, a4, (void *)a5, 3);
            if (v16) {
              unsigned int v17 = 0;
            }
            else {
              unsigned int v17 = 5;
            }
          }
        }
        else
        {
          unsigned int v17 = 4;
        }
      }
      else
      {
        uint64_t v16 = 0;
        unsigned int v17 = 3;
      }
    }
    else
    {
      uint64_t v16 = 0;
      unsigned int v17 = 2;
    }
  }
  else
  {
    uint64_t v16 = 0;
    unsigned int v17 = 1;
  }
  if (*(int *)a2 >= 2)
  {
    mosyntknowl_WriteTraceHeader(a1, 4u);
    m2__cp__str("[AccPhr]           ", &v32, 21);
    mosyntbase_WString(a1, "[AccPhr] Node ", 0);
    int v18 = *(uint64_t **)(a2 + 8);
    int v19 = mosyntkbaccphr_GetRule(1, v10, a3);
    mosyntkbaccphr_WriteAccPhrNode(a1, v18, v10, v19);
    mosyntbase_WStringLn(a1, " covers:", 0);
    mosyntbase_WString(a1, "[AccPhr] ", 0);
    WriteCoverage(a1, a2, *(unsigned int **)(a5 + 16), *(unsigned int **)(a5 + 24));
    mosyntbase_WLn(a1);
    mosyntbase_WStringLn(a1, "[AccPhr] Matching rule:", 0);
    mosyntbase_WString(a1, "[AccPhr] ", 0);
    mosyntkbaccphr_WriteRuleHeadline(a1, *(uint64_t **)(a2 + 8), v10, a3);
    mosyntbase_WLn(a1);
    if (v16)
    {
      mosyntbase_WriteMessage(a1, "%s...\\n[AccPhr] Rule matched successfully.\\n", 0, (unsigned __int8 *)&v32, 21, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
      return v16;
    }
    if (v17 == 5)
    {
      uint64_t v24 = *(uint64_t **)(a2 + 8);
      int v25 = mosyntkbaccphr_GetRule(5, v10, a3);
      mosyntkbaccphr_WriteChildrenList(a1, v24, v10, (unsigned __int8 *)&v32, 21, v25);
      mosyntbase_WriteMessage(a1, "%s...\\n[AccPhr] Rule doesn't match: ", 0, (unsigned __int8 *)&v32, 21, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
      char v23 = "children";
    }
    else if (v17 == 1)
    {
      int v20 = mosyntkbaccphr_GetRule(8, v10, a3);
      *((void *)&v29 + 1) = mosyntkbaccphr_GetRule(9, v10, a3);
      LODWORD(v29) = 0;
      DWORD1(v29) = v20;
      mosyntbase_WriteMessage(a1, "%s<wordrange(%i,%i)>\\n", 0, (unsigned __int8 *)&v32, 21, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, v29);
      int v21 = mosyntkbaccphr_GetRule(6, v10, a3);
      *((void *)&v30 + 1) = mosyntkbaccphr_GetRule(7, v10, a3);
      LODWORD(v30) = 0;
      DWORD1(v30) = v21;
      mosyntbase_WriteMessage(a1, "%s<syllrange(%i,%i)>\\n", 0, (unsigned __int8 *)&v32, 21, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, v30);
      int v22 = mosyntkbaccphr_GetRule(10, v10, a3);
      *((void *)&v31 + 1) = mosyntkbaccphr_GetRule(11, v10, a3);
      LODWORD(v31) = 0;
      DWORD1(v31) = v22;
      mosyntbase_WriteMessage(a1, "%s<accrange(%i,%i)>\\n", 0, (unsigned __int8 *)&v32, 21, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, v31);
      mosyntbase_WriteMessage(a1, "%s...\\n[AccPhr] Rule doesn't match: ", 0, (unsigned __int8 *)&v32, 21, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
      char v23 = "constraints";
    }
    else
    {
      mosyntbase_WriteMessage(a1, "%s...\\n[AccPhr] Rule doesn't match: ", 0, (unsigned __int8 *)&v32, 21, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
      uint64_t v26 = v17 - 2;
      if (v26 > 2)
      {
LABEL_18:
        mosyntbase_WStringLn(a1, " definition.", 0);
        return v16;
      }
      char v23 = off_264107F30[v26];
    }
    mosyntbase_WString(a1, (unsigned __int8 *)v23, 0);
    goto LABEL_18;
  }
  return v16;
}

uint64_t AddEdgeRule(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v10 = 0;
  uint64_t result = mosyntpal_ALLOCATE(a1, &v10, 0x20u);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = NoteAPRuleListAlloc(a1, a2, v10);
    if ((result & 0x80000000) == 0)
    {
      uint64_t v9 = (void *)v10;
      *(_DWORD *)(v10 + 8) = a3;
      _OWORD v9[2] = 0;
      v9[3] = a4;
      *uint64_t v9 = *(void *)(a4 + 16);
      *(void *)(a4 + 16) = v10;
    }
  }
  return result;
}

uint64_t AddRuleScenarios(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v10 = *(void *)(a2 + 16);
  uint64_t Scenario = mosyntkbaccphr_GetScenario(2, v10, *(unsigned int *)(a2 + 60));
  if (Scenario != mosyntkbaccphr_Nil())
  {
    char v23 = a5;
    uint64_t v12 = 0;
    while (1)
    {
      if (mosyntkbaccphr_GetRuleSetIsSubset(v10, Scenario))
      {
        for (uint64_t i = mosyntkbaccphr_AccPhrScenarios(*(void *)(a2 + 16)); ; uint64_t i = mosyntkbaccphr_GetScenario(3, v10, v14))
        {
          uint64_t v14 = i;
          if (i == mosyntkbaccphr_Nil()) {
            break;
          }
          int v15 = mosyntkbaccphr_GetScenario(1, v10, v14);
          if (v15 == mosyntkbaccphr_GetRuleSet(2, v10, Scenario)) {
            break;
          }
        }
        if (v14 != mosyntkbaccphr_Nil())
        {
          uint64_t v16 = mosyntkbaccphr_GetScenario(2, v10, v14);
          if (v16 != mosyntkbaccphr_Nil())
          {
            do
            {
              if (mosyntkbaccphr_GetRuleSetIsSubset(v10, v16))
              {
                BOOL v17 = 0;
              }
              else
              {
                int RuleSet = mosyntkbaccphr_GetRuleSet(1, v10, v16);
                BOOL v17 = RuleSet == mosyntkbaccphr_GetRule(0, v10, a3);
              }
              uint64_t v16 = mosyntkbaccphr_GetRuleSet(4, v10, v16);
            }
            while (v16 != mosyntkbaccphr_Nil() && !v17);
            if (v17)
            {
              int v19 = mosyntkbaccphr_GetScenario(1, v10, v14);
              uint64_t inserted = InsertScenario(a1, a2, v19, a4, &v24);
              if ((inserted & 0x80000000) != 0) {
                return inserted;
              }
              int v21 = mosyntkbaccphr_GetScenario(1, v10, v14);
              uint64_t v12 = InsertScenario(a1, a2, v21, v23, &v24);
              if ((v12 & 0x80000000) != 0) {
                return v12;
              }
            }
          }
        }
      }
      uint64_t Scenario = mosyntkbaccphr_GetRuleSet(4, v10, Scenario);
      if (Scenario == mosyntkbaccphr_Nil()) {
        return v12;
      }
    }
  }
  return 0;
}

uint64_t NoteAPRuleListAlloc(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0;
  uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v7, 0x18u);
  if ((result & 0x80000000) == 0)
  {
    *uint64_t v7 = *(void *)(a2 + 32);
    uint64_t v6 = v7;
    *(void *)(a2 + 32) = v7;
    *((_DWORD *)v6 + 2) = 4;
    unsigned char v6[2] = a3;
  }
  return result;
}

uint64_t IsMatchingNodeContext(uint64_t a1, uint64_t a2, uint64_t a3, void **a4, void *a5, int a6)
{
  unsigned int v33 = 0;
  uint64_t v11 = *(void *)(a2 + 16);
  switch(a6)
  {
    case 0:
      uint64_t v12 = 2;
      goto LABEL_6;
    case 1:
      uint64_t v12 = 3;
      goto LABEL_6;
    case 2:
      uint64_t v12 = 4;
LABEL_6:
      uint64_t Rule = mosyntkbaccphr_GetRule(v12, *(void *)(a2 + 16), a3);
      unsigned int v33 = Rule;
      goto LABEL_7;
    case 3:
      uint64_t v20 = mosyntkbaccphr_GetRule(5, *(void *)(a2 + 16), a3);
      break;
    default:
      uint64_t Rule = 0;
LABEL_7:
      if (mosyntkbaccphr_GetNode(3, v11, Rule))
      {
        char NodeMatchOp = mosyntkbaccphr_GetNodeMatchOp(v11, Rule);
        if (a6) {
          goto LABEL_14;
        }
        if ((NodeMatchOp & 1) == 0) {
          goto LABEL_14;
        }
        int v15 = (void *)a5[4];
        unsigned int v34 = Rule;
        if (v15 == a4) {
          goto LABEL_14;
        }
        do
        {
          int v16 = IsMatchingNode(a1, a2, &v34, (uint64_t)v15);
          LODWORD(v17) = v16;
          if (v16) {
            break;
          }
          int v15 = (void *)*v15;
        }
        while (v15 != a4);
        if (!v16)
        {
LABEL_14:
          if ((mosyntkbaccphr_GetNodeMatchOp(v11, Rule) & 2) != 0)
          {
            unsigned int v18 = mosyntkbaccphr_GetNodeMatchOp(v11, Rule);
            LODWORD(v17) = IsMatchingNodeNeighbours(a1, a2, &v33, a5, a6, (v18 >> 2) & 1);
            LODWORD(Rule) = v33;
          }
          else
          {
            LODWORD(v17) = 0;
          }
        }
      }
      else
      {
        LODWORD(v17) = 1;
      }
      if (mosyntkbaccphr_GetNodeNegated(v11, Rule)) {
        return v17 == 0;
      }
      else {
        return v17;
      }
  }
  while (1)
  {
    if (v20 == mosyntkbaccphr_Nil()) {
      return 0;
    }
    Childreuint64_t n = mosyntkbaccphr_GetChildren(1, v11, v20);
    if (!mosyntkbaccphr_GetChildrenOp(v11, v20)) {
      break;
    }
    if ((mosyntkbaccphr_GetNodeMatchOp(v11, Children) & 1) != 0
      && (int Node = mosyntkbaccphr_GetNode(8, v11, Children), Node == mosyntkbaccphr_Nil())
      && (char v23 = *a4, v34 = Children, v23))
    {
      do
      {
        uint64_t v17 = IsMatchingNode(a1, a2, &v34, (uint64_t)v23);
        if (v17) {
          break;
        }
        char v23 = (void *)*v23;
      }
      while (v23);
    }
    else
    {
      uint64_t v17 = 0;
    }
    while (Children != mosyntkbaccphr_Nil())
    {
      char v24 = mosyntkbaccphr_GetNodeMatchOp(v11, Children);
      Childreuint64_t n = mosyntkbaccphr_GetNode(8, v11, Children);
      if ((v24 & 2) == 0) {
        goto LABEL_55;
      }
    }
    if (v17) {
      goto LABEL_59;
    }
    if (a5[9])
    {
      uint64_t v29 = mosyntkbaccphr_GetChildren(1, v11, v20);
      uint64_t v30 = a5[2];
      uint64_t v31 = a5[9];
      unsigned __int8 v32 = mosyntkbaccphr_GetChildrenOp(v11, v20) == 2;
      uint64_t v17 = IsMatchingChildren(a1, a2, v29, v30, (uint64_t)a5, v31, v32);
    }
    else
    {
      uint64_t v17 = 0;
    }
LABEL_55:
    uint64_t v20 = mosyntkbaccphr_GetChildren(2, v11, v20);
    if (v17) {
      return v17;
    }
  }
  if (Children != mosyntkbaccphr_Nil())
  {
    while (1)
    {
      if ((mosyntkbaccphr_GetNodeMatchOp(v11, Children) & 1) == 0) {
        goto LABEL_62;
      }
      int v25 = *a4;
      unsigned int v34 = Children;
      if (!v25) {
        goto LABEL_62;
      }
      do
      {
        int v26 = IsMatchingNode(a1, a2, &v34, (uint64_t)v25);
        LODWORD(v17) = v26;
        if (v26) {
          break;
        }
        int v25 = (void *)*v25;
      }
      while (v25);
      if (!v26) {
LABEL_62:
      }
        LODWORD(v17) = (mosyntkbaccphr_GetNodeMatchOp(v11, Children) & 2) != 0
                    && (uint64_t v27 = (void *)a5[9]) != 0
                    && IsMatchingChildFuzzy(a1, a2, Children, v27);
      uint64_t v17 = mosyntkbaccphr_GetNodeNegated(v11, Children) ? v17 == 0 : v17;
      uint64_t v28 = mosyntkbaccphr_GetNode(8, v11, Children);
      if (!v17) {
        goto LABEL_55;
      }
      Childreuint64_t n = v28;
      if (v28 == mosyntkbaccphr_Nil()) {
        goto LABEL_59;
      }
    }
  }
  uint64_t v17 = 1;
LABEL_59:
  mosyntkbaccphr_GetChildren(2, v11, v20);
  return v17;
}

BOOL IsMatchingChildFuzzy(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v8 = *(void *)(a2 + 16);
  uint64_t v9 = (void *)a4[4];
  unsigned int v12 = a3;
  if (v9)
  {
    do
    {
      int v10 = IsMatchingNode(a1, a2, &v12, (uint64_t)v9);
      if (v10) {
        break;
      }
      uint64_t v9 = (void *)*v9;
    }
    while (v9);
    if (v10) {
      return 1;
    }
  }
  if ((mosyntkbaccphr_GetNodeMatchOp(v8, a3) & 4) != 0 && a4[9] && IsMatchingChildFuzzy(a1, a2, a3)) {
    return 1;
  }
  if (a4[7]) {
    return IsMatchingChildFuzzy(a1, a2, a3) != 0;
  }
  return 0;
}

uint64_t IsMatchingChildren(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned __int8 a7)
{
  while (2)
  {
    if (*(void *)(a6 + 16) == a4)
    {
      BOOL v14 = *(_DWORD *)(a6 + 92) == 0;
      int v13 = (void *)a6;
    }
    else
    {
      int v13 = *(void **)(a4 + 48);
      if (v13)
      {
        BOOL v14 = 0;
      }
      else
      {
        int v13 = *(void **)(a4 + 32);
        BOOL v14 = 1;
      }
    }
    uint64_t v15 = *(void *)(a2 + 16);
    do
    {
      while (1)
      {
        uint64_t v16 = v13[4];
        unsigned int v28 = a3;
        if (!v16) {
          goto LABEL_22;
        }
        do
        {
          int v17 = IsMatchingNode(a1, a2, &v28, v16);
          if (v17) {
            break;
          }
          uint64_t v16 = *(void *)v16;
        }
        while (v16);
        if (!v17) {
          goto LABEL_20;
        }
        int Node = mosyntkbaccphr_GetNode(8, v15, a3);
        if (Node != mosyntkbaccphr_Nil())
        {
          if ((mosyntkbaccphr_GetNodeMatchOp(v15, a3) & 4) != 0 && *(_DWORD *)v13[3] < **(_DWORD **)(a6 + 24))
          {
            uint64_t v19 = mosyntkbaccphr_GetNode(8, v15, a3);
            uint64_t v20 = v13[3];
            uint64_t v21 = a7;
            uint64_t v22 = a1;
            uint64_t v23 = a2;
            uint64_t v24 = a5;
            uint64_t v25 = a6;
LABEL_19:
            uint64_t v16 = IsMatchingChildren(v22, v23, v19, v20, v24, v25, v21);
            goto LABEL_22;
          }
          if (*(void *)(a6 + 56))
          {
            uint64_t v19 = mosyntkbaccphr_GetNode(8, v15, a3);
            uint64_t v25 = *(void *)(a6 + 56);
            uint64_t v20 = *(void *)(v25 + 16);
            uint64_t v21 = a7;
            uint64_t v22 = a1;
            uint64_t v23 = a2;
            uint64_t v24 = a5;
            goto LABEL_19;
          }
LABEL_20:
          uint64_t v16 = 0;
          goto LABEL_22;
        }
        uint64_t v16 = !a7 || (unint64_t)(v13[3] == *(void *)(a5 + 24));
LABEL_22:
        if ((mosyntkbaccphr_GetNodeMatchOp(v15, a3) & 4) == 0) {
          goto LABEL_28;
        }
        int v13 = (void *)*v13;
        if (!v13) {
          break;
        }
        if (v16) {
          goto LABEL_28;
        }
      }
      if (v14) {
        break;
      }
      int v13 = *(void **)(a4 + 32);
      BOOL v14 = 1;
    }
    while (!v16);
LABEL_28:
    if (!(v16 | a7))
    {
      if ((mosyntkbaccphr_GetNodeMatchOp(v15, a3) & 4) != 0 && *(_DWORD *)a4 + 1 < **(_DWORD **)(a6 + 24))
      {
        a7 = 0;
        a4 = *(void *)(a4 + 16);
        continue;
      }
      a6 = *(void *)(a6 + 56);
      if (a6)
      {
        a7 = 0;
        a4 = *(void *)(a6 + 16);
        continue;
      }
      return 0;
    }
    return v16;
  }
}

uint64_t IsMatchingNodeNeighbours(uint64_t a1, uint64_t a2, unsigned int *a3, void *a4, int a5, int a6)
{
  while (1)
  {
    int v6 = a6;
    int v7 = a5;
    uint64_t v8 = a4;
    uint64_t v9 = a3;
    uint64_t v10 = a2;
    uint64_t v11 = a1;
    int v38 = 0;
    uint64_t v37 = 0;
    uint64_t v12 = *(void *)(a2 + 16);
    if (mosyntkbaccphr_GetNode(3, v12, *a3) == 3) {
      break;
    }
    if (v7 == 2)
    {
      uint64_t v18 = v8[3];
      uint64_t v19 = *(void **)(v18 + 48);
      if (v19)
      {
        do
        {
          uint64_t v20 = (void *)v19[4];
          LODWORD(v39) = *v9;
          if (v20)
          {
            do
            {
              uint64_t result = IsMatchingNode(v11, v10, (unsigned int *)&v39, (uint64_t)v20);
              if (result) {
                break;
              }
              uint64_t v20 = (void *)*v20;
            }
            while (v20);
          }
          else
          {
            uint64_t result = 0;
          }
          if (result) {
            break;
          }
          uint64_t v19 = (void *)*v19;
        }
        while (v19);
        uint64_t v18 = v8[3];
        if (result) {
          return result;
        }
      }
      else
      {
        uint64_t result = 0;
      }
      int v26 = *(void **)(v18 + 32);
      if (!v26) {
        return result;
      }
      uint64_t v27 = (void *)v26[4];
      LODWORD(v39) = *v9;
      if (v27)
      {
        do
        {
          uint64_t result = IsMatchingNode(v11, v10, (unsigned int *)&v39, (uint64_t)v27);
          if (result) {
            break;
          }
          uint64_t v27 = (void *)*v27;
        }
        while (v27);
      }
      else
      {
        uint64_t result = 0;
      }
      if (!v6 || result) {
        return result;
      }
      a1 = v11;
      a2 = v10;
      a3 = v9;
      a4 = v26;
      a5 = 2;
    }
    else if (v7 == 1)
    {
      uint64_t v21 = v8[2];
      uint64_t v22 = *(void *)(v21 + 40);
      if (v22)
      {
        do
        {
          uint64_t v23 = *(void **)(v22 + 32);
          LODWORD(v39) = *v9;
          if (v23)
          {
            do
            {
              uint64_t result = IsMatchingNode(v11, v10, (unsigned int *)&v39, (uint64_t)v23);
              if (result) {
                break;
              }
              uint64_t v23 = (void *)*v23;
            }
            while (v23);
          }
          else
          {
            uint64_t result = 0;
          }
          if (result) {
            break;
          }
          uint64_t v22 = *(void *)(v22 + 8);
        }
        while (v22);
        uint64_t v21 = v8[2];
        if (result) {
          return result;
        }
      }
      else
      {
        uint64_t result = 0;
      }
      unsigned int v28 = *(void **)(v21 + 24);
      if (!v28) {
        return result;
      }
      uint64_t v29 = (void *)v28[4];
      LODWORD(v39) = *v9;
      if (v29)
      {
        do
        {
          uint64_t result = IsMatchingNode(v11, v10, (unsigned int *)&v39, (uint64_t)v29);
          if (result) {
            break;
          }
          uint64_t v29 = (void *)*v29;
        }
        while (v29);
      }
      else
      {
        uint64_t result = 0;
      }
      if (!v6 || result) {
        return result;
      }
      a1 = v11;
      a2 = v10;
      a3 = v9;
      a4 = v28;
      a5 = 1;
    }
    else
    {
      if (v7) {
        return 0;
      }
      uint64_t v15 = v8[6];
      if (!v15) {
        return 0;
      }
      uint64_t v16 = *(void **)(v15 + 32);
      LODWORD(v39) = *v9;
      if (v16)
      {
        do
        {
          uint64_t result = IsMatchingNode(v11, v10, (unsigned int *)&v39, (uint64_t)v16);
          if (result) {
            break;
          }
          uint64_t v16 = (void *)*v16;
        }
        while (v16);
      }
      else
      {
        uint64_t result = 0;
      }
      if (!v6 || result) {
        return result;
      }
      a4 = (void *)v8[6];
      a1 = v11;
      a2 = v10;
      a3 = v9;
      a5 = 0;
    }
    a6 = 1;
  }
  if (v7 != 2)
  {
    if (v7 == 1)
    {
      if (mosyntkbaccphr_GetNode(7, v12, *v9) == 1)
      {
        uint64_t v13 = v8[2];
        int v39 = 0;
        if (v13)
        {
          mosyntdata_GetSentTermCommList(v11, *(void *)(v10 + 40), *(_DWORD *)(v13 + 64), &v39);
          uint64_t result = v39 != 0;
          if (!v6) {
            return result;
          }
        }
        else
        {
          uint64_t result = 0;
          if (!v6) {
            return result;
          }
        }
        if ((result & 1) == 0)
        {
          uint64_t v32 = v8[2];
          do
          {
            uint64_t v32 = *(void *)(v32 + 8);
            if (!v32) {
              break;
            }
            int v39 = 0;
            mosyntdata_GetSentTermCommList(v11, *(void *)(v10 + 40), *(_DWORD *)(v32 + 64), &v39);
          }
          while (!v39);
          return v32 != 0;
        }
        return result;
      }
      if (mosyntkbaccphr_GetNode(7, v12, *v9) == 2)
      {
        uint64_t v24 = *(void *)(v8[2] + 8);
        return v6 || v24 == 0;
      }
    }
    return 0;
  }
  if (mosyntkbaccphr_GetNode(7, v12, *v9) != 1)
  {
    if (mosyntkbaccphr_GetNode(7, v12, *v9) == 3)
    {
      uint64_t v24 = *(void *)(v8[3] + 16);
      return v6 || v24 == 0;
    }
    if (mosyntkbaccphr_GetNode(7, v12, *v9) == 4)
    {
      uint64_t v30 = v8[3];
      int v39 = 0;
      if (v30)
      {
        mosyntdata_GetSentTermCommList(v11, *(void *)(v10 + 40), *(_DWORD *)(v30 + 64), &v39);
        uint64_t v31 = v39;
      }
      else
      {
        uint64_t v31 = 0;
      }
      mosyntdata_GetPunctFromCommandList(v11, v31, &v38, &v37);
      uint64_t result = v38 == 10;
      if (!v6 || v38 == 10) {
        return result;
      }
      uint64_t v33 = *(void *)(v8[3] + 16);
      if (v33)
      {
        do
        {
          uint64_t v34 = v8[3];
          int v39 = 0;
          if (v34)
          {
            mosyntdata_GetSentTermCommList(v11, *(void *)(v10 + 40), *(_DWORD *)(v34 + 64), &v39);
            int v35 = v39;
          }
          else
          {
            int v35 = 0;
          }
          mosyntdata_GetPunctFromCommandList(v11, v35, &v38, &v37);
          uint64_t v33 = *(void *)(v33 + 16);
        }
        while (v38 != 10 && v33 != 0);
        return v38 == 10;
      }
    }
    return 0;
  }
  uint64_t v17 = v8[3];
  int v39 = 0;
  if (v17)
  {
    mosyntdata_GetSentTermCommList(v11, *(void *)(v10 + 40), *(_DWORD *)(v17 + 64), &v39);
    uint64_t result = v39 != 0;
    if (!v6) {
      return result;
    }
  }
  else
  {
    uint64_t result = 0;
    if (!v6) {
      return result;
    }
  }
  if ((result & 1) == 0)
  {
    uint64_t v32 = v8[3];
    do
    {
      uint64_t v32 = *(void *)(v32 + 16);
      if (!v32) {
        break;
      }
      int v39 = 0;
      mosyntdata_GetSentTermCommList(v11, *(void *)(v10 + 40), *(_DWORD *)(v32 + 64), &v39);
    }
    while (!v39);
    return v32 != 0;
  }
  return result;
}

uint64_t IsMatchingNode(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a2 + 16);
  unsigned __int8 v16 = 0;
  switch(mosyntkbaccphr_GetNode(3, v7, *a3))
  {
    case 0u:
      return 1;
    case 1u:
      uint64_t v8 = (uint64_t **)(a4 + 16);
      break;
    case 2u:
      int Node = mosyntkbaccphr_GetNode(5, v7, *a3);
      unsigned int v15 = mosyntkbaccphr_GetNode(6, v7, *a3);
      mosyntkbaccphr_CheckMatchingConsFeat2(a1, v7, Node, v15, *(__int16 *)(*(void *)(a4 + 8) + 16), (unsigned __int16 *)(*(void *)(a4 + 8) + 24), (char *)&v16);
      return v16;
    case 3u:
      mosyntbase_WriteDevelMessage(a1, "IsMatchingNode -- Property, not handeled here\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, 0, 0, 0);
      return 0;
    default:
      return 0;
  }
  while (1)
  {
    uint64_t v8 = (uint64_t **)*v8;
    if (!v8) {
      break;
    }
    int v9 = mosyntkbaccphr_GetNode(4, v7, *a3);
    int Rule = mosyntkbaccphr_GetRule(0, v7, *((unsigned int *)v8 + 2));
    int v11 = mosyntkbaccphr_GetRule(0, v7, *((unsigned int *)v8 + 2));
    if (Rule >= 0) {
      int v12 = v11;
    }
    else {
      int v12 = -v11;
    }
    if (v9 == v12) {
      return 1;
    }
  }
  return 0;
}

uint64_t InsertScenario(uint64_t a1, uint64_t a2, int a3, uint64_t *a4, _DWORD *a5)
{
  int v6 = 0;
  *a5 = 1;
  uint64_t v7 = a4;
  while (1)
  {
    uint64_t v8 = v6;
    int v11 = v6;
    int v6 = (uint64_t *)*v7;
    if (!*v7) {
      break;
    }
    int v9 = *((_DWORD *)v6 + 2);
    uint64_t v7 = (uint64_t *)*v7;
    if (v9 >= a3)
    {
      if (v8)
      {
        if (v9 <= a3) {
          goto LABEL_13;
        }
        goto LABEL_8;
      }
      if (v9 <= a3)
      {
LABEL_13:
        uint64_t result = 0;
        *a5 = 0;
        return result;
      }
      goto LABEL_11;
    }
  }
  if (v8)
  {
LABEL_8:
    uint64_t result = NewScenarioList(a1, a2, a3, v8);
    if ((result & 0x80000000) == 0) {
      *(void *)*uint64_t v8 = v6;
    }
    return result;
  }
LABEL_11:
  uint64_t result = NewScenarioList(a1, a2, a3, (uint64_t *)&v11);
  if ((result & 0x80000000) == 0)
  {
    *int v11 = *a4;
    *a4 = (uint64_t)v11;
  }
  return result;
}

uint64_t NewScenarioList(uint64_t a1, uint64_t a2, int a3, uint64_t *a4)
{
  uint64_t v7 = *(void *)(a2 + 80);
  if (v7)
  {
    uint64_t result = 0;
    *a4 = v7;
    *(void *)(a2 + 80) = **(void **)(a2 + 80);
LABEL_6:
    uint64_t v12 = *a4;
    *(_DWORD *)(v12 + 8) = a3;
    *(void *)uint64_t v12 = 0;
    return result;
  }
  uint64_t result = mosyntpal_ALLOCATE(a1, a4, 0x10u);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v10 = *a4;
    uint64_t v13 = 0;
    uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v13, 0x18u);
    if ((result & 0x80000000) == 0)
    {
      void *v13 = *(void *)(a2 + 32);
      int v11 = v13;
      *(void *)(a2 + 32) = v13;
      *((_DWORD *)v11 + 2) = 6;
      v11[2] = v10;
      goto LABEL_6;
    }
  }
  return result;
}

uint64_t AddSegment(uint64_t a1, uint64_t a2, int a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v21 = 0;
  uint64_t v10 = mosyntpal_ALLOCATE(a1, &v21, 0x28u);
  if ((v10 & 0x80000000) != 0) {
    return v10;
  }
  uint64_t v11 = v21;
  uint64_t v22 = 0;
  uint64_t v12 = mosyntpal_ALLOCATE(a1, (uint64_t *)&v22, 0x18u);
  if ((v12 & 0x80000000) == 0)
  {
    *uint64_t v22 = *(void *)(a2 + 32);
    uint64_t v13 = v22;
    *(void *)(a2 + 32) = v22;
    *((_DWORD *)v13 + 2) = 7;
    _OWORD v13[2] = v11;
    uint64_t v14 = v21;
    *(void *)(v21 + 8) = a4;
    *(void *)(v14 + 16) = a5;
    *(_DWORD *)(v14 + 24) = a3;
    *(_DWORD *)(v14 + 28) = *a5 - *(_DWORD *)a4;
    uint64_t v15 = *(void *)(a2 + 16);
    for (uint64_t i = mosyntkbaccphr_GetScenario(2, v15, *(unsigned int *)(a2 + 60));
          ;
          uint64_t i = mosyntkbaccphr_GetRuleSet(4, v15, v17))
    {
      uint64_t v17 = i;
      if (i == mosyntkbaccphr_Nil()
        || mosyntkbaccphr_GetRuleSet(2, v15, v17) == a3)
      {
        break;
      }
    }
    if (v17 == mosyntkbaccphr_Nil()) {
      int RuleSet = 10000;
    }
    else {
      int RuleSet = mosyntkbaccphr_GetRuleSet(3, v15, v17);
    }
    uint64_t v19 = (void *)v21;
    *(_DWORD *)(v21 + 32) = RuleSet;
    *uint64_t v19 = *(void *)(a4 + 56);
    *(void *)(a4 + 56) = v21;
  }
  return v12;
}

uint64_t GetBestScenarioPathSuffix(uint64_t a1, void *a2, uint64_t **a3, uint64_t a4, uint64_t a5, int *a6, _DWORD *a7, _DWORD *a8, uint64_t *a9)
{
  int v9 = a8;
  uint64_t v17 = *(void *)(a4 + 16);
  if (v17 == a5)
  {
    uint64_t result = 0;
    *a6 = 0;
    *a7 = 0;
    *a8 = 0;
    *a9 = 0;
  }
  else
  {
    uint64_t result = GetBestScenarioPathSuffix(a1, a2, a3, v17, a5, a6, a7, a8, a9);
    if ((result & 0x80000000) != 0) {
      return result;
    }
  }
  uint64_t v19 = *(uint64_t **)(a4 + 56);
  if (!v19) {
    return result;
  }
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v37 = 0;
  int v38 = 0;
  int v36 = v9;
  while (1)
  {
    if (v19[2] == a5)
    {
      uint64_t v40 = 0;
      HIDWORD(v39) = 0;
      uint64_t v37 = 0;
      if (!a3) {
        goto LABEL_30;
      }
      int v22 = *((_DWORD *)v19 + 6);
      uint64_t v23 = (uint64_t *)a3;
      while (1)
      {
        int v24 = *((_DWORD *)v23 + 2);
        if (v24 >= v22) {
          break;
        }
        uint64_t v23 = (uint64_t *)*v23;
        if (!v23) {
          goto LABEL_30;
        }
      }
      if (v24 == v22) {
        LODWORD(v39) = 0;
      }
      else {
LABEL_30:
      }
        LODWORD(v39) = 1;
      goto LABEL_31;
    }
    if (a3) {
      break;
    }
    int v38 = 0;
LABEL_21:
    uint64_t result = InsertScenario(a1, (uint64_t)a2, *((_DWORD *)v19 + 6), (uint64_t *)&v38, &v39);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    uint64_t result = GetBestScenarioPathSuffix(a1, a2, v38, v19[2], a5, (char *)&v40 + 4, &v40, (char *)&v39 + 4, &v37);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    uint64_t v25 = v38;
    if (v38)
    {
      do
      {
        int v26 = v25;
        uint64_t v25 = (void *)*v25;
      }
      while (v25);
      uint64_t result = 0;
      *int v26 = a2[10];
      a2[10] = v38;
      int v38 = 0;
    }
    else
    {
      uint64_t result = 0;
    }
    int v9 = v36;
LABEL_31:
    int v27 = *((_DWORD *)v19 + 7) + HIDWORD(v40);
    if (v27 <= *a6)
    {
      if (v27 != *a6) {
        goto LABEL_49;
      }
      int v28 = v40;
      int v29 = *((_DWORD *)v19 + 8) + v40;
      if (v29 >= *a7 && (v29 != *a7 || (int)v39 + HIDWORD(v39) >= *v9)) {
        goto LABEL_49;
      }
    }
    else
    {
      int v28 = v40;
    }
    *a6 = v27;
    *a7 = *((_DWORD *)v19 + 8) + v28;
    *int v9 = v39 + HIDWORD(v39);
    uint64_t v30 = *a9;
    if (*a9)
    {
      uint64_t v31 = *(void **)v30;
      if (*(void *)v30)
      {
        do
        {
          uint64_t v32 = v31;
          uint64_t v31 = (void *)*v31;
        }
        while (v31);
        *uint64_t v32 = a2[11];
        a2[11] = *(void *)v30;
        *(void *)uint64_t v30 = 0;
        uint64_t v30 = *a9;
      }
      uint64_t result = 0;
      *(void *)(v30 + 8) = v19;
    }
    else
    {
      uint64_t v33 = a2[11];
      if (v33)
      {
        uint64_t result = 0;
        *a9 = v33;
        a2[11] = *(void *)a2[11];
      }
      else
      {
        uint64_t result = mosyntpal_ALLOCATE(a1, a9, 0x10u);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t v34 = *a9;
        uint64_t v41 = 0;
        uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v41, 0x18u);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        *uint64_t v41 = a2[4];
        int v35 = v41;
        a2[4] = v41;
        *((_DWORD *)v35 + 2) = 8;
        v35[2] = v34;
        int v9 = v36;
      }
      *(void *)(*a9 + 8) = v19;
      *(void *)*a9 = 0;
    }
    *(void *)*a9 = v37;
LABEL_49:
    uint64_t v19 = (uint64_t *)*v19;
    if (!v19) {
      return result;
    }
  }
  uint64_t result = NewScenarioList(a1, (uint64_t)a2, *((_DWORD *)a3 + 2), (uint64_t *)&v38);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  uint64_t v20 = *a3;
  if (!*a3) {
    goto LABEL_21;
  }
  uint64_t v21 = (uint64_t *)&v38;
  while (1)
  {
    uint64_t v21 = (uint64_t *)*v21;
    uint64_t result = NewScenarioList(a1, (uint64_t)a2, *((_DWORD *)v20 + 2), v21);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    uint64_t v20 = (uint64_t *)*v20;
    if (!v20) {
      goto LABEL_21;
    }
  }
}

uint64_t IsRightMatchingTarget(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5)
{
  while (1)
  {
    uint64_t v10 = *(void *)(a2 + 16);
    *a5 = a4;
    uint64_t v11 = (void *)a4[4];
    unsigned int v15 = a3;
    if (v11)
    {
      do
      {
        uint64_t result = IsMatchingNode(a1, a2, &v15, (uint64_t)v11);
        if (result) {
          break;
        }
        uint64_t v11 = (void *)*v11;
      }
      while (v11);
      if (result) {
        break;
      }
    }
    if ((mosyntkbaccphr_GetNodeMatchOp(v10, a3) & 4) != 0)
    {
      uint64_t v13 = a4[9];
      if (v13)
      {
        do
        {
          uint64_t v14 = v13;
          uint64_t v13 = *(void *)(v13 + 56);
        }
        while (v13);
        uint64_t result = IsRightMatchingTarget(a1, a2, a3, v14, a5);
        if (result) {
          break;
        }
      }
    }
    a4 = (void *)a4[8];
    if (!a4) {
      return 0;
    }
  }
  return result;
}

BOOL IsLeftMatchingTarget(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5)
{
  uint64_t v10 = *(void *)(a2 + 16);
  *a5 = a4;
  uint64_t v11 = (void *)a4[4];
  unsigned int v16 = a3;
  if (v11)
  {
    do
    {
      int v12 = IsMatchingNode(a1, a2, &v16, (uint64_t)v11);
      if (v12) {
        break;
      }
      uint64_t v11 = (void *)*v11;
    }
    while (v11);
    if (v12) {
      return 1;
    }
  }
  if ((mosyntkbaccphr_GetNodeMatchOp(v10, a3) & 4) != 0)
  {
    uint64_t v13 = a4[9];
    if (v13)
    {
      if (IsLeftMatchingTarget(a1, a2, a3, v13, a5)) {
        return 1;
      }
    }
  }
  uint64_t v15 = a4[7];
  return v15 && IsLeftMatchingTarget(a1, a2, a3, v15, a5) != 0;
}

uint64_t mosyntsentpho_TreatSentPho(uint64_t a1, int a2, uint64_t a3, int *a4, int *a5, int *a6, uint64_t *a7, uint64_t **a8)
{
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v18 = 0;
  uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v18, 0x10u);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v17 = v18;
    *uint64_t v18 = a2;
    *((void *)v17 + 1) = a3;
    uint64_t result = ApplyFSTSeq(a1, (uint64_t)v17, 5, a4, a7, &v20);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = ApplyFSTSeq(a1, (uint64_t)v18, 6, a5, v20, &v19);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = mosyntdata_DisposePhonEleList(a1, &v20);
        if ((result & 0x80000000) == 0)
        {
          uint64_t result = ApplyFSTSeq(a1, (uint64_t)v18, 7, a6, v19, a8);
          if ((result & 0x80000000) == 0)
          {
            uint64_t result = mosyntdata_DisposePhonEleList(a1, &v19);
            if ((result & 0x80000000) == 0)
            {
              if (v18) {
                return mosyntpal_DEALLOCATE(a1, (uint64_t *)&v18);
              }
              else {
                return 0;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t ApplyFSTSeq(uint64_t a1, uint64_t a2, int a3, int *a4, uint64_t *a5, uint64_t **a6)
{
  uint64_t v15 = a5;
  *a6 = a5;
  uint64_t result = mosyntdata_CopyPhonList(a1, a6);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    uint64_t result = mosynttrans_InitTransDesc(a1, *(_DWORD *)a2, *(void *)(a2 + 8), &v13);
    if ((result & 0x80000000) == 0)
    {
      if (*a4 < 1)
      {
        return mosynttrans_FinishTransDesc(a1, &v13);
      }
      else
      {
        uint64_t v12 = 0;
        while (1)
        {
          uint64_t v15 = *a6;
          uint64_t result = mosynttrans_TransducePhonList(a1, v13, a3, *(void *)&a4[2 * v12 + 2], v12, v15, 0, 0, a6, &v14);
          if ((result & 0x80000000) != 0) {
            break;
          }
          uint64_t result = mosyntdata_DisposePhonEleList(a1, &v15);
          if ((result & 0x80000000) != 0) {
            break;
          }
          if (++v12 >= *a4) {
            return mosynttrans_FinishTransDesc(a1, &v13);
          }
        }
      }
    }
  }
  return result;
}

uint64_t mosyntkbwgram_GetFirstEpsTrans(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4, unsigned char *a5, int *a6)
{
  int v8 = 0;
  uint64_t result = wgram_GetFirstEpsTrans(a1, a2, a3, a4, &v8, a6);
  *a5 = v8;
  return result;
}

uint64_t mosyntkbwgram_GetNextEpsTrans(uint64_t a1, int a2, unsigned int *a3, _DWORD *a4, unsigned char *a5, int *a6)
{
  int v8 = 0;
  uint64_t result = wgram_GetNextEpsTrans(a1, a2, a3, a4, &v8, a6);
  *a5 = v8;
  return result;
}

uint64_t kbsymtab_LoadData(_WORD *a1, int a2, _WORD *a3, int a4, uint64_t *a5, int a6)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  uint64_t v59 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v59);
  uint64_t v13 = inited;
  if (!a5) {
    return v13;
  }
  if ((inited & 0x80000000) != 0) {
    return v13;
  }
  uint64_t v13 = 2371887114;
  uint64_t v14 = heap_Calloc(*(void **)(v59 + 8), 1, 16624);
  *a5 = v14;
  if (!v14) {
    return v13;
  }
  uint64_t Lex = kblex_loadLex(a1, a2, a3, a4, 3, (void *)(v14 + 8584));
  if ((Lex & 0x80000000) != 0) {
    goto LABEL_31;
  }
  uint64_t Lex = kblex_loadLex(a1, a2, a3, a4, 4, (void *)(*a5 + 8592));
  if ((Lex & 0x80000000) != 0) {
    goto LABEL_31;
  }
  uint64_t Lex = kblex_loadLex(a1, a2, a3, a4, 5, (void *)(*a5 + 8600));
  if ((Lex & 0x80000000) != 0) {
    goto LABEL_31;
  }
  uint64_t Lex = kblex_loadLex(a1, a2, a3, a4, 6, (void *)(*a5 + 8608));
  if ((Lex & 0x80000000) != 0) {
    goto LABEL_31;
  }
  uint64_t v13 = kblex_loadLex(a1, a2, a3, a4, 7, (void *)(*a5 + 8616));
  if ((v13 & 0x80000000) != 0)
  {
LABEL_32:
    freeTabsAsLex(*a5, a1, a2, a3, a4);
    heap_Free(*(void **)(v59 + 8), *a5);
    *a5 = 0;
    return v13;
  }
  if (!*a5) {
    return v13;
  }
  *(void *)(*a5 + 120) = heap_Calloc(*(void **)(v59 + 8), 1, 1000);
  *(void *)(*a5 + 128) = LhpuCreate(*(void *)(v59 + 8));
  unsigned int v16 = (void *)*a5;
  if (!*(void *)(*a5 + 120) || !v16[16]) {
    uint64_t v13 = 2371887114;
  }
  *unsigned int v16 = v59;
  *(_DWORD *)(*a5 + 8) = 1;
  for (uint64_t i = 1078; i != 2078; ++i)
    *(void *)(*a5 + 8 * i) = 0;
  uint64_t v18 = *a5;
  *(_DWORD *)(*a5 + 8536) = 0;
  if (a6)
  {
    for (uint64_t j = 0; j != 100; ++j)
    {
      LOWORD(__s) = j;
      *(_DWORD *)(v18 + 4 * j + 136) = kbsymtab_KnownGraphId(v18, (unsigned __int8 *)&__s);
    }
    uint64_t v20 = 0;
    uint64_t v21 = (char *)(v18 + 536);
    do
    {
      kbsymtab_GraphSymString(v18, v20, (char *)&__s, 0x64uLL);
      if (strlen((const char *)&__s) > 7) {
        char *v21 = 0;
      }
      else {
        strcpy(v21, (const char *)&__s);
      }
      ++v20;
      v21 += 8;
    }
    while (v20 != 1000);
    *(_DWORD *)(v18 + 8536) = 1;
    uint64_t v18 = *a5;
  }
  *(_DWORD *)(v18 + 12) = kbsymtab_KnownGraphId(v18, "#");
  int v22 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{*}");
  *(_DWORD *)(v18 + 16) = v22 & ~(v22 >> 31);
  int v23 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"&");
  *(_DWORD *)(v18 + 20) = v23 & ~(v23 >> 31);
  int v24 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"#");
  *(_DWORD *)(v18 + 24) = v24 & ~(v24 >> 31);
  int v25 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{#ACC0}");
  *(_DWORD *)(v18 + 28) = v25 & ~(v25 >> 31);
  int v26 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{#ACC1}");
  *(_DWORD *)(v18 + 32) = v26 & ~(v26 >> 31);
  int v27 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{#ACC2}");
  *(_DWORD *)(v18 + 36) = v27 & ~(v27 >> 31);
  int v28 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{#ACC3}");
  *(_DWORD *)(v18 + 40) = v28 & ~(v28 >> 31);
  int v29 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{#ACC4}");
  *(_DWORD *)(v18 + 44) = v29 & ~(v29 >> 31);
  int v30 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)".");
  *(_DWORD *)(v18 + 48) = v30 & ~(v30 >> 31);
  int v31 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"'");
  *(_DWORD *)(v18 + 52) = v31 & ~(v31 >> 31);
  int v32 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"'2");
  *(_DWORD *)(v18 + 56) = v32 & ~(v32 >> 31);
  int v33 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"_");
  *(_DWORD *)(v18 + 60) = v33 & ~(v33 >> 31);
  int v34 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"_");
  *(_DWORD *)(v18 + 64) = v34 & ~(v34 >> 31);
  int v35 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"*");
  *(_DWORD *)(v18 + 68) = v35 & ~(v35 >> 31);
  int v36 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{#PB-S}");
  *(_DWORD *)(v18 + 72) = v36 & ~(v36 >> 31);
  int v37 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"+");
  *(_DWORD *)(v18 + 76) = v37 & ~(v37 >> 31);
  int v38 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{#PB-W}");
  *(_DWORD *)(v18 + 80) = v38 & ~(v38 >> 31);
  int v39 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{#BEG}");
  *(_DWORD *)(v18 + 84) = v39 & ~(v39 >> 31);
  int v40 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{#END}");
  *(_DWORD *)(v18 + 88) = v40 & ~(v40 >> 31);
  int v41 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)".");
  *(_DWORD *)(v18 + 92) = v41 & ~(v41 >> 31);
  int v42 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"{#WB}");
  *(_DWORD *)(v18 + 96) = v42 & ~(v42 >> 31);
  int v43 = dictSingleLookupInt((uint64_t *)v18, 0, (uint64_t)"\"");
  *(_DWORD *)(v18 + 100) = v43 & ~(v43 >> 31);
  int v44 = dictSingleLookupInt((uint64_t *)v18, 1, (uint64_t)"*");
  *(_DWORD *)(v18 + 104) = v44 & ~(v44 >> 31);
  int v45 = dictSingleLookupInt((uint64_t *)v18, 1, (uint64_t)"**");
  *(_DWORD *)(v18 + 108) = v45 & ~(v45 >> 31);
  int v46 = dictSingleLookupInt((uint64_t *)v18, 1, (uint64_t)"%");
  *(_DWORD *)(v18 + 112) = v46 & ~(v46 >> 31);
  int v47 = dictSingleLookupInt((uint64_t *)v18, 1, (uint64_t)"%%");
  *(_DWORD *)(v18 + 116) = v47 & ~(v47 >> 31);
  if ((v13 & 0x80000000) != 0) {
    goto LABEL_32;
  }
  uint64_t v48 = *(void **)(v59 + 8);
  uint64_t v49 = (uint64_t *)(*a5 + 8544);
  *(void *)&long long __s = ssftmap_ElemCopyString;
  *((void *)&__s + 1) = ssftmap_ElemFreeString;
  uint64_t v61 = ssftmap_ElemCompareKeysString;
  uint64_t v62 = ssftmap_ElemCopyString;
  uint64_t v63 = ssftmap_ElemFreeString;
  uint64_t Lex = ssftmap_ObjOpen(v48, 0, &__s, v49);
  if ((Lex & 0x80000000) != 0) {
    goto LABEL_31;
  }
  uint64_t v50 = *(void **)(v59 + 8);
  uint64_t v51 = (uint64_t *)(*a5 + 8552);
  *(void *)&long long __s = ssftmap_ElemCopyString;
  *((void *)&__s + 1) = ssftmap_ElemFreeString;
  uint64_t v61 = ssftmap_ElemCompareKeysString;
  uint64_t v62 = ssftmap_ElemCopyString;
  uint64_t v63 = ssftmap_ElemFreeString;
  uint64_t Lex = ssftmap_ObjOpen(v50, 0, &__s, v51);
  if ((Lex & 0x80000000) != 0) {
    goto LABEL_31;
  }
  uint64_t v52 = *(void **)(v59 + 8);
  uint64_t v53 = (uint64_t *)(*a5 + 8560);
  *(void *)&long long __s = ssftmap_ElemCopyString;
  *((void *)&__s + 1) = ssftmap_ElemFreeString;
  uint64_t v61 = ssftmap_ElemCompareKeysString;
  uint64_t v62 = ssftmap_ElemCopyString;
  uint64_t v63 = ssftmap_ElemFreeString;
  uint64_t Lex = ssftmap_ObjOpen(v52, 0, &__s, v53);
  if ((Lex & 0x80000000) != 0) {
    goto LABEL_31;
  }
  uint64_t v54 = *(void **)(v59 + 8);
  unsigned int v55 = (uint64_t *)(*a5 + 8568);
  *(void *)&long long __s = ssftmap_ElemCopyString;
  *((void *)&__s + 1) = ssftmap_ElemFreeString;
  uint64_t v61 = ssftmap_ElemCompareKeysString;
  uint64_t v62 = ssftmap_ElemCopyString;
  uint64_t v63 = ssftmap_ElemFreeString;
  uint64_t Lex = ssftmap_ObjOpen(v54, 0, &__s, v55);
  if ((Lex & 0x80000000) != 0)
  {
LABEL_31:
    uint64_t v13 = Lex;
    goto LABEL_32;
  }
  uint64_t v56 = *(void **)(v59 + 8);
  unsigned int v57 = (uint64_t *)(*a5 + 8576);
  *(void *)&long long __s = ssftmap_ElemCopyString;
  *((void *)&__s + 1) = ssftmap_ElemFreeString;
  uint64_t v61 = ssftmap_ElemCompareKeysString;
  uint64_t v62 = ssftmap_ElemCopyString;
  uint64_t v63 = ssftmap_ElemFreeString;
  uint64_t v13 = ssftmap_ObjOpen(v56, 0, &__s, v57);
  if ((v13 & 0x80000000) != 0) {
    goto LABEL_32;
  }
  return v13;
}

uint64_t freeTabsAsLex(uint64_t result, _WORD *a2, int a3, _WORD *a4, int a5)
{
  int v9 = (void *)result;
  uint64_t v10 = *(void *)(result + 8584);
  if (v10) {
    uint64_t result = kblex_FinishLex(a2, a3, a4, a5, v10);
  }
  uint64_t v11 = v9[1074];
  if (v11) {
    uint64_t result = kblex_FinishLex(a2, a3, a4, a5, v11);
  }
  uint64_t v12 = v9[1075];
  if (v12) {
    uint64_t result = kblex_FinishLex(a2, a3, a4, a5, v12);
  }
  uint64_t v13 = v9[1076];
  if (v13) {
    uint64_t result = kblex_FinishLex(a2, a3, a4, a5, v13);
  }
  uint64_t v14 = v9[1077];
  if (v14)
  {
    return kblex_FinishLex(a2, a3, a4, a5, v14);
  }
  return result;
}

uint64_t kbsymtab_UnloadData(_WORD *a1, int a2, _WORD *a3, int a4, uint64_t *a5)
{
  uint64_t v6 = 2371887111;
  if (a5)
  {
    uint64_t v11 = *a5;
    if (*a5)
    {
      uint64_t v12 = *(void **)(*(void *)v11 + 8);
      freeTabsAsLex(v11, a1, a2, a3, a4);
      uint64_t v13 = *a5;
      if (*(void *)(*a5 + 128))
      {
        LhpuRemove(v12, (uint64_t *)(*a5 + 128));
        uint64_t v13 = *a5;
      }
      uint64_t v14 = *(void *)(v13 + 120);
      if (v14)
      {
        heap_Free(v12, v14);
        uint64_t v13 = *a5;
      }
      ssftmap_ObjClose(*(void *)(v13 + 8544));
      ssftmap_ObjClose(*(void *)(*a5 + 8552));
      ssftmap_ObjClose(*(void *)(*a5 + 8560));
      ssftmap_ObjClose(*(void *)(*a5 + 8568));
      ssftmap_ObjClose(*(void *)(*a5 + 8576));
      for (uint64_t i = 1078; i != 2078; ++i)
      {
        uint64_t v16 = *(void *)(*a5 + 8 * i);
        if (v16) {
          heap_Free(v12, v16);
        }
      }
      heap_Free(v12, *a5);
      return 0;
    }
  }
  return v6;
}

uint64_t kbsymtab_KnownGraphId(uint64_t a1, unsigned __int8 *a2)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 8536))
    {
      unint64_t v2 = *a2;
      if (v2 <= 0x63 && !a2[1]) {
        return *(unsigned int *)(a1 + 4 * v2 + 136);
      }
    }
  }
  int v3 = dictSingleLookupInt((uint64_t *)a1, 3, (uint64_t)a2);
  return v3 & ~(v3 >> 31);
}

uint64_t kbsymtab_KnownPhonId(uint64_t *a1, uint64_t a2)
{
  int v2 = dictSingleLookupInt(a1, 0, a2);
  return v2 & ~(v2 >> 31);
}

uint64_t kbsymtab_KnownAtomId(uint64_t *a1, uint64_t a2)
{
  int v2 = dictSingleLookupInt(a1, 2, a2);
  return v2 & ~(v2 >> 31);
}

uint64_t kbsymtab_KnownConsId(uint64_t *a1, uint64_t a2)
{
  int v2 = dictSingleLookupInt(a1, 1, a2);
  return v2 & ~(v2 >> 31);
}

char *kbsymtab_GraphSymString(uint64_t a1, signed int a2, char *__dst, unint64_t a4)
{
  char *__dst = 0;
  if (!a1
    || a4 < 8
    || a2 > 999
    || !*(_DWORD *)(a1 + 8536)
    || (uint64_t result = strcpy(__dst, (const char *)(a1 + 8 * a2 + 536)), !*__dst))
  {
    return (char *)dictLookupSymStr((uint64_t *)a1, 3, a2, __dst, a4);
  }
  return result;
}

uint64_t dictLookupSymStr(uint64_t *a1, int a2, unsigned int a3, char *a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  char v13 = 58;
  uint64_t result = (uint64_t)LH_itoa(a3, v14, 0xAu);
  if (a4 && a5)
  {
    uint64_t v12 = 0;
    *a4 = 0;
    __int16 v11 = -1;
    uint64_t result = dictLookup(a1, a2, (uint64_t)&v13, &v12, &v11);
    if (v11)
    {
      size_t v10 = a5 - 1;
      uint64_t result = (uint64_t)strncpy(a4, *v12, v10);
      a4[v10] = 0;
    }
  }
  return result;
}

uint64_t kbsymtab_PhonSymString(uint64_t *a1, unsigned int a2, char *a3, uint64_t a4)
{
  return dictLookupSymStr(a1, 0, a2, a3, a4);
}

uint64_t kbsymtab_AtomSymString(uint64_t *a1, unsigned int a2, char *a3, uint64_t a4)
{
  return dictLookupSymStr(a1, 2, a2, a3, a4);
}

uint64_t kbsymtab_ConsSymString(uint64_t *a1, unsigned int a2, char *a3, uint64_t a4)
{
  return dictLookupSymStr(a1, 1, a2, a3, a4);
}

uint64_t kbsymtab_PhonStartId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t kbsymtab_PhonTermId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t kbsymtab_SyllSepId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t kbsymtab_PrimAccId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 52);
}

uint64_t kbsymtab_SecAccId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

uint64_t kbsymtab_AccId(uint64_t a1, int a2)
{
  unsigned int v2 = a2 & ~(a2 >> 31);
  if (v2 >= 4) {
    unsigned int v2 = 4;
  }
  return *(unsigned int *)(a1 + 4 * v2 + 28);
}

uint64_t kbsymtab_WordSepId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 60);
}

uint64_t kbsymtab_PhrSepPauseId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 68);
}

uint64_t kbsymtab_PhrSepNoPauseId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 76);
}

uint64_t kbsymtab_WordSep2Id(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t kbsymtab_PhrSepPause2Id(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

uint64_t kbsymtab_PhrSepNoPause2Id(uint64_t a1)
{
  return *(unsigned int *)(a1 + 80);
}

uint64_t kbsymtab_IPABeginId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 84);
}

uint64_t kbsymtab_IPAEndId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 88);
}

uint64_t kbsymtab_IPASyllSepId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 92);
}

uint64_t kbsymtab_IPAWordSepId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 96);
}

uint64_t kbsymtab_IPAPrimAccId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 100);
}

uint64_t kbsymtab_Star2ConsId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 108);
}

uint64_t kbsymtab_WildConsId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 112);
}

uint64_t kbsymtab_Wild2ConsId(uint64_t a1)
{
  return *(unsigned int *)(a1 + 116);
}

BOOL kbsymtab_PropTabAvailable(uint64_t a1)
{
  return *(void *)(a1 + 8616) != 0;
}

uint64_t kbsymtab_IntPropValue(uint64_t *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  buildSymFeatPropKey(a1, a2, 0, a3, v5);
  return dictSingleLookupInt(a1, 4, (uint64_t)v5);
}

char *buildSymFeatPropKey(uint64_t *a1, unsigned int a2, __int16 *a3, unsigned int a4, unsigned char *a5)
{
  *a5 = 58;
  int v8 = a5 + 1;
  LH_itoa(a2, a5 + 1, 0xAu);
  unsigned int v9 = strlen(v8);
  size_t v10 = (char *)&v8[v9];
  uint64_t v11 = 100 - v9;
  if (a3)
  {
    *size_t v10 = 40;
    uint64_t v12 = v10 + 1;
    if (*a3 >= 1)
    {
      uint64_t v13 = 0;
      unint64_t v14 = 99 - v9;
      do
      {
        if (v13 && v14 >= 3)
        {
          *v12++ = 44;
          --v14;
        }
        int v15 = a3[v13 + 1];
        if (v15 < 0)
        {
          dictLookupSymStr(a1, 2, -v15, v12, v14 - 2);
          unsigned int v16 = strlen(v12);
          v12 += (int)v16;
          v14 -= v16;
        }
        ++v13;
      }
      while (v13 < *a3);
    }
    *(_WORD *)uint64_t v12 = 41;
    unsigned int v17 = strlen(v10);
    v10 += (int)v17;
    v11 -= v17;
  }
  *size_t v10 = 58;
  if (a4 > 9) {
    uint64_t v18 = &byte_20D5A22AE;
  }
  else {
    uint64_t v18 = off_264107F48[a4];
  }
  return strncpy(v10 + 1, v18, v11 - 1);
}

uint64_t dictSingleLookupInt(uint64_t *a1, int a2, uint64_t a3)
{
  uint64_t v6 = 0;
  __int16 v5 = -1;
  dictLookup(a1, a2, a3, &v6, &v5);
  if (!v5) {
    return 0xFFFFFFFFLL;
  }
  int v3 = *v6;
  return atoi(v3);
}

BOOL kbsymtab_HasIntPropValue(uint64_t *a1, unsigned int a2, unsigned int a3, int a4)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  buildSymFeatPropKey(a1, a2, 0, a3, v14);
  uint64_t v13 = 0;
  unsigned __int16 v12 = 0;
  dictLookup(a1, 4, (uint64_t)v14, &v13, (__int16 *)&v12);
  unint64_t v6 = v12;
  if (!v12) {
    return 0;
  }
  unint64_t v7 = 0;
  uint64_t v8 = v13;
  do
    int v9 = atoi(*(const char **)(v8 + 8 * v7++));
  while (v9 != a4 && v7 < v6);
  return v9 == a4;
}

uint64_t **kbsymtab_GetFirstAccPatVal(uint64_t **result, int a2, int a3, uint64_t a4, void *a5)
{
  if (result)
  {
    if (a4)
    {
      *(void *)a4 = result;
      *(_DWORD *)(a4 + 8) = a2;
      *(_DWORD *)(a4 + 24) = a3;
      *(_DWORD *)(a4 + 28) = -1;
      return kbsymtab_GetNextAccPatVal((uint64_t **)a4, a5);
    }
  }
  return result;
}

uint64_t **kbsymtab_GetNextAccPatVal(uint64_t **result, void *a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (result && a2)
  {
    int v3 = result;
    uint64_t v9 = 0;
    *a2 = 0;
    buildSymFeatPropKey(*result, *((_DWORD *)v3 + 2), 0, *((_DWORD *)v3 + 6), v10);
    uint64_t v4 = *v3;
    unsigned __int16 v7 = 0;
    uint64_t result = (uint64_t **)dictLookup(v4, 4, (uint64_t)v10, &v9, (__int16 *)&v7);
    uint64_t v5 = *((int *)v3 + 7) + 1;
    if ((int)v5 < v7)
    {
      uint64_t v8 = (char *)(*v3)[15];
      unint64_t v6 = v8;
      *((_DWORD *)v3 + 7) = v5;
      strncpy(v6, *(const char **)(v9 + 8 * v5), 0x3E8uLL);
      return (uint64_t **)stringToPatternTree(*v3, &v8, (uint64_t)a2);
    }
  }
  return result;
}

uint64_t stringToPatternTree(uint64_t *a1, char **a2, uint64_t a3)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  uint64_t result = heap_Calloc(*(void **)(*a1 + 8), 1, 24);
  *(void *)a3 = result;
  if (!result) {
    return result;
  }
  *(void *)uint64_t result = 0;
  *(void *)(*(void *)a3 + 8) = 0;
  *(_DWORD *)(*(void *)a3 + 16) = 0;
  unsigned __int16 v7 = *a2;
  int v8 = **a2;
  if (v8 == 37)
  {
    *a2 = v7 + 1;
    if (v7[1] == 37)
    {
      *a2 = v7 + 2;
      __int16 v9 = 9509;
      goto LABEL_8;
    }
    __int16 v15 = 37;
LABEL_15:
    __int16 v30 = v15;
    goto LABEL_33;
  }
  if (v8 == 42)
  {
    *a2 = v7 + 1;
    if (v7[1] == 42)
    {
      *a2 = v7 + 2;
      __int16 v9 = 10794;
LABEL_8:
      __int16 v30 = v9;
      char v31 = 0;
LABEL_33:
      uint64_t result = dictSingleLookupInt(a1, 1, (uint64_t)&v30);
      *(_WORD *)(*(void *)a3 + 16) = result & ~(unsigned __int16)((int)result >> 31);
      goto LABEL_34;
    }
    __int16 v15 = 42;
    goto LABEL_15;
  }
  char v10 = **a2;
  unsigned int v11 = (char)v8 - 48;
  if (v11 > 9)
  {
    uint64_t v16 = MEMORY[0x263EF8318];
    if ((char)v8 < 0) {
      int v17 = __maskrune((char)v8, 0x100uLL);
    }
    else {
      int v17 = *(_DWORD *)(MEMORY[0x263EF8318] + 4 * (char)v8 + 60) & 0x100;
    }
    uint64_t v18 = &v30;
    if (v17)
    {
      LOBYTE(v30) = v10;
      uint64_t v19 = *a2 + 1;
      *a2 = v19;
      for (unint64_t i = 1; ; ++i)
      {
        unsigned int v21 = *v19;
        int v22 = (v21 & 0x80000000) != 0 ? __maskrune(*v19, 0x500uLL) : *(_DWORD *)(v16 + 4 * v21 + 60) & 0x500;
        BOOL v23 = v22 || v21 == 95;
        if (!v23 || i > 0x62) {
          break;
        }
        uint64_t v19 = *a2 + 1;
        *((unsigned char *)&v30 + i) = **a2;
        *a2 = v19;
      }
      uint64_t v18 = (__int16 *)((char *)&v30 + i);
    }
    *(unsigned char *)uint64_t v18 = 0;
    goto LABEL_33;
  }
  __int16 v12 = 0;
  uint64_t v13 = v7 + 1;
  do
  {
    __int16 v12 = v11 + 10 * v12;
    *a2 = v13;
    int v14 = *v13++;
    LOWORD(v11) = v14 - 48;
  }
  while ((v14 - 48) < 0xA);
  *(_WORD *)(*(void *)a3 + 18) = v12;
LABEL_34:
  int v24 = *a2;
  if (**a2 == 40)
  {
    int v29 = 0;
    *a2 = v24 + 1;
    uint64_t result = stringToPatternTree(a1, a2, &v29);
    int v25 = v29;
    *(void *)(*(void *)a3 + 8) = v29;
    while (1)
    {
      int v26 = *a2;
      int v27 = **a2;
      if (v27 != 44) {
        break;
      }
      *a2 = v26 + 1;
      uint64_t result = stringToPatternTree(a1, a2, &v29);
      int v28 = v29;
      void *v25 = v29;
      int v25 = v28;
    }
    if (v27 == 41) {
      *a2 = v26 + 1;
    }
  }
  return result;
}

void *kbsymtab_DisposeAccPat(void *result, void **a2)
{
  if (result)
  {
    if (a2)
    {
      int v3 = *a2;
      if (*a2)
      {
        uint64_t v4 = result;
        do
        {
          uint64_t v5 = (void *)*v3;
          kbsymtab_DisposeAccPat(v4, v3 + 1);
          uint64_t result = heap_Free(*(void **)(*v4 + 8), (uint64_t)v3);
          int v3 = v5;
        }
        while (v5);
        *a2 = 0;
      }
    }
  }
  return result;
}

void kbsymtab_GetFeatMatchedFirstIntPropVal(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5, int *a6)
{
  if (a6) {
    *a6 = -1;
  }
  if (a5)
  {
    *(void *)a5 = a1;
    *(_DWORD *)(a5 + 8) = a2;
    *(void *)(a5 + 16) = a3;
    *(_DWORD *)(a5 + 24) = a4;
    *(_DWORD *)(a5 + 28) = -1;
    kbsymtab_GetFeatMatchedNextIntPropVal(a1, a5, a6);
  }
}

void kbsymtab_GetFeatMatchedNextIntPropVal(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (a3) {
    *a3 = -1;
  }
  if (a2)
  {
    uint64_t v10 = 0;
    buildSymFeatPropKey(*(uint64_t **)a2, *(_DWORD *)(a2 + 8), *(__int16 **)(a2 + 16), *(_DWORD *)(a2 + 24), v11);
    uint64_t v5 = *(uint64_t **)a2;
    unsigned __int16 v9 = 0;
    uint64_t v6 = dictLookup(v5, 4, (uint64_t)v11, &v10, (__int16 *)&v9);
    uint64_t v7 = *(int *)(a2 + 28) + 1;
    if ((int)v7 >= v9)
    {
      if (*(void *)(a2 + 16))
      {
        int v8 = *(_DWORD *)(a2 + 8);
        if (a3) {
          *a3 = -1;
        }
        *(_DWORD *)(a2 + 8) = v8;
        *(void *)(a2 + 16) = 0;
        *(_DWORD *)(a2 + 28) = -1;
        kbsymtab_GetFeatMatchedNextIntPropVal(v6, a2, a3);
      }
    }
    else
    {
      *(_DWORD *)(a2 + 28) = v7;
      if (a3) {
        *a3 = atoi(*(const char **)(v10 + 8 * v7));
      }
    }
  }
}

uint64_t *kbsymtab_GetLhPlusPhone(uint64_t *result, uint64_t a2, int a3, int *a4, char *a5, int a6, unsigned char *a7)
{
  if (a7)
  {
    *a7 = 0;
    if (a5)
    {
      unsigned __int16 v9 = result;
      if (!result) {
        goto LABEL_20;
      }
      if (!a2) {
        goto LABEL_20;
      }
      if (!a4) {
        goto LABEL_20;
      }
      uint64_t v11 = *a4;
      if ((int)v11 >= a3) {
        goto LABEL_20;
      }
      __int16 v17 = 0;
      uint64_t v13 = (unsigned __int8 *)(a2 + v11);
      uint64_t result = (uint64_t *)getComplexPhoneLen(result, (unsigned char *)(a2 + v11));
      unsigned __int8 v14 = result;
      if (!result)
      {
        uint64_t result = (uint64_t *)LhplGetSymbol(v13, v9[16], (unsigned char *)&v17 + 1, &v17);
        if (result)
        {
          unsigned __int8 v14 = a6;
        }
        else
        {
          unsigned __int8 v15 = v17;
          unsigned __int8 v14 = v17 - HIBYTE(v17) + 1;
          if (v17 > HIBYTE(v17))
          {
            while (v13[v15] != 123)
            {
              LOBYTE(v17) = --v15;
              if (HIBYTE(v17) >= v15)
              {
                unsigned __int8 v15 = HIBYTE(v17);
                break;
              }
            }
          }
          uint64_t v16 = &v13[v15];
          if (*v16 == 123)
          {
            uint64_t result = (uint64_t *)getComplexPhoneLen(v9, v16);
            if (result) {
              unsigned __int8 v14 = v17 - HIBYTE(v17);
            }
          }
        }
      }
      if (v14 < a6)
      {
        uint64_t result = (uint64_t *)strncpy(a5, (const char *)v13, v14);
        a5[v14] = 0;
        *a4 += v14;
        *a7 = 1;
        return result;
      }
      if (!*a7) {
LABEL_20:
      }
        *a5 = 0;
    }
  }
  return result;
}

uint64_t getComplexPhoneLen(uint64_t *a1, unsigned char *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (*a2 != 123) {
    return 0;
  }
  v7[0] = 123;
  for (uint64_t i = 1; i != 13; ++i)
  {
    int v3 = a2[i];
    if (!a2[i]) {
      break;
    }
    if (v3 == 123) {
      break;
    }
    if (v3 == 125) {
      break;
    }
    v7[i] = v3;
  }
  char v4 = i;
  if (a2[i] == 125)
  {
    *(_WORD *)&v7[i] = 125;
    if ((int)dictSingleLookupInt(a1, 0, (uint64_t)v7) >= 1) {
      return (v4 + 1);
    }
    else {
      return 0;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t dictLookup(uint64_t *a1, int a2, uint64_t a3, void *a4, __int16 *a5)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  switch(a2)
  {
    case 0:
      unsigned __int16 v9 = a1 + 1073;
      uint64_t v10 = 1068;
      goto LABEL_8;
    case 1:
      unsigned __int16 v9 = a1 + 1074;
      uint64_t v10 = 1069;
      goto LABEL_8;
    case 2:
      unsigned __int16 v9 = a1 + 1075;
      uint64_t v10 = 1070;
      goto LABEL_8;
    case 3:
      unsigned __int16 v9 = a1 + 1076;
      uint64_t v10 = 1071;
      goto LABEL_8;
    case 4:
      unsigned __int16 v9 = a1 + 1077;
      uint64_t v10 = 1072;
LABEL_8:
      uint64_t v11 = *v9;
      uint64_t v12 = a1[v10];
      break;
    default:
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      break;
  }
  memset(v29, 0, sizeof(v29));
  *(void *)__src = 0;
  memset(v28, 0, sizeof(v28));
  BOOL v26 = 0;
  int v13 = ssftmap_FindReadOnly(v12, a3, __src) & 0x1FFF;
  if (v13 != 7 && v13 != 20)
  {
    BOOL v23 = *(const char **)__src;
    uint64_t result = strcmp(*(const char **)__src, "~");
    if (result)
    {
      int v24 = (char *)a1[1078];
      if (!v24)
      {
        int v24 = (char *)heap_Alloc(*(void *)(*a1 + 8), 101);
        if (!v24) {
          goto LABEL_11;
        }
        BOOL v23 = *(const char **)__src;
      }
      uint64_t result = (uint64_t)strncpy(v24, v23, 0x64uLL);
      *(unsigned char *)(result + 100) = 0;
      a1[1078] = result;
      __int16 v25 = 1;
      *a4 = a1 + 1078;
    }
    else
    {
      __int16 v25 = 0;
    }
    *a5 = v25;
    return result;
  }
LABEL_11:
  int v14 = (unsigned __int16)*a5;
  *a5 = 0;
  kblexXX_StartLookup(v11, (uint64_t)v29);
  __int16 v15 = 0;
  char v27 = 1;
  while (*(unsigned char *)(a3 + v15))
  {
    uint64_t result = kblexXX_LookupChar(*(unsigned char *)(a3 + v15++), (int *)v29, &v27);
    if (!v27) {
      goto LABEL_28;
    }
  }
  kblexXX_GetFirstEntry(v29, &v26, (uint64_t)v28);
  while (v26)
  {
    if (*a5 && v14 != 0) {
      break;
    }
    kblexXX_GetEntryPhon(0, v28, __src, 100);
    unint64_t v18 = (unsigned __int16)*a5;
    if (v18 <= 0x3E7)
    {
      uint64_t v19 = (char *)a1[v18 + 1078];
      if (v19 || (uint64_t v19 = (char *)heap_Alloc(*(void *)(*a1 + 8), 101)) != 0)
      {
        uint64_t v20 = strncpy(v19, __src, 0x64uLL);
        v20[100] = 0;
        uint64_t v21 = (unsigned __int16)*a5;
        a1[v21 + 1078] = (uint64_t)v20;
        *a5 = v21 + 1;
      }
    }
    kblexXX_GetNextEntry(&v26, (int *)v28);
  }
  uint64_t result = kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)v28);
LABEL_28:
  *a4 = a1 + 1078;
  if (*a5)
  {
    if (*a5 != 1) {
      return result;
    }
    int v22 = (const char *)a1[1078];
  }
  else
  {
    int v22 = "~";
  }
  return ssftmap_Insert(v12, a3, (uint64_t)v22);
}

uint64_t mosynt_PadWithChar(uint64_t a1, int a2, int __c, unsigned int a4)
{
  unsigned int v5 = 0;
  do
    LODWORD(v6) = v5;
  while (*(unsigned __int8 *)(a1 + v5++));
  uint64_t v6 = v6;
  if (a4 >= a2 - 1) {
    uint64_t v8 = (a2 - 1);
  }
  else {
    uint64_t v8 = a4;
  }
  if (v5 - 1 < v8)
  {
    memset((void *)(a1 + v6), __c, v8 - v5 + 1);
    uint64_t v6 = v8;
  }
  *(unsigned char *)(a1 + v6) = 0;
  return 0;
}

uint64_t mosynt_RemoveAllSubstrOcc(char *a1, unsigned char *a2)
{
  char v2 = *a1;
  if (*a1)
  {
    int v3 = 0;
    int v4 = 0;
    do
    {
      int v5 = *a2;
      if (*a2)
      {
        unsigned int v6 = 0;
        while (a1[v4 + v6] == v5)
        {
          int v5 = a2[++v6];
          if (!a2[v6]) {
            goto LABEL_10;
          }
        }
        a1[v3++] = v2;
        unsigned int v6 = 1;
      }
      else
      {
        unsigned int v6 = 0;
      }
LABEL_10:
      v4 += v6;
      char v2 = a1[v4];
    }
    while (v2);
  }
  else
  {
    int v3 = 0;
  }
  a1[v3] = 0;
  return 0;
}

uint64_t mosynt_SubstAllSubstrOcc(char *a1, unsigned char *a2, unsigned char *a3, unsigned char *a4, int a5)
{
  if (*a2)
  {
    char v5 = *a1;
    if (*a1)
    {
      unsigned int v6 = 0;
      int v7 = 0;
      unsigned int v8 = a5 - 1;
      do
      {
        int v9 = *a2;
        if (*a2)
        {
          unsigned int v10 = 0;
          while (a1[v7 + v10] == v9)
          {
            int v9 = a2[++v10];
            if (!a2[v10]) {
              goto LABEL_10;
            }
          }
          if (v6 < v8) {
            a4[v6++] = v5;
          }
          unsigned int v10 = 1;
        }
        else
        {
          unsigned int v10 = 0;
LABEL_10:
          LOBYTE(v11) = *a3;
          if (*a3)
          {
            unsigned int v12 = 1;
            do
            {
              if (v6 < v8) {
                a4[v6++] = v11;
              }
              int v11 = a3[v12++];
            }
            while (v11);
          }
        }
        v7 += v10;
        char v5 = a1[v7];
      }
      while (v5);
    }
    else
    {
      unsigned int v6 = 0;
    }
    a4 += v6;
  }
  *a4 = 0;
  return 0;
}

uint64_t mosynt_GetTermSubstr(uint64_t a1, _DWORD *a2, unsigned __int8 a3, _DWORD *a4, unsigned char *a5, int a6)
{
  if (*(unsigned char *)(a1 + *a2))
  {
    *a4 = 1;
    uint64_t v6 = *a2;
    int v7 = *(unsigned __int8 *)(a1 + v6);
    for (i = 0; v7 != a3 && v7 != 0; int v7 = *(unsigned __int8 *)(a1 + v6))
    {
      if (i < a6 - 1)
      {
        a5[i++] = v7;
        LODWORD(v6) = *a2;
      }
      LODWORD(v6) = v6 + 1;
      *a2 = v6;
    }
    a5[i] = 0;
    uint64_t v11 = *a2;
    if (*(unsigned char *)(a1 + v11)) {
      *a2 = v11 + 1;
    }
  }
  else
  {
    *a4 = 0;
    *a5 = 0;
  }
  return 0;
}

uint64_t mosynt_RemoveInitSubstr(const char *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (!strncmp(a1, __s, v4))
  {
    int v5 = strlen(__s);
    char v6 = a1[(unsigned __int16)v5];
    if (v6)
    {
      LOWORD(v7) = 0;
      do
      {
        a1[(unsigned __int16)v7] = v6;
        ++v5;
        LOWORD(v7) = v7 + 1;
        char v6 = a1[(unsigned __int16)v5];
      }
      while (v6);
      uint64_t v7 = (unsigned __int16)v7;
    }
    else
    {
      uint64_t v7 = 0;
    }
    a1[v7] = 0;
  }
  return 0;
}

uint64_t mosynt_App(uint64_t a1, int a2, unsigned int *a3, unsigned char *a4, _DWORD *a5)
{
  *a5 = 1;
  LOBYTE(v5) = *a4;
  unsigned int v6 = *a3;
  if (*a4)
  {
    unsigned int v7 = 1;
    while (v6 < a2 - 1)
    {
      *(unsigned char *)(a1 + v6) = v5;
      unsigned int v6 = *a3 + 1;
      *a3 = v6;
      int v5 = a4[v7++];
      if (!v5) {
        goto LABEL_7;
      }
    }
    *a5 = 0;
    unsigned int v6 = *a3;
  }
LABEL_7:
  *(unsigned char *)(a1 + v6) = 0;
  return 0;
}

uint64_t mosynt_NormalizeSpaceFields(unsigned char *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v14 = 0;
  unsigned int v5 = *a1;
  if (*a1)
  {
    unsigned int v13 = 0;
    unsigned int v7 = a3 - 1;
    while (1)
    {
      uint64_t result = mosynt_GetSpace(0, (uint64_t)a1, (unsigned int *)&v14 + 1, &v13);
      if ((result & 0x80000000) != 0) {
        break;
      }
      int v9 = (unsigned __int16)v13;
      LODWORD(v10) = v14;
      if ((_WORD)v13)
      {
        do
        {
          uint64_t v11 = v10;
          if (v10 < v7)
          {
            uint64_t v10 = (v10 + 1);
            *(unsigned char *)(a2 + v11) = 32;
            uint64_t v11 = v10;
          }
          *(unsigned char *)(a2 + v11) = 0;
          --v9;
        }
        while (v9);
      }
      LODWORD(v14) = v10;
      unsigned int v12 = HIDWORD(v14);
      uint64_t result = mosynt_GetField((uint64_t)a1, (unsigned int *)&v14 + 1, &v13);
      if ((result & 0x80000000) != 0) {
        break;
      }
      uint64_t result = mosynt_TransferStretchedStringSection((uint64_t)a1, &v12, v13, a2, a3, (unsigned int *)&v14, v13, 32);
      if ((result & 0x80000000) != 0) {
        break;
      }
      if (!a1[HIDWORD(v14)])
      {
        unsigned int v5 = v14;
        goto LABEL_13;
      }
    }
  }
  else
  {
    uint64_t result = 0;
LABEL_13:
    if (v5 >= a3) {
      unsigned int v5 = a3 - 1;
    }
    *(unsigned char *)(a2 + v5) = 0;
  }
  return result;
}

uint64_t mosynt_GetSpace(int a1, uint64_t a2, unsigned int *a3, _DWORD *a4)
{
  *a4 = 0;
  uint64_t result = utf8_getUTF8Char(a2, *a3, __s);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  while (1)
  {
LABEL_2:
    unsigned int v9 = __s[0] - 32;
    BOOL v10 = v9 > 0x3F;
    unint64_t v11 = (1 << v9) & 0x8000000000002001;
    if (!v10 && v11 != 0) {
      goto LABEL_6;
    }
    if (a1 && (__s[0] == 47 || __s[0] == 35))
    {
      unsigned int v14 = *a3;
      if (*a3 && *(unsigned char *)(a2 + v14 - 1) != 32 || (*(unsigned __int8 *)(a2 + v14 + 1) | 0x20) != 0x20) {
        return result;
      }
LABEL_6:
      ++*a4;
      unsigned int v13 = *a3 + strlen(__s);
      *a3 = v13;
      uint64_t result = utf8_getUTF8Char(a2, v13, __s);
      goto LABEL_7;
    }
    if (*(_DWORD *)__s == 8689634) {
      break;
    }
    if (*(_DWORD *)__s == 12228322 || *(_DWORD *)__s == 9799394) {
      goto LABEL_6;
    }
    if (*(_DWORD *)__s != 11704034) {
      return result;
    }
    while (1)
    {
      int v15 = *(_DWORD *)__s;
      ++*a4;
      unsigned int v16 = *a3 + strlen(__s);
      *a3 = v16;
      uint64_t result = utf8_getUTF8Char(a2, v16, __s);
      if (v15 == 12359394) {
        break;
      }
      if ((result & 0x80000000) != 0) {
        return result;
      }
      if (!__s[0]) {
        goto LABEL_2;
      }
    }
LABEL_7:
    if ((result & 0x80000000) != 0) {
      return result;
    }
  }
  unsigned int v17 = 0;
  while (1)
  {
    ++*a4;
    unsigned int v18 = *a3 + strlen(__s);
    *a3 = v18;
    uint64_t result = utf8_getUTF8Char(a2, v18, __s);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    BOOL v10 = v17++ > 1;
    if (v10) {
      goto LABEL_2;
    }
  }
}

uint64_t mosynt_GetField(uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  *a3 = 0;
  for (uint64_t result = utf8_getUTF8Char(a1, *a2, __s); (result & 0x80000000) == 0; uint64_t result = utf8_getUTF8Char(a1, v7, __s))
  {
    if (!__s[0]) {
      break;
    }
    if (__s[0] == 32) {
      break;
    }
    if (__s[0] == 95) {
      break;
    }
    if (*(_DWORD *)__s == 8689634) {
      break;
    }
    if (*(_DWORD *)__s == 12228322) {
      break;
    }
    if (*(_DWORD *)__s == 9799394) {
      break;
    }
    if (*(_DWORD *)__s == 11704034) {
      break;
    }
    ++*a3;
    unsigned int v7 = *a2 + strlen(__s);
    *a2 = v7;
  }
  return result;
}

uint64_t mosynt_TransferStretchedStringSection(uint64_t a1, unsigned int *a2, unsigned int a3, uint64_t a4, int a5, unsigned int *a6, unsigned int a7, int a8)
{
  __s[0] = 0;
  if (a3)
  {
    int v25 = a8;
    int v26 = a5;
    unsigned int v13 = 0;
    int v14 = 0;
    unsigned int v15 = a5 - 1;
    while (1)
    {
      uint64_t UTF8Char = utf8_getUTF8Char(a1, *a2, __s);
      if ((UTF8Char & 0x80000000) != 0) {
        break;
      }
      *a2 += strlen(__s);
      if (v13 < a7)
      {
        LOBYTE(v17) = __s[0];
        unsigned int v18 = *a6;
        if (__s[0])
        {
          int v19 = 1;
          do
          {
            if (v18 >= v15) {
              break;
            }
            *(unsigned char *)(a4 + v18) = v17;
            unsigned int v18 = *a6 + 1;
            *a6 = v18;
            int v17 = __s[v19++];
          }
          while (v17);
        }
        uint64_t UTF8Char = 0;
        *(unsigned char *)(a4 + v18) = 0;
      }
      unsigned int v13 = (unsigned __int16)++v14;
      if ((unsigned __int16)v14 >= a3)
      {
        LOBYTE(a8) = v25;
        a5 = v26;
        if (v25) {
          goto LABEL_14;
        }
        goto LABEL_16;
      }
    }
  }
  else
  {
    int v14 = 0;
    uint64_t UTF8Char = 0;
    if (a8)
    {
LABEL_14:
      __s[0] = a8;
      __s[1] = 0;
    }
    else
    {
      strcpy(__s, " ");
    }
LABEL_16:
    if (a7 > (unsigned __int16)v14)
    {
      int v20 = __s[0];
      do
      {
        unsigned int v21 = *a6;
        if (v20)
        {
          int v22 = 1;
          LOBYTE(v23) = v20;
          do
          {
            if (v21 >= a5 - 1) {
              break;
            }
            *(unsigned char *)(a4 + v21) = v23;
            unsigned int v21 = *a6 + 1;
            *a6 = v21;
            int v23 = __s[v22++];
          }
          while (v23);
        }
        *(unsigned char *)(a4 + v21) = 0;
        ++v14;
      }
      while (a7 > (unsigned __int16)v14);
      uint64_t UTF8Char = 0;
    }
    *(unsigned char *)(a4 + *a6) = 0;
  }
  return UTF8Char;
}

uint64_t mosynt_ReplaceNonSpaceFields(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, int a6)
{
  uint64_t result = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  unsigned int v23 = 0;
  while (*(unsigned char *)(a1 + HIDWORD(v25)) || *(unsigned char *)(a2 + v25))
  {
    unsigned int v22 = HIDWORD(v25);
    uint64_t result = mosynt_GetSpace(1, a1, (unsigned int *)&v25 + 1, &v24);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = mosynt_GetSpace(1, a2, (unsigned int *)&v25, &v23);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = mosynt_TransferStretchedStringSection(a1, &v22, v24, a3, a4, (unsigned int *)&v24 + 1, v24, 32);
        if ((result & 0x80000000) == 0)
        {
          unsigned int v22 = HIDWORD(v25);
          uint64_t result = mosynt_GetField(a1, (unsigned int *)&v25 + 1, &v24);
          if ((result & 0x80000000) == 0)
          {
            uint64_t v13 = v25;
            int v21 = v25;
            uint64_t result = mosynt_GetField(a2, (unsigned int *)&v25, &v23);
            if ((result & 0x80000000) == 0)
            {
              if (a6 && *(unsigned char *)(a2 + v13) == 123)
              {
                unsigned int v14 = v24;
                unsigned int v15 = &v22;
                uint64_t v16 = a1;
                uint64_t v17 = a3;
                int v18 = a4;
                unsigned int v19 = v24;
              }
              else
              {
                unsigned int v14 = v23;
                unsigned int v19 = v23 <= v24 ? v24 : v23;
                unsigned int v15 = (unsigned int *)&v21;
                uint64_t v16 = a2;
                uint64_t v17 = a3;
                int v18 = a4;
              }
              uint64_t result = mosynt_TransferStretchedStringSection(v16, v15, v14, v17, v18, (unsigned int *)&v24 + 1, v19, a5);
              if ((result & 0x80000000) == 0) {
                continue;
              }
            }
          }
        }
      }
    }
    return result;
  }
  unsigned int v20 = HIDWORD(v24);
  if (HIDWORD(v24) >= a4) {
    unsigned int v20 = a4 - 1;
  }
  *(unsigned char *)(a3 + v20) = 0;
  return result;
}

uint64_t mosynt_AlignFieldsWithRef(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5)
{
  uint64_t result = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  unsigned int v13 = 0;
  while (*(unsigned char *)(a1 + HIDWORD(v15)) || *(unsigned char *)(a2 + v14))
  {
    uint64_t result = mosynt_GetSpace(1, a1, (unsigned int *)&v15 + 1, &v15);
    if ((result & 0x80000000) == 0)
    {
      unsigned int v12 = v14;
      uint64_t result = mosynt_GetSpace(1, a2, (unsigned int *)&v14, (_DWORD *)&v14 + 1);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = mosynt_TransferStretchedStringSection(a2, &v12, HIDWORD(v14), a3, a4, &v13, v15, 32);
        if ((result & 0x80000000) == 0)
        {
          uint64_t result = mosynt_GetField(a1, (unsigned int *)&v15 + 1, &v15);
          if ((result & 0x80000000) == 0)
          {
            unsigned int v12 = v14;
            uint64_t result = mosynt_GetField(a2, (unsigned int *)&v14, (_DWORD *)&v14 + 1);
            if ((result & 0x80000000) == 0)
            {
              uint64_t result = mosynt_TransferStretchedStringSection(a2, &v12, HIDWORD(v14), a3, a4, &v13, v15, a5);
              if ((result & 0x80000000) == 0) {
                continue;
              }
            }
          }
        }
      }
    }
    return result;
  }
  unsigned int v11 = v13;
  if (v13 >= a4) {
    unsigned int v11 = a4 - 1;
  }
  *(unsigned char *)(a3 + v11) = 0;
  return result;
}

uint64_t mosynt_TraceString(uint64_t a1, char *__s, unsigned int a3)
{
  if (a1)
  {
    unsigned int v5 = *(_DWORD *)(a1 + 1024);
    if (v5)
    {
      unsigned int v5 = *(unsigned __int16 *)(a1 + 1028);
    }
    else
    {
      *(_WORD *)(a1 + 1028) = 0;
      *(_DWORD *)(a1 + 1024) = 1;
      *(_DWORD *)(a1 + 1032) = 20;
    }
  }
  else
  {
    unsigned int v5 = 0;
  }
  if (v5 < a3) {
    return 0;
  }
  int v7 = strlen(__s);
  return mosyntbase_WString(a1, (unsigned __int8 *)__s, v7);
}

uint64_t mosynt_TraceInt(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if (a1)
  {
    unsigned int v3 = *(_DWORD *)(a1 + 1024);
    if (v3)
    {
      unsigned int v3 = *(unsigned __int16 *)(a1 + 1028);
    }
    else
    {
      *(_WORD *)(a1 + 1028) = 0;
      *(_DWORD *)(a1 + 1024) = 1;
      *(_DWORD *)(a1 + 1032) = 20;
    }
  }
  else
  {
    unsigned int v3 = 0;
  }
  if (v3 >= a3) {
    return mosyntbase_WInt(a1, a2, 0);
  }
  else {
    return 0;
  }
}

uint64_t mosynt_NumPOSListToPOSList(uint64_t a1, uint64_t *a2, unsigned char *a3, uint64_t a4, int a5)
{
  int v16 = 0;
  if (*a3)
  {
    unsigned int v10 = 0;
    unsigned int v11 = 0;
    while (1)
    {
      while (1)
      {
        int v12 = a3[v10];
        if (!a3[v10] || v12 == 92) {
          break;
        }
        unsigned int v11 = (char)v12 + 10 * v11 - 48;
        ++v10;
      }
      uint64_t result = mosyntkbsymtab_AppDecomprConsToString(a1, a2, v11, a4, a5, &v16);
      if ((result & 0x80000000) != 0) {
        break;
      }
      uint64_t v14 = v10;
      int v15 = v16;
      if (v16 < a5)
      {
        *(unsigned char *)(a4 + v16) = a3[v10];
        int v16 = v15 + 1;
        if (a3[v10]) {
          uint64_t v14 = v10 + 1;
        }
        else {
          uint64_t v14 = v10;
        }
        unsigned int v10 = v14;
      }
      unsigned int v11 = 0;
      if (!a3[v14]) {
        goto LABEL_15;
      }
    }
  }
  else
  {
    uint64_t result = 0;
LABEL_15:
    *(unsigned char *)(a4 + (a5 - 1)) = 0;
  }
  return result;
}

uint64_t mosynt_ResetMosyntWS(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 5000) = 0;
    *(unsigned char *)(a2 + 15000) = 0;
    *(unsigned char *)(a2 + 20000) = 0;
    *(_OWORD *)(a2 + 25000) = 0u;
  }
  return 0;
}

uint64_t mosynt_StartWordAnalysis(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a8) {
    return 0;
  }
  *(void *)a8 = a2;
  *(_WORD *)(a8 + 8) = 1;
  *(void *)(a8 + 16) = a3;
  *(_WORD *)(a8 + 96) = 1;
  *(void *)(a8 + 104) = a4;
  *(void *)(a8 + 184) = a5;
  *(void *)(a8 + 192) = a6;
  uint64_t result = fst_getFSTSeq(a7, 0, (void *)(a8 + 200), (_DWORD *)(a8 + 208));
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = fst_getFSTSeq(a7, 1, (void *)(a8 + 216), (_DWORD *)(a8 + 224));
    if ((result & 0x80000000) == 0)
    {
      *(unsigned char *)(a8 + 1248) = 0;
      *(void *)(a8 + 232) = 0;
      *(void *)(a8 + 240) = 0;
      *(unsigned char *)(a8 + 248) = 0;
    }
  }
  return result;
}

uint64_t mosynt_WordAnalysis()
{
  uint64_t v0 = MEMORY[0x270FA5388]();
  size_t v4 = v3;
  unsigned int v5 = v2;
  char v7 = v6;
  char v9 = v8;
  char v11 = v10;
  uint64_t v12 = (uint64_t)v1;
  uint64_t v14 = v13;
  uint64_t v15 = v0;
  uint64_t v55 = *MEMORY[0x263EF8340];
  if (!v0) {
    goto LABEL_7;
  }
  if (!*(_DWORD *)(v0 + 1024))
  {
    *(_WORD *)(v0 + 1028) = 0;
    *(_DWORD *)(v0 + 1024) = 1;
    *(_DWORD *)(v0 + 1032) = 20;
LABEL_7:
    int v16 = 0;
    *char v2 = 0;
    goto LABEL_8;
  }
  int v16 = *(unsigned __int16 *)(v0 + 1028);
  *char v2 = 0;
  if (!v16)
  {
LABEL_8:
    char v18 = 1;
    goto LABEL_9;
  }
  uint64_t result = mosyntbase_WriteMessage(v0, "\n\n[WANA] analyzing word '%s'\n", 0, v1, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  char v18 = 0;
LABEL_9:
  BOOL v47 = 0;
  uint64_t result = utf8_getUTF8Char(v12, 0, __s);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  int v40 = v4;
  if (__s[0])
  {
    int v35 = v16;
    char v38 = v11;
    int v19 = 0;
    unsigned int v20 = 0;
    while (1)
    {
      int v21 = strlen(__s);
      uint64_t result = utf8_ToLower(__s, 0, (uint64_t)v41);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      unsigned int v22 = strlen(v41);
      if (v22 && v19 + v22 + 1 <= 0x1388)
      {
        uint64_t v23 = v22;
        uint64_t v24 = v41;
        int v25 = v19;
        do
        {
          char v26 = *v24++;
          int v19 = v25 + 1;
          v54[v25++] = v26;
          --v23;
        }
        while (v23);
      }
      v20 += v21;
      utf8_getUTF8Char(v12, v20, __s);
      if (!__s[0])
      {
        v54[v19] = 0;
        char v11 = v38;
        int v16 = v35;
        if ((v18 & 1) == 0) {
          goto LABEL_21;
        }
        goto LABEL_22;
      }
    }
  }
  v54[0] = 0;
  if ((v18 & 1) == 0)
  {
LABEL_21:
    uint64_t result = mosyntbase_WriteMessage(v15, "[WANA] after lowercase conversion '%s'\n", 0, (unsigned __int8 *)v54, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
    if ((result & 0x80000000) != 0) {
      return result;
    }
  }
LABEL_22:
  uint64_t v53 = 0;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  *(_OWORD *)long long __s = 0u;
  uint64_t result = hlp_CastFSTSeq(*(void *)(v14 + 200), *(_DWORD *)(v14 + 208), (int *)__s);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v39 = *(void *)v14;
    int v27 = *(unsigned __int16 *)(v14 + 8);
    int v37 = *(unsigned __int16 *)(v14 + 96);
    uint64_t v28 = *(void *)(v14 + 192);
    uint64_t v36 = *(void *)(v14 + 184);
    int v29 = strlen(v54);
    long long v43 = v50;
    long long v44 = v51;
    long long v45 = v52;
    uint64_t v46 = v53;
    *(_OWORD *)int v41 = *(_OWORD *)__s;
    long long v42 = v49;
    uint64_t result = mosyntwordana_ParseWord(v15, v16, v39, v27, (char *)(v14 + 16), v37, (char *)(v14 + 104), v36, (uint64_t)v41, v28, 0, (uint64_t)v54, v29, v11, v9, v7, &v47, (void *)(v14 + 232));
    BOOL v30 = v47;
    *unsigned int v5 = v47;
    if ((result & 0x80000000) == 0)
    {
      int *v40 = 0;
      uint64_t v31 = *(void *)(v14 + 232);
      if (v30)
      {
        int *v40 = -1;
        uint64_t v32 = *(uint64_t **)(v31 + 32);
        if (!v32) {
          goto LABEL_32;
        }
        int v33 = -1;
        do
        {
          int v34 = *((_DWORD *)v32 + 3);
          if (v33 < 0 || v34 < v33)
          {
            int *v40 = v34;
            int v33 = v34;
          }
          uint64_t v32 = (uint64_t *)*v32;
        }
        while (v32);
      }
      if (!v31)
      {
        *(void *)(v14 + 240) = 0;
        return result;
      }
LABEL_32:
      *(void *)(v14 + 240) = *(void *)(v31 + 32);
    }
  }
  return result;
}

uint64_t hlp_CastFSTSeq(uint64_t a1, int a2, int *a3)
{
  if (a2 < 1)
  {
    uint64_t result = 0;
LABEL_7:
    *a3 = a2;
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v8 = 0;
    while (1)
    {
      uint64_t result = fst_getFST(a1, v6, &v8);
      if ((result & 0x80000000) != 0) {
        break;
      }
      *(void *)&a3[2 * v6++ + 2] = v8;
      if (a2 == v6) {
        goto LABEL_7;
      }
    }
  }
  return result;
}

uint64_t mosynt_GetReading(uint64_t a1, uint64_t a2, int a3, _DWORD *a4, unsigned __int8 *a5, int a6, char *a7, int a8, _DWORD *a9)
{
  uint64_t v37 = *MEMORY[0x263EF8340];
  uint64_t v34 = 0;
  memset(v33, 0, sizeof(v33));
  if (a1)
  {
    if (*(_DWORD *)(a1 + 1024))
    {
      uint64_t v15 = *(unsigned __int16 *)(a1 + 1028);
    }
    else
    {
      uint64_t v15 = 0;
      *(_WORD *)(a1 + 1028) = 0;
      *(_DWORD *)(a1 + 1024) = 1;
      *(_DWORD *)(a1 + 1032) = 20;
    }
  }
  else
  {
    uint64_t v15 = 0;
  }
  *a4 = 0;
  *a5 = 0;
  *a7 = 0;
  *a9 = 0;
  uint64_t v16 = *(void *)(a2 + 240);
  if (!v16) {
    return 0;
  }
  *a4 = 1;
  int v35 = 0;
  int v17 = a6 - 1;
  uint64_t result = mosyntkbsymtab_AppDecomprConsToString(a1, *(uint64_t **)a2, *(_DWORD *)(v16 + 8), (uint64_t)a5, a6 - 1, &v35);
  if ((result & 0x80000000) == 0)
  {
    a5[v17] = 0;
    uint64_t result = hlp_CastFSTSeq(*(void *)(a2 + 216), *(_DWORD *)(a2 + 224), (int *)v33);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = mosyntwordpho_ReadingToPhonString(a1, v15, *(uint64_t **)a2, v16, a7, a8);
      if ((result & 0x80000000) == 0)
      {
        if (!strcmp((const char *)(a2 + 248), a7))
        {
          unsigned int v20 = (const char *)(a2 + 1248);
          int v19 = a7;
        }
        else
        {
          __strcpy_chk();
          uint64_t result = mosyntwordpho_TreatSingleReadingString(a1, v15, *(void *)a2, (uint64_t)v33, v16, (unsigned __int8 *)a7, a8);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          a7[a8 - 1] = 0;
          int v19 = (char *)(a2 + 1248);
          unsigned int v20 = a7;
        }
        strcpy(v19, v20);
        uint64_t result = mosyntwordpho_TraceReading(a1, v15, *(uint64_t **)a2, v16, (unsigned __int8 *)a7, a8);
        if ((result & 0x80000000) == 0)
        {
          *a9 = *(_DWORD *)(v16 + 12);
          if (a3)
          {
            *(_DWORD *)long long __s = 8689634;
            unsigned int v21 = strlen(__s);
            unsigned int v22 = strlen(a7);
            unsigned int v23 = v22 + 2 * v21;
            LODWORD(v24) = ~(2 * v21) + a8;
            if (v23 <= a8 - 1) {
              uint64_t v24 = v22;
            }
            else {
              uint64_t v24 = v24;
            }
            if (v24)
            {
              uint64_t v25 = v24 - 1;
              do
                a7[v21 + v25] = a7[v25];
              while ((unint64_t)v25--);
            }
            if (v21)
            {
              uint64_t v27 = v21;
              if (v23 >= a8 - 1) {
                unsigned int v23 = a8 - 1;
              }
              unsigned int v28 = v23 - v21;
              int v29 = __s;
              BOOL v30 = a7;
              do
              {
                char v31 = *v29++;
                *v30++ = v31;
                a7[v28++] = v31;
                --v27;
              }
              while (v27);
            }
            uint64_t result = 0;
            a7[2 * v21 + v24] = 0;
          }
          if (!v15
            || (HIDWORD(v32) = 0,
                LODWORD(v32) = 0,
                *(void *)((char *)&v32 + 4) = *(unsigned int *)(v16 + 12),
                uint64_t result = mosyntbase_WriteMessage(a1, "\n[WANA] reading: %s cost %d  %s\n\n", 0, a5, 0, (unsigned __int8 *)a7, 0, (unsigned __int8 *)&byte_20D5A22AE, v32), (result & 0x80000000) == 0)&& (uint64_t result = mosyntdata_WriteReadingStruct(a1, *(uint64_t **)a2, 1, v16, 4), (result & 0x80000000) == 0))
          {
            *(void *)(a2 + 240) = **(void **)(a2 + 240);
          }
        }
      }
    }
  }
  return result;
}

uint64_t mosynt_SkipToFirstOptimalReading(uint64_t a1, uint64_t a2)
{
  char v2 = *(uint64_t **)(a2 + 240);
  if (v2)
  {
    int v3 = *((_DWORD *)v2 + 3);
    size_t v4 = *(uint64_t **)(a2 + 240);
    do
    {
      if (*((_DWORD *)v4 + 3) < v3)
      {
        char v2 = v4;
        int v3 = *((_DWORD *)v4 + 3);
      }
      size_t v4 = (uint64_t *)*v4;
    }
    while (v4);
    *(void *)(a2 + 240) = v2;
  }
  return 0;
}

uint64_t mosynt_FinishWordAnalysis(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 1024))
    {
      if (*(_WORD *)(a1 + 1028))
      {
        uint64_t result = mosyntbase_WriteMessage(a1, "\n\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
        if (!a2 || (result & 0x80000000) != 0) {
          return result;
        }
        goto LABEL_9;
      }
    }
    else
    {
      *(_WORD *)(a1 + 1028) = 0;
      *(_DWORD *)(a1 + 1024) = 1;
      *(_DWORD *)(a1 + 1032) = 20;
    }
  }
  uint64_t result = 0;
  if (!a2) {
    return result;
  }
LABEL_9:
  unsigned int v5 = *(void **)(a2 + 232);
  if (v5)
  {
    while (1)
    {
      uint64_t v6 = v5;
      unsigned int v5 = (void *)*v5;
      uint64_t result = mosyntdata_DisposeItem(a1, (uint64_t *)&v6);
      if ((result & 0x80000000) != 0) {
        break;
      }
      if (!v5) {
        goto LABEL_12;
      }
    }
  }
  else
  {
LABEL_12:
    *(unsigned char *)(a2 + 1248) = 0;
    *(void *)(a2 + 232) = 0;
    *(void *)(a2 + 240) = 0;
    *(unsigned char *)(a2 + 248) = 0;
  }
  return result;
}

uint64_t mosynt_LHPlusMapping(uint64_t a1, uint64_t *a2, uint64_t a3, char *__s1, char *a5, unsigned int a6)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 1024))
    {
      int v12 = *(unsigned __int16 *)(a1 + 1028);
    }
    else
    {
      int v12 = 0;
      *(_WORD *)(a1 + 1028) = 0;
      *(_DWORD *)(a1 + 1024) = 1;
      *(_DWORD *)(a1 + 1032) = 20;
    }
  }
  else
  {
    int v12 = 0;
  }
  uint64_t v19 = 0;
  int v18 = 0;
  memset(v16, 0, sizeof(v16));
  uint64_t v17 = 0;
  *a5 = 0;
  if (!strncmp(__s1, "[SVOX]", 6uLL))
  {
    uint64_t v15 = strncpy(a5, __s1, a6 - 1);
    uint64_t v14 = "[SVOX]";
LABEL_14:
    mosynt_RemoveInitSubstr(v15, v14);
    if (!v12) {
      return 0;
    }
    uint64_t result = mosyntbase_WriteMessage(a1, "[WANA] before LHPlus mapping: %s\n", 0, (unsigned __int8 *)__s1, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
    if ((result & 0x80000000) == 0) {
      return mosyntbase_WriteMessage(a1, "[WANA] after LHPlus mapping: %s\n\n", 0, (unsigned __int8 *)a5, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
    }
    return result;
  }
  if (a6 >= 6)
  {
    strcpy(a5, "{VOC}");
    strncat(a5, __s1, a6 - 6);
  }
  uint64_t result = fst_getFSTSeq(a3, 1, &v19, &v18);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = hlp_CastFSTSeq(v19, v18, (int *)v16);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = mosyntwordpho_LHPlusMapping(a1, v12, a2, (int *)v16, (unsigned __int8 *)a5, a6);
      if ((result & 0x80000000) == 0)
      {
        a5[a6 - 1] = 0;
        uint64_t v14 = "{VOC}";
        uint64_t v15 = a5;
        goto LABEL_14;
      }
    }
  }
  return result;
}

uint64_t mosynt_StartSentenceAnalysis(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  if (!a1)
  {
    int v9 = 0;
    if (a7) {
      goto LABEL_6;
    }
    return 0;
  }
  if (!*(_DWORD *)(a1 + 1024))
  {
    int v9 = 0;
    *(_WORD *)(a1 + 1028) = 0;
    *(_DWORD *)(a1 + 1024) = 1;
    *(_DWORD *)(a1 + 1032) = 20;
    if (a7) {
      goto LABEL_6;
    }
    return 0;
  }
  int v9 = *(unsigned __int16 *)(a1 + 1028);
  if (!a7) {
    return 0;
  }
LABEL_6:
  uint64_t v13 = 0;
  *a7 = a5;
  a7[1] = a6;
  uint64_t result = com_mosynt_GetCfgParamVal(a2, a3, a4, (uint64_t)"mosynt_maxvertexedges", "-1", &v13);
  if ((result & 0x80000000) == 0)
  {
    int v11 = atoi(v13);
    if (v11 >= 0) {
      int v12 = v11;
    }
    else {
      int v12 = 200;
    }
    uint64_t result = mosyntsentana_CreateAndInitParseDesc(a1, v9, *a7, a7[1], v12, a7 + 2);
    if ((result & 0x80000000) == 0) {
      a7[3] = 0;
    }
  }
  return result;
}

void mosynt_InsertTerminals(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 *a9)
{
  uint64_t v9 = MEMORY[0x270FA5388]();
  uint64_t v33 = v11;
  int v32 = v12;
  unsigned int v14 = v13;
  unsigned int v16 = v15;
  signed int v18 = v17;
  uint64_t v20 = v19;
  uint64_t v21 = v9;
  uint64_t v41 = *MEMORY[0x263EF8340];
  if (v9)
  {
    if (*(_DWORD *)(v9 + 1024))
    {
      unsigned int v22 = *(unsigned __int16 *)(v9 + 1028);
    }
    else
    {
      unsigned int v22 = 0;
      *(_WORD *)(v9 + 1028) = 0;
      *(_DWORD *)(v9 + 1024) = 1;
      *(_DWORD *)(v9 + 1032) = 20;
    }
  }
  else
  {
    unsigned int v22 = 0;
  }
  memset(v40, 0, sizeof(v40));
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  int v34 = 0;
  if (*v10) {
    unsigned int v23 = v10;
  }
  else {
    unsigned int v23 = "MosyntDummyConsFeat";
  }
  int v24 = strlen(v23);
  while ((mosyntkbsymtab_GetConsFeatFromString(v21, *(uint64_t **)v20, 1, (unsigned __int8 *)v23, v24, (signed int *)&v35, (_DWORD *)&v35 + 1, v40) & 0x80000000) == 0)
  {
    if (SHIDWORD(v35) < 1)
    {
      if ((mosyntbase_WriteMessage(v21, "[SANA] error converting cons/feat \"%s\"\n", 0, (unsigned __int8 *)v23, 0, a9, 0, (unsigned __int8 *)&byte_20D5A22AE, 0) & 0x80000000) != 0)return; {
      goto LABEL_26;
      }
    }
    mosyntdata_NewTermInfo(v21, 0, &v36);
    if (v25 < 0) {
      return;
    }
    uint64_t v26 = v36;
    if (v36)
    {
      *(_DWORD *)(v36 + 8) = v32;
      *(void *)(v26 + 16) = v33;
      *(_DWORD *)(v26 + 24) = v18;
      *(_DWORD *)(v26 + 28) = v16 - 2;
      *(void *)(v26 + 32) = a9;
      *(_DWORD *)(v26 + 40) = 0;
      int v27 = strlen((const char *)a9);
      int v28 = v27 - 1;
      if (v27 > 4999) {
        int v28 = 4998;
      }
      *(_DWORD *)(v26 + 44) = v28;
      if (v22)
      {
LABEL_20:
        uint64_t v29 = v28 + 1;
        __strncpy_chk();
        v37[v29] = 0;
        int v34 = 0;
        if ((mosyntkbsymtab_AppConsFeatToString(v21, *(uint64_t **)v20, HIDWORD(v35), v40, (uint64_t)v39, 4999, &v34) & 0x80000000) != 0) {
          return;
        }
        __strcpy_chk();
        if ((mosyntkbsymtab_ConsFeatToComprConsFeatStr((uint64_t)v38, 5000) & 0x80000000) != 0) {
          return;
        }
        *((void *)&v30 + 1) = v14;
        LODWORD(v30) = 0;
        DWORD1(v30) = ~v18 + v16;
        if ((mosyntbase_WriteMessage(v21, "[SANA] reading from pos 0 to pos %d: %s cost %d  %s\n", 0, v38, 0, v37, 0, (unsigned __int8 *)&byte_20D5A22AE, v30) & 0x80000000) != 0)return; {
        if (v22 >= 2)
        }
        {
          *((void *)&v31 + 1) = v16;
          LODWORD(v31) = 0;
          DWORD1(v31) = v18;
          if ((mosyntbase_WriteMessage(v21, "[SANA] terminal edge from %d to %d for %s \"%s\"\n", 0, v39, 0, v37, 0, (unsigned __int8 *)&byte_20D5A22AE, v31) & 0x80000000) != 0)return; {
        }
          }
      }
    }
    else
    {
      int v28 = 0;
      if (v22) {
        goto LABEL_20;
      }
    }
    if ((mosyntsentana_InsertTerminalEdge(v21, *(int **)(v20 + 16), v18, v16, SHIDWORD(v35), (uint64_t)v40, v36, v14) & 0x80000000) != 0) {
      return;
    }
LABEL_26:
    if (v23[(int)v35] != 92)
    {
      if (v22) {
        mosyntbase_WLn(v21);
      }
      return;
    }
    LODWORD(v35) = v35 + 1;
  }
}

void mosynt_ParseSentence(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (*(_DWORD *)(a1 + 1024))
    {
      int v4 = *(unsigned __int16 *)(a1 + 1028);
    }
    else
    {
      int v4 = 0;
      *(_WORD *)(a1 + 1028) = 0;
      *(_DWORD *)(a1 + 1024) = 1;
      *(_DWORD *)(a1 + 1032) = 20;
    }
  }
  else
  {
    int v4 = 0;
  }
  if ((mosyntsentana_DoParse(a1, *(void *)(a2 + 16)) & 0x80000000) == 0)
  {
    mosyntsentana_GetOptimalTree(a1, *(void *)(a2 + 16), (void *)(a2 + 24));
    if ((v5 & 0x80000000) == 0
      && v4
      && (mosyntbase_WLn(a1) & 0x80000000) == 0
      && (mosyntbase_WLn(a1) & 0x80000000) == 0)
    {
      uint64_t v6 = *(void *)(a2 + 16);
      char v7 = *(uint64_t **)(a2 + 24);
      mosyntsentana_DisplayTree(a1, v6, v7);
    }
  }
}

uint64_t mosynt_GetTerminalInfoById(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, unsigned char *a5, int a6)
{
  *a4 = 0;
  *a5 = 0;
  if (!a2) {
    return 0;
  }
  uint64_t result = *(void *)(a2 + 24);
  if (!result) {
    return result;
  }
  uint64_t v15 = 0;
  mosynt_GetTerminalNode(result, a3, &v15);
  uint64_t v12 = v15;
  if (!v15) {
    return 0;
  }
  *a4 = 1;
  int v14 = 0;
  unsigned int v13 = a6 - 1;
  uint64_t result = mosyntkbsymtab_AppConsFeatToString(a1, *(uint64_t **)a2, *(__int16 *)(v12 + 16), (__int16 *)(v12 + 24), (uint64_t)a5, v13, &v14);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = 0;
    a5[v13] = 0;
  }
  return result;
}

uint64_t mosynt_GetTerminalNode(uint64_t result, uint64_t a2, uint64_t *a3)
{
  *a3 = 0;
  if (*(unsigned char *)(result + 60))
  {
    uint64_t v5 = *(void *)(result + 64);
    if (v5)
    {
      if (*(_DWORD *)(v5 + 8) == a2) {
        *a3 = result;
      }
    }
  }
  else
  {
    uint64_t v6 = *(void **)(result + 8);
    if (v6)
    {
      do
      {
        uint64_t result = mosynt_GetTerminalNode(v6, a2, a3);
        uint64_t v6 = (void *)*v6;
        if (*a3) {
          BOOL v7 = 1;
        }
        else {
          BOOL v7 = v6 == 0;
        }
      }
      while (!v7);
    }
  }
  return result;
}

uint64_t mosynt_SyntTreeToString(uint64_t a1, uint64_t a2, unsigned char *a3, uint64_t a4)
{
  *a3 = 0;
  if (!a2) {
    return 0;
  }
  int v5 = 0;
  return mosynt_SyntTreeToString1(a1, *(uint64_t **)a2, *(void *)(a2 + 24), (uint64_t)a3, a4, &v5);
}

uint64_t mosynt_SyntTreeToString1(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, int *a6)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  if (!a3) {
    return 0;
  }
  int v27 = *a6;
  unsigned int v12 = a5 - 1;
  uint64_t result = mosyntkbsymtab_AppConsFeatToString(a1, a2, *(__int16 *)(a3 + 16), (__int16 *)(a3 + 24), a4, (int)a5 - 1, &v27);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  *(unsigned char *)(a4 + v12) = 0;
  uint64_t v14 = (unsigned __int16)v27;
  *a6 = (unsigned __int16)v27;
  uint64_t v15 = (void *)(a3 + 8);
  if (*(void *)(a3 + 8))
  {
    if (v14 < v12)
    {
      *(unsigned char *)(a4 + v14) = 91;
      LODWORD(v14) = *a6 + 1;
      *a6 = v14;
    }
    *(unsigned char *)(a4 + v14) = 0;
    unsigned int v16 = (void *)(a3 + 8);
    while (1)
    {
      unsigned int v16 = (void *)*v16;
      if (!v16) {
        break;
      }
      if (v16 != (void *)*v15)
      {
        uint64_t v17 = *a6;
        if (v17 < v12)
        {
          *(unsigned char *)(a4 + v17) = 44;
          LODWORD(v17) = *a6 + 1;
          *a6 = v17;
        }
        *(unsigned char *)(a4 + v17) = 0;
      }
      uint64_t result = mosynt_SyntTreeToString1(a1, a2, v16, a4, a5, a6);
      if ((result & 0x80000000) != 0) {
        return result;
      }
    }
    unsigned int v25 = *a6;
    if (*a6 >= v12) {
      goto LABEL_32;
    }
    char v26 = 93;
  }
  else
  {
    if (v14 < v12)
    {
      *(unsigned char *)(a4 + v14) = 60;
      LODWORD(v14) = *a6 + 1;
      *a6 = v14;
    }
    *(unsigned char *)(a4 + v14) = 0;
    LH_itoa(*(_DWORD *)(a3 + 52), v28, 0xAu);
    LOBYTE(v18) = v28[0];
    unsigned int v19 = *a6;
    if (v28[0])
    {
      int v20 = 1;
      do
      {
        if (v19 >= v12) {
          break;
        }
        *(unsigned char *)(a4 + v19) = v18;
        unsigned int v19 = *a6 + 1;
        *a6 = v19;
        int v18 = v28[v20++];
      }
      while (v18);
    }
    *(unsigned char *)(a4 + v19) = 0;
    uint64_t v21 = *a6;
    if (v21 < v12)
    {
      *(unsigned char *)(a4 + v21) = 44;
      LODWORD(v21) = *a6 + 1;
      *a6 = v21;
    }
    *(unsigned char *)(a4 + v21) = 0;
    LH_itoa(*(_DWORD *)(a3 + 56), v28, 0xAu);
    LOBYTE(v22) = v28[0];
    unsigned int v23 = *a6;
    if (v28[0])
    {
      int v24 = 1;
      do
      {
        if (v23 >= v12) {
          break;
        }
        *(unsigned char *)(a4 + v23) = v22;
        unsigned int v23 = *a6 + 1;
        *a6 = v23;
        int v22 = v28[v24++];
      }
      while (v22);
    }
    *(unsigned char *)(a4 + v23) = 0;
    unsigned int v25 = *a6;
    if (*a6 >= v12) {
      goto LABEL_32;
    }
    char v26 = 62;
  }
  *(unsigned char *)(a4 + v25) = v26;
  unsigned int v25 = *a6 + 1;
  *a6 = v25;
LABEL_32:
  uint64_t result = 0;
  *(unsigned char *)(a4 + v25) = 0;
  return result;
}

uint64_t mosynt_FinishSentenceAnalysis(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  if (!*(void *)(a2 + 24)
    || (uint64_t result = mosyntsentana_DisposeTree(a1, *(void *)(a2 + 16), a2 + 24), (result & 0x80000000) == 0))
  {
    return mosyntsentana_DisposeParseDesc(a1, (uint64_t *)(a2 + 16));
  }
  return result;
}

void mosynt_StringToSyntTree(uint64_t a1, uint64_t *a2, char *__s, uint64_t *a4)
{
  uint64_t v12 = 0;
  int v11 = 0;
  __int16 v8 = strlen(__s);
  mosynt_StringToSyntTree1(a1, a2, (unsigned __int8 *)__s, (unsigned __int16)(v8 + 1), (signed int *)&v12 + 1, a4, (int *)&v12, &v11);
  if ((v9 & 0x80000000) == 0)
  {
    if (__s[SHIDWORD(v12)])
    {
      LODWORD(v10) = 0;
      HIDWORD(v10) = HIDWORD(v12);
      mosyntbase_WriteMessage(a1, "### syntax tree not fully parsed; last position is %d: %s\n",
        0,
        (unsigned __int8 *)__s,
        0,
        (unsigned __int8 *)&byte_20D5A22AE,
        0,
        (unsigned __int8 *)&byte_20D5A22AE,
        v10);
    }
  }
}

void mosynt_StringToSyntTree1(uint64_t a1, uint64_t *a2, unsigned __int8 *a3, uint64_t a4, signed int *a5, uint64_t *a6, int *a7, _DWORD *a8)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  *a6 = 0;
  if ((mosyntutils_SkipBlanksInString((uint64_t)a3, a4, a5) & 0x80000000) == 0)
  {
    if (a3[*a5])
    {
      int v29 = 0;
      uint64_t v31 = 0;
      __n128 v30 = 0uLL;
      int v27 = 0;
      uint64_t v28 = 0;
      char v26 = 0;
      int v25 = 0;
      if ((mosyntkbsymtab_GetConsFeatFromString(a1, a2, 1, a3, a4, a5, &v29, (__int16 *)&v30) & 0x80000000) == 0)
      {
        mosyntdata_NewSyntNode(a1, v29, &v30, a6);
        if ((v16 & 0x80000000) == 0)
        {
          uint64_t v17 = *a6;
          *(unsigned char *)(v17 + 60) = 0;
          *(void *)uint64_t v17 = 0;
          *(void *)(*a6 + 8) = 0;
          if (a3[*a5] == 91)
          {
            if ((mosyntutils_CheckSkipCharInString(a1, a3, a4, a5, 0x5Bu) & 0x80000000) == 0
              && (mosyntdata_StartPhonList(a1, &v28, &v27) & 0x80000000) == 0)
            {
              uint64_t v18 = a1;
              unsigned int v19 = a2;
              int v20 = a3;
              uint64_t v21 = a4;
              int v22 = a5;
              unsigned int v23 = a7;
              while ((mosynt_StringToSyntTree1(v18, v19, v20, v21, v22, &v26, v23, a8) & 0x80000000) == 0
                   && (mosyntdata_AppendNode(a1, &v28, &v27, 1, v26) & 0x80000000) == 0)
              {
                if (a3[*a5] != 44)
                {
                  if ((mosyntutils_CheckSkipCharInString(a1, a3, a4, a5, 0x5Du) & 0x80000000) == 0)
                  {
                    *(void *)(*a6 + 8) = v28;
                    uint64_t v24 = *a6;
                    *(_DWORD *)(v24 + 52) = *a7;
                    *(_DWORD *)(v24 + 56) = *a8;
                  }
                  return;
                }
                if ((mosyntutils_CheckSkipCharInString(a1, a3, a4, a5, 0x2Cu) & 0x80000000) != 0) {
                  return;
                }
                unsigned int v23 = &v25;
                uint64_t v18 = a1;
                unsigned int v19 = a2;
                int v20 = a3;
                uint64_t v21 = a4;
                int v22 = a5;
              }
            }
          }
          else
          {
            *(unsigned char *)(*a6 + 60) = 1;
            if ((mosyntutils_CheckSkipCharInString(a1, a3, a4, a5, 0x3Cu) & 0x80000000) == 0
              && (mosyntutils_GetCardFromString(a1, a3, a4, a5, a7) & 0x80000000) == 0)
            {
              *(_DWORD *)(*a6 + 52) = *a7;
              if ((mosyntutils_CheckSkipCharInString(a1, a3, a4, a5, 0x2Cu) & 0x80000000) == 0
                && (mosyntutils_GetCardFromString(a1, a3, a4, a5, a8) & 0x80000000) == 0)
              {
                *(_DWORD *)(*a6 + 56) = *a8;
                mosyntutils_CheckSkipCharInString(a1, a3, a4, a5, 0x3Eu);
              }
            }
          }
        }
      }
    }
  }
}

uint64_t mosynt_StartAccentPhrasing(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7)
{
  if (!a7) {
    return 0;
  }
  *(void *)a7 = a5;
  if (mosyntkbaccphr_AccPhrType(a6)) {
    uint64_t v14 = a6;
  }
  else {
    uint64_t v14 = 0;
  }
  long long __s = 0;
  *(void *)(a7 + 8) = v14;
  uint64_t result = com_mosynt_GetCfgParamVal(a2, a3, a4, (uint64_t)"mosynt_phrpar", "1", &__s);
  if ((result & 0x80000000) == 0)
  {
    *(_WORD *)(a7 + 16) = atoi(__s);
    uint64_t result = com_mosynt_GetCfgParamVal(a2, a3, a4, (uint64_t)"mosynt_accphrdefdomain", "DEFAULT", &__s);
    if ((result & 0x80000000) == 0)
    {
      strlen(__s);
      *(_DWORD *)(a7 + 20) = mosyntkbsymtab_KnownAtomId(a1, a5, (uint64_t)__s);
      return mosyntdata_CreateAndInitSentTermData(a1, (uint64_t *)(a7 + 24));
    }
  }
  return result;
}

double mosynt_InsertAccPhrTermWord(uint64_t a1, uint64_t a2, unsigned int a3, signed int a4, int a5, char *__s)
{
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v12 = *(uint64_t **)a2;
  int v13 = strlen(__s);
  if ((mosyntdata_StringToLexPhonList(a1, v12, (unsigned __int8 *)__s, v13, &v16, &v15) & 0x80000000) == 0) {
    return mosyntdata_InsertSentTermWord(a1, *(void *)(a2 + 24), a3, a4, a5, v16);
  }
  return result;
}

BOOL mosynt_IsPunctChar(uint64_t a1, uint64_t a2, int a3)
{
  return a2 && mosyntknowl_OrthPunctType(a1, a3) != 0;
}

void mosynt_InsertAccPhrPunct(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  int v7 = mosyntknowl_OrthPunctType(a1, a4);
  if (v7)
  {
    uint64_t v8 = *(void *)(a2 + 24);
    mosyntdata_InsertSentTermPunct(a1, v8, a3, v7);
  }
}

void mosynt_DoAccentPhrasing(uint64_t a1, uint64_t a2, char *a3)
{
  int v7 = 0;
  uint64_t v8 = 0;
  if (a1)
  {
    if (*(_DWORD *)(a1 + 1024))
    {
      int v5 = *(unsigned __int16 *)(a1 + 1028);
    }
    else
    {
      int v5 = 0;
      *(_WORD *)(a1 + 1028) = 0;
      *(_DWORD *)(a1 + 1024) = 1;
      *(_DWORD *)(a1 + 1032) = 20;
    }
  }
  else
  {
    int v5 = 0;
  }
  mosynt_StringToSyntTree(a1, *(uint64_t **)a2, a3, &v8);
  if ((v6 & 0x80000000) == 0
    && (mosyntaccphr_TreatSyntTree(a1, v5, *(void *)a2, *(void *)(a2 + 8), *(unsigned __int16 *)(a2 + 16), *(_DWORD *)(a2 + 20), *(void *)(a2 + 24), v8) & 0x80000000) == 0&& (!v5|| (mosyntdata_GenPhonoRepr(a1, *(void *)a2, *(void *)(a2 + 24), &v7) & 0x80000000) == 0&& (mosyntbase_WLn(a1) & 0x80000000) == 0&& (mosyntbase_WString(a1, "after acc/phr: ", 0) & 0x80000000) == 0&& (mosyntdata_WritePhonList(a1, *(uint64_t **)a2, v7) & 0x80000000) == 0&& (mosyntbase_WLn(a1) & 0x80000000) == 0&& (mosyntbase_WLn(a1) & 0x80000000) == 0&& (mosyntdata_DisposePhonEleList(a1, &v7) & 0x80000000) == 0))
  {
    if (v8) {
      mosyntdata_DisposeSyntTree(a1, &v8);
    }
  }
}

uint64_t mosynt_GetWordProminence(uint64_t a1, uint64_t a2, unsigned int a3, _WORD *a4)
{
  *a4 = 0;
  if (a2
    && (uint64_t v5 = *(void *)(a2 + 24)) != 0
    && (uint64_t v6 = mosyntdata_SentTermWordData(a1, v5, a3)) != 0
    && (int v7 = *(_DWORD *)(v6 + 16), (v7 & 0xFFFC) == 0))
  {
    unint64_t v8 = 0x1000200020000uLL >> (16 * v7);
  }
  else
  {
    LOWORD(v8) = 0;
  }
  *a4 = v8;
  return 0;
}

uint64_t mosynt_GetPhraseInfo(uint64_t a1, uint64_t a2, unsigned int a3, _WORD *a4, unsigned char *a5, int a6)
{
  *a4 = 0;
  *a5 = 0;
  if (!a2) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 24);
  if (!v6) {
    return 0;
  }
  uint64_t result = mosyntdata_SentTermBoundData(a1, v6, a3);
  if (!result) {
    return result;
  }
  int v11 = *(_DWORD *)(result + 8);
  if (v11 < 0) {
    return 0;
  }
  *a4 = v11;
  int v12 = mosyntkbaccphr_SimplifiedPhraseType(*(_DWORD *)(result + 12));
  uint64_t result = mosyntkbaccphr_PhraseTypeToString(v12, (uint64_t)a5, a6);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = 0;
    a5[a6 - 1] = 0;
  }
  return result;
}

uint64_t mosynt_FinishAccentPhrasing(uint64_t a1, uint64_t a2)
{
  if (a2 && (v3 = *(void *)(a2 + 24), char v2 = (uint64_t *)(a2 + 24), v3)) {
    return mosyntdata_DisposeSentTermData(a1, v2);
  }
  else {
    return 0;
  }
}

uint64_t mosynt_SentPhono(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned __int8 *a4, char *a5, char *a6, int a7)
{
  uint64_t v48 = 0;
  v49[0] = 0;
  if (!a1)
  {
    int v14 = 0;
    goto LABEL_7;
  }
  if (!*(_DWORD *)(a1 + 1024))
  {
    int v14 = 0;
    *(_WORD *)(a1 + 1028) = 0;
    char v16 = 1;
    *(_DWORD *)(a1 + 1024) = 1;
    *(_DWORD *)(a1 + 1032) = 20;
    goto LABEL_9;
  }
  int v14 = *(unsigned __int16 *)(a1 + 1028);
  if (!*(_WORD *)(a1 + 1028))
  {
LABEL_7:
    char v16 = 1;
    goto LABEL_9;
  }
  uint64_t result = mosyntbase_WriteMessage(a1, "[SLPH] input string: %s\n", 0, a4, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  char v16 = 0;
LABEL_9:
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  int v43 = 0;
  long long v42 = 0;
  memset(v40, 0, sizeof(v40));
  uint64_t v41 = 0;
  memset(v38, 0, sizeof(v38));
  uint64_t v39 = 0;
  uint64_t v37 = 0;
  memset(v36, 0, sizeof(v36));
  int v17 = strlen((const char *)a4);
  size_t v18 = strlen(a5);
  uint64_t result = mosyntdata_StringToPhonoPhonList(a1, a2, 1, a4, v17, a5, v18, v49);
  if ((result & 0x80000000) == 0)
  {
    if ((v16 & 1) != 0
      || (uint64_t result = mosyntbase_WString(a1, "[SLPH] input phono list: ", 0), (result & 0x80000000) == 0)
      && (uint64_t result = mosyntdata_WritePhonList(a1, a2, v49[0]), (result & 0x80000000) == 0)
      && (uint64_t result = mosyntbase_WLn(a1), (result & 0x80000000) == 0))
    {
      uint64_t result = fst_getFSTSeq(a3, 2, &v47, (_DWORD *)&v44 + 1);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = hlp_CastFSTSeq(v47, SHIDWORD(v44), (int *)v40);
        if ((result & 0x80000000) == 0)
        {
          uint64_t result = fst_getFSTSeq(a3, 3, &v46, &v44);
          if ((result & 0x80000000) == 0)
          {
            uint64_t result = hlp_CastFSTSeq(v46, v44, (int *)v38);
            if ((result & 0x80000000) == 0)
            {
              uint64_t result = fst_getFSTSeq(a3, 4, &v45, &v43);
              if ((result & 0x80000000) == 0)
              {
                uint64_t result = hlp_CastFSTSeq(v45, v43, (int *)v36);
                if ((result & 0x80000000) == 0)
                {
                  unsigned int v19 = v49[0];
                  if (v49[0])
                  {
                    int v20 = 0;
                    uint64_t v21 = v49[0];
                    do
                    {
                      *((_WORD *)v21 + 4) = v20++;
                      uint64_t v21 = (void *)*v21;
                    }
                    while (v21);
                  }
                  uint64_t result = mosyntsentpho_TreatSentPho(a1, v14, (uint64_t)a2, (int *)v40, (int *)v38, (int *)v36, v19, &v48);
                  if ((result & 0x80000000) == 0)
                  {
                    int v22 = v48;
                    unsigned int v23 = v49[0];
                    long long v42 = v48;
                    if (v49[0])
                    {
                      while (1)
                      {
                        if (!v22) {
                          goto LABEL_36;
                        }
                        int v24 = *((unsigned __int16 *)v22 + 4);
                        if (v24 == 0xFFFF || *((__int16 *)v23 + 4) > (__int16)v24)
                        {
                          int v22 = (uint64_t *)*v22;
                          long long v42 = v22;
                        }
                        else
                        {
                          if (*((unsigned char *)v23 + 20)) {
                            BOOL v25 = v24 == *((unsigned __int16 *)v23 + 4);
                          }
                          else {
                            BOOL v25 = 0;
                          }
                          if (v25 && *((unsigned char *)v22 + 20) && *((_DWORD *)v23 + 6) >= 2u && *((_DWORD *)v22 + 6) <= 1u)
                          {
                            __int16 v26 = mosyntkbsymtab_KnownPhonId(a1, a2, (uint64_t)"*");
                            int v27 = v42;
                            *((_DWORD *)v42 + 6) = 2;
                            uint64_t v28 = *v27;
                            *int v27 = 0;
                            uint64_t result = mosyntdata_AddPhonEle(a1, &v48, (uint64_t *)&v42, 1, v26);
                            if ((result & 0x80000000) != 0) {
                              return result;
                            }
                            uint64_t *v42 = v28;
                          }
LABEL_36:
                          unsigned int v23 = (void *)*v23;
                          if (!v23) {
                            break;
                          }
                          int v22 = v42;
                        }
                      }
                    }
                    if ((v16 & 1) != 0
                      || (uint64_t result = mosyntbase_WString(a1, "[SLPH] output phono list: ", 0), (result & 0x80000000) == 0)
                      && (uint64_t result = mosyntdata_WritePhonList(a1, a2, v48), (result & 0x80000000) == 0)
                      && (uint64_t result = mosyntbase_WLn(a1), (result & 0x80000000) == 0))
                    {
                      uint64_t result = mosyntdata_PhonListToString(a1, a2, 1, v48, a6, a7);
                      if ((result & 0x80000000) == 0)
                      {
                        a6[a7 - 1] = 0;
                        int v29 = *a6;
                        if (*a6)
                        {
                          unsigned __int16 v30 = 0;
                          uint64_t v31 = a6;
                          do
                          {
                            if (v30 && v29 == 42 && (uint64_t v32 = v30 - 1, a6[v32] == 39))
                            {
                              a6[v32] = 42;
                              char v33 = 39;
                            }
                            else
                            {
                              uint64_t v34 = v30 - 2;
                              if (v30 < 2u) {
                                goto LABEL_56;
                              }
                              if (v29 != 42) {
                                goto LABEL_56;
                              }
                              uint64_t v35 = v30 - 1;
                              if (a6[v35] != 50 || a6[v34] != 39) {
                                goto LABEL_56;
                              }
                              a6[v34] = 42;
                              a6[v35] = 39;
                              char v33 = 50;
                            }
                            *uint64_t v31 = v33;
LABEL_56:
                            uint64_t v31 = &a6[++v30];
                            int v29 = *v31;
                          }
                          while (*v31);
                        }
                        if ((v16 & 1) != 0
                          || (uint64_t result = mosyntbase_WriteMessage(a1, "[SLPH] output string: %s\n", 0, (unsigned __int8 *)a6, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0), (result & 0x80000000) == 0))
                        {
                          uint64_t result = mosyntdata_DisposePhonEleList(a1, v49);
                          if ((result & 0x80000000) == 0) {
                            return mosyntdata_DisposePhonEleList(a1, &v48);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t sgram_CheckIfExists(_WORD *a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  char v16 = 0;
  uint64_t v17 = 0;
  memset(v18, 0, sizeof(v18));
  *a3 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v17);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t inited = kbaux_BuildBrokerString(v17, "sgram", (char *)v18, 0x100uLL);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t v7 = sgram_OpenRiffForReading(a1, a2, (const char *)v18, (uint64_t *)&v16);
  uint64_t v14 = v7;
  if ((v7 & 0x80000000) == 0)
  {
    *a3 = 1;
    return sgram_CloseRiff(&v16, v7, v8, v9, v10, v11, v12, v13);
  }
  if ((v7 & 0x1FFF) == 0xD || (v7 & 0x1FFF) == 3) {
    return 0;
  }
  return v14;
}

uint64_t sgram_LoadData(_WORD *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  unsigned int v23 = 0;
  uint64_t v24 = 0;
  memset(v25, 0, sizeof(v25));
  uint64_t inited = InitRsrcFunction(a1, a2, &v24);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t v7 = 2371887111;
  if (a3)
  {
    uint64_t v8 = heap_Calloc(*(void **)(v24 + 8), 1, 232);
    *a3 = v8;
    if (!v8) {
      return 2371887114;
    }
    uint64_t inited = kbaux_BuildBrokerString(v24, "sgram", (char *)v25, 0x100uLL);
    if ((inited & 0x80000000) == 0)
    {
      uint64_t inited = sgram_OpenRiffForReading(a1, a2, (const char *)v25, (uint64_t *)&v23);
      if ((inited & 0x80000000) == 0)
      {
        uint64_t v15 = sgram_ReadFromRiff((uint64_t)v23, *a3, v9, v10, v11, v12, v13, v14);
        return sgram_CloseRiff(&v23, v15, v16, v17, v18, v19, v20, v21);
      }
    }
    return inited;
  }
  return v7;
}

uint64_t sgram_UnloadData(_WORD *a1, int a2, uint64_t *a3)
{
  uint64_t v3 = 2371887111;
  if (a3)
  {
    uint64_t v15 = 0;
    uint64_t inited = InitRsrcFunction(a1, a2, &v15);
    if ((inited & 0x80000000) != 0)
    {
      return inited;
    }
    else if (*a3)
    {
      uint64_t v13 = v15;
      uint64_t v3 = sgram_ReleaseData(*a3, v6, v7, v8, v9, v10, v11, v12);
      heap_Free(*(void **)(v13 + 8), *a3);
      *a3 = 0;
    }
  }
  return v3;
}

uint64_t sgram_GetStartCons(_DWORD *a1, _DWORD *a2)
{
  uint64_t result = 2371887111;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0;
      *a2 = *a1;
    }
  }
  return result;
}

BOOL sgram_HasEmptyRules(BOOL result)
{
  if (result) {
    return *(void *)(result + 40) != 0;
  }
  return result;
}

BOOL sgram_HasSimpleFollowRel(BOOL result)
{
  if (result) {
    return *(void *)(result + 192) != 0;
  }
  return result;
}

uint64_t sgram_GetFirstRuleSameLast(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  uint64_t result = 2371887111;
  if (a1 && a3 && a4 && a5 && a6)
  {
    int v13 = *(_DWORD *)(a1 + 80);
    *(void *)a3 = a1;
    a3[2] = 0;
    for (int i = *(_DWORD *)(*(void *)(a1 + 96) + 4 * (a2 % v13));
          ;
          int i = *(_DWORD *)(*(void *)(*(void *)a3 + 72) + 4 * (int)a3[3] + 32))
    {
      a3[3] = 10 * i;
      getRuleHeadSubCons(a3, a4, a5, a6);
      if (!*a4) {
        break;
      }
      if (*a6)
      {
        if (*a6 == a2) {
          return 0;
        }
      }
      else
      {
        uint64_t result = 0;
        if (!a2 || *a5 == a2) {
          return result;
        }
      }
    }
    return 0;
  }
  return result;
}

_DWORD *getRuleHeadSubCons(_DWORD *result, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  int v4 = result[3];
  if (result[2] == 1)
  {
    if (v4 < *(_DWORD *)(*(void *)result + 32))
    {
      uint64_t v5 = (uint64_t *)(*(void *)result + 48);
      goto LABEL_6;
    }
LABEL_8:
    int v7 = 0;
    *a2 = 0;
    *a3 = 0;
    goto LABEL_9;
  }
  if (v4 < 0) {
    goto LABEL_8;
  }
  uint64_t v5 = (uint64_t *)(*(void *)result + 72);
LABEL_6:
  uint64_t v6 = *v5;
  if (!v6) {
    goto LABEL_8;
  }
  *a2 = *(_DWORD *)(v6 + 4 * (v4 + 1));
  *a3 = *(_DWORD *)(v6 + 4 * (int)result[3] + 8);
  int v7 = *(_DWORD *)(v6 + 4 * (int)result[3] + 12);
LABEL_9:
  *a4 = v7;
  return result;
}

uint64_t sgram_GetNextRuleSameLast(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t result = 2371887111;
  if (a2 && a3 && a4 && a5)
  {
    while (1)
    {
      a2[3] = 10 * *(_DWORD *)(*(void *)(*(void *)a2 + 72) + 4 * (int)a2[3] + 32);
      getRuleHeadSubCons(a2, a3, a4, a5);
      if (!*a3) {
        break;
      }
      if (*a5)
      {
        if (*a5 == a1) {
          return 0;
        }
      }
      else
      {
        uint64_t result = 0;
        if (!a1 || *a4 == a1) {
          return result;
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t sgram_GetFirstRuleSameFirst(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  uint64_t result = 2371887111;
  if (a1 && a3 && a4 && a5 && a6)
  {
    int v13 = *(_DWORD *)(a1 + 104);
    *(void *)a3 = a1;
    a3[2] = 0;
    for (int i = *(_DWORD *)(*(void *)(a1 + 120) + 4 * (a2 % v13));
          ;
          int i = *(_DWORD *)(*(void *)(*(void *)a3 + 72) + 4 * (int)a3[3] + 36))
    {
      a3[3] = 10 * i;
      getRuleHeadSubCons(a3, a4, a5, a6);
      if (!*a4 || *a5 != a2) {
        break;
      }
    }
    return 0;
  }
  return result;
}

uint64_t sgram_GetNextRuleSameFirst(int a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t result = 2371887111;
  if (a2 && a3 && a4 && a5)
  {
    do
    {
      a2[3] = 10 * *(_DWORD *)(*(void *)(*(void *)a2 + 72) + 4 * (int)a2[3] + 36);
      getRuleHeadSubCons(a2, a3, a4, a5);
    }
    while (*a3 && *a5 != a1);
    return 0;
  }
  return result;
}

uint64_t sgram_GetFirstEmptyRule(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  uint64_t result = 2371887111;
  if (a1 && a2 && a3 && a4)
  {
    if (a5)
    {
      *(void *)a2 = a1;
      *(void *)(a2 + 8) = 1;
      getRuleHeadSubCons((_DWORD *)a2, a3, a4, a5);
      return 0;
    }
  }
  return result;
}

uint64_t sgram_GetNextEmptyRule(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  uint64_t result = 2371887111;
  if (a1 && a2 && a3)
  {
    if (a4)
    {
      a1[3] += 8;
      getRuleHeadSubCons(a1, a2, a3, a4);
      return 0;
    }
  }
  return result;
}

uint64_t sgram_GetRuleFeatLists(uint64_t *a1, _WORD *a2, _WORD *a3, _WORD *a4)
{
  uint64_t result = 2371887111;
  if (a1 && a2 && a3 && a4)
  {
    int v6 = *((_DWORD *)a1 + 3);
    if (*((_DWORD *)a1 + 2) == 1)
    {
      uint64_t v7 = *a1;
      if (v6 >= *(_DWORD *)(v7 + 32)) {
        goto LABEL_16;
      }
      uint64_t v8 = (uint64_t *)(v7 + 48);
    }
    else
    {
      if (v6 < 0) {
        goto LABEL_16;
      }
      uint64_t v7 = *a1;
      uint64_t v8 = (uint64_t *)(v7 + 72);
    }
    uint64_t v9 = *v8;
    if (v9)
    {
      uint64_t v10 = *(unsigned int *)(v9 + 4 * (v6 + 4));
      if ((v10 & 0x80000000) != 0)
      {
        LOWORD(v12) = 0;
      }
      else
      {
        uint64_t v11 = *(void *)(v7 + 24);
        int v12 = *(__int16 *)(v11 + 2 * v10);
        if (v12 >= 1)
        {
          uint64_t v13 = *(unsigned __int16 *)(v11 + 2 * v10);
          uint64_t v14 = a2 + 1;
          uint64_t v15 = (__int16 *)(v11 + 2 * v10 + 2);
          do
          {
            __int16 v16 = *v15++;
            *v14++ = v16;
            --v13;
          }
          while (v13);
        }
      }
      *a2 = v12;
      uint64_t v18 = *(unsigned int *)(v9 + 4 * (v6 + 5));
      if ((v18 & 0x80000000) != 0)
      {
        LOWORD(v20) = 0;
      }
      else
      {
        uint64_t v19 = *(void *)(v7 + 24);
        int v20 = *(__int16 *)(v19 + 2 * v18);
        if (v20 >= 1)
        {
          uint64_t v21 = *(unsigned __int16 *)(v19 + 2 * v18);
          int v22 = a3 + 1;
          unsigned int v23 = (__int16 *)(v19 + 2 * v18 + 2);
          do
          {
            __int16 v24 = *v23++;
            *v22++ = v24;
            --v21;
          }
          while (v21);
        }
      }
      *a3 = v20;
      uint64_t v25 = *(unsigned int *)(v9 + 4 * (v6 + 6));
      if ((v25 & 0x80000000) != 0)
      {
        LOWORD(v17) = 0;
      }
      else
      {
        uint64_t v26 = *(void *)(v7 + 24);
        int v17 = *(__int16 *)(v26 + 2 * v25);
        if (v17 >= 1)
        {
          uint64_t v27 = *(unsigned __int16 *)(v26 + 2 * v25);
          uint64_t v28 = a4 + 1;
          int v29 = (__int16 *)(v26 + 2 * v25 + 2);
          do
          {
            __int16 v30 = *v29++;
            *v28++ = v30;
            --v27;
          }
          while (v27);
        }
      }
      goto LABEL_17;
    }
LABEL_16:
    LOWORD(v17) = 0;
    *a2 = 0;
    *a3 = 0;
LABEL_17:
    uint64_t result = 0;
    *a4 = v17;
  }
  return result;
}

uint64_t sgram_GetRuleVisAndCost(_DWORD *a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v3 = 2371887111;
  if (a1 && a2 && a3)
  {
    uint64_t v4 = (int)a1[3];
    if (a1[2] == 1)
    {
      if ((int)v4 >= *(_DWORD *)(*(void *)a1 + 32)) {
        goto LABEL_11;
      }
      uint64_t v5 = (uint64_t *)(*(void *)a1 + 48);
    }
    else
    {
      if ((v4 & 0x80000000) != 0) {
        goto LABEL_11;
      }
      uint64_t v5 = (uint64_t *)(*(void *)a1 + 72);
    }
    uint64_t v6 = *v5;
    if (v6)
    {
      *a2 = *(_DWORD *)(v6 + 4 * v4) != 0;
      int v7 = *(_DWORD *)(v6 + 4 * (int)a1[3] + 28);
LABEL_12:
      uint64_t v3 = 0;
      *a3 = v7;
      return v3;
    }
LABEL_11:
    int v7 = 0;
    *a2 = 0;
    goto LABEL_12;
  }
  return v3;
}

BOOL sgram_IsFollowerCons(BOOL result, int a2, int a3)
{
  if (result)
  {
    uint64_t v3 = (unsigned int *)(*(void *)(result + 224) + 4 * (a3 % *(_DWORD *)(result + 208)));
    uint64_t v4 = *v3;
    LODWORD(v3) = v3[1];
    int v5 = v3 - v4;
    if ((int)v3 <= (int)v4) {
      return 0;
    }
    int v6 = 2 * v4;
    uint64_t v7 = *(void *)(result + 200);
    uint64_t v8 = v4 << 33;
    uint64_t v9 = (int *)(v7 + 4 * v6);
    while (1)
    {
      int v10 = *v9;
      v9 += 2;
      BOOL v11 = v10 == a3;
      if (v10 >= a3) {
        break;
      }
      v8 += 0x200000000;
      if (!--v5) {
        return 0;
      }
    }
    if (v11
      && (int v12 = (_DWORD *)(*(void *)(result + 176)
                         + 4
                         * (*(_DWORD *)(v7 + ((v8 >> 30) | 4))
                          + *(_DWORD *)(v7 + ((v8 >> 30) | 4)) * *(_DWORD *)(result + 160)
                          + a2 % *(_DWORD *)(result + 160))),
          LODWORD(v14) = *v12,
          int v13 = v12[1],
          uint64_t v14 = (int)v14,
          (int)v14 < v13))
    {
      uint64_t v15 = *(void *)(result + 152);
      while (1)
      {
        int v16 = *(_DWORD *)(v15 + 4 * v14);
        if (v16 >= a2) {
          break;
        }
        uint64_t result = 0;
        if (v13 <= (int)++v14) {
          return result;
        }
      }
      return v16 == a2;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t mosyntdata_StartPhonList(uint64_t a1, void *a2, void *a3)
{
  *a2 = 0;
  *a3 = 0;
  return 0;
}

uint64_t mosyntdata_AddPhonEle(uint64_t a1, void *a2, uint64_t *a3, int a4, __int16 a5)
{
  uint64_t v12 = 0;
  uint64_t result = mosyntpal_ALLOCATE(a1, &v12, 0x28u);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v10 = v12;
    *(unsigned char *)(v12 + 20) = 0;
    *(_WORD *)(v10 + 24) = a5;
    *(_WORD *)(v10 + 26) = -1;
    *(void *)(v10 + 8) = -1;
    *(_DWORD *)(v10 + 16) = 0xFFFF;
    if (a4)
    {
      *(void *)uint64_t v10 = 0;
      uint64_t v11 = v12;
      if (*a3)
      {
        *(void *)*a3 = v12;
        uint64_t v11 = v12;
      }
      else
      {
        *a2 = v12;
      }
    }
    else
    {
      *(void *)uint64_t v10 = *a2;
      uint64_t v11 = v12;
      *a2 = v12;
      if (*a3) {
        return result;
      }
    }
    *a3 = v11;
  }
  return result;
}

uint64_t mosyntdata_AddBound(uint64_t a1, uint64_t *a2, uint64_t *a3, int a4, int a5, __int16 a6, int a7, __int16 a8)
{
  uint64_t result = mosyntdata_AddPhonEle(a1, a2, a3, a4, 0);
  if ((result & 0x80000000) == 0)
  {
    if (a4) {
      int v16 = a3;
    }
    else {
      int v16 = a2;
    }
    uint64_t v17 = *v16;
    *(unsigned char *)(v17 + 20) = 1;
    *(_DWORD *)(v17 + 24) = a5;
    *(_WORD *)(v17 + 28) = a6;
    *(_DWORD *)(v17 + 32) = a7;
    *(_WORD *)(v17 + 36) = a8;
  }
  return result;
}

uint64_t mosyntdata_AppendPhonList(uint64_t a1, void *a2, void *a3, uint64_t a4, uint64_t a5)
{
  if (!*a3 || (a2 = (void *)*a3, a5))
  {
    *a2 = a4;
    *a3 = a5;
  }
  return 0;
}

void *mosyntdata_LastPhonEle(uint64_t a1, void *a2)
{
  if (!a2) {
    return 0;
  }
  do
  {
    uint64_t result = a2;
    a2 = (void *)*a2;
  }
  while (a2);
  return result;
}

uint64_t mosyntdata_PopPhonEle(uint64_t a1, void **a2, void *a3, void *a4)
{
  if (*a2)
  {
    *a4 = *a2;
    *a2 = (void *)**a2;
    a4 = (void *)*a4;
  }
  *a4 = 0;
  if (!*a2) {
    *a3 = 0;
  }
  return 0;
}

uint64_t mosyntdata_CopyPhonList(uint64_t a1, uint64_t **a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    int v5 = 0;
    int v6 = 0;
    uint64_t v12 = 0;
    while (1)
    {
      uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v12, 0x28u);
      if ((result & 0x80000000) != 0) {
        break;
      }
      uint64_t v8 = (uint64_t)v12;
      uint64_t v9 = v3[4];
      long long v10 = *((_OWORD *)v3 + 1);
      *uint64_t v12 = *(_OWORD *)v3;
      *(_OWORD *)(v8 + 16) = v10;
      *(void *)(v8 + 32) = v9;
      *(void *)uint64_t v8 = 0;
      uint64_t v11 = v12;
      if (v5)
      {
        *int v5 = v12;
        uint64_t v11 = v12;
      }
      else
      {
        int v6 = (uint64_t *)v12;
      }
      uint64_t v3 = (uint64_t *)*v3;
      int v5 = v11;
      if (!v3) {
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t result = 0;
    int v6 = 0;
LABEL_10:
    *a2 = v6;
  }
  return result;
}

uint64_t mosyntdata_DisposePhonEleList(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    while (1)
    {
      int v6 = v3;
      uint64_t v3 = (void *)*v3;
      uint64_t result = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v6);
      if ((result & 0x80000000) != 0) {
        break;
      }
      if (!v3) {
        goto LABEL_6;
      }
    }
  }
  else
  {
    uint64_t result = 0;
LABEL_6:
    *a2 = 0;
  }
  return result;
}

uint64_t mosyntdata_WritePhonEle(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned int a4, int a5, unsigned __int8 a6, unsigned __int8 a7)
{
  uint64_t v15 = 0;
  uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v15, 0x3E8u);
  if ((result & 0x80000000) == 0)
  {
    int v16 = 0;
    *uint64_t v15 = 0;
    uint64_t result = AppPhonEleString(a1, a2, (uint64_t)v15, 1000, &v16, a3, a4, a5, a6, a7);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = mosyntbase_WString(a1, v15, 1000);
      if ((result & 0x80000000) == 0) {
        return mosyntpal_DEALLOCATE(a1, (uint64_t *)&v15);
      }
    }
  }
  return result;
}

uint64_t AppPhonEleString(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, int *a5, uint64_t a6, unsigned int a7, int a8, unsigned __int8 a9, unsigned __int8 a10)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  BOOL v29 = 0;
  int v33 = 0;
  memset(v32, 0, sizeof(v32));
  __int16 v31 = 0;
  uint64_t v30 = 0;
  int v18 = mosyntkbsymtab_KnownPhonId(a1, a2, (uint64_t)"{VOC}");
  if (!*(unsigned char *)(a6 + 20))
  {
    unsigned int v22 = *(__int16 *)(a6 + 24);
    if (v18 == v22 && (int v23 = *(__int16 *)(a6 + 26), v23 >= 1))
    {
      LOWORD(v32[0]) = v23;
    }
    else
    {
      if (a8 && *(__int16 *)(a6 + 26) >= 1) {
        unsigned int v22 = *(unsigned __int16 *)(a6 + 26);
      }
      uint64_t result = mosyntkbsymtab_PhonSymString(a1, a2, v22, (char *)v32, 100);
      if ((result & 0x80000000) != 0) {
        return result;
      }
    }
    if (a7 == 10 && LOBYTE(v32[0]) == 123 && BYTE1(v32[0]) == 99)
    {
      unsigned __int8 v24 = BYTE2(v32[0]) - 48;
      if (BYTE2(v32[0]) >= 0x30u && BYTE2(v32[0]) <= 0x39u)
      {
        if (BYTE3(v32[0]) != 125 || BYTE4(v32[0]))
        {
          if (BYTE3(v32[0]) - 48 > 9 || BYTE4(v32[0]) != 125 || BYTE5(v32[0])) {
            return mosyntbase_App(a3, a4, a5, (uint64_t)v32, 100, &v29);
          }
          unsigned __int8 v24 = BYTE3(v32[0]) + 10 * BYTE2(v32[0]) - 16;
        }
        LOWORD(v32[0]) = v24;
      }
    }
    return mosyntbase_App(a3, a4, a5, (uint64_t)v32, 100, &v29);
  }
  int v19 = *(_DWORD *)(a6 + 24);
  if (v19 != 3)
  {
    if (v19 != 2)
    {
      if (v19 == 1)
      {
        unsigned int v20 = mosyntkbsymtab_SyllSepId(a2);
        uint64_t result = mosyntkbsymtab_PhonSymString(a1, a2, v20, (char *)v32, 100);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t result = mosyntbase_App(a3, a4, a5, (uint64_t)v32, 100, &v29);
        if ((result & 0x80000000) != 0) {
          return result;
        }
LABEL_52:
        if (a7 && a7 != 4) {
          goto LABEL_54;
        }
LABEL_59:
        if (*(__int16 *)(a6 + 36) <= 0) {
          return result;
        }
        goto LABEL_60;
      }
LABEL_51:
      uint64_t result = 0;
      goto LABEL_52;
    }
    if (!a7)
    {
      uint64_t v25 = " ";
LABEL_58:
      uint64_t result = mosyntbase_CApp(a3, a4, a5, (unsigned __int8 *)v25, 0, &v29);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      goto LABEL_59;
    }
    if (a7 != 1)
    {
      if (a7 == 4)
      {
        uint64_t v25 = " | ";
        goto LABEL_58;
      }
      if (a7 != 10)
      {
        if (a7 == 5)
        {
          uint64_t result = mosyntbase_CApp(a3, a4, a5, " {#WB} ", 0, &v29);
          if ((result & 0x80000000) != 0) {
            return result;
          }
        }
        else
        {
          uint64_t result = 0;
        }
LABEL_54:
        BOOL v27 = a10 != 0;
        if (a7 != 5 || a10) {
          goto LABEL_67;
        }
LABEL_60:
        uint64_t result = mosyntbase_CApp(a3, a4, a5, "[", 0, &v29);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t result = mosyntpal_IntToString(*(__int16 *)(a6 + 36), 0, v32, 100);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t result = mosyntbase_App(a3, a4, a5, (uint64_t)v32, 100, &v29);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t v28 = "]";
        return mosyntbase_CApp(a3, a4, a5, (unsigned __int8 *)v28, 0, &v29);
      }
      uint64_t v26 = " ";
      goto LABEL_49;
    }
    goto LABEL_47;
  }
  if (a7 > 5 || ((0x31u >> a7) & 1) == 0)
  {
    if (a7 == 10)
    {
      if (!(a10 | a9))
      {
        if (*(__int16 *)(a6 + 28) > 1) {
          uint64_t v26 = " / ";
        }
        else {
          uint64_t v26 = " # ";
        }
LABEL_49:
        uint64_t result = mosyntbase_CApp(a3, a4, a5, (unsigned __int8 *)v26, 0, &v29);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        goto LABEL_66;
      }
LABEL_65:
      uint64_t result = 0;
LABEL_66:
      BOOL v27 = a10 != 0;
LABEL_67:
      if (a7 != 10 || v27) {
        return result;
      }
      if (*(_WORD *)(a6 + 36) && *(__int16 *)(a6 + 36) <= 3)
      {
        uint64_t v28 = "'";
      }
      else
      {
        if (*(unsigned __int16 *)(a6 + 36) < 4u) {
          return result;
        }
        uint64_t v28 = "'2";
      }
      return mosyntbase_CApp(a3, a4, a5, (unsigned __int8 *)v28, 0, &v29);
    }
    if (a7 != 1) {
      goto LABEL_51;
    }
    if (!*(_DWORD *)(a6 + 32)) {
      goto LABEL_65;
    }
LABEL_47:
    if (*a5 >= 1)
    {
      uint64_t v26 = "|";
      goto LABEL_49;
    }
    goto LABEL_65;
  }
  uint64_t result = mosyntbase_CApp(a3, a4, a5, " #{", 0, &v29);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = mosyntpal_IntToString(*(__int16 *)(a6 + 28), 0, v32, 100);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = mosyntbase_CApp(a3, a4, a5, (unsigned __int8 *)v32, 100, &v29);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = mosyntbase_CApp(a3, a4, a5, "} ", 0, &v29);
        if ((result & 0x80000000) == 0)
        {
          if (!*(_DWORD *)(a6 + 32)) {
            goto LABEL_52;
          }
          uint64_t result = mosyntkbaccphr_PhraseTypeToString(*(_DWORD *)(a6 + 32), (uint64_t)&v30, 10);
          if ((result & 0x80000000) == 0)
          {
            uint64_t result = mosyntbase_CApp(a3, a4, a5, "(", 0, &v29);
            if ((result & 0x80000000) == 0)
            {
              uint64_t result = mosyntbase_App(a3, a4, a5, (uint64_t)&v30, 10, &v29);
              if ((result & 0x80000000) == 0)
              {
                uint64_t result = mosyntbase_CApp(a3, a4, a5, ") ", 0, &v29);
                if ((result & 0x80000000) == 0) {
                  goto LABEL_52;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mosyntdata_WritePhonList(uint64_t a1, uint64_t *a2, void *a3)
{
  return mosyntdata_WriteFormattedPhonList(a1, a2, a3, 0, 0);
}

uint64_t mosyntdata_WriteFormattedPhonList(uint64_t a1, uint64_t *a2, void *a3, unsigned int a4, int a5)
{
  if (!a3) {
    return 0;
  }
  long long v10 = a3;
  do
  {
    uint64_t result = mosyntdata_WritePhonEle(a1, a2, (uint64_t)v10, a4, a5, v10 == a3, *v10 == 0);
    if ((result & 0x80000000) != 0) {
      break;
    }
    long long v10 = (void *)*v10;
  }
  while (v10);
  return result;
}

uint64_t mosyntdata_PhonListToString(uint64_t a1, uint64_t *a2, int a3, void *a4, unsigned char *a5, int a6)
{
  int v14 = 0;
  *a5 = 0;
  if (!a4) {
    return 0;
  }
  if (a3) {
    unsigned int v11 = 10;
  }
  else {
    unsigned int v11 = 0;
  }
  uint64_t v12 = a4;
  do
  {
    uint64_t result = AppPhonEleString(a1, a2, (uint64_t)a5, a6, &v14, (uint64_t)v12, v11, 0, v12 == a4, *v12 == 0);
    if ((result & 0x80000000) != 0) {
      break;
    }
    uint64_t v12 = (void *)*v12;
  }
  while (v12);
  return result;
}

uint64_t mosyntdata_StringToLexPhonList(uint64_t a1, uint64_t *a2, unsigned __int8 *a3, int a4, void *a5, uint64_t *a6)
{
  uint64_t v14 = 0;
  *a5 = 0;
  *a6 = 0;
  uint64_t result = mosyntknowl_GetPhoneFromString(a1, a2, a3, a4, (int *)&v14, (int *)&v14 + 1);
  if ((result & 0x80000000) == 0)
  {
    __int16 v13 = WORD2(v14);
    if (SHIDWORD(v14) >= 1)
    {
      do
      {
        uint64_t result = mosyntdata_AddPhonEle(a1, a5, a6, 1, v13);
        if ((result & 0x80000000) != 0) {
          break;
        }
        uint64_t result = mosyntknowl_GetPhoneFromString(a1, a2, a3, a4, (int *)&v14, (int *)&v14 + 1);
        if ((result & 0x80000000) != 0) {
          break;
        }
        __int16 v13 = WORD2(v14);
      }
      while (SHIDWORD(v14) > 0);
    }
  }
  return result;
}

uint64_t mosyntdata_StringToPhonoPhonList(uint64_t a1, uint64_t *a2, int a3, unsigned __int8 *a4, int a5, unsigned char *a6, uint64_t a7, void *a8)
{
  int v33 = 0;
  uint64_t v32 = 0;
  int v31 = 0;
  *a8 = 0;
  uint64_t v35 = 0;
  if (a3)
  {
    uint64_t PhraseTypeFromString = mosyntdata_AddPhonEle(a1, a8, &v35, 1, 0);
    if ((PhraseTypeFromString & 0x80000000) != 0) {
      return PhraseTypeFromString;
    }
    uint64_t v13 = v35;
    *(unsigned char *)(v35 + 20) = 1;
    *(_DWORD *)(v13 + 24) = 3;
    *(_WORD *)(v13 + 28) = 0;
    *(_DWORD *)(v13 + 32) = 0;
    *(_WORD *)(v13 + 36) = 0;
  }
  else
  {
    uint64_t PhraseTypeFromString = 0;
    uint64_t v13 = 0;
  }
  int v14 = 0;
  uint64_t v15 = 0;
  int v34 = 0;
  int v16 = *a4;
  uint64_t v17 = v13;
  while (1)
  {
    if (v16 == 32)
    {
      uint64_t PhraseTypeFromString = mosyntutils_SkipBlanksInString((uint64_t)a4, a5, &v34);
      if ((PhraseTypeFromString & 0x80000000) != 0) {
        return PhraseTypeFromString;
      }
      if (*a8 && v13 != v35)
      {
        uint64_t PhraseTypeFromString = mosyntdata_AddPhonEle(a1, a8, &v35, 1, 0);
        if ((PhraseTypeFromString & 0x80000000) != 0) {
          return PhraseTypeFromString;
        }
        uint64_t v13 = v35;
        *(unsigned char *)(v35 + 20) = 1;
        int v20 = 2;
LABEL_18:
        *(_DWORD *)(v13 + 24) = v20;
        *(_WORD *)(v13 + 28) = -1;
        *(_DWORD *)(v13 + 32) = 0;
        *(_WORD *)(v13 + 36) = 0;
        goto LABEL_49;
      }
      goto LABEL_49;
    }
    if (v16 == 35)
    {
      if (a3)
      {
        uint64_t PhraseBoundFromString = mosyntutils_CheckSkipCharInString(a1, a4, a5, &v34, 0x23u);
        if ((PhraseBoundFromString & 0x80000000) != 0) {
          return PhraseBoundFromString;
        }
        int v19 = 1;
LABEL_22:
        HIDWORD(v32) = v19;
      }
      else
      {
        uint64_t PhraseBoundFromString = mosyntknowl_GetPhraseBoundFromString(a1, a4, a5, &v34, (_DWORD *)&v32 + 1);
        if ((PhraseBoundFromString & 0x80000000) != 0) {
          return PhraseBoundFromString;
        }
        LOWORD(v19) = WORD2(v32);
        if (!HIDWORD(v32))
        {
          if (v17 && *(unsigned char *)(v17 + 20) && *(_DWORD *)(v17 + 24) == 3 && !*(_DWORD *)(v17 + 32))
          {
            LOWORD(v19) = 0;
            *(_DWORD *)(v17 + 32) = 2;
            if (!v15) {
              goto LABEL_43;
            }
            goto LABEL_42;
          }
          LOWORD(v19) = 0;
LABEL_41:
          if (!v15)
          {
LABEL_43:
            uint64_t v13 = v35;
            if (v35 && *(unsigned char *)(v35 + 20) && *(_DWORD *)(v35 + 24) == 2)
            {
              uint64_t PhraseTypeFromString = 0;
              uint64_t v15 = 0;
              *(_DWORD *)(v35 + 24) = 3;
              *(_WORD *)(v13 + 28) = v19;
              uint64_t v17 = v13;
              *(_DWORD *)(v13 + 32) = 0;
            }
            else
            {
              uint64_t PhraseTypeFromString = mosyntdata_AddPhonEle(a1, a8, &v35, 1, 0);
              if ((PhraseTypeFromString & 0x80000000) != 0) {
                return PhraseTypeFromString;
              }
              uint64_t v15 = 0;
              uint64_t v13 = v35;
              *(unsigned char *)(v35 + 20) = 1;
              *(_DWORD *)(v13 + 24) = 3;
              *(_WORD *)(v13 + 28) = v19;
              *(_DWORD *)(v13 + 32) = 0;
              *(_WORD *)(v13 + 36) = 0;
              uint64_t v17 = v13;
            }
            goto LABEL_49;
          }
LABEL_42:
          *(_WORD *)(v15 + 36) = 1;
          goto LABEL_43;
        }
      }
      if (v17 && *(unsigned char *)(v17 + 20) && *(_DWORD *)(v17 + 24) == 3 && !*(_DWORD *)(v17 + 32))
      {
        *(_DWORD *)(v17 + 32) = 1;
        if (!v15) {
          goto LABEL_43;
        }
        goto LABEL_42;
      }
      goto LABEL_41;
    }
    if (!v16) {
      break;
    }
    if (a3 && v16 == 47)
    {
      uint64_t PhraseBoundFromString = mosyntutils_CheckSkipCharInString(a1, a4, a5, &v34, 0x2Fu);
      if ((PhraseBoundFromString & 0x80000000) != 0) {
        return PhraseBoundFromString;
      }
      int v19 = 2;
      goto LABEL_22;
    }
    if (v16 == 91)
    {
      if (a3)
      {
LABEL_56:
        uint64_t PhraseBoundFromString = mosyntutils_CheckSkipCharInString(a1, a4, a5, &v34, 0x27u);
        if ((PhraseBoundFromString & 0x80000000) != 0) {
          return PhraseBoundFromString;
        }
        if (*a6 && a6[v14] == 49) {
          int v21 = 3;
        }
        else {
          int v21 = 2;
        }
        LODWORD(v32) = v21;
        if (v34 < a5 && a4[v34] == 50)
        {
          uint64_t PhraseBoundFromString = mosyntutils_CheckSkipCharInString(a1, a4, a5, &v34, 0x32u);
          if ((PhraseBoundFromString & 0x80000000) != 0) {
            return PhraseBoundFromString;
          }
          int v21 = 4;
          LODWORD(v32) = 4;
        }
      }
      else
      {
        uint64_t PhraseBoundFromString = mosyntknowl_GetAccentFromString(a1, a4, a5, &v34, &v32);
        if ((PhraseBoundFromString & 0x80000000) != 0) {
          return PhraseBoundFromString;
        }
        int v21 = v32;
      }
      if (v13 && *(unsigned char *)(v13 + 20)) {
        *(_WORD *)(v13 + 36) = v21;
      }
      uint64_t PhraseTypeFromString = 0;
      if (v21 == 2) {
        uint64_t v15 = v13;
      }
      goto LABEL_49;
    }
    if (v16 == 40)
    {
      uint64_t PhraseTypeFromString = mosyntknowl_GetPhraseTypeFromString(a1, a4, a5, &v34, &v31);
      if ((PhraseTypeFromString & 0x80000000) != 0) {
        return PhraseTypeFromString;
      }
      if (v17) {
        *(_DWORD *)(v17 + 32) = v31;
      }
    }
    else
    {
      if (a3 && v16 == 39) {
        goto LABEL_56;
      }
      if (a3) {
        BOOL v22 = v16 == 46;
      }
      else {
        BOOL v22 = 0;
      }
      int v23 = v22;
      if (v16 == 45 || v23)
      {
        if (a3) {
          unsigned __int8 v24 = 46;
        }
        else {
          unsigned __int8 v24 = 45;
        }
        uint64_t PhraseBoundFromString = mosyntutils_CheckSkipCharInString(a1, a4, a5, &v34, v24);
        if ((PhraseBoundFromString & 0x80000000) != 0) {
          return PhraseBoundFromString;
        }
        uint64_t PhraseTypeFromString = mosyntdata_AddPhonEle(a1, a8, &v35, 1, 0);
        if ((PhraseTypeFromString & 0x80000000) != 0) {
          return PhraseTypeFromString;
        }
        uint64_t v13 = v35;
        int v20 = 1;
        *(unsigned char *)(v35 + 20) = 1;
        goto LABEL_18;
      }
      uint64_t PhraseTypeFromString = mosyntknowl_GetPhoneFromString(a1, a2, a4, a5, &v34, &v33);
      if ((PhraseTypeFromString & 0x80000000) != 0) {
        return PhraseTypeFromString;
      }
      if (v33 <= 0)
      {
        int v25 = mosyntkbsymtab_KnownPhonId(a1, a2, (uint64_t)"{VOC}");
        int v33 = v25;
        if (v25 >= 1)
        {
          uint64_t PhraseTypeFromString = mosyntdata_AddPhonEle(a1, a8, &v35, 1, v25);
          if ((PhraseTypeFromString & 0x80000000) != 0) {
            return PhraseTypeFromString;
          }
          *(_WORD *)(v35 + 26) = a4[v14];
        }
        int v34 = v14 + 1;
      }
      else
      {
        uint64_t PhraseTypeFromString = mosyntdata_AddPhonEle(a1, a8, &v35, 1, v33);
        if ((PhraseTypeFromString & 0x80000000) != 0) {
          return PhraseTypeFromString;
        }
      }
    }
LABEL_49:
    int v16 = 0;
    int v14 = v34;
    if (v34 < a5) {
      int v16 = a4[v34];
    }
  }
  if (a3)
  {
    if (v17 && *(unsigned char *)(v17 + 20) && *(_DWORD *)(v17 + 24) == 3 && !*(_DWORD *)(v17 + 32)) {
      *(_DWORD *)(v17 + 32) = 2;
    }
    if (v15) {
      *(_WORD *)(v15 + 36) = 1;
    }
    uint64_t PhraseTypeFromString = mosyntdata_AddPhonEle(a1, a8, &v35, 1, 0);
    if ((PhraseTypeFromString & 0x80000000) == 0)
    {
      uint64_t v27 = v35;
      *(unsigned char *)(v35 + 20) = 1;
      *(_DWORD *)(v27 + 24) = 3;
      *(_WORD *)(v27 + 28) = 0;
      *(_DWORD *)(v27 + 32) = 0;
      *(_WORD *)(v27 + 36) = 0;
    }
  }
  return PhraseTypeFromString;
}

uint64_t mosyntdata_NewCommand(uint64_t a1, uint64_t *a2)
{
  uint64_t result = mosyntpal_ALLOCATE(a1, a2, 0x88u);
  if ((result & 0x80000000) == 0)
  {
    *(void *)*a2 = 0;
    uint64_t v4 = *a2;
    *(void *)(v4 + 20) = 0;
    *(void *)(v4 + 12) = 0;
    *(unsigned char *)(v4 + 36) = 0;
    *(void *)(v4 + 28) = 0;
  }
  return result;
}

uint64_t mosyntdata_GetPunctFromCommandList(uint64_t a1, uint64_t *a2, _DWORD *a3, void *a4)
{
  if (a2)
  {
    while (*((_DWORD *)a2 + 2))
    {
      a2 = (uint64_t *)*a2;
      if (!a2) {
        goto LABEL_4;
      }
    }
    int v4 = *((_DWORD *)a2 + 3);
  }
  else
  {
LABEL_4:
    int v4 = 0;
  }
  *a3 = v4;
  *a4 = a2;
  return 0;
}

uint64_t mosyntdata_DisposeCommandList(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    while (1)
    {
      int v6 = v3;
      uint64_t v3 = (void *)*v3;
      uint64_t result = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v6);
      if ((result & 0x80000000) != 0) {
        break;
      }
      if (!v3) {
        goto LABEL_6;
      }
    }
  }
  else
  {
    uint64_t result = 0;
LABEL_6:
    *a2 = 0;
  }
  return result;
}

uint64_t mosyntdata_WriteCommandList(uint64_t a1, uint64_t *a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v8 = 0;
  uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v8, 0x3E8u);
  if ((result & 0x80000000) == 0)
  {
    int v9 = 0;
    *uint64_t v8 = 0;
    int v5 = v8;
    if (a2)
    {
      BOOL v10 = 0;
      memset(v11, 0, sizeof(v11));
      int v12 = 0;
      while (1)
      {
        uint64_t result = mosyntbase_CApp((uint64_t)v5, 1000, &v9, "<", 0, &v10);
        if ((result & 0x80000000) != 0) {
          break;
        }
        switch(*((_DWORD *)a2 + 2))
        {
          case 0:
            uint64_t v6 = (uint64_t)v5;
            uint64_t v7 = "PUNCT";
            break;
          case 1:
            uint64_t v6 = (uint64_t)v5;
            uint64_t v7 = "SPEED";
            break;
          case 2:
            uint64_t v6 = (uint64_t)v5;
            uint64_t v7 = "PITCH";
            break;
          case 3:
            uint64_t v6 = (uint64_t)v5;
            uint64_t v7 = "VOLUME";
            break;
          case 4:
            uint64_t v6 = (uint64_t)v5;
            uint64_t v7 = "SYMBOLICSIL";
            break;
          case 5:
            uint64_t v6 = (uint64_t)v5;
            uint64_t v7 = "PROSDOMAIN";
            break;
          default:
            uint64_t v6 = (uint64_t)v5;
            uint64_t v7 = "?XXX;";
            break;
        }
        uint64_t result = mosyntbase_CApp(v6, 1000, &v9, (unsigned __int8 *)v7, 0, &v10);
        if ((result & 0x80000000) != 0) {
          break;
        }
        uint64_t result = mosyntbase_CApp((uint64_t)v5, 1000, &v9, ";", 0, &v10);
        if ((result & 0x80000000) != 0) {
          break;
        }
        uint64_t result = mosyntpal_IntToString(*((_DWORD *)a2 + 3), 0, v11, 100);
        if ((result & 0x80000000) != 0) {
          break;
        }
        uint64_t result = mosyntbase_CApp((uint64_t)v5, 1000, &v9, (unsigned __int8 *)v11, 100, &v10);
        if ((result & 0x80000000) != 0) {
          break;
        }
        uint64_t result = mosyntbase_CApp((uint64_t)v5, 1000, &v9, ";", 0, &v10);
        if ((result & 0x80000000) != 0) {
          break;
        }
        uint64_t result = mosyntbase_CApp((uint64_t)v5, 1000, &v9, (unsigned __int8 *)a2 + 36, 100, &v10);
        if ((result & 0x80000000) != 0) {
          break;
        }
        uint64_t result = mosyntbase_CApp((uint64_t)v5, 1000, &v9, ">", 0, &v10);
        if ((result & 0x80000000) != 0) {
          break;
        }
        a2 = (uint64_t *)*a2;
        if (!a2)
        {
          int v5 = v8;
          goto LABEL_22;
        }
      }
    }
    else
    {
LABEL_22:
      uint64_t result = mosyntbase_WString(a1, v5, 1000);
      if ((result & 0x80000000) == 0) {
        return mosyntpal_DEALLOCATE(a1, (uint64_t *)&v8);
      }
    }
  }
  return result;
}

uint64_t mosyntdata_GetNilLexItem(uint64_t a1)
{
  uint64_t result = mosyntkblex_GetNilEntry();
  if ((result & 0x80000000) == 0) {
    *(_DWORD *)(a1 + 24) = 0;
  }
  return result;
}

BOOL mosyntdata_IsValidLexItem(uint64_t a1)
{
  return *(_DWORD *)(a1 + 24) && mosyntkblex_IsValidEntry() != 0;
}

BOOL mosyntdata_IdenticalLexItems(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 24) == *(_DWORD *)(a2 + 24) && mosyntkblex_IdenticalEntries() != 0;
}

uint64_t mosyntdata_GetFirstLexItem(uint64_t a1, uint64_t *a2, long long *a3, uint64_t a4, int a5, int *a6, unsigned char *a7, uint64_t a8)
{
  *a6 = 0;
  return mosyntdata_GetNextLexItem(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t mosyntdata_GetNextLexItem(uint64_t a1, uint64_t *a2, long long *a3, uint64_t a4, int a5, int *a6, unsigned char *a7, uint64_t a8)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  *a7 = 0;
  uint64_t NilEntry = mosyntkblex_GetNilEntry(a8);
  if ((NilEntry & 0x80000000) != 0) {
    return NilEntry;
  }
  BOOL v22 = 0;
  memset(v23, 0, sizeof(v23));
  uint64_t v24 = 0;
  *(_DWORD *)(a8 + 24) = 0;
  uint64_t v17 = (int *)(a8 + 24);
  SepPartunsigned int Str = mosyntbase_GetSepPartStr(a4, a5, a6, 0x5Cu, v23, 200, (char *)&v22);
  if ((SepPartStr & 0x80000000) == 0)
  {
    if (!v22)
    {
      int *v17 = 0;
      return SepPartStr;
    }
    if (LOBYTE(v23[0]) - 48 > 9)
    {
      SepPartunsigned int Str = mosyntkbsymtab_ConsFeatToComprConsFeatStr((uint64_t)v23, 200);
      if ((SepPartStr & 0x80000000) != 0) {
        return SepPartStr;
      }
      int v19 = mosyntkbsymtab_KnownConsId(a1, a2, (uint64_t)v23);
      int *v17 = v19;
    }
    else
    {
      SepPartunsigned int Str = mosyntpal_StringToInt((uint64_t)v23, 200, (int *)(a8 + 24), &v22);
      if ((SepPartStr & 0x80000000) != 0) {
        return SepPartStr;
      }
      int v19 = *v17;
    }
    if (v19 >= 1)
    {
      long long v20 = *a3;
      *(void *)(a8 + 16) = *((void *)a3 + 2);
      *(_OWORD *)a8 = v20;
      *a7 = 1;
    }
  }
  return SepPartStr;
}

uint64_t mosyntdata_SetLexEleRefCounts(uint64_t a1, void *a2)
{
  if (a2)
  {
    char v2 = a2;
    do
    {
      for (int i = (uint64_t *)v2[2]; i; int i = (uint64_t *)*i)
        *((_DWORD *)i + 12) = 0;
      char v2 = (void *)*v2;
    }
    while (v2);
    do
    {
      int v4 = (uint64_t *)a2[2];
      if (v4)
      {
        while (1)
        {
          int v5 = *((_DWORD *)v4 + 12);
          if (v5) {
            break;
          }
          *((_DWORD *)v4 + 12) = 1;
          int v4 = (uint64_t *)*v4;
          if (!v4) {
            goto LABEL_11;
          }
        }
        *((_DWORD *)v4 + 12) = v5 + 1;
      }
LABEL_11:
      a2 = (void *)*a2;
    }
    while (a2);
  }
  return 0;
}

uint64_t mosyntdata_PruneLexEleBranch(uint64_t a1, uint64_t *a2)
{
  uint64_t result = 0;
  uint64_t v4 = *a2;
  do
  {
    uint64_t v5 = v4;
    if (!v4) {
      break;
    }
    if (*(_DWORD *)(v4 + 48) != 1)
    {
      --*(_DWORD *)(v4 + 48);
      return result;
    }
    uint64_t v4 = *(void *)v4;
    uint64_t result = mosyntpal_DEALLOCATE(a1, &v5);
  }
  while ((result & 0x80000000) == 0);
  return result;
}

uint64_t RemoveInitSubstr(uint64_t a1, uint64_t a2, int a3)
{
  int v9 = 0;
  char v8 = 0;
  uint64_t result = mosyntbase_FindSubstring(a1, 10, a2, a3, 0, &v9);
  if ((result & 0x80000000) == 0 && !v9)
  {
    int v7 = mosyntbase_Length(a1, 10);
    return mosyntbase_RemoveSubstring(0, v7, a2, a3, &v8);
  }
  return result;
}

uint64_t mosyntdata_LexEleListToPhonString(uint64_t a1, uint64_t *a2, unsigned int a3, void *a4, uint64_t a5, int a6)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  memset(v24, 0, 512);
  memset(v23, 0, sizeof(v23));
  memset(v22, 0, sizeof(v22));
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  __int16 v21 = 0;
  BOOL v17 = 0;
  int v18 = 0;
  uint64_t result = mosyntkbsymtab_DecompressCons(a1, a2, a3, &v19, (__int16 *)v22);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = AppAddPhonString(a1, a2, v19, (__int16 *)v22, 1, a5, a6, &v18);
    if ((result & 0x80000000) == 0)
    {
      if (a4)
      {
        int v12 = 0;
        do
        {
          uint64_t v13 = v12;
          int v12 = a4;
          a4 = (void *)*a4;
          *int v12 = v13;
        }
        while (a4);
        int v14 = v12;
        while (1)
        {
          uint64_t result = mosyntkbsymtab_DecompressCons(a1, a2, *((_DWORD *)v14 + 8), (_DWORD *)&v19 + 1, (__int16 *)v23);
          if ((result & 0x80000000) != 0) {
            break;
          }
          uint64_t result = AppAddPhonString(a1, a2, SHIDWORD(v19), (__int16 *)v23, 1, a5, a6, &v18);
          if ((result & 0x80000000) != 0) {
            break;
          }
          uint64_t result = mosyntkblex_GetEntryPhon(a1, v14 + 1, v24, 1000);
          if ((result & 0x80000000) != 0) {
            break;
          }
          m2__cp__str("[SVOX]", &v20, 10);
          uint64_t result = RemoveInitSubstr((uint64_t)&v20, (uint64_t)v24, 1000);
          if ((result & 0x80000000) != 0) {
            break;
          }
          uint64_t result = mosyntbase_App(a5, a6, &v18, (uint64_t)v24, 1000, &v17);
          if ((result & 0x80000000) != 0) {
            break;
          }
          uint64_t result = AppAddPhonString(a1, a2, SHIDWORD(v19), (__int16 *)v23, 0, a5, a6, &v18);
          if ((result & 0x80000000) != 0) {
            break;
          }
          int v14 = (void *)*v14;
          if (!v14)
          {
            uint64_t v15 = 0;
            do
            {
              int v16 = v12;
              int v12 = (void *)*v12;
              *int v16 = v15;
              uint64_t v15 = v16;
            }
            while (v12);
            return AppAddPhonString(a1, a2, v19, (__int16 *)v22, 0, a5, a6, &v18);
          }
        }
      }
      else
      {
        return AppAddPhonString(a1, a2, v19, (__int16 *)v22, 0, a5, a6, &v18);
      }
    }
  }
  return result;
}

uint64_t AppAddPhonString(uint64_t a1, uint64_t *a2, int a3, __int16 *a4, int a5, uint64_t a6, int a7, int *a8)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  v16[1] = 0;
  uint64_t v17 = 0;
  v16[0] = 0;
  memset(v15, 0, sizeof(v15));
  int v19 = 0;
  memset(v18, 0, sizeof(v18));
  BOOL v14 = 0;
  for (uint64_t result = GetFirstAddPhon(a1, (uint64_t)a2, a5, a3, a4, v16, (uint64_t)v15, (int *)&v17 + 1);
        (result & 0x80000000) == 0;
        uint64_t result = mosyntkbsymtab_GetFeatMatchedNextIntPropVal((uint64_t)v16, (uint64_t)v15, (int *)&v17 + 1))
  {
    if (v17 < 0) {
      break;
    }
    uint64_t result = mosyntkbsymtab_PhonSymString(a1, a2, HIDWORD(v17), (char *)v18, 100);
    if ((result & 0x80000000) != 0) {
      break;
    }
    uint64_t result = mosyntbase_App(a6, a7, a8, (uint64_t)v18, 100, &v14);
    if ((result & 0x80000000) != 0) {
      break;
    }
  }
  return result;
}

uint64_t mosyntdata_WriteReadingList(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(a3 + 16);
  if (!v3) {
    return 0;
  }
  do
  {
    unsigned int v8 = *(_DWORD *)(a3 + 4);
    unsigned int v7 = *(_DWORD *)(a3 + 8);
    uint64_t v9 = *(void *)(a3 + 16);
    uint64_t result = mosyntknowl_WriteTraceHeader(a1, 1u);
    if ((result & 0x80000000) != 0) {
      break;
    }
    uint64_t result = mosyntbase_WString(a1, "reading from pos ", 0);
    if ((result & 0x80000000) != 0) {
      break;
    }
    uint64_t result = mosyntbase_WInt(a1, v8, 0);
    if ((result & 0x80000000) != 0) {
      break;
    }
    uint64_t result = mosyntbase_WString(a1, " to pos ", 0);
    if ((result & 0x80000000) != 0) {
      break;
    }
    uint64_t result = mosyntbase_WInt(a1, v7, 0);
    if ((result & 0x80000000) != 0) {
      break;
    }
    uint64_t result = mosyntbase_WString(a1, ": ", 0);
    if ((result & 0x80000000) != 0) {
      break;
    }
    uint64_t result = mosyntkbsymtab_WriteCons(a1, a2, *(_DWORD *)(v9 + 8));
    if ((result & 0x80000000) != 0) {
      break;
    }
    uint64_t result = mosyntbase_WString(a1, " cost ", 0);
    if ((result & 0x80000000) != 0) {
      break;
    }
    uint64_t result = mosyntbase_WInt(a1, *(_DWORD *)(v9 + 12), 0);
    if ((result & 0x80000000) != 0) {
      break;
    }
    uint64_t result = mosyntbase_WString(a1, "  ", 0);
    if ((result & 0x80000000) != 0) {
      break;
    }
    uint64_t result = WriteLexEleList(a1, *(void **)(v9 + 16));
    if ((result & 0x80000000) != 0) {
      break;
    }
    uint64_t result = mosyntbase_WLn(a1);
    if ((result & 0x80000000) != 0) {
      break;
    }
    uint64_t v3 = (void *)*v3;
  }
  while (v3);
  return result;
}

double mosyntdata_NewTermInfo(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  if ((mosyntpal_ALLOCATE(a1, a3, 0x30u) & 0x80000000) == 0)
  {
    *(void *)*a3 = a2;
    uint64_t v6 = (void *)*a3;
    *((_DWORD *)v6 + 2) = -1;
    unsigned char v6[2] = 0;
    unsigned int v7 = (void *)*a3;
    double result = NAN;
    v7[3] = 0xFFFFFFFF00000000;
    v7[4] = 0;
    *(void *)(*a3 + 40) = 0xFFFFFFFF00000000;
  }
  return result;
}

uint64_t mosyntdata_DisposeTermInfo(uint64_t a1, uint64_t *a2)
{
  if (!*a2) {
    return 0;
  }
  uint64_t v4 = *(void *)*a2;
  if (!v4
    || (uint64_t result = mosyntdata_PruneLexEleBranch(a1, (uint64_t *)(v4 + 16)), (result & 0x80000000) == 0)
    && (uint64_t result = mosyntpal_DEALLOCATE(a1, (uint64_t *)*a2), (result & 0x80000000) == 0))
  {
    return mosyntpal_DEALLOCATE(a1, a2);
  }
  return result;
}

double mosyntdata_CopyTermInfo(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  if (!a2)
  {
    *a3 = 0;
    return result;
  }
  if ((mosyntpal_ALLOCATE(a1, a3, 0x30u) & 0x80000000) != 0) {
    return result;
  }
  uint64_t v7 = *a2;
  unsigned int v8 = (uint64_t *)*a3;
  *(void *)*a3 = 0;
  if (!v7) {
    goto LABEL_17;
  }
  uint64_t v17 = 0;
  uint64_t v9 = *(uint64_t **)(v7 + 16);
  if (v9)
  {
    BOOL v10 = 0;
    unsigned int v11 = 0;
    while ((mosyntpal_ALLOCATE(a1, (uint64_t *)&v17, 0x38u) & 0x80000000) == 0)
    {
      void *v17 = 0;
      int v12 = v17;
      if (v10)
      {
        *BOOL v10 = v17;
        int v12 = v17;
      }
      else
      {
        unsigned int v11 = v17;
      }
      long long v13 = *(_OWORD *)(v9 + 1);
      *(_OWORD *)(v12 + 3) = *(_OWORD *)(v9 + 3);
      *(_OWORD *)(v12 + 1) = v13;
      *((_WORD *)v12 + 20) = *((_WORD *)v9 + 20);
      *((_DWORD *)v12 + 12) = 1;
      uint64_t v9 = (uint64_t *)*v9;
      BOOL v10 = v12;
      if (!v9) {
        goto LABEL_15;
      }
    }
    return result;
  }
  unsigned int v11 = 0;
LABEL_15:
  if ((mosyntpal_ALLOCATE(a1, v8, 0x18u) & 0x80000000) == 0)
  {
    *(void *)*unsigned int v8 = 0;
    BOOL v14 = (void *)*v8;
    v14[1] = *(void *)(v7 + 8);
    v14[2] = v11;
LABEL_17:
    uint64_t v15 = *a3;
    *(_DWORD *)(v15 + 8) = *((_DWORD *)a2 + 2);
    *(void *)(v15 + 16) = a2[2];
    uint64_t v16 = *a3;
    *(void *)(v16 + 24) = a2[3];
    *(void *)(v16 + 32) = a2[4];
    double result = *((double *)a2 + 5);
    *(double *)(*a3 + 40) = result;
  }
  return result;
}

__n128 mosyntdata_NewSyntNode(uint64_t a1, __int16 a2, __n128 *a3, uint64_t *a4)
{
  if ((mosyntpal_ALLOCATE(a1, a4, 0x48u) & 0x80000000) == 0)
  {
    *(void *)*a4 = 0;
    *(void *)(*a4 + 8) = 0;
    uint64_t v8 = *a4;
    *(_WORD *)(v8 + 16) = a2;
    __n128 result = *a3;
    *(void *)(v8 + 40) = a3[1].n128_u64[0];
    *(__n128 *)(v8 + 24) = result;
    uint64_t v9 = (void *)*a4;
    v9[8] = 0;
    *(void *)((char *)v9 + 53) = 0;
    v9[6] = 0;
  }
  return result;
}

uint64_t mosyntdata_AppendNode(uint64_t a1, void *a2, void **a3, int a4, void *a5)
{
  if (a5)
  {
    if (a4)
    {
      uint64_t v5 = *a3;
      if (!*a3) {
        uint64_t v5 = a2;
      }
      *uint64_t v5 = a5;
      goto LABEL_7;
    }
    *a5 = *a2;
    *a2 = a5;
    if (!*a3) {
LABEL_7:
    }
      *a3 = a5;
  }
  return 0;
}

void mosyntdata_AddNode(uint64_t a1, void *a2, void **a3, int a4, __int16 a5, __n128 *a6)
{
  int v12 = 0;
  mosyntdata_NewSyntNode(a1, a5, a6, (uint64_t *)&v12);
  if ((v9 & 0x80000000) == 0)
  {
    BOOL v10 = v12;
    if (v12)
    {
      if (a4)
      {
        unsigned int v11 = *a3;
        if (!*a3) {
          unsigned int v11 = a2;
        }
        *unsigned int v11 = v12;
        goto LABEL_9;
      }
      *int v12 = *a2;
      *a2 = v10;
      if (!*a3) {
LABEL_9:
      }
        *a3 = v10;
    }
  }
}

uint64_t DisposeSyntTreeList(uint64_t a1, void **a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    int v9 = 0;
    while (1)
    {
      uint64_t result = DisposeSyntTreeList(a1, v3 + 1);
      if ((result & 0x80000000) != 0) {
        break;
      }
      int v9 = v3;
      uint64_t v6 = (void *)*v3;
      uint64_t v8 = v3[8];
      uint64_t v7 = v3 + 8;
      if (v8)
      {
        uint64_t result = mosyntdata_DisposeTermInfo(a1, v7);
        if ((result & 0x80000000) != 0) {
          break;
        }
      }
      uint64_t result = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v9);
      if ((result & 0x80000000) != 0) {
        break;
      }
      uint64_t v3 = v6;
      if (!v6) {
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t result = 0;
LABEL_10:
    *a2 = 0;
  }
  return result;
}

uint64_t mosyntdata_WriteReadingStruct(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  if (!a4) {
    return 0;
  }
  uint64_t result = mosyntknowl_WriteTraceHeader(a1, a3);
  if ((result & 0x80000000) == 0)
  {
    if (a5 < 1)
    {
LABEL_7:
      int v14 = 0;
      memset(v13, 0, sizeof(v13));
      int v12 = 0;
      uint64_t result = mosyntkbsymtab_AppDecomprConsToString(a1, a2, *(_DWORD *)(a4 + 8), (uint64_t)v13, 100, &v12);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = mosyntbase_WString(a1, (unsigned __int8 *)v13, 100);
        if ((result & 0x80000000) == 0)
        {
          uint64_t result = mosyntbase_WString(a1, "  ", 0);
          if ((result & 0x80000000) == 0)
          {
            uint64_t result = mosyntbase_WInt(a1, *(_DWORD *)(a4 + 12), 0);
            if ((result & 0x80000000) == 0)
            {
              uint64_t result = mosyntbase_WLn(a1);
              if ((result & 0x80000000) == 0)
              {
                uint64_t result = mosyntbase_WLn(a1);
                if ((result & 0x80000000) == 0) {
                  return WriteLexConsList(a1, a2, a3, *(void *)(a4 + 16), a5 + 2);
                }
              }
            }
          }
        }
      }
    }
    else
    {
      int v11 = a5;
      while (1)
      {
        uint64_t result = mosyntbase_WString(a1, " ", 0);
        if ((result & 0x80000000) != 0) {
          break;
        }
        if (!--v11) {
          goto LABEL_7;
        }
      }
    }
  }
  return result;
}

uint64_t WriteLexConsList(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  if (!a4) {
    return 0;
  }
  unsigned int v7 = a3;
  uint64_t result = WriteLexConsList(a1, a2, a3, *(void *)a4);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = mosyntknowl_WriteTraceHeader(a1, v7);
    if ((result & 0x80000000) == 0)
    {
      if (a5 < 1)
      {
LABEL_7:
        uint64_t v11 = 0;
        memset(v12, 0, sizeof(v12));
        memset(v13, 0, sizeof(v13));
        uint64_t v14 = 0;
        if (*(_DWORD *)(a4 + 32) && mosyntkblex_IsValidEntry(a4 + 8))
        {
          uint64_t result = mosyntkbsymtab_DecompressCons(a1, a2, *(_DWORD *)(a4 + 32), &v11, (__int16 *)v12);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t result = mosyntkbsymtab_WriteConsAndFeat(a1, a2, v11, (__int16 *)v12);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t result = mosyntbase_WString(a1, " ", 0);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t result = mosyntkblex_GetEntryGraph(a1, a4 + 8, v13, 200);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t result = mosyntbase_WString(a1, (unsigned __int8 *)v13, 200);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t result = mosyntbase_WString(a1, "  [", 0);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t result = mosyntkblex_GetEntryPhon(a1, a4 + 8, v13, 200);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t result = mosyntbase_WString(a1, (unsigned __int8 *)v13, 200);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t result = mosyntbase_WString(a1, "]  ", 0);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t result = mosyntkblex_GetEntryCost(a1, a4 + 8, (char *)&v11 + 4);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t result = mosyntbase_WInt(a1, HIDWORD(v11), 0);
          if ((result & 0x80000000) != 0) {
            return result;
          }
        }
        else
        {
          uint64_t result = mosyntbase_WString(a1, "NIL", 0);
          if ((result & 0x80000000) != 0) {
            return result;
          }
        }
        uint64_t result = mosyntbase_WLn(a1);
        if ((result & 0x80000000) == 0) {
          return mosyntbase_WLn(a1);
        }
        return result;
      }
      while (1)
      {
        uint64_t result = mosyntbase_WString(a1, " ", 0);
        if ((result & 0x80000000) != 0) {
          break;
        }
        if (!--a5) {
          goto LABEL_7;
        }
      }
    }
  }
  return result;
}

uint64_t mosyntdata_WriteTree(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t *a4)
{
  return WriteTree1(a1, a2, a3, a4, 0);
}

uint64_t WriteTree1(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t *a4, int a5)
{
  if (!a4) {
    return 0;
  }
  uint64_t v6 = a4;
  uint64_t v10 = (a5 + 2);
  while (1)
  {
    uint64_t result = mosyntknowl_WriteTraceHeader(a1, a3);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    int v12 = a5;
    if (a5 >= 1)
    {
      do
      {
        uint64_t result = mosyntbase_WString(a1, " ", 0);
        if ((result & 0x80000000) != 0) {
          return result;
        }
      }
      while (--v12);
    }
    uint64_t result = mosyntkbsymtab_WriteConsAndFeat(a1, a2, *((__int16 *)v6 + 8), (__int16 *)v6 + 12);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    uint64_t result = mosyntbase_WString(a1, "  ", 0);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    uint64_t result = mosyntbase_WInt(a1, *((_DWORD *)v6 + 12), 0);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    if (*((unsigned char *)v6 + 60))
    {
      uint64_t result = mosyntbase_WString(a1, "  @@", 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntbase_WLn(a1);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntbase_WLn(a1);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t v13 = v6[8];
      if (v13)
      {
        uint64_t result = WriteTermInfo(a1, a2, a3, v13, v10);
        if ((result & 0x80000000) != 0) {
          return result;
        }
      }
    }
    else
    {
      uint64_t result = mosyntbase_WLn(a1);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t result = mosyntbase_WLn(a1);
      if ((result & 0x80000000) != 0) {
        return result;
      }
    }
    uint64_t result = WriteTree1(a1, a2, a3, v6[1], v10);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    uint64_t v6 = (uint64_t *)*v6;
    if (!v6) {
      return 0;
    }
  }
}

uint64_t mosyntdata_EncodeSymbolicValue(uint64_t a1, int a2, int a3, _DWORD *a4)
{
  if (a3) {
    int v4 = -2147482647;
  }
  else {
    int v4 = -2147481647;
  }
  *a4 = v4 - a2;
  return 0;
}

uint64_t mosyntdata_AppendItem(uint64_t a1, void *a2, void **a3, void *a4)
{
  if (a4)
  {
    *a4 = 0;
    int v4 = *a3;
    if (!*a3) {
      int v4 = a2;
    }
    void *v4 = a4;
    *a3 = a4;
  }
  return 0;
}

uint64_t mosyntdata_DisposeItem(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (!*a2) {
    return 0;
  }
  if (*(_DWORD *)(v2 + 8)) {
    return mosyntpal_DEALLOCATE(a1, a2);
  }
  mosyntdata_SetLexEleRefCounts(a1, *(void **)(v2 + 32));
  uint64_t v5 = *(void **)(v2 + 32);
  if (!v5)
  {
LABEL_8:
    *(void *)(v2 + 32) = 0;
    return mosyntpal_DEALLOCATE(a1, a2);
  }
  unsigned int v7 = 0;
  while (1)
  {
    uint64_t result = mosyntdata_PruneLexEleBranch(a1, v5 + 2);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    unsigned int v7 = v5;
    uint64_t v5 = (void *)*v5;
    uint64_t result = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v7);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    if (!v5) {
      goto LABEL_8;
    }
  }
}

uint64_t mosyntdata_AddOutItem(uint64_t a1, void *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v26 = 0;
  uint64_t result = mosyntpal_ALLOCATE(a1, &v26, 0x28u);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  *(void *)uint64_t v26 = 0;
  uint64_t v9 = v26;
  *(_DWORD *)(v26 + 8) = *(_DWORD *)(a4 + 8);
  if (*(_DWORD *)(a4 + 8)) {
    goto LABEL_32;
  }
  long long v10 = *(_OWORD *)(a4 + 16);
  *(void *)(v9 + 32) = *(void *)(a4 + 32);
  *(_OWORD *)(v9 + 16) = v10;
  uint64_t v11 = *(void **)(a4 + 32);
  if (!v11) {
    goto LABEL_30;
  }
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  do
  {
    for (int i = (void *)v11[2]; i; int i = (void *)*i)
      i[6] = 0;
    uint64_t v11 = (void *)*v11;
  }
  while (v11);
  uint64_t v13 = *(void **)(a4 + 32);
  if (!v13)
  {
LABEL_30:
    uint64_t result = 0;
    uint64_t v15 = 0;
    uint64_t v23 = v9;
LABEL_31:
    *(void *)(v9 + 32) = v15;
    uint64_t v9 = v23;
LABEL_32:
    *(void *)uint64_t v9 = 0;
    uint64_t v24 = v26;
    if (*a3)
    {
      *(void *)*a3 = v26;
      uint64_t v24 = v26;
    }
    else
    {
      *a2 = v26;
    }
    *a3 = v24;
    return result;
  }
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  while (1)
  {
    uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v28, 0x18u);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    *uint64_t v28 = 0;
    if (v14)
    {
      *uint64_t v14 = v28;
      uint64_t v14 = v28;
    }
    else
    {
      uint64_t v14 = v28;
      uint64_t v15 = v28;
    }
    v14[1] = v13[1];
    uint64_t v16 = (uint64_t *)v13[2];
    if (v16)
    {
      int v18 = v16 + 6;
      uint64_t v17 = v16[6];
      if (!v17)
      {
        uint64_t v25 = v15;
        int v19 = 0;
        while (1)
        {
          uint64_t result = mosyntpal_ALLOCATE(a1, &v27, 0x38u);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          uint64_t v20 = v27;
          long long v21 = *(_OWORD *)(v16 + 3);
          *(_OWORD *)(v27 + 8) = *(_OWORD *)(v16 + 1);
          *(_OWORD *)(v20 + 24) = v21;
          *(_WORD *)(v20 + 40) = *((_WORD *)v16 + 20);
          *(void *)uint64_t v20 = 0;
          if (v19)
          {
            *int v19 = v27;
            int v19 = (void *)v27;
          }
          else
          {
            int v19 = (void *)v27;
            uint64_t v17 = v27;
          }
          *int v18 = v19;
          uint64_t v16 = (uint64_t *)*v16;
          if (!v16) {
            goto LABEL_27;
          }
          int v18 = v16 + 6;
          uint64_t v22 = v16[6];
          if (v22)
          {
            if (v19) {
              *int v19 = v22;
            }
            else {
              uint64_t v17 = v16[6];
            }
LABEL_27:
            uint64_t v15 = v25;
            break;
          }
        }
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    v28[2] = v17;
    uint64_t v13 = (void *)*v13;
    if (!v13)
    {
      uint64_t v23 = v26;
      goto LABEL_31;
    }
  }
}

uint64_t GetFirstAddPhon(uint64_t a1, uint64_t a2, int a3, int a4, __int16 *a5, _WORD *a6, uint64_t a7, int *a8)
{
  *a6 = *a5;
  if (*a5 >= 1)
  {
    uint64_t v8 = 1;
    do
      a6[v8] = a5[v8];
    while (v8++ < *a5);
  }
  return mosyntkbsymtab_GetFeatMatchedFirstIntPropVal(a1, a2, a4, (uint64_t)a6, a3 == 0, a7, a8);
}

uint64_t mosyntdata_GenWordPhono(uint64_t a1, uint64_t a2, uint64_t *a3, int a4, uint64_t a5, __int16 a6, void *a7, uint64_t *a8)
{
  *a7 = 0;
  *a8 = 0;
  if (a3)
  {
    uint64_t v11 = a3;
    uint64_t v14 = 0;
    while (1)
    {
      if (*((unsigned char *)v11 + 20))
      {
        uint64_t v15 = mosyntbase_WriteDevelMessage(a1, "*** boundary detected in word phoneme list\\n", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, 0, 0, 0);
        goto LABEL_5;
      }
      int v16 = *((__int16 *)v11 + 12);
      if (mosyntkbsymtab_SyllSepId(a2) == v16)
      {
        uint64_t v14 = mosyntdata_AddPhonEle(a1, a7, a8, 1, 0);
        if ((v14 & 0x80000000) != 0) {
          return v14;
        }
        uint64_t v17 = *a8;
        *(unsigned char *)(v17 + 20) = 1;
        *(_DWORD *)(v17 + 24) = 1;
        *(_WORD *)(v17 + 28) = -1;
        *(_DWORD *)(v17 + 32) = 0;
        *(_WORD *)(v17 + 36) = 0;
        a5 = *a8;
        goto LABEL_18;
      }
      int v18 = *((__int16 *)v11 + 12);
      if (mosyntkbsymtab_PrimAccId(a2) == v18)
      {
        if (a5)
        {
          __int16 v19 = a4;
LABEL_17:
          *(_WORD *)(a5 + 36) = v19;
        }
      }
      else
      {
        int v20 = *((__int16 *)v11 + 12);
        if (mosyntkbsymtab_SecAccId(a2) != v20)
        {
          uint64_t v15 = mosyntdata_AddPhonEle(a1, a7, a8, 1, *((_WORD *)v11 + 12));
LABEL_5:
          uint64_t v14 = v15;
          if ((v15 & 0x80000000) != 0) {
            return v14;
          }
          goto LABEL_18;
        }
        if (a4 >= 1 && a5)
        {
          __int16 v19 = a6;
          goto LABEL_17;
        }
      }
LABEL_18:
      uint64_t v11 = (uint64_t *)*v11;
      if (!v11) {
        return v14;
      }
    }
  }
  return 0;
}

uint64_t mosyntdata_CreateAndInitSentTermData(uint64_t a1, uint64_t *a2)
{
  uint64_t result = mosyntpal_ALLOCATE(a1, a2, 0x13890u);
  if ((result & 0x80000000) == 0)
  {
    for (uint64_t i = 0; i != 80016; i += 16)
    {
      *(void *)(*a2 + i) = 0;
      *(void *)(*a2 + i + 8) = 0;
    }
  }
  return result;
}

uint64_t mosyntdata_DisposeSentTermData(uint64_t a1, uint64_t *a2)
{
  if (!*a2) {
    return 0;
  }
  uint64_t v4 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  do
  {
    uint64_t v5 = *a2;
    uint64_t v6 = *(void *)(*a2 + v4);
    uint64_t v12 = v6;
    if (v6)
    {
      uint64_t v8 = *(void *)(v6 + 8);
      unsigned int v7 = (void **)(v6 + 8);
      if (v8)
      {
        uint64_t result = mosyntdata_DisposePhonEleList(a1, v7);
        if ((result & 0x80000000) != 0) {
          return result;
        }
      }
      uint64_t result = mosyntpal_DEALLOCATE(a1, &v12);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t v5 = *a2;
    }
    long long v10 = *(void ***)(v5 + v4 + 8);
    uint64_t v11 = v10;
    if (v10)
    {
      if (*v10)
      {
        uint64_t result = mosyntdata_DisposeCommandList(a1, v10);
        if ((result & 0x80000000) != 0) {
          return result;
        }
      }
      uint64_t result = mosyntpal_DEALLOCATE(a1, (uint64_t *)&v11);
      if ((result & 0x80000000) != 0) {
        return result;
      }
    }
    v4 += 16;
  }
  while (v4 != 80016);
  return mosyntpal_DEALLOCATE(a1, a2);
}

double mosyntdata_AssertBoundPosData(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a2)
  {
    if (a3 < 0x1389)
    {
      uint64_t v4 = a2 + 16 * a3;
      uint64_t v6 = *(void *)(v4 + 8);
      uint64_t v5 = (void *)(v4 + 8);
      if (!v6)
      {
        uint64_t v9 = 0;
        if ((mosyntpal_ALLOCATE(a1, (uint64_t *)&v9, 0x10u) & 0x80000000) == 0)
        {
          unsigned int v7 = v9;
          *uint64_t v5 = v9;
          *unsigned int v7 = 0;
          *(void *)&double result = 0xFFFFFFFFLL;
          v9[1] = 0xFFFFFFFFLL;
        }
      }
    }
    else
    {
      LODWORD(v8) = 0;
      HIDWORD(v8) = a3;
      mosyntbase_WriteMessage(a1, "***** error in asserting word boundary pos; wrong pos: %d\\n",
        0,
        (unsigned __int8 *)&byte_20D5A22AE,
        0,
        (unsigned __int8 *)&byte_20D5A22AE,
        0,
        (unsigned __int8 *)&byte_20D5A22AE,
        v8);
    }
  }
  return result;
}

double mosyntdata_InsertSentTermWord(uint64_t a1, uint64_t a2, unsigned int a3, signed int a4, int a5, uint64_t a6)
{
  if (a2)
  {
    if (a3 > 0x1388 || a4 < (int)a3 || a4 >= 5001)
    {
      *((void *)&v17 + 1) = a4;
      LODWORD(v17) = 0;
      DWORD1(v17) = a3;
      mosyntbase_WriteMessage(a1, "***** error in word term insertion; wrong start/end pos: %d/%d\\n",
        0,
        (unsigned __int8 *)&byte_20D5A22AE,
        0,
        (unsigned __int8 *)&byte_20D5A22AE,
        0,
        (unsigned __int8 *)&byte_20D5A22AE,
        v17);
    }
    else
    {
      long long v10 = (void *)(a2 + 16 * a3);
      if (*v10)
      {
        *((void *)&v16 + 1) = a4;
        LODWORD(v16) = 0;
        DWORD1(v16) = a3;
        mosyntbase_WriteMessage(a1, "***** error in word term insertion; position %d already occupied\\n",
          0,
          (unsigned __int8 *)&byte_20D5A22AE,
          0,
          (unsigned __int8 *)&byte_20D5A22AE,
          0,
          (unsigned __int8 *)&byte_20D5A22AE,
          v16);
      }
      else
      {
        uint64_t v18 = 0;
        if ((mosyntpal_ALLOCATE(a1, &v18, 0x18u) & 0x80000000) == 0)
        {
          uint64_t v14 = v18;
          *long long v10 = v18;
          *(_DWORD *)uint64_t v14 = a5;
          *(_DWORD *)(v14 + 4) = a4;
          *(void *)(v14 + 8) = a6;
          *(_DWORD *)(v14 + 16) = 0;
          double result = mosyntdata_AssertBoundPosData(a1, a2, a3);
          if ((v15 & 0x80000000) == 0) {
            return mosyntdata_AssertBoundPosData(a1, a2, a4);
          }
        }
      }
    }
  }
  return result;
}

void mosyntdata_InsertSentTermPunct(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  if (a2)
  {
    mosyntdata_AssertBoundPosData(a1, a2, a3);
    if (a3 <= 0x1388 && (v8 & 0x80000000) == 0)
    {
      uint64_t v9 = *(void ***)(a2 + 16 * a3 + 8);
      if (v9)
      {
        uint64_t v12 = 0;
        if ((mosyntpal_ALLOCATE(a1, (uint64_t *)&v12, 0x88u) & 0x80000000) == 0)
        {
          *uint64_t v12 = 0;
          long long v10 = v12;
          int v12[2] = 0;
          v10[3] = 0;
          v10[1] = 0;
          *(void *)((char *)v10 + 29) = 0;
          *((_DWORD *)v10 + 3) = a4;
          uint64_t v11 = *v9;
          if (!*v9) {
            goto LABEL_9;
          }
          do
          {
            uint64_t v9 = (void **)v11;
            uint64_t v11 = (void *)*v11;
          }
          while (v11);
          if (v10) {
LABEL_9:
          }
            *uint64_t v9 = v10;
        }
      }
    }
  }
}

uint64_t mosyntdata_SentTermBoundData(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result = 0;
  if (a2)
  {
    if (a3 <= 0x1388) {
      return *(void *)(a2 + 16 * a3 + 8);
    }
  }
  return result;
}

uint64_t mosyntdata_SentTermWordData(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t result = 0;
  if (a2)
  {
    if (a3 <= 0x1388) {
      return *(void *)(a2 + 16 * a3);
    }
  }
  return result;
}

uint64_t mosyntdata_GetSentTermWordPhonList(uint64_t a1, uint64_t a2, unsigned int a3, void *a4)
{
  *a4 = 0;
  if (a2)
  {
    if (a3 <= 0x1388)
    {
      uint64_t v4 = *(void *)(a2 + 16 * a3);
      if (v4) {
        *a4 = *(void *)(v4 + 8);
      }
    }
  }
  return 0;
}

uint64_t mosyntdata_GetSentTermCommList(uint64_t a1, uint64_t a2, unsigned int a3, void *a4)
{
  *a4 = 0;
  if (a2)
  {
    if (a3 <= 0x1388)
    {
      uint64_t v4 = *(void **)(a2 + 16 * a3 + 8);
      if (v4) {
        *a4 = *v4;
      }
    }
  }
  return 0;
}

uint64_t mosyntdata_GenPhonoRepr(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v7 = 0;
  uint64_t result = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  *a4 = 0;
  uint64_t v9 = (uint64_t *)(a3 + 8);
  uint64_t v19 = 0;
  uint64_t v10 = 5001;
  do
  {
    uint64_t v12 = *(v9 - 1);
    uint64_t v11 = *v9;
    if (*v9)
    {
      int v13 = *(_DWORD *)(v11 + 8);
      if (v13 < 0)
      {
        uint64_t result = mosyntdata_AddPhonEle(a1, a4, &v19, 1, 0);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        int v14 = 0;
        uint64_t v7 = v19;
        *(unsigned char *)(v19 + 20) = 1;
        *(_DWORD *)(v7 + 24) = 2;
        LOWORD(v13) = -1;
      }
      else
      {
        int v14 = *(_DWORD *)(v11 + 12);
        uint64_t result = mosyntdata_AddPhonEle(a1, a4, &v19, 1, 0);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t v7 = v19;
        *(unsigned char *)(v19 + 20) = 1;
        *(_DWORD *)(v7 + 24) = 3;
      }
      *(_WORD *)(v7 + 28) = v13;
      *(_DWORD *)(v7 + 32) = v14;
      *(_WORD *)(v7 + 36) = 0;
    }
    if (v12)
    {
      uint64_t result = mosyntdata_GenWordPhono(a1, a2, *(uint64_t **)(v12 + 8), *(_DWORD *)(v12 + 16), v7, 4, &v18, &v17);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      if (v18)
      {
        uint64_t v15 = v17;
        long long v16 = a4;
        if (v19 && (long long v16 = (void *)v19, !v17))
        {
          uint64_t result = 0;
        }
        else
        {
          uint64_t result = 0;
          *long long v16 = v18;
          uint64_t v19 = v15;
        }
      }
    }
    else
    {
      uint64_t v17 = 0;
      uint64_t v18 = 0;
    }
    v9 += 2;
    --v10;
  }
  while (v10);
  return result;
}

uint64_t WriteLexEleList(uint64_t a1, void *a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  if (!a2) {
    return 0;
  }
  uint64_t result = WriteLexEleList(a1, *a2);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v6 = 0;
    memset(v5, 0, sizeof(v5));
    uint64_t result = mosyntkblex_GetEntryPhon(a1, a2 + 1, v5, 200);
    if ((result & 0x80000000) == 0) {
      return mosyntbase_WString(a1, (unsigned __int8 *)v5, 200);
    }
  }
  return result;
}

uint64_t WriteTermInfo(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, int a5)
{
  int v5 = a5;
  if (*(void *)a4)
  {
    uint64_t v7 = *(void *)(*(void *)a4 + 16);
    return WriteLexConsList(a1, a2, a3, v7, a5);
  }
  uint64_t result = mosyntknowl_WriteTraceHeader(a1, a3);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  if (v5 < 1)
  {
LABEL_9:
    if (*(void *)(a4 + 16))
    {
      uint64_t result = mosyntbase_WString(a1, "\"", 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t v10 = *(int *)(a4 + 24);
      if ((int)v10 <= *(_DWORD *)(a4 + 28))
      {
        do
        {
          uint64_t result = mosyntbase_Wr(a1, *(char *)(*(void *)(a4 + 16) + v10));
          if ((result & 0x80000000) != 0) {
            return result;
          }
          BOOL v11 = v10++ < *(int *)(a4 + 28);
        }
        while (v11);
      }
      uint64_t result = mosyntbase_WString(a1, "\" ", 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
    }
    if (*(void *)(a4 + 32))
    {
      uint64_t result = mosyntbase_WString(a1, " [", 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      uint64_t v12 = *(int *)(a4 + 40);
      if ((int)v12 <= *(_DWORD *)(a4 + 44))
      {
        do
        {
          uint64_t result = mosyntbase_Wr(a1, *(char *)(*(void *)(a4 + 32) + v12));
          if ((result & 0x80000000) != 0) {
            return result;
          }
          BOOL v11 = v12++ < *(int *)(a4 + 44);
        }
        while (v11);
      }
      uint64_t result = mosyntbase_WString(a1, "] ", 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
    }
    uint64_t result = mosyntbase_WLn(a1);
    if ((result & 0x80000000) == 0)
    {
      return mosyntbase_WLn(a1);
    }
    return result;
  }
  while (1)
  {
    uint64_t result = mosyntbase_WString(a1, " ", 0);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    if (!--v5) {
      goto LABEL_9;
    }
  }
}

uint64_t kblexXX_StartLookup(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = a1;
  if (*(unsigned char *)(a1 + 260)) {
    *(_DWORD *)(a2 + 8) = 1;
  }
  else {
    *(void *)(a2 + 8) = *(void *)(a1 + 264);
  }
  *(_DWORD *)(a2 + 16) = 0;
  return 0;
}

uint64_t kblexXX_LookupChar(unsigned __int8 a1, int *a2, unsigned char *a3)
{
  unsigned int v5 = a1;
  uint64_t v6 = *(void *)a2;
  if (!*(unsigned char *)(*(void *)a2 + 260))
  {
    uint64_t v10 = *((void *)a2 + 1);
    uint64_t v11 = a2[4];
    *a3 = 0;
    if (*(unsigned char *)(v10 + v11))
    {
      if (*(unsigned __int8 *)(v10 + v11) == v5)
      {
        *a3 = 1;
        int v12 = v11 + 1;
LABEL_8:
        uint64_t result = 0;
        a2[4] = v12;
        return result;
      }
    }
    else
    {
      uint64_t v19 = *(unsigned __int8 **)(v10 + 16);
      if (v19)
      {
        while (1)
        {
          unsigned int v20 = *v19;
          if (v20 >= v5) {
            break;
          }
          uint64_t v19 = (unsigned __int8 *)*((void *)v19 + 3);
          if (!v19) {
            return 0;
          }
        }
        if (v20 == v5)
        {
          int v12 = 1;
          *a3 = 1;
          *((void *)a2 + 1) = v19;
          goto LABEL_8;
        }
      }
    }
    return 0;
  }
  int v27 = 0;
  int v22 = 0;
  uint64_t v7 = a2[4];
  uint64_t result = DecomprNode(v6, a2[2], &v28, &v27, &v22, &v26);
  *a3 = 0;
  if (*((unsigned char *)&v22 + v7))
  {
    if (*((unsigned __int8 *)&v22 + v7) != v5) {
      return result;
    }
    *a3 = 1;
    int v9 = v7 + 1;
    goto LABEL_24;
  }
  int v25 = 0;
  int v21 = 0;
  int v13 = v27;
  uint64_t v14 = *(void *)a2;
  uint64_t result = DecomprNodeStart(*(void *)a2, v27, &v25, &v21);
  BOOL v15 = v13 != 0;
  int v16 = v21;
  if (v13 && v21 < v5)
  {
    do
    {
      int v13 = v25;
      uint64_t result = DecomprNodeStart(v14, v25, &v25, &v21);
      BOOL v15 = v13 != 0;
      int v16 = v21;
      if (v13) {
        BOOL v17 = v21 >= v5;
      }
      else {
        BOOL v17 = 1;
      }
    }
    while (!v17);
  }
  if (v15 && v16 == v5)
  {
    *a3 = 1;
    if (!BYTE1(v21)) {
      uint64_t result = DecomprNode(*(void *)a2, v13, &v25, &v24, &v21, &v23);
    }
    a2[2] = v13;
    int v9 = 1;
LABEL_24:
    a2[4] = v9;
  }
  return result;
}

uint64_t kblexXX_GetFirstEntry(_DWORD *a1, unsigned char *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)a1;
  if (*(unsigned char *)(*(void *)a1 + 260))
  {
    uint64_t v11 = 0;
    int v6 = a1[2];
    uint64_t v7 = (int)a1[4];
    DecomprNode(v5, v6, &v13, &v12, &v11, (int *)&v11 + 1);
    if (v6 && !*((unsigned char *)&v11 + v7) && (int v10 = HIDWORD(v11)) != 0 && *(unsigned char *)(*(void *)(v5 + 272) + SHIDWORD(v11)))
    {
      *a2 = 1;
      *(void *)a3 = v5;
      *(_DWORD *)(a3 + 8) = v10;
      *(_DWORD *)(a3 + 12) = v6;
    }
    else
    {
      *a2 = 0;
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
    }
  }
  else
  {
    uint64_t v8 = *((void *)a1 + 1);
    if (v8 && !*(unsigned char *)(v8 + (int)a1[4]) && *(void *)(v8 + 32))
    {
      *a2 = 1;
      *(void *)a3 = v5;
      *(void *)(a3 + 16) = v8;
      *(void *)(a3 + 8) = *(void *)(v8 + 32);
    }
    else
    {
      *a2 = 0;
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
    }
  }
  return 0;
}

uint64_t kblexXX_GetNextEntry(BOOL *a1, int *a2)
{
  uint64_t v3 = *(void *)a2;
  if (!*(void *)a2) {
    goto LABEL_11;
  }
  if (*(unsigned char *)(v3 + 260))
  {
    uint64_t v5 = a2[2];
    if (!v5) {
      goto LABEL_12;
    }
    uint64_t v6 = *(void *)(v3 + 272);
    if (*(unsigned char *)(v6 + v5))
    {
      uint64_t v12 = 0;
      int v11 = 0;
      uint64_t v5 = DecomprEntry1(v3, v5, (*(unsigned __int8 *)(v6 + a2[3]) >> 5) & 1, (int *)&v12 + 1, (int *)&v12, &v11);
      uint64_t v7 = v11;
      a2[2] = v11;
      if (!v7) {
        goto LABEL_10;
      }
      uint64_t v3 = *(void *)a2;
      if (!*(unsigned char *)(*(void *)(*(void *)a2 + 272) + v7)) {
        goto LABEL_10;
      }
      goto LABEL_12;
    }
LABEL_11:
    uint64_t v5 = 0;
    goto LABEL_12;
  }
  uint64_t v8 = (uint64_t *)*((void *)a2 + 1);
  if (!v8) {
    goto LABEL_11;
  }
  uint64_t v5 = 0;
  uint64_t v9 = *v8;
  *((void *)a2 + 1) = v9;
  if (!v9)
  {
LABEL_10:
    uint64_t v3 = 0;
    *(void *)a2 = 0;
  }
LABEL_12:
  *a1 = v3 != 0;
  return v5;
}

uint64_t DecomprEntry1(uint64_t a1, int a2, int a3, int *a4, int *a5, int *a6)
{
  if (a2)
  {
    int v16 = a2;
    DecomprNum(*(void *)(a1 + 272), &v16, a4);
    if (*a4 < 1)
    {
      int v11 = 0;
    }
    else
    {
      if (!a3 || (DecomprNum(*(void *)(a1 + 272), &v16, a5), *a5 <= 0)) {
        *a5 = 1;
      }
      int v11 = v16;
      if ((*(_DWORD *)(a1 + 280) & 0x80000000) != 0)
      {
        uint64_t v12 = *(void *)(a1 + 272);
        if (*(unsigned char *)(v12 + v16))
        {
          int v13 = (unsigned __int8 *)(v16 + v12 + 1);
          do
          {
            int v14 = *v13++;
            ++v11;
          }
          while (v14);
        }
        ++v11;
      }
    }
  }
  else
  {
    int v11 = 0;
    *a4 = 0;
  }
  *a6 = v11;
  return 0;
}

uint64_t kblexXX_GetEntryGraph(uint64_t a1, uint64_t *a2, unsigned char *a3, int a4)
{
  *a3 = 0;
  uint64_t v4 = *a2;
  if (!*a2) {
    return 0;
  }
  BOOL v35 = 0;
  if (!*(unsigned char *)(v4 + 260))
  {
    if (a2[1])
    {
      uint64_t v21 = a2[2];
      for (i = a4 - 1; v21; uint64_t v21 = *(void *)(v21 + 8))
      {
        if (v21 == *(void *)(v4 + 264)) {
          break;
        }
        uint64_t v23 = 0;
        while (*(unsigned __int8 *)(v21 + v23++))
          ;
        if (v23 != 1)
        {
          uint64_t v25 = 0;
          do
          {
            a3[i + v25] = *(unsigned char *)(v21 + (v23 + v25 - 2));
            --v25;
          }
          while (v23 + v25 > 1);
          i += v25;
        }
      }
      uint64_t v26 = a4 - 1 - i;
      if ((int)v26 >= 1)
      {
        int v27 = i + 1;
        uint64_t v28 = v26;
        BOOL v29 = a3;
        do
        {
          *v29++ = a3[v27++];
          --v28;
        }
        while (v28);
      }
      uint64_t result = 0;
      a3[v26] = 0;
      return result;
    }
    return 0;
  }
  if (!*(unsigned char *)(v4 + 264)) {
    return mosyntbase_CCopy("???", 0, (uint64_t)a3, a4, &v35);
  }
  int v6 = *((_DWORD *)a2 + 3);
  uint64_t v7 = a4 - 1;
  if (v6)
  {
    int __dst = 0;
    int v8 = a4 - 1;
    while (1)
    {
      uint64_t v9 = *(void *)(v4 + 272);
      char v10 = *(unsigned char *)(v9 + v6);
      int v11 = v6 + 1;
      unsigned int v12 = v10 & 3;
      if ((v10 & 3) != 0)
      {
        memcpy(&__dst, (const void *)(v9 + v11), v10 & 3);
        v11 += v12;
        uint64_t v13 = v10 & 3;
      }
      else
      {
        uint64_t v13 = 0;
      }
      *(unsigned char *)((unint64_t)&__dst | v13) = 0;
      if ((v10 & 4) != 0)
      {
        if (*(char *)(v9 + v11) < 0)
        {
          int v14 = (char *)(v9 + v11 + 1);
          do
          {
            int v15 = *v14++;
            ++v11;
          }
          while (v15 < 0);
        }
        ++v11;
      }
      int v16 = *(unsigned __int8 *)(v9 + v11);
      if (*(char *)(v9 + v11) < 0) {
        break;
      }
      int v17 = 0;
      if (v12) {
        goto LABEL_16;
      }
LABEL_17:
      int v6 = v17 + v6 - v16;
      if (!v6) {
        goto LABEL_40;
      }
    }
    int v18 = 0;
    uint64_t v19 = (char *)(v9 + v11 + 1);
    do
    {
      int v18 = v16 + (v18 << 7) - 128;
      int v20 = *v19++;
      int v16 = v20;
    }
    while (v20 < 0);
    int v17 = -128 * v18;
    if (!v12) {
      goto LABEL_17;
    }
LABEL_16:
    memcpy(&a3[v8 + 1 - v12], &__dst, v12);
    v8 -= v12;
    goto LABEL_17;
  }
  int v8 = a4 - 1;
LABEL_40:
  uint64_t v31 = v7 - v8;
  if ((int)v31 >= 1)
  {
    int v32 = v8 + 1;
    uint64_t v33 = v31;
    int v34 = a3;
    do
    {
      *v34++ = a3[v32++];
      --v33;
    }
    while (v33);
  }
  uint64_t result = 0;
  a3[v31] = 0;
  return result;
}

uint64_t kblexXX_GetEntryPhon(uint64_t a1, uint64_t *a2, unsigned char *a3, int a4)
{
  *a3 = 0;
  uint64_t v4 = *a2;
  if (!*a2) {
    return 0;
  }
  if (*(unsigned char *)(v4 + 260))
  {
    int v7 = *((_DWORD *)a2 + 2);
    if (v7)
    {
      uint64_t v8 = *(void *)(v4 + 272);
      int v9 = *(unsigned __int8 *)(v8 + v7);
      if (*(char *)(v8 + v7) < 0)
      {
        int v15 = 0;
        int v16 = (char *)(v7 + v8 + 1);
        do
        {
          int v15 = v9 + (v15 << 7) - 128;
          int v17 = *v16++;
          int v9 = v17;
          ++v7;
        }
        while (v17 < 0);
        int v10 = v15 << 7;
      }
      else
      {
        int v10 = 0;
      }
      if (v9 + v10 >= 1)
      {
        int v18 = v7 + 1;
        if ((*(unsigned char *)(v8 + *((int *)a2 + 3)) & 0x20) != 0)
        {
          if (*(char *)(v8 + v18) < 0)
          {
            uint64_t v19 = (char *)(v18 + v8 + 1);
            do
            {
              int v20 = *v19++;
              ++v18;
            }
            while (v20 < 0);
          }
          ++v18;
        }
        if ((*(_DWORD *)(v4 + 280) & 0x80000000) == 0) {
          return mosyntbase_WriteDevelMessage(a1, "***** extern phon string lexica not supported", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, 0, 0, 0);
        }
        uint64_t v21 = 0;
        uint64_t v22 = v8 + v18;
        do
        {
          int v23 = *(unsigned __int8 *)(v22 + v21);
          if (v21 < a4) {
            a3[v21] = v23;
          }
          ++v21;
        }
        while (v23);
      }
    }
    return 0;
  }
  uint64_t v11 = a2[1];
  if (!v11) {
    return 0;
  }
  uint64_t v12 = *(void *)(v4 + 280);
  signed int v13 = *(_DWORD *)(v11 + 12);
  return auxkbcommondef_RecallString(a1, v12, v13, (uint64_t)a3, a4);
}

uint64_t kblexXX_GetEntryCost(uint64_t a1, uint64_t a2, int *a3)
{
  *a3 = 0;
  uint64_t result = *(void *)a2;
  if (*(void *)a2)
  {
    if (*(unsigned char *)(result + 260))
    {
      int v6 = 0;
      return DecomprEntry1(result, *(_DWORD *)(a2 + 8), (*(unsigned __int8 *)(*(void *)(result + 272) + *(int *)(a2 + 12)) >> 5) & 1, &v6, a3, &v5);
    }
    else
    {
      uint64_t v4 = *(void *)(a2 + 8);
      uint64_t result = 0;
      if (v4) {
        *a3 = *(_DWORD *)(v4 + 16);
      }
    }
  }
  return result;
}

uint64_t kblexXX_GetEntryCostAndConsList(uint64_t a1, uint64_t a2, int *a3, unsigned char *a4, int a5)
{
  int v10 = 0;
  uint64_t v7 = *(void *)a2;
  if (*(void *)a2)
  {
    if (*(unsigned char *)(v7 + 260))
    {
      DecomprEntry1(v7, *(_DWORD *)(a2 + 8), (*(unsigned __int8 *)(*(void *)(v7 + 272) + *(int *)(a2 + 12)) >> 5) & 1, &v10, a3, &v11);
      LODWORD(v7) = v10;
    }
    else
    {
      uint64_t v8 = *(void *)(a2 + 8);
      if (v8)
      {
        LODWORD(v7) = *(_DWORD *)(v8 + 8);
        *a3 = *(_DWORD *)(v8 + 16);
      }
      else
      {
        LODWORD(v7) = 0;
      }
    }
  }
  return mosyntpal_IntToString(v7, 0, a4, a5);
}

uint64_t kblexXX_GetNilEntry(void *a1)
{
  *a1 = 0;
  return 0;
}

BOOL kblexXX_IsValidEntry(void *a1)
{
  return *a1 != 0;
}

BOOL kblexXX_IdenticalEntries(_DWORD *a1, uint64_t a2)
{
  if (*(void *)a1 != *(void *)a2) {
    return 0;
  }
  if (*(unsigned char *)(*(void *)a1 + 260)) {
    return a1[2] == *(_DWORD *)(a2 + 8);
  }
  else {
    return *((void *)a1 + 1) == *(void *)(a2 + 8);
  }
}

uint64_t DecomprNode(uint64_t a1, int a2, int *a3, int *a4, unsigned char *a5, int *a6)
{
  if (a2)
  {
    uint64_t v6 = *(void *)(a1 + 272);
    int v7 = *(unsigned __int8 *)(v6 + a2);
    int v8 = a2 + 1;
    uint64_t v9 = v7 & 3;
    if ((v7 & 3) != 0)
    {
      int v10 = (char *)(v6 + v8);
      int v8 = a2 + (v7 & 3) + 1;
      int v11 = a5;
      uint64_t v12 = v7 & 3;
      do
      {
        char v13 = *v10++;
        *v11++ = v13;
        --v12;
      }
      while (v12);
    }
    else
    {
      uint64_t v9 = 0;
    }
    a5[v9] = 0;
    if ((v7 & 4) != 0)
    {
      uint64_t v16 = *(void *)(a1 + 272);
      int v17 = *(unsigned __int8 *)(v16 + v8);
      if (*(char *)(v16 + v8) < 0)
      {
        int v19 = 0;
        int v20 = (char *)(v8 + v16 + 1);
        do
        {
          int v19 = v17 + (v19 << 7) - 128;
          int v21 = *v20++;
          int v17 = v21;
          ++v8;
        }
        while (v21 < 0);
        int v18 = v19 << 7;
      }
      else
      {
        int v18 = 0;
      }
      int v15 = ++v8 + v18 + v17;
    }
    else
    {
      int v15 = 0;
    }
    *a3 = v15;
    if (*(unsigned char *)(a1 + 264))
    {
      uint64_t v22 = *(void *)(a1 + 272);
      if (*(char *)(v22 + v8) < 0)
      {
        int v23 = (char *)(v8 + v22 + 1);
        do
        {
          int v24 = *v23++;
          ++v8;
        }
        while (v24 < 0);
      }
      ++v8;
    }
    if ((v7 & 8) != 0)
    {
      uint64_t v26 = *(void *)(a1 + 272);
      int v27 = *(unsigned __int8 *)(v26 + v8);
      if (*(char *)(v26 + v8) < 0)
      {
        int v29 = 0;
        uint64_t v30 = (char *)(v8 + v26 + 1);
        do
        {
          int v29 = v27 + (v29 << 7) - 128;
          int v31 = *v30++;
          int v27 = v31;
          ++v8;
        }
        while (v31 < 0);
        int v28 = v29 << 7;
      }
      else
      {
        int v28 = 0;
      }
      int v25 = ++v8 + v28 + v27;
    }
    else
    {
      int v25 = 0;
    }
    *a4 = v25;
    int v14 = v8 & (v7 << 27 >> 31);
  }
  else
  {
    int v14 = 0;
    *a3 = 0;
    *a4 = 0;
    *a5 = 0;
  }
  *a6 = v14;
  return 0;
}

uint64_t DecomprNodeStart(uint64_t a1, int a2, _DWORD *a3, unsigned char *a4)
{
  if (a2)
  {
    uint64_t v4 = *(void *)(a1 + 272);
    char v5 = *(unsigned char *)(v4 + a2);
    int v6 = a2 + 1;
    uint64_t v7 = v5 & 3;
    if ((v5 & 3) != 0)
    {
      int v8 = (char *)(v4 + v6);
      int v6 = a2 + (v5 & 3) + 1;
      uint64_t v9 = a4;
      uint64_t v10 = v5 & 3;
      do
      {
        char v11 = *v8++;
        *v9++ = v11;
        --v10;
      }
      while (v10);
    }
    else
    {
      uint64_t v7 = 0;
    }
    a4[v7] = 0;
    if ((v5 & 4) != 0)
    {
      uint64_t v12 = *(void *)(a1 + 272);
      int v13 = *(unsigned __int8 *)(v12 + v6);
      if (*(char *)(v12 + v6) < 0)
      {
        int v15 = 0;
        uint64_t v16 = (char *)(v6 + v12 + 1);
        do
        {
          int v15 = v13 + (v15 << 7) - 128;
          int v17 = *v16++;
          int v13 = v17;
          ++v6;
        }
        while (v17 < 0);
        int v14 = v15 << 7;
      }
      else
      {
        int v14 = 0;
      }
      *a3 = v6 + v14 + v13 + 1;
    }
    else
    {
      *a3 = 0;
    }
  }
  else
  {
    *a3 = 0;
    *a4 = 0;
  }
  return 0;
}

uint64_t DecomprNum(uint64_t result, int *a2, _DWORD *a3)
{
  *a3 = 0;
  int v3 = *(unsigned __int8 *)(result + *a2);
  if (*(char *)(result + *a2) < 0)
  {
    do
    {
      *a3 = v3 + (*a3 << 7) - 128;
      uint64_t v5 = *a2 + 1;
      *a2 = v5;
      int v6 = *(char *)(result + v5);
      int v3 = *(unsigned __int8 *)(result + v5);
    }
    while (v6 < 0);
    int v4 = *a3 << 7;
  }
  else
  {
    int v4 = 0;
  }
  *a3 = v4 + v3;
  ++*a2;
  return result;
}

uint64_t mosyntwordpho_LHPlusMapping(uint64_t a1, int a2, uint64_t *a3, int *a4, unsigned __int8 *a5, int a6)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  if (*a4 < 2) {
    return 0;
  }
  uint64_t v11 = *(void *)&a4[2 * (*a4 - 1) + 2];
  if (a2 < 1
    || (uint64_t result = mosyntknowl_WriteTraceHeader(a1, 3u), (result & 0x80000000) == 0)
    && (uint64_t result = mosyntbase_WriteMessage(a1, "lhplus mapping input: %s\\n", 0, a5, a6, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0), (result & 0x80000000) == 0))
  {
    int v21 = 0;
    uint64_t v22 = 0;
    memset(v23, 0, sizeof(v23));
    int v24 = 0;
    uint64_t v19 = 0;
    int v20 = 0;
    uint64_t result = mosyntdata_StringToLexPhonList(a1, a3, a5, a6, &v21, &v19);
    if ((result & 0x80000000) == 0)
    {
      uint64_t result = mosynttrans_InitTransDesc(a1, a2, (uint64_t)a3, &v22);
      if ((result & 0x80000000) == 0)
      {
        m2__cp__str("lhplus mapping", v23, 100);
        v13[0] = 1;
        v13[1] = v11;
        long long v14 = 0u;
        long long v15 = 0u;
        long long v16 = 0u;
        long long v17 = 0u;
        uint64_t v18 = 0;
        uint64_t result = mosynttrans_SeqTransducePhonList(a1, v22, 3u, v21, &v20, (uint64_t)v13, 0, -1, 0xFFFFFFFF, v23, 100);
        if ((result & 0x80000000) == 0)
        {
          uint64_t result = mosynttrans_FinishTransDesc(a1, &v22);
          if ((result & 0x80000000) == 0)
          {
            uint64_t result = mosyntdata_PhonListToString(a1, a3, 1, v20, a5, a6);
            if ((result & 0x80000000) == 0)
            {
              uint64_t result = mosyntdata_DisposePhonEleList(a1, &v21);
              if ((result & 0x80000000) == 0)
              {
                uint64_t result = mosyntdata_DisposePhonEleList(a1, &v20);
                if (a2 >= 1 && (result & 0x80000000) == 0)
                {
                  uint64_t result = mosyntknowl_WriteTraceHeader(a1, 3u);
                  if ((result & 0x80000000) == 0) {
                    return mosyntbase_WriteMessage(a1, "lhplus mapping output: %s\\n", 0, a5, a6, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mosyntwordpho_ReadingToPhonString(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, unsigned char *a5, int a6)
{
  if (a4) {
    return mosyntdata_LexEleListToPhonString(a1, a3, *(_DWORD *)(a4 + 8), *(void **)(a4 + 16), (uint64_t)a5, a6);
  }
  *a5 = 0;
  return 0;
}

uint64_t mosyntwordpho_TreatSingleReadingString(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned __int8 *a6, int a7)
{
  v31[2] = *MEMORY[0x263EF8340];
  int v23 = 0;
  uint64_t result = mosyntpal_ALLOCATE(a1, (uint64_t *)&v23, 0x68u);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v15 = (uint64_t)v23;
    *int v23 = a2;
    *(void *)(v15 + 8) = a3;
    long long v16 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)(v15 + 16) = *(_OWORD *)a4;
    *(_OWORD *)(v15 + 32) = v16;
    long long v18 = *(_OWORD *)(a4 + 48);
    long long v17 = *(_OWORD *)(a4 + 64);
    long long v19 = *(_OWORD *)(a4 + 32);
    *(void *)(v15 + 96) = *(void *)(a4 + 80);
    *(_OWORD *)(v15 + 64) = v18;
    *(_OWORD *)(v15 + 80) = v17;
    *(_OWORD *)(v15 + 48) = v19;
    if (!a5) {
      return mosyntpal_DEALLOCATE(a1, (uint64_t *)&v23);
    }
    uint64_t v29 = 0;
    v30[0] = 0;
    v30[1] = 0;
    v31[0] = 0;
    *(void *)((char *)v31 + 6) = 0;
    uint64_t v27 = 0;
    int v28 = 0;
    uint64_t result = mosyntdata_StartPhonList(a1, &v28, &v27);
    if ((result & 0x80000000) == 0)
    {
      uint64_t v26 = 0;
      uint64_t result = mosyntdata_StringToLexPhonList(a1, *(uint64_t **)(v15 + 8), a6, a7, &v28, &v27);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = mosynttrans_InitTransDesc(a1, *(_DWORD *)v15, *(void *)(v15 + 8), &v29);
        if ((result & 0x80000000) == 0)
        {
          m2__cp__str("morphophonemic rules", v30, 30);
          int v20 = *(_DWORD *)(v15 + 16) - 1;
          long long v21 = *(_OWORD *)(v15 + 64);
          unsigned char v24[2] = *(_OWORD *)(v15 + 48);
          v24[3] = v21;
          v24[4] = *(_OWORD *)(v15 + 80);
          uint64_t v25 = *(void *)(v15 + 96);
          long long v22 = *(_OWORD *)(v15 + 32);
          v24[0] = *(_OWORD *)(v15 + 16);
          v24[1] = v22;
          uint64_t result = mosynttrans_SeqTransducePhonList(a1, v29, 3u, v28, &v26, (uint64_t)v24, 0, v20, 0xFFFFFFFF, (unsigned __int8 *)v30, 30);
          if ((result & 0x80000000) == 0)
          {
            uint64_t result = mosynttrans_FinishTransDesc(a1, &v29);
            if ((result & 0x80000000) == 0)
            {
              uint64_t result = mosyntdata_DisposePhonEleList(a1, &v28);
              if ((result & 0x80000000) == 0)
              {
                uint64_t result = mosyntdata_PhonListToString(a1, *(uint64_t **)(v15 + 8), 1, v26, a6, a7);
                if ((result & 0x80000000) == 0)
                {
                  uint64_t result = mosyntdata_DisposePhonEleList(a1, &v26);
                  if ((result & 0x80000000) == 0) {
                    return mosyntpal_DEALLOCATE(a1, (uint64_t *)&v23);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mosyntwordpho_TraceReading(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, unsigned __int8 *a5, int a6)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (a2 < 2) {
    return 0;
  }
  uint64_t result = mosyntknowl_WriteTraceHeader(a1, 3u);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v13 = 0;
    memset(v12, 0, sizeof(v12));
    uint64_t result = mosyntkbsymtab_ConsToString(a1, a3, *(_DWORD *)(a4 + 8), (char *)v12, 200);
    if ((result & 0x80000000) == 0) {
      return mosyntbase_WriteMessage(a1, "getting internal phon list for word cons %s: %s\\n", 0, (unsigned __int8 *)v12, 200, a5, a6, (unsigned __int8 *)&byte_20D5A22AE, 0);
    }
  }
  return result;
}

uint64_t mosyntpal_ALLOCATE(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  uint64_t v8 = 0;
  uint64_t inited = InitRsrcFunction(*(_WORD **)a1, *(void *)(a1 + 8), &v8);
  if ((inited & 0x80000000) == 0)
  {
    uint64_t v6 = heap_Calloc(*(void **)(v8 + 8), 1, a3);
    *a2 = v6;
    if (v6) {
      return inited;
    }
    else {
      return 2371887114;
    }
  }
  return inited;
}

uint64_t mosyntpal_DEALLOCATE(uint64_t a1, uint64_t *a2)
{
  uint64_t v5 = 0;
  uint64_t inited = InitRsrcFunction(*(_WORD **)a1, *(void *)(a1 + 8), &v5);
  heap_Free(*(void **)(v5 + 8), *a2);
  *a2 = 0;
  return inited;
}

uint64_t mosyntpal_IntToString(unsigned int a1, uint64_t a2, unsigned char *a3, int a4)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  LH_itoa(a1, v13, 0xAu);
  uint64_t v6 = (a4 - 1);
  if (a4 >= 1)
  {
    if (a4 != 1)
    {
      uint64_t v7 = v6 - 1;
      uint64_t v8 = v13;
      uint64_t v9 = a3;
      do
      {
        int v10 = *v8++;
        *v9++ = v10;
        if (v10) {
          BOOL v11 = v7 == 0;
        }
        else {
          BOOL v11 = 1;
        }
        --v7;
      }
      while (!v11);
    }
    a3[v6] = 0;
  }
  return 0;
}

uint64_t mosyntpal_StringToInt(uint64_t a1, uint64_t a2, int *a3, BOOL *a4)
{
  uint64_t v4 = 0;
  do
  {
    int v5 = *(char *)(a1 + v4);
    int v6 = *(unsigned __int8 *)(a1 + v4++);
  }
  while (v5 <= 32 && v6 != 0);
  if (v6 == 45 || v6 == 43) {
    int v9 = v4 + 1;
  }
  else {
    int v9 = v4;
  }
  uint64_t v10 = (v9 - 1);
  int v11 = *(unsigned __int8 *)(a1 + v10);
  BOOL v12 = (v11 - 58) < 0xFFFFFFF6;
  if ((v11 - 48) > 9)
  {
    int v13 = 0;
  }
  else
  {
    int v13 = 0;
    if ((v6 == 43) <= (v6 == 45)) {
      BOOL v14 = v6 == 45;
    }
    else {
      BOOL v14 = v6 == 43;
    }
    uint64_t v15 = v14 + v4;
    do
    {
      int v16 = v11 + 10 * v13 - 48;
      BOOL v17 = v16 < v13;
      if (v16 > v13) {
        int v13 = v16;
      }
      if (v17) {
        BOOL v12 = 1;
      }
      int v11 = *(unsigned __int8 *)(a1 + v15++);
    }
    while ((v11 - 48) < 0xA);
    uint64_t v10 = (v15 - 1);
  }
  long long v18 = (char *)(a1 + v10);
  do
  {
    int v20 = *v18++;
    int v19 = v20;
  }
  while (v20 <= 32 && v19 != 0);
  if (v6 == 45) {
    int v22 = -v13;
  }
  else {
    int v22 = v13;
  }
  BOOL v23 = (v12 | v19) == 0;
  if (!v23) {
    int v22 = 0;
  }
  *a4 = v23;
  *a3 = v22;
  return 0;
}

uint64_t mosyntpal_WriteChar(uint64_t a1, int a2)
{
  uint64_t v10 = 0;
  if (!a1) {
    return 0;
  }
  uint64_t inited = InitRsrcFunction(*(_WORD **)a1, *(void *)(a1 + 8), &v10);
  if ((inited & 0x80000000) == 0)
  {
    if (a2 == 10)
    {
      *(unsigned char *)(a1 + 16 + *(int *)(a1 + 1020)) = 0;
      log_OutText(*(void *)(v10 + 32), (uint64_t)"FE_MOSYNT", 0, 0, (uint64_t)"%s", v4, v5, v6, a1 + 16);
      *(_DWORD *)(a1 + 1020) = 0;
    }
    else
    {
      int v8 = *(_DWORD *)(a1 + 1020);
      if (v8 == 1000)
      {
        *(unsigned char *)(a1 + 1016) = 0;
        log_OutText(*(void *)(v10 + 32), (uint64_t)"FE_MOSYNT", 0, 0, (uint64_t)"%s", v4, v5, v6, a1 + 16);
        int v8 = 0;
        *(_DWORD *)(a1 + 1020) = 0;
      }
      *(unsigned char *)(a1 + v8 + 16) = a2;
      ++*(_DWORD *)(a1 + 1020);
    }
  }
  return inited;
}

uint64_t mosyntpal_WriteString(uint64_t a1, unsigned __int8 *a2, int a3)
{
  if (a3 >= 1)
  {
    uint64_t v5 = a3;
    do
    {
      int v7 = *a2++;
      char v6 = v7;
      if (!v7) {
        break;
      }
      mosyntpal_WriteChar(a1, v6);
      --v5;
    }
    while (v5);
  }
  return 0;
}

uint64_t mosyntpal_WriteLn(uint64_t a1)
{
  return 0;
}

uint64_t mosyntpal_EOL()
{
  return 10;
}

uint64_t wgram_CheckIfExists(_WORD *a1, uint64_t a2, _WORD *a3, int a4, _DWORD *a5)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  memset(v25, 0, sizeof(v25));
  int v22 = 0;
  *a5 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v24);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t inited = InitRsrcFunction(a3, a4, &v23);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t inited = kbaux_BuildBrokerString(v24, "wgram", (char *)v25, 0x100uLL);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  RsrcHandleForThisApint i = (_WORD *)getRsrcHandleForThisApi(v24, (uint64_t)a1, a2, (uint64_t)a3);
  uint64_t v13 = wgram_OpenRiffForReading(RsrcHandleForThisApi, v12, (const char *)v25, (uint64_t *)&v22);
  uint64_t v20 = v13;
  if ((v13 & 0x80000000) == 0)
  {
    *a5 = 1;
    return wgram_CloseRiff(&v22, v13, v14, v15, v16, v17, v18, v19);
  }
  if ((v13 & 0x1FFF) == 0xD || (v13 & 0x1FFF) == 3) {
    return 0;
  }
  return v20;
}

uint64_t getRsrcHandleForThisApi(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __s1 = 0;
  if ((paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"clcpppipelinemode", &__s1) & 0x80000000) == 0
    && __s1
    && *__s1
    && strcmp(__s1, "internal"))
  {
    return a2;
  }
  return a4;
}

uint64_t wgram_LoadData(_WORD *a1, uint64_t a2, _WORD *a3, int a4, void *a5)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  memset(v26, 0, sizeof(v26));
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v25);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t inited = InitRsrcFunction(a3, a4, &v24);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  if (!a5) {
    return 2371887111;
  }
  uint64_t inited = kbaux_BuildBrokerString(v25, "wgram", (char *)v26, 0x100uLL);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  RsrcHandleForThisApint i = (_WORD *)getRsrcHandleForThisApi(v25, (uint64_t)a1, a2, (uint64_t)a3);
  uint64_t inited = wgram_OpenRiffForReading(RsrcHandleForThisApi, v12, (const char *)v26, (uint64_t *)&v23);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  ObjcForThisApint i = getObjcForThisApi(v25, v24);
  AddRefCounteduint64_t Object = objc_GetAddRefCountedObject(ObjcForThisApi, (uint64_t)v26, (uint64_t (*)(void, void, uint64_t, long long *, uint64_t))wgram_loc_ObjcLoadData, (void (*)(void, void, long long *))wgram_loc_ObjcUnloadData, (uint64_t)v23, &v22);
  if ((AddRefCountedObject & 0x80000000) == 0)
  {
    *a5 = *(void *)(v22 + 32);
    return wgram_CloseRiff(&v23, AddRefCountedObject, v15, v16, v17, v18, v19, v20);
  }
  return AddRefCountedObject;
}

uint64_t wgram_loc_ObjcLoadData(_WORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = wgram_ReadFromRiff(a1, a2, a5, (uint64_t *)(a4 + 32));
  if ((v5 & 0x80000000) == 0) {
    __strcpy_chk();
  }
  return v5;
}

uint64_t wgram_loc_ObjcUnloadData(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t v16 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v16);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t v12 = *(void ***)(a3 + 32);
  if (!v12) {
    return 2371887111;
  }
  uint64_t v13 = v16;
  uint64_t v14 = wgram_ReleaseData(v12, v5, v6, v7, v8, v9, v10, v11);
  heap_Free(*(void **)(v13 + 8), (uint64_t)v12);
  return v14;
}

uint64_t wgram_UnloadData(_WORD *a1, int a2, _WORD *a3, int a4, uint64_t *a5)
{
  if (!a5) {
    return 2371887111;
  }
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v11);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = InitRsrcFunction(a3, a4, &v10);
    if ((result & 0x80000000) == 0)
    {
      ObjcForThisApint i = getObjcForThisApi(v11, v10);
      return objc_ReleaseObject(ObjcForThisApi, *a5);
    }
  }
  return result;
}

uint64_t wgram_GetStartState(uint64_t a1, _DWORD *a2)
{
  uint64_t result = 2371887111;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0;
      *a2 = *(_DWORD *)(a1 + 256);
    }
  }
  return result;
}

uint64_t wgram_GetFirstTrans(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  uint64_t result = 2371887111;
  if (a1 && a3 && a4 && a5 && a6)
  {
    *a4 = -1;
    *a5 = -1;
    *a6 = -1;
    if (a2 < 0)
    {
      return 0;
    }
    else
    {
      unsigned int v8 = a2 % *(_DWORD *)(a1 + 264);
      uint64_t v9 = *(void *)(a1 + 272);
      uint64_t v10 = *(unsigned int *)(v9 + 4 * v8);
      int v11 = *(_DWORD *)(v9 + 4 * (v8 + 1));
      if ((int)v10 >= v11)
      {
LABEL_12:
        uint64_t result = 0;
        *a3 = v10 + 1;
        a3[1] = v11;
      }
      else
      {
        uint64_t v12 = *(void *)(a1 + 280);
        unint64_t v13 = 0xFFFFFFFC00000000 * v10;
        uint64_t v14 = (int *)(v12 + 16 * v10 + 8);
        while (1)
        {
          int v15 = *v14;
          v14 += 4;
          LODWORD(v10) = v10 + 1;
          if (v15 == a2) {
            break;
          }
          v13 -= 0x400000000;
          if (v11 == v10)
          {
            LODWORD(v10) = v11;
            goto LABEL_12;
          }
        }
        uint64_t result = 0;
        *a3 = v10;
        a3[1] = v11;
        *a4 = *(_DWORD *)(v12 + (-(uint64_t)v13 >> 30));
        *a5 = *(_DWORD *)(v12 + ((uint64_t)(0x100000000 - v13) >> 30));
        *a6 = *(_DWORD *)(v12 + (((uint64_t)(0x200000000 - v13) >> 30) | 4));
      }
    }
  }
  return result;
}

uint64_t wgram_GetNextTrans(uint64_t a1, int a2, unsigned int *a3, _DWORD *a4, _DWORD *a5, int *a6)
{
  uint64_t result = 2371887111;
  if (a1 && a3 && a4 && a5 && a6)
  {
    uint64_t v8 = *a3;
    int v9 = a3[1];
    if ((int)v8 >= v9)
    {
LABEL_11:
      *a3 = v8 + 1;
      int v14 = -1;
      *a4 = -1;
      *a5 = -1;
    }
    else
    {
      uint64_t v10 = *(void *)(a1 + 280);
      uint64_t v11 = v8 << 34;
      uint64_t v12 = (int *)(v10 + 16 * v8 + 8);
      while (1)
      {
        int v13 = *v12;
        v12 += 4;
        LODWORD(v8) = v8 + 1;
        if (v13 == a2) {
          break;
        }
        v11 += 0x400000000;
        if (v9 == v8)
        {
          LODWORD(v8) = a3[1];
          goto LABEL_11;
        }
      }
      *a3 = v8;
      *a4 = *(_DWORD *)(v10 + (v11 >> 30));
      *a5 = *(_DWORD *)(v10 + ((v11 >> 30) | 4));
      int v14 = *(_DWORD *)(v10 + ((v11 >> 30) | 0xC));
    }
    uint64_t result = 0;
    *a6 = v14;
  }
  return result;
}

uint64_t wgram_GetFirstEpsTrans(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, int *a6)
{
  uint64_t v6 = 2371887111;
  if (a1 && a3 && a4 && a5 && a6)
  {
    uint64_t v7 = (unsigned int *)(*(void *)(a1 + 312) + 4 * (a2 % *(_DWORD *)(a1 + 304)));
    uint64_t v9 = *v7;
    int v8 = v7[1];
    if ((int)v9 >= v8)
    {
LABEL_11:
      *a3 = v9 + 1;
      a3[1] = v8;
      int v14 = -1;
      *a4 = -1;
      *a5 = 0;
    }
    else
    {
      uint64_t v10 = *(void *)(a1 + 320);
      uint64_t v11 = v9 << 34;
      uint64_t v12 = (int *)(v10 + 16 * v9);
      while (1)
      {
        int v13 = *v12;
        v12 += 4;
        LODWORD(v9) = v9 + 1;
        if (v13 == a2) {
          break;
        }
        v11 += 0x400000000;
        if (v8 == v9)
        {
          LODWORD(v9) = v8;
          goto LABEL_11;
        }
      }
      *a3 = v9;
      a3[1] = v8;
      int v15 = *(_DWORD *)(v10 + ((v11 >> 30) | 4));
      *a4 = v15;
      *a5 = v15 == *(_DWORD *)(a1 + 260);
      int v14 = *(_DWORD *)(v10 + ((v11 >> 30) | 0xC));
    }
    uint64_t v6 = 0;
    *a6 = v14;
  }
  return v6;
}

uint64_t wgram_GetNextEpsTrans(uint64_t a1, int a2, unsigned int *a3, _DWORD *a4, _DWORD *a5, int *a6)
{
  uint64_t v6 = 2371887111;
  if (a1 && a3 && a4 && a5 && a6)
  {
    uint64_t v7 = *a3;
    int v8 = a3[1];
    if ((int)v7 >= v8)
    {
LABEL_11:
      *a3 = v7 + 1;
      int v13 = -1;
      *a4 = -1;
      *a5 = 0;
    }
    else
    {
      uint64_t v9 = *(void *)(a1 + 320);
      uint64_t v10 = v7 << 34;
      uint64_t v11 = (int *)(v9 + 16 * v7);
      while (1)
      {
        int v12 = *v11;
        v11 += 4;
        LODWORD(v7) = v7 + 1;
        if (v12 == a2) {
          break;
        }
        v10 += 0x400000000;
        if (v8 == v7)
        {
          LODWORD(v7) = a3[1];
          goto LABEL_11;
        }
      }
      *a3 = v7;
      int v14 = *(_DWORD *)(v9 + ((v10 >> 30) | 4));
      *a4 = v14;
      *a5 = v14 == *(_DWORD *)(a1 + 260);
      int v13 = *(_DWORD *)(v9 + ((v10 >> 30) | 0xC));
    }
    uint64_t v6 = 0;
    *a6 = v13;
  }
  return v6;
}

uint64_t mosyntkbaccphr_CheckMatchingConsFeat2(uint64_t a1, uint64_t a2, int a3, unsigned int a4, int a5, unsigned __int16 *a6, char *a7)
{
  v13[3] = *MEMORY[0x263EF8340];
  memset(v13, 0, 24);
  *a7 = 0;
  GetFeat(a2, a4, v13);
  uint64_t result = 0;
  if (a3 == a5)
  {
    if (LOWORD(v13[0]))
    {
      return mosyntknowl_CheckUnifiable(a1, (unsigned __int16 *)v13, a6, a7);
    }
    else
    {
      uint64_t result = 0;
      *a7 = 1;
    }
  }
  return result;
}

uint64_t GetFeat(uint64_t a1, unsigned int a2, _WORD *a3)
{
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  uint64_t result = accphr_getFeatList(a1, a2, v10);
  __int16 v5 = v10[0];
  if (SLODWORD(v10[0]) >= 1)
  {
    uint64_t v6 = (int *)v10 + 1;
    uint64_t v7 = a3 + 1;
    uint64_t v8 = LODWORD(v10[0]);
    do
    {
      int v9 = *v6++;
      *v7++ = v9;
      --v8;
    }
    while (v8);
  }
  *a3 = v5;
  return result;
}

uint64_t mosyntkbaccphr_CheckMatchingConsFeat3(uint64_t a1, uint64_t a2, int a3, unsigned __int16 *a4, int a5, unsigned int a6, char *a7)
{
  v13[3] = *MEMORY[0x263EF8340];
  memset(v13, 0, 24);
  *a7 = 0;
  GetFeat(a2, a6, v13);
  uint64_t result = 0;
  if (a3 == a5)
  {
    if (*a4)
    {
      return mosyntknowl_CheckUnifiable(a1, a4, (unsigned __int16 *)v13, a7);
    }
    else
    {
      uint64_t result = 0;
      *a7 = 1;
    }
  }
  return result;
}

uint64_t mosyntkbaccphr_GetNodeNegated(uint64_t a1, int a2)
{
  return accphr_getNodeNegated(a1, a2);
}

uint64_t mosyntkbaccphr_GetInstrRight(uint64_t a1, int a2)
{
  return accphr_getInstrRight(a1, a2);
}

uint64_t mosyntkbaccphr_GetRuleSetIsSubset(uint64_t a1, int a2)
{
  return accphr_getRuleSetIsSubset(a1, a2);
}

uint64_t mosyntkbaccphr_LookupAccPhrRule(uint64_t a1, uint64_t a2, int a3, __int16 *a4, unsigned char *a5, uint64_t a6)
{
  Firstint Rule = accphr_getFirstRule(a2, a3);
  char v19 = 0;
  if (FirstRule == accphr_Nil())
  {
    uint64_t v13 = 0;
LABEL_3:
    if (FirstRule == accphr_Nil())
    {
      *a5 = 0;
    }
    else
    {
      *a5 = 1;
      *(void *)a6 = a2;
      *(_DWORD *)(a6 + 40) = FirstRule;
      *(_DWORD *)(a6 + 8) = a3;
      return mosyntknowl_CopyFeatList(a4, (_WORD *)(a6 + 16));
    }
  }
  else
  {
    while (1)
    {
      int Rule = accphr_getRule(1, a2, FirstRule);
      int Node = accphr_getNode(5, a2, Rule);
      int v16 = accphr_getRule(1, a2, FirstRule);
      unsigned int v17 = accphr_getNode(6, a2, v16);
      uint64_t v13 = mosyntkbaccphr_CheckMatchingConsFeat2(a1, a2, Node, v17, a3, (unsigned __int16 *)a4, &v19);
      if ((v13 & 0x80000000) != 0) {
        break;
      }
      if (!v19) {
        Firstint Rule = accphr_getRule(14, a2, FirstRule);
      }
      if (FirstRule == accphr_Nil() || v19) {
        goto LABEL_3;
      }
    }
  }
  return v13;
}

uint64_t mosyntkbaccphr_GetNextAccPhrEntry(uint64_t a1, uint64_t a2, unsigned char *a3, uint64_t a4)
{
  *a3 = 0;
  int Rule = accphr_getRule(14, a2, *(_DWORD *)(a4 + 40));
  char v15 = 0;
  if (Rule == accphr_Nil())
  {
    uint64_t v9 = 0;
LABEL_3:
    if (Rule == accphr_Nil())
    {
      *a3 = 0;
    }
    else
    {
      *a3 = 1;
      *(_DWORD *)(a4 + 40) = Rule;
    }
  }
  else
  {
    while (1)
    {
      int v10 = accphr_getRule(1, a2, Rule);
      int Node = accphr_getNode(5, a2, v10);
      int v12 = accphr_getRule(1, a2, Rule);
      unsigned int v13 = accphr_getNode(6, a2, v12);
      uint64_t v9 = mosyntkbaccphr_CheckMatchingConsFeat2(a1, a2, Node, v13, *(_DWORD *)(a4 + 8), (unsigned __int16 *)(a4 + 16), &v15);
      if ((v9 & 0x80000000) != 0) {
        break;
      }
      if (!v15) {
        int Rule = accphr_getRule(14, a2, Rule);
      }
      if (Rule == accphr_Nil() || v15) {
        goto LABEL_3;
      }
    }
  }
  return v9;
}

uint64_t mosyntkbaccphr_WriteAccPhrNode(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (accphr_getNodeNegated(a3, a4))
  {
    uint64_t v8 = mosyntbase_Wr(a1, 126);
    if ((v8 & 0x80000000) != 0) {
      return v8;
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  int v20 = 0;
  memset(v19, 0, sizeof(v19));
  switch(accphr_getNode(3, a3, a4))
  {
    case 0u:
      uint64_t v9 = "?";
      goto LABEL_7;
    case 1u:
      unsigned int Node = accphr_getNode(4, a3, a4);
      uint64_t v14 = mosyntkbsymtab_AtomSymString(a1, a2, Node, (char *)v19, 100);
      if ((v14 & 0x80000000) != 0) {
        goto LABEL_25;
      }
      uint64_t v14 = mosyntbase_Wr(a1, 94);
      if ((v14 & 0x80000000) != 0) {
        goto LABEL_25;
      }
      uint64_t v9 = (char *)v19;
      uint64_t v10 = a1;
      int v11 = 100;
LABEL_8:
      uint64_t v12 = mosyntbase_WString(v10, (unsigned __int8 *)v9, v11);
LABEL_13:
      uint64_t v8 = v12;
      if ((v12 & 0x80000000) != 0) {
        return v8;
      }
LABEL_14:
      if (accphr_getNodeMatchOp(a3, a4) == 6)
      {
        unsigned int v17 = "*";
      }
      else if (accphr_getNodeMatchOp(a3, a4) == 3)
      {
        unsigned int v17 = "+";
      }
      else if (accphr_getNodeMatchOp(a3, a4) == 1)
      {
        unsigned int v17 = "$";
      }
      else
      {
        if (accphr_getNodeMatchOp(a3, a4) != 7) {
          return v8;
        }
        unsigned int v17 = "@";
      }
      uint64_t v14 = mosyntbase_WString(a1, (unsigned __int8 *)v17, 0);
LABEL_25:
      uint64_t v8 = v14;
      break;
    case 2u:
      unsigned int v15 = accphr_getNode(5, a3, a4);
      unsigned int v16 = accphr_getNode(6, a3, a4);
      uint64_t v12 = WriteConsFeat1(a1, a2, a3, v15, v16);
      goto LABEL_13;
    case 3u:
      switch(accphr_getNode(7, a3, a4))
      {
        case 1u:
          uint64_t v9 = "'OBR'";
          break;
        case 2u:
          uint64_t v9 = "'BOS'";
          break;
        case 3u:
          uint64_t v9 = "'EOS'";
          break;
        case 4u:
          uint64_t v9 = "'QOS'";
          break;
        default:
          uint64_t v9 = "'(unknown property)'";
          break;
      }
LABEL_7:
      uint64_t v10 = a1;
      int v11 = 0;
      goto LABEL_8;
    default:
      goto LABEL_14;
  }
  return v8;
}

uint64_t WriteConsFeat1(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  v9[3] = *MEMORY[0x263EF8340];
  memset(v9, 0, 24);
  GetFeat(a3, a5, v9);
  uint64_t result = mosyntkbsymtab_WriteCons(a1, a2, a4);
  if ((result & 0x80000000) == 0 && SLOWORD(v9[0]) >= 1)
  {
    uint64_t result = mosyntbase_WString(a1, " ", 0);
    if ((result & 0x80000000) == 0) {
      return mosyntkbsymtab_WriteFeatList(a1, a2, (__int16 *)v9);
    }
  }
  return result;
}

uint64_t mosyntkbaccphr_WriteRuleHeadline(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  int Rule = accphr_getRule(0, a3, a4);
  unsigned int v9 = accphr_getRule(0, a3, a4);
  memset(v19, 0, 32);
  if (Rule >= 0) {
    unsigned int v10 = v9;
  }
  else {
    unsigned int v10 = -v9;
  }
  memset(&v19[2], 0, 64);
  int v20 = 0;
  uint64_t result = mosyntkbsymtab_AtomSymString(a1, a2, v10, (char *)v19, 100);
  if ((result & 0x80000000) == 0)
  {
    if ((int)accphr_getRule(0, a3, a4) < 1) {
      uint64_t result = mosyntbase_WriteMessage(a1, "^%s <== ", 0, (unsigned __int8 *)v19, 100, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
    }
    else {
      uint64_t result = mosyntbase_WriteMessage(a1, "^%s <-- ", 0, (unsigned __int8 *)v19, 100, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0);
    }
    if ((result & 0x80000000) == 0)
    {
      int v12 = accphr_getRule(1, a3, a4);
      unsigned int Node = accphr_getNode(5, a3, v12);
      int v14 = accphr_getRule(1, a3, a4);
      unsigned int v15 = accphr_getNode(6, a3, v14);
      uint64_t result = WriteConsFeat1(a1, a2, a3, Node, v15);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = mosyntbase_WString(a1, " [ ", 0);
        if ((result & 0x80000000) == 0)
        {
          int v16 = accphr_getRule(2, a3, a4);
          uint64_t result = mosyntkbaccphr_WriteAccPhrNode(a1, a2, a3, v16);
          if ((result & 0x80000000) == 0)
          {
            uint64_t result = mosyntbase_WString(a1, ", ", 0);
            if ((result & 0x80000000) == 0)
            {
              int v17 = accphr_getRule(3, a3, a4);
              uint64_t result = mosyntkbaccphr_WriteAccPhrNode(a1, a2, a3, v17);
              if ((result & 0x80000000) == 0)
              {
                uint64_t result = mosyntbase_WString(a1, ", ", 0);
                if ((result & 0x80000000) == 0)
                {
                  int v18 = accphr_getRule(4, a3, a4);
                  uint64_t result = mosyntkbaccphr_WriteAccPhrNode(a1, a2, a3, v18);
                  if ((result & 0x80000000) == 0) {
                    return mosyntbase_WString(a1, " ]", 0);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mosyntkbaccphr_WriteChildrenList(uint64_t a1, uint64_t *a2, uint64_t a3, unsigned __int8 *a4, int a5, int a6)
{
  int v6 = a6;
  if (accphr_Nil() != a6)
  {
    while (1)
    {
      uint64_t v13 = mosyntbase_WString(a1, a4, a5);
      if ((v13 & 0x80000000) != 0) {
        return v13;
      }
      uint64_t v13 = mosyntbase_WString(a1, "[ ", 0);
      if ((v13 & 0x80000000) != 0) {
        return v13;
      }
      for (int i = accphr_getChildren(1, a3, v6); ; int i = accphr_getNode(8, a3, v15))
      {
        int v15 = i;
        if (i == accphr_Nil()) {
          break;
        }
        uint64_t v13 = mosyntkbaccphr_WriteAccPhrNode(a1, a2, a3, v15);
        if ((v13 & 0x80000000) != 0) {
          return v13;
        }
        int Node = accphr_getNode(8, a3, v15);
        if (Node != accphr_Nil())
        {
          uint64_t v13 = mosyntbase_WString(a1, ", ", 0);
          if ((v13 & 0x80000000) != 0) {
            return v13;
          }
        }
      }
      uint64_t v13 = mosyntbase_WString(a1, " ]", 0);
      if ((v13 & 0x80000000) != 0) {
        return v13;
      }
      int ChildrenOpType = accphr_getChildrenOpType(a3, v6);
      if (ChildrenOpType == 2)
      {
        uint64_t v18 = a1;
        char v19 = " :FC";
      }
      else
      {
        if (ChildrenOpType != 1) {
          goto LABEL_17;
        }
        uint64_t v18 = a1;
        char v19 = " :OL";
      }
      uint64_t v13 = mosyntbase_WString(v18, (unsigned __int8 *)v19, 0);
      if ((v13 & 0x80000000) != 0) {
        return v13;
      }
LABEL_17:
      Childreuint64_t n = accphr_getChildren(2, a3, v6);
      if (Children == accphr_Nil()) {
        uint64_t v21 = mosyntbase_WLn(a1);
      }
      else {
        uint64_t v21 = mosyntbase_WStringLn(a1, "||", 0);
      }
      uint64_t v12 = v21;
      if ((v21 & 0x80000000) == 0)
      {
        int v6 = accphr_getChildren(2, a3, v6);
        if (v6 != accphr_Nil()) {
          continue;
        }
      }
      return v12;
    }
  }
  return 0;
}

uint64_t mosyntkbaccphr_WriteInstruction(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  v26[2] = *MEMORY[0x263EF8340];
  accphr_getInstrType(a3, a4);
  if (accphr_getInstrType(a3, a4) <= 6)
  {
    if (accphr_getInstrTargetRange(a3, a4))
    {
      uint64_t v8 = (unsigned __int8 *)(accphr_getInstrRight(a3, a4) ? "r_" : "l_");
      uint64_t v10 = mosyntbase_WString(a1, v8, 0);
      if ((v10 & 0x80000000) != 0) {
        return v10;
      }
    }
    if (accphr_getInstrTargetRange(a3, a4) == 2)
    {
      int v11 = "syll_";
    }
    else
    {
      if (accphr_getInstrTargetRange(a3, a4) != 3) {
        goto LABEL_16;
      }
      if (accphr_getInstr(5, a3, a4) == -1)
      {
        int v11 = "prsyll_";
      }
      else if (accphr_getInstr(5, a3, a4))
      {
        int v11 = "flsyll_";
      }
      else
      {
        int v11 = "ssyll_";
      }
    }
    uint64_t v10 = mosyntbase_WString(a1, (unsigned __int8 *)v11, 0);
    if ((v10 & 0x80000000) != 0) {
      return v10;
    }
LABEL_16:
    char v12 = 0;
    uint64_t v13 = "XL";
    int v14 = "L";
    int v15 = "H";
    int v16 = "XH";
    switch(accphr_getInstrType(a3, a4))
    {
      case 0u:
        if (accphr_getInstr(2, a3, a4))
        {
          uint64_t v10 = mosyntbase_WString(a1, "br", 0);
          if ((v10 & 0x80000000) != 0) {
            return v10;
          }
          char v12 = 0;
          uint64_t v13 = "XW";
          int v14 = "W";
          int v15 = "S";
        }
        else
        {
          uint64_t v10 = mosyntbase_WString(a1, "bnd", 0);
          if ((v10 & 0x80000000) != 0) {
            return v10;
          }
          uint64_t v13 = "XW";
          int v14 = "W";
          int v15 = "S";
          char v12 = 1;
        }
        int v16 = "XS";
        goto LABEL_27;
      case 2u:
        int v17 = "emph";
        goto LABEL_25;
      case 3u:
        int v17 = "rate";
        goto LABEL_25;
      case 4u:
        int v17 = "pitch";
        goto LABEL_25;
      case 5u:
        int v17 = "volume";
        goto LABEL_25;
      case 6u:
        int v17 = "stress";
LABEL_25:
        uint64_t v10 = mosyntbase_WString(a1, (unsigned __int8 *)v17, 0);
        if ((v10 & 0x80000000) != 0) {
          return v10;
        }
        char v12 = 0;
LABEL_27:
        int Instr = accphr_getInstr(0, a3, a4);
        if (Instr != accphr_Nil())
        {
          int v19 = accphr_getInstr(0, a3, a4);
          if (accphr_getNode(3, a3, v19))
          {
            uint64_t v10 = mosyntbase_WString(a1, "(", 0);
            if ((v10 & 0x80000000) != 0) {
              return v10;
            }
            int v20 = accphr_getInstr(0, a3, a4);
            uint64_t v10 = mosyntkbaccphr_WriteAccPhrNode(a1, a2, a3, v20);
            if ((v10 & 0x80000000) != 0) {
              return v10;
            }
            uint64_t v10 = mosyntbase_WString(a1, ")", 0);
            if ((v10 & 0x80000000) != 0) {
              return v10;
            }
          }
        }
        if (v12)
        {
          return mosyntbase_WString(a1, " = default", 0);
        }
        uint64_t v25 = 0;
        v26[0] = 0;
        *(void *)((char *)v26 + 5) = 0;
        BOOL v24 = 0;
        int v22 = accphr_getInstr(2, a3, a4);
        uint64_t v23 = "(no value)";
        switch(v22)
        {
          case 0:
            goto LABEL_49;
          case 1:
            uint64_t v23 = "default";
            goto LABEL_49;
          case 2:
            uint64_t v23 = (char *)v13;
            goto LABEL_49;
          case 3:
            uint64_t v23 = (char *)v14;
            goto LABEL_49;
          case 4:
            uint64_t v23 = "M";
            goto LABEL_49;
          case 5:
            uint64_t v23 = (char *)v15;
            goto LABEL_49;
          case 6:
            uint64_t v23 = (char *)v16;
LABEL_49:
            uint64_t v9 = mosyntbase_CCopy((unsigned __int8 *)v23, 0, (uint64_t)&v25, 21, &v24);
            if ((v9 & 0x80000000) == 0) {
              goto LABEL_50;
            }
            return v9;
          default:
            uint64_t v9 = 0;
LABEL_50:
            if (!accphr_getInstr(2, a3, a4)) {
              return v9;
            }
            uint64_t v10 = mosyntbase_WString(a1, " = ", 0);
            if ((v10 & 0x80000000) == 0) {
              uint64_t v10 = mosyntbase_WString(a1, (unsigned __int8 *)&v25, 21);
            }
            break;
        }
        break;
      default:
        goto LABEL_27;
    }
    return v10;
  }
  return 0;
}

uint64_t mosyntkbaccphr_WritePromTemplate(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t result = mosyntbase_WString(a1, "<prom =", 0);
  if ((result & 0x80000000) == 0)
  {
    Childreuint64_t n = accphr_getChildren(1, a3, a4);
    if (Children == accphr_Nil())
    {
LABEL_6:
      return mosyntbase_WStringLn(a1, " >", 0);
    }
    else
    {
      while (1)
      {
        HIDWORD(v10) = 0;
        LODWORD(v10) = 0;
        *(void *)((char *)&v10 + 4) = accphr_getNode(2, a3, Children);
        uint64_t result = mosyntbase_WriteMessage(a1, " [%i] ", 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, v10);
        if ((result & 0x80000000) != 0) {
          break;
        }
        uint64_t result = mosyntkbaccphr_WriteAccPhrNode(a1, a2, a3, Children);
        if ((result & 0x80000000) != 0) {
          break;
        }
        Childreuint64_t n = accphr_getNode(8, a3, Children);
        if (Children == accphr_Nil()) {
          goto LABEL_6;
        }
      }
    }
  }
  return result;
}

uint64_t mosyntkbaccphr_PhraseTypeToString(int a1, uint64_t a2, int a3)
{
  BOOL v5 = 0;
  if ((a1 - 1) > 8) {
    int v3 = &byte_20D5A22AE;
  }
  else {
    int v3 = off_264107F98[a1 - 1];
  }
  return mosyntbase_CCopy((unsigned __int8 *)v3, 0, a2, a3, &v5);
}

uint64_t mosyntkbaccphr_StringToPhraseType(uint64_t a1, unsigned __int8 *a2, int a3, int *a4)
{
  if (mosyntbase_CEqual(a2, a3, "P", 0))
  {
    int v8 = 1;
LABEL_19:
    *a4 = v8;
    return 0;
  }
  if (mosyntbase_CEqual(a2, a3, "T", 0))
  {
    int v8 = 2;
    goto LABEL_19;
  }
  if (mosyntbase_CEqual(a2, a3, "S", 0))
  {
    int v8 = 3;
    goto LABEL_19;
  }
  if (mosyntbase_CEqual(a2, a3, "Y", 0))
  {
    int v8 = 4;
    goto LABEL_19;
  }
  if (mosyntbase_CEqual(a2, a3, "W", 0))
  {
    int v8 = 5;
    goto LABEL_19;
  }
  if (mosyntbase_CEqual(a2, a3, "AI", 0))
  {
    int v8 = 6;
    goto LABEL_19;
  }
  if (mosyntbase_CEqual(a2, a3, "AM", 0))
  {
    int v8 = 7;
    goto LABEL_19;
  }
  if (mosyntbase_CEqual(a2, a3, "AF", 0))
  {
    int v8 = 8;
    goto LABEL_19;
  }
  if (mosyntbase_CEqual(a2, a3, "E", 0))
  {
    int v8 = 9;
    goto LABEL_19;
  }
  return mosyntbase_WriteDevelMessage(a1, "***** illegal phrase type '%s'\\n", 0, a2, a3, (unsigned __int8 *)&byte_20D5A22AE, 0, (unsigned __int8 *)&byte_20D5A22AE, 0, 0, 0, 0);
}

uint64_t mosyntkbaccphr_SimplifiedPhraseType(int a1)
{
  if ((a1 - 1) > 8) {
    return 0;
  }
  else {
    return dword_20D62D5B4[a1 - 1];
  }
}

BOOL mosyntkbfst_IsValidPair(_DWORD *a1)
{
  return fst_validPair(a1);
}

uint64_t mosyntkbfst_GetFirstSameInSymPair(__int16 *a1, __int16 a2, uint64_t a3, BOOL *a4)
{
  fst_firstSamePair(a1, a2, a3);
  *a4 = v5 != 0;
  return 0;
}

uint64_t mosyntkbfst_GetNextSameInSymPair(uint64_t a1, int *a2, BOOL *a3)
{
  *a3 = fst_nextSamePair(a1, a2) != 0;
  return 0;
}

uint64_t mosyntkbfst_OutSym(uint64_t a1, _DWORD *a2)
{
  int v4 = 0;
  __int16 v3 = 0;
  fst_getPair(a1, a2, (_WORD *)&v4 + 1, &v4, &v3);
  return (__int16)v4;
}

uint64_t mosyntkbfst_GetTransductionMode(uint64_t a1, _DWORD *a2)
{
  return 0;
}

uint64_t mosyntkbfst_WriteGraphPair(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4, int a5)
{
  return WritePair(a1, a2, 1, a3, a4, a5);
}

uint64_t WritePair(uint64_t a1, uint64_t *a2, int a3, uint64_t a4, _DWORD *a5, int a6)
{
  int v14 = 0;
  __int16 v13 = 0;
  fst_getPair(a4, a5, (_WORD *)&v14 + 1, &v14, &v13);
  if ((a6 | 2) == 2)
  {
    if (HIWORD(v14))
    {
      uint64_t result = mosyntbase_WString(a1, "\"", 0);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      if (a3)
      {
        uint64_t result = mosyntkbsymtab_WriteGraphSym(a1, (uint64_t)a2, SHIWORD(v14));
        if ((result & 0x80000000) != 0) {
          return result;
        }
      }
      else
      {
        uint64_t result = mosyntkbsymtab_WritePhonSym(a1, a2, SHIWORD(v14));
        if ((result & 0x80000000) != 0) {
          return result;
        }
      }
      int v11 = "\"";
    }
    else
    {
      int v11 = "@";
    }
    uint64_t result = mosyntbase_WString(a1, (unsigned __int8 *)v11, 0);
    if ((result & 0x80000000) != 0) {
      return result;
    }
  }
  else
  {
    uint64_t result = 0;
  }
  if (a6 == 2)
  {
    uint64_t result = mosyntbase_WString(a1, "/", 0);
    if ((result & 0x80000000) != 0) {
      return result;
    }
  }
  else if ((a6 - 1) > 1)
  {
    return result;
  }
  if (!(_WORD)v14)
  {
    char v12 = "@";
    return mosyntbase_WString(a1, (unsigned __int8 *)v12, 0);
  }
  uint64_t result = mosyntbase_WString(a1, "\"", 0);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  if (!a3)
  {
    uint64_t result = mosyntkbsymtab_WritePhonSym(a1, a2, (__int16)v14);
    if ((result & 0x80000000) != 0) {
      return result;
    }
    goto LABEL_23;
  }
  uint64_t result = mosyntkbsymtab_WriteGraphSym(a1, (uint64_t)a2, (__int16)v14);
  if ((result & 0x80000000) == 0)
  {
LABEL_23:
    char v12 = "\"";
    return mosyntbase_WString(a1, (unsigned __int8 *)v12, 0);
  }
  return result;
}

uint64_t mosyntkbfst_WritePhonPair(uint64_t a1, uint64_t *a2, uint64_t a3, _DWORD *a4, int a5)
{
  return WritePair(a1, a2, 0, a3, a4, a5);
}

uint64_t mosyntkbsgram_NilIter(void *a1)
{
  *a1 = 0;
  a1[1] = -1;
  return 0;
}

BOOL mosyntkbsgram_IsNilIter(void *a1)
{
  return *a1 == 0;
}

uint64_t mosyntkbsgram_StartCons(_DWORD *a1)
{
  unsigned int v2 = 0;
  sgram_GetStartCons(a1, &v2);
  return v2;
}

BOOL mosyntkbsgram_HasEmptyRules(BOOL a1)
{
  return sgram_HasEmptyRules(a1);
}

BOOL mosyntkbsgram_HasSimpleFollowRel(BOOL a1)
{
  return sgram_HasSimpleFollowRel(a1);
}

uint64_t mosyntkbsgram_GetNextRuleSameLast(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  return sgram_GetNextRuleSameLast(a2, a3, a4, a5, a6);
}

uint64_t mosyntkbsgram_GetNextRuleSameFirst(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  return sgram_GetNextRuleSameFirst(a2, a3, a4, a5, a6);
}

uint64_t mosyntkbsgram_GetFirstEmptyRule(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  int v5 = 0;
  int v4 = 0;
  sgram_GetFirstEmptyRule(a1, a2, a3, &v5, &v4);
  return 0;
}

uint64_t mosyntkbsgram_GetNextEmptyRule(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  int v5 = 0;
  int v4 = 0;
  sgram_GetNextEmptyRule(a2, a3, &v5, &v4);
  return 0;
}

uint64_t mosyntkbsgram_GetRuleFeatLists(uint64_t *a1, _WORD *a2, _WORD *a3, _WORD *a4)
{
  v15[0] = 0;
  v15[1] = 0;
  int v16 = 0;
  v13[0] = 0;
  v13[1] = 0;
  int v14 = 0;
  v11[0] = 0;
  v11[1] = 0;
  int v12 = 0;
  sgram_GetRuleFeatLists(a1, v15, v13, v11);
  __int16 v7 = v15[0];
  if (SLOWORD(v15[0]) >= 1) {
    memcpy(a2 + 1, (char *)v15 + 2, 2 * LOWORD(v15[0]));
  }
  *a2 = v7;
  __int16 v8 = v13[0];
  if (SLOWORD(v13[0]) >= 1) {
    memcpy(a3 + 1, (char *)v13 + 2, 2 * LOWORD(v13[0]));
  }
  *a3 = v8;
  __int16 v9 = v11[0];
  if (SLOWORD(v11[0]) >= 1) {
    memcpy(a4 + 1, (char *)v11 + 2, 2 * LOWORD(v11[0]));
  }
  *a4 = v9;
  return 0;
}

uint64_t mosyntkbsgram_GetRuleVisAndCost(_DWORD *a1, unsigned char *a2, _DWORD *a3)
{
  int v5 = 0;
  sgram_GetRuleVisAndCost(a1, &v5, a3);
  *a2 = v5;
  return 0;
}

BOOL mosyntkbsgram_IsFollowerCons(BOOL a1, int a2, int a3)
{
  return sgram_IsFollowerCons(a1, a2, a3);
}

uint64_t sgram_OpenRiffForReading(_WORD *a1, uint64_t a2, const char *a3, uint64_t *a4)
{
  return ssftriff_reader_ObjOpen(a1, a2, 2, a3, "SGRM", 1031, a4);
}

uint64_t sgram_CloseRiff(void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (a1)
  {
    LODWORD(result) = ssftriff_reader_ObjClose(*a1, a2, a3, a4, a5, a6, a7, a8);
    if (v8 >= 0) {
      uint64_t result = result;
    }
    else {
      uint64_t result = v8;
    }
    *a1 = 0;
  }
  else if ((int)a2 < 0)
  {
    return a2;
  }
  else
  {
    return 2371887111;
  }
  return result;
}

uint64_t sgram_ReadFromRiff(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = -1923080188;
  if (!a2) {
    return 2371887111;
  }
  uint64_t result = openChunk(a1, "GRAM", a3, a4, a5, a6, a7, a8);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  uint64_t v56 = 0;
  unsigned __int8 v59 = 0;
  unsigned int v57 = 0;
  int v58 = 0;
  int HashTab = ssftriff_reader_OpenChunk(a1, &v58, &v57, &v56, v12, v13, v14, v15);
  if (HashTab < 0)
  {
LABEL_18:
    int v8 = HashTab;
    goto LABEL_21;
  }
  if (!(v58 ^ 0x53445247 | v59) && v57 == 44)
  {
    int v17 = v56;
    *(_DWORD *)a2 = *v56;
    *(_DWORD *)(a2 + 8) = v17[1];
    *(_DWORD *)(a2 + 32) = v17[2];
    *(_DWORD *)(a2 + 56) = v17[3];
    *(_DWORD *)(a2 + 80) = v17[4];
    *(_DWORD *)(a2 + 104) = v17[5];
    *(_DWORD *)(a2 + 128) = v17[6];
    *(_DWORD *)(a2 + 160) = v17[7];
    *(_DWORD *)(a2 + 136) = v17[8];
    *(_DWORD *)(a2 + 208) = v17[9];
    *(_DWORD *)(a2 + 184) = v17[10];
    int HashTab = ssftriff_reader_CloseChunk(a1);
    if ((HashTab & 0x80000000) == 0)
    {
      int HashTab = detachChunk(a1, "GRFL", (uint64_t *)(a2 + 16), (void *)(a2 + 24), v18, v19, v20, v21);
      if ((HashTab & 0x80000000) == 0)
      {
        int HashTab = detachChunk(a1, "GRER", (uint64_t *)(a2 + 40), (void *)(a2 + 48), v22, v23, v24, v25);
        if ((HashTab & 0x80000000) == 0)
        {
          int HashTab = openChunk(a1, "GRRU", v26, v27, v28, v29, v30, v31);
          if ((HashTab & 0x80000000) == 0)
          {
            int v36 = detachChunk(a1, "GRHE", (uint64_t *)(a2 + 64), (void *)(a2 + 72), v32, v33, v34, v35);
            if ((v36 & 0x80000000) == 0)
            {
              int v36 = detachChunk(a1, "GRHS", (uint64_t *)(a2 + 88), (void *)(a2 + 96), v37, v38, v39, v40);
              if ((v36 & 0x80000000) == 0) {
                int v36 = detachChunk(a1, "GRHS", (uint64_t *)(a2 + 112), (void *)(a2 + 120), v41, v42, v43, v44);
              }
            }
            int v8 = v36;
            int v45 = ssftriff_reader_CloseChunk(a1);
            if (v8 >= 0) {
              int v8 = v45;
            }
            if (v8 < 0) {
              goto LABEL_21;
            }
            int HashTab = sgram_ReadHashTab(a1, "GRSE", (uint64_t *)(a2 + 136), v46, v47, v48, v49, v50);
            if ((HashTab & 0x80000000) == 0) {
              int HashTab = sgram_ReadHashTab(a1, "GRRE", (uint64_t *)(a2 + 184), v51, v52, v53, v54, v55);
            }
          }
        }
      }
    }
    goto LABEL_18;
  }
  ssftriff_reader_CloseChunk(a1);
LABEL_21:
  LODWORD(result) = ssftriff_reader_CloseChunk(a1);
  if (v8 >= 0) {
    return result;
  }
  else {
    return v8;
  }
}

uint64_t sgram_ReleaseData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 2371887111;
  }
  int v16 = ssftriff_reader_ReleaseChunkData(*(void **)(a1 + 16), a2, a3, a4, a5, a6, a7, a8);
  int v17 = *(void **)(a1 + 40);
  if (v17)
  {
    int v18 = ssftriff_reader_ReleaseChunkData(v17, v9, v10, v11, v12, v13, v14, v15);
    if (v16 >= 0) {
      int v16 = v18;
    }
  }
  int v19 = ssftriff_reader_ReleaseChunkData(*(void **)(a1 + 64), v9, v10, v11, v12, v13, v14, v15);
  if (v16 >= 0) {
    int v16 = v19;
  }
  int v27 = ssftriff_reader_ReleaseChunkData(*(void **)(a1 + 88), v20, v21, v22, v23, v24, v25, v26);
  if (v16 >= 0) {
    int v16 = v27;
  }
  int v35 = ssftriff_reader_ReleaseChunkData(*(void **)(a1 + 112), v28, v29, v30, v31, v32, v33, v34);
  if (v16 >= 0) {
    int v16 = v35;
  }
  int v43 = sgram_ReleaseHashTab(a1 + 136, v36, v37, v38, v39, v40, v41, v42);
  if (v16 >= 0) {
    int v16 = v43;
  }
  LODWORD(result) = sgram_ReleaseHashTab(a1 + 184, v44, v45, v46, v47, v48, v49, v50);
  if (v16 >= 0) {
    return result;
  }
  else {
    return v16;
  }
}

uint64_t sgram_ReleaseHashTab(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void **)(a1 + 8);
  if (v9) {
    uint64_t v10 = ssftriff_reader_ReleaseChunkData(v9, a2, a3, a4, a5, a6, a7, a8);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = *(void **)(a1 + 32);
  if (v11)
  {
    unsigned int v12 = ssftriff_reader_ReleaseChunkData(v11, a2, a3, a4, a5, a6, a7, a8);
    if ((int)v10 >= 0) {
      return v12;
    }
    else {
      return v10;
    }
  }
  return v10;
}

uint64_t openChunk(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v15 = 0;
  unsigned int v13 = 0;
  *(_DWORD *)__s1 = 0;
  uint64_t v12 = 0;
  uint64_t v10 = ssftriff_reader_OpenChunk(a1, __s1, &v13, &v12, a5, a6, a7, a8);
  if ((v10 & 0x80000000) == 0 && strcmp(__s1, a2))
  {
    ssftriff_reader_CloseChunk(a1);
    return 2371887108;
  }
  return v10;
}

uint64_t detachChunk(uint64_t a1, const char *a2, uint64_t *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v22 = 0;
  unsigned int v20 = 0;
  *(_DWORD *)__s1 = 0;
  uint64_t v12 = ssftriff_reader_OpenChunk(a1, __s1, &v20, a4, a5, a6, a7, a8);
  if ((v12 & 0x80000000) != 0) {
    return v12;
  }
  if (!strcmp(__s1, a2))
  {
    if (!v20) {
      return ssftriff_reader_CloseChunk(a1);
    }
    uint64_t v18 = ssftriff_reader_DetachChunkData(a1, a3, a4, v13, v14, v15, v16, v17);
    uint64_t v12 = ssftriff_reader_CloseChunk(a1);
    if ((v18 & 0x80000000) != 0) {
      return v18;
    }
    return v12;
  }
  ssftriff_reader_CloseChunk(a1);
  return 2371887108;
}

uint64_t sgram_ReadHashTab(uint64_t a1, const char *a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = openChunk(a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  if ((result & 0x80000000) == 0)
  {
    int v15 = detachChunk(a1, "GRHE", a3 + 1, a3 + 2, v11, v12, v13, v14);
    if ((v15 & 0x80000000) == 0) {
      int v15 = detachChunk(a1, "GRHS", a3 + 4, a3 + 5, v16, v17, v18, v19);
    }
    int v20 = v15;
    LODWORD(result) = ssftriff_reader_CloseChunk(a1);
    if (v20 >= 0) {
      return result;
    }
    else {
      return v20;
    }
  }
  return result;
}

uint64_t wgram_OpenRiffForReading(_WORD *a1, uint64_t a2, const char *a3, uint64_t *a4)
{
  return ssftriff_reader_ObjOpen(a1, a2, 2, a3, "WGRM", 1031, a4);
}

uint64_t wgram_CloseRiff(void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (a1)
  {
    LODWORD(result) = ssftriff_reader_ObjClose(*a1, a2, a3, a4, a5, a6, a7, a8);
    if (v8 < 0) {
      uint64_t result = v8;
    }
    else {
      uint64_t result = result;
    }
    *a1 = 0;
  }
  else if ((int)a2 < 0)
  {
    return a2;
  }
  else
  {
    return 7;
  }
  return result;
}

uint64_t wgram_ReadFromRiff(_WORD *a1, int a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v34 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v34);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t v7 = heap_Calloc(*(void **)(v34 + 8), 1, 344);
  *a4 = v7;
  if (!v7) {
    return 2371887114;
  }
  uint64_t v12 = v7;
  unsigned __int8 v37 = 0;
  unsigned int v35 = 0;
  int v36 = 0;
  uint64_t v17 = ssftriff_reader_OpenChunk(a3, &v36, &v35, 0, v8, v9, v10, v11);
  if ((v17 & 0x80000000) == 0)
  {
    if (!(v36 ^ 0x4741464E | v37))
    {
      unsigned __int8 v41 = 0;
      unsigned int v39 = 0;
      int v40 = 0;
      uint64_t v38 = 0;
      int HashTab = ssftriff_reader_OpenChunk(a3, &v40, &v39, &v38, v13, v14, v15, v16);
      if ((HashTab & 0x80000000) == 0)
      {
        if (!(v40 ^ 0x5341464E | v41))
        {
          uint64_t v19 = v38;
          *(_DWORD *)(v12 + 256) = *v38;
          *(_DWORD *)(v12 + 260) = v19[1];
        }
        int HashTab = ssftriff_reader_CloseChunk(a3);
        if ((HashTab & 0x80000000) == 0)
        {
          int HashTab = wgram_ReadHashTab(a3, v12 + 264, v20, v21, v22, v23, v24, v25);
          if ((HashTab & 0x80000000) == 0) {
            int HashTab = wgram_ReadHashTab(a3, v12 + 304, v26, v27, v28, v29, v30, v31);
          }
        }
      }
      LODWORD(v17) = HashTab;
    }
    unsigned int v32 = ssftriff_reader_CloseChunk(a3);
    if ((int)v17 >= 0) {
      return v32;
    }
    else {
      return v17;
    }
  }
  return v17;
}

uint64_t wgram_ReleaseData(void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 2371887111;
  }
  int v9 = ssftriff_reader_ReleaseChunkData(a1[36], a2, a3, a4, a5, a6, a7, a8);
  int v17 = ssftriff_reader_ReleaseChunkData(a1[37], v10, v11, v12, v13, v14, v15, v16);
  if (v9 >= 0) {
    int v25 = v17;
  }
  else {
    int v25 = v9;
  }
  int v26 = ssftriff_reader_ReleaseChunkData(a1[41], v18, v19, v20, v21, v22, v23, v24);
  unsigned int v34 = ssftriff_reader_ReleaseChunkData(a1[42], v27, v28, v29, v30, v31, v32, v33);
  if (v26 >= 0) {
    unsigned int v35 = v34;
  }
  else {
    unsigned int v35 = v26;
  }
  if (v25 >= 0) {
    return v35;
  }
  else {
    return v25;
  }
}

uint64_t wgram_ReadHashTab(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 v42 = 0;
  unsigned int v40 = 0;
  int v41 = 0;
  uint64_t v39 = 0;
  uint64_t v14 = ssftriff_reader_OpenChunk(a1, &v41, &v40, &v39, a5, a6, a7, a8);
  if ((v14 & 0x80000000) == 0)
  {
    if (!(v41 ^ 0x42544854 | v42))
    {
      unsigned __int8 v46 = 0;
      unsigned int v44 = 0;
      int v45 = 0;
      int v43 = 0;
      int v15 = ssftriff_reader_OpenChunk(a1, &v45, &v44, &v43, v10, v11, v12, v13);
      if (v15 < 0) {
        goto LABEL_18;
      }
      if (!(v45 ^ 0x44544854 | v46))
      {
        uint64_t v16 = v43;
        *(_DWORD *)a2 = *v43;
        *(_DWORD *)(a2 + 4) = v16[1];
      }
      int v15 = ssftriff_reader_CloseChunk(a1);
      if (v15 < 0)
      {
LABEL_18:
        LODWORD(v14) = v15;
      }
      else
      {
        unsigned __int8 v46 = 0;
        unsigned int v44 = 0;
        int v45 = 0;
        int v43 = 0;
        LODWORD(v14) = ssftriff_reader_OpenChunk(a1, &v45, &v44, &v43, v17, v18, v19, v20);
        if ((v14 & 0x80000000) == 0)
        {
          if (!(v45 ^ 0x53544854 | v46)) {
            LODWORD(v14) = ssftriff_reader_DetachChunkData(a1, (uint64_t *)(a2 + 24), (void *)(a2 + 8), v21, v22, v23, v24, v25);
          }
          int v26 = ssftriff_reader_CloseChunk(a1);
          if ((int)v14 >= 0) {
            LODWORD(v14) = v26;
          }
          if ((v14 & 0x80000000) == 0)
          {
            unsigned __int8 v46 = 0;
            unsigned int v44 = 0;
            int v45 = 0;
            int v43 = 0;
            LODWORD(v14) = ssftriff_reader_OpenChunk(a1, &v45, &v44, &v43, v27, v28, v29, v30);
            if ((v14 & 0x80000000) == 0)
            {
              if (!(v45 ^ 0x45544854 | v46)) {
                LODWORD(v14) = ssftriff_reader_DetachChunkData(a1, (uint64_t *)(a2 + 32), (void *)(a2 + 16), v31, v32, v33, v34, v35);
              }
              int v36 = ssftriff_reader_CloseChunk(a1);
              if ((int)v14 >= 0) {
                LODWORD(v14) = v36;
              }
            }
          }
        }
      }
    }
    unsigned int v37 = ssftriff_reader_CloseChunk(a1);
    if ((int)v14 >= 0) {
      return v37;
    }
    else {
      return v14;
    }
  }
  return v14;
}

uint64_t kbaux_BuildBrokerString(uint64_t a1, const char *a2, char *a3, unint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  *(void *)int v9 = 0;
  uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"langcode", v9);
  if ((result & 0x80000000) == 0)
  {
    auxil_strlcpy(v10, "mosynt_", 0x80uLL);
    auxil_strlcat(v10, a2, 128);
    auxil_strlcat(v10, "_", 128);
    if (auxil_strlcat(v10, *(const char **)v9, 128) > 0x7F)
    {
      return 2371887113;
    }
    else
    {
      LODWORD(result) = brokeraux_ComposeBrokerString(a1, v10, 0, 1, *(char **)v9, 0, 0, a3, a4);
      if ((int)result >= 0) {
        return result;
      }
      else {
        return result | 0x8D602000;
      }
    }
  }
  return result;
}

uint64_t hlp_VoiceSetup(uint64_t a1)
{
  uint64_t v17 = 0;
  unsigned __int8 v15 = 0;
  unsigned int v14 = 0;
  uint64_t v13 = 0;
  unsigned int v2 = (_DWORD *)(a1 + 88);
  uint64_t result = com_mosynt_UseMosynt(*(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56), (BOOL *)(a1 + 88));
  if ((result & 0x80000000) == 0)
  {
    __int16 v16 = 0;
    memset(__c, 0, sizeof(__c));
    *(_DWORD *)(a1 + 244) = 0;
    if (((*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 40), *(void *)(a1 + 48), "fecfg", "keep_stress", &__c[3], &__c[1], __c) & 0x80000000) == 0&& *(unsigned __int16 *)&__c[1] == 1&& *(void *)&__c[3])
    {
      int v4 = **(const char ***)&__c[3];
      int v5 = strchr(**(char ***)&__c[3], __c[0]);
      if (v5)
      {
        *int v5 = 0;
        int v4 = **(const char ***)&__c[3];
      }
      if (!strcmp(v4, "YES") || !strcmp(v4, "yes")) {
        *(_DWORD *)(a1 + 244) = 1;
      }
    }
    *(unsigned char *)(a1 + 360) = 0;
    __int16 v16 = 0;
    uint64_t result = (*(uint64_t (**)(void, void, const char *, const char *, char ***, __int16 *, unsigned __int8 *))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 40), *(void *)(a1 + 48), "fecfg", "orthtrigger", &v17, &v16, &v15);
    if ((result & 0x80000000) == 0)
    {
      if (v16 == 1 && v17)
      {
        int v6 = strchr(*v17, v15);
        if (v6) {
          *int v6 = 0;
        }
        __strcpy_chk();
      }
      *(_DWORD *)(a1 + 264) = 0;
      __int16 v16 = 0;
      if ((paramc_ParamGetUInt(*(void *)(*(void *)a1 + 40), (uint64_t)"prmigexists", &v14) & 0x80000000) == 0
        && v14 == 1)
      {
        *(_DWORD *)(a1 + 264) = 1;
      }
      *(_DWORD *)(a1 + 248) = 0;
      __int16 v16 = 0;
      uint64_t result = (*(uint64_t (**)(void, void, const char *, const char *, char ***, __int16 *, unsigned __int8 *))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 40), *(void *)(a1 + 48), "fecfg", "usetntag", &v17, &v16, &v15);
      if ((result & 0x80000000) == 0)
      {
        if (v16 == 1 && v17 && **v17 == 49) {
          *(_DWORD *)(a1 + 248) = 1;
        }
        *(_DWORD *)(a1 + 252) = 0;
        __int16 v16 = 0;
        uint64_t result = (*(uint64_t (**)(void, void, const char *, const char *, char ***, __int16 *, unsigned __int8 *))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 40), *(void *)(a1 + 48), "fecfg", "docclassmap", &v17, &v16, &v15);
        if ((result & 0x80000000) == 0)
        {
          if (v16 == 1 && v17 && !strncmp(*v17, "yes", 3uLL)) {
            *(_DWORD *)(a1 + 252) = 1;
          }
          *(_DWORD *)(a1 + 256) = 0;
          __int16 v16 = 0;
          uint64_t result = (*(uint64_t (**)(void, void, const char *, const char *, char ***, __int16 *, unsigned __int8 *))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 40), *(void *)(a1 + 48), "fecfg", "feGlobaluseFullPOS", &v17, &v16, &v15);
          if ((result & 0x80000000) == 0)
          {
            if (v16 == 1 && v17 && **v17 == 49) {
              *(_DWORD *)(a1 + 256) = 1;
            }
            *(_DWORD *)(a1 + 260) = 0;
            if ((paramc_ParamGetStr(*(void *)(*(void *)a1 + 40), (uint64_t)"clcpppipelinemode", &v13) & 0x80000000) == 0
              && v13
              && *v13)
            {
              *(_DWORD *)(a1 + 260) = 1;
            }
            if ((*(unsigned int (**)(void, void, const char *))(*(void *)(a1 + 32) + 72))(*(void *)(a1 + 16), *(void *)(a1 + 24), "global") == 2)*(_DWORD *)(a1 + 260) = 1; {
            if (*v2 != 1
            }
              || (*(void *)&__c[3] = 0,
                  uint64_t result = com_mosynt_GetCfgParamVal(*(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56), (uint64_t)"mosynt_enablegraphsymcache", "yes", (char **)&__c[3]), (result & 0x80000000) == 0)&& (v7 = strcmp(*(const char **)&__c[3], "yes") == 0, uint64_t result = kbsymtab_LoadData(*(_WORD **)(a1 + 296), *(void *)(a1 + 304), *(_WORD **)(a1 + 320), *(void *)(a1 + 328), (uint64_t *)(a1 + 336), v7), (result & 0x80000000) == 0)&& (uint64_t result = fst_LoadData(*(_WORD **)(a1 + 296), *(void *)(a1 + 304), (uint64_t *)(a1 + 344)), (result & 0x80000000) == 0))
            {
              uint64_t result = com_depes_InitLayers(*(void *)a1, a1 + 96);
              if ((result & 0x80000000) == 0)
              {
                *(void *)(a1 + 224) = 0x3000200010000;
                *(_WORD *)(a1 + 232) = 4;
                if (*(_DWORD *)(a1 + 88) || *(_DWORD *)(a1 + 264))
                {
                  __int16 v8 = 8;
                  __int16 v9 = 7;
                  __int16 v10 = 6;
                  __int16 v11 = 5;
                }
                else
                {
                  __int16 v11 = 0;
                  __int16 v8 = 7;
                  __int16 v9 = 6;
                  __int16 v10 = 5;
                }
                *(_WORD *)(a1 + 234) = v11;
                *(_WORD *)(a1 + 238) = v10;
                *(_WORD *)(a1 + 240) = v9;
                __int16 v12 = v8 - (*(_DWORD *)(a1 + 248) == 0);
                *(_WORD *)(a1 + 236) = v12;
                *(_WORD *)(a1 + 106) = v12 + 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t fe_global_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  uint64_t v5 = 2316312583;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  if (a5)
  {
    *(void *)a5 = 0;
    *(_DWORD *)(a5 + 8) = 0;
    uint64_t inited = InitRsrcFunction(a3, a4, &v28);
    if ((inited & 0x80000000) == 0)
    {
      uint64_t v12 = heap_Calloc(*(void **)(v28 + 8), 1, 408);
      uint64_t v17 = v28;
      if (v12)
      {
        uint64_t v18 = v12;
        uint64_t v19 = (void *)heap_Calloc(*(void **)(v28 + 8), 1, 1040);
        *(void *)(v18 + 312) = v19;
        if (v19)
        {
          *uint64_t v19 = a3;
          v19[1] = a4;
          uint64_t Object = objc_GetObject(*(void *)(v28 + 48), (uint64_t)"LINGDB", &v27);
          if ((Object & 0x80000000) != 0) {
            goto LABEL_14;
          }
          *(void *)(v18 + 8) = *(void *)(v27 + 8);
          uint64_t Object = objc_GetObject(*(void *)(v28 + 48), (uint64_t)"FE_DEPES", &v26);
          if ((Object & 0x80000000) != 0) {
            goto LABEL_14;
          }
          uint64_t v21 = v26;
          *(void *)(v18 + 32) = *(void *)(v26 + 8);
          *(_OWORD *)(v18 + 16) = *(_OWORD *)(v21 + 16);
          uint64_t Object = objc_GetObject(*(void *)(v28 + 48), (uint64_t)"FE_DCTLKP", &v25);
          if ((Object & 0x80000000) != 0) {
            goto LABEL_14;
          }
          uint64_t v22 = v25;
          *(void *)(v18 + 56) = *(void *)(v25 + 8);
          *(_OWORD *)(v18 + 40) = *(_OWORD *)(v22 + 16);
          *(void *)uint64_t v18 = v28;
          *(_DWORD *)(v18 + 268) = 0;
          *(void *)(v18 + 296) = a3;
          *(void *)(v18 + 304) = a4;
          *(void *)(v18 + 320) = a1;
          *(void *)(v18 + 328) = a2;
          *(void *)(v18 + 400) = 0;
          *(_OWORD *)(v18 + 368) = 0u;
          *(_OWORD *)(v18 + 384) = 0u;
          uint64_t Object = hlp_VoiceSetup(v18);
          if ((Object & 0x80000000) != 0
            || (uint64_t Object = globalbeadapt_SetFEBOOLKeyword((void *)v18, (uint64_t)"mdesegpos_morpheme_processing", (_DWORD *)(v18 + 272), 0), (Object & 0x80000000) != 0)|| (uint64_t Object = globalbeadapt_SetFEBOOLKeyword((void *)v18, (uint64_t)"feGlobalmergemorphemes", (_DWORD *)(v18 + 276), 1), (Object & 0x80000000) != 0))
          {
LABEL_14:
            uint64_t v5 = Object;
          }
          else
          {
            uint64_t v5 = globalbeadapt_SetFEBOOLKeyword((void *)v18, (uint64_t)"feGlobalmergemorphemes", (_DWORD *)(v18 + 280), 1);
            if ((v5 & 0x80000000) == 0)
            {
              int v23 = 62344;
LABEL_18:
              *(void *)a5 = v18;
              *(_DWORD *)(a5 + 8) = v23;
              return v5;
            }
          }
LABEL_17:
          fe_global_ObjClose(*(void *)a5, *(void *)(a5 + 8));
          uint64_t v18 = 0;
          int v23 = 0;
          goto LABEL_18;
        }
        uint64_t v17 = v28;
      }
      log_OutPublic(*(void *)(v17 + 32), (uint64_t)"FE_GLOBAL", 38000, 0, v13, v14, v15, v16, v25);
      uint64_t v5 = 2316312586;
      goto LABEL_17;
    }
    return inited;
  }
  return v5;
}

uint64_t fe_global_ObjClose(uint64_t a1, int a2)
{
  uint64_t result = safeh_HandleCheck(a1, a2, 62344, 408);
  if ((result & 0x80000000) != 0) {
    return 2316312584;
  }
  if (a1)
  {
    hlp_UnloadSymTabs(a1);
    if (*(void *)(a1 + 344))
    {
      fst_UnloadData(*(_WORD **)(a1 + 296), *(void *)(a1 + 304), (uint64_t *)(a1 + 344));
      *(void *)(a1 + 344) = 0;
    }
    if (*(void *)(a1 + 8)) {
      objc_ReleaseObject(*(void *)(*(void *)a1 + 48), (uint64_t)"LINGDB");
    }
    if (*(void *)(a1 + 32)) {
      objc_ReleaseObject(*(void *)(*(void *)a1 + 48), (uint64_t)"FE_DEPES");
    }
    if (*(void *)(a1 + 56)) {
      objc_ReleaseObject(*(void *)(*(void *)a1 + 48), (uint64_t)"FE_DCTLKP");
    }
    uint64_t v4 = *(void *)(a1 + 312);
    if (v4) {
      heap_Free(*(void **)(*(void *)a1 + 8), v4);
    }
    heap_Free(*(void **)(*(void *)a1 + 8), a1);
    return 0;
  }
  return result;
}

uint64_t fe_global_ObjReopen(uint64_t a1, int a2)
{
  uint64_t result = safeh_HandleCheck(a1, a2, 62344, 408);
  if ((result & 0x80000000) != 0) {
    return 2316312584;
  }
  if (a1)
  {
    uint64_t result = hlp_UnloadSymTabs(a1);
    if ((result & 0x80000000) == 0)
    {
      if (!*(void *)(a1 + 344)
        || (uint64_t result = fst_UnloadData(*(_WORD **)(a1 + 296), *(void *)(a1 + 304), (uint64_t *)(a1 + 344)),
            *(void *)(a1 + 344) = 0,
            (result & 0x80000000) == 0))
      {
        uint64_t result = hlp_VoiceSetup(a1);
        if ((result & 0x80000000) == 0)
        {
          uint64_t result = globalbeadapt_SetFEBOOLKeyword((void *)a1, (uint64_t)"mdesegpos_morpheme_processing", (_DWORD *)(a1 + 272), 0);
          if ((result & 0x80000000) == 0)
          {
            uint64_t result = globalbeadapt_SetFEBOOLKeyword((void *)a1, (uint64_t)"feGlobalmergemorphemes", (_DWORD *)(a1 + 276), 1);
            if ((result & 0x80000000) == 0)
            {
              return globalbeadapt_SetFEBOOLKeyword((void *)a1, (uint64_t)"feGlobalmergemorphemes", (_DWORD *)(a1 + 280), 1);
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t hlp_UnloadSymTabs(uint64_t a1)
{
  if (!*(void *)(a1 + 336)) {
    return 0;
  }
  uint64_t result = kbsymtab_UnloadData(*(_WORD **)(a1 + 296), *(void *)(a1 + 304), *(_WORD **)(a1 + 320), *(void *)(a1 + 328), (uint64_t *)(a1 + 336));
  *(void *)(a1 + 336) = 0;
  return result;
}

uint64_t fe_global_ProcessStart(uint64_t a1, int a2)
{
  LODWORD(result) = safeh_HandleCheck(a1, a2, 62344, 408);
  if ((int)result >= 0) {
    return result;
  }
  else {
    return 2316312584;
  }
}

uint64_t fe_global_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  v94[16] = *(const char **)MEMORY[0x263EF8340];
  __int16 v78 = 0;
  __s1 = 0;
  int v76 = 0;
  if ((safeh_HandleCheck(a1, a2, 62344, 408) & 0x80000000) != 0) {
    return 2316312584;
  }
  uint64_t v82 = 0;
  int v81 = 0;
  int v80 = 0;
  unsigned __int16 v79 = 0;
  *a5 = 1;
  uint64_t v9 = (*(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 32) + 144))(*(void *)(a1 + 16), *(void *)(a1 + 24), a1 + 104);
  if ((v9 & 0x80000000) != 0) {
    goto LABEL_174;
  }
  *(_DWORD *)(a1 + 352) = 0;
  if ((paramc_ParamGetStr(*(void *)(*(void *)a1 + 40), (uint64_t)"foreignpron", &__s1) & 0x80000000) == 0
    && __s1
    && !strcmp(__s1, "yes"))
  {
    *(_DWORD *)(a1 + 352) = 1;
  }
  *(_DWORD *)(a1 + 356) = 0;
  if ((paramc_ParamGetStr(*(void *)(*(void *)a1 + 40), (uint64_t)"nlucompatvc6be", &__s1) & 0x80000000) == 0
    && __s1
    && !strcmp(__s1, "yes"))
  {
    *(_DWORD *)(a1 + 356) = 1;
  }
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *))(*(void *)(a1 + 8) + 104))(a3, a4, 1, 0, (char *)&v81 + 2);
  if ((v10 & 0x80000000) == 0
    && ((*(uint64_t (**)(uint64_t, uint64_t, void, void, __int16 *))(*(void *)(a1 + 8) + 184))(a3, a4, HIWORD(v81), 0, &v78) & 0x80000000) == 0&& v78 == 1)
  {
    uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, char **, int *))(*(void *)(a1 + 8) + 176))(a3, a4, HIWORD(v81), 0, &v82, &v81);
    if ((v10 & 0x80000000) == 0 && (unsigned __int16)v81 >= 2u)
    {
      if (*(_DWORD *)(a1 + 88))
      {
        uint64_t v11 = heap_Calloc(*(void **)(*(void *)a1 + 8), 5000, 1);
        *(void *)(a1 + 368) = v11;
        uint64_t v16 = *(void *)a1;
        if (v11)
        {
          uint64_t v17 = heap_Calloc(*(void **)(v16 + 8), 5000, 1);
          *(void *)(a1 + 376) = v17;
          uint64_t v16 = *(void *)a1;
          if (v17)
          {
            uint64_t v18 = heap_Calloc(*(void **)(v16 + 8), 5000, 1);
            *(void *)(a1 + 384) = v18;
            uint64_t v16 = *(void *)a1;
            if (v18)
            {
              uint64_t v19 = heap_Calloc(*(void **)(v16 + 8), 5000, 1);
              *(void *)(a1 + 392) = v19;
              uint64_t v16 = *(void *)a1;
              if (v19)
              {
                uint64_t v20 = heap_Calloc(*(void **)(v16 + 8), 8, 8);
                *(void *)(a1 + 400) = v20;
                if (v20)
                {
                  for (uint64_t i = 0; i != 64; i += 8)
                    *(void *)(*(void *)(a1 + 400) + i) = 0;
                  uint64_t v22 = 0;
                  while (1)
                  {
                    *(void *)(*(void *)(a1 + 400) + v22) = heap_Calloc(*(void **)(*(void *)a1 + 8), 5000, 1);
                    if (!*(void *)(*(void *)(a1 + 400) + v22)) {
                      break;
                    }
                    v22 += 8;
                    if (v22 == 64) {
                      goto LABEL_27;
                    }
                  }
                }
                uint64_t v16 = *(void *)a1;
              }
            }
          }
        }
        log_OutPublic(*(void *)(v16 + 32), (uint64_t)"FE_GLOBAL", 38000, 0, v12, v13, v14, v15, v73);
        uint64_t v10 = 2316312586;
        goto LABEL_175;
      }
LABEL_27:
      int v92 = 0;
      int v93 = 0;
      int v91 = 0;
      unsigned int v89 = 0;
      v94[0] = 0;
      uint64_t v86 = 0;
      int v87 = 0;
      long long __s = 0;
      int v84 = 0;
      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *))(*(void *)(a1 + 8) + 104))(a3, a4, 2, HIWORD(v81), (char *)&v93 + 2);
      if ((v9 & 0x80000000) != 0) {
        goto LABEL_174;
      }
      LOWORD(v91) = 0;
      __int16 v90 = 0;
      unsigned __int16 v23 = HIWORD(v93);
      if (!HIWORD(v93)) {
        goto LABEL_132;
      }
      int v24 = 0;
      uint64_t v25 = "PHR:";
LABEL_30:
      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, unsigned int *, char *))(*(void *)(a1 + 8) + 168))(a3, a4, v23, 0, 1, &v89, (char *)&v92 + 2);
      if ((v9 & 0x80000000) != 0) {
        goto LABEL_174;
      }
      if (v89 - 9 >= 6 && v89 != 4)
      {
        if (v89 != 15) {
          goto LABEL_91;
        }
        int v24 = HIWORD(v93);
        uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, char *))(*(void *)(a1 + 8) + 120))(a3, a4, HIWORD(v93), (char *)&v93 + 2);
        goto LABEL_41;
      }
      __int16 v83 = 0;
      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, char *))(*(void *)(a1 + 8)
                                                                                                + 168))(a3, a4, HIWORD(v93), 1, 1, &v91, (char *)&v92 + 2);
      if ((v9 & 0x80000000) != 0) {
        goto LABEL_174;
      }
      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, __int16 *, char *))(*(void *)(a1 + 8) + 168))(a3, a4, HIWORD(v93), 2, 1, &v90, (char *)&v92 + 2);
      if ((v9 & 0x80000000) != 0) {
        goto LABEL_174;
      }
      int v27 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, __int16 *))(*(void *)(a1 + 8) + 184))(a3, a4, HIWORD(v93), 14, &v83);
      uint64_t v28 = *(void *)(a1 + 8);
      if (v27 < 0 || !v83)
      {
        uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, char *))(v28 + 120))(a3, a4, HIWORD(v93), (char *)&v93 + 2);
        goto LABEL_41;
      }
      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, char *))(v28 + 176))(a3, a4, HIWORD(v93), 14, &__s, (char *)&v92 + 2);
      if ((v9 & 0x80000000) != 0) {
        goto LABEL_174;
      }
      if (*(_DWORD *)(a1 + 356) != 1) {
        goto LABEL_81;
      }
      int v74 = v24;
      uint64_t v29 = __s;
      size_t v30 = strlen(__s);
      size_t v31 = v30;
      for (uint64_t j = __s; ; ++j)
      {
        if (*j == 59)
        {
          char *j = 0;
        }
        else if (!*j)
        {
          uint64_t v33 = &v29[v30];
          uint64_t v34 = v29;
          if (!v30) {
            goto LABEL_80;
          }
          while (2)
          {
            if (!strncmp(v34, v25, 4uLL))
            {
              uint64_t v35 = v25;
              int v36 = v34 + 4;
              size_t v37 = strlen(v34 + 4);
              if (v37 >= 3)
              {
                unsigned int v38 = *v36 - 66;
                BOOL v39 = v38 > 0xD;
                int v40 = (1 << v38) & 0x2081;
                BOOL v41 = v39 || v40 == 0;
                if (!v41 && v34[5] == 45)
                {
                  unint64_t v42 = v37;
                  size_t v75 = v37 - 2;
                  memmove(v34 + 4, v34 + 6, v37 - 2);
                  uint64_t v43 = -1;
                  if (v42 - 1 < v42) {
                    uint64_t v43 = 0;
                  }
                  bzero(&v36[v75], v43 + 2);
                }
              }
LABEL_65:
              unsigned int v44 = strchr(v36, 43);
              uint64_t v25 = v35;
              if (v44 && *v44)
              {
                int v45 = (unsigned __int8 *)(v44 + 1);
                do
                  *(v45 - 1) = 0;
                while (*v45++);
              }
            }
            else if (!strncmp(v34, "POS:", 4uLL))
            {
              uint64_t v35 = v25;
              int v36 = v34 + 4;
              goto LABEL_65;
            }
            if (++v34 != v33) {
              continue;
            }
            break;
          }
          int v47 = 0;
          uint64_t v48 = v29;
          do
          {
            char v49 = *v48;
            if (*v48)
            {
              if (v47 == 1)
              {
                *v29++ = 59;
                char v49 = *v48;
              }
              int v47 = 0;
              *v29++ = v49;
            }
            else
            {
              int v47 = 1;
            }
            ++v48;
            --v31;
          }
          while (v31);
LABEL_80:
          *uint64_t v29 = 0;
          int v24 = v74;
LABEL_81:
          hlp_NLUStrFind(__s, "BND", (uint64_t *)&v86, (unsigned __int16 *)&v84);
          hlp_NLUStrFind(__s, "PRM", (uint64_t *)&v87, (unsigned __int16 *)&v84 + 1);
          if (v90 && (_WORD)v24)
          {
            v88[0] = 0;
            if (!v87
              || (v88[0] = *v87) == 0
              || (v88[1] = 0,
                  __int16 v50 = strlen(v88),
                  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, char *, int *))(*(void *)(a1 + 8) + 160))(a3, a4, HIWORD(v93), 13, (unsigned __int16)(v50 + 1), v88, &v92), (v9 & 0x80000000) == 0))
            {
              if (!v86) {
                goto LABEL_94;
              }
              int v51 = (char)*v86;
              if (v51 != 78 && v51 != 87)
              {
                if (v51 == 83)
                {
                  HIWORD(v91) = 200;
                  goto LABEL_93;
                }
                goto LABEL_94;
              }
              HIWORD(v91) = 0;
LABEL_93:
              uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(*(void *)(a1 + 8) + 160))(a3, a4, HIWORD(v93), 8, 1, (char *)&v91 + 2, &v92);
              if ((v9 & 0x80000000) == 0)
              {
LABEL_94:
                unsigned __int16 v52 = HIWORD(v93);
                while (1)
                {
                  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, char *))(*(void *)(a1 + 8) + 120))(a3, a4, v52, (char *)&v93 + 2);
                  if ((v9 & 0x80000000) != 0) {
                    break;
                  }
                  if (!HIWORD(v93)) {
                    goto LABEL_42;
                  }
                  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 + 8) + 168))(a3, a4);
                  if ((v9 & 0x80000000) != 0) {
                    break;
                  }
                  unsigned __int16 v52 = HIWORD(v93);
                  if (!HIWORD(v93)) {
                    goto LABEL_42;
                  }
                  if (v89 <= 0xF && ((1 << v89) & 0xFE10) != 0)
                  {
                    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 + 8) + 168))(a3, a4);
                    if ((v9 & 0x80000000) != 0) {
                      goto LABEL_174;
                    }
                    if (!v86) {
                      goto LABEL_42;
                    }
                    int v53 = *v86;
                    if (v53 == 78)
                    {
                      if (v89 != 15) {
                        goto LABEL_42;
                      }
                      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, __int16 *, char *))(*(void *)(a1 + 8) + 168))(a3, a4, HIWORD(v93), 2, 1, &v90, (char *)&v92 + 2);
                      if ((v9 & 0x80000000) == 0)
                      {
                        uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, __int16 *, int *))(*(void *)(a1 + 8) + 160))(a3, a4, (unsigned __int16)v24, 2, 1, &v90, &v92);
                        if ((v9 & 0x80000000) == 0)
                        {
                          uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, const char **, char *))(*(void *)(a1 + 8) + 176))(a3, a4, HIWORD(v93), 4, v94, (char *)&v92 + 2);
                          if ((v9 & 0x80000000) == 0)
                          {
                            __int16 v54 = strlen(v94[0]);
                            uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, const char *, int *))(*(void *)(a1 + 8) + 160))(a3, a4, (unsigned __int16)v24, 4, (unsigned __int16)(v54 + 1), v94[0], &v92);
                            if ((v9 & 0x80000000) == 0)
                            {
                              uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, int *))(*(void *)(a1 + 8)
                                                                                              + 120))(a3, a4, HIWORD(v93), &v93);
                              if ((v9 & 0x80000000) == 0)
                              {
                                uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)(a1 + 8) + 192))(a3, a4, HIWORD(v93));
                                if ((v9 & 0x80000000) == 0)
                                {
                                  HIWORD(v93) = v93;
                                  goto LABEL_42;
                                }
                              }
                            }
                          }
                        }
                      }
                      goto LABEL_174;
                    }
                    if (v89 != 15)
                    {
                      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, char *))(*(void *)(a1 + 8) + 88))(a3, a4, HIWORD(v93), (char *)&v93 + 2);
                      if ((v9 & 0x80000000) != 0) {
                        goto LABEL_174;
                      }
                      unsigned int v89 = 15;
                      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, unsigned int *, int *))(*(void *)(a1 + 8) + 160))(a3, a4, HIWORD(v93), 0, 1, &v89, &v92);
                      if ((v9 & 0x80000000) != 0) {
                        goto LABEL_174;
                      }
                      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, int *))(*(void *)(a1 + 8) + 160))(a3, a4, HIWORD(v93), 1, 1, &v91, &v92);
                      if ((v9 & 0x80000000) != 0) {
                        goto LABEL_174;
                      }
                      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, __int16 *, char *))(*(void *)(a1 + 8) + 168))(a3, a4, (unsigned __int16)v24, 2, 1, &v90, (char *)&v92 + 2);
                      if ((v9 & 0x80000000) != 0) {
                        goto LABEL_174;
                      }
                      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, __int16 *, int *))(*(void *)(a1 + 8) + 160))(a3, a4, HIWORD(v93), 2, 1, &v90, &v92);
                      if ((v9 & 0x80000000) != 0) {
                        goto LABEL_174;
                      }
                      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, int *))(*(void *)(a1 + 8) + 160))(a3, a4, (unsigned __int16)v24, 2, 1, &v91, &v92);
                      if ((v9 & 0x80000000) != 0) {
                        goto LABEL_174;
                      }
                      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, const char **, char *))(*(void *)(a1 + 8) + 176))(a3, a4, (unsigned __int16)v24, 4, v94, (char *)&v92 + 2);
                      if ((v9 & 0x80000000) != 0) {
                        goto LABEL_174;
                      }
                      __int16 v55 = strlen(v94[0]);
                      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, const char *, int *))(*(void *)(a1 + 8) + 160))(a3, a4, HIWORD(v93), 4, (unsigned __int16)(v55 + 1), v94[0], &v92);
                      if ((v9 & 0x80000000) != 0) {
                        goto LABEL_174;
                      }
                      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, const char *, int *))(*(void *)(a1 + 8) + 160))(a3, a4, (unsigned __int16)v24, 4, 2, "P", &v92);
                      if ((v9 & 0x80000000) != 0) {
                        goto LABEL_174;
                      }
                      int v53 = *v86;
                    }
                    if (v53 == 87)
                    {
                      HIWORD(v91) = 2;
                      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(*(void *)(a1 + 8) + 160))(a3, a4, HIWORD(v93), 7, 1, (char *)&v91 + 2, &v92);
                      if ((v9 & 0x80000000) != 0) {
                        goto LABEL_174;
                      }
                      HIWORD(v91) = 0;
                    }
                    else
                    {
                      if ((char)v53 != 83) {
                        goto LABEL_42;
                      }
                      HIWORD(v91) = 1;
                      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(*(void *)(a1 + 8) + 160))(a3, a4, HIWORD(v93), 7, 1, (char *)&v91 + 2, &v92);
                      if ((v9 & 0x80000000) != 0) {
                        goto LABEL_174;
                      }
                      HIWORD(v91) = 200;
                    }
                    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(*(void *)(a1 + 8) + 160))(a3, a4, HIWORD(v93), 8, 1, (char *)&v91 + 2, &v92);
                    if ((v9 & 0x80000000) == 0) {
                      goto LABEL_42;
                    }
                    goto LABEL_174;
                  }
                }
              }
            }
            goto LABEL_174;
          }
LABEL_91:
          uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, char *))(*(void *)(a1 + 8) + 120))(a3, a4, HIWORD(v93), (char *)&v93 + 2);
LABEL_41:
          if ((v9 & 0x80000000) != 0) {
            goto LABEL_174;
          }
LABEL_42:
          unsigned __int16 v23 = HIWORD(v93);
          if (!HIWORD(v93))
          {
LABEL_132:
            if (*(_DWORD *)(a1 + 244))
            {
              uint64_t v56 = 2;
            }
            else if (*(_DWORD *)(a1 + 88))
            {
              uint64_t v56 = 98;
            }
            else
            {
              uint64_t v56 = 34;
            }
            uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, void))(*(void *)(a1 + 8)
                                                                                               + 272))(a3, a4, v56, 3, 0, 0);
            if ((v9 & 0x80000000) != 0) {
              goto LABEL_174;
            }
            uint64_t v9 = globalbeadapt_SetupDepesInput(a1, a3, a4, HIWORD(v81), (uint64_t)"global", 0, v57, v58);
            if ((v9 & 0x80000000) != 0) {
              goto LABEL_174;
            }
            if (*(_DWORD *)(a1 + 88))
            {
              uint64_t v9 = hlp_SaveLayers(a1);
              if ((v9 & 0x80000000) != 0) {
                goto LABEL_174;
              }
            }
            strcpy((char *)v94, "global");
            unsigned __int16 v59 = strlen((const char *)v94);
            if (*(_DWORD *)(a1 + 352))
            {
              unsigned __int16 v60 = v59;
              __strcat_chk();
              if (((*(uint64_t (**)(void, void, const char **))(*(void *)(a1 + 32) + 80))(*(void *)(a1 + 16), *(void *)(a1 + 24), v94) & 0x80000000) != 0)
              {
                *((unsigned char *)v94 + v60) = 0;
                uint64_t v9 = (*(uint64_t (**)(void, void, const char **))(*(void *)(a1 + 32) + 80))(*(void *)(a1 + 16), *(void *)(a1 + 24), v94);
                if ((v9 & 0x80000000) != 0) {
                  goto LABEL_174;
                }
              }
            }
            else
            {
              hlp_WriteDepesLayers(a1, "before cgn");
              uint64_t v9 = (*(uint64_t (**)(void, void, const char **))(*(void *)(a1 + 32) + 80))(*(void *)(a1 + 16), *(void *)(a1 + 24), v94);
              if ((v9 & 0x80000000) != 0) {
                goto LABEL_174;
              }
              hlp_WriteDepesLayers(a1, "after cgn");
            }
            if (!*(_DWORD *)(a1 + 88)) {
              goto LABEL_157;
            }
            uint64_t v9 = hlp_ReconstituteLayers(a1);
            if ((v9 & 0x80000000) != 0) {
              goto LABEL_174;
            }
            hlp_WriteDepesLayers(a1, "after realignment");
            uint64_t v9 = fe_global_ApplyFSTs(a1);
            if ((v9 & 0x80000000) != 0) {
              goto LABEL_174;
            }
            uint64_t v9 = hlp_ReconstituteLayers(a1);
            if ((v9 & 0x80000000) != 0) {
              goto LABEL_174;
            }
            hlp_WriteDepesLayers(a1, "before be_adapt");
            strcpy((char *)v94, "be_adapt");
            if (!(*(unsigned int (**)(void, void, const char **))(*(void *)(a1 + 32) + 72))(*(void *)(a1 + 16), *(void *)(a1 + 24), v94)|| (v61 = (*(uint64_t (**)(void, void, const char **))(*(void *)(a1 + 32) + 80))(*(void *)(a1 + 16), *(void *)(a1 + 24), v94), (v61 & 0x80000000) == 0)|| (uint64_t v10 = v61, (v61 & 0x1FFF) == 4))
            {
              hlp_WriteDepesLayers(a1, "after be_adapt");
LABEL_157:
              uint64_t v9 = (*(uint64_t (**)(void, void, void, char **, unsigned __int16 *))(*(void *)(a1 + 32)
                                                                                                  + 128))(*(void *)(a1 + 16), *(void *)(a1 + 24), 0, &v80, &v79);
              if ((v9 & 0x80000000) != 0) {
                goto LABEL_174;
              }
              v80[v79] = 0;
              log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_GLOBAL", 5, 0, (uint64_t)"%s O1: %s", v62, v63, v64, (uint64_t)v94);
              uint64_t v9 = globalbeadapt_DoPostprocessing((void *)a1, v82, &v80, 1);
              if ((v9 & 0x80000000) != 0) {
                goto LABEL_174;
              }
              uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 320))(a3, a4, 1);
              if ((v9 & 0x80000000) != 0) {
                goto LABEL_174;
              }
              int v65 = *(_DWORD *)(a1 + 272);
              if (!v65 || v65 == 1 && !*(_DWORD *)(a1 + 276)) {
                goto LABEL_193;
              }
              uint64_t v9 = globalbeadapt_OutputMorphemesToLingDBAsWords((uint64_t *)a1, a3, a4, HIWORD(v81), v82, *(unsigned __int8 **)(a1 + 120), v80, &v76);
              if ((v9 & 0x80000000) != 0) {
                goto LABEL_174;
              }
              if (v76 == 1)
              {
LABEL_193:
                uint64_t v9 = globalbeadapt_OutputToLingDB(a1, a3, a4, HIWORD(v81), (uint64_t)v82, v80);
                if ((v9 & 0x80000000) != 0) {
                  goto LABEL_174;
                }
              }
              if (*(_DWORD *)(a1 + 272) == 1
                && *(_DWORD *)(a1 + 276) == 1
                && (!v76
                 && (uint64_t v9 = globalbeadapt_SplitWordRecordsWithSpecialChar((uint64_t *)a1, a3, a4, HIWORD(v81), v82, (const char *)(a1 + 360)), (v9 & 0x80000000) != 0)|| (uint64_t v9 = globalbeadapt_RemoveSpecialChar((void *)a1, a3, a4, HIWORD(v81)), (v9 & 0x80000000) != 0)))
              {
LABEL_174:
                uint64_t v10 = v9;
              }
              else
              {
                uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, void))(*(void *)(a1 + 8) + 272))(a3, a4, 4, 1, 0, 0);
                if ((v10 & 0x80000000) == 0 && *(unsigned char *)(a1 + 360))
                {
                  uint64_t v9 = fe_global_CleanTriggerOrth(a1, a3, a4, HIWORD(v81));
                  goto LABEL_174;
                }
              }
            }
LABEL_175:
            com_depes_FreeLayers(*(void *)a1, a1 + 96);
            if (*(_DWORD *)(a1 + 88))
            {
              uint64_t v66 = *(void *)(a1 + 368);
              if (v66)
              {
                heap_Free(*(void **)(*(void *)a1 + 8), v66);
                *(void *)(a1 + 368) = 0;
              }
              uint64_t v67 = *(void *)(a1 + 376);
              if (v67)
              {
                heap_Free(*(void **)(*(void *)a1 + 8), v67);
                *(void *)(a1 + 376) = 0;
              }
              uint64_t v68 = *(void *)(a1 + 384);
              if (v68)
              {
                heap_Free(*(void **)(*(void *)a1 + 8), v68);
                *(void *)(a1 + 384) = 0;
              }
              uint64_t v69 = *(void *)(a1 + 392);
              if (v69)
              {
                heap_Free(*(void **)(*(void *)a1 + 8), v69);
                *(void *)(a1 + 392) = 0;
              }
              if (*(void *)(a1 + 400))
              {
                for (uint64_t k = 0; k != 64; k += 8)
                {
                  uint64_t v71 = *(void *)(*(void *)(a1 + 400) + k);
                  if (v71)
                  {
                    heap_Free(*(void **)(*(void *)a1 + 8), v71);
                    *(void *)(*(void *)(a1 + 400) + k) = 0;
                  }
                }
                heap_Free(*(void **)(*(void *)a1 + 8), *(void *)(a1 + 400));
                *(void *)(a1 + 400) = 0;
              }
            }
            return v10;
          }
          goto LABEL_30;
        }
      }
    }
  }
  return v10;
}

uint64_t hlp_SaveLayers(uint64_t a1)
{
  __src = 0;
  if (!*(_WORD *)(a1 + 104)) {
    return 0;
  }
  unint64_t v2 = 0;
  unsigned __int16 v7 = 0;
  do
  {
    uint64_t v3 = (*(uint64_t (**)(void, void, void, char **, unsigned __int16 *))(*(void *)(a1 + 32) + 128))(*(void *)(a1 + 16), *(void *)(a1 + 24), (unsigned __int16)v2, &__src, &v7);
    if ((v3 & 0x80000000) != 0) {
      break;
    }
    char v4 = __src[v7];
    __src[v7] = 0;
    strncpy(*(char **)(*(void *)(a1 + 400) + 8 * v2), __src, 0x1387uLL);
    *(unsigned char *)(*(void *)(*(void *)(a1 + 400) + 8 * v2) + 4999) = 0;
    __src[v7] = v4;
    ++v2;
  }
  while (v2 < *(unsigned __int16 *)(a1 + 104));
  return v3;
}

uint64_t hlp_WriteDepesLayers(uint64_t result, char *a2)
{
  v14[2] = *MEMORY[0x263EF8340];
  if (*(_DWORD *)(result + 88))
  {
    uint64_t v3 = result;
    uint64_t result = mosynt_TraceString(*(void *)(result + 312), "\n", 1u);
    if ((result & 0x80000000) == 0)
    {
      unint64_t v13 = 0;
      unsigned __int16 v12 = 0;
      uint64_t result = (*(uint64_t (**)(void, void, void, unint64_t *, unsigned __int16 *))(*(void *)(v3 + 32) + 128))(*(void *)(v3 + 16), *(void *)(v3 + 24), 0, &v13, &v12);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = Utf8_LengthInUtf8chars(v13, v12);
        v14[0] = 0;
        v14[1] = 0;
        unsigned int v4 = (unsigned __int16)result;
        if ((_WORD)result)
        {
          uint64_t v5 = "\n";
          while (1)
          {
            unsigned __int16 v6 = v4 <= 0x32 ? result : 50;
            if (*(_WORD *)(v3 + 104)) {
              break;
            }
LABEL_24:
            uint64_t result = mosynt_TraceString(*(void *)(v3 + 312), v5, 1u);
            if ((result & 0x80000000) == 0)
            {
              uint64_t result = v4 - v6;
              unsigned int v4 = (unsigned __int16)(v4 - v6);
              if (v4) {
                continue;
              }
            }
            return result;
          }
          uint64_t v7 = 0;
          while (1)
          {
            uint64_t result = (*(uint64_t (**)(void, void, void, unint64_t *, unsigned __int16 *))(*(void *)(v3 + 32) + 128))(*(void *)(v3 + 16), *(void *)(v3 + 24), (unsigned __int16)v7, &v13, &v12);
            if ((result & 0x80000000) != 0) {
              break;
            }
            uint64_t result = mosynt_TraceString(*(void *)(v3 + 312), a2, 1u);
            if ((result & 0x80000000) != 0) {
              break;
            }
            uint64_t result = mosynt_TraceString(*(void *)(v3 + 312), " L", 1u);
            if ((result & 0x80000000) != 0) {
              break;
            }
            uint64_t result = mosynt_TraceInt(*(void *)(v3 + 312), (int)v7 + 1, 1u);
            if ((result & 0x80000000) != 0) {
              break;
            }
            uint64_t result = mosynt_TraceString(*(void *)(v3 + 312), ": ", 1u);
            if ((result & 0x80000000) != 0) {
              break;
            }
            if (v6)
            {
              __int16 v8 = v5;
              int v9 = 0;
              int v10 = *((unsigned __int16 *)v14 + v7);
              while (1)
              {
                uint64_t result = utf8_getUTF8Char(v13, (unsigned __int16)v10, __s);
                if ((result & 0x80000000) != 0) {
                  break;
                }
                uint64_t result = mosynt_TraceString(*(void *)(v3 + 312), __s, 1u);
                if ((result & 0x80000000) != 0) {
                  break;
                }
                v10 += strlen(__s);
                if ((unsigned __int16)++v9 >= v6)
                {
                  *((_WORD *)v14 + v7) = v10;
                  uint64_t v5 = v8;
                  goto LABEL_22;
                }
              }
              *((_WORD *)v14 + v7) = v10;
              return result;
            }
LABEL_22:
            uint64_t result = mosynt_TraceString(*(void *)(v3 + 312), v5, 1u);
            if ((result & 0x80000000) != 0) {
              return result;
            }
            if (++v7 >= (unint64_t)*(unsigned __int16 *)(v3 + 104)) {
              goto LABEL_24;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t hlp_ReconstituteLayers(uint64_t a1)
{
  unsigned __int16 v11 = 0;
  __src = 0;
  uint64_t v2 = (*(uint64_t (**)(void, void, void, char **, unsigned __int16 *))(*(void *)(a1 + 32) + 128))(*(void *)(a1 + 16), *(void *)(a1 + 24), 0, &__src, &v11);
  if ((v2 & 0x80000000) == 0)
  {
    char v3 = __src[v11];
    __src[v11] = 0;
    unsigned int v4 = __src;
    strncpy(**(char ***)(a1 + 400), __src, 0x1387uLL);
    *(unsigned char *)(**(void **)(a1 + 400) + 4999) = 0;
    v4[v11] = v3;
    if (*(unsigned __int16 *)(a1 + 104) >= 2u)
    {
      uint64_t v5 = 1;
      while (1)
      {
        int v6 = v5 == 1 ? 126 : 0;
        uint64_t v7 = mosynt_AlignFieldsWithRef(**(void **)(a1 + 400), *(void *)(*(void *)(a1 + 400) + 8 * v5), *(void *)(a1 + 384), 0x1388u, v6);
        if ((v7 & 0x80000000) != 0) {
          break;
        }
        strcpy(*(char **)(*(void *)(a1 + 400) + 8 * v5), *(const char **)(a1 + 384));
        unsigned __int16 v8 = strlen(*(const char **)(a1 + 384));
        uint64_t v2 = (*(uint64_t (**)(void, void, void, void, void))(*(void *)(a1 + 32) + 120))(*(void *)(a1 + 16), *(void *)(a1 + 24), (unsigned __int16)v5, *(void *)(a1 + 384), v8);
        if ((v2 & 0x80000000) == 0 && ++v5 < (unint64_t)*(unsigned __int16 *)(a1 + 104)) {
          continue;
        }
        return v2;
      }
      return v7;
    }
  }
  return v2;
}

uint64_t fe_global_ApplyFSTs(uint64_t a1)
{
  uint64_t v21 = 0;
  int v18 = 0;
  uint64_t result = paramc_ParamGetStr(*(void *)(*(void *)a1 + 40), (uint64_t)"langcode", &v21);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  int v3 = *v21;
  uint64_t result = mosynt_NormalizeSpaceFields(**(unsigned char ***)(a1 + 400), *(void *)(a1 + 384), 0x1388u);
  if ((result & 0x80000000) != 0) {
    return result;
  }
  unsigned __int16 v4 = 0;
  LOWORD(v5) = 0;
  while (1)
  {
    int v6 = *(char **)(a1 + 384);
    int v7 = v6[v4];
    if (v7 == 32)
    {
      if ((unsigned __int16)v5 >= v4)
      {
        LOBYTE(v7) = 32;
      }
      else
      {
        uint64_t v5 = (unsigned __int16)v5;
        do
          *(unsigned char *)(*(void *)(a1 + 384) + v5++) = 126;
        while (v4 != v5);
        int v6 = *(char **)(a1 + 384);
        LOBYTE(v7) = v6[v4];
        LOWORD(v5) = v4;
      }
      goto LABEL_13;
    }
    if (v7 == 126) {
      goto LABEL_14;
    }
    if (!v6[v4]) {
      break;
    }
LABEL_13:
    v6[(unsigned __int16)v5] = v7;
    LOWORD(v5) = v5 + 1;
LABEL_14:
    ++v4;
  }
  if ((unsigned __int16)v5 < v4)
  {
    uint64_t v8 = (unsigned __int16)v5;
    do
      *(unsigned char *)(*(void *)(a1 + 384) + v8++) = 126;
    while (v4 != v8);
    int v6 = *(char **)(a1 + 384);
  }
  mosynt_SubstAllSubstrOcc(v6, "~", " ", *(unsigned char **)(a1 + 392), 5000);
  uint64_t result = mosynt_SubstAllSubstrOcc(*(char **)(a1 + 392), "¡", "~", *(unsigned char **)(a1 + 384), 5000);
  if ((result & 0x80000000) == 0)
  {
    unsigned int v19 = 0;
    __int16 v17 = 95;
    int v9 = *(unsigned char **)(a1 + 384);
    if (*v9)
    {
      unsigned __int16 v10 = 0;
      int v11 = 0;
      while (1)
      {
        utf8_getUTF8Char((uint64_t)v9, (unsigned __int16)v11, __s);
        int v12 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 400) + 32) + v10);
        if ((char)v12 < 33 || (char)v3 < 33 || v12 == v3) {
          unint64_t v13 = __s;
        }
        else {
          unint64_t v13 = (char *)&v17;
        }
        uint64_t result = mosynt_App(*(void *)(a1 + 392), 5000, &v19, v13, &v18);
        if ((result & 0x80000000) != 0) {
          break;
        }
        v11 += strlen(__s);
        ++v10;
        int v9 = *(unsigned char **)(a1 + 384);
        if (!v9[(unsigned __int16)v11])
        {
          uint64_t v14 = v19;
          goto LABEL_31;
        }
      }
    }
    else
    {
      uint64_t v14 = 0;
LABEL_31:
      *(unsigned char *)(*(void *)(a1 + 392) + v14) = 0;
      uint64_t result = mosynt_SentPhono(*(void *)(a1 + 312), *(uint64_t **)(a1 + 336), *(void *)(a1 + 344), *(unsigned __int8 **)(a1 + 392), *(char **)(*(void *)(a1 + 400) + 40), *(char **)(a1 + 368), 5000);
      if ((result & 0x80000000) == 0)
      {
        uint64_t result = mosynt_SubstAllSubstrOcc(*(char **)(a1 + 368), "~", "¡", *(unsigned char **)(a1 + 392), 5000);
        if ((result & 0x80000000) == 0)
        {
          strcpy(*(char **)(a1 + 368), *(const char **)(a1 + 392));
          __int16 v17 = 95;
          __int16 v16 = 123;
          uint64_t result = mosynt_SubstAllSubstrOcc(*(char **)(a1 + 368), &v17, &v16, *(unsigned char **)(a1 + 384), 5000);
          if ((result & 0x80000000) == 0)
          {
            uint64_t result = mosynt_ReplaceNonSpaceFields(**(void **)(a1 + 400), *(void *)(a1 + 384), *(void *)(a1 + 376), 0x1388u, 126, 1);
            if ((result & 0x80000000) == 0)
            {
              unsigned __int16 v15 = strlen(*(const char **)(a1 + 376));
              return (*(uint64_t (**)(void, void, void, void, void))(*(void *)(a1 + 32) + 120))(*(void *)(a1 + 16), *(void *)(a1 + 24), 0, *(void *)(a1 + 376), v15);
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t fe_global_CleanTriggerOrth(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v26 = 0;
  int v27 = 0;
  __int16 v25 = 0;
  __s1 = 0;
  uint64_t v24 = 0;
  unsigned __int16 v22 = 0;
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char **, int *))(*(void *)(a1 + 8) + 176))(a2, a3, a4, 0, &__s1, &v26);
  if ((v8 & 0x80000000) != 0) {
    return v8;
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *, unsigned __int16 *))(*(void *)(a1 + 8) + 176))(a2, a3, a4, 1, &v24, &v22);
  if ((v9 & 0x80000000) == 0)
  {
    unsigned __int16 v10 = strstr(__s1, (const char *)(a1 + 360));
    if (v10)
    {
      int v11 = v10;
LABEL_5:
      size_t v12 = strlen((const char *)(a1 + 360));
      unsigned __int16 v13 = v12;
      uint64_t v14 = &v11[v12];
      unsigned __int16 v15 = strlen(v11);
      memmove(v11, v14, v15 - (unint64_t)v13 + 1);
      uint64_t v16 = v22;
      if (v22)
      {
        uint64_t v17 = v24;
        unsigned int v18 = (unsigned __int16)((_WORD)v11 - (_WORD)__s1);
        unsigned int v19 = (_DWORD *)(v24 + 12);
        do
        {
          if (*v19 - *(_DWORD *)(v17 + 12) > v18) {
            *v19 -= (unsigned __int16)strlen((const char *)(a1 + 360));
          }
          v19 += 8;
          --v16;
        }
        while (v16);
      }
      for (uint64_t i = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *))(*(void *)(a1 + 8) + 104))(a2, a3, 2, a4, (char *)&v27 + 2);
            ;
            uint64_t i = (*(uint64_t (**)(uint64_t, uint64_t, void, char *))(*(void *)(a1 + 8) + 120))(a2, a3, HIWORD(v27), (char *)&v27 + 2))
      {
        uint64_t v9 = i;
        if ((i & 0x80000000) != 0) {
          break;
        }
        if (!HIWORD(v27))
        {
          int v11 = strstr(__s1, (const char *)(a1 + 360));
          if (v11) {
            goto LABEL_5;
          }
          return v9;
        }
        uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, int *))(*(void *)(a1 + 8)
                                                                                                 + 168))(a2, a3, HIWORD(v27), 1, 1, &v27, &v26);
        if ((v8 & 0x80000000) != 0) {
          return v8;
        }
        if (v11 - __s1 < (unsigned __int16)v27)
        {
          LOWORD(v27) = v27 - strlen((const char *)(a1 + 360));
          uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, __int16 *))(*(void *)(a1 + 8) + 160))(a2, a3, HIWORD(v27), 1, 1, &v27, &v25);
          if ((v8 & 0x80000000) != 0) {
            return v8;
          }
        }
        uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(*(void *)(a1 + 8)
                                                                                                  + 168))(a2, a3, HIWORD(v27), 2, 1, (char *)&v26 + 2, &v26);
        if ((v8 & 0x80000000) != 0) {
          return v8;
        }
        if (v11 - __s1 < HIWORD(v26))
        {
          HIWORD(v26) -= strlen((const char *)(a1 + 360));
          uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, __int16 *))(*(void *)(a1 + 8) + 160))(a2, a3, HIWORD(v27), 2, 1, (char *)&v26 + 2, &v25);
          if ((v8 & 0x80000000) != 0) {
            return v8;
          }
        }
      }
    }
  }
  return v9;
}

uint64_t fe_global_ProcessEnd(uint64_t a1, int a2)
{
  LODWORD(result) = safeh_HandleCheck(a1, a2, 62344, 408);
  if ((int)result >= 0) {
    return result;
  }
  else {
    return 2316312584;
  }
}

uint64_t fe_global_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2316312577;
  }
  uint64_t result = 0;
  *a2 = &IFeGlobal;
  return result;
}

uint64_t fe_global_ClassOpen(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0;
  if (!a3) {
    return 2316312583;
  }
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *(void *)a3 = a1;
    *(void *)(a3 + 8) = a2;
  }
  return result;
}

uint64_t fe_global_ClassClose()
{
  return 0;
}

uint64_t get_ner_brokerstring(uint64_t a1, char *a2, unint64_t a3)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v7 = 0;
  *(void *)uint64_t v8 = 0;
  memset(v9, 0, sizeof(v9));
  uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"langcode", v8);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"fecfg", &v7);
    if ((result & 0x80000000) == 0)
    {
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      return brokeraux_ComposeBrokerString(a1, (const char *)v9, 1, 1, *(char **)v8, 0, 0, a2, a3);
    }
  }
  return result;
}

uint64_t updateNLUNE(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7)
{
  int v28 = 0;
  __int16 v27 = 0;
  long long __s = 0;
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char *))(a4 + 184))(a2, a3, a5, 14, (char *)&v28 + 2);
  if ((v14 & 0x80000000) != 0) {
    return v14;
  }
  if (!HIWORD(v28))
  {
LABEL_5:
    unsigned __int16 v15 = &byte_20D5A22AE;
    long long __s = &byte_20D5A22AE;
    goto LABEL_8;
  }
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char **, int *))(a4 + 176))(a2, a3, a5, 14, &__s, &v28);
  if ((v14 & 0x80000000) != 0) {
    return v14;
  }
  if ((unsigned __int16)v28 < 2u) {
    goto LABEL_5;
  }
  unsigned __int16 v15 = __s;
LABEL_8:
  size_t v17 = strlen(v15);
  unsigned int v18 = (char *)heap_Calloc(*(void **)(a1 + 8), v17 + 7, 1);
  if (!v18) {
    return 2314215434;
  }
  unsigned int v19 = v18;
  uint64_t v20 = strcpy(v18, __s);
  hlp_NLUStrSet(v20, "NE", (char *)(*(void *)(a7 + 8) + 40 * a6 + 30));
  log_OutText(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"updating WordRecord[%d] word[%d] LD_W_NLU %s -> %s", v21, v22, v23, a5);
  __int16 v24 = strlen(v19);
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, const char *, __int16 *))(a4 + 160))(a2, a3, a5, 14, (unsigned __int16)(v24 + 1), v19, &v27);
  heap_Free(*(void **)(a1 + 8), (uint64_t)v19);
  return v16;
}

uint64_t ner_process(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  int v39 = 0;
  unsigned __int16 v38 = 0;
  uint64_t v36 = 0;
  size_t v37 = 0;
  uint64_t v35 = 0;
  *(void *)(a2 + 8) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(void *)(a2 + 24) = 0;
  uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *))(a5 + 104))(a3, a4, 1, 0, (char *)&v39 + 2);
  if ((v17 & 0x80000000) != 0) {
    return v17;
  }
  uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, int *))(a5 + 184))(a3, a4, HIWORD(v39), 0, &v39);
  if ((v18 & 0x80000000) == 0 && (unsigned __int16)v39 == 1)
  {
    uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, const char **, unsigned __int16 *))(a5 + 176))(a3, a4, HIWORD(v39), 0, &v35, &v38);
    if ((v18 & 0x80000000) == 0 && v38 >= 2u)
    {
      uint64_t v19 = a9 || *(_DWORD *)(a2 + 36) != 1
          ? ner_getSentenceData(a1, a3, a4, a5, HIWORD(v39), v35, a2, a6, a7, a8, (uint64_t *)&v37)
          : ner_getSentenceData(a1, a3, a4, a5, HIWORD(v39), v35, a2, *(void *)(a2 + 48), *(void *)(a2 + 72), *(void *)(a2 + 80), (uint64_t *)&v37);
      uint64_t v18 = v19;
      if ((v19 & 0x80000000) == 0)
      {
        if (*(_WORD *)(a2 + 16))
        {
          uint64_t v18 = fi_predict(*(uint64_t ****)a2, &v37, *(unsigned __int16 *)(a2 + 18), &v36, v20, v21, v22, v23);
          if ((v18 & 0x80000000) != 0)
          {
            log_OutText(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"FI NER Prediction Failed", v25, v26, v27, 0);
            return v18;
          }
          if (*(_WORD *)(a2 + 16))
          {
            unint64_t v28 = 0;
            unsigned __int16 v29 = 0;
            uint64_t v30 = v36;
            uint64_t v31 = *(void *)(a2 + 8);
            int v32 = 78;
            do
            {
              if (!*(_WORD *)(v31 + 40 * v28 + 24)) {
                goto LABEL_26;
              }
              uint64_t v33 = 0;
              while (!v33)
              {
                int v32 = **(unsigned __int8 **)(v30 + 8 * v29);
                *(unsigned char *)(v31 + 40 * v28 + 30) = v32;
                *(unsigned char *)(*(void *)(a2 + 8) + 40 * v28 + 31) = 0;
                uint64_t v31 = *(void *)(a2 + 8);
LABEL_25:
                if (++v33 >= (unint64_t)*(unsigned __int16 *)(v31 + 40 * v28 + 24)) {
                  goto LABEL_26;
                }
              }
              int v34 = **(unsigned __int8 **)(v30 + 8 * v29 + 8 * v33);
              if (v32 == v34 || v34 == 78 || v32 == 78) {
                goto LABEL_25;
              }
              int v32 = 78;
              *(unsigned char *)(v31 + 40 * v28 + 30) = 78;
              *(unsigned char *)(*(void *)(a2 + 8) + 40 * v28 + 31) = 0;
              uint64_t v31 = *(void *)(a2 + 8);
LABEL_26:
              v29 += *(_WORD *)(v31 + 40 * v28++ + 24);
            }
            while (v28 < *(unsigned __int16 *)(a2 + 16));
          }
        }
      }
    }
  }
  return v18;
}

uint64_t ner_getSentenceData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t *a11)
{
  uint64_t v18 = a1;
  uint64_t v87 = 0;
  log_OutText(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"ner: processing=\"%s\"", (uint64_t)a6, a7, a8, (uint64_t)a6);
  *(_WORD *)(a7 + 18) = 0;
  *(void *)(a7 + 8) = 0;
  if (a6)
  {
    unsigned __int16 v22 = strlen(a6);
    unsigned __int16 v23 = 1;
    uint64_t v24 = v22;
    if (v22)
    {
      uint64_t v25 = a6;
      do
      {
        int v27 = *(unsigned __int8 *)v25++;
        int v26 = v27;
        if (v27 == 95 || v26 == 32) {
          ++v23;
        }
        --v24;
      }
      while (v24);
      *(_WORD *)(a7 + 16) = v23;
      if (!v23) {
        goto LABEL_11;
      }
    }
    else
    {
      *(_WORD *)(a7 + 16) = 1;
    }
    uint64_t v28 = 2314215434;
    unsigned __int16 v91 = 0;
    int v89 = 0;
    unsigned int v90 = 0;
    unsigned __int16 v88 = 0;
    unsigned int v86 = 0;
    uint64_t v29 = heap_Calloc(*(void **)(v18 + 8), v23, 40);
    *(void *)(a7 + 8) = v29;
    if (v29)
    {
      uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, unsigned __int16 *))(a4 + 104))(a2, a3, 2, a5, &v91);
      if ((v30 & 0x80000000) != 0)
      {
LABEL_68:
        uint64_t v28 = v30;
      }
      else
      {
        unsigned __int16 v31 = v91;
        if (!v91)
        {
LABEL_77:
          *(_WORD *)(a7 + 16) = 0;
          heap_Free(*(void **)(v18 + 8), *(void *)(a7 + 8));
          *(void *)(a7 + 8) = 0;
          return v30;
        }
        uint64_t v82 = a8;
        __int16 v32 = 0;
        int v85 = 0;
        while (1)
        {
          unsigned int v33 = (unsigned __int16)v85 - 1;
          while (1)
          {
            uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, unsigned int *, char *))(a4 + 168))(a2, a3, v31, 0, 1, &v90, (char *)&v89 + 2);
            if ((v34 & 0x80000000) != 0) {
              goto LABEL_78;
            }
            if (v90 > 0xA || ((1 << v90) & 0x610) == 0) {
              goto LABEL_59;
            }
            uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, char *))(a4 + 168))(a2, a3, v91, 1, 1, &v89, (char *)&v89 + 2);
            if ((v34 & 0x80000000) != 0) {
              goto LABEL_78;
            }
            uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned __int16 *, char *))(a4 + 168))(a2, a3, v91, 2, 1, &v88, (char *)&v89 + 2);
            if ((v34 & 0x80000000) != 0) {
              goto LABEL_78;
            }
            __int16 v39 = v89;
            if ((unsigned __int16)v89 >= v88)
            {
              log_OutText(*(void *)(v18 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"ner: out of memory", v36, v37, v38, v77);
              unsigned __int16 v66 = 16049;
LABEL_87:
              uint64_t v28 = v66 | 0x89F00000;
              goto LABEL_88;
            }
            ++v32;
            uint64_t v40 = *(void *)(a7 + 8);
            if (!(_WORD)v85
              || (unsigned __int16)v89 != *(unsigned __int16 *)(v40 + 40 * v33 + 26)
              || v88 != *(unsigned __int16 *)(v40 + 40 * v33 + 28))
            {
              break;
            }
            uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t, void, unsigned __int16 *))(a4 + 120))(a2, a3, v91, &v91);
            if ((v30 & 0x80000000) != 0) {
              goto LABEL_68;
            }
            unsigned __int16 v31 = v91;
            if (!v91) {
              goto LABEL_70;
            }
          }
          if (*(unsigned __int16 *)(a7 + 16) <= (unsigned __int16)v85)
          {
            *(_WORD *)(a7 + 16) = v85 + 1;
            uint64_t v41 = heap_Realloc(*(uint64_t **)(v18 + 8), v40, 40 * (unsigned __int16)(v85 + 1));
            *(void *)(a7 + 8) = v41;
            if (!v41) {
              break;
            }
            uint64_t v40 = v41;
            __int16 v39 = v89;
          }
          uint64_t v42 = v40 + 40 * (unsigned __int16)v85;
          *(_WORD *)(v42 + 26) = v39;
          *(_WORD *)(v42 + 28) = v88;
          unsigned __int16 v43 = v88 - v89;
          *(void *)uint64_t v42 = 0;
          size_t v44 = v43;
          int v45 = (char *)heap_Alloc(*(void *)(v18 + 8), v43 + 1);
          *(void *)(*(void *)(a7 + 8) + 40 * (unsigned __int16)v85) = v45;
          if (!v45) {
            break;
          }
          strncpy(v45, &a6[(unsigned __int16)v89], v44);
          *(unsigned char *)(*(void *)(*(void *)(a7 + 8) + 40 * (unsigned __int16)v85) + v44) = 0;
          uint64_t v46 = *(void *)(a7 + 8);
          uint64_t v47 = v46 + 40 * (unsigned __int16)v85;
          uint64_t v48 = *(const char **)v47;
          unsigned __int16 v79 = (__int16 *)(v47 + 24);
          char v93 = 0;
          *(_DWORD *)long long __s = 0;
          __int16 v83 = (uint64_t *)v47;
          *(void *)(v47 + 16) = 0;
          char v49 = (uint64_t *)(v47 + 16);
          __int16 v50 = Utf8_Utf8NbrOfSymbols(v48);
          if (v50 == 1)
          {
            __int16 v63 = 0;
          }
          else
          {
            uint64_t v84 = v18;
            uint64_t v51 = 0;
            unsigned __int16 v52 = 0;
            int v81 = (int *)(v46 + 40 * (unsigned __int16)v85 + 32);
            unsigned __int16 v78 = v50 - 1;
            uint64_t v80 = (unsigned __int16)(v50 - 1);
            while (1)
            {
              unsigned __int16 v53 = v52;
              uint64_t UTF8Char = utf8_getUTF8Char(*v83, v52, __s);
              if ((UTF8Char & 0x80000000) != 0)
              {
                uint64_t v28 = UTF8Char;
                uint64_t v18 = v84;
                goto LABEL_88;
              }
              BOOL IsChineseLetter = utf8_IsChineseLetter(__s);
              if (strlen(__s) > 1
                || (__s[0] - 33 <= 0x3E
                  ? (BOOL v56 = ((1 << (__s[0] - 33)) & 0x7400000056003D8DLL) == 0)
                  : (BOOL v56 = 1),
                    v56 && __s[0] != 124))
              {
                if (!v51 && !IsChineseLetter) {
                  break;
                }
              }
              if (!v51)
              {
                int *v81 = 0;
                uint64_t v57 = heap_Calloc(*(void **)(v84 + 8), v80, 8);
                *char v49 = v57;
                if (!v57)
                {
                  uint64_t v18 = v84;
LABEL_86:
                  unsigned __int16 v66 = 8202;
                  goto LABEL_87;
                }
              }
              size_t v58 = strlen(__s);
              *(void *)(*v49 + v51) = heap_Calloc(*(void **)(v84 + 8), v58 + 1, 1);
              unsigned __int16 v59 = *(char **)(*v49 + v51);
              if (!v59)
              {
                uint64_t v73 = 0;
                uint64_t v18 = v84;
                do
                {
                  uint64_t v74 = *v49;
                  uint64_t v75 = *(void *)(*v49 + v73);
                  if (v75)
                  {
                    heap_Free(*(void **)(v84 + 8), v75);
                    uint64_t v74 = *v49;
                  }
                  *(void *)(v74 + v73) = 0;
                  v73 += 8;
                }
                while (8 * v78 != v73);
                heap_Free(*(void **)(v84 + 8), *v49);
                *char v49 = 0;
                goto LABEL_86;
              }
              strcpy(v59, __s);
              unsigned __int16 v52 = v53 + strlen(__s);
              v51 += 8;
              if (8 * v80 == v51)
              {
                uint64_t v18 = v84;
                int v60 = v85;
                uint64_t v28 = 2314215434;
                unsigned int v61 = (unsigned __int16)v85;
                __int16 v63 = v78;
                uint64_t v62 = v79;
                goto LABEL_56;
              }
            }
            if ((__s[0] & 0xDFu) - 65 < 0x1A) {
              int v65 = 1;
            }
            else {
              int v65 = 3;
            }
            if (__s[0] - 48 < 0xA) {
              int v65 = 2;
            }
            int *v81 = v65;
            __int16 v63 = 1;
            uint64_t v18 = v84;
          }
          uint64_t v28 = 2314215434;
          int v60 = v85;
          unsigned int v61 = (unsigned __int16)v85;
          uint64_t v62 = v79;
LABEL_56:
          *uint64_t v62 = v63;
          uint64_t v64 = *(void *)(a7 + 8);
          *(_WORD *)(a7 + 18) += *(_WORD *)(v64 + 40 * v61 + 24);
          if (*(_DWORD *)(a7 + 32)) {
            (*(void (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *))(a4 + 176))(a2, a3, v91, 5, v64 + 40 * v61 + 8, (char *)&v89 + 2);
          }
          int v85 = v60 + 1;
LABEL_59:
          uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t, void, unsigned __int16 *))(a4 + 120))(a2, a3, v91, &v91);
          if ((v30 & 0x80000000) != 0) {
            goto LABEL_68;
          }
          unsigned __int16 v31 = v91;
          if (!v91)
          {
LABEL_70:
            if (!v32) {
              goto LABEL_77;
            }
            uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned int *))(v82 + 40))(a9, a10, &v86);
            if ((v34 & 0x80000000) != 0)
            {
LABEL_78:
              uint64_t v28 = v34;
              break;
            }
            unsigned int v67 = v86;
            if (*(_DWORD *)(a7 + 32)) {
              unsigned int v67 = v86 + *(unsigned __int16 *)(a7 + 40);
            }
            uint64_t v68 = heap_Calloc(*(void **)(v18 + 8), v67 * *(unsigned __int16 *)(a7 + 18), 4);
            uint64_t v87 = v68;
            if (v68)
            {
              uint64_t v69 = v68;
              uint64_t v70 = *(void *)(a7 + 8);
              unsigned int v71 = *(unsigned __int16 *)(a7 + 16);
              if (*(_DWORD *)(a7 + 32)) {
                uint64_t CharEmbeddingWithPOS = getCharEmbeddingWithPOS(v18, v82, a9, a10, &v87, v86, v70, v71, *(unsigned __int16 *)(a7 + 40));
              }
              else {
                uint64_t CharEmbeddingWithPOS = getCharEmbedding(v18, v82, a9, a10, &v87, v86, v70, v71);
              }
              uint64_t v28 = CharEmbeddingWithPOS;
              if ((CharEmbeddingWithPOS & 0x80000000) != 0)
              {
                ner_freeNEData(v18, a7);
                heap_Free(*(void **)(v18 + 8), v69);
              }
              else
              {
                *a11 = v69;
              }
              return v28;
            }
            break;
          }
        }
      }
    }
LABEL_88:
    ner_freeNEData(v18, a7);
    return v28;
  }
  *(_WORD *)(a7 + 16) = 0;
LABEL_11:
  *(void *)(a7 + 8) = 0;
  log_OutText(*(void *)(v18 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"ner: no words found", v19, v20, v21, v77);
  return 0;
}

uint64_t ner_freeNEData(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = *(void *)(a2 + 8);
    if (v3)
    {
      if (*(_WORD *)(a2 + 16))
      {
        unint64_t v5 = 0;
        do
        {
          if (*(void *)(v3 + 40 * v5))
          {
            heap_Free(*(void **)(a1 + 8), *(void *)(v3 + 40 * v5));
            uint64_t v3 = *(void *)(a2 + 8);
            *(void *)(v3 + 40 * v5) = 0;
          }
          uint64_t v6 = *(void *)(v3 + 40 * v5 + 16);
          if (v6)
          {
            unint64_t v7 = v3 + 40 * v5;
            int v9 = *(unsigned __int16 *)(v7 + 24);
            uint64_t v8 = (_WORD *)(v7 + 24);
            if (v9)
            {
              unint64_t v10 = 0;
              do
              {
                if (*(void *)(*(void *)(v3 + 40 * v5 + 16) + 8 * v10))
                {
                  heap_Free(*(void **)(a1 + 8), *(void *)(*(void *)(v3 + 40 * v5 + 16) + 8 * v10));
                  *(void *)(*(void *)(*(void *)(a2 + 8) + 40 * v5 + 16) + 8 * v10) = 0;
                  uint64_t v3 = *(void *)(a2 + 8);
                }
                ++v10;
                unint64_t v11 = v3 + 40 * v5;
                unsigned int v12 = *(unsigned __int16 *)(v11 + 24);
                uint64_t v8 = (_WORD *)(v11 + 24);
              }
              while (v10 < v12);
              uint64_t v6 = *(void *)(v3 + 40 * v5 + 16);
            }
            *uint64_t v8 = 0;
            heap_Free(*(void **)(a1 + 8), v6);
            uint64_t v3 = *(void *)(a2 + 8);
            *(void *)(v3 + 40 * v5 + 16) = 0;
          }
          ++v5;
        }
        while (v5 < *(unsigned __int16 *)(a2 + 16));
      }
      heap_Free(*(void **)(a1 + 8), v3);
      *(_WORD *)(a2 + 16) = 0;
      *(void *)(a2 + 8) = 0;
    }
  }
  return 0;
}

uint64_t getCharEmbeddingWithPOS(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, unsigned int a6, uint64_t a7, unsigned int a8, unsigned int a9)
{
  if (a8)
  {
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    uint64_t v14 = *a5;
    uint64_t v34 = a6;
    uint64_t v35 = a8;
    uint64_t v15 = 4 * a6;
    uint64_t v39 = v15 + 4 * a9;
    while (1)
    {
      uint64_t v16 = a7 + 40 * v12;
      int v19 = *(unsigned __int16 *)(v16 + 24);
      uint64_t v18 = (unsigned __int16 *)(v16 + 24);
      int v17 = v19;
      uint64_t v37 = v12;
      if (v19)
      {
        if (v17 != 1)
        {
          unint64_t v22 = 0;
          uint64_t v23 = a7 + 40 * v12;
          uint64_t v24 = (void *)(v23 + 16);
          uint64_t v25 = (char **)(v23 + 8);
          do
          {
            uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(a2 + 56))(a3, a4, *(void *)(*v24 + 8 * v22), v14);
            if ((v13 & 0x1FFF) == 0x14)
            {
              log_OutText(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"No embedding vector for character %s . Fall back!", v26, v27, v28, *(void *)(*v24 + 8 * v22));
              uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(a2 + 56))(a3, a4, "</s>", v14);
            }
            uint64_t v40 = v14 + v15;
            getPOSFeature(*v25, &v40);
            v14 += v39;
            uint64_t v40 = v14;
            ++v22;
          }
          while (v22 < *v18);
          goto LABEL_21;
        }
        int v20 = *(_DWORD *)(a7 + 40 * v12 + 32);
        switch(v20)
        {
          case 1:
            uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(a2 + 56))(a3, a4, "ENG", v14);
            break;
          case 2:
            uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(a2 + 56))(a3, a4, "NUM", v14);
            break;
          case 3:
            uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(a2 + 56))(a3, a4, "</s>", v14);
            break;
          default:
            unint64_t v29 = 0;
            uint64_t v30 = a7 + 40 * v12;
            unsigned __int16 v31 = (void *)(v30 + 16);
            __int16 v32 = (char **)(v30 + 8);
            do
            {
              uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(a2 + 56))(a3, a4, *(void *)(*v31 + 8 * v29), v14);
              if ((v13 & 0x1FFF) == 0x14) {
                uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(a2 + 56))(a3, a4, "</s>", v14);
              }
              uint64_t v40 = v14 + v15;
              getPOSFeature(*v32, &v40);
              v14 += v39;
              uint64_t v40 = v14;
              ++v29;
            }
            while (v29 < *v18);
            goto LABEL_21;
        }
        uint64_t v13 = v21;
        v14 += 4 * v34;
        uint64_t v40 = v14;
      }
LABEL_21:
      uint64_t v12 = v37 + 1;
      if (v37 + 1 == v35) {
        return v13;
      }
    }
  }
  return 0;
}

uint64_t getCharEmbedding(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, unsigned int a6, uint64_t a7, unsigned int a8)
{
  if (!a8) {
    return 0;
  }
  uint64_t v12 = 0;
  uint64_t result = 0;
  uint64_t v14 = *a5;
  uint64_t v15 = 4 * a6;
  uint64_t v28 = a6;
  uint64_t v29 = a8;
  uint64_t v30 = a7;
  do
  {
    uint64_t v16 = a7 + 40 * v12;
    int v19 = *(unsigned __int16 *)(v16 + 24);
    uint64_t v18 = (unsigned __int16 *)(v16 + 24);
    int v17 = v19;
    if (v19)
    {
      if (v17 == 1)
      {
        unsigned int v20 = *(_DWORD *)(a7 + 40 * v12 + 32) - 1;
        if (v20 >= 3)
        {
          unint64_t v26 = 0;
          uint64_t v27 = (void *)(a7 + 40 * v12 + 16);
          do
          {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(a2 + 56))(a3, a4, *(void *)(*v27 + 8 * v26), v14);
            if ((result & 0x1FFF) == 0x14) {
              uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(a2 + 56))(a3, a4, "</s>", v14);
            }
            ++v26;
            v14 += v15;
          }
          while (v26 < *v18);
        }
        else
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, char *, uint64_t))(a2 + 56))(a3, a4, off_264107FE0[v20], v14);
          v14 += 4 * v28;
        }
      }
      else
      {
        unint64_t v21 = 0;
        unint64_t v22 = (void *)(a7 + 40 * v12 + 16);
        do
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(a2 + 56))(a3, a4, *(void *)(*v22 + 8 * v21), v14);
          if ((result & 0x1FFF) == 0x14)
          {
            log_OutText(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"No embedding vector for character %s . Fall back!", v23, v24, v25, *(void *)(*v22 + 8 * v21));
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t))(a2 + 56))(a3, a4, "</s>", v14);
          }
          ++v21;
          v14 += v15;
        }
        while (v21 < *v18);
      }
    }
    ++v12;
    a7 = v30;
  }
  while (v12 != v29);
  return result;
}

BOOL getPOSFeature(char *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  BOOL result = utf8_ToLower(a1, 0, (uint64_t)v6);
  unsigned int v4 = v6[0] - 99;
  if (v4 > 0x16) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = qword_20D62D628[(char)v4];
  }
  *(_DWORD *)(v2 + 4 * v5) = 1065353216;
  return result;
}

uint64_t hlp_loadOptions(void *a1)
{
  uint64_t v2 = a1[13];
  if (v2)
  {
    heap_Free(*(void **)(*a1 + 8), v2);
    a1[15] = 0;
  }
  uint64_t v3 = heap_Alloc(*(void *)(*a1 + 8), 128);
  a1[13] = v3;
  if (v3)
  {
    a1[15] = 128;
    uint64_t v8 = a1[14];
    if (v8)
    {
      heap_Free(*(void **)(*a1 + 8), v8);
      a1[16] = 0;
    }
    uint64_t v9 = heap_Alloc(*(void *)(*a1 + 8), 128);
    a1[14] = v9;
    if (v9)
    {
      a1[16] = 128;
      uint64_t v10 = a1[19];
      if (v10) {
        heap_Free(*(void **)(*a1 + 8), v10);
      }
      uint64_t v11 = heap_Alloc(*(void *)(*a1 + 8), 128);
      a1[19] = v11;
      if (v11)
      {
        uint64_t v12 = a1[20];
        if (v12) {
          heap_Free(*(void **)(*a1 + 8), v12);
        }
        uint64_t v13 = heap_Alloc(*(void *)(*a1 + 8), 128);
        a1[20] = v13;
        if (v13)
        {
          uint64_t v14 = a1[21];
          if (v14) {
            heap_Free(*(void **)(*a1 + 8), v14);
          }
          uint64_t v15 = heap_Alloc(*(void *)(*a1 + 8), 128);
          a1[21] = v15;
          if (v15)
          {
            uint64_t v16 = a1[22];
            if (v16) {
              heap_Free(*(void **)(*a1 + 8), v16);
            }
            uint64_t v17 = heap_Alloc(*(void *)(*a1 + 8), 128);
            a1[22] = v17;
            if (v17) {
              return 0;
            }
          }
        }
      }
    }
  }
  log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v4, v5, v6, v7, v19);
  return 2314215434;
}

uint64_t hlp_loadNNOptions(uint64_t a1)
{
  uint64_t v2 = 2314216452;
  *(void *)&__c[3] = 0;
  *(_WORD *)&__c[1] = -1;
  __c[0] = 0;
  __int16 v50 = 0;
  __lasts = 0;
  if (((*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", "stathmogrph_nn_chars", &__c[3], &__c[1], __c) & 0x80000000) != 0|| !*(_WORD *)&__c[1])
  {
    return v2;
  }
  uint64_t v3 = **(const char ***)&__c[3];
  uint64_t v4 = strchr(**(char ***)&__c[3], __c[0]);
  if (v4)
  {
    char *v4 = 0;
    uint64_t v3 = **(const char ***)&__c[3];
  }
  size_t v5 = strlen(v3);
  uint64_t v6 = heap_Alloc(*(void *)(*(void *)a1 + 8), v5 + 1);
  if (!v6)
  {
    log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v7, v8, v9, v10, v45);
    return 2314215434;
  }
  uint64_t v11 = (char *)v6;
  size_t v12 = strlen(**(const char ***)&__c[3]);
  strncpy(v11, **(const char ***)&__c[3], v12);
  v11[strlen(**(const char ***)&__c[3])] = 0;
  *(_WORD *)&__c[1] = -1;
  uint64_t v13 = 0;
  if (((*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", "stathmogrph_nn_default_phones", &__c[3], &__c[1], __c) & 0x80000000) != 0|| !*(_WORD *)&__c[1])
  {
    goto LABEL_38;
  }
  uint64_t v14 = **(const char ***)&__c[3];
  uint64_t v15 = strchr(**(char ***)&__c[3], __c[0]);
  if (v15)
  {
    *uint64_t v15 = 0;
    uint64_t v14 = **(const char ***)&__c[3];
  }
  size_t v16 = strlen(v14);
  uint64_t v13 = (char *)heap_Alloc(*(void *)(*(void *)a1 + 8), v16 + 1);
  if (!v13) {
    goto LABEL_36;
  }
  size_t v21 = strlen(**(const char ***)&__c[3]);
  strncpy(v13, **(const char ***)&__c[3], v21);
  v13[strlen(**(const char ***)&__c[3])] = 0;
  unint64_t v22 = *(void **)(*(void *)a1 + 8);
  *(void *)&long long v46 = ssftmap_ElemCopyString;
  *((void *)&v46 + 1) = ssftmap_ElemFreeString;
  uint64_t v47 = ssftmap_ElemCompareKeysString;
  uint64_t v48 = ssftmap_ElemCopyString;
  char v49 = ssftmap_ElemFreeString;
  uint64_t v23 = ssftmap_ObjOpen(v22, 0, &v46, (uint64_t *)(a1 + 248));
  if ((v23 & 0x80000000) != 0)
  {
LABEL_18:
    uint64_t v2 = v23;
    goto LABEL_38;
  }
  uint64_t v24 = strtok_r(v11, "|", &__lasts);
  for (uint64_t i = v13; ; uint64_t i = 0)
  {
    unint64_t v26 = strtok_r(i, "|", &v50);
    if (!v24 || !v26) {
      break;
    }
    uint64_t v23 = ssftmap_Insert(*(void *)(a1 + 248), (uint64_t)v24, (uint64_t)v26);
    if ((v23 & 0x80000000) != 0) {
      goto LABEL_18;
    }
    uint64_t v24 = strtok_r(0, "|", &__lasts);
  }
  if (v24 || v26)
  {
    log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"NN chars amount and default phones amount do not match!", v27, v28, v29, 0);
    uint64_t v2 = 2314215439;
    goto LABEL_38;
  }
  *(_WORD *)&__c[1] = -1;
  if (((*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", "stathmogrph_nn_step", &__c[3], &__c[1], __c) & 0x80000000) == 0)
  {
    if (*(_WORD *)&__c[1])
    {
      *(_DWORD *)(a1 + 256) = 0;
      *(_DWORD *)(a1 + 256) = (unsigned __int16)LH_atou(**(const char ***)&__c[3]);
      *(_WORD *)&__c[1] = -1;
      if (((*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", "stathmogrph_nn_vect", &__c[3], &__c[1], __c) & 0x80000000) == 0)
      {
        if (*(_WORD *)&__c[1])
        {
          *(_DWORD *)(a1 + 260) = 0;
          *(_DWORD *)(a1 + 260) = (unsigned __int16)LH_atou(**(const char ***)&__c[3]);
          *(_WORD *)&__c[1] = -1;
          if (((*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", "stathmogrph_nn_null_fea", &__c[3], &__c[1], __c) & 0x80000000) == 0)
          {
            if (*(_WORD *)&__c[1])
            {
              *(void *)(a1 + 272) = 0;
              uint64_t v30 = **(const char ***)&__c[3];
              unsigned __int16 v31 = strchr(**(char ***)&__c[3], __c[0]);
              if (v31)
              {
                *unsigned __int16 v31 = 0;
                uint64_t v30 = **(const char ***)&__c[3];
              }
              size_t v32 = strlen(v30);
              uint64_t v33 = heap_Alloc(*(void *)(*(void *)a1 + 8), v32 + 1);
              *(void *)(a1 + 272) = v33;
              if (v33)
              {
                uint64_t v34 = (char *)v33;
                size_t v35 = strlen(**(const char ***)&__c[3]);
                strncpy(v34, **(const char ***)&__c[3], v35);
                *(unsigned char *)(*(void *)(a1 + 272) + strlen(**(const char ***)&__c[3])) = 0;
                *(_WORD *)&__c[1] = -1;
                uint64_t v36 = (*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", "stathmogrph_embed_type", &__c[3], &__c[1], __c);
                if ((v36 & 0x80000000) == 0 && *(_WORD *)&__c[1])
                {
                  uint64_t v37 = v36;
                  *(void *)(a1 + 264) = 0;
                  uint64_t v38 = **(const char ***)&__c[3];
                  uint64_t v39 = strchr(**(char ***)&__c[3], __c[0]);
                  if (v39)
                  {
                    char *v39 = 0;
                    uint64_t v38 = **(const char ***)&__c[3];
                  }
                  size_t v40 = strlen(v38);
                  uint64_t v41 = heap_Alloc(*(void *)(*(void *)a1 + 8), v40 + 1);
                  *(void *)(a1 + 264) = v41;
                  if (v41)
                  {
                    uint64_t v42 = (char *)v41;
                    size_t v43 = strlen(**(const char ***)&__c[3]);
                    strncpy(v42, **(const char ***)&__c[3], v43);
                    *(unsigned char *)(*(void *)(a1 + 264) + strlen(**(const char ***)&__c[3])) = 0;
                    uint64_t v2 = v37;
                    goto LABEL_38;
                  }
                  goto LABEL_36;
                }
                goto LABEL_38;
              }
LABEL_36:
              log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v17, v18, v19, v20, v45);
              uint64_t v2 = 2314215434;
            }
          }
        }
      }
    }
  }
LABEL_38:
  heap_Free(*(void **)(*(void *)a1 + 8), (uint64_t)v11);
  if (v13) {
    heap_Free(*(void **)(*(void *)a1 + 8), (uint64_t)v13);
  }
  return v2;
}

uint64_t hlp_loadStatWordOptions(uint64_t a1)
{
  *(void *)&__c[3] = 0;
  __c[0] = 0;
  *(_WORD *)&__c[1] = -1;
  uint64_t v2 = (*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", "statwordhmogrph_step", &__c[3], &__c[1], __c);
  if ((v2 & 0x80000000) != 0) {
    return v2;
  }
  *(_DWORD *)(a1 + 320) = 0;
  if (*(_WORD *)&__c[1]) {
    *(_DWORD *)(a1 + 320) = LH_atou(**(const char ***)&__c[3]);
  }
  *(_WORD *)&__c[1] = -1;
  uint64_t v2 = (*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", "statwordhmogrph_vect", &__c[3], &__c[1], __c);
  if ((v2 & 0x80000000) != 0) {
    return v2;
  }
  *(_DWORD *)(a1 + 324) = 0;
  if (*(_WORD *)&__c[1]) {
    *(_DWORD *)(a1 + 324) = LH_atou(**(const char ***)&__c[3]);
  }
  *(_WORD *)&__c[1] = -1;
  uint64_t v2 = (*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", "statwordhmogrph_thresholdpercent", &__c[3], &__c[1], __c);
  if ((v2 & 0x80000000) != 0) {
    return v2;
  }
  *(_DWORD *)(a1 + 328) = 0;
  if (*(_WORD *)&__c[1]) {
    *(_DWORD *)(a1 + 328) = LH_atou(**(const char ***)&__c[3]);
  }
  *(_WORD *)&__c[1] = -1;
  uint64_t v2 = (*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", "statwordhmogrph_list", &__c[3], &__c[1], __c);
  if ((v2 & 0x80000000) != 0) {
    return v2;
  }
  if (*(_WORD *)&__c[1])
  {
    uint64_t v7 = **(const char ***)&__c[3];
    uint64_t v8 = strchr(**(char ***)&__c[3], __c[0]);
    if (v8)
    {
      *uint64_t v8 = 0;
      uint64_t v7 = **(const char ***)&__c[3];
    }
    size_t v9 = strlen(v7);
    uint64_t v10 = (char *)heap_Alloc(*(void *)(*(void *)a1 + 8), v9 + 1);
    *(void *)(a1 + 336) = v10;
    if (v10)
    {
      strcpy(v10, **(const char ***)&__c[3]);
      strcpy((char *)(a1 + 364), "$MEANW2V$");
      *(_WORD *)&__c[1] = -1;
      if (((*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", "statwordhmogrph_fbck", &__c[3], &__c[1], __c) & 0x80000000) == 0&& *(_WORD *)&__c[1])
      {
        uint64_t v15 = strchr(**(char ***)&__c[3], __c[0]);
        if (v15) {
          *uint64_t v15 = 0;
        }
        __strcpy_chk();
      }
      *(void *)(a1 + 344) = 0x2D3A3F2E213B2CLL;
      *(_WORD *)&__c[1] = -1;
      if (((*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", "statwordhmogrph_punc", &__c[3], &__c[1], __c) & 0x80000000) == 0&& *(_WORD *)&__c[1])
      {
        size_t v16 = strchr(**(char ***)&__c[3], __c[0]);
        if (v16) {
          *size_t v16 = 0;
        }
        __strcpy_chk();
      }
      *(void *)(a1 + 354) = 0x30303433333030;
      *(_WORD *)&__c[1] = -1;
      if (((*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", "statwordhmogrph_mappunc", &__c[3], &__c[1], __c) & 0x80000000) == 0&& *(_WORD *)&__c[1])
      {
        uint64_t v17 = strchr(**(char ***)&__c[3], __c[0]);
        if (v17) {
          char *v17 = 0;
        }
        __strcpy_chk();
      }
      *(_DWORD *)(a1 + 376) = 0;
      *(_WORD *)&__c[1] = -1;
      uint64_t v18 = (*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", "statwordhmogrph_nnlkpcaseconv", &__c[3], &__c[1], __c);
      if ((v18 & 0x80000000) == 0 && *(_WORD *)&__c[1])
      {
        uint64_t v19 = **(const char ***)&__c[3];
        uint64_t v20 = strchr(**(char ***)&__c[3], __c[0]);
        if (v20)
        {
          *uint64_t v20 = 0;
          uint64_t v19 = **(const char ***)&__c[3];
        }
        if (!strcmp("yes", v19) || !strcmp("YES", v19)) {
          *(_DWORD *)(a1 + 376) = 1;
        }
      }
      *(void *)(a1 + 264) = 0;
    }
    else
    {
      uint64_t v18 = 2314215434;
      log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v11, v12, v13, v14, v22);
    }
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v3, v4, v5, v6, v22);
    return 2314215444;
  }
  return v18;
}

uint64_t fe_hmogrph_ObjOpen(_WORD *a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v62 = *MEMORY[0x263EF8340];
  uint64_t v59 = 0;
  int v60 = 0;
  uint64_t v5 = 2314215431;
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  uint64_t v55 = 0;
  uint64_t v56 = 0;
  uint64_t v52 = 0;
  uint64_t v53 = 0;
  memset(v61, 0, sizeof(v61));
  if (!a5) {
    return v5;
  }
  long long __s = 0;
  uint64_t v51 = 0;
  *(void *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v59);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t inited = InitRsrcFunction(a3, a4, &v60);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t inited = objc_GetObject(v60[6], (uint64_t)"LINGDB", &v58);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t Object = objc_GetObject(v60[6], (uint64_t)"FE_DCTLKP", &v56);
  uint64_t v13 = v60[6];
  if ((Object & 0x80000000) != 0)
  {
    uint64_t v34 = "LINGDB";
LABEL_25:
    objc_ReleaseObject(v13, (uint64_t)v34);
    return Object;
  }
  uint64_t v14 = objc_GetObject(v13, (uint64_t)"FE_DEPES", &v57);
  if ((v14 & 0x80000000) != 0)
  {
    uint64_t Object = v14;
    objc_ReleaseObject(v60[6], (uint64_t)"LINGDB");
    uint64_t v13 = v60[6];
    uint64_t v34 = "FE_DCTLKP";
    goto LABEL_25;
  }
  uint64_t v15 = heap_Alloc(v60[1], 488);
  if (!v15)
  {
    log_OutPublic(v60[4], (uint64_t)"FE_HMOGRPH", 37000, 0, v16, v17, v18, v19, v46);
    objc_ReleaseObject(v60[6], (uint64_t)"LINGDB");
    objc_ReleaseObject(v60[6], (uint64_t)"FE_DEPES");
    objc_ReleaseObject(v60[6], (uint64_t)"FE_DCTLKP");
    return 2314215434;
  }
  uint64_t v20 = v15;
  *(void *)uint64_t v15 = v60;
  *(void *)(v15 + 8) = a3;
  uint64_t v21 = v59;
  *(void *)(v15 + 16) = a4;
  *(void *)(v15 + 24) = v21;
  *(void *)(v15 + 32) = a1;
  *(void *)(v15 + 40) = a2;
  *(void *)(v15 + 48) = *(void *)(v58 + 8);
  uint64_t v22 = v57;
  *(void *)(v15 + 72) = *(void *)(v57 + 8);
  *(_OWORD *)(v15 + 56) = *(_OWORD *)(v22 + 16);
  uint64_t v23 = v56;
  uint64_t v24 = *(void *)(v56 + 8);
  *(void *)(v15 + 96) = v24;
  long long v25 = *(_OWORD *)(v23 + 16);
  *(_OWORD *)(v15 + 200) = 0u;
  uint64_t v26 = v15 + 200;
  *(_OWORD *)(v15 + 80) = v25;
  *(_OWORD *)(v15 + 104) = 0u;
  *(_OWORD *)(v15 + 120) = 0u;
  *(_WORD *)(v15 + 136) = 0;
  *(_OWORD *)(v15 + 152) = 0u;
  *(_OWORD *)(v15 + 168) = 0u;
  *(_OWORD *)(v15 + 216) = 0u;
  *(_OWORD *)(v15 + 232) = 0u;
  *(_OWORD *)(v15 + 248) = 0u;
  *(_OWORD *)(v15 + 264) = 0u;
  *(_OWORD *)(v15 + 280) = 0u;
  *(_OWORD *)(v15 + 296) = 0u;
  *(_OWORD *)(v15 + 312) = 0u;
  *(_OWORD *)(v15 + 328) = 0u;
  *(_OWORD *)(v15 + 344) = 0u;
  *(_OWORD *)(v15 + 360) = 0u;
  *(void *)(v15 + 376) = 0;
  *(void *)(v15 + 472) = 0;
  *(_OWORD *)(v15 + 440) = 0u;
  *(_OWORD *)(v15 + 456) = 0u;
  *(_OWORD *)(v15 + 408) = 0u;
  *(_OWORD *)(v15 + 424) = 0u;
  *(_OWORD *)(v15 + 392) = 0u;
  *(void *)(v15 + 188) = 0;
  *(_DWORD *)(v15 + 384) = 0;
  *(_DWORD *)(v15 + 480) = 0;
  *(void *)(v15 + 280) = 0;
  uint64_t OptionalHmogrphModels = (*(uint64_t (**)(void, void, char *, uint64_t *))(v24 + 88))(*(void *)(v15 + 80), *(void *)(v15 + 88), (char *)&v53 + 4, &v53);
  if ((OptionalHmogrphModels & 0x80000000) != 0) {
    goto LABEL_53;
  }
  BOOL v28 = v53 == 1 && HIDWORD(v53) == 1;
  BOOL v29 = v28;
  *(_DWORD *)(v20 + 184) = v29;
  uint64_t OptionalHmogrphModels = hlp_loadOptionalHmogrphModels(v20);
  if ((OptionalHmogrphModels & 0x80000000) != 0) {
    goto LABEL_53;
  }
  uint64_t OptionalHmogrphModels = hlp_loadNerOptions(v20);
  if ((OptionalHmogrphModels & 0x80000000) != 0) {
    goto LABEL_53;
  }
  uint64_t v30 = *(void *)v20;
  *(void *)(v20 + 200) = *(void *)v20;
  int v31 = paramc_ParamGet(*(void *)(v30 + 40), (uint64_t)"numberoutputtranscriptions", &__s, 0);
  __int16 v32 = 0;
  if ((v31 & 0x80000000) == 0 && __s) {
    __int16 v32 = atoi(__s);
  }
  *(_WORD *)(v20 + 138) = v32;
  BOOL v33 = (paramc_ParamGet(*(void *)(*(void *)v20 + 40), (uint64_t)"mlset", &__s, 0) & 0x80000000) == 0
     && strlen(__s) > 3;
  *(_DWORD *)(v20 + 140) = v33;
  uint64_t OptionalHmogrphModels = checkSkipCrosstoken(*(void *)(v20 + 80), *(void *)(v20 + 88), *(void *)(v20 + 96), (_DWORD *)(v20 + 144));
  if ((OptionalHmogrphModels & 0x80000000) != 0) {
    goto LABEL_53;
  }
  if (*(_DWORD *)(v20 + 144))
  {
    uint64_t OptionalHmogrphModels = hlp_loadOptions((void *)v20);
    if ((OptionalHmogrphModels & 0x80000000) != 0) {
      goto LABEL_53;
    }
  }
  if (!*(_DWORD *)(v20 + 188)) {
    goto LABEL_49;
  }
  if (*(_DWORD *)(v20 + 480))
  {
    uint64_t v50 = 0;
    long long v48 = 0u;
    long long v49 = 0u;
    uint64_t OptionalHmogrphModels = hlp_loadStatWordOptions(v20);
    if ((OptionalHmogrphModels & 0x80000000) != 0) {
      goto LABEL_53;
    }
    uint64_t OptionalHmogrphModels = nn_word_lkp_GetInterface(1u, &v51);
    if ((OptionalHmogrphModels & 0x80000000) != 0) {
      goto LABEL_53;
    }
    *(void *)(v20 + 280) = v51;
    *(void *)(v20 + 288) = safeh_GetNullHandle();
    *(void *)(v20 + 296) = v35;
    *(void *)(v20 + 304) = safeh_GetNullHandle();
    *(void *)(v20 + 312) = v36;
    uint64_t OptionalHmogrphModels = (*(uint64_t (**)(void, void, const char *, _WORD *, uint64_t, uint64_t))(v51 + 16))(*(void *)(v20 + 288), *(void *)(v20 + 296), "word", a3, a4, v20 + 304);
    if ((OptionalHmogrphModels & 0x80000000) != 0) {
      goto LABEL_53;
    }
    long long v49 = *(_OWORD *)(v20 + 304);
    *((void *)&v48 + 1) = v51;
    uint64_t OptionalHmogrphModels = objc_RegisterObject(v60[6], (uint64_t)"NNWRDLKP", &v48);
    if ((OptionalHmogrphModels & 0x80000000) != 0) {
      goto LABEL_53;
    }
    goto LABEL_46;
  }
  if (*(_DWORD *)(v20 + 192))
  {
    uint64_t OptionalHmogrphModels = hlp_loadNNOptions(v20);
    if ((OptionalHmogrphModels & 0x80000000) != 0)
    {
LABEL_53:
      uint64_t v5 = OptionalHmogrphModels;
      fe_hmogrph_ObjClose(*(void *)a5, *(void *)(a5 + 8));
      return v5;
    }
    int v37 = strcmp(*(const char **)(v20 + 264), "albert");
    if ((objc_GetObject(v60[6], (uint64_t)"NNCHRLKP", &v55) & 0x80000000) != 0 || !v37)
    {
      uint64_t OptionalHmogrphModels = nn_word_lkp_GetInterface(1u, &v51);
      if ((OptionalHmogrphModels & 0x80000000) != 0) {
        goto LABEL_53;
      }
      *(void *)(v20 + 280) = v51;
      *(void *)(v20 + 288) = safeh_GetNullHandle();
      *(void *)(v20 + 296) = v39;
      *(void *)(v20 + 304) = safeh_GetNullHandle();
      *(void *)(v20 + 312) = v40;
      uint64_t OptionalHmogrphModels = (*(uint64_t (**)(void, void, void, _WORD *, uint64_t, uint64_t))(v51 + 16))(*(void *)(v20 + 288), *(void *)(v20 + 296), *(void *)(v20 + 264), a3, a4, v20 + 304);
      if ((OptionalHmogrphModels & 0x80000000) != 0) {
        goto LABEL_53;
      }
    }
    else
    {
      *(void *)(v20 + 280) = *(void *)(v55 + 8);
      *(void *)(v20 + 288) = safeh_GetNullHandle();
      *(void *)(v20 + 296) = v38;
      *(_OWORD *)(v20 + 304) = *(_OWORD *)(v55 + 16);
    }
LABEL_46:
    uint64_t inited = fi_model_getBrokerString(*(void *)v20, (char *)v61);
    if ((inited & 0x80000000) == 0)
    {
      uint64_t v41 = fi_init(a3, a4, a1, a2, &v52, 0, (uint64_t)v61, (uint64_t)"FINN", 1, 0);
      if ((v41 & 0x80000000) != 0)
      {
        uint64_t v5 = v41;
        log_OutText(*(void *)(*(void *)v20 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"create FI model failed", v42, v43, v44, v47);
        return v5;
      }
      *(void *)(v20 + 240) = v52;
      goto LABEL_49;
    }
    return inited;
  }
  *(void *)(v20 + 240) = 0;
LABEL_49:
  uint64_t v5 = init_ner_struct(v20, (void *)(v26 + 192));
  if ((v5 & 0x80000000) == 0)
  {
    *(void *)a5 = v20;
    *(_DWORD *)(a5 + 8) = 62342;
  }
  return v5;
}

uint64_t hlp_loadOptionalHmogrphModels(uint64_t a1)
{
  if ((com_useStatHmogrph(*(void *)a1, (_DWORD *)(a1 + 188)) & 0x80000000) == 0)
  {
    *(_WORD *)(a1 + 232) = 0;
    *(void *)(a1 + 200) = 0;
    if (*(_DWORD *)(a1 + 188))
    {
      if ((stat_hmogrph_ModelInit(*(_WORD **)(a1 + 8), *(void *)(a1 + 16), *(void *)a1, *(void *)(a1 + 96), *(void *)(a1 + 80), *(void *)(a1 + 88), (uint64_t *)(a1 + 224), (_WORD *)(a1 + 232), (unsigned __int16 *)(a1 + 234)) & 0x80000000) == 0)*(void *)(a1 + 200) = *(void *)a1; {
    }
      }
  }
  *(void *)&__c[3] = 0;
  __c[0] = 0;
  *(_DWORD *)(a1 + 480) = 0;
  *(_WORD *)&__c[1] = -1;
  if (((*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", "statwordhmogrph_step", &__c[3], &__c[1], __c) & 0x80000000) == 0&& *(unsigned __int16 *)&__c[1] == 1)
  {
    *(_DWORD *)(a1 + 188) = 1;
    *(_DWORD *)(a1 + 480) = 1;
  }
  *(_DWORD *)(a1 + 192) = 0;
  *(_WORD *)&__c[1] = -1;
  uint64_t v2 = (*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", "stathmogrph_enable_nnets", &__c[3], &__c[1], __c);
  if ((v2 & 0x80000000) == 0 && *(unsigned __int16 *)&__c[1] == 1 && *(void *)&__c[3])
  {
    uint64_t v3 = **(const char ***)&__c[3];
    uint64_t v4 = strchr(**(char ***)&__c[3], __c[0]);
    if (v4)
    {
      char *v4 = 0;
      uint64_t v3 = **(const char ***)&__c[3];
    }
    if (!strcmp("yes", v3) || !strcmp("YES", v3)) {
      *(_DWORD *)(a1 + 192) = 1;
    }
  }
  return v2;
}

uint64_t hlp_loadNerOptions(uint64_t a1)
{
  size_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v8 = 0;
  __int16 v7 = -1;
  char v6 = 0;
  uint64_t v2 = (*(uint64_t (**)(void, void, const char *, const char *, const char ***, __int16 *, char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", "ner_enable_ner", &v10, &v7, &v6);
  if ((v2 & 0x80000000) == 0)
  {
    if (v7 && v10)
    {
      (*v10)[strlen(*v10) - 1] = 0;
      int v3 = strcmp(*v10, "yes");
      *(_DWORD *)(a1 + 384) = v3 == 0;
      if (!v3)
      {
        __int16 v7 = -1;
        char v6 = 0;
        *(_DWORD *)(a1 + 428) = 0;
        if (((*(uint64_t (**)(void, void, const char *, const char *, const char ***, __int16 *, char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", "ner_embed_type", &v9, &v7, &v6) & 0x80000000) == 0&& v7&& v9)
        {
          (*v9)[strlen(*v9) - 1] = 0;
          *(_DWORD *)(a1 + 428) = strcmp(*v9, "char") == 0;
        }
        __int16 v7 = -1;
        char v6 = 0;
        uint64_t v2 = (*(uint64_t (**)(void, void, const char *, const char *, const char ***, __int16 *, char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", "ner_enable_pos", &v9, &v7, &v6);
        if ((v2 & 0x80000000) == 0)
        {
          if (v7 && v9)
          {
            (*v9)[strlen(*v9) - 1] = 0;
            int v4 = strcmp(*v9, "yes");
            *(_DWORD *)(a1 + 424) = v4 == 0;
            if (!v4)
            {
              __int16 v7 = -1;
              char v6 = 0;
              uint64_t v2 = (*(uint64_t (**)(void, void, const char *, const char *, const char ***, __int16 *, char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", "ner_pos_dimension", &v8, &v7, &v6);
              if ((v2 & 0x80000000) == 0) {
                *(_WORD *)(a1 + 432) = (unsigned __int16)LH_atou(*v8);
              }
            }
          }
          else
          {
            *(_DWORD *)(a1 + 424) = 0;
          }
        }
      }
    }
    else
    {
      *(_DWORD *)(a1 + 384) = 0;
    }
  }
  return v2;
}

uint64_t checkSkipCrosstoken(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  *(void *)&__c[3] = 0;
  *(_WORD *)&__c[1] = -1;
  __c[0] = 0;
  *a4 = 0;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(a3 + 96))(a1, a2, "fecfg", "feoneword_skipcrosstoken", &__c[3], &__c[1], __c);
  if ((v5 & 0x80000000) == 0 && *(unsigned __int16 *)&__c[1] == 1 && *(void *)&__c[3] != 0)
  {
    __int16 v7 = **(const char ***)&__c[3];
    uint64_t v8 = strchr(**(char ***)&__c[3], __c[0]);
    if (v8)
    {
      *uint64_t v8 = 0;
      __int16 v7 = **(const char ***)&__c[3];
    }
    if (!strcmp("yes", v7) || !strcmp("YES", v7)) {
      *a4 = 1;
    }
  }
  return v5;
}

uint64_t fi_model_getBrokerString(uint64_t a1, char *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v5 = 0;
  *(void *)char v6 = 0;
  memset(v7, 0, sizeof(v7));
  uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"langcode", v6);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"fecfg", &v5);
    if ((result & 0x80000000) == 0)
    {
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      return brokeraux_ComposeBrokerString(a1, (const char *)v7, 1, 1, *(char **)v6, 0, 0, a2, 0x100uLL);
    }
  }
  return result;
}

uint64_t init_ner_struct(uint64_t a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  memset(v15, 0, sizeof(v15));
  uint64_t v14 = 0;
  *a2 = 0;
  if (!*(_DWORD *)(a1 + 384)) {
    return 0;
  }
  *(void *)(a1 + 440) = 0;
  *(void *)(a1 + 448) = safeh_GetNullHandle();
  *(void *)(a1 + 456) = v4;
  *(void *)(a1 + 464) = safeh_GetNullHandle();
  *(void *)(a1 + 472) = v5;
  char v6 = *(const char **)(a1 + 264);
  if (v6)
  {
    if (strcmp(v6, "char"))
    {
      if (*(_DWORD *)(a1 + 428) == 1)
      {
        uint64_t Interface = nn_word_lkp_GetInterface(1u, (void *)(a1 + 440));
        if ((Interface & 0x80000000) != 0) {
          return Interface;
        }
        uint64_t Interface = (*(uint64_t (**)(void, void, const char *, void, void, uint64_t))(*(void *)(a1 + 440) + 16))(*(void *)(a1 + 448), *(void *)(a1 + 456), "char", *(void *)(a1 + 8), *(void *)(a1 + 16), a1 + 464);
        if ((Interface & 0x80000000) != 0) {
          return Interface;
        }
      }
    }
  }
  get_ner_brokerstring(*(void *)a1, (char *)v15, 0x100uLL);
  uint64_t v11 = fi_init(*(_WORD **)(a1 + 8), *(void *)(a1 + 16), *(_WORD **)(a1 + 32), *(void *)(a1 + 40), &v14, 0, (uint64_t)v15, (uint64_t)"FINN", 1, 0);
  if ((v11 & 0x80000000) != 0) {
    log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Init NER FI model failed", v8, v9, v10, v13);
  }
  else {
    *a2 = v14;
  }
  return v11;
}

uint64_t fe_hmogrph_ObjClose(uint64_t a1, int a2)
{
  uint64_t result = safeh_HandleCheck(a1, a2, 62342, 488);
  if ((result & 0x80000000) != 0) {
    return 2314215432;
  }
  if (!a1) {
    return result;
  }
  uint64_t v9 = *(void *)(a1 + 104);
  if (v9) {
    heap_Free(*(void **)(*(void *)a1 + 8), v9);
  }
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 120) = 0;
  uint64_t v10 = *(void *)(a1 + 112);
  if (v10) {
    heap_Free(*(void **)(*(void *)a1 + 8), v10);
  }
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 128) = 0;
  uint64_t v11 = *(void *)(a1 + 152);
  if (v11) {
    heap_Free(*(void **)(*(void *)a1 + 8), v11);
  }
  *(void *)(a1 + 152) = 0;
  uint64_t v12 = *(void *)(a1 + 160);
  if (v12) {
    heap_Free(*(void **)(*(void *)a1 + 8), v12);
  }
  *(void *)(a1 + 160) = 0;
  uint64_t v13 = *(void *)(a1 + 168);
  if (v13) {
    heap_Free(*(void **)(*(void *)a1 + 8), v13);
  }
  *(void *)(a1 + 168) = 0;
  uint64_t v14 = *(void *)(a1 + 176);
  if (v14) {
    heap_Free(*(void **)(*(void *)a1 + 8), v14);
  }
  *(void *)(a1 + 176) = 0;
  uint64_t v15 = *(void *)(a1 + 280);
  if (v15)
  {
    if (*(_DWORD *)(a1 + 480))
    {
      if (((*(uint64_t (**)(void, void))(v15 + 24))(*(void *)(a1 + 304), *(void *)(a1 + 312)) & 0x80000000) == 0) {
        objc_UnregisterObject(*(void *)(*(void *)a1 + 48), (uint64_t)"NNWRDLKP");
      }
    }
    else if (*(_DWORD *)(a1 + 192) {
           && (objc_ReleaseObject(*(void *)(*(void *)a1 + 48), (uint64_t)"NNCHRLKP") & 0x80000000) != 0)
    }
    {
      (*(void (**)(void, void))(*(void *)(a1 + 280) + 24))(*(void *)(a1 + 304), *(void *)(a1 + 312));
    }
    *(void *)(a1 + 280) = 0;
  }
  if (*(_DWORD *)(a1 + 188))
  {
    if (*(_DWORD *)(a1 + 480))
    {
      uint64_t v16 = *(void *)(a1 + 336);
      if (v16)
      {
        heap_Free(*(void **)(*(void *)a1 + 8), v16);
        *(void *)(a1 + 336) = 0;
      }
    }
    else
    {
      if (!*(_DWORD *)(a1 + 192))
      {
LABEL_37:
        if (*(_WORD *)(a1 + 232)) {
          stat_hmogrph_ModelDeinit(*(void *)a1, (uint64_t *)(a1 + 224), *(unsigned __int16 *)(a1 + 232), v4, v5, v6, v7, v8);
        }
        goto LABEL_39;
      }
      uint64_t v17 = *(void *)(a1 + 272);
      if (v17)
      {
        heap_Free(*(void **)(*(void *)a1 + 8), v17);
        *(void *)(a1 + 272) = 0;
      }
      uint64_t v18 = *(void *)(a1 + 248);
      if (v18)
      {
        ssftmap_ObjClose(v18);
        *(void *)(a1 + 248) = 0;
      }
      uint64_t v19 = *(void *)(a1 + 264);
      if (v19)
      {
        heap_Free(*(void **)(*(void *)a1 + 8), v19);
        *(void *)(a1 + 264) = 0;
      }
    }
    uint64_t v20 = *(uint64_t **)(a1 + 240);
    if (v20)
    {
      fi_deinit(*(void *)a1, *(void *)(a1 + 24), v20);
      *(void *)(a1 + 240) = 0;
    }
    goto LABEL_37;
  }
LABEL_39:
  if (*(_DWORD *)(a1 + 384))
  {
    uint64_t v21 = *(uint64_t **)(a1 + 392);
    if (v21)
    {
      fi_deinit(*(void *)a1, *(void *)(a1 + 24), v21);
      *(void *)(a1 + 392) = 0;
    }
    uint64_t v22 = *(void *)(a1 + 440);
    if (v22)
    {
      (*(void (**)(void, void))(v22 + 24))(*(void *)(a1 + 464), *(void *)(a1 + 472));
      *(void *)(a1 + 440) = 0;
    }
  }
  objc_ReleaseObject(*(void *)(*(void *)a1 + 48), (uint64_t)"LINGDB");
  objc_ReleaseObject(*(void *)(*(void *)a1 + 48), (uint64_t)"FE_DEPES");
  objc_ReleaseObject(*(void *)(*(void *)a1 + 48), (uint64_t)"FE_DCTLKP");
  heap_Free(*(void **)(*(void *)a1 + 8), a1);
  return 0;
}

uint64_t fe_hmogrph_ObjReopen(uint64_t a1, int a2)
{
  uint64_t v49 = *MEMORY[0x263EF8340];
  uint64_t v46 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  memset(v48, 0, sizeof(v48));
  uint64_t Options = safeh_HandleCheck(a1, a2, 62342, 488);
  if ((Options & 0x80000000) == 0)
  {
    if (!a1) {
      return Options;
    }
    long long __s = 0;
    uint64_t v45 = 0;
    uint64_t Options = (*(uint64_t (**)(void, void, char *, uint64_t *))(*(void *)(a1 + 96) + 88))(*(void *)(a1 + 80), *(void *)(a1 + 88), (char *)&v46 + 4, &v46);
    if ((Options & 0x80000000) != 0) {
      return Options;
    }
    BOOL v10 = v46 == 1 && HIDWORD(v46) == 1;
    *(_DWORD *)(a1 + 184) = v10;
    uint64_t v11 = *(void *)(a1 + 104);
    if (v11) {
      heap_Free(*(void **)(*(void *)a1 + 8), v11);
    }
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 120) = 0;
    uint64_t v12 = *(void *)(a1 + 112);
    if (v12) {
      heap_Free(*(void **)(*(void *)a1 + 8), v12);
    }
    *(void *)(a1 + 112) = 0;
    *(void *)(a1 + 128) = 0;
    uint64_t v13 = *(void *)(a1 + 152);
    if (v13) {
      heap_Free(*(void **)(*(void *)a1 + 8), v13);
    }
    *(void *)(a1 + 152) = 0;
    uint64_t v14 = *(void *)(a1 + 160);
    if (v14) {
      heap_Free(*(void **)(*(void *)a1 + 8), v14);
    }
    *(void *)(a1 + 160) = 0;
    uint64_t v15 = *(void *)(a1 + 168);
    if (v15) {
      heap_Free(*(void **)(*(void *)a1 + 8), v15);
    }
    *(void *)(a1 + 168) = 0;
    uint64_t v16 = *(void *)(a1 + 176);
    if (v16) {
      heap_Free(*(void **)(*(void *)a1 + 8), v16);
    }
    *(void *)(a1 + 176) = 0;
    uint64_t v17 = *(void *)(a1 + 280);
    if (v17)
    {
      if (*(_DWORD *)(a1 + 480))
      {
        uint64_t v45 = *(void *)(a1 + 280);
        if (((*(uint64_t (**)(void, void))(v17 + 24))(*(void *)(a1 + 304), *(void *)(a1 + 312)) & 0x80000000) == 0) {
          objc_UnregisterObject(*(void *)(*(void *)a1 + 48), (uint64_t)"NNWRDLKP");
        }
      }
      else if (*(_DWORD *)(a1 + 192) {
             && (objc_ReleaseObject(*(void *)(*(void *)a1 + 48), (uint64_t)"NNCHRLKP") & 0x80000000) != 0)
      }
      {
        uint64_t v45 = *(void *)(a1 + 280);
        (*(void (**)(void, void))(v45 + 24))(*(void *)(a1 + 304), *(void *)(a1 + 312));
      }
      *(void *)(a1 + 280) = 0;
    }
    if (!*(_DWORD *)(a1 + 188))
    {
LABEL_51:
      uint64_t Options = checkSkipCrosstoken(*(void *)(a1 + 80), *(void *)(a1 + 88), *(void *)(a1 + 96), (_DWORD *)(a1 + 144));
      if ((Options & 0x80000000) != 0) {
        return Options;
      }
      if (*(_DWORD *)(a1 + 144))
      {
        uint64_t Options = hlp_loadOptions((void *)a1);
        if ((Options & 0x80000000) != 0) {
          return Options;
        }
      }
      uint64_t Options = hlp_loadOptionalHmogrphModels(a1);
      if ((Options & 0x80000000) != 0) {
        return Options;
      }
      uint64_t Options = hlp_loadNerOptions(a1);
      if ((Options & 0x80000000) != 0) {
        return Options;
      }
      *(void *)(a1 + 200) = *(void *)a1;
      if (*(_DWORD *)(a1 + 188))
      {
        if (*(_DWORD *)(a1 + 480))
        {
          uint64_t v42 = 0;
          long long v40 = 0u;
          long long v41 = 0u;
          uint64_t Options = hlp_loadStatWordOptions(a1);
          if ((Options & 0x80000000) != 0) {
            return Options;
          }
          uint64_t Options = nn_word_lkp_GetInterface(1u, &v45);
          if ((Options & 0x80000000) != 0) {
            return Options;
          }
          *(void *)(a1 + 280) = v45;
          *(void *)(a1 + 288) = safeh_GetNullHandle();
          *(void *)(a1 + 296) = v26;
          *(void *)(a1 + 304) = safeh_GetNullHandle();
          *(void *)(a1 + 312) = v27;
          uint64_t Options = (*(uint64_t (**)(void, void, const char *, void, void, uint64_t))(v45 + 16))(*(void *)(a1 + 288), *(void *)(a1 + 296), "word", *(void *)(a1 + 8), *(void *)(a1 + 16), a1 + 304);
          if ((Options & 0x80000000) != 0) {
            return Options;
          }
          long long v41 = *(_OWORD *)(a1 + 304);
          *((void *)&v40 + 1) = v45;
          uint64_t Options = objc_RegisterObject(*(void *)(*(void *)a1 + 48), (uint64_t)"NNWRDLKP", &v40);
          if ((Options & 0x80000000) != 0) {
            return Options;
          }
          goto LABEL_67;
        }
        if (*(_DWORD *)(a1 + 192))
        {
          uint64_t Options = hlp_loadNNOptions(a1);
          if ((Options & 0x80000000) != 0) {
            return Options;
          }
          if ((objc_GetObject(*(void *)(*(void *)a1 + 48), (uint64_t)"NNCHRLKP", &v44) & 0x80000000) != 0)
          {
            uint64_t Options = nn_word_lkp_GetInterface(1u, &v45);
            if ((Options & 0x80000000) != 0) {
              return Options;
            }
            *(void *)(a1 + 280) = v45;
            *(void *)(a1 + 288) = safeh_GetNullHandle();
            *(void *)(a1 + 296) = v37;
            *(void *)(a1 + 304) = safeh_GetNullHandle();
            *(void *)(a1 + 312) = v38;
            uint64_t Options = (*(uint64_t (**)(void, void, void, void, void, uint64_t))(v45 + 16))(*(void *)(a1 + 288), *(void *)(a1 + 296), *(void *)(a1 + 264), *(void *)(a1 + 8), *(void *)(a1 + 16), a1 + 304);
            if ((Options & 0x80000000) != 0) {
              return Options;
            }
          }
          else
          {
            *(void *)(a1 + 280) = *(void *)(v44 + 8);
            *(void *)(a1 + 288) = safeh_GetNullHandle();
            *(void *)(a1 + 296) = v28;
            *(_OWORD *)(a1 + 304) = *(_OWORD *)(v44 + 16);
          }
LABEL_67:
          uint64_t Options = fi_model_getBrokerString(*(void *)a1, (char *)v48);
          if ((Options & 0x80000000) == 0)
          {
            uint64_t v29 = fi_init(*(_WORD **)(a1 + 8), *(void *)(a1 + 16), *(_WORD **)(a1 + 32), *(void *)(a1 + 40), &v43, 0, (uint64_t)v48, (uint64_t)"FINN", 1, 0);
            if ((v29 & 0x80000000) != 0)
            {
              uint64_t v18 = v29;
              log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"create FI model failed", v30, v31, v32, v39);
              return v18;
            }
            *(void *)(a1 + 240) = v43;
            goto LABEL_71;
          }
          return Options;
        }
        *(void *)(a1 + 240) = 0;
      }
LABEL_71:
      int v33 = paramc_ParamGet(*(void *)(*(void *)a1 + 40), (uint64_t)"numberoutputtranscriptions", &__s, 0);
      __int16 v34 = 0;
      if ((v33 & 0x80000000) == 0 && __s) {
        __int16 v34 = atoi(__s);
      }
      *(_WORD *)(a1 + 138) = v34;
      BOOL v35 = (paramc_ParamGet(*(void *)(*(void *)a1 + 40), (uint64_t)"mlset", &__s, 0) & 0x80000000) == 0
         && strlen(__s) > 3;
      *(_DWORD *)(a1 + 140) = v35;
      return init_ner_struct(a1, (void *)(a1 + 392));
    }
    if (*(_DWORD *)(a1 + 480))
    {
      uint64_t v19 = *(void *)(a1 + 336);
      if (v19)
      {
        heap_Free(*(void **)(*(void *)a1 + 8), v19);
        *(void *)(a1 + 336) = 0;
      }
    }
    else
    {
      if (!*(_DWORD *)(a1 + 192))
      {
LABEL_44:
        if (*(_DWORD *)(a1 + 384))
        {
          uint64_t v24 = *(uint64_t **)(a1 + 392);
          if (v24)
          {
            fi_deinit(*(void *)a1, *(void *)(a1 + 24), v24);
            *(void *)(a1 + 392) = 0;
          }
          uint64_t v25 = *(void *)(a1 + 440);
          if (v25)
          {
            uint64_t v45 = *(void *)(a1 + 440);
            (*(void (**)(void, void))(v25 + 24))(*(void *)(a1 + 464), *(void *)(a1 + 472));
            *(void *)(a1 + 440) = 0;
          }
        }
        if (*(_WORD *)(a1 + 232)) {
          stat_hmogrph_ModelDeinit(*(void *)a1, (uint64_t *)(a1 + 224), *(unsigned __int16 *)(a1 + 232), v4, v5, v6, v7, v8);
        }
        goto LABEL_51;
      }
      uint64_t v20 = *(void *)(a1 + 272);
      if (v20)
      {
        heap_Free(*(void **)(*(void *)a1 + 8), v20);
        *(void *)(a1 + 272) = 0;
      }
      uint64_t v21 = *(void *)(a1 + 248);
      if (v21)
      {
        ssftmap_ObjClose(v21);
        *(void *)(a1 + 248) = 0;
      }
      uint64_t v22 = *(void *)(a1 + 264);
      if (v22)
      {
        heap_Free(*(void **)(*(void *)a1 + 8), v22);
        *(void *)(a1 + 264) = 0;
      }
    }
    uint64_t v23 = *(uint64_t **)(a1 + 240);
    if (v23)
    {
      fi_deinit(*(void *)a1, *(void *)(a1 + 24), v23);
      *(void *)(a1 + 240) = 0;
    }
    goto LABEL_44;
  }
  return 2314215432;
}

uint64_t fe_hmogrph_ProcessStart(uint64_t a1, int a2)
{
  LODWORD(result) = safeh_HandleCheck(a1, a2, 62342, 488);
  if ((int)result >= 0) {
    return result;
  }
  else {
    return 2314215432;
  }
}

uint64_t fe_hmogrph_Process_StatHmogrph(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *a4 = 1;
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"BEGIN fe_hmogrph_Process_StatHmogrph()", a6, a7, a8, 0);
  if (*(_DWORD *)(a1 + 480) == 1)
  {
    uint64_t SentenceData = stat_hmogrph_disambiguateWords(a1, *(void *)(a1 + 48), a2, a3, a1 + 200);
LABEL_13:
    uint64_t v18 = SentenceData;
    int v19 = 0;
    goto LABEL_14;
  }
  if (!*(_DWORD *)(a1 + 384))
  {
    *(void *)(a1 + 400) = 0;
    goto LABEL_10;
  }
  uint64_t v15 = *(const char **)(a1 + 264);
  BOOL v16 = v15 && !strcmp(v15, "char");
  uint64_t v17 = ner_process(*(void *)a1, a1 + 392, a2, a3, *(void *)(a1 + 48), *(void *)(a1 + 280), *(void *)(a1 + 304), *(void *)(a1 + 312), v16);
  if ((v17 & 0x80000000) == 0)
  {
LABEL_10:
    uint64_t SentenceData = stat_hmogrph_getSentenceData(a1, *(void *)(a1 + 48), a2, a3, (uint64_t *)(a1 + 200));
    if ((SentenceData & 0x80000000) == 0)
    {
      uint64_t SentenceData = stat_hmogrph_disambiguatePhons(a1, a1 + 200);
      if ((SentenceData & 0x80000000) == 0) {
        uint64_t SentenceData = stat_hmogrph_updateLingdb(a1, *(void *)(a1 + 48), a2, a3, a1 + 200, a1 + 392);
      }
    }
    goto LABEL_13;
  }
  uint64_t v18 = v17;
  int v19 = 1;
LABEL_14:
  if (!(*(_DWORD *)(a1 + 480) | v19))
  {
    int v20 = stat_hmogrph_freeSentenceData((unsigned __int16 *)(a1 + 200));
    if ((int)v18 > -1 && v20 < 0) {
      uint64_t v18 = v20;
    }
    else {
      uint64_t v18 = v18;
    }
  }
  if (*(_DWORD *)(a1 + 384))
  {
    int v22 = ner_freeNEData(*(void *)a1, a1 + 392);
    if ((int)v18 > -1 && v22 < 0) {
      uint64_t v18 = v22;
    }
    else {
      uint64_t v18 = v18;
    }
  }
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"END fe_hmogrph_Process_StatHmogrph()", v12, v13, v14, 0);
  return v18;
}

uint64_t checkCRFMDE(_WORD *a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  *a4 = 0;
  long long __s = 0;
  __int16 v34 = 0;
  BOOL v35 = &byte_20D5A22AE;
  memset(v37, 0, sizeof(v37));
  if ((paramc_ParamGetStr(*(void *)(a3 + 40), (uint64_t)"langcode", &__s) & 0x80000000) == 0
    && (paramc_ParamGetStr(*(void *)(a3 + 40), (uint64_t)"fecfg", &v35) & 0x80000000) == 0)
  {
    __strcat_chk();
    __strcat_chk();
    __strcat_chk();
    __strcat_chk();
    uint64_t v8 = (char *)heap_Calloc(*(void **)(a3 + 8), 1, 1024);
    if (v8)
    {
      uint64_t v13 = v8;
      int v14 = brokeraux_ComposeBrokerString(a3, (const char *)v37, 1, 1, __s, 0, 0, v8, 0x400uLL);
      size_t v15 = strlen(__s);
      BOOL v16 = (char *)heap_Calloc(*(void **)(a3 + 8), 1, v15 + 1);
      if (v16)
      {
        uint64_t v21 = v16;
        strcpy(v16, __s);
        if ((v14 & 0x80000000) == 0
          && (ssftriff_reader_ObjOpen(a1, a2, 2, v13, "CRPH", 1031, (uint64_t *)&v34) & 0x80000000) == 0)
        {
          ssftriff_reader_ObjClose(v34, v22, v23, v24, v25, v26, v27, v28);
          *a4 = 1;
        }
        heap_Free(*(void **)(a3 + 8), (uint64_t)v13);
        uint64_t v29 = *(void **)(a3 + 8);
        uint64_t v30 = (uint64_t)v21;
      }
      else
      {
        log_OutPublic(*(void *)(a3 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v17, v18, v19, v20, v33);
        uint64_t v29 = *(void **)(a3 + 8);
        uint64_t v30 = (uint64_t)v13;
      }
      heap_Free(v29, v30);
    }
    else
    {
      log_OutPublic(*(void *)(a3 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v9, v10, v11, v12, v32);
    }
  }
  return 0;
}

uint64_t fe_hmogrph_Process(uint64_t a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v96 = *MEMORY[0x263EF8340];
  __int16 v88 = 0;
  unsigned __int16 v86 = 0;
  int v84 = 0;
  BOOL v85 = 0;
  if ((safeh_HandleCheck(a1, a2, 62342, 488) & 0x80000000) != 0) {
    return 2314215432;
  }
  long long __s = 0;
  int v92 = 0;
  int v93 = 0;
  unsigned __int16 v91 = 0;
  int v90 = 0;
  unsigned __int16 v89 = 0;
  uint64_t v87 = 0;
  *a5 = 1;
  checkCRFMDE(*(_WORD **)(a1 + 8), *(void *)(a1 + 16), *(void *)a1, &v84);
  uint64_t v9 = *(void *)(a1 + 88);
  uint64_t v10 = *(void *)(a1 + 96);
  uint64_t v11 = *(void *)(a1 + 80);
  *(void *)__s2 = 0;
  LOWORD(v83) = -1;
  LOBYTE(__c[0]) = 0;
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, const char *, char *, uint64_t *, int *))(v10 + 96))(v11, v9, "fecfg", "usecompound", __s2, &v83, __c);
  if ((v12 & 0x80000000) != 0) {
    return v12;
  }
  int v13 = 0;
  int v14 = 1;
  if ((unsigned __int16)v83 == 1 && *(void *)__s2)
  {
    size_t v15 = **(const char ***)__s2;
    BOOL v16 = strchr(**(char ***)__s2, LOBYTE(__c[0]));
    if (v16)
    {
      *BOOL v16 = 0;
      size_t v15 = **(const char ***)__s2;
    }
    if (!strcmp("yes", v15) || !strcmp("YES", v15))
    {
      int v14 = 0;
      int v13 = 1;
    }
    else
    {
      int v13 = 0;
    }
  }
  uint64_t v17 = com_mosynt_UseMosynt(*(void *)(a1 + 80), *(void *)(a1 + 88), *(void *)(a1 + 96), &v85);
  if ((v17 & 0x80000000) != 0) {
    return v17;
  }
  int v21 = v85 ? v14 : 0;
  if (v21 == 1 && !*(_DWORD *)(a1 + 188)) {
    return v17;
  }
  int v22 = *(_DWORD *)(a1 + 188);
  if ((v85 & ~v13) != 0)
  {
    if (!v22) {
      goto LABEL_23;
    }
  }
  else if (!v22)
  {
    goto LABEL_24;
  }
  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Stathmogrph Enabled", v18, v19, v20, 0);
  uint64_t v17 = fe_hmogrph_Process_StatHmogrph(a1, a3, a4, a5, v23, v24, v25, v26);
  if ((v17 & 0x80000000) != 0)
  {
    log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Stathmogrph Processing Failed", v27, v28, v29, 0);
    return v17;
  }
LABEL_23:
  if (!*(_DWORD *)(a1 + 480)) {
    return v17;
  }
LABEL_24:
  uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *))(*(void *)(a1 + 48) + 104))(a3, a4, 1, 0, (char *)&v93 + 2);
  if ((v17 & 0x80000000) != 0) {
    return v17;
  }
  if (((*(uint64_t (**)(uint64_t, uint64_t, void, void, __int16 *))(*(void *)(a1 + 48) + 184))(a3, a4, HIWORD(v93), 0, &v88) & 0x80000000) != 0)return v17; {
  if (v88 != 1)
  }
    return v17;
  uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, char **, char *))(*(void *)(a1 + 48) + 176))(a3, a4, HIWORD(v93), 0, &__s, (char *)&v92 + 2);
  if ((v17 & 0x80000000) != 0) {
    return v17;
  }
  __int16 v30 = HIWORD(v92);
  if (HIWORD(v92) < 2u) {
    return v17;
  }
  *(_WORD *)(a1 + 136) = 0;
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t *, unsigned __int16 *))(*(void *)(a1 + 48) + 176))(a3, a4, HIWORD(v93), 1, &v87, &v86);
  if ((v12 & 0x80000000) != 0) {
    return v12;
  }
  int v31 = *(_DWORD *)(v87 + 12);
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, int *))(*(void *)(a1 + 48) + 104))(a3, a4, 2, HIWORD(v93), &v93);
  if ((v12 & 0x80000000) != 0) {
    return v12;
  }
  __int16 v79 = v31;
  int v80 = 0;
  unsigned __int16 v32 = 0;
  unsigned __int16 v33 = v30 - 1;
  int v34 = 1;
  while (1)
  {
    uint64_t v35 = *(void *)(a1 + 48);
    if (!(_WORD)v93) {
      break;
    }
    uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(v35 + 168))(a3, a4);
    if ((v12 & 0x80000000) != 0) {
      return v12;
    }
    if (v90 == 4)
    {
      uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, char *))(*(void *)(a1 + 48)
                                                                                                 + 168))(a3, a4, (unsigned __int16)v93, 1, 1, &v92, (char *)&v92 + 2);
      if ((v12 & 0x80000000) != 0) {
        return v12;
      }
      int v36 = (unsigned __int16)v92;
      if (!v34 && (unsigned __int16)v92 == v80)
      {
        uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned __int16 *, char *))(*(void *)(a1 + 48) + 168))(a3, a4, (unsigned __int16)v93, 2, 1, &v91, (char *)&v92 + 2);
        if ((v12 & 0x80000000) != 0) {
          return v12;
        }
        unsigned int v37 = (unsigned __int16)v92;
        uint64_t v38 = __s;
        if (!(_WORD)v92) {
          goto LABEL_52;
        }
        unsigned __int8 v39 = 0;
        do
        {
          unsigned __int16 PreviousUtf8Offset = utf8_GetPreviousUtf8Offset((uint64_t)v38, v37);
          uint64_t v38 = __s;
          unsigned int v37 = PreviousUtf8Offset;
          int v41 = __s[PreviousUtf8Offset];
          if (v41 == 95 || v41 == 32)
          {
            int v42 = __s[PreviousUtf8Offset + 1];
            if (v42 != 32 && v42 != 95) {
              ++v39;
            }
          }
        }
        while (v39 <= 3u && PreviousUtf8Offset);
        if (PreviousUtf8Offset)
        {
          unsigned __int16 NextUtf8Offset = utf8_GetNextUtf8Offset(__s, PreviousUtf8Offset);
          uint64_t v38 = __s;
        }
        else
        {
LABEL_52:
          unsigned __int16 NextUtf8Offset = 0;
        }
        unsigned __int16 v45 = v91;
        if (v91 >= v33)
        {
          unsigned __int16 v50 = v91;
        }
        else
        {
          unsigned __int8 v46 = 0;
          do
          {
            unsigned __int16 v45 = utf8_GetNextUtf8Offset(v38, v45);
            uint64_t v38 = __s;
            int v47 = __s[v45];
            if (v47 == 95 || v47 == 32)
            {
              int v48 = __s[v45 - 1];
              if (v48 != 32 && v48 != 95) {
                ++v46;
              }
            }
          }
          while (v46 <= 2u && v33 > v45);
          unsigned __int16 v50 = v45;
          unsigned __int16 v45 = v91;
        }
        int v51 = (unsigned __int16)v92;
        if (v32)
        {
          uint64_t v12 = hlp_Disambiguate(a1, a3, a4, v38, v32, NextUtf8Offset, v50, (unsigned __int16)v92, v45);
          if ((v12 & 0x80000000) != 0) {
            return v12;
          }
          uint64_t v38 = __s;
          int v51 = (unsigned __int16)v92;
          unsigned __int16 v45 = v91;
        }
        uint64_t v12 = hlp_Disambiguate(a1, a3, a4, v38, (unsigned __int16)v93, NextUtf8Offset, v50, v51, v45);
        if ((v12 & 0x80000000) != 0) {
          return v12;
        }
        unsigned __int16 v32 = 0;
        int v36 = (unsigned __int16)v92;
      }
      if (v36 != v80 || v34 == 1) {
        unsigned __int16 v32 = v93;
      }
      int v80 = v36;
      int v34 = 0;
    }
    uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 + 48) + 120))(a3, a4);
    if ((v17 & 0x80000000) != 0) {
      return v17;
    }
  }
  uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, int *))(v35 + 104))(a3, a4, 2, HIWORD(v93), &v93);
  if ((v17 & 0x80000000) == 0)
  {
    unsigned __int16 v53 = v93;
    if ((_WORD)v93)
    {
      int v54 = 0;
      unsigned int v55 = 0;
      uint64_t v76 = 0;
      unsigned __int16 v56 = 0;
      int v77 = 1;
      int v78 = 0;
      int v81 = v84;
      unsigned __int8 v74 = 1;
      BOOL v75 = 0;
      int v57 = 1;
      while (1)
      {
        uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, int *, char *))(*(void *)(a1 + 48)
                                                                                                  + 168))(a3, a4, v53, 0, 1, &v90, (char *)&v92 + 2);
        if ((v12 & 0x80000000) != 0) {
          return v12;
        }
        uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, char *))(*(void *)(a1 + 48) + 168))(a3, a4, (unsigned __int16)v93, 1, 1, &v92, (char *)&v92 + 2);
        if ((v12 & 0x80000000) != 0) {
          return v12;
        }
        if ((unsigned __int16)v92 != v56 || v57 == 1) {
          int v54 = 0;
        }
        if (v55 < v86)
        {
          uint64_t v59 = v55;
          uint64_t v60 = v87 + 32 * v55 + 12;
          while ((__int16)(v92 + 1) > (__int16)(*(_WORD *)v60 - v79))
          {
            if (*(_DWORD *)(v60 - 12) == 14 && *(_DWORD *)(v60 + 12) == 64) {
              int v54 = 1;
            }
            ++v59;
            v60 += 32;
            if (v86 == v59)
            {
              unsigned int v55 = v86;
              goto LABEL_101;
            }
          }
          unsigned int v55 = (unsigned __int16)v59;
        }
LABEL_101:
        if (v90 == 4) {
          goto LABEL_112;
        }
        BOOL v61 = v90 == 9;
        if (v90 == 9) {
          char v62 = v13;
        }
        else {
          char v62 = 0;
        }
        if (!v85) {
          char v62 = 0;
        }
        if (v81 != 1) {
          BOOL v61 = 0;
        }
        if ((v62 & 1) != 0 || v61)
        {
LABEL_112:
          uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned __int16 *, char *))(*(void *)(a1 + 48) + 168))(a3, a4, (unsigned __int16)v93, 7, 1, &v89, (char *)&v92 + 2);
          if ((v12 & 0x80000000) != 0) {
            return v12;
          }
          if (v85) {
            char v65 = v13;
          }
          else {
            char v65 = 0;
          }
          if ((v65 & 1) != 0 || v81 == 1)
          {
            *(_WORD *)__s2 = 0;
            __int16 v88 = 0;
            if (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, __int16 *))(*(void *)(a1 + 48) + 184))(a3, a4, (unsigned __int16)v93, 17, &v88) & 0x80000000) == 0&& v88 == 1)
            {
              uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, char *))(*(void *)(a1 + 48) + 168))(a3, a4, (unsigned __int16)v93, 17, 1, __s2, (char *)&v92 + 2);
              if ((v12 & 0x80000000) != 0) {
                return v12;
              }
            }
            if (*(_WORD *)__s2) {
              unsigned __int16 v66 = 0;
            }
            else {
              unsigned __int16 v66 = ~v89;
            }
            unsigned __int16 v89 = v66;
          }
          if (*(_DWORD *)(a1 + 480))
          {
            *(void *)unsigned __int8 __c = 0;
            uint64_t v83 = 0;
            uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t *, char *))(*(void *)(a1 + 48)
                                                                                                  + 176))(a3, a4, (unsigned __int16)v93, 5, &v83, (char *)&v92 + 2);
            if ((v12 & 0x80000000) != 0) {
              return v12;
            }
            uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, int *, char *))(*(void *)(a1 + 48)
                                                                                              + 176))(a3, a4, (unsigned __int16)v93, 14, __c, (char *)&v92 + 2);
            if ((v12 & 0x80000000) != 0) {
              return v12;
            }
            strcpy(__s2, "POS:");
            __strcat_chk();
            __strcat_chk();
            unsigned int v67 = *(char **)__c;
            uint64_t v68 = strstr(*(char **)__c, __s2);
            if (v68 && (v68 == v67 || *(v68 - 1) == 59)) {
              v89 += 100;
            }
          }
          __int16 v88 = 0;
          if (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, __int16 *))(*(void *)(a1 + 48) + 184))(a3, a4, (unsigned __int16)v93, 9, &v88) & 0x80000000) == 0&& v88 == 1)
          {
            *(void *)__s2 = 0;
            uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char *, char *))(*(void *)(a1 + 48)
                                                                                               + 176))(a3, a4, (unsigned __int16)v93, 9, __s2, (char *)&v92 + 2);
            if ((v12 & 0x80000000) != 0) {
              return v12;
            }
            int v78 = **(unsigned char **)__s2;
          }
          if (v57 || (unsigned __int16)v92 != v56)
          {
            unsigned __int16 v63 = 0;
            int v57 = 0;
            uint64_t v64 = (unsigned __int16)v93;
            unsigned __int8 v70 = v77;
            int v69 = v78;
            if (!(_BYTE)v78) {
              int v69 = v77;
            }
            BOOL v75 = v78 == v77;
            LOWORD(v76) = v93;
            unsigned __int16 v56 = v92;
            HIDWORD(v76) = v89;
            int v77 = v69;
            unsigned __int8 v74 = v70;
            goto LABEL_152;
          }
          if (v89 > HIDWORD(v76)
            || v89 == HIDWORD(v76) && !v75 && (v74 == 101 || v78 != 101))
          {
            uint64_t v64 = (unsigned __int16)v93;
            if (!v54) {
              goto LABEL_149;
            }
          }
          else
          {
            uint64_t v64 = (unsigned __int16)v93;
            if (v54)
            {
LABEL_149:
              int v57 = 0;
              int v71 = v78;
              if ((v78 & 0xFE) == 0) {
                int v71 = 1;
              }
              HIDWORD(v76) = v89;
              int v77 = v71;
              unsigned __int16 v63 = v76;
              BOOL v75 = v78 == v74;
              LOWORD(v76) = v64;
              goto LABEL_152;
            }
          }
          int v57 = 0;
          unsigned __int16 v63 = v64;
        }
        else
        {
          unsigned __int16 v63 = 0;
          uint64_t v64 = (unsigned __int16)v93;
        }
LABEL_152:
        uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, int *))(*(void *)(a1 + 48) + 120))(a3, a4, v64, &v93);
        if ((v17 & 0x80000000) == 0)
        {
          if (!v63
            || (*(unsigned __int16 *)(a1 + 138) < 2u || !*(_DWORD *)(a1 + 140)
              ? (uint64_t v72 = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)(a1 + 48) + 192))(a3, a4, v63))
              : (*(_WORD *)__s2 = 0,
                 int v90 = 16,
                 v72 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, int *, char *))(*(void *)(a1 + 48) + 160))(a3, a4, v63, 0, 1, &v90, __s2)), uint64_t v17 = v72, (v72 & 0x80000000) == 0))
          {
            unsigned __int16 v53 = v93;
            if ((_WORD)v93) {
              continue;
            }
          }
        }
        return v17;
      }
    }
  }
  return v17;
}

uint64_t hlp_Disambiguate(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, uint64_t a5, unsigned int a6, unsigned int a7, int a8, unsigned __int16 a9)
{
  LODWORD(NextUtf8Offset) = a8;
  uint64_t v14 = a3;
  uint64_t v82 = *MEMORY[0x263EF8340];
  long long v78 = xmmword_20D62D762;
  long long v79 = unk_20D62D772;
  long long v80 = xmmword_20D62D782;
  long long v81 = unk_20D62D792;
  strcpy(v74, "disambiguate_homographs");
  uint64_t v75 = unk_20D62D73A;
  long long v76 = xmmword_20D62D742;
  long long v77 = unk_20D62D752;
  __int16 v73 = 0;
  long long __s = 0;
  int v71 = 0;
  __s1 = 0;
  int v68 = 0;
  int v69 = 0;
  uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, int *))(*(void *)(a1 + 48) + 104))(a2, a3, 1, 0, &v68);
  if ((v17 & 0x80000000) == 0
    && ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, __int16 *))(*(void *)(a1 + 48) + 184))(a2, v14, a5, 4, &v73) & 0x80000000) == 0)
  {
    unsigned int v66 = a7;
    uint64_t v67 = a2;
    if (v73 == 1)
    {
      uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char **, int *))(*(void *)(a1 + 48) + 176))(a2, v14, a5, 4, &__s, &v69);
      if ((v17 & 0x80000000) == 0)
      {
        if (*__s)
        {
          unint64_t v18 = (int)(a7 - a6 + 14);
          if (v18 > *(unsigned __int16 *)(a1 + 136))
          {
            uint64_t v19 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 104), (int)(a7 - a6 + 14));
            if (!v19
              || (*(void *)(a1 + 104) = v19,
                  (uint64_t v24 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 112), v18)) == 0))
            {
              uint64_t v17 = 2314215434;
              log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v20, v21, v22, v23, v62);
              return v17;
            }
            *(void *)(a1 + 112) = v24;
            *(_WORD *)(a1 + 136) = a7 - a6 + 14;
          }
          **(unsigned char **)(a1 + 104) = 0;
          **(unsigned char **)(a1 + 112) = 0;
          uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *))(*(void *)(a1 + 48) + 104))(a2, v14, 2, (unsigned __int16)v68, (char *)&v71 + 2);
          if ((v25 & 0x80000000) != 0) {
            return v25;
          }
          uint64_t v29 = 0;
          LODWORD(PreviousUtf8Offset) = a9;
          unsigned int v65 = a5;
          uint64_t v64 = v14;
          while (1)
          {
            uint64_t v31 = HIWORD(v71);
            if (!HIWORD(v71)) {
              break;
            }
            if (HIWORD(v71) == a5)
            {
              unsigned __int16 v32 = &a4[NextUtf8Offset];
              for (int i = (*(uint64_t (**)(void, void, const char *))(*(void *)(a1 + 96) + 128))(*(void *)(a1 + 80), *(void *)(a1 + 88), v32);
                    i == 1;
                    int i = (*(uint64_t (**)(void, void, char *))(*(void *)(a1 + 96) + 128))(*(void *)(a1 + 80), *(void *)(a1 + 88), &a4[NextUtf8Offset]))
              {
                uint64_t NextUtf8Offset = (unsigned __int16)utf8_GetNextUtf8Offset(a4, NextUtf8Offset);
                unsigned __int16 v32 = &a4[NextUtf8Offset];
              }
              do
                uint64_t PreviousUtf8Offset = (unsigned __int16)utf8_GetPreviousUtf8Offset((uint64_t)a4, PreviousUtf8Offset);
              while ((*(unsigned int (**)(void, void, char *))(*(void *)(a1 + 96) + 128))(*(void *)(a1 + 80), *(void *)(a1 + 88), &a4[PreviousUtf8Offset]) == 1);
              unsigned __int16 v34 = utf8_GetNextUtf8Offset(a4, PreviousUtf8Offset);
              uint64_t v35 = &a4[a6];
              int v36 = NextUtf8Offset - a6;
              strncat(*(char **)(a1 + 104), v35, v36);
              for (int j = (unsigned __int16)Utf8_LengthInUtf8chars((unint64_t)v35, v36); j; --j)
                *(_WORD *)(*(void *)(a1 + 112) + strlen(*(const char **)(a1 + 112))) = 32;
              a6 = v34;
              size_t v38 = *(void *)(a1 + 104) + strlen(*(const char **)(a1 + 104));
              *(_WORD *)size_t v38 = -22590;
              *(unsigned char *)(v38 + 2) = 0;
              strncat(*(char **)(a1 + 104), v32, v34 - (int)NextUtf8Offset);
              size_t v39 = (unsigned __int16)Utf8_LengthInUtf8chars((unint64_t)v32, v34 - NextUtf8Offset);
              BOOL v40 = strlen(__s) <= v39 || v29 > 9;
              if (v40)
              {
                a5 = v29;
              }
              else
              {
                unint64_t v41 = 1;
                do
                {
                  *(_WORD *)(*(void *)(a1 + 104) + strlen(*(const char **)(a1 + 104))) = 126;
                  a5 = (v29 + 1);
                  BOOL v40 = strlen(__s) - v39 > v41++;
                  BOOL v42 = !v40 || v29 >= 9;
                  LODWORD(v29) = v29 + 1;
                }
                while (!v42);
              }
              size_t v43 = *(void *)(a1 + 104) + strlen(*(const char **)(a1 + 104));
              *(_WORD *)size_t v43 = -22590;
              *(unsigned char *)(v43 + 2) = 0;
              size_t v44 = *(void *)(a1 + 112) + strlen(*(const char **)(a1 + 112));
              *(_WORD *)size_t v44 = -22590;
              *(unsigned char *)(v44 + 2) = 0;
              strcat(*(char **)(a1 + 112), __s);
              if (strlen(__s) < v39)
              {
                int v45 = 0;
                do
                {
                  *(_WORD *)(*(void *)(a1 + 112) + strlen(*(const char **)(a1 + 112))) = 126;
                  ++v45;
                }
                while (v39 - strlen(__s) > (unsigned __int16)v45);
              }
              size_t v46 = *(void *)(a1 + 112) + strlen(*(const char **)(a1 + 112));
              *(_WORD *)size_t v46 = -22590;
              *(unsigned char *)(v46 + 2) = 0;
              uint64_t v31 = HIWORD(v71);
              LODWORD(PreviousUtf8Offset) = a6;
              uint64_t v29 = a5;
              LODWORD(a5) = v65;
              uint64_t v14 = v64;
            }
            uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, char *))(*(void *)(a1 + 48) + 120))(a2, v14, v31, (char *)&v71 + 2);
            if ((v17 & 0x80000000) != 0) {
              return v17;
            }
          }
          if (a6 < v66)
          {
            int v47 = &a4[a6];
            strncat(*(char **)(a1 + 104), v47, (int)(v66 - a6));
            for (int k = (unsigned __int16)Utf8_LengthInUtf8chars((unint64_t)v47, v66 - a6); k; --k)
              *(_WORD *)(*(void *)(a1 + 112) + strlen(*(const char **)(a1 + 112))) = 32;
          }
          uint64_t v49 = *(void *)(*(void *)a1 + 32);
          if (v29 > 9)
          {
            log_OutText(v49, (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Homograph validation not OK", v26, v27, v28, v62);
            LOWORD(v71) = 0;
            return (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, char *))(*(void *)(a1 + 48) + 160))(v67, v64, v65, 7, 1, &v71, (char *)&v68 + 2);
          }
          log_OutText(v49, (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"%s L1: %s", v26, v27, v28, (uint64_t)v74);
          unsigned __int16 v50 = strlen(*(const char **)(a1 + 104));
          uint64_t v25 = (*(uint64_t (**)(void, void, void, void, void))(*(void *)(a1 + 72) + 120))(*(void *)(a1 + 56), *(void *)(a1 + 64), 0, *(void *)(a1 + 104), v50);
          if ((v25 & 0x80000000) != 0) {
            return v25;
          }
          log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"%s L2: %s", v51, v52, v53, (uint64_t)v74);
          unsigned __int16 v54 = strlen(*(const char **)(a1 + 112));
          uint64_t v25 = (*(uint64_t (**)(void, void, uint64_t, void, void))(*(void *)(a1 + 72) + 120))(*(void *)(a1 + 56), *(void *)(a1 + 64), 1, *(void *)(a1 + 112), v54);
          if ((v25 & 0x80000000) != 0) {
            return v25;
          }
          uint64_t v25 = (*(uint64_t (**)(void, void, char *))(*(void *)(a1 + 72) + 80))(*(void *)(a1 + 56), *(void *)(a1 + 64), v74);
          if ((v25 & 0x80000000) != 0) {
            return v25;
          }
          uint64_t v17 = (*(uint64_t (**)(void, void, void, char **, char *))(*(void *)(a1 + 72) + 128))(*(void *)(a1 + 56), *(void *)(a1 + 64), 0, &__s1, (char *)&v69 + 2);
          if ((v17 & 0x80000000) == 0)
          {
            __s1[HIWORD(v69)] = 0;
            log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"%s O1: %s", v55, v56, v57, (uint64_t)v74);
            if (strstr(__s1, "§"))
            {
              log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Homograph validation not OK", v58, v59, v60, v63);
              LOWORD(v71) = 0;
              return (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, char *))(*(void *)(a1 + 48) + 160))(v67, v64, v65, 7, 1, &v71, (char *)&v68 + 2);
            }
          }
        }
      }
    }
  }
  return v17;
}

uint64_t fe_hmogrph_ProcessEnd(uint64_t a1, int a2)
{
  LODWORD(result) = safeh_HandleCheck(a1, a2, 62342, 488);
  if ((int)result >= 0) {
    return result;
  }
  else {
    return 2314215432;
  }
}

uint64_t fe_hmogrph_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2314215425;
  }
  uint64_t result = 0;
  *a2 = &IFeHmogrph;
  return result;
}

uint64_t fe_hmogrph_ClassOpen(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0;
  if (!a3) {
    return 2314215431;
  }
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *(void *)a3 = a1;
    *(void *)(a3 + 8) = a2;
  }
  return result;
}

uint64_t fe_hmogrph_ClassClose()
{
  return 0;
}

uint64_t com_useStatHmogrph(uint64_t a1, _DWORD *a2)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v8 = 0;
  memset(v9, 0, sizeof(v9));
  *a2 = 0;
  uint64_t result = stat_hmogrph_getBrokerString(a1, (char *)v9, 0x100uLL);
  if ((result & 0x80000000) == 0)
  {
    if ((brk_DataOpenEx(*(void *)(a1 + 24), (uint64_t)v9, 1, (uint64_t)&v8) & 0x80000000) != 0)
    {
      log_OutText(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Stathmogrph data not found", v5, v6, v7, 0);
    }
    else
    {
      *a2 = 1;
      uint64_t result = brk_DataClose(*(void *)(a1 + 24), v8);
      if ((result & 0x80000000) != 0) {
        return result;
      }
    }
    return 0;
  }
  return result;
}

uint64_t stat_hmogrph_getBrokerString(uint64_t a1, char *a2, unint64_t a3)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v8 = 0;
  *(void *)uint64_t v9 = 0;
  memset(v10, 0, sizeof(v10));
  uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"langcode", v9);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"fecfg", &v8);
    if ((result & 0x80000000) == 0)
    {
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      int v7 = brokeraux_ComposeBrokerString(a1, (const char *)v10, 1, 1, *(char **)v9, 0, 0, a2, a3);
      return v7 & (v7 >> 31);
    }
  }
  return result;
}

uint64_t com_getUnicodeOrth(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  *(_WORD *)&__c[1] = -1;
  __c[0] = 0;
  *(void *)&__c[3] = 0;
  strcpy(v14, "stathmogrph_");
  __strcat_chk();
  int v9 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, char *, unsigned char *, unsigned char *, unsigned char *))(a1 + 96))(a2, a3, "fecfg", v14, &__c[3], &__c[1], __c);
  uint64_t result = 0;
  if ((v9 & 0x80000000) == 0 && *(_WORD *)&__c[1])
  {
    uint64_t v11 = **(void **)&__c[3];
    uint64_t v12 = strchr(**(char ***)&__c[3], __c[0]);
    if (v12)
    {
      *uint64_t v12 = 0;
      uint64_t v11 = **(void **)&__c[3];
    }
    *a5 = v11;
    return 1;
  }
  return result;
}

uint64_t hlp_addWord(uint64_t a1, char *__s, int a3, int a4, const char *a5, const char *a6, const char *a7, unsigned int a8, const char *a9, uint64_t *a10, const char *a11, const char *a12, uint64_t a13)
{
  __int16 v14 = a4;
  __int16 v15 = a3;
  uint64_t v17 = a1;
  uint64_t v18 = a13;
  uint64_t v19 = a10;
  if (*(_WORD *)(a13 + 8))
  {
    uint64_t v20 = a6;
    uint64_t v21 = *(void *)a13 + 48;
    uint64_t v22 = *(unsigned __int16 *)(a13 + 8);
    while (*(unsigned __int16 *)(v21 - 40) != a3 || *(unsigned __int16 *)(v21 - 38) != a4)
    {
      v21 += 64;
      if (!--v22) {
        goto LABEL_6;
      }
    }
    if (*(_WORD *)(v21 + 8))
    {
      uint64_t v39 = 0;
      uint64_t v40 = *(void *)v21;
      while (1)
      {
        uint64_t v41 = v40 + 16 * v39;
        unsigned int v43 = *(unsigned __int16 *)(v41 + 10);
        BOOL v42 = (_WORD *)(v41 + 10);
        uint64_t v44 = *v19 + 32 * v39;
        __int16 v45 = *(_WORD *)(v44 + 8);
        unsigned int v46 = *(unsigned __int16 *)(v44 + 24);
        if (v43 > v46) {
          _WORD *v42 = v46;
        }
        uint64_t v47 = (unsigned __int16)*(v42 - 1);
        unsigned __int16 v48 = v45 + v47;
        uint64_t v109 = (unsigned __int16)(v45 + v47);
        uint64_t v49 = heap_Realloc(*(uint64_t **)(a1 + 8), *(void *)(v40 + 16 * v39), 56 * v109);
        if (!v49) {
          break;
        }
        uint64_t v40 = *(void *)v21;
        *(void *)(*(void *)v21 + 16 * v39) = v49;
        if (v47 < v48)
        {
          uint64_t v50 = v47;
          uint64_t v104 = v47;
          for (uint64_t i = v47; i != v109; ++i)
          {
            uint64_t v52 = *v19;
            if (v50)
            {
              uint64_t v53 = i - v50;
              unsigned __int16 v54 = *(const char **)(*(void *)(v52 + 32 * v39) + 8 * (i - v50));
              uint64_t v55 = (_WORD *)(*(void *)(v40 + 16 * v39) + 8);
              uint64_t v56 = v50;
              while (strcmp(*((const char **)v55 - 1), v54))
              {
                v55 += 28;
                if (!--v56)
                {
                  uint64_t v20 = a6;
                  goto LABEL_29;
                }
              }
              unsigned int v67 = *(unsigned __int16 *)(*(void *)(v52 + 32 * v39 + 16) + 2 * v53);
              if ((unsigned __int16)*v55 > v67) {
                *uint64_t v55 = v67;
              }
              uint64_t v20 = a6;
              uint64_t v19 = a10;
            }
            else
            {
              uint64_t v53 = i - v50;
              unsigned __int16 v54 = *(const char **)(*(void *)(v52 + 32 * v39) + 8 * (i - v50));
LABEL_29:
              uint64_t v17 = a1;
              int v57 = strlen(v54);
              uint64_t v58 = (char *)heap_Calloc(*(void **)(a1 + 8), 1, (v57 + 1));
              *(void *)(*(void *)(*(void *)v21 + 16 * v39)
                        + 56 * *(unsigned __int16 *)(*(void *)v21 + 16 * v39 + 8)) = v58;
              if (!v58) {
                goto LABEL_59;
              }
              uint64_t v19 = a10;
              strcpy(v58, *(const char **)(*(void *)(*a10 + 32 * v39) + 8 * v53));
              *(_WORD *)(*(void *)(*(void *)v21 + 16 * v39)
                       + 56 * *(unsigned __int16 *)(*(void *)v21 + 16 * v39 + 8)
                       + 8) = *(_WORD *)(*(void *)(*a10 + 32 * v39 + 16) + 2 * v53);
              int v59 = strlen(a9);
              uint64_t v60 = (char *)heap_Calloc(*(void **)(a1 + 8), 1, (v59 + 1));
              *(void *)(*(void *)(*(void *)v21 + 16 * v39)
                        + 56 * *(unsigned __int16 *)(*(void *)v21 + 16 * v39 + 8)
                        + 16) = v60;
              if (!v60) {
                goto LABEL_59;
              }
              strcpy(v60, a9);
              int v61 = strlen(a11);
              uint64_t v62 = (char *)heap_Calloc(*(void **)(a1 + 8), 1, (v61 + 1));
              *(void *)(*(void *)(*(void *)v21 + 16 * v39)
                        + 56 * *(unsigned __int16 *)(*(void *)v21 + 16 * v39 + 8)
                        + 24) = v62;
              if (!v62) {
                goto LABEL_59;
              }
              strcpy(v62, a11);
              int v63 = strlen(a12);
              uint64_t v64 = (char *)heap_Calloc(*(void **)(a1 + 8), 1, (v63 + 1));
              *(void *)(*(void *)(*(void *)v21 + 16 * v39)
                        + 56 * *(unsigned __int16 *)(*(void *)v21 + 16 * v39 + 8)
                        + 32) = v64;
              if (!v64) {
                goto LABEL_59;
              }
              strcpy(v64, a12);
              int v65 = strlen(v20);
              unsigned int v66 = (char *)heap_Calloc(*(void **)(a1 + 8), 1, (v65 + 1));
              *(void *)(*(void *)(*(void *)v21 + 16 * v39)
                        + 56 * *(unsigned __int16 *)(*(void *)v21 + 16 * v39 + 8)
                        + 40) = v66;
              if (!v66) {
                goto LABEL_59;
              }
              strcpy(v66, v20);
              uint64_t v40 = *(void *)v21;
              ++*(_WORD *)(*(void *)v21 + 16 * v39 + 8);
            }
            uint64_t v50 = v104;
          }
        }
        uint64_t v68 = 0;
        if (++v39 >= (unint64_t)*(unsigned __int16 *)(v21 + 8)) {
          return v68;
        }
      }
      uint64_t v68 = 2314215434;
      uint64_t v97 = *(void *)(a1 + 32);
      goto LABEL_61;
    }
    return 0;
  }
LABEL_6:
  uint64_t v23 = *(unsigned __int16 *)(a13 + 10);
  if (*(_WORD *)(a13 + 10))
  {
    uint64_t v24 = *(void *)a13;
    if (*(unsigned __int16 *)(a13 + 8) + 2 > v23)
    {
      uint64_t v25 = heap_Realloc(*(uint64_t **)(a1 + 8), *(void *)a13, (v23 << 6) + 1280);
      if (!v25) {
        goto LABEL_59;
      }
      *(void *)a13 = v25;
      bzero((void *)(v25 + ((unint64_t)*(unsigned __int16 *)(a13 + 8) << 6)), 0x540uLL);
      *(_WORD *)(a13 + 10) += 20;
      uint64_t v24 = *(void *)a13;
    }
  }
  else
  {
    uint64_t v30 = heap_Calloc(*(void **)(a1 + 8), 1, 3201);
    *(void *)a13 = v30;
    if (!v30) {
      goto LABEL_59;
    }
    uint64_t v24 = v30;
    *(_WORD *)(a13 + 10) = 50;
  }
  uint64_t v103 = *(unsigned __int16 *)(a13 + 8);
  uint64_t v31 = v24 + (v103 << 6);
  int v32 = strlen(__s);
  unsigned __int16 v33 = (char *)heap_Calloc(*(void **)(v17 + 8), 1, (v32 + 4));
  *(void *)uint64_t v31 = v33;
  if (!v33) {
    goto LABEL_59;
  }
  strcpy(v33, __s);
  *(_DWORD *)(v31 + 32) = 0;
  uint64_t v34 = v17;
  *(_DWORD *)(v31 + 36) = hlp_doesWordEndInComma(__s);
  int v35 = strlen(__s);
  int v36 = (char *)heap_Calloc(*(void **)(v17 + 8), 1, (v35 + 4));
  *(void *)(v31 + 40) = v36;
  if (!v36) {
    goto LABEL_60;
  }
  unsigned int v37 = v36;
  if (*(_DWORD *)(v31 + 36) == 1)
  {
    int v38 = strlen(*(const char **)v31);
    strncpy(v37, *(const char **)v31, (v38 - 1));
  }
  else
  {
    strcpy(v36, *(const char **)v31);
  }
  int v69 = strlen(a5);
  unsigned __int8 v70 = (char *)heap_Calloc(*(void **)(v17 + 8), 1, (v69 + 1));
  uint64_t v71 = v103;
  uint64_t v72 = v24 + (v103 << 6);
  *(void *)(v72 + 16) = v70;
  if (!v70
    || (strcpy(v70, a5),
        __int16 v73 = (char *)heap_Calloc(*(void **)(v34 + 8), 1, a8 + 1),
        (*(void *)(v72 + 24) = v73) == 0))
  {
LABEL_60:
    uint64_t v68 = 2314215434;
    uint64_t v97 = *(void *)(v34 + 32);
    goto LABEL_61;
  }
  strncpy(v73, a7, a8);
  unsigned __int8 v74 = a10;
  uint64_t v75 = *((unsigned __int16 *)a10 + 4);
  uint64_t v76 = v24 + (v103 << 6);
  *(_WORD *)(v76 + 56) = v75;
  uint64_t v77 = heap_Calloc(*(void **)(v34 + 8), v75, 16);
  *(void *)(v76 + 48) = v77;
  __srcb = (char *)(v76 + 48);
  uint64_t v17 = v34;
  if (!v77)
  {
LABEL_59:
    uint64_t v68 = 2314215434;
    uint64_t v97 = *(void *)(v17 + 32);
LABEL_61:
    log_OutPublic(v97, (uint64_t)"FE_HMOGRPH", 37000, 0, v26, v27, v28, v29, v99);
    return v68;
  }
  if (*((_WORD *)a10 + 4))
  {
    unint64_t v78 = 0;
    uint64_t v79 = *a10;
    unsigned int v99 = a13;
    uint64_t v100 = v24;
    do
    {
      uint64_t v80 = v79 + 32 * v78;
      uint64_t v81 = *(unsigned __int16 *)(v80 + 8);
      uint64_t v82 = *(void *)__srcb + 16 * v78;
      *(_WORD *)(v82 + 8) = v81;
      *(_WORD *)(v82 + 10) = *(_WORD *)(v80 + 24);
      if (!v81) {
        return 0;
      }
      uint64_t v83 = heap_Calloc(*(void **)(v17 + 8), v81, 56);
      uint64_t v102 = 16 * v78;
      *(void *)(*(void *)__srcb + 16 * v78) = v83;
      if (!v83) {
        goto LABEL_59;
      }
      uint64_t v79 = *v74;
      if (*(_WORD *)(*v74 + 32 * v78 + 8))
      {
        uint64_t v84 = 0;
        uint64_t v85 = 0;
        unint64_t v101 = v78;
        while (1)
        {
          int v86 = strlen(*(const char **)(*(void *)(v79 + 32 * v78) + 8 * v85));
          uint64_t v87 = (char *)heap_Calloc(*(void **)(v17 + 8), 1, (v86 + 1));
          *(void *)(*(void *)(*(void *)__srcb + v102) + v84) = v87;
          if (!v87) {
            break;
          }
          strcpy(v87, *(const char **)(*(void *)(*a10 + 32 * v78) + 8 * v85));
          uint64_t v110 = v85;
          *(_WORD *)(*(void *)(*(void *)__srcb + v102) + v84 + 8) = *(_WORD *)(*(void *)(*a10 + 32 * v78 + 16)
                                                                                 + 2 * v85);
          int v88 = strlen(a9);
          unsigned __int16 v89 = (char *)heap_Calloc(*(void **)(v17 + 8), 1, (v88 + 1));
          *(void *)(*(void *)(*(void *)__srcb + v102) + v84 + 16) = v89;
          if (!v89) {
            goto LABEL_59;
          }
          strcpy(v89, a9);
          int v90 = strlen(a11);
          unsigned __int16 v91 = (char *)heap_Calloc(*(void **)(v17 + 8), 1, (v90 + 1));
          *(void *)(*(void *)(*(void *)__srcb + v102) + v84 + 24) = v91;
          if (!v91) {
            goto LABEL_59;
          }
          strcpy(v91, a11);
          int v92 = strlen(a12);
          int v93 = (char *)heap_Calloc(*(void **)(v17 + 8), 1, (v92 + 1));
          *(void *)(*(void *)(*(void *)__srcb + v102) + v84 + 32) = v93;
          if (!v93) {
            goto LABEL_59;
          }
          strcpy(v93, a12);
          int v94 = strlen(a6);
          int v95 = (char *)heap_Calloc(*(void **)(v17 + 8), 1, (v94 + 1));
          *(void *)(*(void *)(*(void *)__srcb + v102) + v84 + 40) = v95;
          if (!v95) {
            goto LABEL_59;
          }
          strcpy(v95, a6);
          ++v85;
          uint64_t v79 = *a10;
          unint64_t v78 = v101;
          v84 += 56;
          if (v110 + 1 >= (unint64_t)*(unsigned __int16 *)(*a10 + 32 * v101 + 8)) {
            goto LABEL_57;
          }
        }
        uint64_t v68 = 2314215434;
        uint64_t v97 = *(void *)(v17 + 32);
        goto LABEL_61;
      }
LABEL_57:
      ++v78;
      unsigned __int8 v74 = a10;
      uint64_t v71 = v103;
      uint64_t v18 = a13;
      uint64_t v24 = v100;
    }
    while (v78 < *((unsigned __int16 *)a10 + 4));
  }
  uint64_t v68 = 0;
  uint64_t v96 = v24 + (v71 << 6);
  *(_WORD *)(v96 + 8) = v15;
  *(_WORD *)(v96 + 10) = v14;
  ++*(_WORD *)(v18 + 8);
  return v68;
}

BOOL hlp_doesWordEndInComma(const char *a1)
{
  BOOL result = 0;
  if (a1)
  {
    size_t v2 = strlen(a1);
    if (v2)
    {
      if (strstr(",.:?!;()", &a1[v2 - 1])) {
        return 1;
      }
    }
  }
  return result;
}

uint64_t hlp_do_add(uint64_t *a1, uint64_t a2, char *a3, int a4, int a5, const char *a6, const char *a7, const char *a8, const char *a9, const char *a10, unsigned __int16 a11)
{
  if (!*(_WORD *)(a2 + 8)) {
    return 166731781;
  }
  uint64_t v15 = heap_Calloc(*(void **)(*a1 + 8), 1, 16);
  if (v15)
  {
    uint64_t v20 = (uint64_t *)v15;
    uint64_t v21 = *(unsigned __int16 *)(a2 + 8);
    *(_WORD *)(v15 + 10) = v21;
    *(_WORD *)(v15 + 8) = v21;
    uint64_t v22 = heap_Calloc(*(void **)(*a1 + 8), v21, 32);
    *uint64_t v20 = v22;
    if (v22)
    {
      int v52 = a5;
      uint64_t v53 = a6;
      if (!*(_WORD *)(a2 + 8))
      {
LABEL_22:
        hlp_addWord(*a1, a3, a4, v52, a9, v53, a10, a11, a9, v20, a7, a8, (uint64_t)(a1 + 1));
LABEL_26:
        stat_hmogrph_freeCandidatePhons((void *)*a1, (uint64_t)v20);
        heap_Free(*(void **)(*a1 + 8), (uint64_t)v20);
        return 0;
      }
      uint64_t v27 = 0;
      while (1)
      {
        uint64_t v28 = *(void *)a2 + (v27 << 6);
        uint64_t v31 = *(void *)(v28 + 48);
        uint64_t v30 = (uint64_t **)(v28 + 48);
        uint64_t v29 = (void *)v31;
        int v32 = *(unsigned __int16 *)(v31 + 10);
        unsigned __int16 v33 = (_WORD *)(v22 + 32 * v27);
        v33[12] = v32;
        uint64_t v34 = *(unsigned __int16 *)(v31 + 8);
        if (*(_WORD *)(v31 + 8))
        {
          unsigned __int16 v35 = 0;
          int v36 = (unsigned __int16 *)(*v29 + 8);
          do
          {
            int v37 = *v36;
            v36 += 28;
            if (v37 == v32) {
              ++v35;
            }
            --v34;
          }
          while (v34);
        }
        else
        {
          unsigned __int16 v35 = 0;
        }
        v33[4] = v35;
        _OWORD v33[5] = v35;
        uint64_t v38 = heap_Calloc(*(void **)(*a1 + 8), v35, 8);
        uint64_t v39 = *v20;
        *(void *)(*v20 + 32 * v27) = v38;
        uint64_t v40 = *a1;
        if (!v38) {
          break;
        }
        uint64_t v41 = heap_Calloc(*(void **)(v40 + 8), *(unsigned __int16 *)(v39 + 32 * v27 + 10), 2);
        uint64_t v22 = *v20;
        *(void *)(*v20 + 32 * v27 + 16) = v41;
        if (!v41) {
          goto LABEL_24;
        }
        BOOL v42 = *v30;
        if (*((_WORD *)*v30 + 4))
        {
          uint64_t v43 = 0;
          unint64_t v44 = 0;
          unsigned __int16 v45 = 0;
          uint64_t v46 = *v42;
          do
          {
            if (*(unsigned __int16 *)(v46 + v43 + 8) == *(unsigned __int16 *)(v22 + 32 * v27 + 24))
            {
              int v47 = strlen(*(const char **)(v46 + v43));
              *(void *)(*(void *)(*v20 + 32 * v27) + 8 * v45) = heap_Alloc(*(void *)(*a1 + 8), (v47 + 1));
              unsigned __int16 v48 = *(char **)(*(void *)(*v20 + 32 * v27) + 8 * v45);
              if (!v48) {
                goto LABEL_24;
              }
              strcpy(v48, *(const char **)(**v30 + v43));
              BOOL v42 = *v30;
              uint64_t v46 = **v30;
              uint64_t v22 = *v20;
              *(_WORD *)(*(void *)(*v20 + 32 * v27 + 16) + 2 * v45++) = *(_WORD *)(v46 + v43 + 8);
            }
            ++v44;
            v43 += 56;
          }
          while (v44 < *((unsigned __int16 *)v42 + 4));
        }
        if (++v27 >= (unint64_t)*(unsigned __int16 *)(a2 + 8)) {
          goto LABEL_22;
        }
      }
      uint64_t v50 = *(void *)(v40 + 32);
    }
    else
    {
LABEL_24:
      uint64_t v50 = *(void *)(*a1 + 32);
    }
    log_OutPublic(v50, (uint64_t)"FE_HMOGRPH", 37000, 0, v23, v24, v25, v26, v51);
    goto LABEL_26;
  }
  log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v16, v17, v18, v19, v51);
  return 2314215434;
}

void *stat_hmogrph_freeCandidatePhons(void *result, uint64_t a2)
{
  uint64_t v3 = *(void *)a2;
  if (v3)
  {
    uint64_t v4 = result;
    if (*(_WORD *)(a2 + 8))
    {
      unint64_t v5 = 0;
      do
      {
        unint64_t v6 = v3 + 32 * v5;
        uint64_t v7 = *(void *)v6;
        if (*(void *)v6)
        {
          if (*(_WORD *)(v6 + 8))
          {
            unint64_t v8 = 0;
            do
            {
              if (*(void *)(*(void *)v6 + 8 * v8))
              {
                heap_Free((void *)v4[1], *(void *)(*(void *)v6 + 8 * v8));
                *(void *)(*(void *)(*(void *)a2 + 32 * v5) + 8 * v8) = 0;
                uint64_t v3 = *(void *)a2;
              }
              ++v8;
              unint64_t v6 = v3 + 32 * v5;
            }
            while (v8 < *(unsigned __int16 *)(v6 + 8));
            uint64_t v7 = *(void *)v6;
          }
          heap_Free((void *)v4[1], v7);
          uint64_t v3 = *(void *)a2;
          *(void *)(*(void *)a2 + 32 * v5) = 0;
        }
        if (*(void *)(v3 + 32 * v5 + 16))
        {
          heap_Free((void *)v4[1], *(void *)(v3 + 32 * v5 + 16));
          uint64_t v3 = *(void *)a2;
          *(void *)(*(void *)a2 + 32 * v5 + 16) = 0;
        }
        ++v5;
      }
      while (v5 < *(unsigned __int16 *)(a2 + 8));
    }
    BOOL result = heap_Free((void *)v4[1], v3);
    *(void *)a2 = 0;
  }
  return result;
}

uint64_t hlp_prepare_phons(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, const char *a6, uint64_t a7, const char *a8, const char *a9, const char *a10, unsigned __int16 a11, unsigned __int16 a12, unsigned __int16 a13, const char *a14, const char *a15, unsigned __int16 a16)
{
  uint64_t v96 = 0;
  uint64_t v97 = 0;
  int v93 = 0;
  v99[0] = 0;
  uint64_t v24 = heap_Calloc(*(void **)(*a4 + 8), 1, 16);
  if (!v24)
  {
    uint64_t v72 = 2314215434;
    log_OutPublic(*(void *)(*a4 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v25, v26, v27, v28, v81);
    return v72;
  }
  uint64_t v29 = v24;
  int v98 = 0;
  int v95 = 0;
  __int16 v94 = 0;
  *(_DWORD *)(v24 + 8) = 65537;
  uint64_t v30 = heap_Calloc(*(void **)(*a4 + 8), 1, 32);
  *(void *)uint64_t v29 = v30;
  if (!v30
    || (*(_DWORD *)(v30 + 8) = 0, unsigned __int16 v35 = strlen(a6), (v36 = heap_Calloc(*(void **)(*a4 + 8), 1, v35 + 1)) == 0))
  {
    uint64_t v72 = 2314215434;
    log_OutPublic(*(void *)(*a4 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v31, v32, v33, v34, v81);
    int v37 = 0;
    goto LABEL_65;
  }
  int v37 = (char *)v36;
  int v88 = a6;
  uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t, void, _WORD *))(*(void *)(a1 + 48) + 136))(a2, a3, a13, v99);
  if ((v38 & 0x80000000) != 0)
  {
    uint64_t v72 = v38;
LABEL_65:
    if (*(void *)v29) {
      heap_Free(*(void **)(*a4 + 8), *(void *)v29);
    }
    heap_Free(*(void **)(*a4 + 8), v29);
    if (v37) {
      goto LABEL_88;
    }
    return v72;
  }
  unsigned __int16 v39 = v99[0];
  HIWORD(v95) = v99[0];
  uint64_t v87 = v37;
  if (!v99[0])
  {
    uint64_t v72 = 0;
    unsigned __int16 v73 = 0;
    goto LABEL_72;
  }
  unsigned __int16 v89 = 0;
  unsigned __int16 v91 = 0;
  unsigned __int16 v92 = 0;
  int v90 = 0;
  int v84 = 1;
  unsigned __int16 v86 = 1;
  uint64_t v82 = a8;
  uint64_t v83 = a5;
  uint64_t v85 = a7;
  do
  {
    uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, int *, __int16 *))(*(void *)(a1 + 48)
                                                                                                 + 168))(a2, a3, v39, 0, 1, &v98, &v94);
    if ((v40 & 0x80000000) != 0) {
      goto LABEL_62;
    }
    if (v98 != 17)
    {
      if (v96) {
        BOOL v41 = v90 == 1;
      }
      else {
        BOOL v41 = 0;
      }
      if (v41)
      {
        uint64_t v40 = hlp_addWord(*a4, v37, HIWORD(v93), (unsigned __int16)v93, v96, a8, a15, a16, a14, (uint64_t *)v29, a9, a10, a5);
        if ((v40 & 0x80000000) != 0) {
          goto LABEL_62;
        }
        int v90 = 0;
      }
      uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t, void, char *))(*(void *)(a1 + 48) + 136))(a2, a3, HIWORD(v95), (char *)&v95 + 2);
      if ((v40 & 0x80000000) != 0) {
        goto LABEL_62;
      }
      goto LABEL_58;
    }
    uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, __int16 *))(*(void *)(a1 + 48) + 168))(a2, a3, HIWORD(v95), 1, 1, (char *)&v93 + 2, &v94);
    if ((v40 & 0x80000000) != 0) {
      goto LABEL_62;
    }
    uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, __int16 *))(*(void *)(a1 + 48)
                                                                                                  + 168))(a2, a3, HIWORD(v95), 2, 1, &v93, &v94);
    if ((v40 & 0x80000000) != 0) {
      goto LABEL_62;
    }
    if (HIWORD(v93) != v92 || (unsigned __int16)v93 != v91)
    {
      if (v84)
      {
        unsigned __int16 v91 = v93;
        unsigned __int16 v92 = HIWORD(v93);
      }
      else
      {
        uint64_t v40 = hlp_addWord(*a4, v37, v92, v91, v96, a8, a15, a16, a14, (uint64_t *)v29, a9, a10, a5);
        if ((v40 & 0x80000000) != 0) {
          goto LABEL_62;
        }
        ++v86;
        unsigned __int16 v92 = HIWORD(v93);
        unsigned __int16 v91 = v93;
      }
      int v84 = 0;
      uint64_t v42 = *(void *)v29;
      *(_WORD *)(v42 + 8) = 0;
      *(_WORD *)(v42 + 24) = -1;
      int v90 = 1;
    }
    strncpy(v37, &v88[v92], v91 - (unint64_t)v92);
    v37[(unsigned __int16)v93 - HIWORD(v93)] = 0;
    if (HIWORD(v93) < a11 || (unsigned __int16)v93 > a12) {
      break;
    }
    uint64_t v43 = *(unsigned __int16 *)(*(void *)v29 + 8);
    *(_WORD *)(*(void *)v29 + 8) = v43 + 1;
    uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, const char **, __int16 *))(*(void *)(a1 + 48)
                                                                                                 + 176))(a2, a3, HIWORD(v95), 3, &v97, &v94);
    if ((v40 & 0x80000000) != 0) {
      goto LABEL_62;
    }
    uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, const char **, __int16 *))(*(void *)(a1 + 48)
                                                                                                 + 176))(a2, a3, HIWORD(v95), 5, &v96, &v94);
    if ((v40 & 0x80000000) != 0) {
      goto LABEL_62;
    }
    uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, __int16 *))(*(void *)(a1 + 48)
                                                                                                  + 168))(a2, a3, HIWORD(v95), 7, 1, &v95, &v94);
    if ((v40 & 0x80000000) != 0) {
      goto LABEL_62;
    }
    uint64_t v44 = *(void *)v29;
    uint64_t v45 = *(unsigned __int16 *)(*(void *)v29 + 10);
    if (*(_WORD *)(*(void *)v29 + 10))
    {
      if ((int)v43 + 1 >= v45)
      {
        uint64_t v54 = heap_Realloc(*(uint64_t **)(*a4 + 8), *(void *)v44, 8 * v45 + 80);
        if (!v54
          || (uint64_t v55 = *(void *)v29,
              *(void *)uint64_t v55 = v54,
              (uint64_t v46 = heap_Realloc(*(uint64_t **)(*a4 + 8), *(void *)(v55 + 16), 2 * *(unsigned __int16 *)(v55 + 10) + 20)) == 0))
        {
LABEL_90:
          uint64_t v72 = 2314215434;
          uint64_t v53 = *a4;
LABEL_93:
          log_OutPublic(*(void *)(v53 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v48, v49, v50, v51, v81);
          goto LABEL_63;
        }
        uint64_t v44 = *(void *)v29;
        *(void *)(v44 + 16) = v46;
        *(_WORD *)(v44 + 10) += 10;
      }
      else
      {
        uint64_t v46 = *(void *)(v44 + 16);
      }
    }
    else
    {
      *(_WORD *)(v44 + 10) = 10;
      uint64_t v47 = heap_Calloc(*(void **)(*a4 + 8), 10, 8);
      uint64_t v52 = *(void *)v29;
      **(void **)uint64_t v29 = v47;
      uint64_t v53 = *a4;
      if (!v47)
      {
        uint64_t v72 = 2314215434;
        goto LABEL_93;
      }
      uint64_t v46 = heap_Calloc(*(void **)(v53 + 8), *(unsigned __int16 *)(v52 + 10), 2);
      uint64_t v44 = *(void *)v29;
      *(void *)(*(void *)v29 + 16) = v46;
      if (!v46) {
        goto LABEL_90;
      }
    }
    if (v89 <= *(unsigned __int16 *)(v44 + 8)) {
      unsigned __int16 v56 = *(_WORD *)(v44 + 8);
    }
    else {
      unsigned __int16 v56 = v89;
    }
    unsigned __int16 v89 = v56;
    *(_WORD *)(v46 + 2 * v43) = v95;
    if (*(unsigned __int16 *)(v44 + 24) > (unsigned __int16)v95) {
      *(_WORD *)(v44 + 24) = v95;
    }
    uint64_t v57 = v86 - 1;
    uint64_t v58 = *(const char **)(v85 + 8 * v57);
    uint64_t v59 = *(void *)v44;
    uint64_t v60 = *(char **)(v59 + 8 * v43);
    if (v58)
    {
      if (!v60 || (size_t v61 = strlen(*(const char **)(v59 + 8 * v43)), v61 < strlen(v58)))
      {
        int v62 = strlen(v58);
        uint64_t v63 = heap_Realloc(*(uint64_t **)(*a4 + 8), (uint64_t)v60, (v62 + 1));
        if (!v63) {
          goto LABEL_91;
        }
        *(void *)(**(void **)v29 + 8 * v43) = v63;
        uint64_t v60 = *(char **)(**(void **)v29 + 8 * v43);
        uint64_t v58 = *(const char **)(v85 + 8 * v57);
      }
      int v37 = v87;
      a8 = v82;
      strcpy(v60, v58);
    }
    else
    {
      uint64_t v68 = v97;
      if (!v60 || (size_t v69 = strlen(*(const char **)(v59 + 8 * v43)), v69 < strlen(v97)))
      {
        int v70 = strlen(v97);
        uint64_t v71 = heap_Realloc(*(uint64_t **)(*a4 + 8), (uint64_t)v60, (v70 + 1));
        if (!v71)
        {
LABEL_91:
          uint64_t v72 = 2314215434;
          log_OutPublic(*(void *)(*a4 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v64, v65, v66, v67, v81);
          int v37 = v87;
          goto LABEL_63;
        }
        *(void *)(**(void **)v29 + 8 * v43) = v71;
        uint64_t v60 = *(char **)(**(void **)v29 + 8 * v43);
        uint64_t v68 = v97;
      }
      int v37 = v87;
      strcpy(v60, v68);
      a8 = v82;
    }
    uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t, void, char *))(*(void *)(a1 + 48) + 136))(a2, a3, HIWORD(v95), (char *)&v95 + 2);
    a5 = v83;
    if ((v40 & 0x80000000) != 0) {
      goto LABEL_62;
    }
LABEL_58:
    unsigned __int16 v39 = HIWORD(v95);
  }
  while (HIWORD(v95));
  uint64_t v72 = 0;
  if (v96 && v90 == 1)
  {
    uint64_t v40 = hlp_addWord(*a4, v37, HIWORD(v93), (unsigned __int16)v93, v96, a8, a15, a16, a14, (uint64_t *)v29, a9, a10, a5);
LABEL_62:
    uint64_t v72 = v40;
  }
LABEL_63:
  unsigned __int16 v73 = v89;
LABEL_72:
  uint64_t v74 = *a4;
  uint64_t v75 = *(void *)v29;
  if (*(void *)v29)
  {
    if (*(_WORD *)(v29 + 8))
    {
      unint64_t v76 = 0;
      do
      {
        uint64_t v77 = *(void *)(v75 + 32 * v76);
        if (v77)
        {
          if (v73)
          {
            uint64_t v78 = 0;
            do
            {
              uint64_t v79 = *(void *)(*(void *)(*(void *)v29 + 32 * v76) + v78);
              if (v79)
              {
                heap_Free(*(void **)(v74 + 8), v79);
                *(void *)(*(void *)(*(void *)v29 + 32 * v76) + v78) = 0;
              }
              v78 += 8;
            }
            while (8 * v73 != v78);
            uint64_t v77 = *(void *)(*(void *)v29 + 32 * v76);
          }
          heap_Free(*(void **)(v74 + 8), v77);
          uint64_t v75 = *(void *)v29;
          *(void *)(*(void *)v29 + 32 * v76) = 0;
        }
        if (*(void *)(v75 + 32 * v76 + 16))
        {
          heap_Free(*(void **)(v74 + 8), *(void *)(v75 + 32 * v76 + 16));
          uint64_t v75 = *(void *)v29;
          *(void *)(*(void *)v29 + 32 * v76 + 16) = 0;
        }
        ++v76;
      }
      while (v76 < *(unsigned __int16 *)(v29 + 8));
    }
    heap_Free(*(void **)(v74 + 8), v75);
    *(void *)uint64_t v29 = 0;
    uint64_t v74 = *a4;
    int v37 = v87;
  }
  heap_Free(*(void **)(v74 + 8), v29);
LABEL_88:
  heap_Free(*(void **)(*a4 + 8), (uint64_t)v37);
  return v72;
}

uint64_t hlp_merge_add(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, const char *a5, char *a6, const char *a7, const char *a8, const char *a9, unsigned __int16 a10, const char *a11, const char *a12, unsigned __int16 a13)
{
  __lasts = 0;
  uint64_t v71 = 0;
  int v69 = 0;
  unsigned __int16 v68 = 0;
  uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, char *))(*(void *)(a1 + 48)
                                                                                             + 168))(a2, a3, a10, 1, 1, &v69, (char *)&v69 + 2);
  if ((v21 & 0x80000000) != 0) {
    return v21;
  }
  uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned __int16 *, char *))(*(void *)(a1 + 48) + 168))(a2, a3, a10, 2, 1, &v68, (char *)&v69 + 2);
  if ((v21 & 0x80000000) != 0) {
    return v21;
  }
  uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, char *))(*(void *)(a1 + 48) + 176))(a2, a3, a10, 3, &v71, (char *)&v69 + 2);
  if ((v21 & 0x80000000) != 0) {
    return v21;
  }
  uint64_t v66 = a7;
  long long __s = a6;
  ChineseUTFCharNuuint64_t m = utf8_GetChineseUTFCharNum((uint64_t)a5, v68);
  __int16 v23 = utf8_GetChineseUTFCharNum((uint64_t)a5, (unsigned __int16)v69);
  uint64_t v24 = heap_Calloc(*(void **)(*a4 + 8), 1, 16);
  uint64_t v29 = *a4;
  if (v24)
  {
    uint64_t v30 = v24;
    uint64_t v64 = a8;
    uint64_t v31 = *(void **)(v29 + 8);
    int v32 = strlen(__s);
    uint64_t v33 = heap_Calloc(v31, 1, (v32 + 4));
    uint64_t v38 = *a4;
    if (v33)
    {
      uint64_t v39 = v33;
      unsigned __int16 v62 = ChineseUTFCharNum - v23;
      uint64_t v44 = heap_Calloc(*(void **)(v38 + 8), 1, 8 * (unsigned __int16)(ChineseUTFCharNum - v23));
      uint64_t v65 = v30;
      if (!v44)
      {
        uint64_t v55 = 2314215434;
        log_OutPublic(*(void *)(*a4 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v40, v41, v42, v43, v59);
        goto LABEL_23;
      }
      int __dst = (char *)v39;
      uint64_t v45 = strtok_r(v71, ".", &__lasts);
      if (v45)
      {
        uint64_t v46 = v45;
        unsigned __int16 v47 = 0;
        do
        {
          if (strcmp(v46, "*"))
          {
            int v48 = strlen(v46);
            uint64_t v49 = (char *)heap_Calloc(*(void **)(*a4 + 8), 1, (v48 + 1));
            *(void *)(v44 + 8 * v47) = v49;
            if (!v49)
            {
              uint64_t v55 = 2314215434;
              log_OutPublic(*(void *)(*a4 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v50, v51, v52, v53, v59);
LABEL_22:
              uint64_t v39 = (uint64_t)__dst;
              goto LABEL_23;
            }
            strcpy(v49, v46);
            *(unsigned char *)(*(void *)(v44 + 8 * v47) + (unsigned __int16)strlen(v46)) = 0;
          }
          uint64_t v46 = strtok_r(0, ".", &__lasts);
          ++v47;
        }
        while (v46);
      }
      strcpy(__dst, __s);
      int v61 = (unsigned __int16)v69;
      uint64_t v54 = hlp_prepare_phons(a1, a2, a3, a4, v65, a5, v44, v66, v64, a9, v69, v68, a10, a11, a12, a13);
      if ((v54 & 0x80000000) != 0)
      {
        uint64_t v55 = v54;
        goto LABEL_22;
      }
      uint64_t v39 = (uint64_t)__dst;
      uint64_t v55 = hlp_do_add(a4, v65, __dst, v61, v60, v66, v64, a9, a11, a12, a13);
LABEL_23:
      heap_Free(*(void **)(*a4 + 8), v39);
      if (v44)
      {
        uint64_t v57 = v62;
        uint64_t v30 = v65;
        if (v62)
        {
          uint64_t v58 = (uint64_t *)v44;
          do
          {
            if (*v58)
            {
              heap_Free(*(void **)(*a4 + 8), *v58);
              uint64_t *v58 = 0;
            }
            ++v58;
            --v57;
          }
          while (v57);
        }
        heap_Free(*(void **)(*a4 + 8), v44);
      }
      else
      {
        uint64_t v30 = v65;
      }
    }
    else
    {
      uint64_t v55 = 2314215434;
      log_OutPublic(*(void *)(v38 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v34, v35, v36, v37, v59);
    }
    stat_hmogrph_freeNewSentData((uint64_t)a4, v30);
    heap_Free(*(void **)(*a4 + 8), v30);
  }
  else
  {
    uint64_t v55 = 2314215434;
    log_OutPublic(*(void *)(v29 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v25, v26, v27, v28, v59);
  }
  return v55;
}

uint64_t stat_hmogrph_freeNewSentData(uint64_t a1, uint64_t a2)
{
  if (*(_WORD *)(a2 + 10))
  {
    unint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)a2;
      unint64_t v6 = (uint64_t *)(*(void *)a2 + (v4 << 6));
      if (*v6)
      {
        heap_Free(*(void **)(*(void *)a1 + 8), *v6);
        *unint64_t v6 = 0;
      }
      uint64_t v9 = v6[2];
      unint64_t v8 = v6 + 2;
      uint64_t v7 = v9;
      if (v9)
      {
        heap_Free(*(void **)(*(void *)a1 + 8), v7);
        *unint64_t v8 = 0;
      }
      unint64_t v10 = v5 + (v4 << 6);
      uint64_t v11 = *(void *)(v10 + 24);
      if (v11)
      {
        heap_Free(*(void **)(*(void *)a1 + 8), v11);
        *(void *)(v10 + 24) = 0;
      }
      uint64_t v14 = *(void *)(v10 + 40);
      int v13 = (void *)(v10 + 40);
      uint64_t v12 = v14;
      if (v14)
      {
        heap_Free(*(void **)(*(void *)a1 + 8), v12);
        void *v13 = 0;
      }
      unint64_t v15 = v5 + (v4 << 6);
      uint64_t v17 = (uint64_t *)(v15 + 48);
      uint64_t v16 = *(void *)(v15 + 48);
      if (v16)
      {
        int v20 = *(unsigned __int16 *)(v15 + 56);
        uint64_t v19 = (unsigned __int16 *)(v15 + 56);
        unsigned __int16 v18 = v20;
        if (v20)
        {
          unint64_t v21 = 0;
          do
          {
            uint64_t v22 = *(void *)(v16 + 16 * v21);
            if (v22)
            {
              if (*(_WORD *)(v16 + 16 * v21 + 8))
              {
                uint64_t v23 = 0;
                unint64_t v24 = 0;
                do
                {
                  uint64_t v25 = *(void *)(v22 + v23);
                  if (v25)
                  {
                    heap_Free(*(void **)(*(void *)a1 + 8), v25);
                    uint64_t v16 = *v17;
                    uint64_t v22 = *(void *)(*v17 + 16 * v21);
                    *(void *)(v22 + v23) = 0;
                  }
                  uint64_t v26 = *(void *)(v22 + v23 + 16);
                  if (v26)
                  {
                    heap_Free(*(void **)(*(void *)a1 + 8), v26);
                    uint64_t v16 = *v17;
                    uint64_t v22 = *(void *)(*v17 + 16 * v21);
                    *(void *)(v22 + v23 + 16) = 0;
                  }
                  uint64_t v27 = *(void *)(v22 + v23 + 24);
                  if (v27)
                  {
                    heap_Free(*(void **)(*(void *)a1 + 8), v27);
                    uint64_t v16 = *v17;
                    uint64_t v22 = *(void *)(*v17 + 16 * v21);
                    *(void *)(v22 + v23 + 24) = 0;
                  }
                  uint64_t v28 = *(void *)(v22 + v23 + 32);
                  if (v28)
                  {
                    heap_Free(*(void **)(*(void *)a1 + 8), v28);
                    uint64_t v16 = *v17;
                    uint64_t v22 = *(void *)(*v17 + 16 * v21);
                    *(void *)(v22 + v23 + 32) = 0;
                  }
                  uint64_t v29 = *(void *)(v22 + v23 + 40);
                  if (v29)
                  {
                    heap_Free(*(void **)(*(void *)a1 + 8), v29);
                    uint64_t v16 = *v17;
                    uint64_t v22 = *(void *)(*v17 + 16 * v21);
                    *(void *)(v22 + v23 + 40) = 0;
                  }
                  ++v24;
                  v23 += 56;
                }
                while (v24 < *(unsigned __int16 *)(v16 + 16 * v21 + 8));
              }
              heap_Free(*(void **)(*(void *)a1 + 8), v22);
              uint64_t v16 = *v17;
              *(void *)(*v17 + 16 * v21) = 0;
              unsigned __int16 v18 = *v19;
            }
            ++v21;
          }
          while (v21 < v18);
        }
        heap_Free(*(void **)(*(void *)a1 + 8), v16);
        uint64_t *v17 = 0;
      }
      ++v4;
    }
    while (v4 < *(unsigned __int16 *)(a2 + 10));
  }
  if (*(void *)a2)
  {
    heap_Free(*(void **)(*(void *)a1 + 8), *(void *)a2);
    *(void *)a2 = 0;
  }
  return 0;
}

uint64_t stat_hmogrph_getSentenceData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  int v115 = 0;
  *(_DWORD *)uint64_t v116 = 0;
  uint64_t v114 = 0;
  unsigned int v112 = 0;
  int v113 = 0;
  int v111 = 0;
  __int16 v110 = 0;
  uint64_t v108 = 0;
  uint64_t v109 = 0;
  unint64_t v106 = 0;
  int v107 = 0;
  uint64_t v104 = 0;
  unsigned int v105 = 0;
  __s1 = 0;
  uint64_t v101 = 0;
  a5[1] = 0;
  uint64_t v10 = (uint64_t)(a5 + 1);
  *((_DWORD *)a5 + 4) = 0;
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, unsigned __int16 *))(a2 + 104))(a3, a4, 1, 0, &v116[1]);
  if ((v11 & 0x80000000) != 0)
  {
    uint64_t v12 = v11;
    goto LABEL_111;
  }
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, int *))(a2 + 184))(a3, a4, v116[1], 0, &v115);
  if ((v12 & 0x80000000) != 0
    || (unsigned __int16)v115 != 1
    || (uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, const char **, char *))(a2 + 176))(a3, a4, v116[1], 0, &v114, (char *)&v115 + 2), (v12 & 0x80000000) != 0)|| HIWORD(v115) < 2u)
  {
    if ((v12 & 0x80000000) != 0) {
      goto LABEL_111;
    }
    return v12;
  }
  log_OutText(*(void *)(*a5 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Stathmogrph: processing=\"%s\"", v13, v14, v15, (uint64_t)v114);
  uint64_t v16 = heap_Calloc(*(void **)(*a5 + 8), 1, 1024);
  if (!v16)
  {
    uint64_t v12 = 2314215434;
    log_OutPublic(*(void *)(*a5 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v17, v18, v19, v20, v85);
    goto LABEL_111;
  }
  uint64_t v21 = v16;
  __int16 v22 = strlen(v114);
  uint64_t v27 = (char *)heap_Calloc(*(void **)(*a5 + 8), 1, (unsigned __int16)(v22 + 1));
  if (!v27)
  {
    uint64_t v12 = 2314215434;
    log_OutPublic(*(void *)(*a5 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v23, v24, v25, v26, v85);
    uint64_t v96 = 0;
    int v28 = 0;
    int v98 = 0;
    int v99 = 0;
    goto LABEL_149;
  }
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, unsigned __int16 *))(a2 + 104))(a3, a4, 2, v116[1], v116);
  int v28 = 0;
  uint64_t v96 = 0;
  if ((v12 & 0x80000000) != 0)
  {
    int v98 = 0;
    int v99 = 0;
    goto LABEL_149;
  }
  unsigned __int16 v29 = v116[0];
  int v98 = 0;
  int v99 = 0;
  if (!v116[0]) {
    goto LABEL_149;
  }
  uint64_t v86 = v21;
  int v95 = 0;
  unsigned __int16 v89 = 0;
  int v28 = 0;
  int v98 = 0;
  int v99 = 0;
  while (1)
  {
    int v100 = 0;
    uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, unsigned int *, char *))(a2 + 168))(a3, a4, v29, 0, 1, &v112, (char *)&v115 + 2);
    if ((v30 & 0x80000000) != 0)
    {
      uint64_t v96 = 0;
      goto LABEL_121;
    }
    if (v112 > 0xA || ((1 << v112) & 0x610) == 0) {
      goto LABEL_104;
    }
    uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, char *))(a2 + 168))(a3, a4, v116[0], 1, 1, (char *)&v111 + 2, (char *)&v115 + 2);
    if ((v30 & 0x80000000) != 0
      || (uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, char *))(a2 + 168))(a3, a4, v116[0], 2, 1, &v111, (char *)&v115 + 2), (v30 & 0x80000000) != 0))
    {
LABEL_116:
      uint64_t v96 = 0;
      int v28 = 0;
LABEL_119:
      int v98 = 0;
      goto LABEL_120;
    }
    if (HIWORD(v111) > (unsigned __int16)v111)
    {
      uint64_t v96 = 0;
      int v28 = 0;
      int v98 = 0;
      int v99 = 0;
      unsigned __int16 v84 = 16049;
      goto LABEL_138;
    }
    strncpy(v27, &v114[HIWORD(v111)], (unsigned __int16)v111 - (unint64_t)HIWORD(v111));
    v27[(unsigned __int16)v111 - HIWORD(v111)] = 0;
    uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, int *))(a2 + 184))(a3, a4, v116[0], 14, &v115);
    if ((v30 & 0x80000000) != 0) {
      goto LABEL_116;
    }
    if ((unsigned __int16)v115 != 1) {
      goto LABEL_36;
    }
    uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, char *))(a2 + 176))(a3, a4, v116[0], 14, &v109, (char *)&v115 + 2);
    if ((v30 & 0x80000000) != 0) {
      goto LABEL_116;
    }
    hlp_NLUStrFind(v109, "POS", (uint64_t *)&v105, (unsigned __int16 *)&v113 + 1);
    int v32 = v109;
    if (strstr(v109, "POI"))
    {
      LOWORD(v113) = 0;
      hlp_NLUStrFind(v32, "S_POI", (uint64_t *)&v104, (unsigned __int16 *)&v113);
      int v33 = (unsigned __int16)v113;
      if (!(_WORD)v113)
      {
        hlp_NLUStrFind(v109, "I_POI", (uint64_t *)&v104, (unsigned __int16 *)&v113);
        int v33 = (unsigned __int16)v113;
        if (!(_WORD)v113)
        {
          hlp_NLUStrFind(v109, "E_POI", (uint64_t *)&v104, (unsigned __int16 *)&v113);
          int v33 = (unsigned __int16)v113;
        }
      }
      uint64_t v34 = v104;
      if (!v33) {
        uint64_t v34 = &byte_20D5A22AE;
      }
      uint64_t v104 = v34;
      if (v33) {
        __int16 v35 = 4;
      }
      else {
        __int16 v35 = 3;
      }
      unsigned __int16 v92 = v33 + v35 + 1;
      uint64_t v36 = (const char *)heap_Calloc(*(void **)(*a5 + 8), 1, v92);
      if (!v36)
      {
        uint64_t v96 = 0;
        int v28 = 0;
LABEL_135:
        int v98 = 0;
LABEL_136:
        int v99 = 0;
LABEL_137:
        unsigned __int16 v84 = 8202;
LABEL_138:
        uint64_t v12 = v84 | 0x89F00000;
        goto LABEL_139;
      }
      uint64_t v37 = (char *)v36;
      uint64_t v38 = v33 ? "_" : &byte_20D5A22AE;
      *uint64_t v36 = 0;
      *(_DWORD *)&v36[strlen(v36)] = 6909808;
      uint64_t v39 = strcat(v37, v38);
      strncat(v39, v104, (unsigned __int16)v113);
    }
    else
    {
LABEL_36:
      unsigned __int16 v92 = 0;
      uint64_t v37 = 0;
    }
    unsigned __int16 v91 = v105;
    if (v105)
    {
      int v28 = 0;
      if (v37) {
        goto LABEL_44;
      }
    }
    else
    {
      int v28 = 1;
      uint64_t v40 = (char *)heap_Calloc(*(void **)(*a5 + 8), 1, 2);
      unsigned int v105 = v40;
      if (!v40)
      {
        uint64_t v96 = v37;
        goto LABEL_135;
      }
      char *v40 = 61;
      v105[1] = 0;
      int v28 = 1;
      if (v37) {
        goto LABEL_44;
      }
    }
    uint64_t v41 = (char *)heap_Calloc(*(void **)(*a5 + 8), 1, 2);
    if (!v41)
    {
      uint64_t v96 = 0;
      goto LABEL_135;
    }
    uint64_t v37 = v41;
    LOWORD(v113) = 1;
    *(_WORD *)uint64_t v41 = 61;
LABEL_44:
    uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, const char **, char *))(*(void *)(a1 + 48)
                                                                                              + 176))(a3, a4, v116[0], 6, &v107, (char *)&v115 + 2);
    if ((v30 & 0x80000000) != 0
      || (uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, const char **, char *))(*(void *)(a1 + 48) + 176))(a3, a4, v116[0], 9, &v106, (char *)&v115 + 2), (v30 & 0x80000000) != 0)|| (uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, int *))(a2 + 184))(a3, a4, v116[0], 4, &v115), (v30 & 0x80000000) != 0)|| (unsigned __int16)v115 == 1&& (uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, char *))(a2 + 176))(a3, a4, v116[0],
                  4,
                  &v108,
                  (char *)&v115 + 2),
          (v30 & 0x80000000) != 0))
    {
      uint64_t v96 = v37;
      goto LABEL_119;
    }
    int v88 = v108;
    if (v108)
    {
      int v98 = 0;
    }
    else
    {
      uint64_t v42 = (char *)heap_Calloc(*(void **)(*a5 + 8), 1, 2);
      uint64_t v108 = v42;
      if (!v42)
      {
        int v98 = 1;
        uint64_t v96 = v37;
        goto LABEL_136;
      }
      char *v42 = 61;
      v108[1] = 0;
      int v98 = 1;
    }
    uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t *, char *))(a2 + 176))(a3, a4, v116[0], 5, &v101, (char *)&v115 + 2);
    if ((v30 & 0x80000000) != 0)
    {
      uint64_t v96 = v37;
LABEL_120:
      int v99 = 0;
LABEL_121:
      uint64_t v12 = v30;
LABEL_139:
      uint64_t v21 = v86;
      goto LABEL_147;
    }
    uint64_t v87 = v101;
    if (v101)
    {
      int v99 = 0;
    }
    else
    {
      uint64_t v43 = (unsigned char *)heap_Calloc(*(void **)(*a5 + 8), 1, 2);
      uint64_t v101 = (uint64_t)v43;
      if (!v43)
      {
        int v99 = 1;
        uint64_t v96 = v37;
        goto LABEL_137;
      }
      *uint64_t v43 = 61;
      *(unsigned char *)(v101 + 1) = 0;
      int v99 = 1;
    }
    if (*(_DWORD *)(a1 + 144) && v112 == 9 && utf8_IsChineseLetter(v27))
    {
      uint64_t v30 = hlp_merge_add(a1, a3, a4, a5, v114, v27, v108, v107, v106, v116[0], (const char *)v101, v37, v92);
      if ((v30 & 0x80000000) != 0)
      {
        uint64_t v96 = v37;
        goto LABEL_121;
      }
      goto LABEL_97;
    }
    long long __s = v27;
    uint64_t v44 = heap_Calloc(*(void **)(*a5 + 8), 1, 16);
    uint64_t v96 = v37;
    if (!v44)
    {
      log_OutPublic(*(void *)(*a5 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v45, v46, v47, v48, v85);
      uint64_t v21 = v86;
      uint64_t v12 = 2314215434;
      goto LABEL_147;
    }
    uint64_t v49 = v44;
    *(_DWORD *)(v44 + 8) = 655360;
    uint64_t v50 = heap_Calloc(*(void **)(*a5 + 8), 10, 32);
    *(void *)uint64_t v49 = v50;
    if (!v50)
    {
      uint64_t v60 = 0;
      unsigned __int16 v56 = v95;
      goto LABEL_143;
    }
    uint64_t v94 = a1;
    uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, char *))(a2 + 176))(a3, a4, v116[0], 3, &__s1, (char *)&v115 + 2);
    unsigned __int16 v56 = v95;
    if ((v55 & 0x80000000) != 0)
    {
      uint64_t v60 = 0;
LABEL_129:
      uint64_t v12 = v55;
      goto LABEL_144;
    }
    int v90 = v28;
    uint64_t v57 = __s1;
    if (strstr(__s1, "[SVOX]"))
    {
      v57 += 6;
      __s1 = v57;
    }
    size_t v58 = strlen(v57);
    unsigned int v59 = (char *)heap_Alloc(*(void *)(*a5 + 8), v58 + 1);
    uint64_t v60 = (uint64_t)v59;
    if (!v59)
    {
LABEL_117:
      int v28 = v90;
      goto LABEL_143;
    }
    strcpy(v59, __s1);
    unsigned __int16 v61 = strlen(__s1);
    int v28 = v90;
    if (v61 >= v89)
    {
      if ((unsigned __int16)(v61 + 1) <= 4u) {
        uint64_t v62 = 4;
      }
      else {
        uint64_t v62 = (unsigned __int16)(v61 + 1);
      }
      unsigned __int16 v89 = v62;
      uint64_t v63 = heap_Realloc(*(uint64_t **)(*a5 + 8), (uint64_t)v95, v62);
      if (!v63) {
        goto LABEL_143;
      }
      unsigned __int16 v56 = (char *)v63;
    }
    uint64_t v55 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, __int16 *, char *))(a2 + 168))(a3, a4, v116[0], 7, 1, &v110, (char *)&v115 + 2);
    if ((v55 & 0x80000000) != 0) {
      goto LABEL_129;
    }
    int v93 = (char *)v60;
    int v95 = v56;
    unsigned int v64 = 0;
    if (strlen(__s))
    {
      unsigned int NextUtf8Offset = 0;
      uint64_t v66 = (uint64_t)__s;
      a1 = v94;
      while ((utf8_getUTF8Char(v66, NextUtf8Offset, v102) & 0x80000000) == 0)
      {
        uint64_t v67 = *(unsigned __int16 *)(v49 + 10);
        unsigned __int16 v56 = v95;
        uint64_t v60 = (uint64_t)v93;
        if (*(unsigned __int16 *)(v49 + 8) >= v67)
        {
          uint64_t v68 = heap_Realloc(*(uint64_t **)(*a5 + 8), *(void *)v49, 32 * v67 + 320);
          if (!v68) {
            goto LABEL_117;
          }
          *(void *)uint64_t v49 = v68;
          *(_WORD *)(v49 + 10) += 10;
        }
        if (!hlp_getPhonFromPhonStr(__s, NextUtf8Offset, v93, v95, &v100)) {
          goto LABEL_89;
        }
        *(_DWORD *)(*(void *)v49 + 32 * *(unsigned __int16 *)(v49 + 8) + 8) = 65537;
        int v69 = (_WORD *)heap_Calloc(*(void **)(*a5 + 8), 1, 2);
        uint64_t v70 = *(void *)v49;
        *(void *)(*(void *)v49 + 32 * *(unsigned __int16 *)(v49 + 8) + 16) = v69;
        if (!v69) {
          goto LABEL_117;
        }
        *int v69 = v110;
        *(_WORD *)(v70 + 32 * *(unsigned __int16 *)(v49 + 8) + 24) = v110;
        uint64_t v71 = heap_Alloc(*(void *)(*a5 + 8), 8);
        *(void *)(*(void *)v49 + 32 * *(unsigned __int16 *)(v49 + 8)) = v71;
        if (!v71) {
          goto LABEL_117;
        }
        uint64_t v72 = strlen(v95) + 1;
        uint64_t v73 = heap_Alloc(*(void *)(*a5 + 8), v72);
        uint64_t v74 = 32 * *(unsigned __int16 *)(v49 + 8);
        **(void **)(*(void *)v49 + v74) = v73;
        uint64_t v75 = **(char ***)(*(void *)v49 + v74);
        if (!v75) {
          goto LABEL_142;
        }
        v64 += v72;
        strcpy(v75, v95);
        unsigned __int16 v76 = *(_WORD *)(v49 + 8) + 1;
        *(_WORD *)(v49 + 8) = v76;
        if (v100 == 1)
        {
          a1 = v94;
          goto LABEL_91;
        }
        uint64_t v66 = (uint64_t)__s;
        unsigned int NextUtf8Offset = utf8_GetNextUtf8Offset(__s, NextUtf8Offset);
        a1 = v94;
        if (NextUtf8Offset >= strlen(__s)) {
          break;
        }
      }
    }
    else
    {
LABEL_89:
      a1 = v94;
    }
    unsigned __int16 v76 = *(_WORD *)(v49 + 8);
LABEL_91:
    if (v76)
    {
      int v77 = strlen(__s1);
      if (v64 < v77 + 1) {
        break;
      }
    }
LABEL_95:
    uint64_t v37 = (char *)v96;
    uint64_t v82 = hlp_addWord(*a5, __s, HIWORD(v111), (unsigned __int16)v111, v105, v108, v96, v92, (const char *)v101, (uint64_t *)v49, v107, v106, v10);
    stat_hmogrph_freeCandidatePhons((void *)*a5, v49);
    heap_Free(*(void **)(*a5 + 8), v49);
    heap_Free(*(void **)(*a5 + 8), (uint64_t)v93);
    if ((v82 & 0x80000000) != 0)
    {
      uint64_t v12 = v82;
      uint64_t v21 = v86;
      uint64_t v27 = __s;
      int v28 = v90;
      goto LABEL_147;
    }
    uint64_t v27 = __s;
    int v28 = v90;
LABEL_97:
    if (!v91)
    {
      heap_Free(*(void **)(*a5 + 8), (uint64_t)v105);
      unsigned int v105 = 0;
    }
    heap_Free(*(void **)(*a5 + 8), (uint64_t)v37);
    if (!v88)
    {
      heap_Free(*(void **)(*a5 + 8), (uint64_t)v108);
      uint64_t v108 = 0;
    }
    if (v87)
    {
      int v99 = 0;
    }
    else
    {
      heap_Free(*(void **)(*a5 + 8), v101);
      uint64_t v101 = 0;
      int v99 = 1;
    }
LABEL_104:
    uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, void, unsigned __int16 *))(a2 + 120))(a3, a4, v116[0], v116);
    if ((v12 & 0x80000000) == 0)
    {
      unsigned __int16 v29 = v116[0];
      if (v116[0]) {
        continue;
      }
    }
    uint64_t v96 = 0;
    goto LABEL_139;
  }
  uint64_t v78 = **(const char ***)(*(void *)v49 + 32 * (v76 - 1));
  int v79 = strlen(v78);
  uint64_t v80 = heap_Realloc(*(uint64_t **)(*a5 + 8), (uint64_t)v78, v77 - v64 + v79 + 2);
  if (v80)
  {
    uint64_t v81 = 32 * *(unsigned __int16 *)(v49 + 8) - 32;
    **(void **)(*(void *)v49 + v81) = v80;
    strcat(**(char ***)(*(void *)v49 + v81), &__s1[v64 - 1]);
    goto LABEL_95;
  }
  unsigned __int16 v56 = v95;
LABEL_142:
  int v28 = v90;
  uint64_t v60 = (uint64_t)v93;
LABEL_143:
  log_OutPublic(*(void *)(*a5 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v51, v52, v53, v54, v85);
  uint64_t v12 = 2314215434;
LABEL_144:
  int v95 = v56;
  stat_hmogrph_freeCandidatePhons((void *)*a5, v49);
  heap_Free(*(void **)(*a5 + 8), v49);
  if (v60) {
    heap_Free(*(void **)(*a5 + 8), v60);
  }
  uint64_t v21 = v86;
  uint64_t v27 = __s;
LABEL_147:
  if (v95) {
    heap_Free(*(void **)(*a5 + 8), (uint64_t)v95);
  }
LABEL_149:
  heap_Free(*(void **)(*a5 + 8), v21);
  if (v27) {
    heap_Free(*(void **)(*a5 + 8), (uint64_t)v27);
  }
  if ((v12 & 0x80000000) != 0)
  {
    if (v28 == 1)
    {
      heap_Free(*(void **)(*a5 + 8), (uint64_t)v105);
      unsigned int v105 = 0;
    }
    if (v96) {
      heap_Free(*(void **)(*a5 + 8), (uint64_t)v96);
    }
    if (v98 == 1)
    {
      heap_Free(*(void **)(*a5 + 8), (uint64_t)v108);
      uint64_t v108 = 0;
    }
    if (v99 == 1)
    {
      heap_Free(*(void **)(*a5 + 8), v101);
      uint64_t v101 = 0;
    }
LABEL_111:
    stat_hmogrph_freeSentenceData((unsigned __int16 *)a5);
  }
  return v12;
}

uint64_t hlp_getPhonFromPhonStr(char *a1, unsigned int a2, char *a3, char *a4, _DWORD *a5)
{
  uint64_t result = 0;
  unsigned int v13 = a2;
  if (a4 && a5)
  {
    __int16 v12 = 0;
    *a5 = 0;
    if (utf8_Utf8CharTo16bit((unsigned __int8 *)a1, (uint64_t)&v12)
      && (unsigned __int16)((unsigned __int16)(v12 + 24576) >> 9) <= 0x56u)
    {
      strcpy(a4, a3);
      uint64_t result = 1;
      *a5 = 1;
    }
    else
    {
      utf8_GetPreviousValidUtf8Offset((uint64_t)a1, &v13);
      if (v13)
      {
        unsigned int NextUtf8Offset = 0;
        while (1)
        {
          unsigned int NextUtf8Offset = utf8_GetNextUtf8Offset(a1, NextUtf8Offset);
          uint64_t result = (uint64_t)strchr(a3, 46);
          if (!result) {
            break;
          }
          if (*(unsigned char *)result == 46) {
            a3 = (char *)(result + 1);
          }
          else {
            a3 = (char *)result;
          }
          if (NextUtf8Offset == v13) {
            goto LABEL_13;
          }
        }
      }
      else
      {
LABEL_13:
        for (unsigned int NextUtf8Offset = 0; ; ++NextUtf8Offset)
        {
          int v11 = a3[NextUtf8Offset];
          if (!a3[NextUtf8Offset] || v11 == 46) {
            break;
          }
          a4[NextUtf8Offset] = v11;
          if (NextUtf8Offset && v11 == 125 && a4[NextUtf8Offset - 1] - 48 <= 9)
          {
            a3[NextUtf8Offset++] = 46;
            break;
          }
        }
        uint64_t result = 1;
      }
      a4[NextUtf8Offset] = 0;
    }
  }
  return result;
}

uint64_t stat_hmogrph_freeSentenceData(unsigned __int16 *a1)
{
  if (a1)
  {
    size_t v2 = (uint64_t *)(a1 + 4);
    if (a1[8])
    {
      unint64_t v3 = 0;
      do
      {
        uint64_t v4 = *v2;
        uint64_t v5 = (uint64_t *)(*v2 + (v3 << 6));
        if (*v5)
        {
          heap_Free(*(void **)(*(void *)a1 + 8), *v5);
          *uint64_t v5 = 0;
        }
        uint64_t v8 = v5[2];
        uint64_t v7 = v5 + 2;
        uint64_t v6 = v8;
        if (v8)
        {
          heap_Free(*(void **)(*(void *)a1 + 8), v6);
          *uint64_t v7 = 0;
        }
        unint64_t v9 = v4 + (v3 << 6);
        uint64_t v10 = *(void *)(v9 + 24);
        if (v10)
        {
          heap_Free(*(void **)(*(void *)a1 + 8), v10);
          *(void *)(v9 + 24) = 0;
        }
        uint64_t v13 = *(void *)(v9 + 40);
        __int16 v12 = (void *)(v9 + 40);
        uint64_t v11 = v13;
        if (v13)
        {
          heap_Free(*(void **)(*(void *)a1 + 8), v11);
          *__int16 v12 = 0;
        }
        unint64_t v14 = v4 + (v3 << 6);
        uint64_t v16 = (uint64_t *)(v14 + 48);
        uint64_t v15 = *(void *)(v14 + 48);
        if (v15)
        {
          int v19 = *(unsigned __int16 *)(v14 + 56);
          uint64_t v18 = (unsigned __int16 *)(v14 + 56);
          unsigned __int16 v17 = v19;
          if (v19)
          {
            unint64_t v20 = 0;
            do
            {
              uint64_t v21 = *(void *)(v15 + 16 * v20);
              if (v21)
              {
                if (*(_WORD *)(v15 + 16 * v20 + 8))
                {
                  uint64_t v22 = 0;
                  unint64_t v23 = 0;
                  do
                  {
                    uint64_t v24 = *(void *)(v21 + v22);
                    if (v24)
                    {
                      heap_Free(*(void **)(*(void *)a1 + 8), v24);
                      uint64_t v15 = *v16;
                      uint64_t v21 = *(void *)(*v16 + 16 * v20);
                      *(void *)(v21 + v22) = 0;
                    }
                    uint64_t v25 = *(void *)(v21 + v22 + 16);
                    if (v25)
                    {
                      heap_Free(*(void **)(*(void *)a1 + 8), v25);
                      uint64_t v15 = *v16;
                      uint64_t v21 = *(void *)(*v16 + 16 * v20);
                      *(void *)(v21 + v22 + 16) = 0;
                    }
                    uint64_t v26 = *(void *)(v21 + v22 + 24);
                    if (v26)
                    {
                      heap_Free(*(void **)(*(void *)a1 + 8), v26);
                      uint64_t v15 = *v16;
                      uint64_t v21 = *(void *)(*v16 + 16 * v20);
                      *(void *)(v21 + v22 + 24) = 0;
                    }
                    uint64_t v27 = *(void *)(v21 + v22 + 32);
                    if (v27)
                    {
                      heap_Free(*(void **)(*(void *)a1 + 8), v27);
                      uint64_t v15 = *v16;
                      uint64_t v21 = *(void *)(*v16 + 16 * v20);
                      *(void *)(v21 + v22 + 32) = 0;
                    }
                    uint64_t v28 = *(void *)(v21 + v22 + 40);
                    if (v28)
                    {
                      heap_Free(*(void **)(*(void *)a1 + 8), v28);
                      uint64_t v15 = *v16;
                      uint64_t v21 = *(void *)(*v16 + 16 * v20);
                      *(void *)(v21 + v22 + 40) = 0;
                    }
                    ++v23;
                    v22 += 56;
                  }
                  while (v23 < *(unsigned __int16 *)(v15 + 16 * v20 + 8));
                }
                heap_Free(*(void **)(*(void *)a1 + 8), v21);
                uint64_t v15 = *v16;
                *(void *)(*v16 + 16 * v20) = 0;
                unsigned __int16 v17 = *v18;
              }
              ++v20;
            }
            while (v20 < v17);
          }
          heap_Free(*(void **)(*(void *)a1 + 8), v15);
          *uint64_t v16 = 0;
        }
        ++v3;
      }
      while (v3 < a1[8]);
    }
    if (*v2) {
      heap_Free(*(void **)(*(void *)a1 + 8), *v2);
    }
    *size_t v2 = 0;
    v2[1] = 0;
  }
  return 0;
}

uint64_t hlp_initFeatureVector(uint64_t a1, void *a2, unsigned int a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t v5 = a3;
  while (1)
  {
    uint64_t v6 = (_WORD *)heap_Calloc(*(void **)(a1 + 8), 1, 65);
    *a2 = v6;
    if (!v6) {
      break;
    }
    *uint64_t v6 = 61;
    ++a2;
    if (!--v5) {
      return 0;
    }
  }
  log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v7, v8, v9, v10, v12);
  return 2314215434;
}

uint64_t hlp_isFeatureRequired(uint64_t a1, unsigned int a2, int a3, _WORD *a4)
{
  if (a2 < 2) {
    return 0;
  }
  uint64_t v6 = 0;
  uint64_t v7 = a2 - 1;
  uint64_t v8 = g_featureNames[a3];
  while (strcmp(*(const char **)(a1 + 8 * v6), v8))
  {
    if (v7 == ++v6) {
      return 0;
    }
  }
  *a4 = v6;
  return 1;
}

uint64_t hlp_setFeature(uint64_t a1, uint64_t a2, unsigned int a3, int a4, uint64_t a5, const char *a6)
{
  unsigned __int16 v18 = -1;
  uint64_t result = hlp_isFeatureRequired(a2, a3, a4, &v18);
  if (result)
  {
    if (!*a6)
    {
      uint64_t result = 0;
      **(_WORD **)(a5 + 8 * v18) = 61;
      return result;
    }
    size_t v10 = strlen(a6);
    uint64_t v11 = v18;
    if (v10 <= 0x40)
    {
      unsigned int v12 = *(char **)(a5 + 8 * v18);
      goto LABEL_8;
    }
    unsigned int v12 = (char *)heap_Realloc(*(uint64_t **)(a1 + 8), *(void *)(a5 + 8 * v18), (v10 + 1));
    if (v12)
    {
      *(void *)(a5 + 8 * v11) = v12;
LABEL_8:
      strcpy(v12, a6);
      return 0;
    }
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v13, v14, v15, v16, v17);
    return 2314215434;
  }
  return result;
}

uint64_t hlp_wordStrLowerCase(char *a1, char *a2)
{
  *(_DWORD *)&__s[3] = 0;
  *(_DWORD *)long long __s = 0;
  *a2 = 0;
  if ((utf8_getUTF8Char((uint64_t)a1, 0, __s) & 0x80000000) == 0)
  {
    unsigned int NextUtf8Offset = 0;
    do
    {
      if (strlen(a1) <= NextUtf8Offset) {
        break;
      }
      if (strlen(__s) == 1 && __s[0] >= 0x41u && __s[0] <= 0x5Au) {
        a2[NextUtf8Offset] = __s[0] + 32;
      }
      else {
        strcat(a2, __s);
      }
      unsigned int NextUtf8Offset = utf8_GetNextUtf8Offset(a1, NextUtf8Offset);
    }
    while ((utf8_getUTF8Char((uint64_t)a1, NextUtf8Offset, __s) & 0x80000000) == 0);
  }
  return 0;
}

uint64_t feat_character(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5, const char *a6, char *a7)
{
  uint64_t v11 = *(const char ***)a2;
  uint64_t v12 = a3;
  int v13 = strlen(*(const char **)(*(void *)a2 + ((unint64_t)a3 << 6)));
  uint64_t v37 = v12;
  int v14 = 0;
  if (a3)
  {
    uint64_t v15 = v11;
    do
    {
      uint64_t v16 = *v15;
      v15 += 8;
      v14 += strlen(v16);
      --v12;
    }
    while (v12);
  }
  unsigned int v17 = *(unsigned __int16 *)(a2 + 8);
  if (v17 <= (unsigned __int16)(a3 + 1))
  {
    int v18 = 0;
  }
  else
  {
    int v18 = 0;
    uint64_t v19 = (unsigned __int16)(a3 + 1);
    unint64_t v20 = &v11[8 * v19];
    uint64_t v21 = v19 + 1;
    do
    {
      uint64_t v22 = *v20;
      v20 += 8;
      v18 += strlen(v22);
      BOOL v23 = v17 == (unsigned __int16)v21++;
    }
    while (!v23);
  }
  uint64_t v24 = heap_Calloc(*(void **)(a1 + 8), 1, (v13 + v14 + v18 + 1));
  if (!v24)
  {
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v25, v26, v27, v28, v37);
    return 2314215434;
  }
  unsigned __int16 v29 = (char *)v24;
  if (!*(_WORD *)(a2 + 8)) {
    goto LABEL_27;
  }
  uint64_t v30 = 0;
  unint64_t v31 = 0;
  unsigned int NextUtf8Offset = v14 + a4;
  do
  {
    strcat(v29, *(const char **)(*(void *)a2 + v30));
    ++v31;
    unint64_t v33 = *(unsigned __int16 *)(a2 + 8);
    v30 += 64;
  }
  while (v31 < v33);
  if (v33 <= a3 || strlen(*(const char **)(*(void *)a2 + (v37 << 6))) <= a4) {
    goto LABEL_27;
  }
  if (a5 < 0)
  {
    if (!NextUtf8Offset) {
      goto LABEL_27;
    }
    do
    {
      unsigned int PreviousUtf8Offset = utf8_GetPreviousUtf8Offset((uint64_t)v29, NextUtf8Offset);
      unsigned int NextUtf8Offset = PreviousUtf8Offset;
      BOOL v23 = (unsigned __int16)~(_WORD)a5 == 0;
      LOWORD(a5) = a5 + 1;
    }
    while (!v23 && PreviousUtf8Offset);
    if ((_WORD)a5) {
      goto LABEL_27;
    }
  }
  else if (a5)
  {
    while (NextUtf8Offset != strlen(v29))
    {
      unsigned int NextUtf8Offset = utf8_GetNextUtf8Offset(v29, NextUtf8Offset);
      int v34 = (__int16)a5--;
      if (v34 <= 1) {
        goto LABEL_26;
      }
    }
    goto LABEL_27;
  }
LABEL_26:
  if ((utf8_getUTF8Char((uint64_t)v29, NextUtf8Offset, a7) & 0x80000000) != 0) {
LABEL_27:
  }
    strcpy(a7, a6);
  heap_Free(*(void **)(a1 + 8), (uint64_t)v29);
  return 0;
}

uint64_t feat_colloc(unsigned __int16 *a1, unsigned int a2, char *__s1)
{
  unsigned int v4 = a2;
  if (a2)
  {
    uint64_t v6 = *(void *)a1;
    if (!strcmp(__s1, *(const char **)(*(void *)a1 + 40)))
    {
      uint64_t v12 = 76;
      uint64_t v13 = 66;
    }
    else
    {
      uint64_t v7 = (const char **)(v6 + 104);
      uint64_t v8 = 1;
      while (1)
      {
        unint64_t v9 = v8;
        if (v4 == v8) {
          break;
        }
        size_t v10 = *v7;
        v7 += 8;
        int v11 = strcmp(__s1, v10);
        uint64_t v8 = v9 + 1;
        if (!v11)
        {
          uint64_t v12 = 76;
          goto LABEL_10;
        }
      }
      uint64_t v12 = 78;
LABEL_10:
      if (v9 >= v4) {
        uint64_t v13 = 82;
      }
      else {
        uint64_t v13 = 66;
      }
    }
  }
  else
  {
    uint64_t v12 = 78;
    uint64_t v13 = 82;
  }
  unsigned int v14 = a1[4];
  while (1)
  {
    LOWORD(v4) = v4 + 1;
    if (v14 <= (unsigned __int16)v4) {
      break;
    }
    if (!strcmp(__s1, *(const char **)(*(void *)a1 + ((unint64_t)(unsigned __int16)v4 << 6) + 40))) {
      return v13;
    }
  }
  return v12;
}

char *feat_wordbeg(uint64_t a1, int a2, int a3, char *__src, char *__dst)
{
  uint64_t v5 = (a3 + a2);
  if (a3 + a2 < 0 || v5 >= *(unsigned __int16 *)(a1 + 8)) {
    return strcpy(__dst, __src);
  }
  else {
    return (char *)utf8_getUTF8Char(*(void *)(*(void *)a1 + (v5 << 6) + 40), 0, __dst);
  }
}

char *feat_wordend(uint64_t a1, int a2, int a3, char *__src, char *__dst)
{
  uint64_t v6 = (a3 + a2);
  if (a3 + a2 < 0 || v6 >= *(unsigned __int16 *)(a1 + 8))
  {
    return strcpy(__dst, __src);
  }
  else
  {
    uint64_t v7 = *(char **)(*(void *)a1 + (v6 << 6) + 40);
    unsigned int v8 = strlen(v7);
    return utf8_GetUtf8Symbol(v7, v8 - 1, v8, __dst);
  }
}

char *feat_wordlc(uint64_t a1, int a2, int a3, char *__src, char *__dst)
{
  char *__dst = 0;
  uint64_t v5 = (a3 + a2);
  if (a3 + a2 < 0 || v5 >= *(unsigned __int16 *)(a1 + 8)) {
    return strcpy(__dst, __src);
  }
  else {
    return (char *)hlp_wordStrLowerCase(*(char **)(*(void *)a1 + (v5 << 6) + 40), __dst);
  }
}

char *feat_wordlen(uint64_t a1, int a2, int a3, char *__src, char *__dst)
{
  char *__dst = 0;
  uint64_t v6 = (a3 + a2);
  if (a3 + a2 < 0 || v6 >= *(unsigned __int16 *)(a1 + 8))
  {
    return strcpy(__dst, __src);
  }
  else
  {
    int v7 = Utf8_Utf8NbrOfSymbols(*(const char **)(*(void *)a1 + (v6 << 6) + 40));
    return (char *)sprintf(__dst, "%d", v7 - 1);
  }
}

uint64_t feat_pos(uint64_t a1, int a2, int a3, uint64_t a4)
{
  __int16 v8 = a3 + a2;
  if (a3 <= 0) {
    __int16 v9 = a3 + a2;
  }
  else {
    __int16 v9 = a2;
  }
  LOWORD(v10) = v9;
  if (a3 <= 0) {
    __int16 v8 = a2;
  }
  __int16 v11 = v8 - 1;
  if (v9 > v11)
  {
LABEL_12:
    uint64_t v13 = (a3 + a2);
    if (a3 + a2 >= 0 && v13 < *(unsigned __int16 *)(a1 + 8)) {
      return *(void *)(*(void *)a1 + (v13 << 6) + 16);
    }
  }
  else
  {
    int v12 = v11;
    while ((v10 & 0x8000) != 0
         || *(unsigned __int16 *)(a1 + 8) <= (unsigned __int16)v10
         || !hlp_doesWordEndInComma(*(const char **)(*(void *)a1 + ((unint64_t)(unsigned __int16)v10 << 6))))
    {
      int v10 = (__int16)(v10 + 1);
      if (v10 > v12) {
        goto LABEL_12;
      }
    }
  }
  return a4;
}

uint64_t feat_matchprevpos(uint64_t *a1, int a2, char *__s2, uint64_t a4)
{
  if (a2)
  {
    uint64_t v6 = *a1;
    int v7 = a2;
    while (1)
    {
      uint64_t v8 = v6 + ((unint64_t)(v7 - 1) << 6);
      if (!strcmp(*(const char **)(v8 + 16), __s2)) {
        break;
      }
      if (!(_WORD)--v7) {
        return a4;
      }
    }
    return *(void *)(v8 + 40);
  }
  return a4;
}

uint64_t feat_matchnextpos(uint64_t a1, unsigned __int16 a2, char *__s2, uint64_t a4)
{
  unsigned int v8 = *(unsigned __int16 *)(a1 + 8);
  while (v8 > ++a2)
  {
    unint64_t v9 = *(void *)a1 + ((unint64_t)a2 << 6);
    if (!strcmp(*(const char **)(v9 + 16), __s2)) {
      return *(void *)(v9 + 40);
    }
  }
  return a4;
}

uint64_t feat_mosyntpos(uint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t v4 = (a3 + a2);
  if (a3 + a2 >= 0 && v4 < *(unsigned __int16 *)(a1 + 8))
  {
    uint64_t v5 = *(void *)a1 + (v4 << 6);
    uint64_t v6 = *(unsigned __int16 *)(v5 + 56);
    if (*(_WORD *)(v5 + 56))
    {
      for (uint64_t i = (_WORD *)(*(void *)(v5 + 48) + 8); *i != 1; i += 8)
      {
        if (!--v6) {
          return a4;
        }
      }
      return *(void *)(*((void *)i - 1) + 16);
    }
  }
  return a4;
}

uint64_t hlp_setFeatureVector(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned __int16 *a5, unsigned int a6, unsigned int a7, char **a8, unsigned __int16 a9, uint64_t a10)
{
  __int16 v133 = 0;
  uint64_t v18 = heap_Calloc(*(void **)(a1 + 8), 1, 2048);
  if (v18)
  {
    BOOL v23 = (char *)v18;
    unsigned int v131 = a6;
    unsigned int v132 = a7;
    uint64_t v130 = a8;
    if (a4 < 2)
    {
      uint64_t v26 = 0;
LABEL_9:
      if (!hlp_isFeatureRequired(a3, a4, 11, &v133)
        || (!a6 || (uint64_t v27 = a6 - 1, v27 >= a5[4])
          ? (uint64_t v28 = "=")
          : (uint64_t v28 = *(const char **)(*(void *)a5 + (v27 << 6) + 40)),
            uint64_t v26 = hlp_setFeature(a1, a3, a4, 11, a2, v28),
            (v26 & 0x80000000) == 0))
      {
        if (!hlp_isFeatureRequired(a3, a4, 10, &v133)
          || ((uint64_t v35 = a6 - 2, a6 < 2) || v35 >= a5[4]
            ? (uint64_t v36 = "=")
            : (uint64_t v36 = *(const char **)(*(void *)a5 + (v35 << 6) + 40)),
              uint64_t v26 = hlp_setFeature(a1, a3, a4, 10, a2, v36),
              (v26 & 0x80000000) == 0))
        {
          if (!hlp_isFeatureRequired(a3, a4, 9, &v133)
            || ((uint64_t v37 = a6 - 3, a6 < 3) || v37 >= a5[4]
              ? (uint64_t v38 = "=")
              : (uint64_t v38 = *(const char **)(*(void *)a5 + (v37 << 6) + 40)),
                uint64_t v26 = hlp_setFeature(a1, a3, a4, 9, a2, v38),
                (v26 & 0x80000000) == 0))
          {
            if (!hlp_isFeatureRequired(a3, a4, 8, &v133)
              || ((uint64_t v39 = a6 - 4, a6 < 4) || v39 >= a5[4]
                ? (uint64_t v40 = "=")
                : (uint64_t v40 = *(const char **)(*(void *)a5 + (v39 << 6) + 40)),
                  uint64_t v26 = hlp_setFeature(a1, a3, a4, 8, a2, v40),
                  (v26 & 0x80000000) == 0))
            {
              if (!hlp_isFeatureRequired(a3, a4, 7, &v133)
                || ((uint64_t v41 = a6 - 5, a6 < 5) || v41 >= a5[4]
                  ? (uint64_t v42 = "=")
                  : (uint64_t v42 = *(const char **)(*(void *)a5 + (v41 << 6) + 40)),
                    uint64_t v26 = hlp_setFeature(a1, a3, a4, 7, a2, v42),
                    (v26 & 0x80000000) == 0))
              {
                if (!hlp_isFeatureRequired(a3, a4, 15, &v133)
                  || ((uint64_t v50 = a6 + 1, v50 >= a5[4])
                    ? (uint64_t v51 = "=")
                    : (uint64_t v51 = *(const char **)(*(void *)a5 + (v50 << 6) + 40)),
                      uint64_t v26 = hlp_setFeature(a1, a3, a4, 15, a2, v51),
                      (v26 & 0x80000000) == 0))
                {
                  if (!hlp_isFeatureRequired(a3, a4, 16, &v133)
                    || ((uint64_t v64 = a6 + 2, v64 >= a5[4])
                      ? (uint64_t v65 = "=")
                      : (uint64_t v65 = *(const char **)(*(void *)a5 + (v64 << 6) + 40)),
                        uint64_t v26 = hlp_setFeature(a1, a3, a4, 16, a2, v65),
                        (v26 & 0x80000000) == 0))
                  {
                    if (!hlp_isFeatureRequired(a3, a4, 17, &v133)
                      || ((uint64_t v72 = a6 + 3, v72 >= a5[4])
                        ? (uint64_t v73 = "=")
                        : (uint64_t v73 = *(const char **)(*(void *)a5 + (v72 << 6) + 40)),
                          uint64_t v26 = hlp_setFeature(a1, a3, a4, 17, a2, v73),
                          (v26 & 0x80000000) == 0))
                    {
                      if (!hlp_isFeatureRequired(a3, a4, 18, &v133)
                        || ((uint64_t v80 = a6 + 4, v80 >= a5[4])
                          ? (uint64_t v81 = "=")
                          : (uint64_t v81 = *(const char **)(*(void *)a5 + (v80 << 6) + 40)),
                            uint64_t v26 = hlp_setFeature(a1, a3, a4, 18, a2, v81),
                            (v26 & 0x80000000) == 0))
                      {
                        if (!hlp_isFeatureRequired(a3, a4, 19, &v133)
                          || ((uint64_t v88 = a6 + 5, v88 >= a5[4])
                            ? (unsigned __int16 v89 = "=")
                            : (unsigned __int16 v89 = *(const char **)(*(void *)a5 + (v88 << 6) + 40)),
                              uint64_t v26 = hlp_setFeature(a1, a3, a4, 19, a2, v89),
                              (v26 & 0x80000000) == 0))
                        {
                          if (!hlp_isFeatureRequired(a3, a4, 23, &v133)
                            || (unsigned __int16 v92 = (const char *)feat_pos((uint64_t)a5, a6, 0, (uint64_t)"="),
                                uint64_t v26 = hlp_setFeature(a1, a3, a4, 23, a2, v92),
                                (v26 & 0x80000000) == 0))
                          {
                            if (!hlp_isFeatureRequired(a3, a4, 22, &v133)
                              || (int v93 = (const char *)feat_pos((uint64_t)a5, a6, -1, (uint64_t)"="),
                                  uint64_t v26 = hlp_setFeature(a1, a3, a4, 22, a2, v93),
                                  (v26 & 0x80000000) == 0))
                            {
                              if (!hlp_isFeatureRequired(a3, a4, 21, &v133)
                                || (uint64_t v94 = (const char *)feat_pos((uint64_t)a5, a6, -2, (uint64_t)"="),
                                    uint64_t v26 = hlp_setFeature(a1, a3, a4, 21, a2, v94),
                                    (v26 & 0x80000000) == 0))
                              {
                                if (!hlp_isFeatureRequired(a3, a4, 20, &v133)
                                  || (int v95 = (const char *)feat_pos((uint64_t)a5, a6, -3, (uint64_t)"="),
                                      uint64_t v26 = hlp_setFeature(a1, a3, a4, 20, a2, v95),
                                      (v26 & 0x80000000) == 0))
                                {
                                  if (!hlp_isFeatureRequired(a3, a4, 24, &v133)
                                    || (uint64_t v96 = (const char *)feat_pos((uint64_t)a5, a6, 1, (uint64_t)"="),
                                        uint64_t v26 = hlp_setFeature(a1, a3, a4, 24, a2, v96),
                                        (v26 & 0x80000000) == 0))
                                  {
                                    if (!hlp_isFeatureRequired(a3, a4, 25, &v133)
                                      || (uint64_t v97 = (const char *)feat_pos((uint64_t)a5, a6, 2, (uint64_t)"="),
                                          uint64_t v26 = hlp_setFeature(a1, a3, a4, 25, a2, v97),
                                          (v26 & 0x80000000) == 0))
                                    {
                                      if (!hlp_isFeatureRequired(a3, a4, 26, &v133)
                                        || (int v98 = (const char *)feat_pos((uint64_t)a5, a6, 3, (uint64_t)"="),
                                            uint64_t v26 = hlp_setFeature(a1, a3, a4, 26, a2, v98),
                                            (v26 & 0x80000000) == 0))
                                      {
                                        if (!hlp_isFeatureRequired(a3, a4, 27, &v133)
                                          || (int v99 = (const char *)feat_mosyntpos((uint64_t)a5, a6, -1, (uint64_t)"="),
                                              uint64_t v26 = hlp_setFeature(a1, a3, a4, 27, a2, v99),
                                              (v26 & 0x80000000) == 0))
                                        {
                                          if (!hlp_isFeatureRequired(a3, a4, 28, &v133)
                                            || (int v100 = (const char *)feat_mosyntpos((uint64_t)a5, a6, 1, (uint64_t)"="),
                                                uint64_t v26 = hlp_setFeature(a1, a3, a4, 28, a2, v100),
                                                (v26 & 0x80000000) == 0))
                                          {
                                            if (!hlp_isFeatureRequired(a3, a4, 29, &v133)
                                              || (v101 = (const char *)feat_matchprevpos((uint64_t *)a5, a6, "n", (uint64_t)"="), uint64_t v26 = hlp_setFeature(a1, a3, a4, 29, a2, v101), (v26 & 0x80000000) == 0))
                                            {
                                              if (!hlp_isFeatureRequired(a3, a4, 30, &v133)
                                                || (v102 = (const char *)feat_matchnextpos((uint64_t)a5, a6, "n", (uint64_t)"="), uint64_t v26 = hlp_setFeature(a1, a3, a4, 30, a2, v102), (v26 & 0x80000000) == 0))
                                              {
                                                if (!hlp_isFeatureRequired(a3, a4, 31, &v133)
                                                  || (v103 = (const char *)feat_matchprevpos((uint64_t *)a5, a6, "v", (uint64_t)"="), uint64_t v26 = hlp_setFeature(a1, a3, a4, 31, a2, v103), (v26 & 0x80000000) == 0))
                                                {
                                                  if (!hlp_isFeatureRequired(a3, a4, 32, &v133)
                                                    || (v104 = (const char *)feat_matchnextpos((uint64_t)a5, a6, "v", (uint64_t)"="), uint64_t v26 = hlp_setFeature(a1, a3, a4, 32, a2, v104), (v26 & 0x80000000) == 0))
                                                  {
                                                    if (!hlp_isFeatureRequired(a3, a4, 33, &v133)) {
                                                      goto LABEL_250;
                                                    }
                                                    *BOOL v23 = 0;
                                                    int v105 = 0xFFFF;
                                                    int v106 = a6;
                                                    do
                                                    {
                                                      size_t v107 = strlen(v23);
                                                      int v108 = (__int16)v105;
                                                      feat_wordlen((uint64_t)a5, v106, (__int16)v105++, "=", &v23[v107]);
                                                    }
                                                    while (v108 < 1);
                                                    uint64_t v26 = hlp_setFeature(a1, a3, a4, 33, a2, v23);
                                                    a6 = v106;
                                                    if ((v26 & 0x80000000) == 0)
                                                    {
LABEL_250:
                                                      if (!hlp_isFeatureRequired(a3, a4, 34, &v133)) {
                                                        goto LABEL_249;
                                                      }
                                                      *BOOL v23 = 0;
                                                      uint64_t v109 = v130;
                                                      if (a9)
                                                      {
                                                        for (uint64_t i = a9 - 1; ; --i)
                                                        {
                                                          unsigned __int16 v111 = strlen(v23);
                                                          char v112 = feat_colloc(a5, v131, *v109);
                                                          int v113 = &v23[v111];
                                                          *int v113 = v112;
                                                          v113[1] = 0;
                                                          if (!i) {
                                                            break;
                                                          }
                                                          ++v109;
                                                          if (*v23) {
                                                            *(_WORD *)&v23[strlen(v23)] = 32;
                                                          }
                                                        }
                                                      }
                                                      uint64_t v26 = hlp_setFeature(a1, a3, a4, 34, a2, v23);
                                                      a6 = v131;
                                                      if ((v26 & 0x80000000) == 0)
                                                      {
LABEL_249:
                                                        if (!hlp_isFeatureRequired(a3, a4, 35, &v133)
                                                          || (v132 + 1 < 2 ? (BOOL v116 = a6 == 0) : (BOOL v116 = 0),
                                                              !v116 ? (uint64_t v117 = "SI") : (uint64_t v117 = "SB"),
                                                              uint64_t v26 = hlp_setFeature(a1, a3, a4, 35, a2, v117),
                                                              (v26 & 0x80000000) == 0))
                                                        {
                                                          if (!hlp_isFeatureRequired(a3, a4, 38, &v133)
                                                            || (feat_wordbeg((uint64_t)a5, a6, 0, "=", v23),
                                                                uint64_t v26 = hlp_setFeature(a1, a3, a4, 38, a2, v23),
                                                                (v26 & 0x80000000) == 0))
                                                          {
                                                            if (!hlp_isFeatureRequired(a3, a4, 43, &v133)
                                                              || (feat_wordend((uint64_t)a5, a6, 0, "=", v23),
                                                                  uint64_t v26 = hlp_setFeature(a1, a3, a4, 43, a2, v23),
                                                                  (v26 & 0x80000000) == 0))
                                                            {
                                                              if (!hlp_isFeatureRequired(a3, a4, 37, &v133)|| (feat_wordbeg((uint64_t)a5, a6, -1, "=", v23), uint64_t v26 = hlp_setFeature(a1, a3, a4, 37, a2, v23), (v26 & 0x80000000) == 0))
                                                              {
                                                                if (!hlp_isFeatureRequired(a3, a4, 42, &v133)|| (feat_wordend((uint64_t)a5, a6, -1, "=", v23), uint64_t v26 = hlp_setFeature(a1, a3, a4, 42, a2, v23), (v26 & 0x80000000) == 0))
                                                                {
                                                                  if (!hlp_isFeatureRequired(a3, a4, 39, &v133)|| (feat_wordbeg((uint64_t)a5, a6, 1, "=", v23), uint64_t v26 = hlp_setFeature(a1, a3, a4, 39, a2, v23), (v26 & 0x80000000) == 0))
                                                                  {
                                                                    if (!hlp_isFeatureRequired(a3, a4, 44, &v133)|| (feat_wordend((uint64_t)a5, a6, 1, "=", v23), uint64_t v26 = hlp_setFeature(a1, a3, a4, 44, a2, v23), (v26 & 0x80000000) == 0))
                                                                    {
                                                                      if (!hlp_isFeatureRequired(a3, a4, 36, &v133)|| (feat_wordbeg((uint64_t)a5, a6, -2, "=", v23), uint64_t v26 = hlp_setFeature(a1, a3, a4, 36, a2, v23), (v26 & 0x80000000) == 0))
                                                                      {
                                                                        if (!hlp_isFeatureRequired(a3, a4, 41, &v133)|| (feat_wordend((uint64_t)a5, a6, -2, "=", v23), uint64_t v26 = hlp_setFeature(a1, a3, a4, 41, a2, v23), (v26 & 0x80000000) == 0))
                                                                        {
                                                                          if (!hlp_isFeatureRequired(a3, a4, 40, &v133)|| (feat_wordbeg((uint64_t)a5, a6, 2, "=", v23), uint64_t v26 = hlp_setFeature(a1, a3, a4, 40, a2, v23), (v26 & 0x80000000) == 0))
                                                                          {
                                                                            if (!hlp_isFeatureRequired(a3, a4, 45, &v133)|| (feat_wordend((uint64_t)a5, a6, 2, "=", v23), uint64_t v26 = hlp_setFeature(a1, a3, a4, 45, a2, v23), (v26 & 0x80000000) == 0))
                                                                            {
                                                                              if (!hlp_isFeatureRequired(a3, a4, 46, &v133)|| (uint64_t v26 = hlp_setFeature(a1, a3, a4, 46, a2, "="), (v26 & 0x80000000) == 0))
                                                                              {
                                                                                if (!hlp_isFeatureRequired(a3, a4, 47, &v133)
                                                                                  || (uint64_t v26 = hlp_setFeature(a1, a3, a4, 47, a2, "="), (v26 & 0x80000000) == 0))
                                                                                {
                                                                                  if (!hlp_isFeatureRequired(a3, a4, 48, &v133)
                                                                                    || (uint64_t v26 = hlp_setFeature(a1, a3, a4, 48, a2, "="), (v26 & 0x80000000) == 0))
                                                                                  {
                                                                                    if (!hlp_isFeatureRequired(a3, a4, 49, &v133)
                                                                                      || ((uint64_t v118 = *(void *)(a10 + 8)) == 0
                                                                                       || v131 - 2 >= *(unsigned __int16 *)(a10 + 16)
                                                                                        ? (uint64_t v119 = "=")
                                                                                        : (uint64_t v119 = (const char *)(v118 + 40 * (v131 - 2) + 30)),
                                                                                          uint64_t v26 = hlp_setFeature(a1, a3, a4, 49, a2, v119), (v26 & 0x80000000) == 0))
                                                                                    {
                                                                                      if (!hlp_isFeatureRequired(a3, a4, 50, &v133)
                                                                                        || ((uint64_t v120 = *(void *)(a10 + 8)) == 0
                                                                                         || v131 - 1 >= *(unsigned __int16 *)(a10 + 16)
                                                                                          ? (uint64_t v121 = "=")
                                                                                          : (uint64_t v121 = (const char *)(v120 + 40 * (v131 - 1) + 30)),
                                                                                            uint64_t v26 = hlp_setFeature(a1, a3, a4, 50, a2, v121), (v26 & 0x80000000) == 0))
                                                                                      {
                                                                                        if (!hlp_isFeatureRequired(a3, a4, 51, &v133)
                                                                                          || ((uint64_t v122 = *(void *)(a10 + 8)) == 0
                                                                                           || *(unsigned __int16 *)(a10 + 16) <= v131
                                                                                            ? (uint64_t v123 = "=")
                                                                                            : (uint64_t v123 = (const char *)(v122 + 40 * v131 + 30)),
                                                                                              uint64_t v26 = hlp_setFeature(a1, a3, a4, 51, a2, v123),
                                                                                              (v26 & 0x80000000) == 0))
                                                                                        {
                                                                                          if (!hlp_isFeatureRequired(a3, a4, 52, &v133)
                                                                                            || ((uint64_t v124 = *(void *)(a10 + 8)) == 0
                                                                                             || v131 + 1 >= *(unsigned __int16 *)(a10 + 16)
                                                                                              ? (uint64_t v125 = "=")
                                                                                              : (uint64_t v125 = (const char *)(v124 + 40 * (v131 + 1) + 30)),
                                                                                                uint64_t v26 = hlp_setFeature(a1, a3, a4, 52, a2, v125),
                                                                                                (v26 & 0x80000000) == 0))
                                                                                          {
                                                                                            if (hlp_isFeatureRequired(a3, a4, 53, &v133))
                                                                                            {
                                                                                              uint64_t v126 = *(void *)(a10 + 8);
                                                                                              if (v126
                                                                                                && v131 + 2 < *(unsigned __int16 *)(a10 + 16))
                                                                                              {
                                                                                                unsigned int v127 = (const char *)(v126 + 40 * (v131 + 2) + 30);
                                                                                              }
                                                                                              else
                                                                                              {
                                                                                                unsigned int v127 = "=";
                                                                                              }
                                                                                              uint64_t v31 = hlp_setFeature(a1, a3, a4, 53, a2, v127);
LABEL_244:
                                                                                              uint64_t v26 = v31;
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      uint64_t v24 = 0;
      uint64_t v25 = a4 - 1;
      while (strcmp(*(const char **)(a3 + 8 * v24), "char0"))
      {
        if (v25 == ++v24)
        {
          uint64_t v26 = 0;
LABEL_42:
          uint64_t v43 = a2;
          uint64_t v44 = 0;
          while (strcmp(*(const char **)(a3 + 8 * v44), "lchar"))
          {
            if (v25 == ++v44) {
              goto LABEL_56;
            }
          }
          __int16 v133 = v44;
          uint64_t v45 = "=";
          uint64_t v46 = a1;
          if (v132 == -1)
          {
            uint64_t v48 = a3;
            unsigned int v49 = a4;
            uint64_t v47 = v43;
          }
          else
          {
            uint64_t v31 = feat_character(a1, (uint64_t)a5, v131, v132, -1, "=", v23);
            if ((v31 & 0x80000000) != 0) {
              goto LABEL_244;
            }
            uint64_t v47 = v43;
            uint64_t v46 = a1;
            uint64_t v48 = a3;
            unsigned int v49 = a4;
            uint64_t v45 = v23;
          }
          uint64_t v26 = hlp_setFeature(v46, v48, v49, 3, v47, v45);
          if ((v26 & 0x80000000) == 0)
          {
LABEL_56:
            uint64_t v52 = 0;
            while (strcmp(*(const char **)(a3 + 8 * v52), "llchar"))
            {
              if (v25 == ++v52) {
                goto LABEL_65;
              }
            }
            __int16 v133 = v52;
            uint64_t v53 = "=";
            uint64_t v54 = a1;
            if (v132 == -1)
            {
              uint64_t v56 = a3;
              unsigned int v57 = a4;
              uint64_t v55 = v43;
            }
            else
            {
              uint64_t v31 = feat_character(a1, (uint64_t)a5, v131, v132, -2, "=", v23);
              if ((v31 & 0x80000000) != 0) {
                goto LABEL_244;
              }
              uint64_t v55 = v43;
              uint64_t v54 = a1;
              uint64_t v56 = a3;
              unsigned int v57 = a4;
              uint64_t v53 = v23;
            }
            uint64_t v26 = hlp_setFeature(v54, v56, v57, 2, v55, v53);
            if ((v26 & 0x80000000) == 0)
            {
LABEL_65:
              uint64_t v58 = 0;
              while (strcmp(*(const char **)(a3 + 8 * v58), "l3char"))
              {
                if (v25 == ++v58) {
                  goto LABEL_79;
                }
              }
              __int16 v133 = v58;
              unsigned int v59 = "=";
              uint64_t v60 = a1;
              if (v132 == -1)
              {
                uint64_t v62 = a3;
                unsigned int v63 = a4;
                uint64_t v61 = v43;
              }
              else
              {
                uint64_t v31 = feat_character(a1, (uint64_t)a5, v131, v132, -3, "=", v23);
                if ((v31 & 0x80000000) != 0) {
                  goto LABEL_244;
                }
                uint64_t v61 = v43;
                uint64_t v60 = a1;
                uint64_t v62 = a3;
                unsigned int v63 = a4;
                unsigned int v59 = v23;
              }
              uint64_t v26 = hlp_setFeature(v60, v62, v63, 1, v61, v59);
              if ((v26 & 0x80000000) == 0)
              {
LABEL_79:
                uint64_t v66 = 0;
                while (strcmp(*(const char **)(a3 + 8 * v66), "rchar"))
                {
                  if (v25 == ++v66) {
                    goto LABEL_93;
                  }
                }
                __int16 v133 = v66;
                uint64_t v67 = "=";
                uint64_t v68 = a1;
                if (v132 == -1)
                {
                  uint64_t v70 = a3;
                  unsigned int v71 = a4;
                  uint64_t v69 = v43;
                }
                else
                {
                  uint64_t v31 = feat_character(a1, (uint64_t)a5, v131, v132, 1, "=", v23);
                  if ((v31 & 0x80000000) != 0) {
                    goto LABEL_244;
                  }
                  uint64_t v69 = v43;
                  uint64_t v68 = a1;
                  uint64_t v70 = a3;
                  unsigned int v71 = a4;
                  uint64_t v67 = v23;
                }
                uint64_t v26 = hlp_setFeature(v68, v70, v71, 4, v69, v67);
                if ((v26 & 0x80000000) == 0)
                {
LABEL_93:
                  uint64_t v74 = 0;
                  while (strcmp(*(const char **)(a3 + 8 * v74), "rrchar"))
                  {
                    if (v25 == ++v74) {
                      goto LABEL_107;
                    }
                  }
                  __int16 v133 = v74;
                  uint64_t v75 = "=";
                  uint64_t v76 = a1;
                  if (v132 == -1)
                  {
                    uint64_t v78 = a3;
                    unsigned int v79 = a4;
                    uint64_t v77 = v43;
                  }
                  else
                  {
                    uint64_t v31 = feat_character(a1, (uint64_t)a5, v131, v132, 2, "=", v23);
                    if ((v31 & 0x80000000) != 0) {
                      goto LABEL_244;
                    }
                    uint64_t v77 = v43;
                    uint64_t v76 = a1;
                    uint64_t v78 = a3;
                    unsigned int v79 = a4;
                    uint64_t v75 = v23;
                  }
                  uint64_t v26 = hlp_setFeature(v76, v78, v79, 5, v77, v75);
                  if ((v26 & 0x80000000) == 0)
                  {
LABEL_107:
                    uint64_t v82 = 0;
                    while (strcmp(*(const char **)(a3 + 8 * v82), "r3char"))
                    {
                      if (v25 == ++v82) {
                        goto LABEL_121;
                      }
                    }
                    __int16 v133 = v82;
                    uint64_t v83 = "=";
                    uint64_t v84 = a1;
                    if (v132 == -1)
                    {
                      uint64_t v86 = a3;
                      unsigned int v87 = a4;
                      uint64_t v85 = v43;
                    }
                    else
                    {
                      uint64_t v31 = feat_character(a1, (uint64_t)a5, v131, v132, 3, "=", v23);
                      if ((v31 & 0x80000000) != 0) {
                        goto LABEL_244;
                      }
                      uint64_t v85 = v43;
                      uint64_t v84 = a1;
                      uint64_t v86 = a3;
                      unsigned int v87 = a4;
                      uint64_t v83 = v23;
                    }
                    uint64_t v26 = hlp_setFeature(v84, v86, v87, 6, v85, v83);
                    if ((v26 & 0x80000000) != 0) {
                      goto LABEL_245;
                    }
LABEL_121:
                    uint64_t v90 = 0;
                    while (strcmp(*(const char **)(a3 + 8 * v90), "word"))
                    {
                      if (v25 == ++v90) {
                        goto LABEL_168;
                      }
                    }
                    __int16 v133 = v90;
                    if (a5[4] <= v131) {
                      unsigned __int16 v91 = "=";
                    }
                    else {
                      unsigned __int16 v91 = *(const char **)(*(void *)a5 + ((unint64_t)v131 << 6) + 40);
                    }
                    uint64_t v26 = hlp_setFeature(a1, a3, a4, 12, v43, v91);
                    if ((v26 & 0x80000000) != 0) {
                      goto LABEL_245;
                    }
LABEL_168:
                    uint64_t v114 = 0;
                    while (strcmp(*(const char **)(a3 + 8 * v114), "wordnocase"))
                    {
                      if (v25 == ++v114) {
                        goto LABEL_173;
                      }
                    }
                    __int16 v133 = v114;
                    feat_wordlc((uint64_t)a5, v131, 0, "=", v23);
                    uint64_t v26 = hlp_setFeature(a1, a3, a4, 13, v43, v23);
                    if ((v26 & 0x80000000) != 0) {
                      goto LABEL_245;
                    }
LABEL_173:
                    uint64_t v115 = 0;
                    while (strcmp(*(const char **)(a3 + 8 * v115), "wordlen"))
                    {
                      if (v25 == ++v115)
                      {
                        a2 = v43;
                        a6 = v131;
                        goto LABEL_9;
                      }
                    }
                    __int16 v133 = v115;
                    a6 = v131;
                    feat_wordlen((uint64_t)a5, v131, 0, "=", v23);
                    a2 = v43;
                    uint64_t v26 = hlp_setFeature(a1, a3, a4, 14, v43, v23);
                    if ((v26 & 0x80000000) == 0) {
                      goto LABEL_9;
                    }
                    goto LABEL_245;
                  }
                  goto LABEL_245;
                }
                goto LABEL_245;
              }
              goto LABEL_245;
            }
            goto LABEL_245;
          }
          goto LABEL_245;
        }
      }
      __int16 v133 = v24;
      unsigned __int16 v29 = "=";
      uint64_t v30 = a1;
      if (v132 == -1)
      {
        uint64_t v32 = a3;
        unsigned int v33 = a4;
        uint64_t v34 = a2;
      }
      else
      {
        uint64_t v31 = feat_character(a1, (uint64_t)a5, v131, v132, 0, "=", v23);
        if ((v31 & 0x80000000) != 0) {
          goto LABEL_244;
        }
        uint64_t v30 = a1;
        uint64_t v32 = a3;
        unsigned int v33 = a4;
        uint64_t v34 = a2;
        unsigned __int16 v29 = v23;
      }
      uint64_t v26 = hlp_setFeature(v30, v32, v33, 0, v34, v29);
      if ((v26 & 0x80000000) == 0) {
        goto LABEL_42;
      }
    }
LABEL_245:
    heap_Free(*(void **)(a1 + 8), (uint64_t)v23);
  }
  else
  {
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v19, v20, v21, v22, v129);
    return 2314215434;
  }
  return v26;
}

uint64_t _hmgrph_param_split(uint64_t a1, const char *a2, uint64_t *a3, _DWORD *a4)
{
  do
    int v8 = *(unsigned __int8 *)a2++;
  while (v8 == 32);
  size_t v9 = strlen(a2 - 1);
  int v10 = v9;
  __int16 v11 = (unsigned __int8 *)&a2[v9 - 2];
  if (*v11 == 32)
  {
    do
    {
      *__int16 v11 = 0;
      size_t v12 = strlen(a2 - 1);
      __int16 v11 = (unsigned __int8 *)&a2[v12 - 2];
    }
    while (*v11 == 32);
    int v10 = v12;
  }
  unsigned int v13 = 0;
  uint64_t v14 = 0;
  *a4 = 0;
  if ((v10 + 1) > 1) {
    uint64_t v15 = (v10 + 1);
  }
  else {
    uint64_t v15 = 1;
  }
  do
  {
    if ((a2[v14 - 1] | 0x20) == 0x20) {
      *a4 = ++v13;
    }
    ++v14;
  }
  while (v15 != v14);
  uint64_t v16 = (void *)heap_Calloc(*(void **)(a1 + 8), 1, 8 * v13);
  *a3 = (uint64_t)v16;
  if (v16)
  {
    *uint64_t v16 = a2 - 1;
    if (v10)
    {
      uint64_t v21 = 0;
      int v22 = 0;
      do
      {
        BOOL v23 = (unsigned __int8 *)&a2[v21];
        if (a2[v21 - 1] == 32)
        {
          *(v23 - 1) = 0;
          ++v21;
          *(void *)(*a3 + 8 * ++v22) = v23;
        }
        else
        {
          ++v21;
        }
      }
      while (v21 != v10);
    }
    return 0;
  }
  else
  {
    uint64_t v24 = 2314215434;
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v17, v18, v19, v20, v26);
    if (*a3) {
      heap_Free(*(void **)(a1 + 8), *a3);
    }
  }
  return v24;
}

uint64_t _hmgrph_parse_params(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  *(void *)(a4 + 32) = 0;
  uint64_t v6 = (uint64_t *)(a4 + 32);
  uint64_t v7 = *(void *)(a4 + 16);
  *(void *)(v7 + 56) = 0;
  *(unsigned char *)(v7 + 64) = 0;
  *(_WORD *)(a4 + 40) = 0;
  if (a3)
  {
    uint64_t v8 = 2314215424;
    uint64_t v9 = a3;
    int v10 = (const char **)(a2 + 8);
    do
    {
      uint64_t v11 = *(void *)(a4 + 16);
      unsigned int v12 = *(unsigned __int8 *)(v11 + 64);
      unsigned int v23 = *(unsigned __int16 *)(a4 + 40);
      unsigned int v24 = v12;
      unsigned int v13 = *(v10 - 1);
      if (!strcmp(v13, "features"))
      {
        _hmgrph_param_split(a1, *v10, (uint64_t *)(v11 + 56), &v24);
        if (v24 > 0xFF) {
          return v8;
        }
        *(unsigned char *)(*(void *)(a4 + 16) + 64) = v24;
      }
      else if (!strcmp(v13, "collocations"))
      {
        _hmgrph_param_split(a1, *v10, v6, &v23);
        if (HIWORD(v23)) {
          return v8;
        }
        *(_WORD *)(a4 + 40) = v23;
      }
      v10 += 2;
      --v9;
    }
    while (v9);
  }
  else
  {
    *(unsigned char *)(v7 + 64) = 29;
    uint64_t v14 = heap_Calloc(*(void **)(a1 + 8), 1, 232);
    uint64_t v19 = *(void *)(a4 + 16);
    *(void *)(v19 + 56) = v14;
    if (!v14)
    {
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v15, v16, v17, v18, v22);
      return 2314215434;
    }
    if (*(unsigned char *)(v19 + 64))
    {
      unint64_t v20 = 0;
      do
      {
        *(void *)(*(void *)(v19 + 56) + 8 * v20) = off_2641081A8[v20];
        ++v20;
        uint64_t v19 = *(void *)(a4 + 16);
      }
      while (v20 < *(unsigned __int8 *)(v19 + 64));
    }
  }
  return 0;
}

uint64_t stat_hmogrph_ModelInit(_WORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, _WORD *a8, unsigned __int16 *a9)
{
  uint64_t v90 = *MEMORY[0x263EF8340];
  unsigned __int8 v88 = 0;
  unsigned int v86 = 0;
  *(_DWORD *)__s2 = 0;
  *(void *)uint64_t v84 = 0;
  uint64_t v85 = 0;
  memset(v89, 0, sizeof(v89));
  uint64_t v83 = 0;
  *a7 = 0;
  *a8 = 0;
  *a9 = 0;
  uint64_t BrokerString = stat_hmogrph_getBrokerString(a3, (char *)v89, 0x100uLL);
  if ((BrokerString & 0x80000000) != 0) {
    goto LABEL_40;
  }
  uint64_t BrokerString = ssftriff_reader_ObjOpen(a1, a2, 2, (const char *)v89, "HMGR", 1031, (uint64_t *)v84);
  if ((BrokerString & 0x80000000) != 0) {
    goto LABEL_40;
  }
  uint64_t v82 = a4;
  uint64_t v25 = ssftriff_reader_OpenChunk(*(uint64_t *)v84, __s2, &v86, &v85, v21, v22, v23, v24);
  if ((v25 & 0x80000000) != 0)
  {
    uint64_t v39 = v25;
    unsigned __int16 v33 = 0;
  }
  else
  {
    unsigned __int16 v33 = 0;
    do
    {
      ++v33;
      ssftriff_reader_CloseChunk(*(uint64_t *)v84);
      uint64_t v38 = ssftriff_reader_OpenChunk(*(uint64_t *)v84, __s2, &v86, &v85, v34, v35, v36, v37);
    }
    while ((v38 & 0x80000000) == 0);
    uint64_t v39 = v38;
  }
  ssftriff_reader_ObjClose(*(void **)v84, v26, v27, v28, v29, v30, v31, v32);
  *(void *)uint64_t v84 = 0;
  if ((v39 & 0x1FFF) != 0x14) {
    goto LABEL_49;
  }
  uint64_t v40 = heap_Calloc(*(void **)(a3 + 8), 1, 48 * v33);
  *a7 = v40;
  if (!v40)
  {
    uint64_t v39 = 2314215434;
    uint64_t v78 = *(void *)(a3 + 32);
    uint64_t v65 = 0;
    goto LABEL_52;
  }
  *a9 = v33;
  uint64_t BrokerString = ssftriff_reader_ObjOpen(a1, a2, 2, (const char *)v89, "HMGR", 1031, (uint64_t *)v84);
  if ((BrokerString & 0x80000000) != 0)
  {
LABEL_40:
    uint64_t v39 = BrokerString;
    goto LABEL_41;
  }
  unsigned int v45 = ssftriff_reader_OpenChunk(*(uint64_t *)v84, __s2, &v86, &v85, v21, v22, v23, v24);
  if ((v45 & 0x80000000) != 0)
  {
LABEL_37:
    if ((v45 & 0x1FFF) == 0x14) {
      uint64_t v39 = 0;
    }
    else {
      uint64_t v39 = v45;
    }
    goto LABEL_41;
  }
  uint64_t v80 = a5;
  uint64_t v81 = a6;
  while (1)
  {
    uint64_t v46 = (unsigned __int16)*a8;
    uint64_t v47 = *a7;
    if (!*a8)
    {
      unsigned int v53 = 0;
LABEL_20:
      uint64_t v49 = v47 + 48 * v53;
      *a8 = v46 + 1;
      __strcpy_chk();
      if (com_getUnicodeOrth(v82, a5, a6, (uint64_t)__s2, &v83)) {
        __strcpy_chk();
      }
      else {
        log_OutText(*(void *)(a3 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Orth for unicode %s does not exist in dic_cfg4.cfg", v54, v55, v56, (uint64_t)__s2);
      }
      goto LABEL_23;
    }
    uint64_t v48 = 0;
    while (1)
    {
      uint64_t v49 = v47 + v48;
      if (!strcmp((const char *)(v47 + v48 + 7), __s2)) {
        break;
      }
      v48 += 48;
      if (48 * v46 == v48)
      {
        unsigned int v53 = v46;
        a5 = v80;
        a6 = v81;
        goto LABEL_20;
      }
    }
    unsigned int v53 = v46;
    a5 = v80;
    a6 = v81;
    if (!v47) {
      goto LABEL_20;
    }
LABEL_23:
    log_OutText(*(void *)(a3 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"model #%d, homograph %s", v50, v51, v52, (unsigned __int16)*a8);
    uint64_t v61 = ssftriff_reader_OpenChunk(*(uint64_t *)v84, __s2, &v86, &v85, v57, v58, v59, v60);
    if ((v61 & 0x80000000) == 0) {
      break;
    }
LABEL_35:
    uint64_t v39 = v61;
    if ((v61 & 0x1FFF) != 0x14) {
      goto LABEL_41;
    }
    ssftriff_reader_CloseChunk(*(uint64_t *)v84);
    unsigned int v45 = ssftriff_reader_OpenChunk(*(uint64_t *)v84, __s2, &v86, &v85, v71, v72, v73, v74);
    if ((v45 & 0x80000000) != 0) {
      goto LABEL_37;
    }
  }
  while (1)
  {
    log_OutText(*(void *)(a3 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"model chunk %s for homograph %s, size %d", v22, v23, v24, (uint64_t)__s2);
    if (*(_DWORD *)__s2 ^ 0x48505243 | v88) {
      break;
    }
    uint64_t v65 = *(void *)(v49 + 16);
    if (!v65)
    {
      uint64_t v65 = heap_Calloc(*(void **)(a3 + 8), 1, 344);
      *(void *)(v49 + 16) = v65;
      if (!v65) {
        goto LABEL_55;
      }
    }
    *(_DWORD *)(v65 + 72) = 1;
    uint64_t v66 = crf_Init(a1, a2, *(uint64_t *)v84, v65);
    if ((v66 & 0x80000000) != 0)
    {
LABEL_53:
      uint64_t v39 = v66;
      ssftriff_reader_CloseChunk(*(uint64_t *)v84);
      goto LABEL_41;
    }
    _hmgrph_parse_params(a3, *(void *)(*(void *)(v49 + 16) + 32), *(_DWORD *)(*(void *)(v49 + 16) + 40), v49);
LABEL_34:
    ssftriff_reader_CloseChunk(*(uint64_t *)v84);
    uint64_t v61 = ssftriff_reader_OpenChunk(*(uint64_t *)v84, __s2, &v86, &v85, v67, v68, v69, v70);
    if ((v61 & 0x80000000) != 0) {
      goto LABEL_35;
    }
  }
  if (*(_DWORD *)__s2 ^ 0x52544749 | v88)
  {
    log_OutText(*(void *)(a3 + 32), (uint64_t)"FE_HMOGRPH", 0, 0, (uint64_t)"unknown model type %s", v62, v63, v64, (uint64_t)__s2);
    uint64_t v39 = 2314215428;
    goto LABEL_41;
  }
  uint64_t v65 = *(void *)(v49 + 24);
  if (v65 || (uint64_t v65 = heap_Calloc(*(void **)(a3 + 8), 1, 1600), (*(void *)(v49 + 24) = v65) != 0))
  {
    uint64_t v66 = igtree_Init(a1, a2, *(uint64_t *)v84, (char *)v65);
    if ((v66 & 0x80000000) != 0) {
      goto LABEL_53;
    }
    goto LABEL_34;
  }
LABEL_55:
  uint64_t v39 = 2314215434;
  uint64_t v78 = *(void *)(a3 + 32);
LABEL_52:
  log_OutPublic(v78, (uint64_t)"FE_HMOGRPH", 37000, (char *)v65, v41, v42, v43, v44, v79);
LABEL_41:
  if (*(void *)v84)
  {
    int v75 = ssftriff_reader_ObjClose(*(void **)v84, v18, v19, v20, v21, v22, v23, v24);
    if (v75 >= 0 || (int)v39 <= -1) {
      uint64_t v39 = v39;
    }
    else {
      uint64_t v39 = v75;
    }
  }
  if ((v39 & 0x80000000) != 0)
  {
LABEL_49:
    stat_hmogrph_ModelDeinit(a3, a7, (unsigned __int16)*a8, v20, v21, v22, v23, v24);
    *a8 = 0;
  }
  return v39;
}

uint64_t stat_hmogrph_ModelDeinit(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    uint64_t v12 = 48 * a3;
    do
    {
      uint64_t v13 = *a2;
      uint64_t v14 = *(void *)(*a2 + v10 + 24);
      if (v14)
      {
        uint64_t v11 = igtree_Deinit(a1, v14, a3, a4, a5, a6, a7, a8);
        if ((v11 & 0x80000000) != 0) {
          return v11;
        }
        heap_Free(*(void **)(a1 + 8), *(void *)(*a2 + v10 + 24));
        *(void *)(*a2 + v10 + 24) = 0;
        uint64_t v13 = *a2;
      }
      uint64_t v15 = *(void *)(v13 + v10 + 16);
      if (v15)
      {
        uint64_t v11 = crf_Deinit(v15, v14, a3, a4, a5, a6, a7, a8);
        if ((v11 & 0x80000000) != 0) {
          return v11;
        }
        heap_Free(*(void **)(a1 + 8), *(void *)(*a2 + v10 + 16));
        *(void *)(*a2 + v10 + 16) = 0;
        uint64_t v13 = *a2;
      }
      uint64_t v16 = *(void *)(v13 + v10 + 32);
      if (v16)
      {
        heap_Free(*(void **)(a1 + 8), v16);
        *(void *)(*a2 + v10 + 32) = 0;
      }
      v10 += 48;
    }
    while (v12 != v10);
  }
  else
  {
    uint64_t v11 = 0;
  }
  heap_Free(*(void **)(a1 + 8), *a2);
  *a2 = 0;
  return v11;
}

uint64_t hlp_getcharPhons(uint64_t a1, const char **a2, unsigned int a3, uint64_t *a4, _WORD *a5)
{
  if (a3)
  {
    uint64_t v6 = a4;
    uint64_t v10 = a3;
    uint64_t v11 = a3;
    uint64_t v12 = a4;
    do
    {
      size_t v13 = (unsigned __int16)strlen(*a2);
      uint64_t v14 = (void *)heap_Calloc(*(void **)(a1 + 8), 1, v13 + 1);
      *uint64_t v12 = (uint64_t)v14;
      if (!v14)
      {
        log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v15, v16, v17, v18, v26);
        do
        {
          if (*v6)
          {
            heap_Free(*(void **)(a1 + 8), *v6);
            *uint64_t v6 = 0;
          }
          ++v6;
          --v10;
        }
        while (v10);
        return 2314215434;
      }
      uint64_t v19 = *a2;
      a2 += 7;
      memcpy(v14, v19, v13);
      uint64_t v20 = *v12++;
      *(unsigned char *)(v20 + v13) = 0;
      --v11;
    }
    while (v11);
    *a5 = 1;
    if (a3 != 1)
    {
      int v21 = 1;
      uint64_t v22 = 1;
      do
      {
        uint64_t v23 = 0;
        uint64_t v24 = (const char *)v6[v22];
        while (strcmp((const char *)v6[v23], v24))
        {
          if (v22 == ++v23)
          {
            *a5 = ++v21;
            break;
          }
        }
        ++v22;
      }
      while (v22 != v10);
    }
    return 0;
  }
  else
  {
    uint64_t result = 0;
    *a5 = 0;
  }
  return result;
}

uint64_t hlp_concatFeatureVector(uint64_t a1, const char **a2, unsigned int a3, char **a4)
{
  if (a3)
  {
    LODWORD(v8) = 0;
    uint64_t v9 = a3;
    uint64_t v10 = a2;
    do
    {
      uint64_t v11 = *v10++;
      uint64_t v8 = v8 + strlen(v11) + 2;
      --v9;
    }
    while (v9);
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v12 = heap_Calloc(*(void **)(a1 + 8), 1, v8);
  *a4 = (char *)v12;
  if (v12)
  {
    if (a3)
    {
      uint64_t v17 = 0;
      do
      {
        strcat(*a4, a2[v17]);
        if (v17 < a3 - 1) {
          *(_WORD *)&(*a4)[strlen(*a4)] = 32;
        }
        ++v17;
      }
      while (a3 != v17);
    }
    return 0;
  }
  else
  {
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v13, v14, v15, v16, v19);
    return 2314215434;
  }
}

uint64_t hlp_disamWithModels(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, unsigned int a5, const char *a6, uint64_t a7, uint64_t a8, char *a9, long long *a10)
{
  int v182 = 0;
  v183[0] = 0;
  unsigned int v181 = 0;
  uint64_t v179 = 0;
  BOOL v180 = 0;
  int v178 = 0;
  int v177 = 0;
  uint64_t v175 = 0;
  int v176 = 0;
  int v174 = 0;
  if (!*(void *)(a2 + 40))
  {
    int ReadOnly = 0;
LABEL_6:
    BOOL v165 = 0;
    goto LABEL_9;
  }
  uint64_t v15 = *(void *)(a2 + 48);
  if (v15)
  {
    int ReadOnly = ssftmap_FindReadOnly(v15, (uint64_t)a6, &v176);
    if (!*(void *)(a2 + 40)) {
      goto LABEL_6;
    }
  }
  else
  {
    int ReadOnly = 0;
  }
  BOOL v165 = strcmp(*(const char **)(a2 + 64), "albert") == 0;
LABEL_9:
  uint64_t v16 = *(unsigned __int16 *)(a2 + 32);
  uint64_t v162 = (const char **)a8;
  if (*(_WORD *)(a2 + 32))
  {
    LOWORD(v17) = 0;
    uint64_t v18 = 0;
    int v19 = 0;
    uint64_t v20 = *(const char **)(a2 + 24);
    int v21 = v20;
    do
    {
      if (!strcmp(v21, a6))
      {
        LOWORD(v17) = v18;
        int v19 = 1;
      }
      ++v18;
      v21 += 48;
    }
    while (v16 != v18);
    if (v19) {
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v20 = *(const char **)(a2 + 24);
    LOWORD(v17) = 0;
  }
  if (ReadOnly < 0)
  {
    log_OutText(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 0, 0, (uint64_t)"No model for homograph %s exist", (uint64_t)a6, a7, a8, (uint64_t)a6);
    uint64_t v22 = 0;
    uint64_t v23 = 0;
    goto LABEL_78;
  }
LABEL_19:
  uint64_t v24 = a10;
  unsigned int v17 = (unsigned __int16)v17;
  uint64_t v25 = &v20[48 * (unsigned __int16)v17];
  uint64_t v27 = *((void *)v25 + 2);
  unsigned int v26 = (uint64_t *)(v25 + 16);
  uint64_t v28 = *(void *)(a1 + 32);
  unsigned int v160 = a5;
  uint64_t v161 = v20;
  if (!v27)
  {
    log_OutText(v28, (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"MaxEnt model for homograph %s does not exist", (uint64_t)a6, a7, a8, (uint64_t)a6);
    uint64_t v22 = 0;
    uint64_t v30 = 0;
    goto LABEL_30;
  }
  log_OutText(v28, (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Disambiguate homograph %s with MaxEnt model", (uint64_t)a6, a7, a8, (uint64_t)a6);
  uint64_t v29 = (const char **)heap_Calloc(*(void **)(a1 + 8), 1, 8 * *(unsigned __int8 *)(*v26 + 64) - 8);
  if (!v29)
  {
    uint64_t v23 = 0;
    uint64_t v22 = 2314215434;
    goto LABEL_78;
  }
  uint64_t v30 = v29;
  uint64_t inited = hlp_initFeatureVector(a1, v29, (unsigned __int16)(*(unsigned __int8 *)(*v26 + 64) - 1));
  if ((inited & 0x80000000) != 0) {
    goto LABEL_37;
  }
  uint64_t v32 = *(void *)(*v26 + 56);
  unsigned int v33 = *(unsigned __int8 *)(*v26 + 64);
  uint64_t v34 = &v20[48 * (unsigned __int16)v17];
  uint64_t v35 = (char **)*((void *)v34 + 4);
  LOWORD(v34) = *((_WORD *)v34 + 20);
  long long v36 = a10[3];
  long long v170 = a10[2];
  long long v171 = v36;
  long long v172 = a10[4];
  uint64_t v173 = *((void *)a10 + 10);
  long long v37 = a10[1];
  long long v168 = *a10;
  long long v169 = v37;
  hlp_setFeatureVector(a1, (uint64_t)v30, v32, v33, (unsigned __int16 *)(a2 + 8), a3, v160, v35, (unsigned __int16)v34, (uint64_t)&v168);
  uint64_t inited = hlp_concatFeatureVector(a1, v30, (*(unsigned char *)(*v26 + 64) - 1), v183);
  if ((inited & 0x80000000) != 0)
  {
LABEL_37:
    uint64_t v22 = inited;
    goto LABEL_38;
  }
  log_OutText(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"STATHMOGRPH_FEATURE: homograph %s at word %d, char %d", v38, v39, v40, (uint64_t)a6);
  log_OutText(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"STATHMOGRPH_FEATURE: %s", v41, v42, v43, (uint64_t)v183[0]);
  uint64_t v22 = crf_Process(*v26, v183, 1u, (uint64_t *)&v182, &v181);
  if ((v22 & 0x80000000) != 0)
  {
LABEL_38:
    uint64_t v23 = 0;
    uint64_t v69 = 0;
    goto LABEL_75;
  }
  if (*(unsigned char *)(*v26 + 64) != 1)
  {
    uint64_t v47 = (unsigned __int16)(*(unsigned __int8 *)(*v26 + 64) - 1);
    uint64_t v48 = (uint64_t *)v30;
    do
    {
      uint64_t v49 = *v48++;
      heap_Free(*(void **)(a1 + 8), v49);
      --v47;
    }
    while (v47);
  }
  uint64_t v24 = a10;
  if (v181 == 1)
  {
    uint64_t v50 = strcpy(a9, *v182);
    a9[strlen(v50) - 1] = 0;
  }
  else
  {
    log_OutText(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"%d predictions for homograph %s with maxent model (discarded)", v44, v45, v46, v181);
  }
LABEL_30:
  uint64_t v54 = *(void *)(a1 + 32);
  if (!*(void *)(a2 + 40) || ReadOnly < 0)
  {
    uint64_t v158 = v24;
    int __dst = a9;
    log_OutText(v54, (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"No NN model for homograph %s !", v51, v52, v53, (uint64_t)a6);
    uint64_t v23 = 0;
    goto LABEL_40;
  }
  log_OutText(v54, (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Disambiguate homograph %s with NN model", v51, v52, v53, (uint64_t)a6);
  uint64_t v55 = *(void *)(a2 + 80);
  uint64_t v56 = (*(uint64_t (**)(void, void, int *))(v55 + 40))(*(void *)(a2 + 104), *(void *)(a2 + 112), &v177);
  if ((v56 & 0x80000000) != 0)
  {
    uint64_t v22 = v56;
LABEL_73:
    uint64_t v69 = 0;
    uint64_t v23 = 0;
    goto LABEL_74;
  }
  unsigned int v159 = (unsigned __int16)v17;
  uint64_t v62 = (_DWORD *)(a2 + 60);
  int v61 = *(_DWORD *)(a2 + 60);
  if (v165)
  {
    if (v61 == v177)
    {
      int __dst = a9;
      int v157 = (uint64_t *)(a1 + 8);
      uint64_t v63 = heap_Calloc(*(void **)(a1 + 8), 1, 8);
      if (v63)
      {
        uint64_t v23 = (char *)v63;
        int v68 = *(_DWORD *)(a2 + 56) + 2;
        goto LABEL_60;
      }
      goto LABEL_72;
    }
LABEL_64:
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v57, v58, v59, v60, v148);
    uint64_t v69 = 0;
    uint64_t v23 = 0;
    uint64_t v22 = 2314215449;
    goto LABEL_74;
  }
  if (v61 != v177 + 1) {
    goto LABEL_64;
  }
  int __dst = a9;
  int v157 = (uint64_t *)(a1 + 8);
  uint64_t v94 = heap_Calloc(*(void **)(a1 + 8), 1, 8);
  if (!v94)
  {
LABEL_72:
    uint64_t v22 = 2314215434;
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v64, v65, v66, v67, v148);
    goto LABEL_73;
  }
  uint64_t v23 = (char *)v94;
  uint64_t v62 = (_DWORD *)(a2 + 56);
  int v68 = *(_DWORD *)(a2 + 60);
LABEL_60:
  int v95 = (_DWORD *)heap_Alloc(*v157, 4 * (v68 * *v62));
  uint64_t v179 = v95;
  if (!v95)
  {
    uint64_t v22 = 2314215434;
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v96, v97, v98, v99, v148);
    goto LABEL_54;
  }
  int v100 = (float *)v95;
  uint64_t nnSent = make_nnSent(a1, a2 + 8, (uint64_t)&v174);
  if ((nnSent & 0x80000000) != 0)
  {
    uint64_t v22 = nnSent;
    uint64_t v110 = *(void *)(a1 + 32);
    unsigned __int16 v111 = "Make NN Sent Failed";
    goto LABEL_170;
  }
  if (v165)
  {
    *v100++ = 101.0;
    unsigned int v103 = *(_DWORD *)(a2 + 56);
    v179[v103 + 1] = 1120665600;
  }
  else
  {
    unsigned int v103 = *(_DWORD *)(a2 + 56);
  }
  unsigned int v17 = v159;
  int v112 = 1 - (__int16)v103;
  if (v112 < 0) {
    int v112 = 2 - (__int16)v103;
  }
  int v113 = v112 >> 1;
  if ((__int16)v103 >= -1) {
    int v114 = (__int16)v103 + 1;
  }
  else {
    int v114 = (__int16)v103 + 2;
  }
  uint64_t v158 = v24;
  if (v113 >= v114 >> 1)
  {
LABEL_158:
    if (v165) {
      uint64_t v143 = v103 + 2;
    }
    else {
      uint64_t v143 = v103;
    }
    uint64_t v22 = fi_predict(*(uint64_t ****)(a2 + 40), (const void **)&v179, v143, &v178, v102, v70, v71, v72);
    if ((v22 & 0x80000000) == 0)
    {
      uint64_t v144 = *(void *)(a7 + 48) + 16 * a4;
      uint64_t v145 = *(unsigned __int16 *)(v144 + 8);
      if (*(_WORD *)(v144 + 8))
      {
        int v146 = *v178;
        int v147 = v162;
        char v73 = 1;
        while (strcmp(*v147, v146))
        {
          ++v147;
          if (!--v145) {
            goto LABEL_173;
          }
        }
        strcpy(__dst, v146);
        char v73 = 0;
LABEL_173:
        uint64_t v74 = v161;
        unsigned int v17 = v159;
        goto LABEL_41;
      }
LABEL_40:
      char v73 = 1;
      uint64_t v74 = v161;
LABEL_41:
      int v75 = &v74[48 * v17];
      uint64_t v77 = *((void *)v75 + 3);
      uint64_t v76 = (uint64_t *)(v75 + 24);
      uint64_t v78 = *(void *)(a1 + 32);
      if (v77)
      {
        log_OutText(v78, (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Disambiguate homograph %s with igtree model", v70, v71, v72, (uint64_t)a6);
        uint64_t v69 = (uint64_t *)heap_Calloc(*(void **)(a1 + 8), 1, 8 * *(unsigned __int8 *)(*v76 + 1296) - 8);
        if (!v69)
        {
          uint64_t v22 = 2314215434;
          goto LABEL_74;
        }
        uint64_t v79 = hlp_initFeatureVector(a1, v69, (unsigned __int16)(*(unsigned __int8 *)(*v76 + 1296) - 1));
        if ((v79 & 0x80000000) != 0)
        {
          uint64_t v22 = v79;
          goto LABEL_74;
        }
        uint64_t v80 = *(void *)(*v76 + 1312);
        unsigned int v81 = *(unsigned __int8 *)(*v76 + 1296);
        long long v82 = v158[3];
        long long v170 = v158[2];
        long long v171 = v82;
        long long v172 = v158[4];
        uint64_t v173 = *((void *)v158 + 10);
        long long v83 = v158[1];
        long long v168 = *v158;
        long long v169 = v83;
        hlp_setFeatureVector(a1, (uint64_t)v69, v80, v81, (unsigned __int16 *)(a2 + 8), a3, v160, 0, 0, (uint64_t)&v168);
        igtree_Process(*v76, (uint64_t)v69, &v180);
        if (*(unsigned char *)(*v76 + 1296) != 1)
        {
          uint64_t v84 = (unsigned __int16)(*(unsigned __int8 *)(*v76 + 1296) - 1);
          uint64_t v85 = v69;
          do
          {
            uint64_t v86 = *v85++;
            heap_Free(*(void **)(a1 + 8), v86);
            --v84;
          }
          while (v84);
        }
        unsigned int v87 = v180;
        int v88 = strcmp(v180, "NOMATCH");
        if (v73)
        {
          if (!v88)
          {
            unsigned __int16 v92 = v176;
            if (!v176 || ReadOnly < 0)
            {
              log_OutText(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"No igtree rule matched for homograph %s", v89, v90, v91, (uint64_t)a6);
              if (!*__dst)
              {
                uint64_t v22 = 0;
                *(void *)int __dst = 0x484354414D4F4ELL;
                goto LABEL_74;
              }
LABEL_71:
              uint64_t v22 = 0;
              goto LABEL_74;
            }
            int v93 = __dst;
LABEL_70:
            strcpy(v93, v92);
            goto LABEL_71;
          }
        }
        else if (!v88 || !strcmp(v87, *v178))
        {
          goto LABEL_71;
        }
        int v93 = __dst;
        unsigned __int16 v92 = v87;
        goto LABEL_70;
      }
      log_OutText(v78, (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"IGTree model for homograph %s does not exist", v70, v71, v72, (uint64_t)a6);
LABEL_54:
      uint64_t v69 = 0;
      goto LABEL_74;
    }
    uint64_t v110 = *(void *)(a1 + 32);
    unsigned __int16 v111 = "FIhmogrph Prediction Failed";
LABEL_170:
    log_OutText(v110, (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)v111, v70, v71, v72, 0);
    goto LABEL_54;
  }
  uint64_t v115 = a3;
  int v151 = v30;
  BOOL v116 = (uint64_t (**)(void, void, char *, float *))(v55 + 72);
  if (!v165) {
    BOOL v116 = (uint64_t (**)(void, void, char *, float *))(v55 + 56);
  }
  int v149 = (void (**)(void, void, char *, float *))(v55 + 56);
  uint64_t v150 = v116;
  while (1)
  {
    int v155 = v113;
    if (!v165)
    {
      if ((_WORD)v113) {
        float v117 = 0.0;
      }
      else {
        float v117 = 1.0;
      }
      *v100++ = v117;
    }
    uint64_t v118 = v174;
    __src = *(char **)(a2 + 72);
    int v153 = v100;
    int v154 = strlen(v174[v115]);
    int v119 = 0;
    if (a3)
    {
      uint64_t v120 = v174;
      uint64_t v121 = (unsigned __int16)(a3 + 1);
      do
      {
        uint64_t v122 = *v120++;
        v119 += strlen(v122);
        --v115;
      }
      while (v115);
    }
    else
    {
      uint64_t v121 = 1;
    }
    uint64_t v123 = (unsigned __int16)v175;
    if (v121 >= (unsigned __int16)v175)
    {
      int v124 = 0;
      unsigned int v17 = v159;
    }
    else
    {
      int v124 = 0;
      unsigned int v17 = v159;
      do
        v124 += strlen(v174[v121++]);
      while ((unsigned __int16)v175 != (unsigned __int16)v121);
    }
    uint64_t v125 = heap_Calloc((void *)*v157, 1, (v154 + v119 + v124 + 1));
    if (!v125) {
      break;
    }
    uint64_t v130 = (char *)v125;
    if (v123)
    {
      unsigned int NextUtf8Offset = v119 + v160;
      unsigned int v132 = v118;
      uint64_t v133 = v123;
      do
      {
        int v134 = *v132++;
        strcat(v130, v134);
        --v133;
      }
      while (v133);
      unsigned int v17 = v159;
      if (v123 > a3 && strlen(v118[a3]) > v160)
      {
        int v135 = v155;
        if ((v155 & 0x8000) != 0)
        {
          if (NextUtf8Offset)
          {
            __int16 v137 = v155;
            do
            {
              unsigned int PreviousUtf8Offset = utf8_GetPreviousUtf8Offset((uint64_t)v130, NextUtf8Offset);
              unsigned int NextUtf8Offset = PreviousUtf8Offset;
              BOOL v139 = (unsigned __int16)~v137++ == 0;
            }
            while (!v139 && PreviousUtf8Offset);
            if (!v137)
            {
LABEL_140:
              if ((utf8_getUTF8Char((uint64_t)v130, NextUtf8Offset, v23) & 0x80000000) == 0) {
                goto LABEL_142;
              }
            }
          }
        }
        else
        {
          if (!(_WORD)v155) {
            goto LABEL_140;
          }
          while (NextUtf8Offset != strlen(v130))
          {
            unsigned int NextUtf8Offset = utf8_GetNextUtf8Offset(v130, NextUtf8Offset);
            int v136 = (__int16)v135--;
            if (v136 <= 1) {
              goto LABEL_140;
            }
          }
        }
      }
    }
    strcpy(v23, __src);
LABEL_142:
    heap_Free((void *)*v157, (uint64_t)v130);
    if (!*v23) {
      strcpy(v23, *(const char **)(a2 + 72));
    }
    uint64_t v30 = v151;
    uint64_t v115 = a3;
    if (utf8_IsChineseLetter(v23)) {
      goto LABEL_152;
    }
    int v140 = *v23;
    switch(v140)
    {
      case 's':
        strcpy(v23, *(const char **)(a2 + 72));
        break;
      case 'e':
        int v141 = 4673093;
        goto LABEL_151;
      case '0':
        int v141 = 5068110;
LABEL_151:
        *(_DWORD *)uint64_t v23 = v141;
        break;
    }
LABEL_152:
    if (((*v150)(*(void *)(a2 + 104), *(void *)(a2 + 112), v23, v153) & 0x1FFF) == 0x14)
    {
      log_OutText(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"No embedding vector for character %s . Fall back!", v70, v71, v72, (uint64_t)v23);
      strcpy(v23, *(const char **)(a2 + 72));
      (*v149)(*(void *)(a2 + 104), *(void *)(a2 + 112), v23, v153);
    }
    int v100 = &v153[v177];
    int v113 = v155 + 1;
    unsigned int v103 = *(_DWORD *)(a2 + 56);
    if ((__int16)v103 >= -1) {
      int v142 = (__int16)v103 + 1;
    }
    else {
      int v142 = (__int16)v103 + 2;
    }
    if (v142 >> 1 <= (__int16)v113) {
      goto LABEL_158;
    }
  }
  uint64_t v22 = 2314215434;
  log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v126, v127, v128, v129, v148);
  uint64_t v69 = 0;
  uint64_t v30 = v151;
LABEL_74:
  if (v30) {
LABEL_75:
  }
    heap_Free(*(void **)(a1 + 8), (uint64_t)v30);
  if (v69) {
    heap_Free(*(void **)(a1 + 8), (uint64_t)v69);
  }
LABEL_78:
  if (v183[0])
  {
    heap_Free(*(void **)(a1 + 8), (uint64_t)v183[0]);
    v183[0] = 0;
  }
  uint64_t v104 = (uint64_t)v182;
  if (v182)
  {
    if (v181)
    {
      for (unint64_t i = 0; i < v181; heap_Free(*(void **)(a1 + 8), (uint64_t)v182[i++]))
        ;
      uint64_t v104 = (uint64_t)v182;
    }
    heap_Free(*(void **)(a1 + 8), v104);
    int v182 = 0;
  }
  if (v23) {
    heap_Free(*(void **)(a1 + 8), (uint64_t)v23);
  }
  uint64_t v106 = (unsigned __int16)v175;
  uint64_t v107 = (uint64_t)v174;
  if ((_WORD)v175)
  {
    int v108 = (uint64_t *)v174;
    do
    {
      if (*v108)
      {
        heap_Free(*(void **)(a1 + 8), *v108);
        *int v108 = 0;
      }
      ++v108;
      --v106;
    }
    while (v106);
LABEL_95:
    heap_Free(*(void **)(a1 + 8), v107);
  }
  else if (v174)
  {
    goto LABEL_95;
  }
  return v22;
}

uint64_t make_nnSent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(unsigned __int16 *)(a2 + 8);
  *(_WORD *)(a3 + 8) = v6;
  uint64_t v7 = heap_Alloc(*(void *)(a1 + 8), 8 * v6);
  *(void *)a3 = v7;
  if (!v7)
  {
LABEL_39:
    uint64_t v36 = 2314215434;
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v8, v9, v10, v11, v43);
    return v36;
  }
  if (!*(_WORD *)(a3 + 8)) {
    return 0;
  }
  uint64_t v12 = 0;
  unint64_t v13 = 0;
  while (1)
  {
    BOOL IsChineseLetter = utf8_IsChineseLetter(*(const char **)(*(void *)a2 + 8 * v12));
    uint64_t v15 = *(const char **)(*(void *)a2 + 8 * v12);
    if (IsChineseLetter || strlen(*(const char **)(*(void *)a2 + 8 * v12)) != 1) {
      break;
    }
    int v16 = *(unsigned __int8 *)v15;
    if ((v16 - 48) <= 9)
    {
      unsigned int v17 = (_WORD *)heap_Alloc(*(void *)(a1 + 8), 2);
      *(void *)(*(void *)a3 + v12) = v17;
      if (!v17) {
        goto LABEL_42;
      }
LABEL_19:
      _WORD *v17 = 48;
      goto LABEL_20;
    }
    unsigned int v33 = (v16 & 0xFFFFFFDF) - 65;
    unsigned int v26 = (char *)heap_Alloc(*(void *)(a1 + 8), 2);
    *(void *)(*(void *)a3 + v12) = v26;
    if (v33 <= 0x19)
    {
      if (!v26) {
        goto LABEL_42;
      }
LABEL_24:
      __int16 v34 = 101;
LABEL_25:
      *(_WORD *)unsigned int v26 = v34;
      goto LABEL_20;
    }
    if (!v26)
    {
LABEL_42:
      uint64_t v36 = 2314215434;
      log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v18, v19, v20, v21, v43);
      uint64_t v41 = *(void *)(a1 + 32);
      uint64_t v42 = "Tag 1-char orth word for NN Failed";
      goto LABEL_44;
    }
LABEL_12:
    strcpy(v26, *(const char **)(*(void *)a2 + 8 * v12));
LABEL_20:
    ++v13;
    v12 += 8;
    if (v13 >= *(unsigned __int16 *)(a3 + 8)) {
      return 0;
    }
  }
  BOOL v22 = utf8_IsChineseLetter(v15);
  uint64_t v23 = *(const char **)(*(void *)a2 + 8 * v12);
  if (v22 || (size_t v24 = strlen(*(const char **)(*(void *)a2 + 8 * v12)), v24 == 1))
  {
    size_t v25 = strlen(v23);
    unsigned int v26 = (char *)heap_Alloc(*(void *)(a1 + 8), v25 + 1);
    *(void *)(*(void *)a3 + v12) = v26;
    if (!v26) {
      goto LABEL_39;
    }
    goto LABEL_12;
  }
  int v27 = *(unsigned __int8 *)v23;
  if ((v27 - 48) < 0xA
    || ((v27 - 35) <= 0x3C
      ? (BOOL v28 = ((1 << (v27 - 35)) & 0x1800000004000503) == 0)
      : (BOOL v28 = 1),
        !v28 || v27 == 124))
  {
    unsigned int v17 = (_WORD *)heap_Alloc(*(void *)(a1 + 8), 2);
    *(void *)(*(void *)a3 + v12) = v17;
    if (!v17) {
      goto LABEL_43;
    }
    goto LABEL_19;
  }
  if ((v27 & 0xFFFFFFDF) - 65 < 0x1A) {
    goto LABEL_30;
  }
  unsigned int v35 = v27 - 34;
  if (v35 > 0x39) {
    goto LABEL_37;
  }
  if (((1 << v35) & 0x200000006000061) != 0)
  {
    unsigned int v26 = (char *)heap_Alloc(*(void *)(a1 + 8), (v24 + 1));
    *(void *)(*(void *)a3 + v12) = v26;
    if (!v26) {
      goto LABEL_43;
    }
    goto LABEL_12;
  }
  if (((1 << v35) & 0x40000010) != 0)
  {
LABEL_30:
    unsigned int v26 = (char *)heap_Alloc(*(void *)(a1 + 8), 2);
    *(void *)(*(void *)a3 + v12) = v26;
    if (!v26) {
      goto LABEL_43;
    }
    goto LABEL_24;
  }
LABEL_37:
  unsigned int v26 = (char *)heap_Alloc(*(void *)(a1 + 8), 2);
  *(void *)(*(void *)a3 + v12) = v26;
  if (v26)
  {
    __int16 v34 = 115;
    goto LABEL_25;
  }
LABEL_43:
  uint64_t v36 = 2314215434;
  log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v29, v30, v31, v32, v43);
  uint64_t v41 = *(void *)(a1 + 32);
  uint64_t v42 = "Tag orth word for NN Failed";
LABEL_44:
  log_OutText(v41, (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)v42, v38, v39, v40, 0);
  return v36;
}

uint64_t hlp_disamCharByChar(uint64_t a1, unsigned int a2, unsigned int a3, _WORD *a4, int *a5, uint64_t a6)
{
  uint64_t v12 = *(void *)a1;
  uint64_t v13 = *(void *)(a1 + 8);
  uint64_t v14 = (char *)heap_Alloc(*(void *)(*(void *)a1 + 8), 1024);
  if (v14)
  {
    uint64_t v19 = v14;
    uint64_t v68 = a6;
    uint64_t v20 = v13 + ((unint64_t)a2 << 6);
    *uint64_t v14 = 0;
    uint64_t v21 = *(void *)(v20 + 48);
    uint64_t v74 = (void *)(v20 + 48);
    uint64_t v22 = *(unsigned __int16 *)(v21 + 16 * a3 + 8);
    uint64_t v73 = a3;
    uint64_t v70 = a2;
    unsigned int v69 = a2;
    if (*(_WORD *)(v21 + 16 * a3 + 8))
    {
      uint64_t v23 = (_DWORD *)(*(void *)(v21 + 16 * a3) + 48);
      uint64_t v24 = v22;
      do
      {
        *uint64_t v23 = 0;
        v23 += 14;
        --v24;
      }
      while (v24);
      uint64_t v25 = v22;
    }
    else
    {
      uint64_t v25 = 0;
    }
    uint64_t v27 = heap_Calloc(*(void **)(v12 + 8), v25, 8);
    if (!v27)
    {
      uint64_t v26 = 2314215434;
      log_OutPublic(*(void *)(v12 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v28, v29, v30, v31, v64);
LABEL_57:
      heap_Free(*(void **)(v12 + 8), (uint64_t)v19);
      return v26;
    }
    uint64_t v67 = v13;
    int v75 = (uint64_t *)v27;
    int v71 = v22;
    if (a3)
    {
      int v32 = 0;
      unsigned int NextUtf8Offset = 0;
      do
      {
        unsigned int NextUtf8Offset = utf8_GetNextUtf8Offset(*(char **)v20, NextUtf8Offset);
        ++v32;
      }
      while (a3 > (unsigned __int16)v32);
    }
    else
    {
      unsigned int NextUtf8Offset = 0;
    }
    unsigned int UTF8Char = utf8_getUTF8Char(*(void *)v20, NextUtf8Offset, __s2);
    if ((UTF8Char & 0x80000000) != 0)
    {
      unsigned int v72 = UTF8Char;
    }
    else
    {
      unsigned __int16 v78 = 0;
      unsigned int v72 = hlp_getcharPhons(v12, *(const char ***)(*v74 + 16 * a3), *(unsigned __int16 *)(*v74 + 16 * a3 + 8), v75, &v78);
      if ((v72 & 0x80000000) == 0)
      {
        uint64_t v66 = a4;
        if (v78 >= 2u)
        {
          uint64_t v65 = a5;
          uint64_t v35 = *(unsigned __int16 *)(a1 + 32);
          if (!*(_WORD *)(a1 + 32)) {
            goto LABEL_33;
          }
          int v36 = 0;
          long long v37 = *(const char **)(a1 + 24);
          do
          {
            if (!strcmp(v37, __s2)) {
              int v36 = 1;
            }
            v37 += 48;
            --v35;
          }
          while (v35);
          if (v36)
          {
            long long v38 = *(_OWORD *)(v68 + 48);
            v76[2] = *(_OWORD *)(v68 + 32);
            v76[3] = v38;
            v76[4] = *(_OWORD *)(v68 + 64);
            uint64_t v77 = *(void *)(v68 + 80);
            long long v39 = *(_OWORD *)(v68 + 16);
            v76[0] = *(_OWORD *)v68;
            v76[1] = v39;
            hlp_disamWithModels(v12, a1, v69, a3, NextUtf8Offset, __s2, v20, (uint64_t)v75, v19, v76);
            a5 = v65;
            if (strcmp(v19, "NOMATCH"))
            {
              uint64_t v40 = *v74 + 16 * a3;
              if (*(_WORD *)(v40 + 8))
              {
                uint64_t v41 = 0;
                uint64_t v42 = 56 * *(unsigned __int16 *)(v40 + 8);
                unsigned int v43 = (const char **)v75;
                do
                {
                  if (strcmp(*v43, v19)) {
                    *(_DWORD *)(*(void *)v40 + v41 + 48) = 1;
                  }
                  ++v43;
                  v41 += 56;
                }
                while (v42 != v41);
              }
            }
          }
          else
          {
LABEL_33:
            a5 = v65;
            int *v65 = 0;
          }
        }
        uint64_t v45 = *(char **)(v67 + (v70 << 6) + 24);
        if (*v45)
        {
          int v46 = strcmp(*(const char **)(v67 + (v70 << 6) + 24), "poi");
          int hasRcdWithGivenPOIClass = hlp_hasRcdWithGivenPOIClass(v20, v45);
          uint64_t v48 = v66;
          if (v46)
          {
            if (!hasRcdWithGivenPOIClass)
            {
              int v44 = v71;
              if (hlp_hasRcdWithGivenPOIClass(v20, "poi")) {
                hlp_filterWordCandIfTnIsNot(v20, "poi");
              }
              else {
                hlp_filterWordCandIfTnHas((char *)v20);
              }
LABEL_43:
              *uint64_t v48 = -1;
              uint64_t v51 = *v74 + 16 * v73;
              unsigned int v54 = *(unsigned __int16 *)(v51 + 8);
              uint64_t v52 = (unsigned __int16 *)(v51 + 8);
              unsigned int v53 = v54;
              if (!v54) {
                goto LABEL_50;
              }
              unint64_t v55 = 0;
              uint64_t v56 = *(void *)(*v74 + 16 * v73) + 48;
              int v57 = 0xFFFF;
              unsigned __int16 v58 = -1;
              uint64_t v59 = (int *)v56;
              do
              {
                int v60 = *v59;
                v59 += 14;
                if (!v60 && *(unsigned __int16 *)(v56 - 40) < v58)
                {
                  int v57 = (unsigned __int16)v55;
                  *uint64_t v48 = v55;
                  unsigned __int16 v58 = *(_WORD *)(v56 - 40);
                  unsigned int v53 = *v52;
                }
                ++v55;
                uint64_t v56 = (uint64_t)v59;
              }
              while (v55 < v53);
              if (v57 != 0xFFFF) {
                int v61 = 1;
              }
              else {
LABEL_50:
              }
                int v61 = 0;
              *a5 = v61;
              goto LABEL_53;
            }
            uint64_t v49 = v20;
            uint64_t v50 = v45;
          }
          else
          {
            if (!hasRcdWithGivenPOIClass)
            {
              hlp_filterWordCandIfTnHas((char *)v20);
              goto LABEL_42;
            }
            uint64_t v50 = "poi";
            uint64_t v49 = v20;
          }
          hlp_filterWordCandIfTnIsNot(v49, v50);
        }
        else
        {
          hlp_filterWordCandIfTnHas((char *)v20);
          uint64_t v48 = v66;
        }
LABEL_42:
        int v44 = v71;
        goto LABEL_43;
      }
    }
    int v44 = v71;
LABEL_53:
    if (v44)
    {
      uint64_t v62 = v75;
      do
      {
        heap_Free(*(void **)(v12 + 8), *v62);
        *v62++ = 0;
        --v25;
      }
      while (v25);
    }
    heap_Free(*(void **)(v12 + 8), (uint64_t)v75);
    uint64_t v26 = v72;
    goto LABEL_57;
  }
  uint64_t v26 = 2314215434;
  log_OutPublic(*(void *)(v12 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v15, v16, v17, v18, v64);
  return v26;
}

uint64_t hlp_disamSpecialWords(uint64_t a1, uint64_t *a2, unsigned int a3, unsigned int a4, _DWORD *a5, uint64_t a6)
{
  *(_DWORD *)&v62[3] = 0;
  *(_DWORD *)uint64_t v62 = 0;
  __int16 v61 = 0;
  uint64_t v10 = (unsigned __int16 *)(a2 + 1);
  uint64_t v9 = a2[1];
  int v60 = 0;
  *a5 = 0;
  unint64_t v11 = v9 + ((unint64_t)a3 << 6);
  uint64_t v13 = (uint64_t *)(v11 + 48);
  uint64_t v12 = *(void *)(v11 + 48);
  uint64_t v14 = a4;
  uint64_t v15 = v12 + 16 * a4;
  uint64_t v16 = *(unsigned __int16 *)(v15 + 8);
  if (*(_WORD *)(v15 + 8))
  {
    uint64_t v17 = *(char ***)(v12 + 16 * a4);
    while (!strstr(*v17, "{SEP"))
    {
      v17 += 7;
      if (!--v16) {
        goto LABEL_5;
      }
    }
LABEL_16:
    uint64_t v21 = 0;
LABEL_17:
    uint64_t v24 = 0;
LABEL_18:
    if (!*(_DWORD *)(a1 + 144))
    {
      uint64_t v25 = *v13 + 16 * v14;
      uint64_t v26 = *(unsigned __int16 *)(v25 + 8);
      if (*(_WORD *)(v25 + 8))
      {
        uint64_t v29 = *(void *)v25;
        uint64_t v28 = (_WORD *)(v25 + 12);
        uint64_t v27 = v29;
        *uint64_t v28 = 0;
        if (v26 != 1)
        {
          uint64_t v30 = 0;
          uint64_t v31 = (unsigned __int16 *)(v27 + 64);
          for (uint64_t i = 1; i != v26; ++i)
          {
            unsigned int v33 = *v31;
            v31 += 28;
            if (v33 < *(unsigned __int16 *)(v27 + 56 * v30 + 8))
            {
              uint64_t v30 = (unsigned __int16)i;
              *uint64_t v28 = i;
            }
          }
        }
      }
LABEL_25:
      *a5 = 1;
    }
    if (v24) {
LABEL_27:
    }
      heap_Free(*(void **)(*a2 + 8), v24);
  }
  else
  {
LABEL_5:
    uint64_t v19 = *(void *)(v11 + 40);
    uint64_t v18 = (char **)(v11 + 40);
    if ((utf8_getUTF8Char(v19, 0, v62) & 0x80000000) == 0)
    {
      unsigned int NextUtf8Offset = 0;
      while (strlen(*v18) > NextUtf8Offset)
      {
        if (utf8_Utf8CharTo16bit(v62, (uint64_t)&v61)
          && (unsigned __int16)((unsigned __int16)(v61 + 24576) >> 9) <= 0x56u)
        {
          if (!*((_WORD *)a2 + 16)) {
            goto LABEL_16;
          }
          uint64_t v22 = 0;
          uint64_t v21 = a2[3];
          uint64_t v23 = 48 * *((unsigned __int16 *)a2 + 16);
          while (strcmp((const char *)(v21 + v22 + 7), "0000"))
          {
            v22 += 48;
            if (v23 == v22) {
              goto LABEL_16;
            }
          }
          if (!v21) {
            goto LABEL_17;
          }
          uint64_t v35 = v21 + v22;
          uint64_t v36 = *(void *)(v35 + 24);
          if (!v36) {
            goto LABEL_16;
          }
          long long v37 = (void *)heap_Calloc(*(void **)(*a2 + 8), 1, 8 * *(unsigned __int8 *)(v36 + 1296) - 8);
          if (!v37) {
            return 2314215434;
          }
          uint64_t v24 = (uint64_t)v37;
          uint64_t inited = hlp_initFeatureVector(*a2, v37, (unsigned __int16)(*(unsigned __int8 *)(*(void *)(v35 + 24) + 1296) - 1));
          if ((inited & 0x80000000) != 0)
          {
            uint64_t v21 = inited;
            goto LABEL_27;
          }
          uint64_t v39 = *a2;
          uint64_t v40 = *(void *)(v35 + 24);
          uint64_t v41 = *(void *)(v40 + 1312);
          unsigned int v42 = *(unsigned __int8 *)(v40 + 1296);
          long long v43 = *(_OWORD *)(a6 + 48);
          v58[2] = *(_OWORD *)(a6 + 32);
          v58[3] = v43;
          v58[4] = *(_OWORD *)(a6 + 64);
          uint64_t v59 = *(void *)(a6 + 80);
          long long v44 = *(_OWORD *)(a6 + 16);
          v58[0] = *(_OWORD *)a6;
          v58[1] = v44;
          hlp_setFeatureVector(v39, v24, v41, v42, v10, a3, 0xFFFFFFFF, 0, 0, (uint64_t)v58);
          uint64_t v21 = igtree_Process(*(void *)(v35 + 24), v24, &v60);
          if ((v21 & 0x80000000) != 0) {
            goto LABEL_27;
          }
          unsigned __int16 v45 = *(unsigned __int8 *)(*(void *)(v35 + 24) + 1296) - 1;
          if (*(unsigned char *)(*(void *)(v35 + 24) + 1296) != 1)
          {
            uint64_t v46 = *a2;
            uint64_t v47 = v45;
            uint64_t v48 = (uint64_t *)v24;
            do
            {
              uint64_t v49 = *v48++;
              heap_Free(*(void **)(v46 + 8), v49);
              --v47;
            }
            while (v47);
          }
          uint64_t v50 = v60;
          if (strcmp(v60, "NOMATCH"))
          {
            uint64_t v51 = *v13 + 16 * v14;
            uint64_t v52 = *(unsigned __int16 *)(v51 + 8);
            if (*(_WORD *)(v51 + 8))
            {
              uint64_t v53 = 0;
              uint64_t v56 = *v13;
              unsigned int v54 = *(const char ***)(*v13 + 16 * v14);
              while (strcmp(v50, *v54))
              {
                ++v53;
                v54 += 7;
                if (v52 == v53) {
                  goto LABEL_18;
                }
              }
              *(_WORD *)(v56 + 16 * v14 + 12) = v53;
              goto LABEL_25;
            }
          }
          goto LABEL_18;
        }
        unsigned int NextUtf8Offset = utf8_GetNextUtf8Offset(*v18, NextUtf8Offset);
        if ((utf8_getUTF8Char((uint64_t)*v18, NextUtf8Offset, v62) & 0x80000000) != 0) {
          return 0;
        }
      }
    }
    return 0;
  }
  return v21;
}

uint64_t stat_hmogrph_disambiguatePhons(uint64_t a1, uint64_t a2)
{
  __int16 v27 = 0;
  int v26 = 0;
  unsigned int v2 = *(unsigned __int16 *)(a2 + 16);
  if (!*(_WORD *)(a2 + 16)) {
    return 0;
  }
  unint64_t v5 = 0;
  uint64_t result = 0;
  uint64_t v7 = (long long *)(a1 + 392);
  do
  {
    unint64_t v8 = *(void *)(a2 + 8) + (v5 << 6);
    int v10 = *(unsigned __int16 *)(v8 + 56);
    uint64_t v9 = (unsigned __int16 *)(v8 + 56);
    if (!v10) {
      goto LABEL_17;
    }
    uint64_t v11 = 0;
    unint64_t v12 = 0;
    uint64_t v13 = (uint64_t *)(*(void *)(a2 + 8) + (v5 << 6) + 48);
    do
    {
      uint64_t v14 = *v13;
      if (*(_WORD *)(*v13 + v11 + 8) == 1)
      {
        __int16 v19 = 0;
LABEL_14:
        *(_WORD *)(v14 + v11 + 12) = v19;
        goto LABEL_15;
      }
      if (!*(_WORD *)(*v13 + v11 + 8)) {
        return result;
      }
      long long v15 = *(_OWORD *)(a1 + 440);
      long long v22 = *(_OWORD *)(a1 + 424);
      long long v23 = v15;
      long long v24 = *(_OWORD *)(a1 + 456);
      uint64_t v25 = *(void *)(a1 + 472);
      long long v16 = *(_OWORD *)(a1 + 408);
      long long v20 = *v7;
      long long v21 = v16;
      uint64_t result = hlp_disamSpecialWords(a1, (uint64_t *)a2, (unsigned __int16)v5, (unsigned __int16)v12, &v26, (uint64_t)&v20);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      if (v26 != 1)
      {
        long long v17 = *(_OWORD *)(a1 + 440);
        long long v22 = *(_OWORD *)(a1 + 424);
        long long v23 = v17;
        long long v24 = *(_OWORD *)(a1 + 456);
        uint64_t v25 = *(void *)(a1 + 472);
        long long v18 = *(_OWORD *)(a1 + 408);
        long long v20 = *v7;
        long long v21 = v18;
        uint64_t result = hlp_disamCharByChar(a2, (unsigned __int16)v5, (unsigned __int16)v12, &v27, &v26, (uint64_t)&v20);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        __int16 v19 = v27;
        if (v26 != 1) {
          __int16 v19 = 0;
        }
        uint64_t v14 = *v13;
        goto LABEL_14;
      }
LABEL_15:
      ++v12;
      v11 += 16;
    }
    while (v12 < *v9);
    unsigned int v2 = *(unsigned __int16 *)(a2 + 16);
LABEL_17:
    ++v5;
  }
  while (v5 < v2);
  return result;
}

uint64_t hlp_CallDepesFunc(void *a1)
{
  int v2 = 0;
  uint64_t v56 = *MEMORY[0x263EF8340];
  uint64_t v53 = 0;
  unsigned int v54 = 0;
  unsigned __int16 v52 = 0;
  *(unsigned char *)a1[19] = 0;
  *(unsigned char *)a1[21] = 0;
  while (1)
  {
    strcpy(__s, "cross_token");
    unsigned __int16 v3 = strlen(__s);
    int v4 = (unsigned __int16)v2;
    if ((_WORD)v2)
    {
      *(_WORD *)(a1[19] + strlen((const char *)a1[19])) = 32;
      *(_WORD *)(a1[21] + strlen((const char *)a1[21])) = 32;
    }
    uint64_t v5 = a1[13];
    uint64_t v6 = (unsigned __int16)v2;
    unsigned int v7 = *(unsigned __int8 *)(v5 + (unsigned __int16)v2);
    if (*(unsigned char *)(v5 + (unsigned __int16)v2))
    {
      uint64_t v8 = (unsigned __int16)v2;
      while ((v7 > 0x20 || ((1 << v7) & 0x100002600) == 0) && v7 != 95)
      {
        uint64_t v8 = (unsigned __int16)++v2;
        unsigned int v7 = *(unsigned __int8 *)(v5 + (unsigned __int16)v2);
        if (!*(unsigned char *)(v5 + (unsigned __int16)v2))
        {
          int v51 = 1;
          goto LABEL_12;
        }
      }
      int v51 = 0;
LABEL_12:
      int v9 = (unsigned __int16)v2;
    }
    else
    {
      int v51 = 1;
      int v9 = (unsigned __int16)v2;
      uint64_t v8 = (unsigned __int16)v2;
    }
    *(unsigned char *)(v5 + v8) = 0;
    unsigned __int16 v10 = Utf8_LengthInUtf8chars(a1[13], v9);
    unsigned __int16 v11 = Utf8_LengthInUtf8chars(a1[13], v4);
    *(unsigned char *)(a1[14] + v10) = 0;
    log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"%s L1: %s", v12, v13, v14, (uint64_t)__s);
    unsigned __int16 v15 = strlen((const char *)(a1[13] + v6));
    uint64_t v16 = (*(uint64_t (**)(void, void, void, uint64_t, void))(a1[9] + 120))(a1[7], a1[8], 0, a1[13] + v6, v15);
    if ((v16 & 0x80000000) != 0) {
      return v16;
    }
    log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"%s L2: %s", v17, v18, v19, (uint64_t)__s);
    unsigned __int16 v20 = strlen((const char *)(a1[14] + v11));
    uint64_t v16 = (*(uint64_t (**)(void, void, uint64_t, void, void))(a1[9] + 120))(a1[7], a1[8], 1, a1[14] + v11, v20);
    if ((v16 & 0x80000000) != 0) {
      return v16;
    }
    if (((*(uint64_t (**)(void, void, char *))(a1[9] + 80))(a1[7], a1[8], __s) & 0x80000000) != 0)
    {
      __s[v3] = 0;
      uint64_t v16 = (*(uint64_t (**)(void, void, char *))(a1[9] + 80))(a1[7], a1[8], __s);
      if ((v16 & 0x80000000) != 0) {
        return v16;
      }
    }
    uint64_t v16 = (*(uint64_t (**)(void, void, void, char **, unsigned __int16 *))(a1[9] + 128))(a1[7], a1[8], 0, &v54, &v52);
    if ((v16 & 0x80000000) != 0) {
      return v16;
    }
    v54[v52] = 0;
    log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"%s O1: %s", v21, v22, v23, (uint64_t)__s);
    uint64_t v27 = (*(uint64_t (**)(void, void, uint64_t, uint64_t *, unsigned __int16 *))(a1[9] + 128))(a1[7], a1[8], 1, &v53, &v52);
    if ((v27 & 0x80000000) != 0) {
      return v27;
    }
    *(unsigned char *)(v53 + v52) = 0;
    log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"%s O2: %s", v24, v25, v26, (uint64_t)__s);
    uint64_t v28 = v54;
    if (*v54)
    {
      uint64_t v29 = 0;
      int v30 = 0;
      do
      {
        uint64_t v31 = &v28[v29];
        if (v28[v29] == 126)
        {
          int v32 = &v28[v29 + 1];
          size_t v33 = strlen(v32);
          memmove(v31, v32, v33 + 1);
          --v30;
        }
        else if (!strncmp(&v28[v29], "¡", 2uLL))
        {
          __int16 v34 = &v28[(unsigned __int16)v30 + 1];
          uint64_t v35 = &v28[(unsigned __int16)v30 + 2];
          size_t v36 = strlen(v35);
          memmove(v34, v35, v36 + 1);
          v54[v29] = 126;
        }
        uint64_t v29 = (unsigned __int16)++v30;
        uint64_t v28 = v54;
        size_t v37 = strlen(v54);
      }
      while (v37 > (unsigned __int16)v30);
      __int16 v38 = v37;
    }
    else
    {
      __int16 v38 = 0;
    }
    uint64_t v39 = (char *)a1[19];
    unsigned __int16 v40 = v38 + strlen(v39) + 2;
    if (v40 >= 0x81u) {
      break;
    }
LABEL_32:
    strcat(v39, v28);
    for (unsigned __int16 i = 0; ; ++i)
    {
      uint64_t v47 = i;
      int v48 = *(unsigned __int8 *)(v53 + i);
      if (v48 != 32 && v48 != 126) {
        break;
      }
    }
    if (!*(unsigned char *)(v53 + i)) {
      goto LABEL_42;
    }
    while (v48 != 32 && v48 != 126)
      LOBYTE(v48) = *(unsigned char *)(v53 + ++i);
    *(unsigned char *)(v53 + i) = 0;
    if (*(unsigned char *)(v53 + v47)) {
      strcat((char *)a1[21], (const char *)(v53 + v47));
    }
    else {
LABEL_42:
    }
      *(_WORD *)(a1[21] + strlen((const char *)a1[21])) = 42;
    ++v2;
    if (v51) {
      return v27;
    }
  }
  uint64_t v41 = heap_Realloc(*(uint64_t **)(*a1 + 8), (uint64_t)v39, v40);
  if (v41)
  {
    uint64_t v39 = (char *)v41;
    a1[19] = v41;
    uint64_t v28 = v54;
    goto LABEL_32;
  }
  log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v42, v43, v44, v45, v50);
  return 2314215434;
}

uint64_t hlp_AppendPhon(uint64_t a1, char *a2, char *__s, uint64_t a4)
{
  if (strlen(__s) >= 2 && !strchr(__s, 32)) {
    __s[1] = 0;
  }
  if (strlen((const char *)a4) >= 2 && !strchr((char *)a4, 32)) {
    *(unsigned char *)(a4 + 1) = 0;
  }
  if (!*a2) {
    return 0;
  }
  uint64_t v8 = *(const char **)(a1 + 152);
  __int16 v9 = strlen(v8);
  unsigned __int16 v10 = v9 + strlen(a2) + 7;
  if (v10 >= 0x81u)
  {
    uint64_t v11 = v10;
    uint64_t v12 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), (uint64_t)v8, v10);
    if (!v12
      || (*(void *)(a1 + 152) = v12,
          (uint64_t v17 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 168), v11)) == 0))
    {
      uint64_t v34 = 2314215434;
      log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v13, v14, v15, v16, v39);
      return v34;
    }
    *(void *)(a1 + 168) = v17;
    uint64_t v8 = *(const char **)(a1 + 152);
  }
  *(_DWORD *)&v8[strlen(v8)] = 8689634;
  *(_WORD *)(*(void *)(a1 + 168) + strlen(*(const char **)(a1 + 168))) = 32;
  uint64_t v18 = strstr(a2, "◄");
  if (strchr(__s, 32) || !v18)
  {
    strcat(*(char **)(a1 + 152), a2);
    strcat(*(char **)(a1 + 168), (const char *)a4);
    int v35 = strlen(a2);
    unsigned int v36 = (unsigned __int16)Utf8_LengthInUtf8chars((unint64_t)a2, v35);
    if (v36 > (unsigned __int16)strlen((const char *)a4))
    {
      int v37 = 0;
      do
      {
        *(_WORD *)(*(void *)(a1 + 168) + strlen(*(const char **)(a1 + 168))) = 126;
        ++v37;
      }
      while ((int)(v36 - (unsigned __int16)strlen((const char *)a4)) > (unsigned __int16)v37);
    }
  }
  else
  {
    uint64_t v19 = strstr(v18 + 3, "◄");
    if (!v19)
    {
      log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v20, v21, v22, v23, v39);
      return 2314215431;
    }
    uint64_t v24 = v19;
    strncat(*(char **)(a1 + 152), a2, (unsigned __int16)((_WORD)v18 - (_WORD)a2 + 3));
    if ((unsigned __int16)Utf8_LengthInUtf8chars((unint64_t)a2, (int)v18 - (int)a2 + 3))
    {
      int v25 = 0;
      do
      {
        *(_WORD *)(*(void *)(a1 + 168) + strlen(*(const char **)(a1 + 168))) = 32;
        ++v25;
      }
      while ((unsigned __int16)Utf8_LengthInUtf8chars((unint64_t)a2, (int)v18 - (int)a2 + 3) > (unsigned __int16)v25);
    }
    strncat(*(char **)(a1 + 152), v18 + 3, (unsigned __int16)((_WORD)v24 - (_WORD)v18 - 3));
    strcat(*(char **)(a1 + 168), (const char *)a4);
    __int16 v26 = Utf8_LengthInUtf8chars((unint64_t)v18, (int)v24 - (int)v18);
    if (~(__int16)strlen((const char *)a4) + v26 >= 1)
    {
      int v27 = 0;
      do
      {
        *(_WORD *)(*(void *)(a1 + 168) + strlen(*(const char **)(a1 + 168))) = 126;
        ++v27;
      }
      while (v26 + ~(__int16)strlen((const char *)a4) > (__int16)v27);
    }
    strcat(*(char **)(a1 + 152), v24);
    int v28 = v24 - a2;
    int v29 = strlen(a2);
    signed int v30 = Utf8_LengthInUtf8chars((unint64_t)a2, v29) << 16;
    if (v30 > (int)(Utf8_LengthInUtf8chars((unint64_t)a2, v28) << 16))
    {
      int v31 = 0;
      do
      {
        *(_WORD *)(*(void *)(a1 + 168) + strlen(*(const char **)(a1 + 168))) = 32;
        ++v31;
        int v32 = strlen(a2);
        int v33 = (__int16)Utf8_LengthInUtf8chars((unint64_t)a2, v32);
      }
      while (v33 - (__int16)Utf8_LengthInUtf8chars((unint64_t)a2, v28) > (__int16)v31);
    }
  }
  *(_DWORD *)(*(void *)(a1 + 152) + strlen(*(const char **)(a1 + 152))) = 8689634;
  uint64_t v34 = 0;
  *(_WORD *)(*(void *)(a1 + 168) + strlen(*(const char **)(a1 + 168))) = 32;
  return v34;
}

uint64_t hlp_ProcessNTokens(void *a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  *(unsigned char *)a1[19] = 0;
  *(unsigned char *)a1[21] = 0;
  unsigned int v5 = *(unsigned __int16 *)(a2 + 16);
  if (*(_WORD *)(a2 + 16))
  {
    uint64_t v8 = 0;
    unsigned int v36 = a4;
    while (1)
    {
      uint64_t v9 = *(void *)(a2 + 8);
      uint64_t v10 = v9 + (v8 << 6);
      if (*(unsigned __int16 *)(v10 + 8) >= a3 && *(unsigned __int16 *)(v10 + 10) <= a4)
      {
        uint64_t v11 = v9 + (v8 << 6);
        uint64_t v12 = (unsigned __int16 *)(v11 + 56);
        if (*(_WORD *)(v11 + 56)) {
          break;
        }
      }
LABEL_10:
      if (++v8 >= (unint64_t)v5) {
        goto LABEL_11;
      }
    }
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    uint64_t v15 = (void *)(v11 + 48);
    while (1)
    {
      uint64_t v16 = *(void *)(*v15 + v13) + 56 * *(unsigned __int16 *)(*v15 + v13 + 12);
      strcpy((char *)a1[22], *(const char **)(v16 + 32));
      uint64_t appended = hlp_AppendPhon((uint64_t)a1, *(char **)v16, *(char **)(v16 + 16), *(void *)(v16 + 24));
      if ((appended & 0x80000000) != 0) {
        return appended;
      }
      ++v14;
      v13 += 16;
      if (v14 >= *v12)
      {
        unsigned int v5 = *(unsigned __int16 *)(a2 + 16);
        a4 = v36;
        goto LABEL_10;
      }
    }
  }
LABEL_11:
  unsigned __int16 v18 = (2 * strlen((const char *)a1[19])) | 1;
  uint64_t v19 = (char *)a1[13];
  if (!v19 || *((unsigned __int16 *)a1 + 60) < v18)
  {
    uint64_t v20 = heap_Realloc(*(uint64_t **)(*a1 + 8), a1[13], v18);
    if (!v20) {
      goto LABEL_33;
    }
    uint64_t v19 = (char *)v20;
    a1[13] = v20;
    a1[15] = v18;
  }
  uint64_t v25 = a1[14];
  if (v25 && *((unsigned __int16 *)a1 + 64) >= v18) {
    goto LABEL_19;
  }
  uint64_t v26 = heap_Realloc(*(uint64_t **)(*a1 + 8), v25, v18);
  if (!v26)
  {
LABEL_33:
    uint64_t v34 = 2314215434;
    log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v21, v22, v23, v24, v35);
    return v34;
  }
  a1[14] = v26;
  a1[16] = v18;
  uint64_t v19 = (char *)a1[13];
LABEL_19:
  strcpy(v19, (const char *)a1[19]);
  strcpy((char *)a1[14], (const char *)a1[21]);
  int v27 = (const char *)a1[13];
  if (*v27)
  {
    uint64_t v28 = 0;
    BOOL v29 = 0;
    int v30 = 0;
    do
    {
      if (!strncmp(&v27[v28], "◄", 3uLL))
      {
        BOOL v29 = !v29;
      }
      else if (v27[v28] == 126 && v29)
      {
        size_t v32 = strlen(&v27[v28]);
        memmove((void *)&v27[v28 + 1], &v27[v28], v32 + 1);
        *(_WORD *)(a1[13] + v28) = -24126;
        int v27 = (const char *)a1[13];
        BOOL v29 = 1;
      }
      uint64_t v28 = (unsigned __int16)++v30;
    }
    while (strlen(v27) > (unsigned __int16)v30);
  }
  return hlp_CallDepesFunc(a1);
}

uint64_t stat_hmogrph_updateLingdb(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v123 = *MEMORY[0x263EF8340];
  unsigned __int16 v101 = 0;
  int v99 = 0;
  int v100 = 0;
  int v97 = 0;
  int v98 = 0;
  int v95 = 0;
  unsigned int v96 = 0;
  uint64_t v94 = 0;
  memset(v122, 0, 64);
  unsigned __int16 v93 = 0;
  long long v120 = 0u;
  long long v121 = 0u;
  long long v118 = 0u;
  long long v119 = 0u;
  long long v116 = 0u;
  long long v117 = 0u;
  long long v114 = 0u;
  long long v115 = 0u;
  long long v112 = 0u;
  long long v113 = 0u;
  long long v111 = 0u;
  long long v109 = 0u;
  long long v110 = 0u;
  long long v107 = 0u;
  long long v108 = 0u;
  *(_OWORD *)long long __s = 0u;
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, unsigned __int16 *))(a2 + 104))(a3, a4, 1, 0, &v101);
  if ((v12 & 0x80000000) != 0) {
    return v12;
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, int *))(a2 + 184))(a3, a4, v101, 0, &v97);
  if ((v13 & 0x80000000) == 0)
  {
    uint64_t v92 = a6;
    if ((unsigned __int16)v97 == 1)
    {
      uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t *, int *))(a2 + 176))(a3, a4, v101, 0, &v94, &v98);
      if ((v13 & 0x80000000) == 0 && (unsigned __int16)v98 >= 2u)
      {
        uint64_t updated = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *))(a2 + 104))(a3, a4, 2, v101, (char *)&v100 + 2);
        if ((updated & 0x80000000) != 0) {
          goto LABEL_123;
        }
        int v15 = 0;
        int v16 = 0;
        int v17 = 0;
        uint64_t v91 = a5;
        while (1)
        {
          if (!HIWORD(v100))
          {
            if (v122[0])
            {
              if (v96 == 4 && v15 == 0)
              {
                uint64_t v71 = v93;
                if (v93)
                {
                  if (v93 != 1)
                  {
                    uint64_t v81 = a1;
                    uint64_t v73 = 0;
                    unsigned __int16 v74 = 0;
                    unsigned __int16 v75 = 10000;
                    while (1)
                    {
                      uint64_t updated = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(a2 + 168))(a3, a4, (unsigned __int16)v122[v73], 7, 1, (char *)&v98 + 2, &v98);
                      if ((updated & 0x80000000) != 0) {
                        goto LABEL_123;
                      }
                      if (HIWORD(v98) < v75)
                      {
                        unsigned __int16 v75 = HIWORD(v98);
                        unsigned __int16 v74 = v73;
                      }
                      if (v71 == ++v73)
                      {
                        __int16 v76 = strlen(__s[v74]);
                        uint64_t updated = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, char *, char *))(a2 + 160))(a3, a4, (unsigned __int16)v122[v74], 3, (unsigned __int16)(v76 + 1), __s[v74], (char *)&v97 + 2);
                        a1 = v81;
                        if ((updated & 0x80000000) != 0) {
                          goto LABEL_123;
                        }
                        goto LABEL_117;
                      }
                    }
                  }
                  __int16 v72 = strlen(__s[0]);
                  uint64_t updated = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, char *, char *))(a2 + 160))(a3, a4, v122[0], 3, (unsigned __int16)(v72 + 1), __s[0], (char *)&v97 + 2);
                  if ((updated & 0x80000000) != 0)
                  {
LABEL_123:
                    uint64_t v13 = updated;
                    goto LABEL_124;
                  }
                }
              }
LABEL_117:
              hlp_freeWordPhoneList((void *)a5, &v93, (uint64_t)v122, (uint64_t)__s);
            }
            if (!*(_DWORD *)(a1 + 144)
              || (uint64_t updated = hlp_updateLingdb_process_skipcrosstoekn_cleanup(a1, a2, a3, a4, v101),
                  (updated & 0x80000000) == 0))
            {
              uint64_t updated = hlp_updateLingdb_delete_duplicated_words(*(void *)a1, a2, a3, a4, a5, v101, *(_DWORD *)(a1 + 384), v92);
              if ((updated & 0x80000000) == 0)
              {
                uint64_t v13 = stat_hmogrph_selectSubOrWholeRcd(a1, a2, a3, a4, (uint64_t *)a5);
                if ((v13 & 0x80000000) != 0) {
                  return v13;
                }
                goto LABEL_124;
              }
            }
            goto LABEL_123;
          }
          uint64_t updated = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 168))(a3, a4);
          if ((updated & 0x80000000) != 0) {
            goto LABEL_123;
          }
          uint64_t updated = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(a2 + 168))(a3, a4, HIWORD(v100), 1, 1, (char *)&v99 + 2, &v98);
          if ((updated & 0x80000000) != 0) {
            goto LABEL_123;
          }
          uint64_t updated = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, int *))(a2 + 168))(a3, a4, HIWORD(v100), 2, 1, &v99, &v98);
          if ((updated & 0x80000000) != 0) {
            goto LABEL_123;
          }
          if (HIWORD(v99) > (unsigned __int16)v99)
          {
            uint64_t v13 = 2314223281;
LABEL_124:
            hlp_freeWordPhoneList((void *)a5, &v93, (uint64_t)v122, (uint64_t)__s);
            return v13;
          }
          if (HIWORD(v99) == (unsigned __int16)v16 && (unsigned __int16)v99 == (unsigned __int16)v17)
          {
            unsigned int v18 = v96;
            if (v96 == 4) {
              break;
            }
          }
          uint64_t updated = (*(uint64_t (**)(uint64_t, uint64_t, void, int *))(*(void *)(a1 + 48) + 136))(a3, a4, HIWORD(v100), &v100);
          if ((updated & 0x80000000) != 0) {
            goto LABEL_123;
          }
          if ((_WORD)v100)
          {
            uint64_t updated = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 + 48) + 168))(a3, a4);
            if ((updated & 0x80000000) != 0) {
              goto LABEL_123;
            }
          }
          if (v95 == 4 && !v15)
          {
            uint64_t v19 = v93;
            if (v93)
            {
              int v85 = v16;
              uint64_t v20 = a1;
              if (v93 == 1)
              {
                __int16 v21 = strlen(__s[0]);
                uint64_t updated = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, char *, char *))(a2 + 160))(a3, a4, v122[0], 3, (unsigned __int16)(v21 + 1), __s[0], (char *)&v97 + 2);
              }
              else
              {
                int v88 = v17;
                uint64_t v22 = 0;
                unsigned __int16 v23 = 0;
                unsigned __int16 v24 = 10000;
                do
                {
                  uint64_t updated = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(a2 + 168))(a3, a4, (unsigned __int16)v122[v22], 7, 1, (char *)&v98 + 2, &v98);
                  if ((updated & 0x80000000) != 0) {
                    goto LABEL_123;
                  }
                  if (HIWORD(v98) < v24)
                  {
                    unsigned __int16 v24 = HIWORD(v98);
                    unsigned __int16 v23 = v22;
                  }
                  ++v22;
                }
                while (v19 != v22);
                __int16 v25 = strlen(__s[v23]);
                uint64_t updated = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, char *, char *))(a2 + 160))(a3, a4, (unsigned __int16)v122[v23], 3, (unsigned __int16)(v25 + 1), __s[v23], (char *)&v97 + 2);
                int v16 = v85;
                int v17 = v88;
              }
              a1 = v20;
              int v15 = 0;
              if ((updated & 0x80000000) != 0) {
                goto LABEL_123;
              }
            }
          }
          hlp_freeWordPhoneList((void *)a5, &v93, (uint64_t)v122, (uint64_t)__s);
          unsigned int v18 = v96;
          if (v96 <= 0xA && ((1 << v96) & 0x610) != 0) {
            break;
          }
LABEL_63:
          uint64_t updated = (*(uint64_t (**)(uint64_t, uint64_t, void, char *))(a2 + 120))(a3, a4, HIWORD(v100), (char *)&v100 + 2);
          if ((updated & 0x80000000) != 0) {
            goto LABEL_123;
          }
        }
        if (HIWORD(v99) != (unsigned __int16)v16 || (unsigned __int16)v99 != (unsigned __int16)v17)
        {
          int v15 = 0;
          int v16 = HIWORD(v99);
          int v17 = (unsigned __int16)v99;
        }
        if (v18 == 9)
        {
          uint64_t updated = (*(uint64_t (**)(uint64_t, uint64_t, void, int *))(*(void *)(a1 + 48) + 136))(a3, a4, HIWORD(v100), &v100);
          if ((updated & 0x80000000) != 0) {
            goto LABEL_123;
          }
          if ((_WORD)v100)
          {
            uint64_t updated = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 + 48) + 168))(a3, a4);
            if ((updated & 0x80000000) != 0) {
              goto LABEL_123;
            }
          }
        }
        if (*(_DWORD *)(a1 + 144) && v96 == 9 && v95 == 17)
        {
          uint64_t updated = hlp_ProcessNTokens((void *)a1, a5, HIWORD(v99), (unsigned __int16)v99);
          if ((updated & 0x80000000) != 0) {
            goto LABEL_123;
          }
          __int16 v26 = strlen(*(const char **)(a1 + 152));
          uint64_t v27 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, void, char *))(*(void *)(a1 + 48) + 160))(a3, a4, HIWORD(v100), 3, (unsigned __int16)(v26 + 1), *(void *)(a1 + 152), (char *)&v97 + 2);
          if ((v27 & 0x80000000) == 0)
          {
            __int16 v28 = strlen(*(const char **)(a1 + 168));
            uint64_t v27 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, void, char *))(*(void *)(a1 + 48) + 160))(a3, a4, HIWORD(v100), 6, (unsigned __int16)(v28 + 1), *(void *)(a1 + 168), (char *)&v97 + 2);
            if ((v27 & 0x80000000) == 0)
            {
              HIWORD(v98) = 4;
              uint64_t v27 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, char *))(*(void *)(a1 + 48) + 160))(a3, a4, HIWORD(v100), 7, 1, (char *)&v98 + 2, (char *)&v97 + 2);
              if ((v27 & 0x80000000) == 0)
              {
                BOOL v29 = *(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, const char *, char *))(*(void *)(a1 + 48) + 160);
                uint64_t v30 = a1;
                int v31 = *(const char **)(a1 + 176);
                __int16 v32 = strlen(v31);
                int v33 = v31;
                a1 = v30;
                uint64_t updated = v29(a3, a4, HIWORD(v100), 9, (unsigned __int16)(v32 + 1), v33, (char *)&v97 + 2);
                a5 = v91;
                if ((updated & 0x80000000) != 0) {
                  goto LABEL_123;
                }
                goto LABEL_63;
              }
            }
          }
          uint64_t v13 = v27;
          a5 = v91;
          goto LABEL_124;
        }
        int v83 = (unsigned __int16)v99;
        uint64_t v84 = HIWORD(v99);
        uint64_t v34 = v93;
        int v105 = 0;
        __int16 v104 = 0;
        __src = 0;
        __int16 v102 = 0;
        unsigned int v90 = HIWORD(v100);
        uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 184))(a3, a4);
        if ((v13 & 0x80000000) == 0 && v102)
        {
          int v89 = v17;
          uint64_t v35 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, int *))(a2 + 176))(a3, a4, v90, 3, &__src, &v105);
          if ((v35 & 0x80000000) != 0)
          {
            uint64_t v13 = v35;
            goto LABEL_124;
          }
          __int16 v102 = 0;
          uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, __int16 *))(a2 + 184))(a3, a4, v90, 7, &v102);
          if ((v13 & 0x80000000) == 0)
          {
            if (v102)
            {
              uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(a2 + 168))(a3, a4, v90, 7, 1, (char *)&v105 + 2, &v105);
              if ((v13 & 0x80000000) != 0) {
                goto LABEL_124;
              }
              unsigned __int16 v36 = strlen(__src);
              int v37 = (char *)heap_Calloc(*(void **)(*(void *)a5 + 8), 1, v36 + 1);
              __s[v34] = v37;
              if (!v37)
              {
LABEL_126:
                uint64_t v13 = 2314215434;
                log_OutPublic(*(void *)(*(void *)a5 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v38, v39, v40, v41, v78);
                goto LABEL_124;
              }
              strcpy(v37, __src);
              uint64_t v42 = *(unsigned __int16 *)(a5 + 16);
              if (!*(_WORD *)(a5 + 16)) {
                goto LABEL_62;
              }
              int v87 = v15;
              uint64_t v80 = a1;
              uint64_t v43 = (_WORD *)(*(void *)(a5 + 8) + 56);
              while ((unsigned __int16)*(v43 - 24) != v84 || (unsigned __int16)*(v43 - 23) != v83)
              {
                v43 += 32;
                if (!--v42)
                {
                  a1 = v80;
                  goto LABEL_61;
                }
              }
              uint64_t v79 = v34;
              int v86 = v16;
              uint64_t v44 = (unsigned __int16)*v43;
              if (*v43)
              {
                unsigned __int16 v45 = 0;
                uint64_t v46 = (unsigned __int16 *)(*((void *)v43 - 1) + 12);
                do
                {
                  unsigned int v47 = *v46;
                  unsigned int v48 = *(v46 - 2);
                  if (v48 <= v47) {
                    LOWORD(v47) = v48 - 1;
                  }
                  int v49 = strlen(*(const char **)(*(void *)(v46 - 6) + 56 * (unsigned __int16)v47));
                  if (v49) {
                    v45 += v49 + 1;
                  }
                  v46 += 8;
                  --v44;
                }
                while (v44);
              }
              else
              {
                unsigned __int16 v45 = 0;
              }
              unsigned int v50 = (char *)heap_Calloc(*(void **)(*(void *)a5 + 8), 1, v45 + 1);
              if (!v50) {
                goto LABEL_126;
              }
              unsigned __int16 v82 = v45;
              char *v50 = 0;
              if (*v43)
              {
                uint64_t v51 = 0;
                for (unint64_t i = 0; i < v60; ++i)
                {
                  uint64_t v53 = (uint64_t *)(*((void *)v43 - 1) + v51);
                  unsigned int v54 = *((unsigned __int16 *)v53 + 6);
                  unsigned int v55 = *((unsigned __int16 *)v53 + 4);
                  if (v55 <= v54) {
                    LOWORD(v54) = v55 - 1;
                  }
                  uint64_t v56 = *v53;
                  uint64_t v57 = 56 * (unsigned __int16)v54;
                  unsigned __int16 v58 = v50;
                  strcat(v50, *(const char **)(*v53 + v57));
                  uint64_t v59 = *(char **)(v56 + v57);
                  unint64_t v60 = (unsigned __int16)*v43;
                  if (*v59) {
                    BOOL v61 = i == v60 - 1;
                  }
                  else {
                    BOOL v61 = 1;
                  }
                  if (!v61)
                  {
                    if (!strstr(v59, "{SEP"))
                    {
                      *(_WORD *)&v58[strlen(v58)] = 46;
                      unsigned int v50 = (char *)v58;
                      unint64_t v60 = (unsigned __int16)*v43;
                      goto LABEL_87;
                    }
                    --v82;
                  }
                  unsigned int v50 = (char *)v58;
LABEL_87:
                  v51 += 16;
                }
              }
              if (v82 >= 2u) {
                v50[v82 - 1] = 0;
              }
              uint64_t v62 = (uint64_t)v50;
              int v16 = v86;
              int v15 = v87;
              a5 = v91;
              int v17 = v89;
              if (strcmp(v50, __src) | v87)
              {
                uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, const char *, __int16 *))(a2 + 160))(a3, a4, v90, 3, 8, "DELETED", &v104);
                uint64_t v69 = *(void *)v91;
                if ((v13 & 0x80000000) != 0)
                {
                  heap_Free(*(void **)(v69 + 8), v62);
                  goto LABEL_124;
                }
                log_OutText(*(void *)(v69 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"DELETED: from %d to %d, orth %s with phon %s and priority %d", v66, v67, v68, v84);
              }
              else
              {
                log_OutText(*(void *)(*(void *)v91 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"from %d to %d, orth %s, disambiguated phon %s, priority %d", v63, v64, v65, v84);
                int v15 = 1;
              }
              heap_Free(*(void **)(*(void *)v91 + 8), v62);
              uint64_t v34 = v79;
              a1 = v80;
            }
          }
        }
LABEL_61:
        if ((v13 & 0x80000000) != 0) {
          goto LABEL_124;
        }
LABEL_62:
        v122[v34] = HIWORD(v100);
        unsigned __int16 v93 = v34 + 1;
        goto LABEL_63;
      }
    }
  }
  return v13;
}

void *hlp_freeWordPhoneList(void *result, _WORD *a2, uint64_t a3, uint64_t a4)
{
  unsigned int v7 = result;
  for (uint64_t i = 0; i != 32; ++i)
  {
    if (*(_WORD *)(a3 + 2 * i)) {
      *(_WORD *)(a3 + 2 * i) = 0;
    }
    uint64_t v9 = *(void *)(a4 + 8 * i);
    if (v9)
    {
      uint64_t result = heap_Free(*(void **)(*v7 + 8), v9);
      *(void *)(a4 + 8 * i) = 0;
    }
  }
  *a2 = 0;
  return result;
}

uint64_t hlp_updateLingdb_process_skipcrosstoekn_cleanup(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v15 = 0;
  int v16 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char *))(a2 + 104))(a3, a4, 2, a5, (char *)&v16 + 2);
  if ((result & 0x80000000) == 0)
  {
    unsigned __int16 v11 = HIWORD(v16);
    if (HIWORD(v16))
    {
      uint64_t v12 = 0;
      do
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, int *, int *))(a2 + 168))(a3, a4, v11, 0, 1, &v15, &v16);
        if ((result & 0x80000000) != 0) {
          break;
        }
        if (v15 == 17)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)(a1 + 48) + 192))(a3, a4, HIWORD(v16));
          if ((result & 0x80000000) != 0) {
            return result;
          }
          HIWORD(v16) = v12;
          uint64_t v13 = v12;
        }
        else
        {
          uint64_t v13 = HIWORD(v16);
        }
        uint64_t v14 = *(void *)(a1 + 48);
        if ((_WORD)v13)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, char *))(v14 + 120))(a3, a4, (unsigned __int16)v13, (char *)&v16 + 2);
          uint64_t v12 = v13;
          if ((result & 0x80000000) != 0) {
            return result;
          }
        }
        else
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char *))(v14 + 104))(a3, a4, 2, a5, (char *)&v16 + 2);
          if ((result & 0x80000000) != 0) {
            return result;
          }
        }
        unsigned __int16 v11 = HIWORD(v16);
      }
      while (HIWORD(v16));
    }
  }
  return result;
}

uint64_t hlp_updateLingdb_delete_duplicated_words(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8)
{
  __s1 = 0;
  int v26 = 0;
  int v27 = 0;
  __int16 v25 = 0;
  unsigned int v24 = 0;
  uint64_t updated = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char *))(a2 + 104))(a3, a4, 2, a6, (char *)&v26 + 2);
  if ((updated & 0x80000000) == 0)
  {
    unsigned __int16 v15 = HIWORD(v26);
    if (HIWORD(v26))
    {
      unsigned __int16 v16 = 0;
      do
      {
        uint64_t updated = (*(uint64_t (**)(uint64_t, uint64_t, void, int *))(a2 + 120))(a3, a4, v15, &v26);
        if ((updated & 0x80000000) != 0) {
          break;
        }
        (*(void (**)(uint64_t, uint64_t, void, void, uint64_t, unsigned int *, __int16 *))(a2 + 168))(a3, a4, HIWORD(v26), 0, 1, &v24, &v25);
        if (v24 <= 0xA && ((1 << v24) & 0x610) != 0)
        {
          uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, __int16 *))(a2 + 168))(a3, a4, HIWORD(v26), 1, 1, (char *)&v27 + 2, &v25);
          if ((v18 & 0x80000000) != 0) {
            return v18;
          }
          uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, __int16 *))(a2 + 168))(a3, a4, HIWORD(v26), 2, 1, &v27, &v25);
          if ((v18 & 0x80000000) != 0) {
            return v18;
          }
          uint64_t updated = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, __int16 *))(a2 + 176))(a3, a4, HIWORD(v26), 3, &__s1, &v25);
          if ((updated & 0x80000000) != 0) {
            return updated;
          }
          if (!strcmp(__s1, "DELETED"))
          {
            uint64_t updated = (*(uint64_t (**)(uint64_t, uint64_t, void))(a2 + 192))(a3, a4, HIWORD(v26));
            if ((updated & 0x80000000) != 0) {
              return updated;
            }
            log_OutText(*(void *)(*(void *)a5 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"delete a word record from pos %d to pos %d", v19, v20, v21, HIWORD(v27));
          }
          else if (a7)
          {
            uint64_t updated = updateNLUNE(a1, a3, a4, a2, HIWORD(v26), v16, a8);
            if ((updated & 0x80000000) != 0) {
              return updated;
            }
            ++v16;
          }
        }
        unsigned __int16 v15 = v26;
        HIWORD(v26) = v26;
      }
      while ((_WORD)v26);
    }
  }
  return updated;
}

uint64_t stat_hmogrph_selectSubOrWholeRcd(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v5 = 0;
  int v77 = 0;
  if (a2 && a5)
  {
    int v78 = 0;
    int v75 = 0;
    int v76 = 0;
    unsigned int v7 = a5 + 1;
    if (*((_WORD *)a5 + 8))
    {
      uint64_t v8 = 0;
      for (unint64_t i = 0; i < *((unsigned __int16 *)a5 + 8); ++i)
      {
        uint64_t v10 = *v7;
        uint64_t v11 = *v7 + v8;
        uint64_t v12 = *(char **)(v11 + 24);
        if (!*v12)
        {
          if (stat_hmogrph_isSubWordRec((uint64_t)(a5 + 1), (unsigned __int16)i)) {
            *(_DWORD *)(v11 + 32) = 1;
          }
          else {
            *(_DWORD *)(v11 + 32) = 0;
          }
          goto LABEL_22;
        }
        int v13 = strcmp(*(const char **)(v11 + 24), "poi");
        int isSubWordRec = stat_hmogrph_isSubWordRec((uint64_t)(a5 + 1), (unsigned __int16)i);
        if (v13)
        {
          if (!isSubWordRec)
          {
            if (hlp_hasRcdWithGivenPOIClass(v11, v12)) {
              goto LABEL_15;
            }
            if (stat_hmogrph_hasSubWordWithGivenTn((uint64_t)(a5 + 1), (unsigned __int16)i, v12))
            {
              *(_DWORD *)(v10 + v8 + 32) = 1;
              unsigned __int16 v15 = (unsigned __int16 *)(a5 + 1);
              unsigned int v16 = (unsigned __int16)i;
              goto LABEL_20;
            }
LABEL_14:
            if (hlp_hasRcdWithGivenPOIClass(v11, "poi"))
            {
LABEL_15:
              *(_DWORD *)(v10 + v8 + 32) = 0;
              unsigned int v16 = (unsigned __int16)i;
              unsigned __int16 v15 = (unsigned __int16 *)(a5 + 1);
              goto LABEL_16;
            }
            hasSubWordWithGivenTuint64_t n = stat_hmogrph_hasSubWordWithGivenTn((uint64_t)(a5 + 1), (unsigned __int16)i, "poi");
            uint64_t v19 = v10 + v8;
            if (hasSubWordWithGivenTn)
            {
              *(_DWORD *)(v19 + 32) = 1;
              unsigned __int16 v15 = (unsigned __int16 *)(a5 + 1);
              unsigned int v16 = (unsigned __int16)i;
LABEL_20:
              int v17 = 0;
            }
            else
            {
              *(_DWORD *)(v19 + 32) = 0;
              unsigned __int16 v15 = (unsigned __int16 *)(a5 + 1);
              unsigned int v16 = (unsigned __int16)i;
LABEL_16:
              int v17 = 1;
            }
            stat_hmogrph_setWillBeDeleteOfSubWords(v15, v16, v17);
          }
        }
        else if (!isSubWordRec)
        {
          goto LABEL_14;
        }
LABEL_22:
        v8 += 64;
      }
    }
    uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *))(a2 + 104))(a3, a4, 1, 0, (char *)&v76 + 2);
    if ((v20 & 0x80000000) != 0)
    {
      return v20;
    }
    else
    {
      uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, int *))(a2 + 104))(a3, a4, 2, HIWORD(v76), &v76);
      if ((v5 & 0x80000000) == 0)
      {
        unsigned __int16 v21 = v76;
        if ((_WORD)v76)
        {
          do
          {
            uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t, void, char *))(a2 + 120))(a3, a4, v21, (char *)&v75 + 2);
            if ((v20 & 0x80000000) != 0) {
              return v20;
            }
            uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, int *, int *))(a2 + 168))(a3, a4, (unsigned __int16)v76, 0, 1, &v78, &v75);
            if ((v5 & 0x80000000) != 0) {
              return v5;
            }
            if (v78 == 4
              || (v78 == 9 ? (BOOL v22 = *(_DWORD *)(a1 + 144) == 0) : (BOOL v22 = 0),
                  !v22 ? (int v23 = 0) : (int v23 = 1),
                  v78 != 10 ? (BOOL v24 = v23 == 0) : (BOOL v24 = 0),
                  !v24))
            {
              uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(a2 + 168))(a3, a4, (unsigned __int16)v76, 1, 1, (char *)&v77 + 2, &v75);
              if ((v20 & 0x80000000) != 0) {
                return v20;
              }
              uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, int *))(a2 + 168))(a3, a4, (unsigned __int16)v76, 2, 1, &v77, &v75);
              if ((v20 & 0x80000000) != 0) {
                return v20;
              }
              if (!*((_WORD *)a5 + 8))
              {
LABEL_108:
                uint64_t v5 = 2314215424;
                log_OutText(*(void *)(*a5 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"cant find lingdb word : no word found with pos=%d,%d", v25, v26, v27, HIWORD(v77));
                return v5;
              }
              uint64_t v28 = 0;
              uint64_t v29 = *v7;
              uint64_t v30 = 32;
              while (__PAIR64__(*(unsigned __int16 *)(v29 + v30 - 22), *(unsigned __int16 *)(v29 + v30 - 24)) != __PAIR64__((unsigned __int16)v77, HIWORD(v77)))
              {
                ++v28;
                v30 += 64;
                if (*((unsigned __int16 *)a5 + 8) == v28) {
                  goto LABEL_108;
                }
              }
              if (*(_DWORD *)(v29 + v30) != 1) {
                goto LABEL_104;
              }
              uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void))(a2 + 192))(a3, a4, (unsigned __int16)v76);
              if ((v5 & 0x80000000) != 0) {
                return v5;
              }
              log_OutText(*(void *)(*a5 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"Due to POI priority, delete a word record from pos %d to pos %d", v31, v32, v33, HIWORD(v77));
              uint64_t v34 = a5[1];
              if (*(_DWORD *)(v34 + v30) != 1
                || stat_hmogrph_isSubWordRec((uint64_t)(a5 + 1), (unsigned __int16)v28))
              {
                goto LABEL_105;
              }
              if (*((_WORD *)a5 + 8))
              {
                unint64_t v35 = 0;
                uint64_t v5 = 0;
                uint64_t v36 = v34 + v30;
                uint64_t v37 = a2;
                uint64_t v70 = v36;
                do
                {
                  if (v28 != v35)
                  {
                    unint64_t v38 = *v7 + (v35 << 6);
                    if (*(unsigned __int16 *)(v36 - 24) <= *(unsigned __int16 *)(v38 + 8))
                    {
                      uint64_t v39 = *(unsigned __int16 *)(v38 + 10);
                      if (*(unsigned __int16 *)(v36 - 22) > v39)
                      {
                        uint64_t v40 = *a5;
                        unsigned __int16 v83 = 0;
                        int v81 = 0;
                        long long __s = 0;
                        HIWORD(v80) = 0;
                        uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, unsigned __int16 *))(v37 + 104))(a3, a4, 1, 0, &v83);
                        if ((v20 & 0x80000000) != 0) {
                          return v20;
                        }
                        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, char *))(v37 + 184))(a3, a4, v83, 0, (char *)&v81 + 2);
                        if ((v5 & 0x80000000) != 0
                          || HIWORD(v81) != 1
                          || (uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, char **, int *))(v37 + 176))(a3, a4, v83, 0, &__s, &v81), (v5 & 0x80000000) != 0)|| (unsigned __int16)v81 < 2u)
                        {
                          if ((v5 & 0x80000000) != 0) {
                            return v5;
                          }
                        }
                        else
                        {
                          size_t v41 = strlen(__s);
                          uint64_t v42 = (char *)heap_Calloc(*(void **)(v40 + 8), 1, v41 + 2);
                          if (!v42)
                          {
                            log_OutPublic(*(void *)(v40 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v43, v44, v45, v46, v69);
                            return 2314215434;
                          }
                          unsigned int v47 = v42;
                          unsigned int v48 = &strcpy(v42, __s)[v39];
                          size_t v49 = strlen(v48);
                          memmove(v48 + 1, v48, v49 + 1);
                          *unsigned int v48 = 32;
                          __int16 v50 = strlen(v47);
                          uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, const char *, char *))(a2 + 160))(a3, a4, v83, 0, (unsigned __int16)(v50 + 1), v47, (char *)&v80 + 2);
                          if ((v20 & 0x80000000) != 0) {
                            return v20;
                          }
                          heap_Free(*(void **)(v40 + 8), (uint64_t)v47);
                        }
                        int v81 = 0;
                        LODWORD(__s) = 0;
                        unsigned __int16 v83 = 0;
                        int v79 = 0;
                        int v80 = 0;
                        uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, int *))(a2 + 104))(a3, a4, 1, 0, &v81);
                        if ((v20 & 0x80000000) != 0) {
                          return v20;
                        }
                        uint64_t v51 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *))(a2 + 104))(a3, a4, 2, (unsigned __int16)v81, (char *)&v80 + 2);
                        uint64_t v5 = v51;
                        if ((v51 & 0x80000000) == 0)
                        {
                          unsigned __int16 v52 = HIWORD(v80);
                          if (HIWORD(v80))
                          {
                            while (1)
                            {
                              uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t, void, int *))(a2 + 120))(a3, a4, v52, &v80);
                              if ((v20 & 0x80000000) != 0) {
                                return v20;
                              }
                              (*(void (**)(uint64_t, uint64_t, void, void, uint64_t, char **, char *))(a2 + 168))(a3, a4, HIWORD(v80), 0, 1, &__s, (char *)&v79 + 2);
                              uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned __int16 *, char *))(a2 + 168))(a3, a4, HIWORD(v80), 1, 1, &v83, (char *)&v79 + 2);
                              if ((v20 & 0x80000000) != 0) {
                                return v20;
                              }
                              uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, char *))(a2 + 168))(a3, a4, HIWORD(v80), 2, 1, (char *)&v81 + 2, (char *)&v79 + 2);
                              if ((v20 & 0x80000000) != 0) {
                                return v20;
                              }
                              if (v83 >= v39)
                              {
                                ++v83;
                                __int16 v53 = HIWORD(v81);
                              }
                              else
                              {
                                __int16 v53 = HIWORD(v81);
                                if (HIWORD(v81) <= v39) {
                                  goto LABEL_77;
                                }
                              }
                              HIWORD(v81) = v53 + 1;
LABEL_77:
                              uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned __int16 *, int *))(a2 + 160))(a3, a4, HIWORD(v80), 1, 1, &v83, &v79);
                              if ((v20 & 0x80000000) != 0) {
                                return v20;
                              }
                              uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(a2 + 160))(a3, a4, HIWORD(v80), 2, 1, (char *)&v81 + 2, &v79);
                              if ((v20 & 0x80000000) != 0) {
                                return v20;
                              }
                              unsigned __int16 v52 = v80;
                              HIWORD(v80) = v80;
                              if (!(_WORD)v80) {
                                goto LABEL_82;
                              }
                            }
                          }
                        }
                        if ((v51 & 0x80000000) != 0) {
                          return v5;
                        }
LABEL_82:
                        uint64_t v37 = a2;
                        if (*((_WORD *)a5 + 8))
                        {
                          uint64_t v54 = 0;
                          uint64_t v55 = 0;
                          unint64_t v56 = (unint64_t)*((unsigned __int16 *)a5 + 8) << 6;
                          uint64_t v57 = v28;
                          do
                          {
                            if (v57)
                            {
                              uint64_t v58 = *v7;
                              uint64_t v59 = *v7 + v54;
                              unsigned int v60 = *(unsigned __int16 *)(v59 + 8);
                              if (v60 >= v39)
                              {
                                *(_WORD *)(v59 + 8) = v60 + 1;
                                uint64_t v64 = (_WORD *)(v58 + (v55 << 6) + 10);
                                __int16 v62 = *(_WORD *)(v59 + 10);
                                goto LABEL_89;
                              }
                              unsigned int v63 = *(unsigned __int16 *)(v59 + 10);
                              BOOL v61 = (_WORD *)(v59 + 10);
                              __int16 v62 = v63;
                              if (v63 > v39)
                              {
                                uint64_t v64 = v61;
LABEL_89:
                                _WORD *v64 = v62 + 1;
                              }
                            }
                            ++v55;
                            --v57;
                            v54 += 64;
                          }
                          while (v56 != v54);
                        }
                        unsigned __int16 v83 = 0;
                        long long __s = 0;
                        HIWORD(v81) = 0;
                        uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *))(a2 + 104))(a3, a4, 1, 0, (char *)&v81 + 2);
                        if ((v20 & 0x80000000) != 0) {
                          return v20;
                        }
                        uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, unsigned __int16 *))(a2 + 176))(a3, a4, HIWORD(v81), 1, &__s, &v83);
                        if ((v5 & 0x80000000) != 0) {
                          return v5;
                        }
                        uint64_t v65 = v83;
                        if (v83)
                        {
                          uint64_t v66 = __s + 16;
                          do
                          {
                            unsigned int v67 = *((_DWORD *)v66 - 1);
                            if (v67 >= v39)
                            {
                              *((_DWORD *)v66 - 1) = v67 + 1;
                            }
                            else if (*(_DWORD *)v66 + v67 > v39)
                            {
                              ++*(_DWORD *)v66;
                            }
                            v66 += 32;
                            --v65;
                          }
                          while (v65);
                        }
                        uint64_t v36 = v70;
                      }
                    }
                  }
                  ++v35;
                }
                while (v35 < *((unsigned __int16 *)a5 + 8));
                if ((v5 & 0x80000000) != 0) {
                  return v5;
                }
              }
              else
              {
LABEL_104:
                uint64_t v5 = 0;
              }
            }
LABEL_105:
            unsigned __int16 v21 = HIWORD(v75);
            LOWORD(v76) = HIWORD(v75);
          }
          while (HIWORD(v75));
        }
      }
    }
  }
  return v5;
}

uint64_t stat_hmogrph_getIOBTNToken(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, unsigned int a7, char *a8)
{
  int v24 = 0;
  int v25 = 0;
  int v23 = 0;
  uint64_t v22 = 0;
  for (uint64_t i = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char *))(a2 + 104))(a3, a4, 2, a5, (char *)&v25 + 2);
        ;
        uint64_t i = (*(uint64_t (**)(uint64_t, uint64_t, void, char *))(a2 + 120))(a3, a4, HIWORD(v25), (char *)&v25 + 2))
  {
    uint64_t v16 = i;
    if ((i & 0x80000000) != 0) {
      break;
    }
    if (!HIWORD(v25)) {
      goto LABEL_19;
    }
    uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, int *, int *))(a2 + 168))(a3, a4, HIWORD(v25), 0, 1, &v23, &v25);
    if ((v17 & 0x80000000) != 0) {
      return v17;
    }
    if (v23 == 6)
    {
      uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(*(void *)(a1 + 48)
                                                                                                 + 168))(a3, a4, HIWORD(v25), 1, 1, (char *)&v24 + 2, &v25);
      if ((v17 & 0x80000000) != 0) {
        return v17;
      }
      uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, int *))(*(void *)(a1 + 48)
                                                                                                + 168))(a3, a4, HIWORD(v25), 2, 1, &v24, &v25);
      if ((v17 & 0x80000000) != 0) {
        return v17;
      }
      if (HIWORD(v24) <= a6 && (unsigned __int16)v24 + 1 >= a7)
      {
        BOOL v18 = HIWORD(v24) + 1 == a6 || HIWORD(v24) == a6;
        uint64_t v19 = "I-";
        if (v18) {
          uint64_t v19 = "B-";
        }
        *(_WORD *)a8 = *(_WORD *)v19;
        a8[2] = v19[2];
        uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t *, int *))(*(void *)(a1 + 48)
                                                                                             + 176))(a3, a4, HIWORD(v25), 4, &v22, &v25);
        if ((v16 & 0x80000000) == 0)
        {
          uint64_t v20 = strncat(a8, (const char *)(v22 + 1), 0x3CuLL);
          a8 += (unsigned __int16)strlen(v20) - 1;
LABEL_19:
          *a8 = 0;
        }
        return v16;
      }
    }
  }
  return v16;
}

uint64_t stat_hmogrph_disambiguateWords(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v167 = *MEMORY[0x263EF8340];
  int v164 = 0;
  int v165 = 0;
  int v163 = 0;
  unsigned __int16 v162 = 0;
  unsigned __int16 v161 = 0;
  unsigned int v159 = 0;
  int v160 = 0;
  unsigned int v158 = 0;
  uint64_t v156 = 0;
  int v157 = 0;
  int v154 = 0;
  int v155 = 0;
  memset(__c, 0, sizeof(__c));
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *))(a2 + 104))(a3, a4, 1, 0, (char *)&v165 + 2);
  if ((v10 & 0x80000000) != 0) {
    return v10;
  }
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, int *))(a2 + 184))(a3, a4, HIWORD(v165), 0, &v163);
  if ((v11 & 0x80000000) != 0) {
    return v11;
  }
  if ((unsigned __int16)v163 != 1) {
    return v11;
  }
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t *, int *))(a2 + 176))(a3, a4, HIWORD(v165), 0, &v156, &v164);
  if ((v11 & 0x80000000) != 0 || (unsigned __int16)v164 < 2u) {
    return v11;
  }
  uint64_t v12 = *(void *)(a1 + 280);
  uint64_t v10 = (*(uint64_t (**)(void, void, unsigned int *))(v12 + 40))(*(void *)(a5 + 104), *(void *)(a5 + 112), &v158);
  if ((v10 & 0x80000000) != 0) {
    return v10;
  }
  if (strlen((const char *)(a1 + 344)) + v158 != *(_DWORD *)(a1 + 324))
  {
    log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v13, v14, v15, v16, v135);
    return 2314215449;
  }
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, int *))(a2 + 104))(a3, a4, 2, HIWORD(v165), &v165);
  if ((v11 & 0x80000000) == 0)
  {
    unsigned __int16 v17 = v165;
    if ((_WORD)v165)
    {
      long long __s = (char *)(a1 + 344);
      __s1 = 0;
      BOOL v18 = 0;
      uint64_t v150 = 0;
      unsigned __int16 v142 = 0;
      unsigned int v141 = 0;
      unsigned int v149 = 0;
      uint64_t v140 = v12;
      while (1)
      {
        uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, unsigned int *, int *))(a2 + 168))(a3, a4, v17, 0, 1, &v159, &v164);
        if ((v19 & 0x80000000) != 0)
        {
LABEL_188:
          uint64_t v11 = v19;
          goto LABEL_189;
        }
        if (v159 <= 0xA && ((1 << v159) & 0x610) != 0) {
          break;
        }
LABEL_28:
        uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, void, int *))(a2 + 120))(a3, a4, (unsigned __int16)v165, &v165);
        if ((v11 & 0x80000000) == 0)
        {
          unsigned __int16 v17 = v165;
          if ((_WORD)v165) {
            continue;
          }
        }
        goto LABEL_189;
      }
      uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned __int16 *, int *))(*(void *)(a1 + 48) + 168))(a3, a4, (unsigned __int16)v165, 1, 1, &v162, &v164);
      if ((v19 & 0x80000000) != 0) {
        goto LABEL_188;
      }
      uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned __int16 *, int *))(*(void *)(a1 + 48) + 168))(a3, a4, (unsigned __int16)v165, 2, 1, &v161, &v164);
      if ((v19 & 0x80000000) != 0) {
        goto LABEL_188;
      }
      uint64_t v21 = v161;
      uint64_t v22 = v162;
      size_t v23 = v161 - v162;
      if (v23 <= v149)
      {
        uint64_t v29 = v162;
        uint64_t v30 = (char *)v150;
      }
      else
      {
        uint64_t v24 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), v150, (v23 + 1));
        if (!v24) {
          goto LABEL_195;
        }
        unsigned int v149 = (unsigned __int16)v23;
        uint64_t v29 = v162;
        uint64_t v30 = (char *)v24;
      }
      strncpy(v30, (const char *)(v156 + v29), v23);
      uint64_t v150 = (uint64_t)v30;
      if (v21 == v22)
      {
        *uint64_t v30 = 0;
        goto LABEL_28;
      }
      if (strchr(__s, v30[(v23 - 1)])) {
        int v31 = v23 - 1;
      }
      else {
        int v31 = v23;
      }
      v30[v31] = 0;
      if (!v31) {
        goto LABEL_28;
      }
      unsigned int v32 = strlen(v30);
      unsigned int v33 = v32;
      int __dst = v18;
      if (v32 <= v142)
      {
        if (!v32)
        {
          int v143 = 0;
          goto LABEL_45;
        }
      }
      else
      {
        uint64_t v34 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), (uint64_t)__s1, v32 + 1);
        if (!v34)
        {
LABEL_195:
          uint64_t v11 = 2314215434;
LABEL_196:
          log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v25, v26, v27, v28, v135);
          goto LABEL_189;
        }
        __s1 = (char *)v34;
        unsigned __int16 v142 = v33;
      }
      int v143 = 0;
      unsigned int v35 = 0;
      do
      {
        unsigned int NextUtf8Offset = utf8_GetNextUtf8Offset(&v30[v35], 0);
        if (utf8_ToLower(v30, v35, (uint64_t)__src))
        {
          if (strlen(__src) <= NextUtf8Offset)
          {
            strcpy(&__s1[v143], __src);
            int v143 = strlen(__s1);
          }
          else
          {
            v142 += 5;
            uint64_t v37 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), (uint64_t)__s1, v142 + 1);
            if (!v37) {
              goto LABEL_198;
            }
            __s1 = (char *)v37;
          }
        }
        else
        {
          strncpy(&__s1[v143], &v30[v35], NextUtf8Offset);
          v143 += NextUtf8Offset;
        }
        v35 += NextUtf8Offset;
      }
      while (v35 < v33);
LABEL_45:
      __s1[v143] = 0;
      if (IsModelHomograph(__s1, *(char **)(a5 + 136)))
      {
        log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"STATWORDHMOGRPH_PRESENT: %s", v42, v43, v44, (uint64_t)__s1);
        unsigned __int16 v49 = v165;
        HIWORD(v164) = v165;
        if ((_WORD)v165)
        {
          int v50 = 0;
          unsigned __int16 v51 = v161;
          unsigned __int16 v52 = v162;
          LOWORD(v53) = v165;
          while (1)
          {
            IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t, void, char *))(a2 + 136))(a3, a4, (unsigned __int16)v53, (char *)&v164 + 2);
            if ((IOBTNToken & 0x80000000) != 0) {
              break;
            }
            if (!HIWORD(v164)) {
              goto LABEL_66;
            }
            IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 168))(a3, a4);
            if ((IOBTNToken & 0x80000000) != 0) {
              break;
            }
            if (v159 > 0xA || ((1 << v159) & 0x610) == 0)
            {
              int v53 = HIWORD(v164);
            }
            else
            {
              IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(*(void *)(a1 + 48) + 168))(a3, a4, HIWORD(v164), 1, 1, (char *)&v160 + 2, &v164);
              if ((IOBTNToken & 0x80000000) != 0) {
                break;
              }
              IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, int *))(*(void *)(a1 + 48) + 168))(a3, a4, HIWORD(v164), 2, 1, &v160, &v164);
              if ((IOBTNToken & 0x80000000) != 0) {
                break;
              }
              int v53 = HIWORD(v164);
              if (HIWORD(v160) == v52 && (unsigned __int16)v160 == v51)
              {
                unsigned __int16 v49 = HIWORD(v164);
              }
              else
              {
                if (++v50 == (*(_DWORD *)(a1 + 320) - 1) >> 1)
                {
                  HIWORD(v164) = 0;
                  unsigned __int16 v49 = v53;
                  goto LABEL_66;
                }
                unsigned __int16 v49 = HIWORD(v164);
                unsigned __int16 v52 = HIWORD(v160);
                unsigned __int16 v51 = v160;
              }
            }
            if (!v53) {
              goto LABEL_66;
            }
          }
LABEL_197:
          uint64_t v11 = IOBTNToken;
LABEL_199:
          BOOL v18 = __dst;
          goto LABEL_189;
        }
LABEL_66:
        uint64_t v56 = *(void *)a1;
        if (!(*(_DWORD *)(a1 + 324) * *(_DWORD *)(a1 + 320)))
        {
          log_OutPublic(*(void *)(v56 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v45, v46, v47, v48, v135);
          uint64_t v11 = 2314215449;
          goto LABEL_199;
        }
        uint64_t v57 = 4 * (*(_DWORD *)(a1 + 324) * *(_DWORD *)(a1 + 320));
        uint64_t v58 = (float *)heap_Alloc(*(void *)(v56 + 8), v57);
        int v155 = v58;
        if (!v58)
        {
LABEL_198:
          uint64_t v11 = 2314215434;
          log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v38, v39, v40, v41, v135);
          goto LABEL_199;
        }
        uint64_t v59 = v58;
        memset_pattern16(v58, &unk_20D62D3B0, v57);
        HIWORD(v164) = v49;
        if (v49)
        {
          int v137 = 0;
          int v144 = 0;
          unsigned __int16 v63 = 0;
          unsigned __int16 v64 = 0;
          while (1)
          {
            IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, unsigned int *, int *))(a2 + 168))(a3, a4, v49, 0, 1, &v159, &v164);
            if ((IOBTNToken & 0x80000000) != 0) {
              goto LABEL_197;
            }
            if (v159 <= 0xA && ((1 << v159) & 0x610) != 0)
            {
              IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(*(void *)(a1 + 48) + 168))(a3, a4, HIWORD(v164), 1, 1, (char *)&v160 + 2, &v164);
              if ((IOBTNToken & 0x80000000) != 0) {
                goto LABEL_197;
              }
              IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, int *))(*(void *)(a1 + 48) + 168))(a3, a4, HIWORD(v164), 2, 1, &v160, &v164);
              if ((IOBTNToken & 0x80000000) != 0) {
                goto LABEL_197;
              }
              unsigned int v66 = HIWORD(v160);
              int v67 = (unsigned __int16)v160;
              if (HIWORD(v160) != v64 || (unsigned __int16)v160 != v63)
              {
                uint64_t v68 = strlen(__s);
                if (v68)
                {
                  unsigned int v69 = v158;
                  do
                  {
                    v59[v69++] = 0.0;
                    --v68;
                  }
                  while (v68);
                }
                size_t v70 = v67 - v66;
                if (v70 <= v149)
                {
                  __int16 v72 = (char *)v150;
                }
                else
                {
                  uint64_t v71 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), v150, (v70 + 1));
                  if (!v71) {
                    goto LABEL_198;
                  }
                  unsigned int v149 = (unsigned __int16)v70;
                  unsigned int v66 = HIWORD(v160);
                  __int16 v72 = (char *)v71;
                }
                strncpy(v72, (const char *)(v156 + v66), v70);
                v72[v70] = 0;
                int v73 = strcmp(__s1, v72);
                int v74 = v137;
                if (HIWORD(v164) == (unsigned __int16)v165) {
                  int v75 = v137;
                }
                else {
                  int v75 = 1;
                }
                if (!v73) {
                  int v74 = v75;
                }
                int v137 = v74;
                uint64_t v76 = (v70 - 1);
                int v77 = strchr(__s, v72[v76]);
                if (v77)
                {
                  unsigned __int8 v81 = *(unsigned char *)(a1 + (v77 - __s) + 354) - 48;
                  v59[v158 + v81] = 1.0;
                  log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"STATWORDHMOGRPH_PUNC: %i", v78, v79, v80, v81);
                  v72[v76] = 0;
                }
                uint64_t v150 = (uint64_t)v72;
                IOBTNTokeuint64_t n = stat_hmogrph_getIOBTNToken(a1, a2, a3, a4, HIWORD(v165), HIWORD(v160), (unsigned __int16)v160, __src);
                if ((IOBTNToken & 0x80000000) != 0) {
                  goto LABEL_197;
                }
                if (__src[0]) {
                  int v85 = __src;
                }
                else {
                  int v85 = v72;
                }
                log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"STATWORDHMOGRPH_WORD: %s", v82, v83, v84, (uint64_t)v85);
                uint64_t v86 = (*(uint64_t (**)(void, void, char *, float *))(v140 + 56))(*(void *)(a5 + 104), *(void *)(a5 + 112), v85, v59);
                uint64_t v11 = v86;
                if ((v86 & 0x1FFF) == 0x14)
                {
                  if (*(_DWORD *)(a5 + 176))
                  {
                    int v87 = *v85;
                    if ((v87 - 65) <= 0x19)
                    {
                      *int v85 = v87 + 32;
                      LOWORD(v11) = (*(uint64_t (**)(void, void, char *, float *))(v140 + 56))(*(void *)(a5 + 104), *(void *)(a5 + 112), v85, v59);
                      *int v85 = v87;
                    }
                  }
                  if ((v11 & 0x1FFF) == 0x14)
                  {
                    IOBTNTokeuint64_t n = (*(uint64_t (**)(void, void, uint64_t, float *))(v140 + 56))(*(void *)(a5 + 104), *(void *)(a5 + 112), a5 + 164, v59);
                    if ((IOBTNToken & 0x80000000) != 0) {
                      goto LABEL_197;
                    }
                  }
                }
                else if ((v86 & 0x80000000) != 0)
                {
                  goto LABEL_199;
                }
                if (HIWORD(v164) == (unsigned __int16)v165) {
                  int v144 = *(_DWORD *)(a1 + 320) >> 1;
                }
                ++v144;
                unsigned __int16 v64 = HIWORD(v160);
                unsigned __int16 v63 = v160;
                v59 += *(unsigned int *)(a1 + 324);
              }
            }
            IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t, void, char *))(a2 + 120))(a3, a4, HIWORD(v164), (char *)&v164 + 2);
            if ((IOBTNToken & 0x80000000) != 0) {
              goto LABEL_197;
            }
            if (v144 == *(_DWORD *)(a1 + 320))
            {
              HIWORD(v164) = 0;
              goto LABEL_114;
            }
            unsigned __int16 v49 = HIWORD(v164);
            if (!HIWORD(v164)) {
              goto LABEL_114;
            }
          }
        }
        int v137 = 0;
LABEL_114:
        log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"STATWORDHMOGRPH_FEATURE: BEGIN", v60, v61, v62, v135);
        if (*(_DWORD *)(a1 + 324) * *(_DWORD *)(a1 + 320))
        {
          unint64_t v91 = 0;
          do
            log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"%f", v88, v89, v90, COERCE__INT64(v155[v91++]));
          while (v91 < (*(_DWORD *)(a1 + 324) * *(_DWORD *)(a1 + 320)));
        }
        log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"STATWORDHMOGRPH_FEATURE: END", v88, v89, v90, v136);
        uint64_t v92 = *(uint64_t ****)(a5 + 40);
        *((float *)*v92 + 49) = (float)*(unsigned int *)(a5 + 128) / 100.0;
        uint64_t v19 = fi_predict(v92, (const void **)&v155, *(unsigned int *)(a1 + 320), &v154, v93, v94, v95, v96);
        BOOL v18 = __dst;
        if ((v19 & 0x80000000) != 0) {
          goto LABEL_188;
        }
        uint64_t v11 = 2314215434;
        LODWORD(__s2) = 0;
        if ((fi_shape_get_size((int *)(**(void **)(a5 + 40) + 92), (int *)&__s2) & 0x80000000) != 0)
        {
          uint64_t v11 = 2314215431;
          goto LABEL_196;
        }
        if (__s2 != 1)
        {
          uint64_t v11 = 2314215449;
          goto LABEL_196;
        }
        int v97 = strlen(__s1);
        unsigned __int16 v98 = v97 + 18;
        if (v97 + 18 > v141)
        {
          uint64_t v99 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), (uint64_t)__dst, (v97 + 19));
          if (!v99) {
            goto LABEL_196;
          }
          unsigned int v141 = v98;
          BOOL v18 = (char *)v99;
        }
        strcpy(v18, "statwordhmogrph__");
        strcat(v18, __s1);
        *(_WORD *)&__c[1] = -1;
        uint64_t v19 = (*(uint64_t (**)(void, void, const char *, char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 96) + 96))(*(void *)(a1 + 80), *(void *)(a1 + 88), "fecfg", v18, &__c[3], &__c[1], __c);
        if ((v19 & 0x80000000) != 0) {
          goto LABEL_188;
        }
        if (!*(_WORD *)&__c[1])
        {
          log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 37000, 0, v100, v101, v102, v103, v135);
          uint64_t v11 = 2314215444;
LABEL_189:
          if (__s1) {
            heap_Free(*(void **)(*(void *)a1 + 8), (uint64_t)__s1);
          }
          if (v150) {
            heap_Free(*(void **)(*(void *)a1 + 8), v150);
          }
          if (v18) {
            heap_Free(*(void **)(*(void *)a1 + 8), (uint64_t)v18);
          }
          return v11;
        }
        __int16 v104 = **(const char ***)&__c[3];
        int v105 = strchr(**(char ***)&__c[3], __c[0]);
        if (v105)
        {
          char *v105 = 0;
          __int16 v104 = **(const char ***)&__c[3];
        }
        unsigned int v106 = strlen(v104);
        if (v141 < v106)
        {
          uint64_t v107 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), (uint64_t)v18, v106 + 1);
          if (!v107) {
            goto LABEL_196;
          }
          unsigned int v141 = (unsigned __int16)v106;
          __int16 v104 = **(const char ***)&__c[3];
          BOOL v18 = (char *)v107;
        }
        strcpy(v18, v104);
        int __dst = v18;
        if (*v154)
        {
          HomographPhouint64_t n = GetHomographPhon(*v154, v18);
          if (HomographPhon)
          {
            if (v137 != 1)
            {
              long long v112 = HomographPhon;
              log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"STATWORDHMOGRPH_PHON: %s", v108, v109, v110, (uint64_t)HomographPhon);
              unsigned __int16 v113 = v165;
              HIWORD(v164) = v165;
              if ((_WORD)v165)
              {
                unsigned __int16 v114 = 0;
                int v145 = v162;
                int v138 = v161;
                while (1)
                {
                  IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, unsigned int *, int *))(a2 + 168))(a3, a4, v113, 0, 1, &v159, &v164);
                  if ((IOBTNToken & 0x80000000) != 0) {
                    goto LABEL_197;
                  }
                  if (v159 <= 0xA && ((1 << v159) & 0x610) != 0)
                  {
                    IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(*(void *)(a1 + 48) + 168))(a3, a4, HIWORD(v164), 1, 1, (char *)&v160 + 2, &v164);
                    if ((IOBTNToken & 0x80000000) != 0) {
                      goto LABEL_197;
                    }
                    IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, int *))(*(void *)(a1 + 48) + 168))(a3, a4, HIWORD(v164), 2, 1, &v160, &v164);
                    if ((IOBTNToken & 0x80000000) != 0) {
                      goto LABEL_197;
                    }
                    if (HIWORD(v160) == v145 && (unsigned __int16)v160 == v138)
                    {
                      IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, int *))(*(void *)(a1 + 48) + 176))(a3, a4, HIWORD(v164), 3, &v157, &v164);
                      if ((IOBTNToken & 0x80000000) != 0) {
                        goto LABEL_197;
                      }
                      int v116 = strcmp(v157, v112);
                      unsigned __int16 v117 = HIWORD(v164);
                      IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t, void, char *))(a2 + 120))(a3, a4, HIWORD(v164), (char *)&v164 + 2);
                      if ((IOBTNToken & 0x80000000) != 0) {
                        goto LABEL_197;
                      }
                      if (!v116) {
                        unsigned __int16 v114 = v117;
                      }
                      unsigned __int16 v113 = HIWORD(v164);
                      if (HIWORD(v164)) {
                        continue;
                      }
                    }
                  }
                  goto LABEL_152;
                }
              }
              goto LABEL_184;
            }
          }
        }
        log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_HMOGRPH", 5, 0, (uint64_t)"STATWORDHMOGRPH_PHON: <>", v108, v109, v110, v135);
      }
      unsigned __int16 v114 = 0;
LABEL_152:
      unsigned __int16 v118 = v165;
      HIWORD(v164) = v165;
      if ((_WORD)v165)
      {
        int v119 = v162;
        int v120 = v161;
        do
        {
          IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, unsigned int *, int *))(a2 + 168))(a3, a4, v118, 0, 1, &v159, &v164);
          if ((IOBTNToken & 0x80000000) != 0) {
            goto LABEL_197;
          }
          if (v159 > 0xA || ((1 << v159) & 0x610) == 0) {
            goto LABEL_183;
          }
          IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(*(void *)(a1 + 48) + 168))(a3, a4, HIWORD(v164), 1, 1, (char *)&v160 + 2, &v164);
          if ((IOBTNToken & 0x80000000) != 0) {
            goto LABEL_197;
          }
          IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, int *))(*(void *)(a1 + 48) + 168))(a3, a4, HIWORD(v164), 2, 1, &v160, &v164);
          if ((IOBTNToken & 0x80000000) != 0) {
            goto LABEL_197;
          }
          if (HIWORD(v160) != v119 || (unsigned __int16)v160 != v120)
          {
LABEL_183:
            HIWORD(v164) = 0;
            break;
          }
          uint64_t v122 = HIWORD(v164);
          IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t, void, char *))(a2 + 120))(a3, a4, HIWORD(v164), (char *)&v164 + 2);
          if ((IOBTNToken & 0x80000000) != 0) {
            goto LABEL_197;
          }
          if (!v114 || v122 == v114)
          {
            LOWORD(v165) = v122;
            if (v122 == v114)
            {
              int v151 = 0;
              __s2 = 0;
              IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, int *))(*(void *)(a1 + 48) + 176))(a3, a4, v114, 5, &__s2, &v164);
              if ((IOBTNToken & 0x80000000) != 0) {
                goto LABEL_197;
              }
              IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, int *))(*(void *)(a1 + 48) + 176))(a3, a4, (unsigned __int16)v165, 14, &v151, &v164);
              if ((IOBTNToken & 0x80000000) != 0) {
                goto LABEL_197;
              }
              __int16 v123 = strlen(v151);
              unsigned __int16 v124 = strlen(__s2) + v123;
              int v146 = v120;
              if (v124 <= v141)
              {
                uint64_t v126 = __dst;
              }
              else
              {
                uint64_t v125 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), (uint64_t)__dst, v124 + 1);
                if (!v125) {
                  goto LABEL_198;
                }
                unsigned int v141 = v124;
                uint64_t v126 = (char *)v125;
              }
              strcpy(v126, "POS:");
              uint64_t v127 = strcat(v126, __s2);
              *(_WORD *)&v126[strlen(v127)] = 59;
              uint64_t v128 = v151;
              int __dst = v126;
              if (!strstr(v151, v126))
              {
                uint64_t v129 = strstr(v128, "POS");
                if (v129)
                {
                  uint64_t v130 = v129;
                  unsigned int v131 = strncpy(__dst, v128, v129 - v128);
                  __dst[v130 - v151] = 0;
                  strcpy(&__dst[strlen(v131)], "POS:");
                  strcat(__dst, __s2);
                  unsigned int v132 = strchr(v130, 59);
                  if (v132) {
                    strcat(__dst, v132);
                  }
                  __int16 v133 = strlen(__dst);
                  IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, char *, char *))(*(void *)(a1 + 48) + 160))(a3, a4, (unsigned __int16)v165, 14, (unsigned __int16)(v133 + 1), __dst, (char *)&v163 + 2);
                  if ((IOBTNToken & 0x80000000) != 0) {
                    goto LABEL_197;
                  }
                }
              }
              int v120 = v146;
            }
          }
          else
          {
            IOBTNTokeuint64_t n = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 192))(a3, a4, v122);
            if ((IOBTNToken & 0x80000000) != 0) {
              goto LABEL_197;
            }
          }
          unsigned __int16 v118 = HIWORD(v164);
        }
        while (HIWORD(v164));
      }
LABEL_184:
      BOOL v18 = __dst;
      goto LABEL_28;
    }
  }
  return v11;
}

char *IsModelHomograph(const char *a1, char *a2)
{
  unsigned __int16 v4 = strlen(a1);
  uint64_t result = strstr(a2, a1);
  if (result)
  {
    if (result == a2 || *(result - 1) == 124) {
      return (char *)(!result[v4] || result[v4] == 124);
    }
    else {
      return 0;
    }
  }
  return result;
}

char *GetHomographPhon(const char *a1, char *__s)
{
  int v2 = __s;
  for (uint64_t i = __s; ; uint64_t i = v8 + 1)
  {
    uint64_t v5 = strchr(i, 61);
    uint64_t v6 = v5;
    if (!v5) {
      break;
    }
    *uint64_t v5 = 0;
    uint64_t v6 = v5 + 1;
    int v7 = strcmp(a1, v2);
    uint64_t v8 = strchr(v6, 124);
    if (!v7)
    {
      if (v8) {
        *uint64_t v8 = 0;
      }
      return v6;
    }
    if (!v8) {
      return 0;
    }
    int v2 = v8 + 1;
  }
  return v6;
}

char *hlp_filterWordCandIfTnHas(char *result)
{
  uint64_t v1 = *((unsigned __int16 *)result + 28);
  if (*((_WORD *)result + 28))
  {
    uint64_t v2 = 0;
    uint64_t v3 = *((void *)result + 6);
    do
    {
      uint64_t v4 = v3 + 16 * v2;
      uint64_t v5 = *(unsigned __int16 *)(v4 + 8);
      if (*(_WORD *)(v4 + 8))
      {
        uint64_t v6 = (_DWORD *)(*(void *)(v3 + 16 * v2) + 48);
        do
        {
          uint64_t result = strstr(*((char **)v6 - 1), "poi");
          if (result) {
            *uint64_t v6 = 1;
          }
          v6 += 14;
          --v5;
        }
        while (v5);
      }
      ++v2;
    }
    while (v2 != v1);
  }
  return result;
}

uint64_t hlp_hasRcdWithGivenPOIClass(uint64_t a1, char *__s2)
{
  uint64_t v2 = *(unsigned __int16 *)(a1 + 56);
  if (!*(_WORD *)(a1 + 56)) {
    return 0;
  }
  uint64_t v4 = 0;
  uint64_t v5 = *(void *)(a1 + 48);
  while (1)
  {
    uint64_t v6 = v5 + 16 * v4;
    uint64_t v7 = *(unsigned __int16 *)(v6 + 8);
    if (*(_WORD *)(v6 + 8)) {
      break;
    }
LABEL_7:
    if (++v4 == v2) {
      return 0;
    }
  }
  uint64_t v8 = (const char **)(*(void *)(v5 + 16 * v4) + 40);
  while (strcmp(*v8, __s2))
  {
    v8 += 7;
    if (!--v7) {
      goto LABEL_7;
    }
  }
  return 1;
}

uint64_t hlp_filterWordCandIfTnIsNot(uint64_t result, char *__s2)
{
  uint64_t v2 = *(unsigned __int16 *)(result + 56);
  if (*(_WORD *)(result + 56))
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(void *)(result + 48);
    do
    {
      uint64_t v6 = v5 + 16 * v4;
      uint64_t v7 = *(unsigned __int16 *)(v6 + 8);
      if (*(_WORD *)(v6 + 8))
      {
        uint64_t v8 = (_DWORD *)(*(void *)(v5 + 16 * v4) + 48);
        do
        {
          uint64_t result = strcmp(*((const char **)v8 - 1), __s2);
          if (result) {
            *uint64_t v8 = 1;
          }
          v8 += 14;
          --v7;
        }
        while (v7);
      }
      ++v4;
    }
    while (v4 != v2);
  }
  return result;
}

uint64_t stat_hmogrph_isSubWordRec(uint64_t a1, unsigned int a2)
{
  if (!*(_WORD *)(a1 + 8)) {
    return 0;
  }
  uint64_t v2 = 0;
  while (1)
  {
    if ((unint64_t)a2 << 6 != v2)
    {
      unint64_t v3 = *(void *)a1 + ((unint64_t)a2 << 6);
      uint64_t v4 = *(void *)a1 + v2;
      if (*(unsigned __int16 *)(v3 + 8) >= *(unsigned __int16 *)(v4 + 8)
        && *(unsigned __int16 *)(v3 + 10) <= *(unsigned __int16 *)(v4 + 10))
      {
        break;
      }
    }
    v2 += 64;
    if ((unint64_t)*(unsigned __int16 *)(a1 + 8) << 6 == v2) {
      return 0;
    }
  }
  return 1;
}

unsigned __int16 *stat_hmogrph_setWillBeDeleteOfSubWords(unsigned __int16 *result, unsigned int a2, int a3)
{
  uint64_t v3 = result[4];
  if (result[4])
  {
    uint64_t v4 = a2;
    unint64_t v5 = *(void *)result + ((unint64_t)a2 << 6);
    uint64_t v6 = (unsigned __int16 *)(v5 + 8);
    uint64_t v7 = (unsigned __int16 *)(v5 + 10);
    uint64_t v8 = (_DWORD *)(*(void *)result + 32);
    do
    {
      if (v4
        && *v6 <= *((unsigned __int16 *)v8 - 12)
        && *v7 >= *((unsigned __int16 *)v8 - 11))
      {
        *uint64_t v8 = a3;
      }
      v8 += 16;
      --v4;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t stat_hmogrph_hasSubWordWithGivenTn(uint64_t a1, unsigned int a2, char *__s2)
{
  uint64_t v3 = *(unsigned __int16 *)(a1 + 8);
  if (!*(_WORD *)(a1 + 8)) {
    return 0;
  }
  uint64_t v5 = *(void *)a1;
  uint64_t v6 = a2;
  unint64_t v7 = *(void *)a1 + ((unint64_t)a2 << 6);
  uint64_t v8 = (unsigned __int16 *)(v7 + 8);
  uint64_t v9 = (unsigned __int16 *)(v7 + 10);
  while (!v6
       || *v8 > *(unsigned __int16 *)(v5 + 8)
       || *v9 < *(unsigned __int16 *)(v5 + 10)
       || !hlp_hasRcdWithGivenPOIClass(v5, __s2))
  {
    v5 += 64;
    --v6;
    if (!--v3) {
      return 0;
    }
  }
  return 1;
}

uint64_t nntn_AllInOneLoop(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v113 = *MEMORY[0x263EF8340];
  unsigned __int16 v104 = 0;
  uint64_t v103 = 0;
  int v102 = 0;
  uint64_t v101 = 0;
  int v100 = 0;
  uint64_t v99 = 0;
  unsigned int v97 = 0;
  log_OutText(*(void *)(*(void *)a1 + 32), *(void *)(a1 + 184), 4, 0, (uint64_t)"nntn : AllInOneLoop Begin", a6, a7, a8, v93);
  if ((paramc_ParamGetInt(*(void *)(*(void *)a1 + 40), (uint64_t)"maxTNNNcallspersent", (int *)&v97) & 0x80000000) == 0) {
    log_OutText(*(void *)(*(void *)a1 + 32), *(void *)(a1 + 184), 5, 0, (uint64_t)"set maxTNNNCallsPerSent to %d", v13, v14, v15, v97);
  }
  if (v97) {
    *(_DWORD *)(a1 + 872) = v97;
  }
  uint64_t v16 = *(uint64_t **)(a1 + 168);
  *(void *)(*(void *)(*v16 + 16) + 32) = a1;
  uint64_t v17 = setDomainsOnSentence_NNTN((uint64_t *)a1, v9, v10, v11, v12, v13, v14, v15);
  if ((v17 & 0x80000000) != 0) {
    return v17;
  }
  uint64_t DomainDefBlockInfo = mergeDomainsOnSentence_NNTN((void *)a1, v18, v19, v20, v21, v22, v23, v24);
  if ((DomainDefBlockInfo & 0x80000000) != 0) {
    return DomainDefBlockInfo;
  }
  uint64_t v26 = *v16;
  *(void *)(*(void *)(*v16 + 16) + 16) = *(void *)(a1 + 304);
  *(_WORD *)(v26 + 64) = 16;
  *(_WORD *)(v26 + 42) = *(_WORD *)(a1 + 312);
  uint64_t v27 = *(void *)(*(void *)(a1 + 264) + 16);
  NumberChildreuint64_t n = LDOTreeNode_GetNumberChildren(v27);
  uint64_t v32 = *(void *)(*(void *)a1 + 32);
  uint64_t v33 = *(void *)(a1 + 184);
  if (!NumberChildren)
  {
    uint64_t v90 = "no basic token records to process";
    uint64_t v91 = 5;
LABEL_106:
    log_OutText(v32, v33, v91, 0, (uint64_t)v90, v28, v29, v30, v94);
    return DomainDefBlockInfo;
  }
  log_OutText(v32, v33, 4, 0, (uint64_t)"tokentn : start loop...", v28, v29, v30, v94);
  uint64_t v34 = *(size_t **)(v27 + 80);
  unint64_t v35 = *(void *)(v27 + 88);
  unsigned __int16 v98 = v34;
  unint64_t v95 = v35;
  if ((unint64_t)v34 < v35)
  {
    unsigned int v36 = 0;
    do
    {
      __s1 = 0;
      LODWORD(v107) = 0;
      LODWORD(v106) = 0;
      size_t v37 = *v34;
      int v38 = LDOTreeNode_ComputeAbsoluteFrom(*v34, &v107);
      uint64_t DomainRange = LH_ERROR_to_VERROR(v38);
      if ((DomainRange & 0x80000000) != 0
        || (int v46 = LDOTreeNode_ComputeAbsoluteTo(v37, &v106),
            uint64_t DomainRange = LH_ERROR_to_VERROR(v46),
            (DomainRange & 0x80000000) != 0))
      {
LABEL_104:
        uint64_t DomainDefBlockInfo = DomainRange;
        goto LABEL_105;
      }
      uint64_t v47 = (unsigned __int16)v107;
      int v96 = (unsigned __int16)v106;
      int Type = LDOObject_GetType(v37, (uint64_t *)&__s1);
      uint64_t DomainDefBlockInfo = LH_ERROR_to_VERROR(Type);
      if ((DomainDefBlockInfo & 0x80000000) != 0) {
        goto LABEL_105;
      }
      *(_DWORD *)(*v16 + 72) = 0;
      unsigned __int16 v49 = __s1;
      if (!strcmp(__s1, "TOKEN_ALPHA")) {
        unsigned int v36 = 0;
      }
      if (!strcmp(v49, "TOKEN_DIGIT")) {
        unsigned int v36 = 1;
      }
      if (!strcmp(v49, "TOKEN_PUNCT")) {
        unsigned int v36 = 2;
      }
      if (!strcmp(v49, "TOKEN_WSPACE")) {
        unsigned int v36 = 3;
      }
      if (!strcmp(v49, "TOKEN_DCT")) {
        unsigned int v36 = 4;
      }
      if (!strcmp(v49, "TOKEN_USER_TN")) {
        unsigned int v36 = 5;
      }
      if (!strcmp(v49, "TOKEN_INT_TN")) {
        unsigned int v36 = 6;
      }
      if (!strcmp(v49, "TOKEN_CASEGENDER")) {
        unsigned int v36 = 7;
      }
      if (v36 <= 2)
      {
        HIWORD(v102) = 0;
        FERuntimeData_GetActiveDomains(a1, (uint64_t)v112, (_WORD *)&v102 + 1, v47, v96, 0);
        log_OutText(*(void *)(*(void *)a1 + 32), *(void *)(a1 + 184), 5, 0, (uint64_t)"START basic token %d,%d ... %d active domains", v50, v51, v52, v47);
        if (HIWORD(v102))
        {
          uint64_t v53 = 0;
          while (1)
          {
            LOWORD(v102) = 0;
            unsigned __int16 v104 = 0;
            uint64_t v54 = *v16;
            *(_WORD *)(v54 + 46) = 0;
            *(_WORD *)(v54 + 44) = v47;
            *(void *)(v54 + 56) = 0;
            uint64_t DomainRange = FERuntimeData_GetDomainRange(a1, (unsigned __int16)v112[v53], &v103);
            if ((DomainRange & 0x80000000) != 0) {
              goto LABEL_104;
            }
            log_OutText(*(void *)(*(void *)a1 + 32), *(void *)(a1 + 184), 5, 0, (uint64_t)"Domain %d : range %d,%d", v43, v44, v45, v53);
            *(_WORD *)(*v16 + 46) = *(_WORD *)(v103 + 2);
            uint64_t DomainRange = FERuntimeData_GetDomainBlockIndex((void *)a1, (unsigned __int16)v112[v53], &v102, &v104);
            if ((DomainRange & 0x80000000) != 0) {
              goto LABEL_104;
            }
            uint64_t DomainDefBlockInfo = FEData_blockData_newGetDomainDefBlockInfo((void *)a1, (unsigned __int16)v102, &v101, v41, v42, v43, v44, v45);
            if ((DomainDefBlockInfo & 0x80000000) != 0) {
              goto LABEL_105;
            }
            if (v104 > *(unsigned __int16 *)(v101 + 24)) {
              break;
            }
            uint64_t v55 = *(void *)(v101 + 40) + 16 * *(unsigned __int16 *)(*(void *)(v101 + 16) + 72 * v104 + 12);
            log_OutText(*(void *)(*(void *)a1 + 32), *(void *)(a1 + 184), 5, 0, (uint64_t)"doing domain %d, Domain[%s:%s] (applying %d rules)", v43, v44, v45, v53);
            if (*(_WORD *)(v55 + 8))
            {
              uint64_t v56 = *v16;
              if (*(_DWORD *)(*v16 + 72) != 1)
              {
                uint64_t v57 = 0;
                uint64_t v58 = 0;
                while (1)
                {
                  uint64_t v59 = *(void *)v55 + v57;
                  *(_WORD *)(v56 + 40) = 0;
                  uint64_t v60 = v56 + 40;
                  *(void *)(v60 + 16) = v59;
                  uint64_t DomainDefBlockInfo = FEData_blockData_getTokenAndRegexData_NNTN((void *)a1, v59, (void *)(v60 - 8), (_WORD *)v60, (void *)(v60 - 16), &v100, v44, v45);
                  if ((DomainDefBlockInfo & 0x80000000) != 0) {
                    goto LABEL_105;
                  }
                  BOOL v61 = v36 < 2;
                  BOOL v62 = v36 == 2;
                  if (v100 != 1) {
                    BOOL v62 = 0;
                  }
                  BOOL v64 = v36 == 1 && v100 == 2;
                  if (v36) {
                    BOOL v65 = 0;
                  }
                  else {
                    BOOL v65 = v100 == 3;
                  }
                  char v66 = v65;
                  if (v100 != 4) {
                    BOOL v61 = 0;
                  }
                  if (!v100 || v62 || v64 || (v66 & 1) != 0 || v61) {
                    break;
                  }
                  if (v100 == 5)
                  {
                    if ((v36 & 0xFFFFFFFD) == 0) {
                      break;
                    }
                  }
                  else if (v100 == 6 && v36 - 1 < 2)
                  {
                    break;
                  }
                  log_OutText(*(void *)(*(void *)a1 + 32), *(void *)(a1 + 184), 5, 0, (uint64_t)"rule %s (token %s, %d,%d) blocked by triggerType %s", v43, v44, v45, *(void *)(*v16 + 24));
LABEL_68:
                  if (++v58 < (unint64_t)*(unsigned __int16 *)(v55 + 8))
                  {
                    v57 += 24;
                    uint64_t v56 = *v16;
                    if (*(_DWORD *)(*v16 + 72) != 1) {
                      continue;
                    }
                  }
                  goto LABEL_70;
                }
                uint64_t v67 = *v16;
                uint64_t v68 = *(uint64_t **)(*v16 + 16);
                uint64_t v69 = *v68;
                *(unsigned char *)(v69 + 82) = 0;
                *(_WORD *)(v69 + 40) = 0;
                v68[2] = *(void *)(a1 + 304);
                void v68[3] = *(void *)(v67 + 24);
                *(void *)(v69 + 96) = *(void *)(v67 + 56);
                *(_WORD *)(v69 + 104) = v102;
                *(_WORD *)(v69 + 106) = v104;
                *((_WORD *)v68 + 26) = *(_WORD *)(v67 + 44);
                *((_WORD *)v68 + 27) = *(_WORD *)(v67 + 46);
                *((_DWORD *)v68 + 11) = 0;
                *((_DWORD *)v68 + 12) = 0;
                uint64_t DomainDefBlockInfo = tokenizer_apply_regex_NNTN((uint64_t *)a1, v67, &v98);
                if ((DomainDefBlockInfo & 0x80000000) != 0) {
                  goto LABEL_105;
                }
                uint64_t v70 = *(void *)(*v16 + 16);
                **(_DWORD **)(v70 + 8) = 0;
                *(_DWORD *)(v70 + 44) = 0;
                goto LABEL_68;
              }
            }
LABEL_70:
            if (++v53 >= (unint64_t)HIWORD(v102)) {
              goto LABEL_71;
            }
          }
          log_OutPublic(*(void *)(*(void *)a1 + 32), *(void *)(a1 + 184), 24028, "%s%d%s%d", v42, v43, v44, v45, "domain");
          return NNTNERROR(0);
        }
LABEL_71:
        log_OutText(*(void *)(*(void *)a1 + 32), *(void *)(a1 + 184), 5, 0, (uint64_t)"END of loop for basic token %d,%d", v43, v44, v45, v47);
        FERuntimeData_FreeMatches((void *)a1, 0, v71, v72, v73, v74, v75, v76);
      }
      uint64_t v34 = v98 + 1;
      unsigned __int16 v98 = v34;
    }
    while ((unint64_t)v34 < v95);
  }
  if ((paramc_ParamGetStr(*(void *)(*(void *)a1 + 40), (uint64_t)"spaceInPYT", &v99) & 0x80000000) != 0
    || LH_stricmp(v99, "yes"))
  {
    goto LABEL_105;
  }
  uint64_t DomainDefBlockInfo = 0;
  unint64_t v110 = 0;
  uint64_t v111 = 0;
  __s1 = 0;
  uint64_t v109 = 0;
  uint64_t v77 = *(void *)(*(void *)(a1 + 264) + 16);
  uint64_t v78 = *(uint64_t **)(v77 + 80);
  if ((unint64_t)v78 < *(void *)(v77 + 88))
  {
    uint64_t v79 = 0;
    int v80 = 0;
    do
    {
      uint64_t v107 = 0;
      if (v79)
      {
        int v81 = LDOObject_GetType(*v79, (uint64_t *)&v107);
        uint64_t v17 = LH_ERROR_to_VERROR(v81);
        if ((v17 & 0x80000000) != 0) {
          return v17;
        }
      }
      int v82 = LDOTreeNode_ComputeAbsoluteFrom(*v78, (_DWORD *)&v111 + 1);
      uint64_t v17 = LH_ERROR_to_VERROR(v82);
      if ((v17 & 0x80000000) != 0) {
        return v17;
      }
      int v83 = LDOTreeNode_ComputeAbsoluteTo(*v78, &v111);
      uint64_t DomainDefBlockInfo = LH_ERROR_to_VERROR(v83);
      if ((DomainDefBlockInfo & 0x80000000) != 0) {
        return DomainDefBlockInfo;
      }
      if (v79 && ((uint64_t v84 = v107, !strcmp(v107, "TOKEN_PUNCT")) || !strcmp(v84, "TOKEN_WSPACE")))
      {
        int v80 = 1;
      }
      else
      {
        int v85 = LDO_ComputeOverlappingLabels(*(void *)(a1 + 264), (unsigned int *)&v111 + 1, (unsigned int *)&v111, 0, (unsigned int *)&__s1);
        uint64_t DomainDefBlockInfo = LH_ERROR_to_VERROR(v85);
        if ((DomainDefBlockInfo & 0x80000000) != 0) {
          return DomainDefBlockInfo;
        }
        for (uint64_t i = v109; (unint64_t)i < v110; ++i)
        {
          unsigned int v106 = 0;
          int v105 = 0;
          int StringAttribute = LDOObject_GetStringAttribute(*i, "TNTAG", &v105, (uint64_t *)&v106);
          uint64_t DomainDefBlockInfo = LH_ERROR_to_VERROR(StringAttribute);
          if ((DomainDefBlockInfo & 0x80000000) != 0) {
            goto LABEL_99;
          }
          if (v105 && !strcmp(v106, "_PI1a_"))
          {
            if (v80 == 1) {
              uint64_t v88 = "left";
            }
            else {
              uint64_t v88 = "none";
            }
            int v89 = LDOObject_SetStringAttribute(*v78, "INPUTSPACETAG", v88);
            uint64_t DomainDefBlockInfo = LH_ERROR_to_VERROR(v89);
            if ((DomainDefBlockInfo & 0x80000000) != 0) {
              goto LABEL_99;
            }
            int v80 = 0;
          }
        }
        LDO_FreeLDOLabelVector(*(void *)(a1 + 264), (uint64_t)&__s1);
        uint64_t v79 = v78;
      }
      ++v78;
    }
    while ((unint64_t)v78 < *(void *)(v77 + 88));
  }
LABEL_99:
  if (v109) {
    LDO_FreeLDOLabelVector(*(void *)(a1 + 264), (uint64_t)&__s1);
  }
  if ((DomainDefBlockInfo & 0x80000000) == 0)
  {
LABEL_105:
    FERuntimeData_FreeMatches((void *)a1, 1, v40, v41, v42, v43, v44, v45);
    uint64_t v32 = *(void *)(*(void *)a1 + 32);
    uint64_t v33 = *(void *)(a1 + 184);
    uint64_t v90 = "nntn : AllInOneLoop End (%x)";
    uint64_t v94 = DomainDefBlockInfo;
    uint64_t v91 = 4;
    goto LABEL_106;
  }
  return DomainDefBlockInfo;
}

BOOL isEnglishLetter(char *a1)
{
  unsigned int v2 = strlen(a1);
  int WCharFromUtf8 = utf8_GetWCharFromUtf8(a1, 0, v2);
  if ((*a1 & 0xDFu) - 65 < 0x1A
    || (WCharFromUtf8 - 192) < 0x17
    || (unsigned __int16)(WCharFromUtf8 - 216) < 7u
    || (unsigned __int16)(WCharFromUtf8 - 223) < 0x18u
    || (WCharFromUtf8 & 0xFFF8) == 0xF8
    || (WCharFromUtf8 - 256) <= 0x36 && (WCharFromUtf8 & 1) == 0
    || (unsigned __int16)(WCharFromUtf8 - 328) >= 0xFFF1u && (WCharFromUtf8 & 1) != 0
    || (WCharFromUtf8 - 330) <= 0x2E && (WCharFromUtf8 & 1) == 0
    || (unsigned __int16)(WCharFromUtf8 - 382) >= 0xFFFBu && (WCharFromUtf8 & 1) != 0)
  {
    return 1;
  }
  BOOL v5 = (WCharFromUtf8 - 312) < 0x11;
  if (WCharFromUtf8) {
    BOOL v5 = (unsigned __int16)(WCharFromUtf8 - 312) > 0xFFC8u;
  }
  if (v5 || (unsigned __int16)(WCharFromUtf8 - 376) >= 0xFFD1u && (WCharFromUtf8 & 1) != 0) {
    return 1;
  }
  if ((WCharFromUtf8 - 378) <= 4) {
    return (WCharFromUtf8 & 1) == 0;
  }
  return WCharFromUtf8 == 383;
}

uint64_t updateLDOTreeNode_CHN(uint64_t *a1, _DWORD *a2)
{
  uint64_t v110 = 0;
  uint64_t v111 = 0;
  uint64_t v108 = 0;
  __s1 = 0;
  int v107 = 0;
  uint64_t v4 = *(void *)(a1[33] + 16);
  NumberChildreuint64_t n = LDOTreeNode_GetNumberChildren(v4);
  *a2 = NumberChildren;
  if (!NumberChildren)
  {
    uint64_t UTF8Char = 0;
    goto LABEL_127;
  }
  uint64_t v6 = heap_Calloc(*(void **)(*a1 + 8), 1, *((unsigned __int16 *)a1 + 156) + 1);
  uint64_t v11 = *a1;
  if (!v6)
  {
    log_OutPublic(*(void *)(v11 + 32), (uint64_t)"FE_NNTN", 37000, 0, v7, v8, v9, v10, v97);
    uint64_t UTF8Char = NNTNERROR(10);
    goto LABEL_127;
  }
  uint64_t v12 = v6;
  uint64_t v17 = (char *)heap_Calloc(*(void **)(v11 + 8), 1, *((unsigned __int16 *)a1 + 156) + 1);
  uint64_t v18 = *a1;
  if (!v17) {
    goto LABEL_108;
  }
  uint64_t v19 = heap_Calloc(*(void **)(v18 + 8), 1, 48 * *a2);
  if (!v19)
  {
    uint64_t v18 = *a1;
LABEL_108:
    log_OutPublic(*(void *)(v18 + 32), (uint64_t)"FE_NNTN", 37000, 0, v13, v14, v15, v16, v97);
    uint64_t UTF8Char = NNTNERROR(10);
    uint64_t v20 = 0;
    int v90 = 0;
    goto LABEL_124;
  }
  uint64_t v20 = v19;
  uint64_t v21 = *(size_t **)(v4 + 80);
  if ((unint64_t)v21 >= *(void *)(v4 + 88))
  {
    uint64_t UTF8Char = 0;
  }
  else
  {
    unsigned __int16 v98 = 0;
    do
    {
      if (!v21)
      {
        int v91 = 6;
        goto LABEL_114;
      }
      int v22 = LDOTreeNode_ComputeText(*v21, &v111);
      uint64_t v23 = LH_ERROR_to_VERROR(v22);
      if ((v23 & 0x80000000) != 0
        || (long long __s = (char *)fst::FstImpl<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::Properties(v111),
            int v24 = LDOTreeNode_ComputeAbsoluteFrom(*v21, (_DWORD *)&v110 + 1),
            uint64_t v23 = LH_ERROR_to_VERROR(v24),
            (v23 & 0x80000000) != 0)
        || (v25 = LDOTreeNode_ComputeAbsoluteTo(*v21, &v110), uint64_t v23 = LH_ERROR_to_VERROR(v25), (v23 & 0x80000000) != 0))
      {
LABEL_115:
        uint64_t UTF8Char = v23;
        goto LABEL_116;
      }
      int v26 = v110;
      int v27 = HIDWORD(v110);
      int Type = LDOObject_GetType(*v21, (uint64_t *)&__s1);
      uint64_t UTF8Char = LH_ERROR_to_VERROR(Type);
      if ((UTF8Char & 0x80000000) != 0) {
        goto LABEL_116;
      }
      if (!strcmp(__s1, "TOKEN_ALPHA"))
      {
        uint64_t UTF8Char = utf8_getUTF8Char((uint64_t)__s, 0, v17);
        if ((UTF8Char & 0x80000000) != 0) {
          goto LABEL_116;
        }
        unsigned int v100 = v26 - v27;
        if (v26 - v27 > (unsigned __int16)strlen(v17))
        {
          uint64_t v30 = (void *)OOCAllocator_Realloc((uint64_t)(a1 + 28), 0, 64, &v107);
          if (!v107)
          {
            uint64_t v103 = 0;
            __s2 = v17;
            uint64_t v99 = (char *)v12;
            int v102 = 0;
            unsigned int v31 = 0;
            int v101 = 0;
            int v32 = 0;
            unsigned int NextUtf8Offset = 0;
            *uint64_t v30 = *v21;
            uint64_t v34 = (void *)(v20 + 48 * v98);
            *uint64_t v34 = 8;
            v34[1] = v30;
            long long v34[2] = v30 + 1;
            unint64_t v35 = __s;
            while (1)
            {
              uint64_t v36 = (uint64_t)v35;
              unsigned int v105 = NextUtf8Offset;
              uint64_t v17 = __s2;
              uint64_t UTF8Char = utf8_getUTF8Char(v36, NextUtf8Offset, __s2);
              if ((UTF8Char & 0x80000000) != 0)
              {
                uint64_t v12 = (uint64_t)v99;
                goto LABEL_116;
              }
              unsigned __int16 v37 = strlen(__s2);
              BOOL v38 = isEnglishLetter(__s2);
              if (!(v38 | v32)) {
                break;
              }
              if (v32 == 1 && !v38)
              {
                int v39 = PNEW_LDOTreeNode_ConRoot((uint64_t)(a1 + 28), (uint64_t)(a1 + 28), v99, "TOKEN", "TOKEN_ALPHA", &v108);
                uint64_t v40 = LH_ERROR_to_VERROR(v39);
                unint64_t v35 = __s;
                if ((v40 & 0x80000000) != 0) {
                  goto LABEL_110;
                }
                LDOObject_SetU32Attribute(v108, "_TTYPE", 0);
                uint64_t UTF8Char = LH_ERROR_to_VERROR(v41);
                if ((UTF8Char & 0x80000000) != 0) {
                  goto LABEL_111;
                }
                uint64_t v42 = v102;
                unint64_t v43 = (unint64_t)v102 - v103;
                unsigned int v44 = (((unint64_t)v102 - v103) >> 3) + 1;
                if (v44 > v31)
                {
                  unsigned int v45 = 2 * v31;
                  if (2 * v31 >= v31 + 1000000) {
                    unsigned int v45 = v31 + 1000000;
                  }
                  if (v45 > v44) {
                    unsigned int v44 = v45;
                  }
                  if (v44 <= 8) {
                    unsigned int v46 = 8;
                  }
                  else {
                    unsigned int v46 = v44;
                  }
                  uint64_t v47 = OOCAllocator_Realloc((uint64_t)(a1 + 28), v103, 8 * v46, &v107);
                  if (v107) {
                    goto LABEL_111;
                  }
                  uint64_t v103 = v47;
                  uint64_t v42 = (void *)(v47 + (v43 & 0x7FFFFFFF8));
                  unsigned int v31 = v46;
                }
                void *v42 = v108;
                uint64_t v48 = v42 + 1;
                v99[2] = 0;
                *(_WORD *)uint64_t v99 = 0;
                int v49 = PNEW_LDOTreeNode_ConRoot((uint64_t)(a1 + 28), (uint64_t)(a1 + 28), __s2, "TOKEN", "TOKEN_ALPHA", &v108);
                uint64_t v40 = LH_ERROR_to_VERROR(v49);
                if ((v40 & 0x80000000) != 0) {
                  goto LABEL_110;
                }
                LDOObject_SetU32Attribute(v108, "_TTYPE", 0);
                uint64_t UTF8Char = LH_ERROR_to_VERROR(v50);
                if ((UTF8Char & 0x80000000) != 0) {
                  goto LABEL_111;
                }
                uint64_t v51 = v48;
                unint64_t v52 = (unint64_t)v48 - v103;
                unsigned int v53 = (v52 >> 3) + 1;
                if (v53 > v31)
                {
                  unsigned int v54 = 2 * v31;
                  if (2 * v31 >= v31 + 1000000) {
                    unsigned int v54 = v31 + 1000000;
                  }
                  if (v54 > v53) {
                    unsigned int v53 = v54;
                  }
                  if (v53 <= 8) {
                    unsigned int v55 = 8;
                  }
                  else {
                    unsigned int v55 = v53;
                  }
                  uint64_t v56 = OOCAllocator_Realloc((uint64_t)(a1 + 28), v103, 8 * v55, &v107);
                  if (v107) {
                    goto LABEL_111;
                  }
                  uint64_t v103 = v56;
                  uint64_t v51 = (void *)(v56 + (v52 & 0x7FFFFFFF8));
                  unsigned int v31 = v55;
                }
                int v32 = 0;
                void *v51 = v108;
                int v102 = v51 + 1;
                int v57 = v101 + 2;
                goto LABEL_77;
              }
              int v65 = v105;
              unsigned int v66 = v105 + v37;
              BOOL v67 = !v38;
              if (v32 != 1) {
                BOOL v67 = 1;
              }
              unint64_t v35 = __s;
              if (v67)
              {
                if (v32 || !v38) {
                  goto LABEL_96;
                }
                *uint64_t v99 = 0;
                strcat(v99, __s2);
                if (v66 == v100)
                {
                  int v76 = PNEW_LDOTreeNode_ConRoot((uint64_t)(a1 + 28), (uint64_t)(a1 + 28), v99, "TOKEN", "TOKEN_ALPHA", &v108);
                  uint64_t v40 = LH_ERROR_to_VERROR(v76);
                  if ((v40 & 0x80000000) != 0)
                  {
LABEL_110:
                    uint64_t UTF8Char = v40;
LABEL_111:
                    uint64_t v12 = (uint64_t)v99;
                    uint64_t v17 = __s2;
                    goto LABEL_116;
                  }
                  LDOObject_SetU32Attribute(v108, "_TTYPE", 0);
                  uint64_t UTF8Char = LH_ERROR_to_VERROR(v77);
                  if ((UTF8Char & 0x80000000) != 0) {
                    goto LABEL_111;
                  }
                  uint64_t v78 = v102;
                  unint64_t v79 = (unint64_t)v102 - v103;
                  unsigned int v80 = (((unint64_t)v102 - v103) >> 3) + 1;
                  if (v80 > v31)
                  {
                    unsigned int v81 = 2 * v31;
                    if (2 * v31 >= v31 + 1000000) {
                      unsigned int v81 = v31 + 1000000;
                    }
                    if (v81 > v80) {
                      unsigned int v80 = v81;
                    }
                    if (v80 <= 8) {
                      unsigned int v82 = 8;
                    }
                    else {
                      unsigned int v82 = v80;
                    }
                    uint64_t v83 = OOCAllocator_Realloc((uint64_t)(a1 + 28), v103, 8 * v82, &v107);
                    if (v107) {
                      goto LABEL_111;
                    }
                    uint64_t v103 = v83;
                    uint64_t v78 = (void *)(v83 + (v79 & 0x7FFFFFFF8));
                    unsigned int v31 = v82;
                  }
                  void *v78 = v108;
                  int v102 = v78 + 1;
                  ++v101;
                  v99[2] = 0;
                  *(_WORD *)uint64_t v99 = 0;
                }
              }
              else
              {
                strcat(v99, __s2);
                if (v66 == v100)
                {
                  int v68 = PNEW_LDOTreeNode_ConRoot((uint64_t)(a1 + 28), (uint64_t)(a1 + 28), v99, "TOKEN", "TOKEN_ALPHA", &v108);
                  uint64_t v40 = LH_ERROR_to_VERROR(v68);
                  if ((v40 & 0x80000000) != 0) {
                    goto LABEL_110;
                  }
                  LDOObject_SetU32Attribute(v108, "_TTYPE", 0);
                  uint64_t UTF8Char = LH_ERROR_to_VERROR(v69);
                  if ((UTF8Char & 0x80000000) != 0) {
                    goto LABEL_111;
                  }
                  uint64_t v70 = v102;
                  unint64_t v71 = (unint64_t)v102 - v103;
                  unsigned int v72 = (((unint64_t)v102 - v103) >> 3) + 1;
                  if (v72 > v31)
                  {
                    unsigned int v73 = 2 * v31;
                    if (2 * v31 >= v31 + 1000000) {
                      unsigned int v73 = v31 + 1000000;
                    }
                    if (v73 > v72) {
                      unsigned int v72 = v73;
                    }
                    if (v72 <= 8) {
                      unsigned int v74 = 8;
                    }
                    else {
                      unsigned int v74 = v72;
                    }
                    uint64_t v75 = OOCAllocator_Realloc((uint64_t)(a1 + 28), v103, 8 * v74, &v107);
                    if (v107) {
                      goto LABEL_111;
                    }
                    uint64_t v103 = v75;
                    uint64_t v70 = (void *)(v75 + (v71 & 0x7FFFFFFF8));
                    unsigned int v31 = v74;
                  }
                  int v32 = 0;
                  *uint64_t v70 = v108;
                  int v102 = v70 + 1;
                  ++v101;
                  v99[2] = 0;
                  *(_WORD *)uint64_t v99 = 0;
                  goto LABEL_95;
                }
              }
              int v32 = 1;
LABEL_95:
              int v65 = v105;
LABEL_96:
              unsigned int NextUtf8Offset = utf8_GetNextUtf8Offset(v35, v65);
              if (NextUtf8Offset >= v100)
              {
                uint64_t v84 = v20 + 48 * v98;
                *(_DWORD *)(v84 + 24) = v31;
                *(_DWORD *)(v84 + 28) = 0;
                *(void *)(v84 + 32) = v103;
                *(void *)(v84 + 40) = v102;
                if ((((unint64_t)v102 - v103) >> 3) == (unsigned __int16)v101)
                {
                  uint64_t v12 = (uint64_t)v99;
                  ++v98;
                  uint64_t v17 = __s2;
                  goto LABEL_99;
                }
                int v91 = 0;
                uint64_t v12 = (uint64_t)v99;
                uint64_t v17 = __s2;
LABEL_114:
                uint64_t v23 = NNTNERROR(v91);
                goto LABEL_115;
              }
            }
            int v58 = PNEW_LDOTreeNode_ConRoot((uint64_t)(a1 + 28), (uint64_t)(a1 + 28), __s2, "TOKEN", "TOKEN_ALPHA", &v108);
            uint64_t v40 = LH_ERROR_to_VERROR(v58);
            if ((v40 & 0x80000000) != 0) {
              goto LABEL_110;
            }
            LDOObject_SetU32Attribute(v108, "_TTYPE", 0);
            uint64_t UTF8Char = LH_ERROR_to_VERROR(v59);
            if ((UTF8Char & 0x80000000) != 0) {
              goto LABEL_111;
            }
            uint64_t v60 = v102;
            unint64_t v61 = (unint64_t)v102 - v103;
            unsigned int v62 = (((unint64_t)v102 - v103) >> 3) + 1;
            if (v62 <= v31)
            {
              unint64_t v35 = __s;
            }
            else
            {
              unsigned int v63 = 2 * v31;
              if (2 * v31 >= v31 + 1000000) {
                unsigned int v63 = v31 + 1000000;
              }
              if (v63 > v62) {
                unsigned int v62 = v63;
              }
              if (v62 <= 8) {
                unsigned int v31 = 8;
              }
              else {
                unsigned int v31 = v62;
              }
              uint64_t v64 = OOCAllocator_Realloc((uint64_t)(a1 + 28), v103, 8 * v31, &v107);
              unint64_t v35 = __s;
              if (v107) {
                goto LABEL_111;
              }
              uint64_t v103 = v64;
              uint64_t v60 = (void *)(v64 + (v61 & 0x7FFFFFFF8));
            }
            int v32 = 0;
            void *v60 = v108;
            int v102 = v60 + 1;
            int v57 = v101 + 1;
LABEL_77:
            int v101 = v57;
            goto LABEL_95;
          }
          goto LABEL_116;
        }
      }
LABEL_99:
      uint64_t v85 = LDOString_BorrowAllocator(v111);
      OOC_PlacementDeleteObject(v85, v111);
      ++v21;
    }
    while ((unint64_t)v21 < *(void *)(v4 + 88));
    if (!v98) {
      goto LABEL_123;
    }
    uint64_t v86 = v98 - 1;
    uint64_t v87 = v20;
    do
    {
      uint64_t v88 = v86;
      int v89 = LDO_ReplaceNodes(a1[33], v87, v87 + 24);
      uint64_t UTF8Char = LH_ERROR_to_VERROR(v89);
      if ((UTF8Char & 0x80000000) != 0) {
        break;
      }
      uint64_t v86 = v88 - 1;
      v87 += 48;
    }
    while (v88);
LABEL_116:
    if (v98)
    {
      uint64_t v92 = 0;
      do
      {
        uint64_t v93 = v20 + v92;
        *(_DWORD *)(v20 + v92) = 0;
        uint64_t v94 = *(void *)(v20 + v92 + 8);
        if (v94)
        {
          OOCAllocator_Free((uint64_t)(a1 + 28), v94);
          *(void *)(v93 + 8) = 0;
        }
        *(void *)(v93 + 16) = 0;
        *(_DWORD *)(v93 + 24) = 0;
        uint64_t v95 = *(void *)(v93 + 32);
        if (v95)
        {
          OOCAllocator_Free((uint64_t)(a1 + 28), v95);
          *(void *)(v93 + 32) = 0;
        }
        *(void *)(v20 + v92 + 40) = 0;
        v92 += 48;
      }
      while (48 * v98 != v92);
    }
  }
LABEL_123:
  int v90 = 1;
LABEL_124:
  heap_Free(*(void **)(*a1 + 8), v12);
  if (v17)
  {
    heap_Free(*(void **)(*a1 + 8), (uint64_t)v17);
    if ((v90 & 1) == 0) {
      goto LABEL_127;
    }
    goto LABEL_126;
  }
  if (v90) {
LABEL_126:
  }
    heap_Free(*(void **)(*a1 + 8), v20);
LABEL_127:
  if (v107) {
    return NNTNERROR(0);
  }
  return UTF8Char;
}

uint64_t applyIgtreeExpansion(uint64_t a1, __int16 *a2, char *a3, char **a4, _DWORD *a5)
{
  uint64_t v10 = (char *)heap_Alloc(*(void *)(*(void *)a1 + 8), 1024);
  if (v10)
  {
    uint64_t v15 = v10;
    *uint64_t v10 = 0;
    uint64_t v16 = fe_nntn_IGTR(a1, a2, a3, v10, a5, v12, v13, v14);
    if (*a5 == 1) {
      strcpy(*a4, v15);
    }
    heap_Free(*(void **)(*(void *)a1 + 8), (uint64_t)v15);
    return v16;
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_NNTN", 37000, 0, v11, v12, v13, v14, v18);
    return NNTNERROR(10);
  }
}

uint64_t applyNNExpansion(_DWORD *a1, __int16 *a2, char **a3)
{
  uint64_t v6 = (char *)heap_Alloc(*(void *)(*(void *)a1 + 8), 1024);
  if (v6)
  {
    uint64_t v11 = v6;
    *uint64_t v6 = 0;
    uint64_t v12 = *(void *)(*(void *)a1 + 32);
    if (a1[210])
    {
      log_OutText(v12, (uint64_t)"FE_NNTN", 5, 0, (uint64_t)"FI prediction enabled", v8, v9, v10, 0);
      uint64_t v16 = fe_mnc_nntn_Process((uint64_t)a1, a2, v11);
      if ((v16 & 0x80000000) != 0) {
        log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_NNTN", 5, 0, (uint64_t)"FI prediction failed", v13, v14, v15, 0);
      }
      else {
        strcpy(*a3, v11);
      }
    }
    else
    {
      log_OutText(v12, (uint64_t)"FE_NNTN", 5, 0, (uint64_t)"FI prediction is not enabled", v8, v9, v10, 0);
      uint64_t v16 = 0;
    }
    heap_Free(*(void **)(*(void *)a1 + 8), (uint64_t)v11);
    return v16;
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_NNTN", 37000, 0, v7, v8, v9, v10, v18);
    return NNTNERROR(10);
  }
}

uint64_t writeExpandFuncNameToLDO(uint64_t a1, char *a2, uint64_t *a3, unsigned __int16 *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v26 = 0;
  unsigned int v11 = *a4;
  unsigned int v24 = a4[1];
  unsigned int v25 = v11;
  log_OutText(*(void *)(*(void *)a1 + 32), *(void *)(a1 + 184), 4, 0, (uint64_t)"nntn : writeExpandFuncNameToLDO Begin (%s)", a6, a7, a8, *a3);
  int v12 = LDO_AddLabelOnSubstring(*(void *)(a1 + 264), "TOKEN", "TOKEN", &v25, &v24, &v26);
  uint64_t v13 = LH_ERROR_to_VERROR(v12);
  if ((v13 & 0x80000000) != 0) {
    goto LABEL_8;
  }
  LDOObject_SetU32Attribute(v26, "_TTYPE", 6);
  uint64_t v13 = LH_ERROR_to_VERROR(v17);
  if ((v13 & 0x80000000) != 0) {
    goto LABEL_8;
  }
  int v18 = LDOObject_SetStringAttribute(v26, "TNTAG", a2);
  uint64_t v13 = LH_ERROR_to_VERROR(v18);
  if ((v13 & 0x80000000) != 0) {
    goto LABEL_8;
  }
  int v19 = LDOObject_SetStringAttribute(v26, "TNFUNCTAG", (char *)*a3);
  uint64_t v13 = LH_ERROR_to_VERROR(v19);
  if ((v13 & 0x80000000) != 0) {
    goto LABEL_8;
  }
  int v20 = LDOObject_SetStringAttribute(v26, "NORM", &byte_20D5A22AE);
  uint64_t v21 = LH_ERROR_to_VERROR(v20);
  if ((v21 & 0x80000000) == 0 && *(_WORD *)(a1 + 418))
  {
    int v22 = LDOObject_SetStringAttribute(v26, "LANGMAP", *(char **)(a1 + 408));
    uint64_t v13 = LH_ERROR_to_VERROR(v22);
LABEL_8:
    uint64_t v21 = v13;
  }
  log_OutText(*(void *)(*(void *)a1 + 32), *(void *)(a1 + 184), 4, 0, (uint64_t)"nntn : writeExpandFuncNameToLDO End (%x) ", v14, v15, v16, v21);
  return v21;
}

uint64_t sortExpansionNNTN(uint64_t *a1, uint64_t a2)
{
  int v27 = 0;
  uint64_t v4 = heap_Alloc(*(void *)(*a1 + 8), 256);
  *(void *)(*(void *)(a2 + 16) + 56) = v4;
  uint64_t v9 = *a1;
  if (!v4)
  {
    log_OutPublic(*(void *)(v9 + 32), (uint64_t)"FE_NNTN", 37000, 0, v5, v6, v7, v8, v26);
    uint64_t v23 = NNTNERROR(10);
    uint64_t v15 = 0;
    goto LABEL_22;
  }
  uint64_t v10 = (char **)heap_Calloc(*(void **)(v9 + 8), 1, 8);
  uint64_t v15 = v10;
  if (!v10)
  {
    log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_NNTN", 37000, 0, v11, v12, v13, v14, v26);
    uint64_t v22 = NNTNERROR(10);
    goto LABEL_21;
  }
  uint64_t v16 = *(void *)(a2 + 16);
  int v17 = *(__int16 **)(v16 + 8);
  int v18 = *(char **)(v16 + 56);
  *uint64_t v10 = v18;
  int v19 = *(char **)(a2 + 24);
  uint64_t v20 = *(void *)(**(void **)(a2 + 16) + 96);
  int v21 = **(unsigned __int16 **)(v20 + 8);
  if (v21 == 3)
  {
    uint64_t v22 = applyIgtreeExpansion((uint64_t)a1, v17, *(char **)(a2 + 24), v10, &v27);
    if ((v22 & 0x80000000) != 0) {
      goto LABEL_21;
    }
    if (v27) {
      goto LABEL_20;
    }
    log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NNTN", 5, 0, (uint64_t)"IGtree found NOMATCH. Set user-defined func from domain def file.", v12, v13, v14, 0);
LABEL_17:
    *uint64_t v15 = *(char **)(v20 + 16);
    goto LABEL_20;
  }
  if (v21 == 2) {
    goto LABEL_17;
  }
  if (v21 != 1)
  {
    uint64_t v23 = 0;
    goto LABEL_22;
  }
  if (*((_DWORD *)a1 + 219) >= *((_DWORD *)a1 + 218))
  {
    strcpy(v18, "DefaultFunc");
    goto LABEL_20;
  }
  if (strcmp(*(const char **)(v20 + 16), "0"))
  {
    uint64_t v22 = applyIgtreeExpansion((uint64_t)a1, v17, v19, v15, &v27);
    if ((v22 & 0x80000000) != 0) {
      goto LABEL_21;
    }
    if (v27)
    {
LABEL_20:
      uint64_t v22 = writeExpandFuncNameToLDO((uint64_t)a1, v19, (uint64_t *)v15, (unsigned __int16 *)v17, v11, v12, v13, v14);
      goto LABEL_21;
    }
  }
  uint64_t v22 = applyNNExpansion(a1, v17, v15);
  if ((v22 & 0x80000000) == 0)
  {
    ++*((_DWORD *)a1 + 219);
    goto LABEL_20;
  }
LABEL_21:
  uint64_t v23 = v22;
LABEL_22:
  uint64_t v24 = *(void *)(*(void *)(a2 + 16) + 56);
  if (v24)
  {
    heap_Free(*(void **)(*a1 + 8), v24);
    *(void *)(*(void *)(a2 + 16) + 56) = 0;
  }
  if (v15) {
    heap_Free(*(void **)(*a1 + 8), (uint64_t)v15);
  }
  log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"sortExpansionNNTN_new : DoExpansions End (%x)", v12, v13, v14, v23);
  return v23;
}

uint64_t fe_nntn_tryLoading_NNTN_igModel(_WORD *a1, uint64_t a2, uint64_t a3, char **a4)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  memset(v29, 0, 240);
  *(void *)unsigned int v26 = 0;
  uint64_t v27 = 0;
  *a4 = 0;
  *(void *)uint64_t v28 = 0;
  memset(v30, 0, 128);
  v29[15] = 0u;
  uint64_t Str = paramc_ParamGetStr(*(void *)(a3 + 40), (uint64_t)"langcode", v28);
  if ((Str & 0x80000000) != 0
    || (uint64_t Str = paramc_ParamGetStr(*(void *)(a3 + 40), (uint64_t)"fecfg", &v27), (Str & 0x80000000) != 0)
    || (__strcat_chk(),
        __strcat_chk(),
        __strcat_chk(),
        __strcat_chk(),
        uint64_t Str = brokeraux_ComposeBrokerString(a3, v30, 1, 1, *(char **)v28, 0, 0, (char *)v29, 0x100uLL),
        (Str & 0x80000000) != 0)
    || (uint64_t Str = ssftriff_reader_ObjOpen(a1, a2, 2, (const char *)v29, "IGTR", 1031, (uint64_t *)v26),
        (Str & 0x80000000) != 0))
  {
    uint64_t v21 = Str;
  }
  else
  {
    uint64_t v16 = (char *)heap_Calloc(*(void **)(a3 + 8), 1, 1600);
    *a4 = v16;
    if (v16)
    {
      uint64_t v21 = igtree_Init(a1, a2, *(uint64_t *)v26, v16);
      ssftriff_reader_CloseChunk(*(uint64_t *)v26);
      if ((v21 & 0x80001FFF) == 0x14)
      {
        ssftriff_reader_CloseChunk(*(uint64_t *)v26);
        uint64_t v21 = 0;
      }
    }
    else
    {
      log_OutPublic(*(void *)(a3 + 32), (uint64_t)"FE_NNTN", 37000, 0, v17, v18, v19, v20, v25);
      uint64_t v21 = 2589990922;
    }
  }
  if (*(void *)v26)
  {
    int v22 = ssftriff_reader_ObjClose(*(void **)v26, v9, v10, v11, v12, v13, v14, v15);
    if (v22 >= 0 || (int)v21 <= -1) {
      return v21;
    }
    else {
      return v22;
    }
  }
  return v21;
}

uint64_t fe_nntn_IGTR(uint64_t a1, __int16 *a2, char *a3, char *a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 936);
  __s1 = 0;
  uint64_t v9 = *(void *)(a1 + 944);
  if (!v9)
  {
    log_OutText(*(void *)(v8 + 32), (uint64_t)"FE_NNTN", 0, 0, (uint64_t)"IGTree model for nntn does not exist", a6, a7, a8, v60);
    return 0;
  }
  uint64_t v15 = 2589990922;
  uint64_t v16 = heap_Calloc(*(void **)(v8 + 8), 1, 8 * *(unsigned __int8 *)(v9 + 1296) - 8);
  if (v16)
  {
    uint64_t v17 = v16;
    unsigned int v18 = *(unsigned __int8 *)(v9 + 1296);
    unsigned __int16 v19 = v18 - 1;
    if (v18 != 1)
    {
      unsigned int v66 = a2;
      uint64_t v20 = (void *)v16;
      uint64_t v21 = a3;
      int v22 = a4;
      uint64_t v23 = a5;
      uint64_t v24 = v19;
      while (1)
      {
        unsigned int v25 = (_WORD *)heap_Calloc(*(void **)(v8 + 8), 1, 65);
        *uint64_t v20 = v25;
        if (!v25) {
          break;
        }
        _WORD *v25 = 61;
        ++v20;
        if (!--v24)
        {
          unsigned int v18 = *(unsigned __int8 *)(v9 + 1296);
          a5 = v23;
          a4 = v22;
          a3 = v21;
          a2 = v66;
          uint64_t v15 = 2589990922;
          goto LABEL_8;
        }
      }
      log_OutPublic(*(void *)(v8 + 32), (uint64_t)"FE_NNTN", 37000, 0, v26, v27, v28, v29, v60);
      uint64_t v15 = 2589990922;
      goto LABEL_64;
    }
LABEL_8:
    uint64_t v65 = *(void *)(a1 + 304);
    signed int v67 = *(__int16 *)(a1 + 312);
    uint64_t v30 = *(void *)(v9 + 1312);
    uint64_t v31 = heap_Calloc(*(void **)(v8 + 8), 1, 2048);
    if (v31)
    {
      uint64_t v36 = v18 - 1;
      if (v18 <= 1)
      {
        heap_Free(*(void **)(v8 + 8), v31);
        uint64_t v15 = 0;
      }
      else
      {
        unsigned int v63 = v18;
        int __dst = (char *)v31;
        __src = a3;
        unsigned int v62 = a5;
        unsigned __int16 v37 = a2;
        uint64_t v38 = 0;
        while (strcmp(*(const char **)(v30 + v38), "token"))
        {
          v38 += 8;
          if (8 * (v18 - 1) == v38)
          {
            uint64_t v39 = 0;
            goto LABEL_29;
          }
        }
        if ((*a2 & 0x80000000) == 0
          && ((v44 = (unsigned __int16)*a2, signed int v45 = a2[1], v45 > (__int16)v44) ? (v46 = v45 <= v67) : (v46 = 0), v46))
        {
          uint64_t v47 = __dst;
          strncpy(__dst, (const char *)(v65 + v44), (unsigned __int16)(v45 - v44));
        }
        else
        {
          uint64_t v47 = __dst;
          *(_WORD *)int __dst = 61;
        }
        uint64_t v39 = fe_nntn_IGTR_setFeature(v8, v30, v18, 3, v17, v47);
        if ((v39 & 0x80000000) != 0)
        {
LABEL_63:
          heap_Free(*(void **)(v8 + 8), (uint64_t)__dst);
          uint64_t v15 = v39;
          goto LABEL_64;
        }
LABEL_29:
        uint64_t v48 = 0;
        while (strcmp(*(const char **)(v30 + 8 * v48), "lchar"))
        {
          if (v36 == ++v48) {
            goto LABEL_34;
          }
        }
        nntn_feat_character(v65, v37, v67, -1, __dst);
        uint64_t v39 = fe_nntn_IGTR_setFeature(v8, v30, v63, 2, v17, __dst);
        if ((v39 & 0x80000000) != 0) {
          goto LABEL_63;
        }
LABEL_34:
        uint64_t v49 = 0;
        while (strcmp(*(const char **)(v30 + 8 * v49), "llchar"))
        {
          if (v36 == ++v49) {
            goto LABEL_39;
          }
        }
        nntn_feat_character(v65, v37, v67, -2, __dst);
        uint64_t v39 = fe_nntn_IGTR_setFeature(v8, v30, v63, 1, v17, __dst);
        if ((v39 & 0x80000000) != 0) {
          goto LABEL_63;
        }
LABEL_39:
        uint64_t v50 = 0;
        while (strcmp(*(const char **)(v30 + 8 * v50), "l3char"))
        {
          if (v36 == ++v50) {
            goto LABEL_44;
          }
        }
        nntn_feat_character(v65, v37, v67, -3, __dst);
        uint64_t v39 = fe_nntn_IGTR_setFeature(v8, v30, v63, 0, v17, __dst);
        if ((v39 & 0x80000000) != 0) {
          goto LABEL_63;
        }
LABEL_44:
        uint64_t v51 = 0;
        while (strcmp(*(const char **)(v30 + 8 * v51), "rchar"))
        {
          if (v36 == ++v51) {
            goto LABEL_49;
          }
        }
        nntn_feat_character(v65, v37, v67, 1, __dst);
        uint64_t v39 = fe_nntn_IGTR_setFeature(v8, v30, v63, 4, v17, __dst);
        if ((v39 & 0x80000000) != 0) {
          goto LABEL_63;
        }
LABEL_49:
        uint64_t v52 = 0;
        while (strcmp(*(const char **)(v30 + 8 * v52), "rrchar"))
        {
          if (v36 == ++v52) {
            goto LABEL_54;
          }
        }
        nntn_feat_character(v65, v37, v67, 2, __dst);
        uint64_t v39 = fe_nntn_IGTR_setFeature(v8, v30, v63, 5, v17, __dst);
        if ((v39 & 0x80000000) != 0) {
          goto LABEL_63;
        }
LABEL_54:
        uint64_t v53 = 0;
        while (strcmp(*(const char **)(v30 + 8 * v53), "r3char"))
        {
          if (v36 == ++v53) {
            goto LABEL_59;
          }
        }
        nntn_feat_character(v65, v37, v67, 3, __dst);
        uint64_t v39 = fe_nntn_IGTR_setFeature(v8, v30, v63, 6, v17, __dst);
        if ((v39 & 0x80000000) != 0) {
          goto LABEL_63;
        }
LABEL_59:
        unsigned int v54 = a4;
        uint64_t v55 = 0;
        while (strcmp(*(const char **)(v30 + 8 * v55), "tnpattern"))
        {
          if (v36 == ++v55)
          {
            uint64_t v15 = v39;
            uint64_t v56 = (uint64_t)__dst;
            goto LABEL_72;
          }
        }
        uint64_t v56 = (uint64_t)__dst;
        strcpy(__dst, __src);
        uint64_t v15 = fe_nntn_IGTR_setFeature(v8, v30, v63, 7, v17, __dst);
LABEL_72:
        heap_Free(*(void **)(v8 + 8), v56);
        a5 = v62;
        a4 = v54;
        if ((v15 & 0x80000000) != 0) {
          goto LABEL_64;
        }
      }
      igtree_Process(v9, v17, &__s1);
      uint64_t v40 = __s1;
      if (!strcmp(__s1, "NOMATCH"))
      {
        log_OutText(*(void *)(v8 + 32), (uint64_t)"FE_NNTN", 5, 0, (uint64_t)"No igtree rule matched", v41, v42, v43, 0);
        *a5 = 0;
      }
      else
      {
        strcpy(a4, v40);
        *a5 = 1;
      }
    }
    else
    {
      log_OutPublic(*(void *)(v8 + 32), (uint64_t)"FE_NNTN", 37000, 0, v32, v33, v34, v35, v60);
    }
LABEL_64:
    if (*(unsigned char *)(v9 + 1296) != 1)
    {
      uint64_t v57 = (unsigned __int16)(*(unsigned __int8 *)(v9 + 1296) - 1);
      int v58 = (uint64_t *)v17;
      do
      {
        if (*v58)
        {
          heap_Free(*(void **)(v8 + 8), *v58);
          uint64_t *v58 = 0;
        }
        ++v58;
        --v57;
      }
      while (v57);
    }
    heap_Free(*(void **)(v8 + 8), v17);
  }
  return v15;
}

uint64_t fe_nntn_IGTR_isFeatureRequired(uint64_t a1, unsigned int a2, int a3, _WORD *a4)
{
  if (a2 < 2) {
    return 0;
  }
  uint64_t v6 = 0;
  uint64_t v7 = a2 - 1;
  uint64_t v8 = g_featureNames_0[a3];
  while (strcmp(*(const char **)(a1 + 8 * v6), v8))
  {
    if (v7 == ++v6) {
      return 0;
    }
  }
  *a4 = v6;
  return 1;
}

uint64_t fe_nntn_IGTR_setFeature(uint64_t a1, uint64_t a2, unsigned int a3, int a4, uint64_t a5, const char *a6)
{
  unsigned __int16 v18 = -1;
  uint64_t result = fe_nntn_IGTR_isFeatureRequired(a2, a3, a4, &v18);
  if (result)
  {
    if (!*a6)
    {
      uint64_t result = 0;
      **(_WORD **)(a5 + 8 * v18) = 61;
      return result;
    }
    size_t v10 = strlen(a6);
    uint64_t v11 = v18;
    if (v10 <= 0x40)
    {
      uint64_t v12 = *(char **)(a5 + 8 * v18);
      goto LABEL_8;
    }
    uint64_t v12 = (char *)heap_Realloc(*(uint64_t **)(a1 + 8), *(void *)(a5 + 8 * v18), (unsigned __int16)v10 + 1);
    if (v12)
    {
      *(void *)(a5 + 8 * v11) = v12;
LABEL_8:
      strcpy(v12, a6);
      return 0;
    }
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_NNTN", 37000, 0, v13, v14, v15, v16, v17);
    return 2589990922;
  }
  return result;
}

uint64_t nntn_feat_character(uint64_t __s, __int16 *a2, signed int a3, int a4, unsigned char *a5)
{
  signed int v6 = *a2;
  if (v6 < 0) {
    goto LABEL_6;
  }
  signed int v8 = a2[1];
  if (v6 >= v8 || v8 > a3) {
    goto LABEL_6;
  }
  __int16 v10 = a4;
  uint64_t v11 = (char *)__s;
  if (a4 < 0)
  {
    if (!*a2) {
      goto LABEL_6;
    }
    do
    {
      long long __s = utf8_GetPreviousUtf8Offset((uint64_t)v11, v6);
      signed int v6 = __s;
      BOOL v12 = (unsigned __int16)~v10++ == 0;
    }
    while (!v12 && __s);
    goto LABEL_17;
  }
  if (a4)
  {
    signed int v6 = v8 - 1;
    if (v8 - 1 == a3) {
      goto LABEL_6;
    }
    do
    {
      long long __s = utf8_GetNextUtf8Offset(v11, v6);
      signed int v6 = __s;
      --v10;
    }
    while (v10 && __s != a3);
LABEL_17:
    if (!v10) {
      goto LABEL_20;
    }
LABEL_6:
    *(_WORD *)a5 = 61;
    return __s;
  }
  signed int v6 = 0;
LABEL_20:
  long long __s = utf8_getUTF8Char((uint64_t)v11, v6, a5);
  if ((__s & 0x80000000) != 0 || !*a5) {
    goto LABEL_6;
  }
  return __s;
}

uint64_t NNTNERROR(int a1)
{
  return a1 | 0x9A602000;
}

uint64_t fe_nntn_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2589990913;
  }
  uint64_t result = 0;
  *a2 = &ITokenizer;
  return result;
}

uint64_t NNTN_ClassOpen(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0;
  if (!a3) {
    return 2589990919;
  }
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *(void *)a3 = a1;
    *(void *)(a3 + 8) = a2;
  }
  return result;
}

uint64_t NNTN_ClassClose()
{
  return 0;
}

uint64_t NNTN_ObjOpen(_WORD *a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v78 = *MEMORY[0x263EF8340];
  uint64_t v75 = 0;
  uint64_t v76 = 0;
  uint64_t v73 = 0;
  uint64_t v74 = 0;
  uint64_t v5 = 2589990922;
  uint64_t v71 = 0;
  uint64_t v72 = 0;
  int v69 = 0;
  uint64_t v70 = 0;
  memset(v77, 0, sizeof(v77));
  if (!a5) {
    return 2589990919;
  }
  uint64_t v68 = 0;
  *(void *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  uint64_t inited = InitRsrcFunction(a3, a4, &v76);
  if ((inited & 0x80000000) == 0)
  {
    uint64_t inited = InitRsrcFunction(a1, a2, &v75);
    if ((inited & 0x80000000) == 0)
    {
      log_OutText(*(void *)(v76 + 32), (uint64_t)"FE_NNTN", 4, 0, (uint64_t)"nntn : ObjOpen Begin", v12, v13, v14, v65);
      uint64_t v15 = heap_Calloc(*(void **)(v76 + 8), 1, 16);
      if (!v15)
      {
        log_OutPublic(*(void *)(v76 + 32), (uint64_t)"FE_NNTN", 21000, 0, v16, v17, v18, v19, v66);
LABEL_49:
        uint64_t v60 = *(void *)(v76 + 32);
        unint64_t v61 = "nntn : ObjOpen End (%x)";
        uint64_t v66 = v5;
        uint64_t v62 = 4;
LABEL_50:
        log_OutText(v60, (uint64_t)"FE_NNTN", v62, 0, (uint64_t)v61, v25, v26, v27, v66);
        return v5;
      }
      uint64_t v20 = v15;
      *(void *)uint64_t v15 = 0;
      *(_DWORD *)(v15 + 8) = 0;
      uint64_t v21 = heap_Calloc(*(void **)(v76 + 8), 1, 968);
      if (!v21)
      {
LABEL_48:
        NNTN_loc_ObjClose(v76, (uint64_t *)v20, v22, v23, v24, v25, v26, v27);
        goto LABEL_49;
      }
      uint64_t v28 = v21;
      *(void *)uint64_t v20 = v21;
      uint64_t v67 = v20;
      *(_DWORD *)(v20 + 8) = 58765;
      *(void *)uint64_t v21 = v76;
      *(void *)(v21 + 8) = a3;
      uint64_t v29 = v75;
      *(void *)(v21 + 16) = a4;
      *(void *)(v21 + 24) = v29;
      *(void *)(v21 + 32) = a1;
      *(void *)(v21 + 40) = a2;
      *(void *)(v21 + 96) = 0;
      uint64_t v30 = (_OWORD *)(v21 + 96);
      *(_DWORD *)(v21 + 104) = 0;
      *(void *)(v21 + 120) = 0;
      uint64_t v31 = (_OWORD *)(v21 + 120);
      *(_DWORD *)(v21 + 128) = 0;
      *(void *)(v21 + 152) = 0;
      *(void *)(v21 + 160) = 0;
      *(void *)(v21 + 176) = 0;
      *(void *)(v21 + 184) = "FE_NNTN";
      *(_WORD *)(v21 + 336) = 0;
      *(void *)(v21 + 344) = 0;
      *(unsigned char *)(v21 + 352) = 0;
      *(_DWORD *)(v21 + 548) = 0;
      *(void *)(v21 + 552) = 0;
      *(void *)(v21 + 520) = 0;
      *(_WORD *)(v21 + 528) = 0;
      *(void *)(v21 + 536) = 0;
      *(_WORD *)(v21 + 544) = 0;
      *(void *)(v21 + 288) = 0;
      *(_DWORD *)(v21 + 296) = 0;
      *(_WORD *)(v21 + 608) = 257;
      *(void *)(v21 + 856) = 0;
      *(void *)(v21 + 888) = 0;
      *(_WORD *)(v21 + 280) = 32;
      if ((paramc_ParamGetUInt(*(void *)(v76 + 40), (uint64_t)"tokentninitstrlen", (unsigned int *)&v71 + 1) & 0x80000000) == 0) {
        *(_WORD *)(v28 + 280) = WORD2(v71);
      }
      *(_WORD *)(v28 + 282) = 5;
      if ((paramc_ParamGetUInt(*(void *)(v76 + 40), (uint64_t)"tokentnmaxpcreframeblocks", (unsigned int *)&v71 + 1) & 0x80000000) == 0) {
        *(_WORD *)(v28 + 282) = WORD2(v71);
      }
      *(_WORD *)(v28 + 284) = 20;
      if ((paramc_ParamGetUInt(*(void *)(v76 + 40), (uint64_t)"tokentnnumframesinblock", (unsigned int *)&v71 + 1) & 0x80000000) == 0) {
        *(_WORD *)(v28 + 284) = WORD2(v71);
      }
      uint64_t v32 = nuance_pcre_ObjOpen(a3, a4, v28 + 136);
      if ((v32 & 0x80000000) != 0)
      {
        uint64_t v59 = v32;
        log_OutPublic(*(void *)(*(void *)v28 + 32), *(void *)(v28 + 184), 24021, 0, v33, v34, v35, v36, v66);
        uint64_t v5 = v59;
LABEL_47:
        uint64_t v20 = v67;
        goto LABEL_48;
      }
      uint64_t Object = addIdentifier2List(v28, "x");
      if ((Object & 0x80000000) == 0)
      {
        if ((objc_GetObject(*(void *)(v76 + 48), (uint64_t)"FE_DCTLKP", &v73) & 0x80000000) != 0)
        {
          uint64_t v64 = 24022;
        }
        else
        {
          uint64_t v42 = v73;
          *(void *)(v28 + 88) = *(void *)(v73 + 8);
          *uint64_t v30 = *(_OWORD *)(v42 + 16);
          if ((objc_GetObject(*(void *)(v76 + 48), (uint64_t)"FE_DEPES", &v72) & 0x80000000) == 0)
          {
            uint64_t v43 = v72;
            *(void *)(v28 + 112) = *(void *)(v72 + 8);
            *uint64_t v31 = *(_OWORD *)(v43 + 16);
            uint64_t Object = objc_GetObject(*(void *)(v76 + 48), (uint64_t)"LINGDB", &v74);
            if ((Object & 0x80000000) == 0)
            {
              *(void *)(v28 + 64) = *(void *)(v74 + 8);
              uint64_t IDStrings = FEData_ObjOpen_NNTN((uint64_t)a3, a4, (uint64_t *)v28, v23, v24, v25, v26, v27);
              uint64_t v20 = v67;
              if ((IDStrings & 0x80000000) != 0) {
                goto LABEL_56;
              }
              uint64_t IDStrings = FERuntimeData_ObjOpen((uint64_t *)v28, v45, v22, v23, v24, v25, v26, v27);
              if ((IDStrings & 0x80000000) != 0) {
                goto LABEL_56;
              }
              uint64_t IDStrings = FEFunctionMap_ObjOpen((uint64_t *)v28, v46, v22, v23, v24, v25, v26, v27);
              if ((IDStrings & 0x80000000) != 0) {
                goto LABEL_56;
              }
              uint64_t IDStrings = tokenizer_NNTN_ObjOpen((uint64_t *)v28, v47, v22, v23, v24, v25, v26, v27);
              if ((IDStrings & 0x80000000) != 0) {
                goto LABEL_56;
              }
              uint64_t IDStrings = textnormalizer_ObjOpen((uint64_t *)v28, v48, v22, v23, v24, v25, v26, v27);
              if ((IDStrings & 0x80000000) != 0) {
                goto LABEL_56;
              }
              uint64_t IDStrings = createIDStrings((unsigned char *)v28);
              if ((IDStrings & 0x80000000) != 0) {
                goto LABEL_56;
              }
              if (!*(_WORD *)(v28 + 336)) {
                goto LABEL_57;
              }
              unint64_t v49 = 0;
              do
              {
                log_OutText(*(void *)(*(void *)v28 + 32), *(void *)(v28 + 184), 5, 0, (uint64_t)"nntn : identifier=\"%s\"", v25, v26, v27, *(void *)(*(void *)(v28 + 344) + 8 * v49++));
                unint64_t v51 = *(unsigned __int16 *)(v28 + 336);
              }
              while (v49 < v51);
              if (!*(_WORD *)(v28 + 336))
              {
LABEL_57:
                log_OutPublic(*(void *)(*(void *)v28 + 32), (uint64_t)"FE_NNTN", 24024, 0, v24, v25, v26, v27, v66);
                uint64_t v5 = 2589990912;
                goto LABEL_48;
              }
              uint64_t IDStrings = FEData_blockData_loadDataFiles_NNTN(v28, v51, *(void *)(v28 + 344), v50, v24, v25, v26, v27);
              if ((IDStrings & 0x80000000) != 0 || (uint64_t IDStrings = getFECFGInfo(v28), (IDStrings & 0x80000000) != 0))
              {
LABEL_56:
                uint64_t v5 = IDStrings;
                goto LABEL_48;
              }
              uint64_t v52 = *(void *)v28;
              *(void *)(v28 + 848) = *(void *)v28;
              *(_DWORD *)(v28 + 876) = 0;
              if (!*(_DWORD *)(v28 + 840)) {
                goto LABEL_35;
              }
              uint64_t Object = nn_word_lkp_GetInterface(1u, &v68);
              if ((Object & 0x80000000) == 0)
              {
                *(void *)(v28 + 888) = v68;
                *(void *)(v28 + 896) = safeh_GetNullHandle();
                *(void *)(v28 + 904) = v53;
                *(void *)(v28 + 912) = safeh_GetNullHandle();
                *(void *)(v28 + 920) = v54;
                uint64_t Object = (*(uint64_t (**)(void, void, const char *, _WORD *, uint64_t, uint64_t))(v68 + 16))(*(void *)(v28 + 896), *(void *)(v28 + 904), "nntn", a3, a4, v28 + 912);
                if ((Object & 0x80000000) == 0)
                {
                  uint64_t inited = fi_model_getBrokerString_0(*(void *)v28, (char *)v77);
                  if ((inited & 0x80000000) == 0)
                  {
                    uint64_t v55 = fi_init(a3, a4, a1, a2, &v70, 0, (uint64_t)v77, (uint64_t)"FINN", 1, 0);
                    if ((v55 & 0x80000000) != 0)
                    {
                      uint64_t v5 = v55;
                      uint64_t v60 = *(void *)(*(void *)v28 + 32);
                      unint64_t v61 = "create FI model failed";
                      goto LABEL_61;
                    }
                    *(void *)(v28 + 856) = v70;
                    uint64_t v52 = *(void *)v28;
LABEL_35:
                    *(void *)(v28 + 936) = v52;
                    if (!*(_DWORD *)(v28 + 928))
                    {
LABEL_38:
                      *(void *)(v28 + 192) = heap_Alloc;
                      *(void *)(v28 + 200) = heap_Calloc;
                      *(void *)(v28 + 208) = heap_Realloc;
                      *(void *)(v28 + 216) = heap_Free;
                      int v57 = OOCAllocator_Con(v28 + 224, (_OWORD *)(v28 + 192), *(void *)(v52 + 8));
                      uint64_t v5 = LH_ERROR_to_VERROR(v57);
                      if ((v5 & 0x80000000) == 0)
                      {
                        *(void *)(v28 + 264) = 0;
                        uint64_t v20 = v67;
                        if (*(_DWORD *)(v28 + 840))
                        {
                          uint64_t v5 = load_lua_code(v28, &v71);
                          if ((v5 & 0x80000000) != 0) {
                            goto LABEL_48;
                          }
                        }
LABEL_55:
                        *(void *)a5 = v20;
                        *(_DWORD *)(a5 + 8) = 58764;
                        goto LABEL_49;
                      }
                      log_OutPublic(*(void *)(*(void *)v28 + 32), (uint64_t)"FE_NNTN", 24024, 0, v58, v25, v26, v27, v66);
                      goto LABEL_47;
                    }
                    uint64_t v56 = fe_nntn_tryLoading_NNTN_igModel(a3, a4, v52, &v69);
                    if ((v56 & 0x80000000) == 0)
                    {
                      *(void *)(v28 + 944) = v69;
                      uint64_t v52 = *(void *)v28;
                      goto LABEL_38;
                    }
                    uint64_t v5 = v56;
                    uint64_t v60 = *(void *)(*(void *)v28 + 32);
                    unint64_t v61 = "create Igtree model failed";
LABEL_61:
                    uint64_t v62 = 5;
                    goto LABEL_50;
                  }
                  return inited;
                }
              }
            }
            goto LABEL_46;
          }
          uint64_t v64 = 24023;
        }
        uint64_t v20 = v67;
        log_OutPublic(*(void *)(*(void *)v28 + 32), *(void *)(v28 + 184), v64, 0, v38, v39, v40, v41, v66);
        uint64_t v5 = 0;
        goto LABEL_55;
      }
LABEL_46:
      uint64_t v5 = Object;
      goto LABEL_47;
    }
  }
  return inited;
}

uint64_t NNTN_ObjClose(uint64_t *a1, int a2)
{
  if ((safeh_HandleCheck((uint64_t)a1, a2, 58764, 16) & 0x80000000) != 0
    || (safeh_HandleCheck(*a1, a1[1], 58765, 968) & 0x80000000) != 0)
  {
    return TOKENTNERROR(8);
  }
  else
  {
    uint64_t v9 = *a1;
    uint64_t v10 = *(void *)(*a1 + 888);
    if (v10)
    {
      (*(void (**)(void, void))(v10 + 24))(*(void *)(v9 + 912), *(void *)(v9 + 920));
      *(void *)(v9 + 888) = 0;
    }
    if (*(_DWORD *)(v9 + 840))
    {
      uint64_t v3 = *(uint64_t **)(v9 + 856);
      if (v3)
      {
        fi_deinit(*(void *)v9, *(void *)(v9 + 24), v3);
        *(void *)(v9 + 856) = 0;
      }
      if (*(_DWORD *)(v9 + 864) || *(_DWORD *)(v9 + 868)) {
        *(void *)(v9 + 864) = 0;
      }
    }
    if (*(_DWORD *)(v9 + 928))
    {
      uint64_t v11 = *(void *)(v9 + 944);
      if (v11)
      {
        igtree_Deinit(*(void *)v9, v11, (uint64_t)v3, v4, v5, v6, v7, v8);
        heap_Free(*(void **)(*(void *)v9 + 8), *(void *)(v9 + 944));
        *(void *)(v9 + 944) = 0;
      }
    }
    uint64_t v12 = *(void *)(v9 + 272);
    if (v12)
    {
      OOC_PlacementDeleteObject(v9 + 224, v12);
      *(void *)(v9 + 272) = 0;
    }
    kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(v9 + 224));
    uint64_t v13 = *(void *)(v9 + 184);
    log_OutText(*(void *)(*(void *)v9 + 32), v13, 4, 0, (uint64_t)"nntn : ObjClose Begin", v14, v15, v16, v36);
    uint64_t v17 = *(void *)v9;
    uint64_t v25 = FEData_blockData_unloadDataFiles((void *)v9, v18, v19, v20, v21, v22, v23, v24);
    NNTN_loc_ObjClose(v17, a1, v26, v27, v28, v29, v30, v31);
    log_OutText(*(void *)(v17 + 32), v13, 4, 0, (uint64_t)"nntn : ObjClose End (%x)", v32, v33, v34, v25);
    return v25;
  }
}

uint64_t NNTN_ObjReopen(uint64_t *a1, int a2)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  memset(v39, 0, sizeof(v39));
  int v35 = 0;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 58764, 16) & 0x80000000) == 0)
  {
    uint64_t v38 = 0;
    if ((safeh_HandleCheck(*a1, a1[1], 58765, 968) & 0x80000000) == 0)
    {
      uint64_t v3 = *a1;
      uint64_t v4 = *(void *)(v3 + 344);
      if (v4)
      {
        if (*(_WORD *)(v3 + 336))
        {
          unint64_t v5 = 0;
          do
          {
            heap_Free(*(void **)(*(void *)v3 + 8), *(void *)(*(void *)(v3 + 344) + 8 * v5));
            *(void *)(*(void *)(v3 + 344) + 8 * v5++) = 0;
          }
          while (v5 < *(unsigned __int16 *)(v3 + 336));
          uint64_t v4 = *(void *)(v3 + 344);
        }
        heap_Free(*(void **)(*(void *)v3 + 8), v4);
        *(void *)(v3 + 344) = 0;
        *(_WORD *)(v3 + 336) = 0;
        *(unsigned char *)(v3 + 352) = 0;
        *(_WORD *)(v3 + 608) = 257;
      }
      uint64_t IDStrings = addIdentifier2List(v3, "x");
      if ((IDStrings & 0x80000000) == 0)
      {
        uint64_t IDStrings = createIDStrings((unsigned char *)v3);
        if ((IDStrings & 0x80000000) == 0)
        {
          if (!*(void *)(v3 + 344)) {
            return 6;
          }
          if (*(_WORD *)(v3 + 336))
          {
            unint64_t v13 = 0;
            do
              log_OutText(*(void *)(*(void *)v3 + 32), *(void *)(v3 + 184), 5, 0, (uint64_t)"nntn : identifier=\"%s\"", v10, v11, v12, *(void *)(*(void *)(v3 + 344) + 8 * v13++));
            while (v13 < *(unsigned __int16 *)(v3 + 336));
          }
          uint64_t v14 = *(void *)(v3 + 888);
          if (v14)
          {
            uint64_t v38 = *(void *)(v3 + 888);
            (*(void (**)(void, void))(v14 + 24))(*(void *)(v3 + 912), *(void *)(v3 + 920));
            *(void *)(v3 + 888) = 0;
          }
          if (*(_DWORD *)(v3 + 840))
          {
            uint64_t v7 = *(uint64_t **)(v3 + 856);
            if (v7)
            {
              fi_deinit(*(void *)v3, *(void *)(v3 + 24), v7);
              *(void *)(v3 + 856) = 0;
            }
            if (*(_DWORD *)(v3 + 864) || *(_DWORD *)(v3 + 868)) {
              *(void *)(v3 + 864) = 0;
            }
          }
          if (*(_DWORD *)(v3 + 928))
          {
            uint64_t v15 = *(void *)(v3 + 944);
            if (v15)
            {
              igtree_Deinit(*(void *)v3, v15, (uint64_t)v7, v8, v9, v10, v11, v12);
              heap_Free(*(void **)(*(void *)v3 + 8), *(void *)(v3 + 944));
              *(void *)(v3 + 944) = 0;
            }
            if (*(void *)(v3 + 936)) {
              *(void *)(v3 + 936) = 0;
            }
          }
          uint64_t v16 = *(void *)(v3 + 288);
          if (v16)
          {
            heap_Free(*(void **)(*(void *)v3 + 8), v16);
            *(void *)(v3 + 288) = 0;
          }
          uint64_t IDStrings = FEData_blockData_unloadUnusedDataFiles((void *)v3, *(unsigned __int16 *)(v3 + 336), *(void *)(v3 + 344), v8, v9, v10, v11, v12);
          if ((IDStrings & 0x80000000) == 0)
          {
            uint64_t IDStrings = getFECFGInfo(v3);
            if ((IDStrings & 0x80000000) == 0)
            {
              if (!*(_WORD *)(v3 + 336))
              {
                log_OutPublic(*(void *)(*(void *)v3 + 32), (uint64_t)"FE_NNTN", 24024, 0, v18, v19, v20, v21, v34);
                return 2589990912;
              }
              uint64_t DataFiles_NNTN = FEData_blockData_loadDataFiles_NNTN(v3, *(unsigned __int16 *)(v3 + 336), *(void *)(v3 + 344), v17, v18, v19, v20, v21);
              if ((DataFiles_NNTN & 0x80000000) != 0) {
                goto LABEL_50;
              }
              uint64_t v23 = *(void *)v3;
              *(void *)(v3 + 848) = *(void *)v3;
              if (!*(_DWORD *)(v3 + 840)) {
                goto LABEL_40;
              }
              uint64_t IDStrings = nn_word_lkp_GetInterface(1u, &v38);
              if ((IDStrings & 0x80000000) == 0)
              {
                *(void *)(v3 + 888) = v38;
                *(void *)(v3 + 896) = safeh_GetNullHandle();
                *(void *)(v3 + 904) = v24;
                *(void *)(v3 + 912) = safeh_GetNullHandle();
                *(void *)(v3 + 920) = v25;
                uint64_t IDStrings = (*(uint64_t (**)(void, void, const char *, void, void, uint64_t))(v38 + 16))(*(void *)(v3 + 896), *(void *)(v3 + 904), "nntn", *(void *)(v3 + 8), *(void *)(v3 + 16), v3 + 912);
                if ((IDStrings & 0x80000000) == 0)
                {
                  uint64_t BrokerString_0 = fi_model_getBrokerString_0(*(void *)v3, (char *)v39);
                  if ((BrokerString_0 & 0x80000000) != 0) {
                    return BrokerString_0;
                  }
                  uint64_t DataFiles_NNTN = fi_init(*(_WORD **)(v3 + 8), *(void *)(v3 + 16), *(_WORD **)(v3 + 32), *(void *)(v3 + 40), &v37, 0, (uint64_t)v39, (uint64_t)"FINN", 1, 0);
                  if ((DataFiles_NNTN & 0x80000000) != 0)
                  {
                    uint64_t v32 = *(void *)(*(void *)v3 + 32);
                    uint64_t v33 = "create FI model failed";
                    goto LABEL_59;
                  }
                  *(void *)(v3 + 856) = v37;
                  uint64_t v23 = *(void *)v3;
LABEL_40:
                  *(void *)(v3 + 936) = v23;
                  if (!*(_DWORD *)(v3 + 928))
                  {
LABEL_43:
                    if (*(_DWORD *)(v3 + 840))
                    {
                      uint64_t DataFiles_NNTN = load_lua_code(v3, &v35);
                      if ((DataFiles_NNTN & 0x80000000) != 0)
                      {
LABEL_50:
                        uint64_t v31 = *(void *)(v3 + 272);
                        if (v31)
                        {
                          OOC_PlacementDeleteObject(v3 + 224, v31);
                          *(void *)(v3 + 272) = 0;
                        }
                        kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(v3 + 224));
                      }
                    }
                    return DataFiles_NNTN;
                  }
                  uint64_t DataFiles_NNTN = fe_nntn_tryLoading_NNTN_igModel(*(_WORD **)(v3 + 8), *(void *)(v3 + 16), v23, &v36);
                  if ((DataFiles_NNTN & 0x80000000) == 0)
                  {
                    *(void *)(v3 + 944) = v36;
                    goto LABEL_43;
                  }
                  uint64_t v32 = *(void *)(*(void *)v3 + 32);
                  uint64_t v33 = "create Igtree model failed";
LABEL_59:
                  log_OutText(v32, (uint64_t)"FE_NNTN", 5, 0, (uint64_t)v33, v27, v28, v29, v34);
                  return DataFiles_NNTN;
                }
              }
            }
          }
        }
      }
      uint64_t DataFiles_NNTN = IDStrings;
      goto LABEL_50;
    }
  }
  return TOKENTNERROR(8);
}

uint64_t NNTN_ProcessStart(uint64_t *a1, int a2)
{
  if ((safeh_HandleCheck((uint64_t)a1, a2, 58764, 16) & 0x80000000) != 0
    || (safeh_HandleCheck(*a1, a1[1], 58765, 968) & 0x80000000) != 0)
  {
    return TOKENTNERROR(8);
  }
  else
  {
    uint64_t v6 = *a1;
    log_OutText(*(void *)(*(void *)*a1 + 32), *(void *)(*a1 + 184), 4, 0, (uint64_t)"nntn : ProcessStart Begin", v3, v4, v5, v17);
    if (*(_WORD *)(v6 + 336))
    {
      uint64_t v15 = nuance_pcre_Init(*(void **)(v6 + 136), *(void *)(v6 + 144), *(unsigned __int16 *)(v6 + 282), *(_WORD *)(v6 + 284));
      if ((v15 & 0x80000000) != 0) {
        log_OutPublic(*(void *)(*(void *)v6 + 32), *(void *)(v6 + 184), 24051, 0, v11, v12, v13, v14, v18);
      }
      log_OutText(*(void *)(*(void *)v6 + 32), *(void *)(v6 + 184), 4, 0, (uint64_t)"nntn : ProcessStart End (%x)", v12, v13, v14, v15);
    }
    else
    {
      log_OutPublic(*(void *)(*(void *)v6 + 32), (uint64_t)"FE_NNTN", 24024, 0, v7, v8, v9, v10, v18);
      return 2589990912;
    }
    return v15;
  }
}

uint64_t NNTN_Process(uint64_t *a1, int a2, void *a3, int a4, _DWORD *a5)
{
  int v55 = 0;
  uint64_t v54 = 0;
  int v53 = 0;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 58764, 16) & 0x80000000) == 0
    && (safeh_HandleCheck(*a1, a1[1], 58765, 968) & 0x80000000) == 0)
  {
    uint64_t v12 = (void **)*a1;
    log_OutText((*v12)[4], (uint64_t)v12[23], 4, 0, (uint64_t)"NNTN : Process Begin", v9, v10, v11, v51);
    v12[9] = a3;
    *((_DWORD *)v12 + 20) = a4;
    *((_DWORD *)v12 + 219) = 0;
    *((_DWORD *)v12 + 137) = log_GetLogLevel((*v12)[4]) > 4;
    v12[33] = 0;
    uint64_t v13 = LingDBHasSentence((uint64_t)v12[8], (uint64_t)v12[9], (uint64_t)v12[10], &v55);
    if ((v13 & 0x80000000) != 0) {
      return v13;
    }
    uint64_t v14 = (uint64_t *)(v12 + 33);
    if (!v55) {
      goto LABEL_48;
    }
    uint64_t inited = initLDO((uint64_t)(v12 + 28), v12 + 33);
    if ((inited & 0x80000000) != 0) {
      goto LABEL_53;
    }
    uint64_t inited = importFromLingDB((uint64_t)*v12, (uint64_t)v12[8], (uint64_t)v12[9], (uint64_t)v12[10], (uint64_t *)v12 + 33);
    if ((inited & 0x80000000) != 0) {
      goto LABEL_53;
    }
    uint64_t v13 = 2589990922;
    int v16 = LDO_ComputeText(*v14, &v54);
    if ((LH_ERROR_to_VERROR(v16) & 0x80000000) != 0) {
      goto LABEL_54;
    }
    v12[38] = (void *)fst::FstImpl<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::Properties(v54);
    *((_WORD *)v12 + 156) = LHString_Length(v54);
    log_OutText((*v12)[4], (uint64_t)v12[23], 5, 0, (uint64_t)"<LOGFE> processing sentence : _%s_", v17, v18, v19, (uint64_t)v12[38]);
    uint64_t v20 = heap_Calloc((void *)(*v12)[1], 1, *((unsigned __int16 *)v12 + 156) + 1);
    v12[69] = (void *)v20;
    if (!v20) {
      goto LABEL_54;
    }
    *((_WORD *)v12 + 157) = 1;
    if (*((_WORD *)v12 + 156))
    {
      int v21 = 0;
      while (utf8_strchr(g_szSpace, (unsigned __int8 *)v12[38] + (unsigned __int16)v21))
      {
        v21 += utf8_determineUTF8CharLength(*((unsigned __int8 *)v12[38] + (unsigned __int16)v21));
        unsigned int v22 = *((unsigned __int16 *)v12 + 156);
        if (v22 <= (unsigned __int16)v21) {
          goto LABEL_18;
        }
      }
      unsigned int v22 = *((unsigned __int16 *)v12 + 156);
LABEL_18:
      if (v22 > (unsigned __int16)v21)
      {
        do
        {
          int v21 = (unsigned __int16)v21;
          if (utf8_strchr(g_szSpace, (unsigned __int8 *)v12[38] + (unsigned __int16)v21))
          {
            ++*((_WORD *)v12 + 157);
            for (unsigned int i = *((unsigned __int8 *)v12[38] + (unsigned __int16)v21);
                  ;
                  unsigned int i = *((unsigned __int8 *)v12[38] + (unsigned __int16)v21))
            {
              v21 += utf8_determineUTF8CharLength(i);
              if (*((unsigned __int16 *)v12 + 156) <= (unsigned __int16)v21
                || !utf8_strchr(g_szSpace, (unsigned __int8 *)v12[38] + (unsigned __int16)v21))
              {
                break;
              }
            }
          }
          else
          {
            LOWORD(v21) = v21 + utf8_determineUTF8CharLength(*((unsigned __int8 *)v12[38] + (unsigned __int16)v21));
          }
        }
        while (*((unsigned __int16 *)v12 + 156) > (unsigned __int16)v21);
      }
    }
    uint64_t inited = initStrRes((uint64_t)v12, (uint64_t)(v12 + 49));
    if ((inited & 0x80000000) != 0) {
      goto LABEL_53;
    }
    uint64_t inited = initStrRes((uint64_t)v12, (uint64_t)(v12 + 51));
    if ((inited & 0x80000000) != 0) {
      goto LABEL_53;
    }
    uint64_t inited = initStrRes((uint64_t)v12, (uint64_t)(v12 + 61));
    if ((inited & 0x80000000) != 0) {
      goto LABEL_53;
    }
    uint64_t inited = initStrRes((uint64_t)v12, (uint64_t)(v12 + 70));
    if ((inited & 0x80000000) != 0) {
      goto LABEL_53;
    }
    uint64_t inited = initStrRes((uint64_t)v12, (uint64_t)(v12 + 72));
    if ((inited & 0x80000000) != 0) {
      goto LABEL_53;
    }
    uint64_t inited = initStrRes((uint64_t)v12, (uint64_t)(v12 + 74));
    if ((inited & 0x80000000) != 0) {
      goto LABEL_53;
    }
    uint64_t inited = initStrRes((uint64_t)v12, (uint64_t)(v12 + 63));
    if ((inited & 0x80000000) != 0) {
      goto LABEL_53;
    }
    uint64_t inited = initAlignmentData((uint64_t)v12);
    if ((inited & 0x80000000) != 0) {
      goto LABEL_53;
    }
    uint64_t inited = initMatchList((uint64_t)v12);
    if ((inited & 0x80000000) != 0) {
      goto LABEL_53;
    }
    uint64_t inited = initSolutionList((uint64_t)v12);
    if ((inited & 0x80000000) != 0) {
      goto LABEL_53;
    }
    uint64_t v25 = heap_Calloc((void *)(*v12)[1], 1, 40);
    v12[40] = (void *)v25;
    uint64_t v30 = (uint64_t)*v12;
    if (v25)
    {
      uint64_t v31 = heap_Calloc(*(void **)(v30 + 8), 1, 48);
      v12[41] = (void *)v31;
      if (v31)
      {
        if (*((_DWORD *)v12 + 238) == 1)
        {
          uint64_t inited = updateLDOTreeNode_CHN((uint64_t *)v12, &v53);
          if ((inited & 0x80000000) != 0) {
            goto LABEL_53;
          }
          if (!v53)
          {
            *a5 = 1;
            goto LABEL_53;
          }
        }
        uint64_t inited = nntn_AllInOneLoop((uint64_t)v12, v32, v33, v34, v26, v27, v28, v29);
        if ((inited & 0x80000000) == 0)
        {
          uint64_t v38 = (uint64_t)v12[34];
          if (!v38)
          {
            log_OutText((*v12)[4], (uint64_t)v12[23], 0, 0, (uint64_t)"NNTN : error - pLuaVMLDO is NULL", v35, v36, v37, v52);
            uint64_t v13 = 2589990918;
            goto LABEL_54;
          }
          int v39 = LuaVMLDO_RunFunction(v38, (uint64_t)"run", *v14);
          uint64_t inited = LH_ERROR_to_VERROR(v39);
          if ((inited & 0x80000000) == 0)
          {
            if (*((_DWORD *)v12 + 137) != 1
              || (uint64_t inited = dumpTokenRecordsInLingDB(v12, (uint64_t)"At End of Processing", 1, v40, v41, v42, v43, v44),
                  (inited & 0x80000000) == 0))
            {
              uint64_t inited = exportToLingDB((uint64_t)*v12, (uint64_t)v12[8], (uint64_t)v12[9], (uint64_t)v12[10], (uint64_t)(v12 + 28), (uint64_t)v12[33], 1, 1);
              if ((inited & 0x80000000) == 0)
              {
                uint64_t v13 = replaceBasicTokensWithTokenIntTnInLingDB((uint64_t)*v12, (uint64_t)v12[8], (uint64_t)v12[9], (uint64_t)v12[10], (uint64_t)v12[33], (uint64_t)v12[23]);
                if ((v13 & 0x80000000) != 0)
                {
LABEL_54:
                  if (v54)
                  {
                    OOC_PlacementDeleteObject((uint64_t)(v12 + 28), v54);
                    uint64_t v54 = 0;
                  }
                  if (*v14)
                  {
                    deinitLDO((uint64_t)(v12 + 28), *v14);
                    v12[33] = 0;
                  }
                  uint64_t v45 = (uint64_t)v12[69];
                  if (v45)
                  {
                    heap_Free((void *)(*v12)[1], v45);
                    v12[69] = 0;
                  }
                  clearStrRes(*v12, (uint64_t)(v12 + 49));
                  clearStrRes(*v12, (uint64_t)(v12 + 51));
                  clearStrRes(*v12, (uint64_t)(v12 + 61));
                  clearStrRes(*v12, (uint64_t)(v12 + 70));
                  clearStrRes(*v12, (uint64_t)(v12 + 72));
                  clearStrRes(*v12, (uint64_t)(v12 + 74));
                  clearStrRes(*v12, (uint64_t)(v12 + 63));
                  freeAlignmentData(v12);
                  freeMatchList(v12);
                  freeSolutionList(v12);
                  uint64_t v49 = (uint64_t)v12[40];
                  if (v49)
                  {
                    heap_Free((void *)(*v12)[1], v49);
                    v12[40] = 0;
                  }
                  uint64_t v50 = (uint64_t)v12[41];
                  if (v50)
                  {
                    heap_Free((void *)(*v12)[1], v50);
                    v12[41] = 0;
                  }
                  log_OutText((*v12)[4], (uint64_t)v12[23], 4, 0, (uint64_t)"nntn : Process End (%x)", v46, v47, v48, v13);
                  return v13;
                }
LABEL_48:
                *a5 = 1;
                goto LABEL_54;
              }
            }
          }
        }
LABEL_53:
        uint64_t v13 = inited;
        goto LABEL_54;
      }
      uint64_t v30 = (uint64_t)*v12;
    }
    log_OutPublic(*(void *)(v30 + 32), (uint64_t)v12[23], 24048, 0, v26, v27, v28, v29, v52);
    goto LABEL_54;
  }
  return TOKENTNERROR(8);
}

uint64_t NNTN_ProcessEnd(uint64_t *a1, int a2)
{
  if ((safeh_HandleCheck((uint64_t)a1, a2, 58764, 16) & 0x80000000) != 0
    || (safeh_HandleCheck(*a1, a1[1], 58765, 968) & 0x80000000) != 0)
  {
    return TOKENTNERROR(8);
  }
  else
  {
    uint64_t v6 = *a1;
    log_OutText(*(void *)(*(void *)v6 + 32), *(void *)(v6 + 184), 4, 0, (uint64_t)"nntn : ProcessEnd Begin", v3, v4, v5, v12);
    uint64_t v7 = nuance_pcre_DeInit(*(void **)(v6 + 136), *(void *)(v6 + 144));
    log_OutText(*(void *)(*(void *)v6 + 32), *(void *)(v6 + 184), 4, 0, (uint64_t)"nntn : ProcessEnd End (%x)", v8, v9, v10, v7);
    return 0;
  }
}

uint64_t addIdentifier2List(uint64_t a1, char *__s2)
{
  uint64_t v4 = *(unsigned __int16 *)(a1 + 336);
  if (*(_WORD *)(a1 + 336))
  {
    uint64_t v5 = *(const char ***)(a1 + 344);
    uint64_t v6 = *(unsigned __int16 *)(a1 + 336);
    uint64_t v7 = v5;
    do
    {
      if (v5 && !strcmp(*v7, __s2)) {
        return 0;
      }
      ++v7;
      --v6;
    }
    while (v6);
    uint64_t v8 = heap_Realloc(*(uint64_t **)(*(void *)a1 + 8), *(void *)(a1 + 344), 8 * v4 + 8);
    if (v8) {
      goto LABEL_9;
    }
    goto LABEL_11;
  }
  uint64_t v8 = heap_Calloc(*(void **)(*(void *)a1 + 8), 1, 8);
  if (!v8)
  {
LABEL_11:
    uint64_t v17 = 2589990922;
    log_OutPublic(*(void *)(*(void *)a1 + 32), *(void *)(a1 + 184), 24048, 0, v9, v10, v11, v12, v19);
    return v17;
  }
LABEL_9:
  *(void *)(a1 + 344) = v8;
  int v13 = strlen(__s2);
  uint64_t v14 = heap_Calloc(*(void **)(*(void *)a1 + 8), 1, (v13 + 1));
  uint64_t v15 = *(unsigned __int16 *)(a1 + 336);
  *(void *)(*(void *)(a1 + 344) + 8 * v15) = v14;
  int v16 = *(char **)(*(void *)(a1 + 344) + 8 * v15);
  if (!v16) {
    goto LABEL_11;
  }
  strcpy(v16, __s2);
  uint64_t v17 = 0;
  ++*(_WORD *)(a1 + 336);
  return v17;
}

uint64_t createIDStrings(unsigned char *a1)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  long long __s = 0;
  *(_OWORD *)__s2 = 0u;
  long long v20 = 0u;
  *(_OWORD *)uint64_t v17 = 0u;
  long long v18 = 0u;
  *(_OWORD *)uint64_t v15 = 0u;
  long long v16 = 0u;
  uint64_t result = paramc_ParamGet(*(void *)(*(void *)a1 + 40), (uint64_t)"langcode", &__s, 0);
  if ((result & 0x80000000) == 0)
  {
    uint64_t v3 = __s;
    if (*__s)
    {
      uint64_t v4 = 0;
      int v5 = 0;
      do
      {
        char v6 = v3[v4];
        v17[v4] = v6;
        __s2[v4] = v6;
        uint64_t v4 = (unsigned __int16)++v5;
      }
      while (strlen(v3) > (unsigned __int16)v5);
    }
    strcpy(&__s2[2], "x");
    v17[3] = 0;
    if (*(_DWORD *)v17 == 6840675) {
      __s2[1] = 110;
    }
    uint64_t result = paramc_ParamGet(*(void *)(*(void *)a1 + 40), (uint64_t)"voice", &__s, 0);
    if ((result & 0x80000000) == 0)
    {
      uint64_t v7 = __s;
      size_t v8 = strlen(__s);
      if (v8 <= 0x1A)
      {
        if (v8)
        {
          uint64_t v9 = 0;
          int v10 = 0;
          do
          {
            v15[v9] = v7[v9];
            uint64_t v9 = (unsigned __int16)++v10;
            size_t v8 = strlen(v7);
          }
          while (v8 > (unsigned __int16)v10);
        }
        v15[v8] = 0;
        if ((int)strlen(__s2) >= 1)
        {
          int v11 = 0;
          do
          {
            __s2[(unsigned __int16)v11] = ssft_tolower(__s2[(unsigned __int16)v11]);
            ++v11;
          }
          while ((int)strlen(__s2) > (unsigned __int16)v11);
        }
        if ((int)strlen(v17) >= 1)
        {
          int v12 = 0;
          do
          {
            v17[(unsigned __int16)v12] = ssft_tolower(v17[(unsigned __int16)v12]);
            ++v12;
          }
          while ((int)strlen(v17) > (unsigned __int16)v12);
        }
        if ((int)strlen(v15) >= 1)
        {
          int v13 = 0;
          do
          {
            v15[(unsigned __int16)v13] = ssft_tolower(v15[(unsigned __int16)v13]);
            ++v13;
          }
          while ((int)strlen(v15) > (unsigned __int16)v13);
        }
        uint64_t result = addIdentifier2List((uint64_t)a1, __s2);
        if ((result & 0x80000000) == 0)
        {
          a1[352] = a1[336];
          uint64_t result = addIdentifier2List((uint64_t)a1, v17);
          if ((result & 0x80000000) == 0) {
            return addIdentifier2List((uint64_t)a1, v15);
          }
        }
      }
      else
      {
        return 2589990912;
      }
    }
  }
  return result;
}

uint64_t getFECFGInfo(uint64_t a1)
{
  uint64_t v2 = 2589991940;
  unsigned __int16 v37 = -1;
  __int16 __c_1 = 0;
  unsigned __int8 __c = 0;
  if (((*(uint64_t (**)(void, void, const char *, const char *, char ***, unsigned __int16 *, unsigned __int8 *))(*(void *)(a1 + 88) + 96))(*(void *)(a1 + 96), *(void *)(a1 + 104), "fecfg", "nrpart_g2p", &__c_1, &v37, &__c) & 0x80000000) != 0)return 2589990912; {
  if (v37 == 1 && __c_1 != 0)
  }
  {
    uint64_t v4 = *__c_1;
    int v5 = strchr(*__c_1, __c);
    if (v5)
    {
      *int v5 = 0;
      uint64_t v4 = *__c_1;
    }
    *(unsigned char *)(a1 + 608) = atoi(v4);
  }
  unsigned __int16 v37 = -1;
  if (((*(uint64_t (**)(void, void, const char *, const char *, char ***, unsigned __int16 *, unsigned __int8 *))(*(void *)(a1 + 88) + 96))(*(void *)(a1 + 96), *(void *)(a1 + 104), "fecfg", "nrpart_tn", &__c_1, &v37, &__c) & 0x80000000) != 0)return 2589990912; {
  if (v37 == 1 && __c_1)
  }
  {
    char v6 = *__c_1;
    uint64_t v7 = strchr(*__c_1, __c);
    if (v7)
    {
      *uint64_t v7 = 0;
      char v6 = *__c_1;
    }
    *(unsigned char *)(a1 + 609) = atoi(v6);
  }
  unsigned __int16 v37 = -1;
  if (((*(uint64_t (**)(void, void, const char *, const char *, char ***, unsigned __int16 *, unsigned __int8 *))(*(void *)(a1 + 88) + 96))(*(void *)(a1 + 96), *(void *)(a1 + 104), "fecfg", "nntn_nn_step", &__c_1, &v37, &__c) & 0x80000000) == 0)
  {
    int v8 = v37;
    if (v37)
    {
      *(_DWORD *)(a1 + 864) = 0;
      if (v8 == 1 && __c_1)
      {
        uint64_t v9 = *__c_1;
        int v10 = strchr(*__c_1, __c);
        if (v10)
        {
          *int v10 = 0;
          uint64_t v9 = *__c_1;
        }
        *(_DWORD *)(a1 + 864) = (unsigned __int16)LH_atou(v9);
      }
      unsigned __int16 v37 = -1;
      if (((*(uint64_t (**)(void, void, const char *, const char *, char ***, unsigned __int16 *, unsigned __int8 *))(*(void *)(a1 + 88) + 96))(*(void *)(a1 + 96), *(void *)(a1 + 104), "fecfg", "nntn_nn_vect", &__c_1, &v37, &__c) & 0x80000000) == 0)
      {
        int v11 = v37;
        if (v37)
        {
          *(_DWORD *)(a1 + 868) = 0;
          if (v11 == 1 && __c_1)
          {
            int v12 = *__c_1;
            int v13 = strchr(*__c_1, __c);
            if (v13)
            {
              char *v13 = 0;
              int v12 = *__c_1;
            }
            *(_DWORD *)(a1 + 868) = (unsigned __int16)LH_atou(v12);
          }
          unsigned __int16 v37 = -1;
          if (((*(uint64_t (**)(void, void, const char *, const char *, char ***, unsigned __int16 *, unsigned __int8 *))(*(void *)(a1 + 88) + 96))(*(void *)(a1 + 96), *(void *)(a1 + 104), "fecfg", "nntn_nn_max", &__c_1, &v37, &__c) & 0x80000000) == 0)
          {
            int v14 = v37;
            if (v37)
            {
              *(_DWORD *)(a1 + 872) = 0;
              if (v14 == 1 && __c_1)
              {
                uint64_t v15 = *__c_1;
                long long v16 = strchr(*__c_1, __c);
                if (v16)
                {
                  *long long v16 = 0;
                  uint64_t v15 = *__c_1;
                }
                *(_DWORD *)(a1 + 872) = (unsigned __int16)LH_atou(v15);
              }
              *(_DWORD *)(a1 + 880) = 0;
              unsigned __int16 v37 = -1;
              if (((*(uint64_t (**)(void, void, const char *, const char *, char ***, unsigned __int16 *, unsigned __int8 *))(*(void *)(a1 + 88) + 96))(*(void *)(a1 + 96), *(void *)(a1 + 104), "fecfg", "nntn_window_option", &__c_1, &v37, &__c) & 0x80000000) != 0|| (int v20 = v37) == 0)
              {
                log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_NNTN", 5, 0, (uint64_t)"Load nntn_window_option from CFG failed, use default 0.", v17, v18, v19, v34);
                int v20 = v37;
              }
              if (v20 == 1 && __c_1)
              {
                uint64_t v21 = *__c_1;
                unsigned int v22 = strchr(*__c_1, __c);
                if (v22)
                {
                  *unsigned int v22 = 0;
                  uint64_t v21 = *__c_1;
                }
                *(_DWORD *)(a1 + 880) = (unsigned __int16)LH_atou(v21);
              }
              unsigned __int16 v37 = -1;
              if (((*(uint64_t (**)(void, void, const char *, const char *, char ***, unsigned __int16 *, unsigned __int8 *))(*(void *)(a1 + 88) + 96))(*(void *)(a1 + 96), *(void *)(a1 + 104), "fecfg", "nntn_use_NNTN", &__c_1, &v37, &__c) & 0x80000000) == 0&& v37)
              {
                if (v37 == 1 && __c_1)
                {
                  uint64_t v23 = *__c_1;
                  uint64_t v24 = strchr(*__c_1, __c);
                  if (v24)
                  {
                    *uint64_t v24 = 0;
                    uint64_t v23 = *__c_1;
                  }
                  if (!strcmp(v23, "yes")) {
                    *(_DWORD *)(a1 + 840) = 1;
                  }
                }
                unsigned __int16 v37 = -1;
                if (((*(uint64_t (**)(void, void, const char *, const char *, char ***, unsigned __int16 *, unsigned __int8 *))(*(void *)(a1 + 88) + 96))(*(void *)(a1 + 96), *(void *)(a1 + 104), "fecfg", "nntn_use_NNTN_IGTree", &__c_1, &v37, &__c) & 0x80000000) == 0&& v37)
                {
                  if (v37 == 1 && __c_1)
                  {
                    uint64_t v25 = *__c_1;
                    uint64_t v26 = strchr(*__c_1, __c);
                    if (v26)
                    {
                      *uint64_t v26 = 0;
                      uint64_t v25 = *__c_1;
                    }
                    if (!strcmp(v25, "yes")) {
                      *(_DWORD *)(a1 + 928) = 1;
                    }
                  }
                  unsigned __int16 v37 = -1;
                  if (((*(uint64_t (**)(void, void, const char *, const char *, char ***, unsigned __int16 *, unsigned __int8 *))(*(void *)(a1 + 88) + 96))(*(void *)(a1 + 96), *(void *)(a1 + 104), "fecfg", "nntn_one_char_per_node", &__c_1, &v37, &__c) & 0x80000000) == 0&& v37)
                  {
                    if (v37 == 1 && __c_1)
                    {
                      uint64_t v27 = *__c_1;
                      uint64_t v28 = strchr(*__c_1, __c);
                      if (v28)
                      {
                        *uint64_t v28 = 0;
                        uint64_t v27 = *__c_1;
                      }
                      if (!strcmp(v27, "yes")) {
                        *(_DWORD *)(a1 + 952) = 1;
                      }
                    }
                    unsigned __int16 v37 = -1;
                    uint64_t v29 = (*(uint64_t (**)(void, void, const char *, const char *, char ***, unsigned __int16 *, unsigned __int8 *))(*(void *)(a1 + 88) + 96))(*(void *)(a1 + 96), *(void *)(a1 + 104), "fecfg", "nntn_feat_focus", &__c_1, &v37, &__c);
                    if ((v29 & 0x80000000) == 0 && v37)
                    {
                      uint64_t v30 = v29;
                      if (v37 == 1 && __c_1)
                      {
                        uint64_t v31 = *__c_1;
                        uint64_t v32 = strchr(*__c_1, __c);
                        if (v32)
                        {
                          *uint64_t v32 = 0;
                          uint64_t v31 = *__c_1;
                        }
                        if (!strcmp(v31, "yes")) {
                          *(_DWORD *)(a1 + 956) = 1;
                        }
                      }
                      return v30;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return v2;
}

uint64_t fi_model_getBrokerString_0(uint64_t a1, char *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v5 = 0;
  *(void *)char v6 = 0;
  memset(v7, 0, sizeof(v7));
  uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"langcode", v6);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"fecfg", &v5);
    if ((result & 0x80000000) == 0)
    {
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      return brokeraux_ComposeBrokerString(a1, (const char *)v7, 1, 1, *(char **)v6, 0, 0, a2, 0x100uLL);
    }
  }
  return result;
}

uint64_t load_lua_code(uint64_t a1, _DWORD *a2)
{
  *a2 = 0;
  uint64_t v4 = *(void *)(a1 + 272);
  if (v4)
  {
    OOC_PlacementDeleteObject(a1 + 224, v4);
    *(void *)(a1 + 272) = 0;
  }
  uint64_t v5 = (uint64_t *)(a1 + 272);
  kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(a1 + 224));
  int IsLuaCodeAvailable = LuaVMLDO_IsLuaCodeAvailable(*(_WORD **)(a1 + 8), *(void *)(a1 + 16), 0, a2);
  uint64_t v7 = LH_ERROR_to_VERROR(IsLuaCodeAvailable);
  if ((v7 & 0x80000000) == 0)
  {
    if (*a2 != 1) {
      return v7;
    }
    *a2 = 0;
    int v8 = OOCAllocator_Con(a1 + 224, (_OWORD *)(a1 + 192), *(void *)(*(void *)a1 + 8));
    uint64_t v9 = LH_ERROR_to_VERROR(v8);
    if ((v9 & 0x80000000) != 0
      || (v10 = PNEW_LuaVMLDO_Con(a1 + 224, a1 + 224, *(void *)(a1 + 8), *(void *)(a1 + 16), (uint64_t)hlp_lua_log_callback_1, (uint64_t **)(a1 + 272)), uint64_t v9 = LH_ERROR_to_VERROR(v10), (v9 & 0x80000000) != 0))
    {
      uint64_t v7 = v9;
    }
    else
    {
      int ScriptFromRIFF = LuaVMLDO_LoadScriptFromRIFF(*v5, 0);
      uint64_t v7 = LH_ERROR_to_VERROR(ScriptFromRIFF);
      if ((v7 & 0x80000000) == 0)
      {
        *a2 = 1;
        return v7;
      }
    }
  }
  if (*v5)
  {
    OOC_PlacementDeleteObject(a1 + 224, *v5);
    *uint64_t v5 = 0;
  }
  kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(a1 + 224));
  return v7;
}

uint64_t NNTN_loc_ObjClose(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    uint64_t v9 = result;
    log_OutText(*(void *)(result + 32), (uint64_t)"FE_NNTN", 4, 0, (uint64_t)"nntn : loc ObjClose Begin", a6, a7, a8, v72);
    uint64_t NullHandle = safeh_GetNullHandle();
    uint64_t v12 = 0;
    if (!safeh_HandlesEqual(*a2, a2[1], NullHandle, v11))
    {
      uint64_t result = safeh_HandleCheck(*a2, a2[1], 58765, 968);
      if ((result & 0x80000000) != 0) {
        return result;
      }
      LODWORD(v12) = result;
      uint64_t v20 = *a2;
      int v21 = tokenizer_NNTN_ObjClose((uint64_t *)*a2, v13, v14, v15, v16, v17, v18, v19);
      if (v21 < 0) {
        LODWORD(v12) = v21;
      }
      int v29 = textnormalizer_ObjClose((uint64_t *)v20, v22, v23, v24, v25, v26, v27, v28);
      if (v29 < 0) {
        LODWORD(v12) = v29;
      }
      uint64_t v30 = safeh_GetNullHandle();
      if (!safeh_HandlesEqual(*(void *)(v20 + 136), *(void *)(v20 + 144), v30, v31))
      {
        int v39 = nuance_pcre_ObjClose(*(void *)(v20 + 136), *(void *)(v20 + 144));
        if (v39 < 0) {
          LODWORD(v12) = v39;
        }
      }
      int v40 = FEData_ObjClose_NNTN((uint64_t *)v20, v32, v33, v34, v35, v36, v37, v38);
      if (v40 < 0) {
        LODWORD(v12) = v40;
      }
      *(void *)(v20 + 152) = 0;
      int v48 = FERuntimeData_ObjClose((void *)v20, v41, v42, v43, v44, v45, v46, v47);
      if (v48 < 0) {
        LODWORD(v12) = v48;
      }
      *(void *)(v20 + 176) = 0;
      int v56 = FEFunctionMap_ObjClose((void *)v20, v49, v50, v51, v52, v53, v54, v55);
      if (v56 >= 0) {
        uint64_t v12 = v12;
      }
      else {
        uint64_t v12 = v56;
      }
      *(void *)(v20 + 160) = 0;
      if (*(void *)(v20 + 88)) {
        objc_ReleaseObject(*(void *)(v9 + 48), (uint64_t)"FE_DCTLKP");
      }
      if (*(void *)(v20 + 112)) {
        objc_ReleaseObject(*(void *)(v9 + 48), (uint64_t)"FE_DEPES");
      }
      if (*(void *)(v20 + 64)) {
        objc_ReleaseObject(*(void *)(v9 + 48), (uint64_t)"LINGDB");
      }
      uint64_t v63 = *(void *)(v20 + 344);
      if (v63)
      {
        if (*(_WORD *)(v20 + 336))
        {
          unint64_t v64 = 0;
          do
          {
            heap_Free(*(void **)(v9 + 8), *(void *)(*(void *)(v20 + 344) + 8 * v64));
            *(void *)(*(void *)(v20 + 344) + 8 * v64++) = 0;
          }
          while (v64 < *(unsigned __int16 *)(v20 + 336));
          uint64_t v63 = *(void *)(v20 + 344);
        }
        heap_Free(*(void **)(v9 + 8), v63);
      }
      uint64_t v65 = *(void *)(v20 + 288);
      if (v65) {
        heap_Free(*(void **)(v9 + 8), v65);
      }
      uint64_t v66 = *(void *)(v20 + 888);
      if (v66)
      {
        uint64_t v12 = (*(uint64_t (**)(void, void))(v66 + 24))(*(void *)(v20 + 912), *(void *)(v20 + 920));
        *(void *)(v20 + 888) = 0;
      }
      if (*(_DWORD *)(v20 + 840))
      {
        int v57 = *(uint64_t **)(v20 + 856);
        if (v57)
        {
          uint64_t v12 = fi_deinit(*(void *)v20, *(void *)(v20 + 24), v57);
          *(void *)(v20 + 856) = 0;
        }
        if (*(_DWORD *)(v20 + 864) || *(_DWORD *)(v20 + 868)) {
          *(void *)(v20 + 864) = 0;
        }
      }
      if (*(_DWORD *)(v20 + 928))
      {
        uint64_t v67 = *(void *)(v20 + 944);
        if (v67)
        {
          igtree_Deinit(*(void *)v20, v67, (uint64_t)v57, v58, v59, v60, v61, v62);
          heap_Free(*(void **)(*(void *)v20 + 8), *(void *)(v20 + 944));
          *(void *)(v20 + 944) = 0;
        }
        if (*(void *)(v20 + 936)) {
          *(void *)(v20 + 936) = 0;
        }
      }
      uint64_t v68 = *(void *)(v20 + 272);
      if (v68)
      {
        OOC_PlacementDeleteObject(v20 + 224, v68);
        *(void *)(v20 + 272) = 0;
      }
      kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)(v20 + 224));
      heap_Free(*(void **)(v9 + 8), v20);
    }
    heap_Free(*(void **)(v9 + 8), (uint64_t)a2);
    return log_OutText(*(void *)(v9 + 32), (uint64_t)"FE_NNTN", 4, 0, (uint64_t)"nntn : loc ObjClose End (%x)", v69, v70, v71, v12);
  }
  return result;
}

uint64_t hlp_lua_log_callback_1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return log_OutText(a1, (uint64_t)"FE_NNTN", 4, 0, a2, a6, a7, a8, 0);
}

uint64_t setDomainsOnSentence_NNTN(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v86 = *MEMORY[0x263EF8340];
  uint64_t v84 = 0;
  unsigned __int16 v83 = 0;
  unsigned int v81 = 0;
  uint64_t v82 = 0;
  if (a1)
  {
    log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"nntn : setDomainsOnSentence_NNTN Begin", a6, a7, a8, v73);
    uint64_t DomainDefBlockInfo = dumpTokenRecordsInLingDB(a1, (uint64_t)"TRACE", 1, v9, v10, v11, v12, v13);
    if ((DomainDefBlockInfo & 0x80000000) == 0)
    {
      FEData_blockData_getDomains2SearchIn(a1, *((unsigned __int16 *)a1 + 168), a1[43], (uint64_t)v85, &v83, 0, v14, v15);
      log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"nntn : %d block(s) to search in", v17, v18, v19, v83);
      if (v83)
      {
        for (unint64_t i = 0; i < v83; ++i)
        {
          FEData_blockData_newGetDomainDefBlockInfo(a1, (unsigned __int16)v85[i], &v82, v20, v21, v22, v23, v24);
          if (*(_WORD *)(v82 + 24))
          {
            uint64_t v26 = 0;
            unint64_t v27 = 0;
            do
            {
              log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"nntn : domain[%d,%d,%s,type=%d] marker \"%s\"%s %s", v22, v23, v24, i);
              ++v27;
              v26 += 72;
            }
            while (v27 < *(unsigned __int16 *)(v82 + 24));
          }
        }
        uint64_t v28 = *(void *)(a1[33] + 32);
        int v29 = *(uint64_t ***)(v28 + 24);
        if ((unint64_t)v29 < *(void *)(v28 + 32))
        {
          do
          {
            __s2 = 0;
            int v79 = 0;
            int StringAttribute = LDOObject_GetStringAttribute(*v29, "TNTAG", &v79, (uint64_t *)&__s2);
            uint64_t DomainDefBlockInfo = LH_ERROR_to_VERROR(StringAttribute);
            if ((DomainDefBlockInfo & 0x80000000) != 0) {
              return DomainDefBlockInfo;
            }
            if (v79)
            {
              uint64_t v78 = 0;
              int v77 = 0;
              __int16 AbsoluteFrom = LDOLabel_GetAbsoluteFrom((uint64_t)*v29);
              uint64_t v75 = v29;
              __int16 AbsoluteTo = LDOLabel_GetAbsoluteTo((uint64_t)*v29);
              log_OutText(*(void *)(*a1 + 32), a1[23], 5, 0, (uint64_t)"doing DB token %s %d,%d", v33, v34, v35, (uint64_t)__s2);
              if (v83)
              {
                unint64_t v38 = 0;
                __int16 v76 = AbsoluteFrom;
                do
                {
                  FEData_blockData_newGetDomainDefBlockInfo(a1, (unsigned __int16)v85[v38], &v82, v36, v37, v22, v23, v24);
                  int IsRemappable = FEData_blockData_IsRemappable(a1, __s2, &v78, (_WORD *)&v77 + 1, &v77, v39, v40, v41);
                  unsigned int v81 = 0;
                  uint64_t v43 = __s2;
                  if (IsRemappable == 1)
                  {
                    log_OutText(*(void *)(*a1 + 32), a1[23], 5, 0, (uint64_t)"domain %s is remappable to %s", v22, v23, v24, (uint64_t)__s2);
                    uint64_t v44 = HIWORD(v77);
                    __int16 v45 = v77;
                    uint64_t DomainDefBlockInfo = FEData_blockData_newGetDomainDefBlockInfo(a1, (unsigned __int16)v77, &v81, v46, v47, v48, v49, v50);
                    if ((DomainDefBlockInfo & 0x80000000) != 0) {
                      return DomainDefBlockInfo;
                    }
                    uint64_t v55 = v81;
                    if (v81) {
                      goto LABEL_24;
                    }
                    log_OutPublic(*(void *)(*a1 + 32), a1[23], 24041, "%s%s", v51, v52, v53, v54, "skipping undefined remapped domain:");
                  }
                  else
                  {
                    uint64_t v55 = (uint64_t *)v82;
                    uint64_t v56 = *(unsigned __int16 *)(v82 + 24);
                    if (*(_WORD *)(v82 + 24))
                    {
                      uint64_t v57 = 0;
                      uint64_t v58 = *(unsigned __int16 **)(v82 + 16);
                      while (strcmp((const char *)(*((void *)v58 + 6) + *v58), v43))
                      {
                        ++v57;
                        v58 += 36;
                        if (v56 == v57) {
                          goto LABEL_35;
                        }
                      }
                      __int16 v45 = v85[v38];
                      unsigned int v81 = v55;
                      uint64_t v44 = (unsigned __int16)v57;
LABEL_24:
                      uint64_t v59 = v55[2];
                      uint64_t DomainDefBlockInfo = FERuntimeData_AddDomainRange((uint64_t)a1, &v84);
                      if ((DomainDefBlockInfo & 0x80000000) != 0) {
                        return DomainDefBlockInfo;
                      }
                      uint64_t v63 = v84;
                      *(_WORD *)(v84 + 6) = v45;
                      *(_WORD *)(v63 + 4) = v44;
                      *(_WORD *)uint64_t v63 = v76;
                      *(_WORD *)(v63 + 2) = AbsoluteTo;
                      *(_DWORD *)(v63 + 8) = 1;
                      log_OutText(*(void *)(*a1 + 32), a1[23], 5, 0, (uint64_t)"Set Active Domain[%s:%s] range %d,%d", v60, v61, v62, *v81);
                      if (!strcmp((const char *)(*(void *)(v59 + 72 * v44 + 48)+ *(unsigned __int16 *)(v59 + 72 * v44)), (const char *)a1[36])|| *(_DWORD *)(v59 + 72 * v44 + 60) == 1)
                      {
                        log_OutText(*(void *)(*a1 + 32), a1[23], 5, 0, (uint64_t)"normal domain OR was remapped to EscNormal - set additional domains, if any", v22, v23, v24, v74);
                        uint64_t v64 = v82;
                        if (*(_WORD *)(v82 + 24))
                        {
                          unint64_t v65 = 0;
                          uint64_t v66 = 48;
                          do
                          {
                            if (v44 != v65)
                            {
                              uint64_t v67 = *(void *)(v64 + 16);
                              if (!strcmp((const char *)(*(void *)(v67 + v66) + *(unsigned __int16 *)(v67 + v66 - 48)), (const char *)a1[36])|| *(_DWORD *)(v67 + v66 + 12) == 1)
                              {
                                uint64_t DomainDefBlockInfo = FERuntimeData_AddDomainRange((uint64_t)a1, &v84);
                                if ((DomainDefBlockInfo & 0x80000000) != 0) {
                                  return DomainDefBlockInfo;
                                }
                                uint64_t v71 = v84;
                                *(_WORD *)(v84 + 6) = v85[v38];
                                *(_WORD *)(v71 + 4) = v65;
                                *(_WORD *)uint64_t v71 = v76;
                                *(_WORD *)(v71 + 2) = AbsoluteTo;
                                *(_DWORD *)(v71 + 8) = 1;
                                log_OutText(*(void *)(*a1 + 32), a1[23], 5, 0, (uint64_t)"Set (as mapped to normal) Active Domain[%s:%s] range %d,%d", v68, v69, v70, *(void *)v82);
                                uint64_t v64 = v82;
                              }
                            }
                            ++v65;
                            v66 += 72;
                          }
                          while (v65 < *(unsigned __int16 *)(v64 + 24));
                        }
                      }
                    }
                  }
LABEL_35:
                  ++v38;
                }
                while (v38 < v83);
              }
              int v29 = v75;
            }
            ++v29;
          }
          while ((unint64_t)v29 < *(void *)(*(void *)(a1[33] + 32) + 32));
        }
        log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"nntn : setDomainsOnSentence_NNTN End (%x)", v22, v23, v24, DomainDefBlockInfo);
      }
      else
      {
        return 0;
      }
    }
    return DomainDefBlockInfo;
  }
  else
  {
    return NNTNERROR(7);
  }
}

uint64_t mergeDomainsOnSentence_NNTN(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  __int16 v45 = 0;
  uint64_t v46 = 0;
  unsigned __int16 v43 = 0;
  int v42 = 0;
  unsigned __int16 v41 = 0;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  if (a1)
  {
    log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"nntn : mergeDomainsOnSentence_NNTN Begin", a6, a7, a8, v37);
    unsigned __int16 v44 = 0;
    FERuntimeData_GetActiveDomains((uint64_t)a1, (uint64_t)v47, &v44, 0, *((unsigned __int16 *)a1 + 156), 1);
    if (v44)
    {
      unint64_t v9 = 0;
      uint64_t v10 = 1;
      do
      {
        FERuntimeData_GetDomainRange((uint64_t)a1, (unsigned __int16)v47[v9], &v46);
        DomainBlockint Index = FERuntimeData_GetDomainBlockIndex(a1, (unsigned __int16)v47[v9++], &v43, (_WORD *)&v42 + 1);
        unint64_t v15 = v44;
        unint64_t v16 = v10;
        if (v9 < v44)
        {
          while (1)
          {
            FERuntimeData_GetDomainRange((uint64_t)a1, (unsigned __int16)v47[v16], &v45);
            uint64_t v17 = FERuntimeData_GetDomainBlockIndex(a1, (unsigned __int16)v47[v16], &v42, &v41);
            if (*((_DWORD *)v45 + 2) == 1
              && (unsigned __int16)v42 == v43
              && v41 == HIWORD(v42)
              && *v46 == *v45
              && v46[1] == v45[1])
            {
              *((_DWORD *)v45 + 2) = 0;
              log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"nntn : Remove duplicate domain %d,%d RANGE %d,%d ?", v12, v13, v14, 1);
            }
            if ((v17 & 0x80000000) != 0) {
              goto LABEL_44;
            }
            ++v16;
            unint64_t v15 = v44;
            if (v16 >= v44) {
              goto LABEL_15;
            }
          }
        }
        uint64_t v17 = DomainBlockIndex;
LABEL_15:
        ++v10;
      }
      while (v9 < v15);
      if (v15)
      {
        unint64_t v18 = 0;
        while (1)
        {
          FERuntimeData_GetDomainRange((uint64_t)a1, (unsigned __int16)v47[v18], &v46);
          uint64_t DomainDefBlockInfo = FERuntimeData_GetDomainBlockIndex(a1, (unsigned __int16)v47[v18], &v43, (_WORD *)&v42 + 1);
          if ((DomainDefBlockInfo & 0x80000000) != 0) {
            goto LABEL_43;
          }
          uint64_t DomainDefBlockInfo = FEData_blockData_newGetDomainDefBlockInfo(a1, v43, &v40, v20, v21, v12, v13, v14);
          if ((DomainDefBlockInfo & 0x80000000) != 0) {
            goto LABEL_43;
          }
          uint64_t v22 = *(void *)(v40 + 16);
          uint64_t v23 = (unsigned __int16 *)(v22 + 72 * HIWORD(v42));
          if (*(_WORD *)(*(void *)(v40 + 40) + 16 * v23[6] + 8) && *((_DWORD *)v46 + 2) == 1)
          {
            unsigned __int16 v38 = v46[1];
            uint64_t v24 = v22 + 72 * HIWORD(v42);
            uint64_t v26 = *(void *)(v24 + 48);
            uint64_t v25 = (void *)(v24 + 48);
            log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"nntn : Modify domain \"%s\" RANGE %d,%d ?", v12, v13, v14, v26 + *v23);
            if (v18 < v44)
            {
              unint64_t v27 = v18;
              do
              {
                FERuntimeData_GetDomainRange((uint64_t)a1, (unsigned __int16)v47[v27], &v45);
                uint64_t DomainDefBlockInfo = FERuntimeData_GetDomainBlockIndex(a1, (unsigned __int16)v47[v27], &v42, &v41);
                if ((DomainDefBlockInfo & 0x80000000) != 0) {
                  goto LABEL_43;
                }
                uint64_t DomainDefBlockInfo = FEData_blockData_newGetDomainDefBlockInfo(a1, (unsigned __int16)v42, &v39, v28, v29, v12, v13, v14);
                if ((DomainDefBlockInfo & 0x80000000) != 0) {
                  goto LABEL_43;
                }
                uint64_t v30 = v45;
                if (v45 != v46 && *((_DWORD *)v45 + 2) == 1)
                {
                  int v31 = *v45;
                  if (v31 == v38 || v31 == *v46 && v45[1] == v46[1])
                  {
                    uint64_t v32 = (const char *)(*v25 + *v23);
                    if (!strcmp(v32, (const char *)(*(void *)(*(void *)(v39 + 16) + 72 * v41 + 48)+ *(unsigned __int16 *)(*(void *)(v39 + 16) + 72 * v41))))
                    {
                      unsigned __int16 v38 = v30[1];
                      log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"nntn : Modify domain \"%s\" RANGE %d,%d -> %d %d (merge with %s)", v33, v34, v35, (uint64_t)v32);
                      *((_DWORD *)v45 + 2) = 0;
                    }
                  }
                }
              }
              while (++v27 < v44);
            }
            if ((__int16)v46[1] != v38)
            {
              uint64_t DomainDefBlockInfo = FERuntimeData_UpdateDomainRange(a1, (unsigned __int16)v18, v38);
              if ((DomainDefBlockInfo & 0x80000000) != 0) {
                goto LABEL_43;
              }
            }
          }
          if (++v18 >= v44) {
            goto LABEL_42;
          }
        }
      }
      if ((v17 & 0x80000000) != 0) {
        goto LABEL_44;
      }
    }
LABEL_42:
    uint64_t DomainDefBlockInfo = FERuntimeData_PruneAndDumpActiveDomains(a1);
LABEL_43:
    uint64_t v17 = DomainDefBlockInfo;
LABEL_44:
    log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"nntn : mergeDomainsOnSentence_NNTN End (%x)", v12, v13, v14, v17);
    return v17;
  }
  else
  {
    return NNTNERROR(7);
  }
}

uint64_t fe_mnc_nntn_Process(uint64_t a1, __int16 *a2, char *a3)
{
  return stat_mnctn_seq2rule(a1, (uint64_t *)(a1 + 848), a2, a3);
}

uint64_t stat_mnctn_seq2rule(uint64_t a1, uint64_t *a2, __int16 *a3, char *a4)
{
  uint64_t v8 = *a2;
  int v62 = 0;
  uint64_t v60 = 0;
  uint64_t v9 = a2[5];
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, int *))(v9 + 40))(a2[8], a2[9], &v62);
  if ((v10 & 0x80000000) != 0) {
    return v10;
  }
  uint64_t v11 = heap_Calloc(*(void **)(v8 + 8), 1, 8);
  if (!v11)
  {
    uint64_t v32 = 2589990922;
    log_OutPublic(*(void *)(v8 + 32), (uint64_t)"FE_NNTN", 37000, 0, v12, v13, v14, v15, v53);
    return v32;
  }
  unint64_t v16 = (char *)v11;
  uint64_t v17 = heap_Calloc(*(void **)(v8 + 8), 1, 2048);
  if (!v17)
  {
    uint64_t v32 = 2589990922;
    log_OutPublic(*(void *)(v8 + 32), (uint64_t)"FE_NNTN", 37000, 0, v18, v19, v20, v21, v53);
    uint64_t v33 = *(void **)(v8 + 8);
    uint64_t v34 = (uint64_t)v16;
    goto LABEL_48;
  }
  uint64_t v22 = (char *)v17;
  int v23 = *((_DWORD *)a2 + 5);
  if (*(_DWORD *)(a1 + 956) == 1) {
    ++v23;
  }
  uint64_t v24 = (void *)heap_Alloc(*(void *)(v8 + 8), 4 * (v23 * *((_DWORD *)a2 + 4)));
  uint64_t v61 = v24;
  if (!v24)
  {
    uint64_t v32 = 2589990922;
    log_OutPublic(*(void *)(v8 + 32), (uint64_t)"FE_NNTN", 37000, 0, v25, v26, v27, v28, v53);
    goto LABEL_47;
  }
  uint64_t v29 = *a3;
  int __dst = a4;
  uint64_t v58 = (float *)v24;
  if (*((_DWORD *)a2 + 8) == 1)
  {
    unsigned __int16 v30 = *((_DWORD *)a2 + 4) - (a3[1] - v29);
    unsigned int v54 = ((v30 & 1) + v30) >> 1;
    int v31 = -v54;
  }
  else
  {
    LOWORD(v54) = 7;
    LOWORD(v31) = -7;
  }
  strncpy(v22, (const char *)(*(void *)(a1 + 304) + v29), (unsigned __int16)(a3[1] - v29 + 1));
  unsigned __int16 v39 = 0;
  int v57 = 0;
  int v40 = 0;
  v22[a3[1] - *a3] = 0;
LABEL_15:
  unsigned int v41 = v39;
  while (1)
  {
    uint64_t v42 = *((unsigned int *)a2 + 4);
    if (v42 <= v41) {
      break;
    }
    if ((v31 & 0x8000) != 0)
    {
      nnGetChar(*(void *)(a1 + 304), a3, (__int16)v31, v16);
      LOWORD(v31) = v31 + 1;
      if (*v16)
      {
        int v59 = v40;
LABEL_32:
        int v46 = *(_DWORD *)(a1 + 956);
        float v47 = 0.0;
        goto LABEL_33;
      }
    }
    else
    {
      int v59 = v40;
      if (v57)
      {
        if ((__int16)v54 < 1)
        {
          strcpy(v16, "</s>");
        }
        else
        {
          nnGetChar(*(void *)(a1 + 304), a3, (__int16)(8 - v54), v16);
          if (!*v16) {
            strcpy(v16, "</s>");
          }
          LOWORD(v54) = v54 - 1;
        }
        goto LABEL_32;
      }
      uint64_t v56 = v9;
      if ((v40 & 0x8000) == 0)
      {
        int v43 = v40;
        if ((_WORD)v40)
        {
          unsigned int NextUtf8Offset = 0;
          while (NextUtf8Offset != strlen(v22))
          {
            unsigned int NextUtf8Offset = utf8_GetNextUtf8Offset(v22, NextUtf8Offset);
            int v45 = (__int16)v43--;
            if (v45 <= 1) {
              goto LABEL_28;
            }
          }
        }
        else
        {
          unsigned int NextUtf8Offset = 0;
LABEL_28:
          if ((utf8_getUTF8Char((uint64_t)v22, NextUtf8Offset, v16) & 0x80000000) == 0) {
            goto LABEL_30;
          }
        }
      }
      *unint64_t v16 = 0;
LABEL_30:
      int v40 = v59 + 1;
      int v57 = 1;
      uint64_t v9 = v56;
      if (*v16)
      {
        ++v59;
        int v57 = 0;
        int v46 = *(_DWORD *)(a1 + 956);
        float v47 = 1.0;
LABEL_33:
        if (v46 == 1)
        {
          float *v58 = v47;
          uint64_t v48 = v58 + 1;
        }
        else
        {
          uint64_t v48 = v58;
        }
        if (((*(uint64_t (**)(uint64_t, uint64_t, char *, float *))(v9 + 56))(a2[8], a2[9], v16, v48) & 0x1FFF) == 0x14)
        {
          log_OutText(*(void *)(v8 + 32), (uint64_t)"FE_NNTN", 5, 0, (uint64_t)"No embedding vector for character %s . Fall back!", v36, v37, v38, (uint64_t)v16);
          strcpy(v16, "</s>");
          (*(void (**)(uint64_t, uint64_t, char *, float *))(v9 + 56))(a2[8], a2[9], v16, v48);
        }
        unsigned __int16 v39 = v41 + 1;
        uint64_t v58 = &v48[v62];
        int v40 = v59;
        goto LABEL_15;
      }
    }
  }
  uint64_t v32 = fi_predict((uint64_t ***)a2[1], &v61, v42, &v60, v35, v36, v37, v38);
  if ((v32 & 0x80000000) != 0) {
    log_OutText(*(void *)(v8 + 32), (uint64_t)"FE_NNTN", 5, 0, (uint64_t)"FIhmogrph Prediction Failed", v49, v50, v51, 0);
  }
  else {
    strcpy(__dst, *v60);
  }
LABEL_47:
  heap_Free(*(void **)(v8 + 8), (uint64_t)v16);
  uint64_t v33 = *(void **)(v8 + 8);
  uint64_t v34 = (uint64_t)v22;
LABEL_48:
  heap_Free(v33, v34);
  return v32;
}

uint64_t nnGetChar(uint64_t __s, __int16 *a2, int a3, unsigned char *a4)
{
  signed int NextUtf8Offset = *a2;
  if ((NextUtf8Offset & 0x80000000) == 0)
  {
    signed int v6 = a2[1];
    if (NextUtf8Offset < v6)
    {
      int v7 = a3;
      uint64_t v8 = (char *)__s;
      if ((a3 & 0x80000000) == 0)
      {
        if (a3)
        {
          signed int NextUtf8Offset = v6 - 1;
          while (1)
          {
            long long __s = strlen(v8);
            if (NextUtf8Offset == __s) {
              goto LABEL_16;
            }
            signed int NextUtf8Offset = utf8_GetNextUtf8Offset(v8, NextUtf8Offset);
            int v9 = (__int16)v7--;
            if (v9 <= 1) {
              goto LABEL_15;
            }
          }
        }
        signed int NextUtf8Offset = 0;
LABEL_15:
        long long __s = utf8_getUTF8Char((uint64_t)v8, NextUtf8Offset, a4);
        if ((__s & 0x80000000) == 0) {
          return __s;
        }
        goto LABEL_16;
      }
      if (*a2)
      {
        do
        {
          long long __s = utf8_GetPreviousUtf8Offset((uint64_t)v8, NextUtf8Offset);
          signed int NextUtf8Offset = __s;
          BOOL v10 = (unsigned __int16)~(_WORD)v7 == 0;
          LOWORD(v7) = v7 + 1;
        }
        while (!v10 && __s);
        if (!(_WORD)v7) {
          goto LABEL_15;
        }
      }
    }
  }
LABEL_16:
  *a4 = 0;
  return __s;
}

uint64_t FEData_ObjOpen_NNTN(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  log_OutText(*(void *)(*a3 + 32), a3[23], 4, 0, (uint64_t)"fe_data : ObjOpen Begin", a6, a7, a8, v27);
  int v9 = (void *)heap_Calloc(*(void **)(*a3 + 8), 1, 24);
  if (v9)
  {
    unint64_t v16 = v9;
    a3[19] = (uint64_t)v9;
    uint64_t v17 = FEData_functionData_ObjOpen(a3, v9, v10, v11, v12, v13, v14, v15);
    if ((v17 & 0x80000000) != 0
      || (uint64_t v17 = FEData_domainDefs_ObjOpen(a3, v16 + 1, v19, v20, v21, v22, v23, v24), (v17 & 0x80000000) != 0))
    {
      uint64_t v25 = v17;
    }
    else
    {
      uint64_t v25 = FEData_blockData_ObjOpen(a3, v16 + 2, v19, v20, v21, v22, v23, v24);
      if ((v25 & 0x80000000) == 0)
      {
LABEL_11:
        log_OutText(*(void *)(*a3 + 32), a3[23], 4, 0, (uint64_t)"fe_data : ObjOpen End (%x)", v22, v23, v24, v25);
        return v25;
      }
    }
    FEData_ObjClose_NNTN(a3, v18, v19, v20, v21, v22, v23, v24);
    goto LABEL_11;
  }
  log_OutPublic(*(void *)(*a3 + 32), a3[23], 24048, 0, v12, v13, v14, v15, v28);
  return NNTNERROR(10);
}

uint64_t FEData_ObjClose_NNTN(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[19];
  if (v8)
  {
    log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"fe_data : ObjClose Begin", a6, a7, a8, v39);
    int v17 = FEData_functionData_ObjClose(a1, v10, v11, v12, v13, v14, v15, v16);
    LODWORD(v18) = v17 & (v17 >> 31);
    int v26 = FEData_blockData_ObjClose_NNTN(a1, v19, v20, v21, v22, v23, v24, v25);
    if (v26 < 0) {
      LODWORD(v18) = v26;
    }
    int v34 = FEData_domainDefs_ObjClose(a1, v27, v28, v29, v30, v31, v32, v33);
    if (v34 >= 0) {
      uint64_t v18 = v18;
    }
    else {
      uint64_t v18 = v34;
    }
    heap_Free(*(void **)(*a1 + 8), v8);
    a1[19] = 0;
    log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"fe_data : ObjClose End (%x)", v35, v36, v37, v18);
    return v18;
  }
  else
  {
    return NNTNERROR(8);
  }
}

uint64_t FEData_blockData_ObjClose_NNTN(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1[19] + 16);
  uint64_t v10 = *(void *)(*a1 + 32);
  uint64_t v11 = a1[23];
  if (v9)
  {
    log_OutText(v10, v11, 4, 0, (uint64_t)"blockData : ObjClose Begin", a6, a7, a8, v16);
    log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"blockData : ObjClose End (%x)", v12, v13, v14, 0);
    heap_Free(*(void **)(*a1 + 8), v9);
    return 0;
  }
  else
  {
    log_OutPublic(v10, v11, 24049, 0, a5, a6, a7, a8, v16);
    return FEDATA_ERROR(7);
  }
}

uint64_t FEData_blockData_getTokenAndRegexData_NNTN(void *a1, uint64_t a2, void *a3, _WORD *a4, void *a5, _DWORD *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1[19] + 16);
  if (v8)
  {
    uint64_t v9 = *(void **)(*(void *)(*(void *)(*(void *)(v8 + 136) + 8)
                                + 8 * *(unsigned __int16 *)(*(void *)a2 + 2))
                    + 8);
    uint64_t v10 = v9[6] + 32 * *(unsigned __int16 *)(*(void *)a2 + 4);
    uint64_t v11 = v9[8] + 16 * *(unsigned __int16 *)(v10 + 6);
    *a4 = *(_WORD *)(v11 + 10);
    *a6 = *(_DWORD *)(v11 + 12);
    *a3 = v9[4] + *(unsigned int *)(v11 + 4);
    *a5 = v9[3] + *(unsigned __int16 *)(v10 + 4);
    return 0;
  }
  else
  {
    log_OutPublic(*(void *)(*a1 + 32), a1[23], 24049, 0, (uint64_t)a5, (uint64_t)a6, a7, a8, vars0);
    return FEDATA_ERROR(7);
  }
}

uint64_t FEData_blockData_loadDataFiles_NNTN(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (uint64_t *)a1;
  uint64_t v115 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a1 + 152);
  long long v112 = 0;
  memset(v114, 0, 128);
  memset(v113, 0, sizeof(v113));
  unsigned int v111 = 0;
  uint64_t v109 = 0;
  uint64_t v110 = 0;
  *(void *)uint64_t v108 = 0;
  uint64_t v10 = *(unsigned __int16 **)(v9 + 16);
  if (!v10)
  {
    uint64_t v11 = *(void *)(*(void *)a1 + 32);
    uint64_t v12 = v8[23];
    uint64_t v13 = 24049;
    goto LABEL_5;
  }
  if (!*v10)
  {
    uint64_t v16 = *(void *)a1;
    if (*(unsigned __int8 *)(a1 + 352) > *(unsigned __int16 *)(a1 + 336))
    {
      log_OutPublic(*(void *)(v16 + 32), *(void *)(a1 + 184), 24056, "%s%d%s%d", a5, a6, a7, a8, "invalid language identifier index");
      uint64_t v14 = 0;
      goto LABEL_6;
    }
    if ((paramc_ParamGetStr(*(void *)(v16 + 40), (uint64_t)"langcode", v108) & 0x80000000) != 0) {
      *(void *)uint64_t v108 = &byte_20D5A22AE;
    }
    if ((paramc_ParamGetStr(*(void *)(*v8 + 40), (uint64_t)"fecfg", &v109) & 0x80000000) == 0)
    {
      strcpy((char *)v113, "nntokentn/");
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      uint64_t v17 = brokeraux_ComposeBrokerString(*v8, (const char *)v113, 1, 1, *(char **)v108, 0, 0, v114, 0x80uLL);
      if ((v17 & 0x80000000) != 0) {
        return FEDATA_ERROR(v17);
      }
      RsrcHandleForThisApunint64_t i = (_WORD *)getRsrcHandleForThisApi(*v8, v8[1], v8[2], v8[4]);
      if ((ssftriff_reader_ObjOpen(RsrcHandleForThisApi, v19, 2, v114, "TOKN", 1031, (uint64_t *)&v112) & 0x80000000) == 0)
      {
LABEL_18:
        Chunint k = ssftriff_reader_FindChunk((uint64_t)v112, "CFIG", 0, &v111, &v110);
        int v31 = Chunk & 0x1FFF;
        if ((Chunk & 0x80000000) != 0)
        {
          uint64_t DataBlockFromFileRefCnt = Chunk;
          if (v31 != 20) {
            goto LABEL_107;
          }
        }
        if (v31 == 20)
        {
          BOOL v33 = 0;
          unsigned int v34 = 0;
          int v35 = 0;
        }
        else
        {
          unsigned int v34 = *v110;
          if (*v110)
          {
            if (v34 == 3)
            {
              unsigned int v34 = 0;
              BOOL v33 = v110[1] == 1;
              int v35 = 1;
            }
            else
            {
              BOOL v33 = v110[1] == 1;
              if (v34 < 2)
              {
                unsigned int v34 = 0;
                int v35 = 0;
              }
              else
              {
                int v35 = 0;
                unsigned int v34 = v110[2] == 1;
              }
            }
          }
          else
          {
            BOOL v33 = 0;
            int v35 = *v110;
          }
          uint64_t v36 = ssftriff_reader_CloseChunk((uint64_t)v112);
          if ((v36 & 0x80000000) != 0) {
            goto LABEL_106;
          }
        }
        uint64_t v36 = ssftriff_reader_FindChunk((uint64_t)v112, "FILE", 0, &v111, &v110);
        if ((v36 & 0x80000000) == 0)
        {
          *uint64_t v10 = *v110;
          uint64_t v36 = ssftriff_reader_CloseChunk((uint64_t)v112);
          if ((v36 & 0x80000000) == 0)
          {
            __strcpy_chk();
            uint64_t DataBlockFromFileRefCnt = readDataBlockFromFileRefCnt((uint64_t)v8, (uint64_t)v112, v33, v34, v35, (uint64_t)v114);
            if ((DataBlockFromFileRefCnt & 0x80000000) == 0)
            {
              ssftriff_reader_ObjClose(v112, v37, v38, v39, v27, v28, v29, v30);
              long long v112 = 0;
              unsigned int v47 = *v10;
              if (*v10)
              {
                unsigned int v96 = DataBlockFromFileRefCnt;
                unsigned int v97 = v8;
                unint64_t v48 = 0;
                int v49 = 0;
                unsigned int v106 = v10;
                do
                {
                  uint64_t v50 = *(void *)(*(void *)(*((void *)v10 + 17) + 8) + 8 * v48);
                  uint64_t v107 = v50;
                  if (v50)
                  {
                    uint64_t v51 = *(void *)(v50 + 16);
                    if (v51)
                    {
                      unint64_t v52 = 0;
                      while (v52 < *(unsigned __int16 *)(v51 + 24))
                      {
                        uint64_t v53 = *(void *)(v51 + 16);
                        unsigned int v54 = (unsigned __int16 *)(v53 + 72 * v52);
                        if (*((_DWORD *)v54 + 16) == 1)
                        {
                          if (v97[36])
                          {
                            if (strcmp((const char *)v97[36], (const char *)(*(void *)(v53 + 72 * v52 + 48) + *v54)))
                            {
                              log_OutPublic(*(void *)(*v97 + 32), v97[23], 24053, "%s%s%s%s", v43, v44, v45, v46, "first assigned");
                              goto LABEL_105;
                            }
                          }
                          else
                          {
                            unint64_t v55 = v52;
                            uint64_t v56 = v53 + 72 * v52;
                            uint64_t v58 = *(void *)(v56 + 48);
                            int v57 = (void *)(v56 + 48);
                            int v59 = strlen((const char *)(v58 + *v54));
                            uint64_t v60 = (char *)heap_Calloc(*(void **)(*v97 + 8), 1, (v59 + 1));
                            v97[36] = (uint64_t)v60;
                            if (!v60)
                            {
                              log_OutPublic(*(void *)(*v97 + 32), v97[23], 24048, 0, v61, v62, v63, v64, v95);
                              uint64_t v17 = 10;
                              return FEDATA_ERROR(v17);
                            }
                            strcpy(v60, (const char *)(*v57 + *v54));
                            *((_WORD *)v97 + 148) = v48;
                            *((_WORD *)v97 + 149) = v55;
                            unint64_t v52 = v55;
                          }
                        }
                        unint64_t v98 = v52;
                        if (*(_DWORD *)(v53 + 72 * v52 + 8) == 1)
                        {
                          uint64_t v65 = *(void *)(v107 + 16);
                          uint64_t v102 = *(unsigned __int16 *)(v65 + 48);
                          if (*(_WORD *)(v65 + 48))
                          {
                            uint64_t v66 = 0;
                            uint64_t v100 = *(void *)(v65 + 40);
                            while (1)
                            {
                              uint64_t v104 = v66;
                              uint64_t v67 = v100 + 16 * v66;
                              uint64_t v68 = *(unsigned __int16 *)(v67 + 8);
                              if (*(_WORD *)(v67 + 8))
                              {
                                uint64_t v69 = 0;
                                uint64_t v70 = *v10;
                                do
                                {
                                  if (v70)
                                  {
                                    uint64_t v71 = 0;
                                    uint64_t v72 = *(void *)(*((void *)v10 + 17) + 8);
                                    while (1)
                                    {
                                      uint64_t v73 = *(void *)(v72 + 8 * v71);
                                      if (*(_DWORD *)v73 != 1 && *(_DWORD *)v73 != 4)
                                      {
                                        if (*(_WORD *)(v65 + 50))
                                        {
                                          uint64_t v75 = *(unsigned __int16 **)(*(void *)v67 + 24 * v69);
                                          uint64_t v76 = *v75;
                                          if (*(unsigned __int16 *)(v65 + 50) > v76
                                            && !strcmp(**(const char ***)(v73 + 8), *(const char **)(*(void *)(v65 + 56) + 8 * v76)))
                                          {
                                            break;
                                          }
                                        }
                                      }
                                      if (v70 == ++v71)
                                      {
                                        int v49 = 0;
                                        goto LABEL_65;
                                      }
                                    }
                                    v75[1] = v71;
                                    int v49 = 1;
LABEL_65:
                                    uint64_t v10 = v106;
                                  }
                                  else
                                  {
                                    int v49 = 0;
                                  }
                                  ++v69;
                                }
                                while (v69 != v68);
                              }
                              if (!v49) {
                                break;
                              }
                              uint64_t v66 = v104 + 1;
                              int v49 = 1;
                              if (v104 + 1 == v102) {
                                goto LABEL_70;
                              }
                            }
                            log_OutPublic(*(void *)(*v97 + 32), v97[23], 24045, 0, v43, v44, v45, v46, v95);
                            return v96;
                          }
                        }
LABEL_70:
                        unint64_t v52 = v98 + 1;
                        uint64_t v50 = v107;
                        uint64_t v51 = *(void *)(v107 + 16);
                        if (!v51) {
                          break;
                        }
                      }
                    }
                    unsigned int v47 = *v10;
                  }
                  if (v47)
                  {
                    uint64_t v77 = 0;
                    unsigned int v99 = v47;
                    uint64_t v101 = *(void *)(*((void *)v10 + 17) + 8);
                    for (unint64_t i = v47; i != v77; v87 = i)
                    {
                      uint64_t v78 = *(void *)(v101 + 8 * v77);
                      if (v78)
                      {
                        uint64_t v79 = *(void *)(v78 + 24);
                        if (v79)
                        {
                          uint64_t v80 = *(unsigned __int16 *)(v79 + 16);
                          if (*(_WORD *)(v79 + 16))
                          {
                            uint64_t v81 = 0;
                            uint64_t v105 = *(void *)(v79 + 8);
                            do
                            {
                              if (v50)
                              {
                                uint64_t v82 = *(void *)(v107 + 16);
                                if (v82)
                                {
                                  uint64_t v83 = *(unsigned __int16 *)(v82 + 24);
                                  if (*(_WORD *)(v82 + 24))
                                  {
                                    uint64_t v84 = *(void *)(v105 + 8 * v81);
                                    uint64_t v85 = *(unsigned __int16 **)(v82 + 16);
                                    uint64_t v86 = *(const char **)v84;
                                    do
                                    {
                                      if (!strcmp(v86, (const char *)(*((void *)v85 + 6) + *v85))) {
                                        *(_WORD *)(v84 + 10) = v48;
                                      }
                                      v85 += 36;
                                      --v83;
                                    }
                                    while (v83);
                                  }
                                }
                              }
                              ++v81;
                              uint64_t v50 = v107;
                            }
                            while (v81 != v80);
                          }
                        }
                      }
                      ++v77;
                    }
                    uint64_t v10 = v106;
                    unsigned int v47 = v99;
                  }
                  else
                  {
                    unint64_t v87 = 0;
                  }
                  ++v48;
                }
                while (v48 < v87);
                uint64_t v8 = v97;
                uint64_t DataBlockFromFileRefCnt = v96;
                if (v47)
                {
                  for (unint64_t j = 0; j < v47; ++j)
                  {
                    uint64_t v89 = *(void *)(*(void *)(*((void *)v10 + 17) + 8) + 8 * j);
                    if (v89)
                    {
                      uint64_t v90 = *(void *)(v89 + 16);
                      if (v90)
                      {
                        uint64_t v91 = 0;
                        uint64_t v92 = -1;
                        do
                        {
                          if (++v92 >= (unint64_t)*(unsigned __int16 *)(v90 + 24)) {
                            break;
                          }
                          uint64_t v93 = *(void *)(v90 + 16) + v91;
                          if (*(_WORD *)(v93 + 40) && (!*(_DWORD *)(v93 + 8) || !*(_WORD *)(v90 + 48))) {
                            log_OutPublic(*(void *)(*v97 + 32), v97[23], 24062, 0, v43, v44, v45, v46, v95);
                          }
                          v91 += 72;
                          uint64_t v90 = *(void *)(v89 + 16);
                        }
                        while (v90);
                      }
                      unsigned int v47 = *v10;
                    }
                  }
                }
              }
              if (!v8[36])
              {
                log_OutPublic(*(void *)(*v8 + 32), v8[23], 24054, 0, v43, v44, v45, v46, v95);
LABEL_105:
                uint64_t v17 = 0;
                return FEDATA_ERROR(v17);
              }
LABEL_108:
              if (v112) {
                ssftriff_reader_ObjClose(v112, v40, v41, v42, v43, v44, v45, v46);
              }
              return DataBlockFromFileRefCnt;
            }
LABEL_107:
            log_OutPublic(*(void *)(*v8 + 32), v8[23], 24052, 0, v27, v28, v29, v30, v95);
            goto LABEL_108;
          }
        }
LABEL_106:
        uint64_t DataBlockFromFileRefCnt = v36;
        goto LABEL_107;
      }
    }
    strcpy((char *)v113, "nntokentn/");
    __strcat_chk();
    uint64_t v17 = brokeraux_ComposeBrokerString(*v8, (const char *)v113, 1, 1, *(char **)v108, 0, 0, v114, 0x80uLL);
    if ((v17 & 0x80000000) == 0)
    {
      uint64_t v20 = (_WORD *)getRsrcHandleForThisApi(*v8, v8[1], v8[2], v8[4]);
      if ((ssftriff_reader_ObjOpen(v20, v21, 0, v114, "TOKN", 1031, (uint64_t *)&v112) & 0x80000000) == 0) {
        goto LABEL_18;
      }
      log_OutPublic(*(void *)(*v8 + 32), v8[23], 24057, "%s%s", v22, v23, v24, v25, "Missing broker header file");
      uint64_t v17 = 3;
    }
    return FEDATA_ERROR(v17);
  }
  uint64_t v11 = *(void *)(*(void *)a1 + 32);
  uint64_t v12 = v8[23];
  uint64_t v13 = 24055;
LABEL_5:
  log_OutPublic(v11, v12, v13, 0, a5, a6, a7, a8, v94);
  uint64_t v14 = 7;
LABEL_6:
  return FEDATA_ERROR(v14);
}

uint64_t readDataBlockFromFileRefCnt(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6)
{
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t result = InitRsrcFunction(*(_WORD **)(a1 + 8), *(void *)(a1 + 16), &v22);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = InitRsrcFunction(*(_WORD **)(a1 + 32), *(void *)(a1 + 40), &v21);
    if ((result & 0x80000000) == 0)
    {
      v16[0] = a1;
      v16[1] = a2;
      int v17 = a3;
      int v18 = a4;
      LODWORD(v19) = a5;
      uint64_t v14 = v21;
      uint64_t v13 = v22;
      __s1 = 0;
      if ((paramc_ParamGetStr(*(void *)(v22 + 40), (uint64_t)"clcpppipelinemode", &__s1) & 0x80000000) != 0
        || !__s1
        || !*__s1
        || !strcmp(__s1, "internal"))
      {
        uint64_t v13 = v14;
      }
      uint64_t result = objc_GetAddRefCountedObject(*(void *)(v13 + 48), a6, (uint64_t (*)(void, void, uint64_t, long long *, uint64_t))readDataBlockFromFile_ObjcLoad, (void (*)(void, void, long long *))readDataBlockFromFile_ObjcClose, (uint64_t)v16, &v20);
      if ((result & 0x80000000) != 0) {
        uint64_t v15 = 0;
      }
      else {
        uint64_t v15 = *(void *)(v20 + 32);
      }
      *(void *)(*(void *)(*(void *)(a1 + 152) + 16) + 136) = v15;
    }
  }
  return result;
}

uint64_t readDataBlockFromFile_ObjcLoad(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  signed int v6 = *(uint64_t **)a5;
  uint64_t v7 = *(void *)(a5 + 8);
  int v8 = *(_DWORD *)(a5 + 16);
  int v9 = *(_DWORD *)(a5 + 20);
  int v10 = *(_DWORD *)(a5 + 24);
  uint64_t v11 = *(unsigned __int16 **)(*(void *)(*(void *)a5 + 152) + 16);
  uint64_t v12 = heap_Calloc(*(void **)(**(void **)a5 + 8), 1, 16);
  *(void *)(a4 + 32) = v12;
  uint64_t v17 = *v6;
  if (!v12)
  {
LABEL_141:
    log_OutPublic(*(void *)(v17 + 32), v6[23], 24048, 0, v13, v14, v15, v16, v169);
    uint64_t v29 = FEDATA_ERROR(10);
    if ((v29 & 0x80000000) != 0) {
LABEL_142:
    }
      log_OutPublic(*(void *)(*v6 + 32), v6[23], 24052, 0, v164, v165, v166, v167, v170);
    return v29;
  }
  *(void *)(*(void *)(a4 + 32) + 8) = heap_Calloc(*(void **)(v17 + 8), 1, (8 * *v11) | 1);
  uint64_t v18 = *(void *)(a4 + 32);
  if (!*(void *)(v18 + 8))
  {
LABEL_140:
    uint64_t v17 = *v6;
    goto LABEL_141;
  }
  int v178 = v11;
  int v19 = *v11;
  *(_WORD *)uint64_t v18 = v19;
  if (v19)
  {
    int v175 = v10;
    int v176 = v8;
    int v177 = v9;
    unsigned int v20 = 0;
    uint64_t v21 = v178;
    while (1)
    {
      *(void *)(*(void *)(*(void *)(a4 + 32) + 8) + 8 * v20) = heap_Calloc(*(void **)(*v6 + 8), 1, 48);
      uint64_t v22 = *(void *)(*(void *)(*(void *)(a4 + 32) + 8) + 8 * v20);
      if (!v22) {
        goto LABEL_140;
      }
      *(void *)BOOL v180 = 0;
      uint64_t v181 = 0;
      unsigned int v179 = 0;
      Chunint k = ssftriff_reader_FindChunk(v7, "HEAD", 1, (unsigned int *)&v181 + 1, v180);
      if ((Chunk & 0x80000000) != 0)
      {
LABEL_94:
        uint64_t v29 = Chunk;
LABEL_95:
        int v42 = 0;
LABEL_96:
        log_OutPublic(*(void *)(*v6 + 32), v6[23], 24052, 0, (uint64_t)v24, v25, v26, v27, v169);
        goto LABEL_97;
      }
      LODWORD(v181) = 0;
      int v28 = (unsigned __int16)**(_WORD **)v180;
      LODWORD(v181) = 2;
      *(_DWORD *)uint64_t v22 = v28;
      uint64_t v29 = ssftriff_reader_CloseChunk(v7);
      if ((v29 & 0x80000000) != 0) {
        goto LABEL_95;
      }
      unsigned int v30 = *(_DWORD *)v22;
      if ((*(_DWORD *)v22 - 3) <= 2)
      {
        uint64_t v31 = heap_Calloc(*(void **)(*v6 + 8), 1, 24);
        *(void *)(v22 + 24) = v31;
        if (!v31) {
          goto LABEL_102;
        }
        Chunint k = ssftriff_reader_FindChunk(v7, "REMP", 1, (unsigned int *)&v181 + 1, v180);
        if ((Chunk & 0x80000000) != 0) {
          goto LABEL_94;
        }
        LODWORD(v181) = 0;
        uint64_t v33 = *(void *)v180;
        int v34 = (unsigned __int16)**(_WORD **)v180;
        LODWORD(v181) = 2;
        uint64_t v35 = *(void *)(v22 + 24);
        *(_DWORD *)uint64_t v35 = v34;
        if (!v34)
        {
          *(_WORD *)(v35 + 16) = *(_WORD *)(v33 + 2);
          LODWORD(v181) = 4;
          if (*(_WORD *)(*(void *)(v22 + 24) + 16))
          {
            uint64_t v135 = heap_Calloc(*(void **)(*v6 + 8), 1, 8 * *(unsigned __int16 *)(*(void *)(v22 + 24) + 16));
            uint64_t v140 = *(void *)(v22 + 24);
            *(void *)(v140 + 8) = v135;
            if (!v135)
            {
              log_OutPublic(*(void *)(*v6 + 32), v6[23], 24048, 0, v136, v137, v138, v139, v169);
              *(_WORD *)(*(void *)(v22 + 24) + 16) = 0;
              goto LABEL_129;
            }
            if (*(_WORD *)(v140 + 16))
            {
              uint64_t v141 = 0;
              while (1)
              {
                *(void *)(*(void *)(*(void *)(v22 + 24) + 8) + 8 * v141) = heap_Calloc(*(void **)(*v6 + 8), 1, 24);
                uint64_t v142 = *(void *)(v22 + 24);
                if (!*(void *)(*(void *)(v142 + 8) + 8 * v141)) {
                  goto LABEL_127;
                }
                if (++v141 >= (unint64_t)*(unsigned __int16 *)(v142 + 16))
                {
                  uint64_t v21 = v178;
                  if (!*(_WORD *)(v142 + 16)) {
                    break;
                  }
                  uint64_t v143 = 0;
                  while (1)
                  {
                    uint64_t v172 = v143;
                    int v144 = *(void **)(*(void *)(v142 + 8) + 8 * v143);
                    __int16 v145 = *(_WORD *)(*(void *)v180 + v181);
                    LODWORD(v181) = v181 + 2;
                    unsigned __int16 v146 = v145 + 1;
                    int v147 = (unsigned char *)heap_Calloc(*(void **)(*v6 + 8), 1, (unsigned __int16)(v145 + 1));
                    *int v144 = v147;
                    if (!v147) {
                      goto LABEL_127;
                    }
                    int v174 = v144;
                    unsigned int v179 = v146;
                    uint64_t v29 = ssftriff_reader_ReadStringZ(v7, *(uint64_t *)v180, HIDWORD(v181), v181, v147, &v179);
                    int v42 = 1;
                    if ((v29 & 0x80000000) != 0 || v179 != v146) {
                      goto LABEL_104;
                    }
                    unsigned int v148 = v181 + v146;
                    LODWORD(v181) = v148;
                    uint64_t v149 = *(void *)v180;
                    uint64_t v150 = v174;
                    *((_WORD *)v174 + 4) = *(_WORD *)(*(void *)v180 + v148);
                    LODWORD(v181) = v148 + 2;
                    *((_WORD *)v174 + 5) = *(_WORD *)(v149 + v148 + 2);
                    LODWORD(v181) = v148 + 4;
                    uint64_t v151 = *(unsigned __int16 *)(v149 + v148 + 4);
                    *((_WORD *)v174 + 6) = v151;
                    LODWORD(v181) = v148 + 6;
                    if (v151)
                    {
                      uint64_t v152 = heap_Calloc(*(void **)(*v6 + 8), 1, 8 * v151);
                      v174[2] = v152;
                      if (!v152)
                      {
                        log_OutPublic(*(void *)(*v6 + 32), v6[23], 24048, 0, v153, v154, v155, v156, v169);
                        *((_WORD *)v174 + 6) = 0;
                        goto LABEL_129;
                      }
                      if (*((_WORD *)v174 + 6))
                      {
                        unint64_t v157 = 0;
                        unsigned int v158 = v181;
                        do
                        {
                          __int16 v159 = *(_WORD *)(*(void *)v180 + v158);
                          LODWORD(v181) = v158 + 2;
                          unsigned __int16 v160 = v159 + 1;
                          *(void *)(v150[2] + 8 * v157) = heap_Calloc(*(void **)(*v6 + 8), 1, (unsigned __int16)(v159 + 1));
                          uint64_t v24 = *(unsigned char **)(v150[2] + 8 * v157);
                          if (!v24) {
                            goto LABEL_127;
                          }
                          unsigned int v179 = v160;
                          uint64_t v29 = ssftriff_reader_ReadStringZ(v7, *(uint64_t *)v180, HIDWORD(v181), v181, v24, &v179);
                          int v42 = 1;
                          if ((v29 & 0x80000000) != 0 || v179 != v160) {
                            goto LABEL_104;
                          }
                          unsigned int v158 = v181 + v160;
                          LODWORD(v181) = v158;
                          ++v157;
                          uint64_t v150 = v174;
                        }
                        while (v157 < *((unsigned __int16 *)v174 + 6));
                      }
                    }
                    uint64_t v143 = v172 + 1;
                    uint64_t v142 = *(void *)(v22 + 24);
                    uint64_t v21 = v178;
                    if (v172 + 1 >= (unint64_t)*(unsigned __int16 *)(v142 + 16)) {
                      goto LABEL_12;
                    }
                  }
                }
              }
            }
          }
        }
LABEL_12:
        uint64_t v29 = ssftriff_reader_CloseChunk(v7);
        if ((v29 & 0x80000000) != 0) {
          goto LABEL_95;
        }
        unsigned int v30 = *(_DWORD *)v22;
      }
      if (v30 <= 5 && ((1 << v30) & 0x2D) != 0)
      {
        uint64_t v36 = heap_Calloc(*(void **)(*v6 + 8), 1, 72);
        *(void *)(v22 + 8) = v36;
        if (!v36) {
          goto LABEL_102;
        }
        unsigned int v30 = *(_DWORD *)v22;
      }
      if (v30 <= 5 && ((1 << v30) & 0x36) != 0)
      {
        uint64_t v37 = heap_Calloc(*(void **)(*v6 + 8), 1, 64);
        *(void *)(v22 + 16) = v37;
        if (!v37)
        {
LABEL_102:
          log_OutPublic(*(void *)(*v6 + 32), v6[23], 24048, 0, v32, v25, v26, v27, v169);
          uint64_t v134 = FEDATA_ERROR(10);
          goto LABEL_103;
        }
        unsigned int v30 = *(_DWORD *)v22;
      }
      if (v30 <= 5 && ((1 << v30) & 0x2D) != 0)
      {
        Chunint k = ssftriff_reader_FindChunk(v7, "TDAT", 1, (unsigned int *)&v181 + 1, v180);
        if ((Chunk & 0x80000000) != 0) {
          goto LABEL_94;
        }
        LODWORD(v181) = 0;
        uint64_t v38 = *(_WORD **)v180;
        *(void *)(v22 + 40) = *(void *)v180;
        LOWORD(v38) = *v38;
        LODWORD(v181) = 2;
        unsigned __int16 v39 = (_WORD)v38 + 1;
        uint64_t v40 = (unsigned char *)heap_Calloc(*(void **)(*v6 + 8), 1, (unsigned __int16)((_WORD)v38 + 1));
        **(void **)(v22 + 8) = v40;
        if (!v40) {
          goto LABEL_127;
        }
        unsigned int v179 = v39;
        uint64_t v29 = ssftriff_reader_ReadStringZ(v7, *(uint64_t *)v180, HIDWORD(v181), v181, v40, &v179);
        int v42 = 1;
        if ((v29 & 0x80000000) != 0 || v179 != v39) {
          goto LABEL_104;
        }
        unsigned int v43 = v181 + v39;
        LODWORD(v181) = v43;
        uint64_t v44 = *(void *)v180;
        *(_WORD *)(*(void *)(v22 + 8) + 8) = *(_WORD *)(*(void *)v180 + v43);
        LODWORD(v181) = v43 + 2;
        *(_WORD *)(*(void *)(v22 + 8) + 12) = *(_WORD *)(v44 + v43 + 2);
        LODWORD(v181) = v43 + 4;
        int v45 = *(_DWORD *)(v44 + v43 + 4);
        LODWORD(v181) = v43 + 8;
        int v46 = *(_DWORD *)(v44 + v43 + 8);
        uint64_t v47 = v43 + 12;
        uint64_t v48 = *(void *)(v22 + 8);
        *(_DWORD *)(v48 + 16) = v47;
        *(void *)(v48 + 24) = v44 + v47;
        LODWORD(v181) = v45 + v47;
        uint64_t v49 = (v45 + v47 + *(_DWORD *)(v44 + (v45 + v47)) + 4);
        *(_DWORD *)(v48 + 40) = v49;
        *(void *)(v48 + 32) = v44 + v49;
        LODWORD(v181) = v49 + v46;
        if (*(_WORD *)(v48 + 8))
        {
          uint64_t v50 = heap_Calloc(*(void **)(*v6 + 8), 1, 32 * *(unsigned __int16 *)(v48 + 8));
          uint64_t v48 = *(void *)(v22 + 8);
          *(void *)(v48 + 48) = v50;
          if (!v50) {
            goto LABEL_131;
          }
          if (*(_WORD *)(v48 + 8))
          {
            uint64_t v51 = 0;
            unint64_t v52 = 0;
            while (1)
            {
              uint64_t v53 = *(void *)(v48 + 48) + v51;
              uint64_t v54 = *(void *)v180;
              int v55 = *(unsigned __int16 *)(*(void *)v180 + v181);
              LODWORD(v181) = v181 + 2;
              *(_DWORD *)uint64_t v53 = v55;
              *(_WORD *)(v53 + 4) = *(_WORD *)(v54 + v181);
              LODWORD(v181) = v181 + 2;
              *(_WORD *)(v53 + 6) = *(_WORD *)(*(void *)v180 + v181);
              LODWORD(v181) = v181 + 2;
              LODWORD(v54) = *(unsigned __int16 *)(*(void *)v180 + v181);
              *(_WORD *)(v53 + 24) = v54;
              LODWORD(v181) = v181 + 2;
              *(_WORD *)(v53 + 26) = *(_WORD *)(*(void *)v180 + v181);
              LODWORD(v181) = v181 + 2;
              *(_WORD *)(v53 + 28) = *(_WORD *)(*(void *)v180 + v181);
              LODWORD(v181) = v181 + 2;
              *(void *)(v53 + 8) = 0;
              if (v54)
              {
                uint64_t v56 = heap_Calloc(*(void **)(*v6 + 8), 1, 56);
                int v57 = (char *)v56;
                *(void *)(v53 + 8) = v56;
                if (!v56) {
                  goto LABEL_133;
                }
                *(void *)uint64_t v56 = &StaticIntPointers;
                *(unsigned char *)(v56 + 24) = 0;
                *(void *)(v56 + 16) = 0;
                *(void *)(v56 + 40) = 0;
                *(void *)(v56 + 48) = 0;
                *(void *)(v56 + 32) = 0;
                uint64_t FunctionDataFromBinaryFile = FEData_readFunctionDataFromBinaryFile(v6, v7, *v6, v56, *(uint64_t *)v180, (unsigned int *)&v181, HIDWORD(v181));
                if ((FunctionDataFromBinaryFile & 0x80000000) != 0) {
                  break;
                }
              }
              *(void *)(v53 + 16) = 0;
              if (*(_WORD *)(v53 + 26))
              {
                uint64_t v59 = heap_Calloc(*(void **)(*v6 + 8), 1, 56);
                int v57 = (char *)v59;
                *(void *)(v53 + 16) = v59;
                if (!v59)
                {
LABEL_133:
                  uint64_t v161 = *(void *)(*v6 + 32);
                  uint64_t v162 = v6[23];
                  goto LABEL_128;
                }
                *(void *)uint64_t v59 = &StaticIntPointers;
                *(unsigned char *)(v59 + 24) = 0;
                *(void *)(v59 + 16) = 0;
                *(void *)(v59 + 40) = 0;
                *(void *)(v59 + 48) = 0;
                *(void *)(v59 + 32) = 0;
                uint64_t FunctionDataFromBinaryFile = FEData_readFunctionDataFromBinaryFile(v6, v7, *v6, v59, *(uint64_t *)v180, (unsigned int *)&v181, HIDWORD(v181));
                if ((FunctionDataFromBinaryFile & 0x80000000) != 0) {
                  break;
                }
              }
              ++v52;
              uint64_t v48 = *(void *)(v22 + 8);
              v51 += 32;
              if (v52 >= *(unsigned __int16 *)(v48 + 8)) {
                goto LABEL_39;
              }
            }
            uint64_t v29 = FunctionDataFromBinaryFile;
            int v42 = 1;
            uint64_t v21 = v178;
            goto LABEL_96;
          }
        }
LABEL_39:
        uint64_t v60 = *(unsigned __int16 *)(v48 + 12);
        uint64_t v21 = v178;
        if (v60)
        {
          uint64_t v61 = heap_Calloc(*(void **)(*v6 + 8), 1, 16 * v60);
          uint64_t v62 = *(void *)(v22 + 8);
          *(void *)(v62 + 64) = v61;
          if (!v61) {
            goto LABEL_127;
          }
          if (*(_WORD *)(v62 + 12))
          {
            uint64_t v63 = 0;
            unint64_t v64 = 0;
            do
            {
              uint64_t v65 = *(void *)(v62 + 64);
              if (v176 == 1)
              {
                *(_DWORD *)(v65 + v63 + 4) = *(_DWORD *)(*(void *)v180 + v181);
                unsigned int v66 = v181 + 4;
                LODWORD(v181) = v181 + 4;
                uint64_t v67 = *(void *)v180;
              }
              else
              {
                uint64_t v67 = *(void *)v180;
                int v68 = *(unsigned __int16 *)(*(void *)v180 + v181);
                LODWORD(v181) = v181 + 2;
                *(_DWORD *)(v65 + v63 + 4) = v68;
                unsigned int v66 = v181;
              }
              uint64_t v69 = v65 + v63;
              *(_WORD *)(v69 + 8) = *(_WORD *)(v67 + v66);
              LODWORD(v181) = v181 + 2;
              *(_WORD *)(v69 + 10) = *(_WORD *)(*(void *)v180 + v181);
              LODWORD(v181) = v181 + 2;
              *(_WORD *)uint64_t v69 = *(_WORD *)(*(void *)v180 + v181);
              int v70 = v181;
              LODWORD(v181) = v181 + 2;
              int v71 = *(unsigned __int16 *)(*(void *)v180 + v181);
              LODWORD(v181) = v70 + 4;
              *(_DWORD *)(v69 + 12) = v71;
              ++v64;
              uint64_t v62 = *(void *)(v22 + 8);
              v63 += 16;
            }
            while (v64 < *(unsigned __int16 *)(v62 + 12));
          }
        }
        uint64_t v72 = ssftriff_reader_DetachChunkData(v7, (uint64_t *)(v22 + 32), v180, v41, (uint64_t)v24, v25, v26, v27);
        if ((v72 & 0x80000000) != 0)
        {
          uint64_t v29 = v72;
          int v42 = 1;
          goto LABEL_96;
        }
        uint64_t v73 = *(void *)v180;
        *(void *)(v22 + 40) = *(void *)v180;
        uint64_t v74 = *(void *)(v22 + 8);
        uint64_t v75 = v73 + *(unsigned int *)(v74 + 16);
        uint64_t v76 = v73 + *(unsigned int *)(v74 + 40);
        *(void *)(v74 + 24) = v75;
        *(void *)(v74 + 32) = v76;
        uint64_t v29 = ssftriff_reader_CloseChunk(v7);
        if ((v29 & 0x80000000) != 0) {
          goto LABEL_95;
        }
        unsigned int v30 = *(_DWORD *)v22;
      }
      if (v30 > 5 || ((1 << v30) & 0x36) == 0) {
        goto LABEL_100;
      }
      Chunint k = ssftriff_reader_FindChunk(v7, "DDAT", 1, (unsigned int *)&v181 + 1, v180);
      if ((Chunk & 0x80000000) != 0) {
        goto LABEL_94;
      }
      LODWORD(v181) = 0;
      __int16 v77 = **(_WORD **)v180;
      LODWORD(v181) = 2;
      unsigned __int16 v78 = v77 + 1;
      uint64_t v79 = (unsigned char *)heap_Calloc(*(void **)(*v6 + 8), 1, (unsigned __int16)(v77 + 1));
      **(void **)(v22 + 16) = v79;
      if (!v79) {
        goto LABEL_127;
      }
      unsigned int v179 = v78;
      uint64_t v29 = ssftriff_reader_ReadStringZ(v7, *(uint64_t *)v180, HIDWORD(v181), v181, v79, &v179);
      int v42 = 1;
      if ((v29 & 0x80000000) == 0 && v179 == v78)
      {
        unsigned int v80 = v181 + v78;
        LODWORD(v181) = v80;
        uint64_t v81 = *(void *)v180;
        int v82 = *(unsigned __int16 *)(*(void *)v180 + v80);
        LODWORD(v181) = v80 + 2;
        uint64_t v83 = *(void *)(v22 + 16);
        *(_DWORD *)(v83 + 8) = v82;
        *(_WORD *)(v83 + 24) = *(_WORD *)(v81 + v80 + 2);
        LODWORD(v181) = v80 + 4;
        *(_WORD *)(*(void *)(v22 + 16) + 50) = *(_WORD *)(v81 + v80 + 4);
        LODWORD(v181) = v80 + 6;
        uint64_t v84 = *(void *)(v22 + 16);
        *(void *)(v84 + 56) = 0;
        if (*(_WORD *)(v84 + 50))
        {
          uint64_t v85 = heap_Calloc(*(void **)(*v6 + 8), 1, 8 * *(unsigned __int16 *)(v84 + 50));
          uint64_t v84 = *(void *)(v22 + 16);
          *(void *)(v84 + 56) = v85;
          if (v85)
          {
            if (*(_WORD *)(v84 + 50))
            {
              unint64_t v86 = 0;
              unsigned int v87 = v181;
              while (1)
              {
                __int16 v88 = *(_WORD *)(*(void *)v180 + v87);
                LODWORD(v181) = v87 + 2;
                unsigned __int16 v89 = v88 + 1;
                *(void *)(*(void *)(*(void *)(v22 + 16) + 56) + 8 * v86) = heap_Calloc(*(void **)(*v6 + 8), 1, (unsigned __int16)(v88 + 1));
                uint64_t v24 = *(unsigned char **)(*(void *)(*(void *)(v22 + 16) + 56) + 8 * v86);
                if (!v24) {
                  goto LABEL_127;
                }
                int v90 = v89;
                unsigned int v179 = v89;
                uint64_t v29 = ssftriff_reader_ReadStringZ(v7, *(uint64_t *)v180, HIDWORD(v181), v181, v24, &v179);
                int v42 = 1;
                if ((v29 & 0x80000000) != 0 || v179 != v90) {
                  goto LABEL_104;
                }
                unsigned int v87 = v181 + v90;
                LODWORD(v181) = v181 + v90;
                ++v86;
                uint64_t v84 = *(void *)(v22 + 16);
                if (v86 >= *(unsigned __int16 *)(v84 + 50)) {
                  goto LABEL_64;
                }
              }
            }
            goto LABEL_64;
          }
        }
        else
        {
LABEL_64:
          if (!*(_WORD *)(v84 + 24)) {
            goto LABEL_75;
          }
          uint64_t v91 = heap_Calloc(*(void **)(*v6 + 8), 1, 72 * *(unsigned __int16 *)(v84 + 24));
          uint64_t v84 = *(void *)(v22 + 16);
          *(void *)(v84 + 16) = v91;
          if (v91)
          {
            if (*(_WORD *)(v84 + 24))
            {
              unint64_t v92 = 0;
              uint64_t v93 = 40;
              while (1)
              {
                uint64_t v94 = *(void *)(v84 + 16);
                size_t v95 = *(unsigned __int16 *)(*(void *)v180 + v181);
                LODWORD(v181) = v181 + 2;
                uint64_t v173 = v94;
                uint64_t v96 = v94 + v93;
                *(_WORD *)(v94 + v93 + 16) = v95;
                unsigned int v97 = (void *)heap_Calloc(*(void **)(*v6 + 8), 1, v95 + 1);
                *(void *)(v96 + 8) = v97;
                if (!v97) {
                  break;
                }
                memcpy(v97, (const void *)(*(void *)v180 + v181), v95);
                *(unsigned char *)(*(void *)(v96 + 8) + v95) = 0;
                LODWORD(v181) = v181 + *(unsigned __int16 *)(v96 + 16);
                *(_WORD *)(v96 - 40) = *(_WORD *)(*(void *)v180 + v181);
                LODWORD(v181) = v181 + 2;
                *(_WORD *)(v96 - 38) = *(_WORD *)(*(void *)v180 + v181);
                int v98 = v181;
                LODWORD(v181) = v181 + 2;
                uint64_t v99 = *(void *)v180;
                int v100 = *(unsigned __int16 *)(*(void *)v180 + v181);
                LODWORD(v181) = v98 + 4;
                *(_DWORD *)(v96 + 20) = v100;
                int v101 = *(unsigned __int16 *)(v99 + v181);
                LODWORD(v181) = v181 + 2;
                *(_DWORD *)(v96 + 24) = v101;
                int v102 = *(unsigned __int16 *)(v99 + v181);
                LODWORD(v181) = v181 + 2;
                *(_DWORD *)(v96 - 32) = v102;
                if (v102 == 1)
                {
                  uint64_t v103 = v173 + v93;
                  *(_WORD *)(v103 - 36) = *(_WORD *)(v99 + v181);
                  LODWORD(v181) = v181 + 2;
                  *(_WORD *)(v103 - 28) = *(_WORD *)(*(void *)v180 + v181);
                  LODWORD(v181) = v181 + 2;
                }
                if (!v177)
                {
                  int v104 = *(unsigned __int16 *)(*(void *)v180 + v181);
                  *(_WORD *)(v173 + v93) = v104;
                  int v105 = v181;
                  LODWORD(v181) = v181 + 2;
                  if (v104) {
                    LODWORD(v181) = v105 + 4 * (unsigned __int16)(v104 - 1) + 6;
                  }
                }
                ++v92;
                uint64_t v84 = *(void *)(v22 + 16);
                v93 += 72;
                if (v92 >= *(unsigned __int16 *)(v84 + 24)) {
                  goto LABEL_75;
                }
              }
            }
            else
            {
LABEL_75:
              int v106 = v181;
              *(_WORD *)(v84 + 48) = *(_WORD *)(*(void *)v180 + v181);
              LODWORD(v181) = v106 + 2;
              uint64_t v107 = *(void *)(v22 + 16);
              uint64_t v108 = *(unsigned __int16 *)(v107 + 48);
              if (!*(_WORD *)(v107 + 48)) {
                goto LABEL_93;
              }
              *(void *)(v107 + 40) = 0;
              uint64_t v109 = heap_Calloc(*(void **)(v6[3] + 8), 1, 16 * v108);
              uint64_t v110 = *(void *)(v22 + 16);
              *(void *)(v110 + 40) = v109;
              if (v109)
              {
                if (!*(_WORD *)(v110 + 48))
                {
LABEL_93:
                  uint64_t v134 = ssftriff_reader_CloseChunk(v7);
LABEL_103:
                  uint64_t v29 = v134;
                  int v42 = 0;
                  goto LABEL_104;
                }
                uint64_t v111 = 0;
                while (1)
                {
                  uint64_t v112 = *(unsigned __int16 *)(*(void *)v180 + v181);
                  uint64_t v171 = v111;
                  uint64_t v113 = *(void *)(v110 + 40) + 16 * v111;
                  *(_WORD *)(v113 + 8) = v112;
                  unsigned __int16 v114 = (_WORD *)(v113 + 8);
                  LODWORD(v181) = v181 + 2;
                  *(void *)uint64_t v113 = 0;
                  uint64_t v115 = heap_Calloc(*(void **)(*v6 + 8), 1, 24 * v112);
                  *(void *)uint64_t v113 = v115;
                  if (!v115) {
                    break;
                  }
                  if (*v114)
                  {
                    uint64_t v116 = 0;
                    for (unint64_t i = 0; i < (unsigned __int16)*v114; ++i)
                    {
                      *(void *)(*(void *)v113 + v116) = 0;
                      unsigned __int16 v118 = (_WORD *)heap_Calloc(*(void **)(*v6 + 8), 1, 12);
                      *(void *)(*(void *)v113 + v116) = v118;
                      if (!v118) {
                        goto LABEL_127;
                      }
                      v118[1] = 0;
                      uint64_t v119 = *(void *)v180;
                      int v120 = v181;
                      if (v177)
                      {
                        __int16 v121 = *(unsigned __int8 *)(*(void *)v180 + v181);
                        LODWORD(v181) = v181 + 1;
                        unsigned int v122 = v181;
                        *unsigned __int16 v118 = v121;
                        __int16 v123 = *(unsigned __int8 *)(v119 + v122);
                        LODWORD(v181) = v120 + 2;
                        v118[2] = v123;
                      }
                      else
                      {
                        *unsigned __int16 v118 = *(_WORD *)(*(void *)v180 + v181);
                        int v124 = v181;
                        LODWORD(v181) = v181 + 2;
                        *(_WORD *)(*(void *)(*(void *)v113 + v116) + 4) = *(_WORD *)(*(void *)v180
                                                                                         + v181);
                        LODWORD(v181) = v124 + 4;
                        if (v175 == 1)
                        {
                          *(void *)(*(void *)v113 + v116 + 8) = 0;
                          uint64_t v125 = (_WORD *)heap_Calloc(*(void **)(*v6 + 8), 1, 2);
                          *(void *)(*(void *)v113 + v116 + 8) = v125;
                          if (!v125) {
                            goto LABEL_127;
                          }
                          *uint64_t v125 = *(_WORD *)(*(void *)v180 + v181);
                          int v126 = v181;
                          LODWORD(v181) = v181 + 2;
                          __int16 v127 = *(_WORD *)(*(void *)v180 + v181);
                          LODWORD(v181) = v126 + 4;
                          unsigned __int16 v128 = v127 + 1;
                          uint64_t v129 = (unsigned char *)heap_Calloc(*(void **)(*v6 + 8), 1, (unsigned __int16)(v127 + 1));
                          *(void *)(*(void *)v113 + v116 + 16) = v129;
                          if (!v129)
                          {
                            log_OutPublic(*(void *)(*v6 + 32), v6[23], 24048, 0, v130, v131, v132, v133, v169);
                            uint64_t v163 = 10;
                            goto LABEL_138;
                          }
                          unsigned int v179 = v128;
                          if ((ssftriff_reader_ReadStringZ(v7, *(uint64_t *)v180, HIDWORD(v181), v181, v129, &v179) & 0x80000000) != 0
                            || v179 != v128)
                          {
                            uint64_t v163 = 0;
LABEL_138:
                            uint64_t v29 = FEDATA_ERROR(v163);
                            uint64_t v21 = v178;
                            if ((v29 & 0x80000000) == 0) {
                              goto LABEL_100;
                            }
                            goto LABEL_139;
                          }
                          LODWORD(v181) = v181 + v128;
                          unsigned __int16 v114 = (_WORD *)(v113 + 8);
                        }
                      }
                      v116 += 24;
                    }
                  }
                  uint64_t v111 = v171 + 1;
                  uint64_t v110 = *(void *)(v22 + 16);
                  if (v171 + 1 >= (unint64_t)*(unsigned __int16 *)(v110 + 48)) {
                    goto LABEL_93;
                  }
                }
              }
            }
LABEL_127:
            uint64_t v161 = *(void *)(*v6 + 32);
            uint64_t v162 = v6[23];
            int v57 = 0;
LABEL_128:
            log_OutPublic(v161, v162, 24048, v57, (uint64_t)v24, v25, v26, v27, v169);
LABEL_129:
            uint64_t v29 = FEDATA_ERROR(10);
            int v42 = 1;
            goto LABEL_104;
          }
        }
LABEL_131:
        log_OutPublic(*(void *)(*v6 + 32), v6[23], 24048, 0, (uint64_t)v24, v25, v26, v27, v169);
        uint64_t v29 = FEDATA_ERROR(10);
      }
LABEL_104:
      uint64_t v21 = v178;
      if ((v29 & 0x80000000) != 0) {
        goto LABEL_96;
      }
LABEL_97:
      if (v42) {
        ssftriff_reader_CloseChunk(v7);
      }
      if ((v29 & 0x80000000) != 0)
      {
LABEL_139:
        *(void *)(*(void *)(*(void *)(a4 + 32) + 8) + 8 * v20) = 0;
        log_OutPublic(*(void *)(*v6 + 32), v6[23], 24044, 0, (uint64_t)v24, v25, v26, v27, v169);
        goto LABEL_142;
      }
LABEL_100:
      log_OutText(*(void *)(*v6 + 32), v6[23], 4, 0, (uint64_t)"loaded data block %d", v25, v26, v27, v20);
      unsigned int v20 = (unsigned __int16)v20 + 1;
      if (v20 >= *v21) {
        return v29;
      }
    }
  }
  return 0;
}

uint64_t readDataBlockFromFile_ObjcClose(_WORD *a1, int a2, uint64_t a3)
{
  uint64_t v3 = *(unsigned __int16 **)(a3 + 32);
  uint64_t v58 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v58);
  uint64_t v11 = inited;
  if ((inited & 0x80000000) == 0)
  {
    if (v3)
    {
      uint64_t v12 = *((void *)v3 + 1);
      if (v12)
      {
        unsigned int v13 = *v3;
        if (*v3)
        {
          unsigned int v56 = inited;
          uint64_t v14 = 0;
          int v55 = v3;
          while (1)
          {
            uint64_t v15 = *(void *)(*((void *)v3 + 1) + 8 * v14);
            if (v15)
            {
              uint64_t v16 = *(void **)(v15 + 32);
              if (v16)
              {
                unsigned int v56 = ssftriff_reader_ReleaseChunkData(v16, v12, v5, v6, v7, v8, v9, v10);
                if ((v56 & 0x80000000) != 0) {
                  return v56;
                }
                *(void *)(v15 + 32) = 0;
                *(void *)(v15 + 40) = 0;
              }
              int v57 = (void **)(v15 + 32);
              uint64_t v17 = v58;
              uint64_t v19 = *(void *)(v15 + 8);
              uint64_t v18 = *(void *)(v15 + 16);
              uint64_t v20 = *(void *)(v15 + 24);
              if (v19)
              {
                if (*(_DWORD *)v15 <= 5u && ((1 << *(_DWORD *)v15) & 0x2D) != 0)
                {
                  heap_Free(*(void **)(v58 + 8), *(void *)v19);
                  *(void *)uint64_t v19 = 0;
                  uint64_t v22 = *(void *)(v19 + 48);
                  if (v22)
                  {
                    if (*(_WORD *)(v19 + 8))
                    {
                      uint64_t v23 = 0;
                      unint64_t v24 = 0;
                      do
                      {
                        uint64_t v25 = *(void *)(v19 + 48) + v23;
                        uint64_t v26 = *(void *)(v25 + 8);
                        if (v26)
                        {
                          FEData_freeEntry((void *)v17, v26, 1);
                          heap_Free(*(void **)(v17 + 8), *(void *)(v25 + 8));
                          *(void *)(v25 + 8) = 0;
                        }
                        uint64_t v27 = *(void *)(v25 + 16);
                        if (v27)
                        {
                          FEData_freeEntry((void *)v17, v27, 1);
                          heap_Free(*(void **)(v17 + 8), *(void *)(v25 + 16));
                          *(void *)(v25 + 16) = 0;
                        }
                        ++v24;
                        v23 += 32;
                      }
                      while (v24 < *(unsigned __int16 *)(v19 + 8));
                      uint64_t v22 = *(void *)(v19 + 48);
                      uint64_t v3 = v55;
                    }
                    heap_Free(*(void **)(v17 + 8), v22);
                    *(void *)(v19 + 48) = 0;
                  }
                  uint64_t v28 = *(void *)(v19 + 64);
                  if (v28)
                  {
                    heap_Free(*(void **)(v17 + 8), v28);
                    *(void *)(v19 + 64) = 0;
                  }
                  heap_Free(*(void **)(v17 + 8), *(void *)(v15 + 8));
                  *(void *)(v15 + 8) = 0;
                }
              }
              if (v18)
              {
                if (*(_DWORD *)v15 <= 5u && ((1 << *(_DWORD *)v15) & 0x36) != 0)
                {
                  if (*(void *)v18)
                  {
                    heap_Free(*(void **)(v17 + 8), *(void *)v18);
                    *(void *)uint64_t v18 = 0;
                  }
                  uint64_t v30 = *(void *)(v18 + 56);
                  if (v30)
                  {
                    if (*(_WORD *)(v18 + 50))
                    {
                      unint64_t v31 = 0;
                      do
                      {
                        heap_Free(*(void **)(v17 + 8), *(void *)(*(void *)(v18 + 56) + 8 * v31));
                        *(void *)(*(void *)(v18 + 56) + 8 * v31++) = 0;
                      }
                      while (v31 < *(unsigned __int16 *)(v18 + 50));
                      uint64_t v30 = *(void *)(v18 + 56);
                    }
                    heap_Free(*(void **)(v17 + 8), v30);
                    *(void *)(v18 + 56) = 0;
                  }
                  if (*(void *)(v18 + 16))
                  {
                    if (*(_WORD *)(v18 + 24))
                    {
                      uint64_t v32 = 0;
                      unint64_t v33 = 0;
                      do
                      {
                        uint64_t v34 = *(void *)(v18 + 16) + v32;
                        heap_Free(*(void **)(v17 + 8), *(void *)(v34 + 48));
                        *(void *)(v34 + 48) = 0;
                        uint64_t v35 = *(void *)(v34 + 16);
                        if (v35)
                        {
                          heap_Free(*(void **)(v17 + 8), v35);
                          *(void *)(v34 + 16) = 0;
                        }
                        ++v33;
                        v32 += 72;
                      }
                      while (v33 < *(unsigned __int16 *)(v18 + 24));
                    }
                    uint64_t v36 = *(void *)(v18 + 40);
                    uint64_t v3 = v55;
                    if (v36)
                    {
                      unsigned __int16 v37 = *(_WORD *)(v18 + 48);
                      if (v37)
                      {
                        for (unint64_t i = 0; i < v37; ++i)
                        {
                          uint64_t v39 = *(void *)(v18 + 40) + 16 * i;
                          uint64_t v40 = *(void *)v39;
                          if (*(void *)v39)
                          {
                            if (*(_WORD *)(v39 + 8))
                            {
                              uint64_t v41 = 0;
                              unint64_t v42 = 0;
                              do
                              {
                                heap_Free(*(void **)(v17 + 8), *(void *)(v40 + v41));
                                unsigned int v43 = (void *)(*(void *)v39 + v41);
                                *unsigned int v43 = 0;
                                heap_Free(*(void **)(v17 + 8), v43[1]);
                                uint64_t v44 = *(void *)v39 + v41;
                                *(void *)(v44 + 8) = 0;
                                heap_Free(*(void **)(v17 + 8), *(void *)(v44 + 16));
                                uint64_t v40 = *(void *)v39;
                                *(void *)(*(void *)v39 + v41 + 16) = 0;
                                ++v42;
                                v41 += 24;
                              }
                              while (v42 < *(unsigned __int16 *)(v39 + 8));
                            }
                            heap_Free(*(void **)(v17 + 8), v40);
                            *(void *)uint64_t v39 = 0;
                            unsigned __int16 v37 = *(_WORD *)(v18 + 48);
                          }
                        }
                        uint64_t v36 = *(void *)(v18 + 40);
                        uint64_t v3 = v55;
                      }
                      heap_Free(*(void **)(v17 + 8), v36);
                      *(void *)(v18 + 40) = 0;
                    }
                    heap_Free(*(void **)(v17 + 8), *(void *)(v18 + 16));
                    *(void *)(v18 + 16) = 0;
                  }
                  heap_Free(*(void **)(v17 + 8), *(void *)(v15 + 16));
                  *(void *)(v15 + 16) = 0;
                }
              }
              if (v20)
              {
                uint64_t v45 = *(void *)(v20 + 8);
                if (v45)
                {
                  unsigned __int16 v46 = *(_WORD *)(v20 + 16);
                  if (v46)
                  {
                    for (unint64_t j = 0; j < v46; ++j)
                    {
                      uint64_t v48 = *(void *)(v20 + 8);
                      uint64_t v49 = *(void *)(v48 + 8 * j);
                      if (v49)
                      {
                        if (*(void *)v49)
                        {
                          heap_Free(*(void **)(v17 + 8), *(void *)v49);
                          uint64_t v48 = *(void *)(v20 + 8);
                          **(void **)(v48 + 8 * j) = 0;
                          uint64_t v49 = *(void *)(v48 + 8 * j);
                        }
                        uint64_t v50 = *(void *)(v49 + 16);
                        if (v50)
                        {
                          if (*(_WORD *)(v49 + 12))
                          {
                            unint64_t v51 = 0;
                            do
                            {
                              uint64_t v52 = *(void *)(*(void *)(v49 + 16) + 8 * v51);
                              if (v52)
                              {
                                heap_Free(*(void **)(v17 + 8), v52);
                                *(void *)(*(void *)(*(void *)(*(void *)(v20 + 8) + 8 * j) + 16) + 8 * v51) = 0;
                                uint64_t v48 = *(void *)(v20 + 8);
                              }
                              ++v51;
                              uint64_t v49 = *(void *)(v48 + 8 * j);
                            }
                            while (v51 < *(unsigned __int16 *)(v49 + 12));
                            uint64_t v50 = *(void *)(v49 + 16);
                          }
                          heap_Free(*(void **)(v17 + 8), v50);
                          uint64_t v53 = *(void *)(v20 + 8);
                          *(void *)(*(void *)(v53 + 8 * j) + 16) = 0;
                          uint64_t v49 = *(void *)(v53 + 8 * j);
                        }
                        *(_WORD *)(v49 + 12) = 0;
                        heap_Free(*(void **)(v17 + 8), v49);
                        *(void *)(*(void *)(v20 + 8) + 8 * j) = 0;
                        unsigned __int16 v46 = *(_WORD *)(v20 + 16);
                      }
                    }
                    uint64_t v45 = *(void *)(v20 + 8);
                  }
                  heap_Free(*(void **)(v17 + 8), v45);
                  *(void *)(v20 + 8) = 0;
                }
                *(_WORD *)(v20 + 16) = 0;
                heap_Free(*(void **)(v17 + 8), v20);
              }
              if (*v57)
              {
                ssftriff_reader_ReleaseChunkData(*v57, v12, v5, v6, v7, v8, v9, v10);
                *int v57 = 0;
                *(void *)(v15 + 40) = 0;
              }
              heap_Free(*(void **)(v17 + 8), v15);
              unsigned int v13 = *v3;
            }
            if (++v14 >= (unint64_t)v13)
            {
              uint64_t v12 = *((void *)v3 + 1);
              uint64_t v11 = v56;
              break;
            }
          }
        }
        heap_Free(*(void **)(v58 + 8), v12);
        heap_Free(*(void **)(v58 + 8), (uint64_t)v3);
      }
    }
  }
  return v11;
}

uint64_t partialMatchFoundInBasicToken_NNTN(uint64_t result, __int16 *a2)
{
  uint64_t v16 = 0;
  if (result)
  {
    uint64_t v2 = (uint64_t *)result;
    uint64_t v3 = *(void *)(*(void *)(result + 264) + 16);
    for (unint64_t i = *(uint64_t **)(v3 + 80); (unint64_t)i < *(void *)(v3 + 88); ++i)
    {
      __s1 = 0;
      int v6 = LDOTreeNode_ComputeAbsoluteFrom(*i, (_DWORD *)&v16 + 1);
      if ((LH_ERROR_to_VERROR(v6) & 0x80000000) != 0) {
        break;
      }
      int v7 = LDOTreeNode_ComputeAbsoluteTo(*i, &v16);
      if ((LH_ERROR_to_VERROR(v7) & 0x80000000) != 0) {
        break;
      }
      int Type = LDOObject_GetType(*i, (uint64_t *)&__s1);
      if ((LH_ERROR_to_VERROR(Type) & 0x80000000) != 0) {
        break;
      }
      uint64_t v9 = __s1;
      if (!strcmp(__s1, "TOKEN_ALPHA")
        || !strcmp(v9, "TOKEN_DIGIT")
        || !strcmp(v9, "TOKEN_PUNCT")
        || !strcmp(v9, "TOKEN_WSPACE"))
      {
        uint64_t v13 = *a2;
        if (__PAIR64__((__int16)v16, SWORD2(v16)) != __PAIR64__(a2[1], v13))
        {
          if (SWORD2(v16) >= (int)v13)
          {
            __int16 v14 = a2[1];
          }
          else
          {
            __int16 v14 = a2[1];
            if ((int)v13 < (__int16)v16) {
              goto LABEL_20;
            }
          }
          if (SWORD2(v16) < v14 && v14 < (__int16)v16)
          {
LABEL_20:
            log_OutText(*(void *)(*v2 + 32), v2[23], 5, 0, (uint64_t)"Regex match %d,%d bisects basic token %d,%d", v10, v11, v12, v13);
            return 1;
          }
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t tokenizer_apply_regex_NNTN(uint64_t *a1, uint64_t a2, size_t **a3)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  int v6 = *(unsigned __int16 *)(a2 + 44);
  int v29 = 0;
  unsigned int v7 = nuance_pcre_exec((void *)a1[17], a1[18], *(void *)(a2 + 32), *(int **)a2, (char *)a1[38], *(unsigned __int16 *)(a2 + 42), v6, *(unsigned __int16 *)(a2 + 64), &v30, 100);
  __int16 v11 = v31;
  if (v31 > *(unsigned __int16 *)(a2 + 46)) {
    goto LABEL_13;
  }
  if ((v7 & 0x80000000) != 0)
  {
    uint64_t v12 = nuance_pcre_ErrorToLhError(v7);
    if (v12 >> 20 == 2213)
    {
      uint64_t v14 = v12;
      if ((v12 & 0x1FFF) == 0xA)
      {
        uint64_t v15 = 11002;
        goto LABEL_23;
      }
      if ((v12 & 0x1FFF) != 0x14)
      {
        uint64_t v15 = 11027;
LABEL_23:
        log_OutPublic(*(void *)(*a1 + 32), a1[23], v15, "%s%x%s%s", v13, v8, v9, v10, "lhError");
        return v14;
      }
      goto LABEL_13;
    }
    __int16 v11 = v31;
  }
  unsigned __int16 v16 = v30;
  uint64_t v17 = *(void *)(a2 + 16);
  uint64_t v18 = *(__int16 **)(v17 + 8);
  *uint64_t v18 = v30;
  v18[1] = v11;
  if (!(v16 | (unsigned __int16)v11)) {
    goto LABEL_13;
  }
  if (*(_DWORD *)(v17 + 44) != 1)
  {
    if (partialMatchFoundInBasicToken_NNTN((uint64_t)a1, v18) != 1) {
      goto LABEL_19;
    }
    log_OutText(*(void *)(*a1 + 32), a1[23], 5, 0, (uint64_t)"token %s invalidated.", v19, v20, v21, *(void *)(a2 + 24));
LABEL_13:
    char v22 = 1;
    goto LABEL_14;
  }
  log_OutText(*(void *)(*a1 + 32), a1[23], 5, 0, (uint64_t)"token %s already validated", v8, v9, v10, *(void *)(a2 + 24));
LABEL_19:
  *(void *)(**(void **)(a2 + 16) + 96) = *(void *)(a2 + 56);
  uint64_t v27 = sortExpansionNNTN(a1, a2);
  if ((v27 & 0x80000000) != 0) {
    return v27;
  }
  char v22 = 0;
  *(_DWORD *)(a2 + 72) = 1;
LABEL_14:
  int v23 = LDOTreeNode_ComputeAbsoluteTo(**a3, &v29);
  uint64_t v24 = LH_ERROR_to_VERROR(v23);
  uint64_t v14 = v24;
  if ((v22 & 1) == 0 && (v24 & 0x80000000) == 0)
  {
    do
    {
      if ((unsigned __int16)v29 >= *(__int16 *)(*(void *)(*(void *)(a2 + 16) + 8) + 2)) {
        break;
      }
      uint64_t v25 = (*a3)++;
      int v26 = LDOTreeNode_ComputeAbsoluteTo(v25[1], &v29);
      uint64_t v14 = LH_ERROR_to_VERROR(v26);
    }
    while ((v14 & 0x80000000) == 0);
  }
  return v14;
}

uint64_t tokenizer_NNTN_ObjOpen(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"tokenizer_NNTN : ObjOpen Begin", a6, a7, a8, v47);
  uint64_t v9 = heap_Calloc(*(void **)(*a1 + 8), 1, 8);
  if (v9)
  {
    uint64_t v14 = v9;
    a1[21] = v9;
    uint64_t v15 = heap_Calloc(*(void **)(*a1 + 8), 1, 80);
    *(void *)uint64_t v14 = v15;
    uint64_t v20 = *a1;
    if (v15)
    {
      uint64_t v21 = heap_Calloc(*(void **)(v20 + 8), 1, 40);
      **(void **)uint64_t v14 = v21;
      uint64_t v20 = *a1;
      if (v21)
      {
        uint64_t v22 = heap_Calloc(*(void **)(v20 + 8), 1, 64);
        *(void *)(*(void *)v14 + 16) = v22;
        uint64_t v20 = *a1;
        if (v22)
        {
          int v23 = (_DWORD *)heap_Calloc(*(void **)(v20 + 8), 1, 4);
          *(void *)(*(void *)(*(void *)v14 + 16) + 8) = v23;
          if (v23)
          {
            *int v23 = 0;
            uint64_t v24 = heap_Calloc(*(void **)(*a1 + 8), 1, 112);
            uint64_t v25 = *(void ***)v14;
            uint64_t v26 = *(void *)(*(void *)v14 + 16);
            *(void *)uint64_t v26 = v24;
            if (v24)
            {
              *(void *)(v24 + 96) = 0;
              *(_WORD *)(v26 + 40) = 0;
              *(_DWORD *)(v26 + 48) = 0;
              *(void *)(v26 + 16) = 0;
              *(void *)(v26 + 24) = 0;
              uint64_t v27 = *v25;
              *v27 |= 4uLL;
              v27[3] = v26;
              uint64_t v50 = 0;
              log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"tokenizer_NNTN : InitCheckFunctions Begin", v17, v18, v19, v48);
              uint64_t Map = FEFunctionMap_GetMap(a1, &v50);
              if ((Map & 0x80000000) != 0)
              {
                uint64_t v38 = Map;
              }
              else
              {
                for (uint64_t i = 0; i != 128; i += 16)
                {
                  uint64_t v30 = ssftmap_Insert(v50, *(uint64_t *)((char *)&off_26C21F310 + i), *(uint64_t *)((char *)&off_26C21F310 + i + 8));
                  if ((v30 & 0x80000000) != 0)
                  {
                    uint64_t v38 = v30;
                    log_OutPublic(*(void *)(*a1 + 32), a1[23], 21011, 0, v31, v32, v33, v34, v49);
                    goto LABEL_22;
                  }
                }
                uint64_t v38 = FEFunctionMap_AddFunctionMap((uint64_t)a1, 0, v50);
                if ((v38 & 0x80000000) == 0) {
                  goto LABEL_23;
                }
              }
LABEL_22:
              ssftmap_ObjClose(v50);
LABEL_23:
              log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"tokenizer_NNTN : InitCheckFunctions End (%x)", v35, v36, v37, v38);
              if ((v38 & 0x80000000) == 0) {
                goto LABEL_19;
              }
              goto LABEL_18;
            }
          }
          uint64_t v20 = *a1;
        }
      }
    }
    log_OutPublic(*(void *)(v20 + 32), a1[23], 24048, 0, v16, v17, v18, v19, v48);
    uint64_t v38 = NNTNERROR(10);
    if ((v38 & 0x80000000) == 0)
    {
LABEL_19:
      log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"tokenizer_NNTN : ObjOpen End (%x)", v44, v45, v46, v38);
      return v38;
    }
LABEL_18:
    tokenizer_loc_ObjClose(a1, v40, v41, v42, v43, v44, v45, v46);
    goto LABEL_19;
  }
  log_OutPublic(*(void *)(*a1 + 32), a1[23], 24048, 0, v10, v11, v12, v13, v48);
  return NNTNERROR(10);
}

uint64_t tokenizer_loc_ObjClose(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1[21];
  log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"tokenizer_NNTN : loc ObjClose Begin", a6, a7, a8, v16);
  uint64_t v10 = *(uint64_t **)v9;
  if (*(void *)v9)
  {
    uint64_t v11 = (uint64_t *)v10[2];
    if (v11)
    {
      if (v11[1])
      {
        heap_Free(*(void **)(*a1 + 8), v11[1]);
        uint64_t v11 = *(uint64_t **)(*(void *)v9 + 16);
        v11[1] = 0;
      }
      if (*v11)
      {
        heap_Free(*(void **)(*a1 + 8), *v11);
        uint64_t v11 = *(uint64_t **)(*(void *)v9 + 16);
        *uint64_t v11 = 0;
      }
      heap_Free(*(void **)(*a1 + 8), (uint64_t)v11);
      uint64_t v10 = *(uint64_t **)v9;
      *(void *)(*(void *)v9 + 16) = 0;
    }
    if (*v10)
    {
      heap_Free(*(void **)(*a1 + 8), *v10);
      uint64_t v10 = *(uint64_t **)v9;
      **(void **)uint64_t v9 = 0;
    }
    heap_Free(*(void **)(*a1 + 8), (uint64_t)v10);
    *(void *)uint64_t v9 = 0;
  }
  heap_Free(*(void **)(*a1 + 8), v9);
  a1[21] = 0;
  return log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"tokenizer_NNTN : loc ObjClose End (%x)", v12, v13, v14, 0);
}

uint64_t tokenizer_NNTN_ObjClose(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[21])
  {
    log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"tokenizer_NNTN : ObjClose Begin", a6, a7, a8, v20);
    tokenizer_loc_ObjClose(a1, v9, v10, v11, v12, v13, v14, v15);
    log_OutText(*(void *)(*a1 + 32), a1[23], 4, 0, (uint64_t)"tokenizer_NNTN : ObjOpen End (%x)", v16, v17, v18, 0);
    return 0;
  }
  else
  {
    return NNTNERROR(8);
  }
}

uint64_t fe_nnws_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2588942337;
  }
  uint64_t result = 0;
  *a2 = &IFeNNWS;
  return result;
}

uint64_t fe_nnws_ClassOpen(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0;
  if (!a3) {
    return 2588942343;
  }
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *(void *)a3 = a1;
    *(void *)(a3 + 8) = a2;
  }
  return result;
}

uint64_t fe_nnws_ClassClose()
{
  return 0;
}

uint64_t fe_nnws_ObjOpen(_WORD *a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v60 = *MEMORY[0x263EF8340];
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  uint64_t v55 = 0;
  uint64_t v56 = 0;
  uint64_t v5 = 2588942343;
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  memset(v59, 0, sizeof(v59));
  if (!a5) {
    return v5;
  }
  uint64_t v54 = 0;
  long long v52 = 0uLL;
  long long v53 = 0uLL;
  uint64_t v51 = 0;
  *(void *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v57);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t inited = InitRsrcFunction(a3, a4, &v58);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t v12 = heap_Calloc(*(void **)(v58 + 8), 1, 208);
  if (!v12)
  {
    log_OutPublic(*(void *)(v58 + 32), (uint64_t)"FE_NNWS", 75000, 0, v13, v14, v15, v16, v47);
    uint64_t v5 = 2588942346;
LABEL_25:
    fe_nnws_ObjClose(*(uint64_t **)a5, *(void *)(a5 + 8));
    *(void *)a5 = 0;
    *(_DWORD *)(a5 + 8) = 0;
    return v5;
  }
  uint64_t v17 = v12;
  uint64_t Object = objc_GetObject(*(void *)(v58 + 48), (uint64_t)"LINGDB", &v56);
  if ((Object & 0x80000000) != 0) {
    goto LABEL_24;
  }
  *(void *)(v17 + 48) = *(void *)(v56 + 8);
  uint64_t Object = objc_GetObject(*(void *)(v58 + 48), (uint64_t)"FE_DCTLKP", &v55);
  if ((Object & 0x80000000) != 0) {
    goto LABEL_24;
  }
  uint64_t v22 = v55;
  *(void *)(v17 + 56) = *(void *)(v55 + 8);
  *(_OWORD *)(v17 + 64) = *(_OWORD *)(v22 + 16);
  *(void *)uint64_t v17 = v58;
  *(void *)(v17 + 8) = a3;
  uint64_t v23 = v57;
  *(void *)(v17 + 16) = a4;
  *(void *)(v17 + 24) = v23;
  *(void *)(v17 + 32) = a1;
  *(void *)(v17 + 40) = a2;
  *(void *)(v17 + 104) = 0;
  uint64_t Object = fe_nnws_loadCfg(v17);
  if ((Object & 0x80000000) != 0
    || (*(void *)(v17 + 128) = 0, uint64_t Object = nn_word_lkp_GetInterface(1u, &v51), (Object & 0x80000000) != 0))
  {
LABEL_24:
    uint64_t v5 = Object;
    log_OutText(*(void *)(*(void *)v17 + 32), (uint64_t)"FE_NNWS", 2, 0, (uint64_t)"fe_nnws ObjOpen Failed!", v19, v20, v21, v47);
    goto LABEL_25;
  }
  *(void *)(v17 + 128) = v51;
  *(void *)(v17 + 136) = safeh_GetNullHandle();
  *(void *)(v17 + 144) = v24;
  *(void *)(v17 + 152) = safeh_GetNullHandle();
  *(void *)(v17 + 160) = v25;
  *(void *)(v17 + 168) = safeh_GetNullHandle();
  *(void *)(v17 + 176) = v26;
  uint64_t v27 = *(void *)(v17 + 136);
  uint64_t v28 = *(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t, uint64_t))(*(void *)(v17 + 128)
                                                                                            + 16);
  uint64_t v29 = *(void *)(v17 + 144);
  uint64_t v30 = *(void *)(v17 + 8);
  uint64_t v31 = *(void *)(v17 + 16);
  if (*(_DWORD *)(v17 + 200))
  {
    uint64_t Object = v28(v27, v29, "albert", v30, v31, v17 + 152);
    if ((Object & 0x80000000) != 0) {
      goto LABEL_24;
    }
  }
  else
  {
    uint64_t Object = v28(v27, v29, "char", v30, v31, v17 + 152);
    if ((Object & 0x80000000) != 0) {
      goto LABEL_24;
    }
    long long v53 = *(_OWORD *)(v17 + 152);
    *((void *)&v52 + 1) = v51;
    uint64_t Object = objc_RegisterObject(*(void *)(v58 + 48), (uint64_t)"NNCHRLKP", &v52);
    if ((Object & 0x80000000) != 0) {
      goto LABEL_24;
    }
  }
  if (!*(_DWORD *)(v17 + 200))
  {
    uint64_t Object = (*(uint64_t (**)(void, void, const char *, void, void, uint64_t))(*(void *)(v17 + 128)
                                                                                              + 16))(*(void *)(v17 + 136), *(void *)(v17 + 144), "nnws_wlist", *(void *)(v17 + 8), *(void *)(v17 + 16), v17 + 168);
    if ((Object & 0x80000000) != 0) {
      goto LABEL_24;
    }
  }
  uint64_t Object = fe_nnws_CreateBrokerString(*(void *)v17, (char *)v59);
  if ((Object & 0x80000000) != 0) {
    goto LABEL_24;
  }
  uint64_t v32 = fi_init(a3, a4, a1, a2, &v50, 0, (uint64_t)v59, (uint64_t)"FINN", 1, 0);
  if ((v32 & 0x80000000) != 0)
  {
    uint64_t v5 = v32;
    uint64_t v45 = *(void *)(*(void *)v17 + 32);
    uint64_t v46 = "create FI model failed";
LABEL_29:
    log_OutText(v45, (uint64_t)"FE_NNWS", 5, 0, (uint64_t)v46, v33, v34, v35, v48);
    return v5;
  }
  *(void *)(v17 + 80) = v50;
  uint64_t v36 = fe_nnws_tagInit(*(void *)v17, &v49);
  if ((v36 & 0x80000000) != 0)
  {
    uint64_t v5 = v36;
    uint64_t v45 = *(void *)(*(void *)v17 + 32);
    uint64_t v46 = "create SBME tags failed";
    goto LABEL_29;
  }
  *(void *)(v17 + 120) = v49;
  uint64_t v37 = (uint64_t *)(v17 + 184);
  uint64_t v5 = fe_nnws_tryLoadingIGTree(*(_WORD **)(v17 + 8), *(void *)(v17 + 16), *(void *)v17, (char **)(v17 + 184));
  if ((v5 & 0x80000000) != 0)
  {
    if (*v37)
    {
      igtree_Deinit(*(void *)v17, *v37, v38, v39, v40, v41, v42, v43);
      heap_Free(*(void **)(*(void *)v17 + 8), *(void *)(v17 + 184));
      uint64_t v5 = 0;
      *(void *)(v17 + 184) = 0;
    }
    else
    {
      uint64_t v5 = 0;
    }
  }
  *(void *)a5 = v17;
  *(_DWORD *)(a5 + 8) = 62346;
  return v5;
}

uint64_t fe_nnws_ObjClose(uint64_t *a1, int a2)
{
  uint64_t v3 = safeh_HandleCheck((uint64_t)a1, a2, 62346, 208);
  if ((v3 & 0x80000000) != 0) {
    return 2588942344;
  }
  uint64_t v9 = v3;
  if (a1)
  {
    if (a1[6]) {
      objc_ReleaseObject(*(void *)(*a1 + 48), (uint64_t)"LINGDB");
    }
    if (a1[7]) {
      objc_ReleaseObject(*(void *)(*a1 + 48), (uint64_t)"FE_DCTLKP");
    }
    uint64_t v10 = a1[16];
    if (v10)
    {
      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(v10 + 24))(a1[19], a1[20]);
      int v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[16] + 24))(a1[21], a1[22]);
      if ((v9 & 0x80000000) == 0 && (v11 & 0x80000000) == 0) {
        objc_UnregisterObject(*(void *)(*a1 + 48), (uint64_t)"NNCHRLKP");
      }
    }
    uint64_t v12 = a1[14];
    if (v12)
    {
      heap_Free(*(void **)(*a1 + 8), v12);
      a1[14] = 0;
    }
    uint64_t v13 = (uint64_t *)a1[10];
    if (v13) {
      uint64_t v9 = fi_deinit(*a1, a1[3], v13);
    }
    if (a1[15])
    {
      for (uint64_t i = 0; i != 32; i += 8)
      {
        heap_Free(*(void **)(*a1 + 8), *(void *)(a1[15] + i));
        *(void *)(a1[15] + i) = 0;
      }
      heap_Free(*(void **)(*a1 + 8), a1[15]);
      a1[15] = 0;
    }
    uint64_t v15 = a1[23];
    if (v15)
    {
      igtree_Deinit(*a1, v15, (uint64_t)v13, v4, v5, v6, v7, v8);
      heap_Free(*(void **)(*a1 + 8), a1[23]);
      a1[23] = 0;
    }
    heap_Free(*(void **)(*a1 + 8), (uint64_t)a1);
  }
  return v9;
}

uint64_t fe_nnws_ObjReopen(void *a1, int a2)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  uint64_t v43 = 0;
  uint64_t v4 = 2588942342;
  uint64_t v39 = 0;
  memset(v44, 0, sizeof(v44));
  if ((safeh_HandleCheck((uint64_t)a1, a2, 62346, 208) & 0x80000000) != 0) {
    return 2588942344;
  }
  if (a1)
  {
    uint64_t v42 = 0;
    long long v40 = 0u;
    long long v41 = 0u;
    uint64_t v10 = a1[16];
    if (v10)
    {
      int v11 = (*(uint64_t (**)(void, void))(v10 + 24))(a1[19], a1[20]);
      int v12 = (*(uint64_t (**)(void, void))(a1[16] + 24))(a1[21], a1[22]);
      if ((v11 & 0x80000000) == 0 && (v12 & 0x80000000) == 0) {
        objc_UnregisterObject(*(void *)(*a1 + 48), (uint64_t)"NNCHRLKP");
      }
    }
    uint64_t v13 = (uint64_t *)a1[10];
    if (v13)
    {
      uint64_t Cfg = fi_deinit(*a1, a1[3], v13);
      if ((Cfg & 0x80000000) != 0)
      {
LABEL_29:
        uint64_t v4 = Cfg;
LABEL_30:
        log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NNWS", 2, 0, (uint64_t)"fe_nnws ObjReopen Failed!", v7, v8, v9, v37);
        fe_nnws_ObjClose(a1, a2);
        return v4;
      }
      a1[10] = 0;
    }
    uint64_t v15 = a1[14];
    if (v15)
    {
      heap_Free(*(void **)(*a1 + 8), v15);
      a1[14] = 0;
    }
    uint64_t v17 = a1 + 23;
    uint64_t v16 = a1[23];
    if (v16)
    {
      igtree_Deinit(*a1, v16, (uint64_t)v13, v5, v6, v7, v8, v9);
      heap_Free(*(void **)(*a1 + 8), a1[23]);
      a1[23] = 0;
    }
    a1[13] = 0;
    uint64_t Cfg = fe_nnws_loadCfg((uint64_t)a1);
    if ((Cfg & 0x80000000) != 0) {
      goto LABEL_29;
    }
    uint64_t Cfg = nn_word_lkp_GetInterface(1u, &v43);
    if ((Cfg & 0x80000000) != 0) {
      goto LABEL_29;
    }
    a1[16] = v43;
    a1[17] = safeh_GetNullHandle();
    a1[18] = v18;
    a1[19] = safeh_GetNullHandle();
    a1[20] = v19;
    a1[21] = safeh_GetNullHandle();
    a1[22] = v20;
    uint64_t v21 = a1[17];
    uint64_t v22 = *(uint64_t (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t, void *))(a1[16] + 16);
    uint64_t v23 = a1[18];
    uint64_t v24 = a1[1];
    uint64_t v25 = a1[2];
    if (*((_DWORD *)a1 + 50))
    {
      uint64_t Cfg = v22(v21, v23, "albert", v24, v25, a1 + 19);
      if ((Cfg & 0x80000000) != 0) {
        goto LABEL_29;
      }
    }
    else
    {
      uint64_t Cfg = v22(v21, v23, "char", v24, v25, a1 + 19);
      if ((Cfg & 0x80000000) != 0) {
        goto LABEL_29;
      }
      long long v41 = *(_OWORD *)(a1 + 19);
      *((void *)&v40 + 1) = v43;
      uint64_t Cfg = objc_RegisterObject(*(void *)(*a1 + 48), (uint64_t)"NNCHRLKP", &v40);
      if ((Cfg & 0x80000000) != 0) {
        goto LABEL_29;
      }
    }
    if (!*((_DWORD *)a1 + 50))
    {
      uint64_t Cfg = (*(uint64_t (**)(void, void, const char *, void, void, void *))(a1[16] + 16))(a1[17], a1[18], "nnws_wlist", a1[1], a1[2], a1 + 21);
      if ((Cfg & 0x80000000) != 0) {
        goto LABEL_29;
      }
    }
    uint64_t Cfg = fe_nnws_CreateBrokerString(*a1, (char *)v44);
    if ((Cfg & 0x80000000) != 0) {
      goto LABEL_29;
    }
    uint64_t v26 = fi_init((_WORD *)a1[1], a1[2], (_WORD *)a1[4], a1[5], &v39, 0, (uint64_t)v44, (uint64_t)"FINN", 1, 0);
    if ((v26 & 0x80000000) != 0)
    {
      uint64_t v4 = v26;
      log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NNWS", 5, 0, (uint64_t)"re-create FI model failed", v27, v28, v29, v38);
      goto LABEL_30;
    }
    a1[10] = v39;
    uint64_t v4 = fe_nnws_tryLoadingIGTree((_WORD *)a1[1], a1[2], *a1, (char **)a1 + 23);
    if ((v4 & 0x80000000) != 0)
    {
      if (*v17)
      {
        igtree_Deinit(*a1, *v17, v30, v31, v32, v33, v34, v35);
        heap_Free(*(void **)(*a1 + 8), a1[23]);
        uint64_t v4 = 0;
        a1[23] = 0;
      }
      else
      {
        return 0;
      }
    }
  }
  return v4;
}

uint64_t fe_nnws_ProcessStart(uint64_t a1, int a2)
{
  LODWORD(result) = safeh_HandleCheck(a1, a2, 62346, 208);
  if ((int)result >= 0) {
    return result;
  }
  else {
    return 2588942344;
  }
}

uint64_t fe_nnws_Process(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unsigned __int16 v176 = 0;
  uint64_t v171 = 0;
  long long __s = 0;
  uint64_t v5 = 2588942346;
  unsigned int v170 = 0;
  unsigned int v169 = 0;
  uint64_t v167 = 0;
  long long v168 = 0;
  int v166 = 0;
  *a5 = 1;
  if (!a1) {
    return 2588942343;
  }
  int v175 = 0;
  __int16 v174 = 0;
  int v173 = 0;
  BOOL v9 = log_GetLogLevel(*(void *)(*a1 + 32)) > 4;
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, unsigned __int16 *))(a1[6] + 104))(a3, a4, 1, 0, &v176);
  if ((v10 & 0x80000000) != 0)
  {
    uint64_t v11 = v10;
LABEL_19:
    char v12 = 0;
    goto LABEL_20;
  }
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, __int16 *))(a1[6] + 184))(a3, a4, v176, 0, &v174);
  char v12 = 0;
  if ((v11 & 0x80000000) != 0 || v174 != 1) {
    goto LABEL_20;
  }
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, char **, char *))(a1[6] + 176))(a3, a4, v176, 0, &__s, (char *)&v175 + 2);
  if ((v11 & 0x80000000) != 0) {
    goto LABEL_19;
  }
  if (HIWORD(v175) < 2u) {
    return v11;
  }
  size_t v13 = strlen(__s);
  uint64_t v14 = (char *)heap_Alloc(*(void *)(*a1 + 8), v13 + 1);
  uint64_t v171 = v14;
  if (!v14)
  {
    log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_NNWS", 75000, 0, v15, v16, v17, v18, v149);
    char v12 = 0;
LABEL_241:
    uint64_t v11 = 2588942346;
    goto LABEL_20;
  }
  uint64_t v19 = v14;
  uint64_t v20 = strcpy(v14, __s);
  int v21 = strlen(v20);
  unsigned int v22 = Utf8_LengthInUtf8chars((unint64_t)v19, v21);
  uint64_t v23 = heap_Calloc(*(void **)(*a1 + 8), v22, 56);
  long long v168 = (uint64_t *)v23;
  if (!v23) {
    goto LABEL_240;
  }
  uint64_t v28 = v23;
  uint64_t v29 = a1[6];
  uint64_t v159 = *a1;
  uint64_t v30 = v176;
  int v185 = 0;
  BOOL v184 = 0;
  int v182 = 0;
  int v183 = 0;
  uint64_t v180 = 0;
  uint64_t v181 = 0;
  uint64_t v179 = 0;
  uint64_t v165 = v29;
  uint64_t UTF8Char = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t *, char *))(v29 + 176))(a3, a4, v176, 1, &v179, (char *)&v183 + 2);
  if ((UTF8Char & 0x80000000) != 0
    || (uint64_t UTF8Char = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, int *))(v165 + 104))(a3, a4, 3, v30, &v183), (UTF8Char & 0x80000000) != 0))
  {
    unsigned int v43 = 0;
LABEL_47:
    uint64_t v5 = UTF8Char;
LABEL_48:
    unsigned int v169 = v43;
    char v12 = 1;
    uint64_t v11 = v5;
LABEL_20:
    uint64_t v35 = v171;
    if (!v171) {
      goto LABEL_22;
    }
LABEL_21:
    heap_Free(*(void **)(*a1 + 8), (uint64_t)v35);
    goto LABEL_22;
  }
  unsigned __int16 v32 = v183;
  uint64_t v161 = v28;
  if ((_WORD)v183)
  {
    while (1)
    {
      int v178 = 0;
      __int16 v177 = 0;
      uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, int *, __int16 *))(v165 + 168))(a3, a4, v32, 0, 1, &v178, &v177);
      if ((v33 & 0x80000000) != 0) {
        goto LABEL_264;
      }
      if (v178 == 6) {
        break;
      }
      uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, void, int *))(v165 + 120))(a3, a4, (unsigned __int16)v183, &v183);
      if ((v33 & 0x80000000) != 0) {
        goto LABEL_264;
      }
      unsigned __int16 v32 = v183;
      if (!(_WORD)v183)
      {
        BOOL v151 = 0;
        int v34 = 1;
        goto LABEL_50;
      }
    }
    uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v183, 1, 1, (char *)&v180 + 4, &v177);
    if ((v33 & 0x80000000) != 0) {
      goto LABEL_264;
    }
    uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v183, 2, 1, &v180, &v177);
    if ((v33 & 0x80000000) != 0) {
      goto LABEL_264;
    }
    uint64_t v110 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char *))(v165 + 184))(a3, a4, (unsigned __int16)v183, 8, (char *)&v182 + 2);
    if ((v110 & 0x80000000) != 0) {
      goto LABEL_201;
    }
    if (HIWORD(v182) == 1)
    {
      uint64_t v110 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v183, 8, 1, &v185, &v177);
      if ((v110 & 0x80000000) != 0) {
        goto LABEL_201;
      }
    }
    else
    {
      int v185 = v180 - HIDWORD(v180);
    }
    uint64_t v110 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, const char **, __int16 *))(v165 + 176))(a3, a4, (unsigned __int16)v183, 4, &v184, &v177);
    if ((v110 & 0x80000000) != 0)
    {
LABEL_201:
      uint64_t v5 = v110;
      unsigned int v43 = 0;
      goto LABEL_48;
    }
    int v111 = strcmp(v184, "_PR_");
    int v34 = 0;
    BOOL v151 = v111 == 0;
  }
  else
  {
    BOOL v151 = 0;
    int v34 = 1;
  }
LABEL_50:
  unsigned int v150 = v30;
  unsigned int v44 = HIWORD(v183);
  if (!HIWORD(v183))
  {
    unsigned int v43 = 0;
    goto LABEL_153;
  }
  int v157 = v34;
  unint64_t v45 = 0;
  uint64_t v163 = 0;
  unsigned int v43 = 0;
  unsigned int v154 = 0;
  uint64_t v46 = 0;
  uint64_t v47 = 40;
  uint64_t v156 = 1;
  unsigned int v153 = v22;
  do
  {
    uint64_t v48 = v179;
    int v49 = *(_DWORD *)(v179 + 32 * v45);
    unint64_t v160 = v45;
    if (v49 != 1)
    {
      if (v43 && (*(void *)(v28 + 56 * (v43 - 1) + 36) = 0x100000001, v45 >= 2) && v49 == 99)
      {
        if (*(_DWORD *)(v48 + 32 * (v45 - 1)) == 1
          && *(_DWORD *)(v48 + 32 * v45 + 12) == *(_DWORD *)(v48 + 32 * (v45 - 1) + 12))
        {
          *(_DWORD *)(v28 + 56 * (v43 - 1) + 48) = 1;
        }
      }
      else if (v49 == 0x4000)
      {
        unsigned int v154 = *(_DWORD *)(v48 + 32 * v45 + 12);
      }
      goto LABEL_150;
    }
    uint64_t v50 = v179 + 32 * v45;
    unsigned int v51 = *(_DWORD *)(v50 + 12);
    v154 += v46;
    uint64_t v152 = v47;
    if (v51 <= v154 || *(_DWORD *)(v50 + 4) <= v154)
    {
      unint64_t v63 = v160;
    }
    else
    {
      unsigned int v52 = v43;
      uint64_t v53 = v28 + 56 * v43;
      *(void *)(v53 + 36) = 1;
      *(int32x2_t *)(v53 + 8) = vdup_n_s32(v46);
      *(_DWORD *)(v53 + 16) = v51 + ~v154;
      uint64_t v54 = (_DWORD *)(v53 + 16);
      int v55 = v46;
      uint64_t v56 = (_DWORD *)heap_Alloc(*(void *)(v159 + 8), 4);
      *(void *)uint64_t v53 = v56;
      if (!v56)
      {
LABEL_197:
        log_OutPublic(*(void *)(v159 + 32), (uint64_t)"FE_NNWS", 75000, 0, v57, v58, v59, v60, v149);
        unsigned int v43 = v52;
        goto LABEL_48;
      }
      *uint64_t v56 = 4673093;
      uint64_t v61 = (*v54 + v55);
      LODWORD(v163) = *v54 + v163;
      HIDWORD(v163) = v61;
      unsigned int v62 = v52 + 1;
      unsigned int v44 = HIWORD(v183);
      uint64_t v48 = v179;
      unsigned int v22 = v153;
      unint64_t v63 = v160;
      uint64_t v28 = v161;
      uint64_t v47 = v152;
      uint64_t v46 = v61;
      unsigned int v43 = v62;
    }
    if (v63 + 1 >= v44)
    {
      int v64 = 0;
LABEL_75:
      int v69 = *(_DWORD *)(v48 + 12);
      int v68 = *(_DWORD *)(v48 + 16);
      int v70 = *(_DWORD *)(v48 + 32 * v160 + 12);
      int v71 = v68 + v69 - v64;
    }
    else
    {
      int v64 = 0;
      uint64_t v65 = (int *)(v48 + v47);
      uint64_t v66 = v156;
      while (*(v65 - 2) != 1)
      {
        int v67 = *v65;
        v65 += 8;
        if (v67 == 1) {
          ++v64;
        }
        if (v44 == ++v66) {
          goto LABEL_75;
        }
      }
      int v71 = *(_DWORD *)(v48 + 32 * v66 + 12);
      int v70 = v64 + *(_DWORD *)(v48 + 32 * v160 + 12);
    }
    unsigned int v155 = v71 - v70;
    if (v43 >= v22) {
      goto LABEL_148;
    }
    unsigned int v162 = 0;
    int v158 = 1;
    while (1)
    {
      uint64_t v72 = v46;
      if (strlen(v19) <= v163 || v162 >= v155) {
        break;
      }
      if ((_WORD)v183 && v157 == 1)
      {
        if (v72 >= v180)
        {
          do
          {
            uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t))(v165 + 120))(a3, a4);
            if ((v33 & 0x80000000) != 0) {
              goto LABEL_264;
            }
            if (!(_WORD)v183) {
              goto LABEL_84;
            }
            int v178 = 0;
            __int16 v177 = 0;
            uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, int *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v183, 0, 1, &v178, &v177);
            if ((v33 & 0x80000000) != 0) {
              goto LABEL_264;
            }
          }
          while (v178 != 6);
          uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v183, 1, 1, (char *)&v180 + 4, &v177);
          if ((v33 & 0x80000000) != 0) {
            goto LABEL_264;
          }
          uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v183, 2, 1, &v180, &v177);
          if ((v33 & 0x80000000) != 0) {
            goto LABEL_264;
          }
          uint64_t UTF8Char = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char *))(v165 + 184))(a3, a4, (unsigned __int16)v183, 8, (char *)&v182 + 2);
          if ((UTF8Char & 0x80000000) != 0) {
            goto LABEL_47;
          }
          if (HIWORD(v182) == 1)
          {
            uint64_t UTF8Char = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v183, 8, 1, &v185, &v177);
            if ((UTF8Char & 0x80000000) != 0) {
              goto LABEL_47;
            }
          }
          else
          {
            int v185 = v180 - HIDWORD(v180);
          }
          uint64_t UTF8Char = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, const char **, __int16 *))(v165 + 176))(a3, a4, (unsigned __int16)v183, 4, &v184, &v177);
          if ((UTF8Char & 0x80000000) != 0) {
            goto LABEL_47;
          }
          int v157 = 0;
          BOOL v151 = strcmp(v184, "_PR_") == 0;
        }
        else
        {
LABEL_84:
          int v157 = 1;
        }
      }
      uint64_t UTF8Char = utf8_getUTF8Char((uint64_t)v19, HIDWORD(v163), __src);
      if ((UTF8Char & 0x80000000) != 0) {
        goto LABEL_47;
      }
      if (utf8_IsChineseLetter(__src))
      {
        int v73 = 0;
        int v74 = 1;
        uint64_t v46 = v72;
      }
      else
      {
        uint64_t v46 = v72;
        int v74 = 0;
        int v73 = 1;
        if (__src[0] - 48 >= 0xA
          && (__src[0] - 35 > 0x3C
           || ((1 << (__src[0] - 35)) & 0x1800000004000503) == 0)
          && __src[0] != 124)
        {
          if ((__src[0] & 0xDFu) - 65 < 0x1A
            || __src[0] - 38 <= 0x1A && ((1 << (__src[0] - 38)) & 0x4000003) != 0)
          {
            int v74 = 0;
            int v73 = 2;
          }
          else
          {
            int v73 = 0;
            int v74 = 1;
          }
        }
      }
      if ((_WORD)v183 && HIDWORD(v163) == HIDWORD(v180))
      {
        if (!v158)
        {
          *(_DWORD *)(v161 + 56 * v43++ + 16) = HIDWORD(v163) - v46;
          LODWORD(v46) = HIDWORD(v163);
        }
        int v82 = (_DWORD *)(v161 + 56 * v43 + 32);
        if (v151)
        {
          *int v82 = 5;
          if (v43) {
            *(void *)(v161 + 56 * (v43 - 1) + 36) = 0x100000001;
          }
        }
        else
        {
          *int v82 = 3;
        }
        unsigned int v52 = v43;
        uint64_t v83 = v161 + 56 * v43;
        *(int32x2_t *)(v83 + 8) = vdup_n_s32(v46);
        *(_DWORD *)(v83 + 20) = v185;
        *(_DWORD *)(v83 + 16) = v180 - HIDWORD(v163);
        uint64_t v84 = (_DWORD *)(v83 + 16);
        *(void *)(v83 + 36) = 1;
        int v85 = v46;
        unint64_t v86 = (_DWORD *)heap_Calloc(*(void **)(v159 + 8), 1, 4);
        *(void *)uint64_t v83 = v86;
        if (!v86) {
          goto LABEL_197;
        }
        *unint64_t v86 = 5068110;
        LODWORD(v163) = *v84 + v163;
        v162 += *v84;
        uint64_t v87 = (*v84 + v85);
        int v157 = 1;
        int v158 = 1;
        HIDWORD(v163) = v87;
        unsigned int v88 = v52 + 1;
        unsigned int v22 = v153;
        uint64_t v28 = v161;
        uint64_t v46 = v87;
        unsigned int v43 = v88;
      }
      else
      {
        if (!v74)
        {
          if (v158)
          {
            uint64_t v75 = (int32x2_t *)(v161 + 56 * v43);
            v75[1] = vdup_n_s32(v46);
            v75[2].i32[0] = 1;
            uint64_t v76 = (_DWORD *)heap_Calloc(*(void **)(v159 + 8), 1, 4);
            *uint64_t v75 = (int32x2_t)v76;
            if (!v76)
            {
              log_OutPublic(*(void *)(v159 + 32), (uint64_t)"FE_NNWS", 75000, 0, v77, v78, v79, v80, v149);
              goto LABEL_48;
            }
            unsigned int v22 = v153;
            uint64_t v46 = v72;
            if (v73 == 1)
            {
              uint64_t v81 = "NUM";
LABEL_124:
              *uint64_t v76 = *(_DWORD *)v81;
            }
            else if (v73 == 2)
            {
              uint64_t v81 = "ENG";
              goto LABEL_124;
            }
            int v158 = 0;
            int v89 = v72 + 1;
          }
          else
          {
            int v158 = 0;
            int v89 = HIDWORD(v163) + 1;
          }
          HIDWORD(v163) = v89;
          int v90 = 1;
          int v91 = 1;
LABEL_132:
          v162 += v90;
          LODWORD(v163) = v91 + v163;
          uint64_t v28 = v161;
          goto LABEL_133;
        }
        if (v158)
        {
          int v158 = 1;
          uint64_t v28 = v161;
        }
        else
        {
          uint64_t v28 = v161;
          if (**(unsigned char **)(v161 + 56 * v43) == 124)
          {
            int v158 = 0;
          }
          else
          {
            *(_DWORD *)(v161 + 56 * v43++ + 16) = HIDWORD(v163) - v46;
            int v158 = 1;
            LODWORD(v46) = HIDWORD(v163);
          }
        }
        if (__src[0] != 32)
        {
          unint64_t v92 = (int32x2_t *)(v28 + 56 * v43);
          v92[4].i32[1] = (v92[4].i32[0] & 0xFFFFFFFE) == 2;
          v92[5].i32[0] = 0;
          v92[1] = vdup_n_s32(v46);
          unsigned int v164 = v43;
          int v93 = v46;
          int v90 = utf8_determineUTF8CharLength(v19[v46]);
          v92[2].i32[0] = v90;
          size_t v94 = strlen(__src);
          size_t v95 = (char *)heap_Calloc(*(void **)(v159 + 8), 1, v94 + 1);
          *unint64_t v92 = (int32x2_t)v95;
          if (!v95)
          {
            log_OutPublic(*(void *)(v159 + 32), (uint64_t)"FE_NNWS", 75000, 0, v96, v97, v98, v99, v149);
LABEL_211:
            unsigned int v43 = v164;
            goto LABEL_48;
          }
          strcpy(v95, __src);
          int v91 = v92[2].i32[0];
          uint64_t v100 = (v91 + v93);
          unsigned int v101 = v164 + 1;
          HIDWORD(v163) = v100;
          unsigned int v22 = v153;
          uint64_t v46 = v100;
          unsigned int v43 = v101;
          goto LABEL_132;
        }
        uint64_t v46 = (v46 + 1);
        ++v162;
        LODWORD(v163) = v163 + 1;
        HIDWORD(v163) = v46;
      }
LABEL_133:
      if (v43 >= v22) {
        goto LABEL_146;
      }
    }
    uint64_t v46 = v72;
LABEL_146:
    if (!v158)
    {
      *(_DWORD *)(v28 + 56 * v43++ + 16) = HIDWORD(v163) - v46;
      uint64_t v46 = HIDWORD(v163);
    }
LABEL_148:
    unint64_t v45 = v160;
    uint64_t v47 = v152;
    if (v43) {
      *(void *)(v28 + 56 * (v43 - 1) + 36) = 0x100000001;
    }
LABEL_150:
    ++v45;
    unsigned int v44 = HIWORD(v183);
    ++v156;
    v47 += 32;
  }
  while (v45 < HIWORD(v183));
LABEL_153:
  unsigned int v169 = v43;
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, int *))(v165 + 104))(a3, a4, 3, v150, &v182);
  if ((v11 & 0x80000000) != 0)
  {
LABEL_196:
    uint64_t v5 = v11;
    goto LABEL_48;
  }
  unsigned __int16 v102 = v182;
  if ((_WORD)v182)
  {
    while (1)
    {
      int v178 = 0;
      __int16 v177 = 0;
      uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, int *, __int16 *))(v165 + 168))(a3, a4, v102, 0, 1, &v178, &v177);
      if ((v33 & 0x80000000) != 0) {
        goto LABEL_264;
      }
      if (v178 == 5)
      {
        uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v182, 1, 1, (char *)&v180 + 4, &v177);
        if ((v33 & 0x80000000) != 0) {
          goto LABEL_264;
        }
        uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v182, 2, 1, &v180, &v177);
        if ((v33 & 0x80000000) != 0) {
          goto LABEL_264;
        }
        uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, const char **, __int16 *))(v165 + 176))(a3, a4, (unsigned __int16)v182, 4, &v181, &v177);
        if ((v11 & 0x80000000) != 0) {
          goto LABEL_196;
        }
        if (!strcmp(v181, "phon")) {
          break;
        }
      }
      uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, void, int *))(v165 + 120))(a3, a4, (unsigned __int16)v182, &v182);
      if ((v11 & 0x80000000) != 0) {
        goto LABEL_265;
      }
      unsigned __int16 v102 = v182;
      if (!(_WORD)v182) {
        goto LABEL_163;
      }
    }
    int v103 = 1;
    if (!v43)
    {
LABEL_203:
      unsigned int v112 = 0;
      unsigned int v169 = 0;
LABEL_204:
      uint64_t v33 = fe_nnws_writeLDB_v2(a1, a3, a4, v176, v161, v112, (uint64_t)__s);
      if ((v33 & 0x80000000) != 0)
      {
LABEL_264:
        uint64_t v11 = v33;
      }
      else
      {
        uint64_t v35 = v171;
        uint64_t v113 = fe_nnws_adjustTokenRecordBND(v161, v112, v171, v176, a3, a4, (uint64_t)a1);
        if ((v113 & 0x80000000) != 0) {
          goto LABEL_258;
        }
        __int16 v114 = strlen(v35);
        uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, const char *, int *))(a1[6] + 160))(a3, a4, v176, 0, (unsigned __int16)(v114 + 1), v35, &v175);
        if ((v11 & 0x80000000) == 0) {
          log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NNWS", 5, 0, (uint64_t)v35, v115, v116, v117, 0);
        }
      }
LABEL_265:
      char v12 = 1;
      goto LABEL_20;
    }
  }
  else
  {
LABEL_163:
    int v103 = 0;
    if (!v43) {
      goto LABEL_203;
    }
  }
  unsigned int v164 = v43;
  unsigned int v104 = 0;
  while (2)
  {
    unsigned int v105 = *(_DWORD *)(v161 + 56 * v104 + 12);
    if (v103 == 1)
    {
      unsigned int v106 = v180;
      if (v105 >= HIDWORD(v180) && *(_DWORD *)(v161 + 56 * v104 + 16) + v105 <= v180)
      {
        int v103 = 1;
        *(_DWORD *)(v161 + 56 * v104 + 44) = 1;
        goto LABEL_176;
      }
    }
    else
    {
      unsigned int v106 = v180;
    }
    if (*(_DWORD *)(v161 + 56 * v104 + 16) + v105 > v106 && (unsigned __int16)v182 != 0)
    {
      while (1)
      {
        uint64_t v108 = (*(uint64_t (**)(uint64_t, uint64_t))(v165 + 120))(a3, a4);
        uint64_t v11 = v108;
        if ((v108 & 0x80000000) != 0) {
          goto LABEL_265;
        }
        if (!(_WORD)v182) {
          goto LABEL_177;
        }
        int v178 = 0;
        __int16 v177 = 0;
        uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, int *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v182, 0, 1, &v178, &v177);
        if ((v33 & 0x80000000) != 0) {
          goto LABEL_264;
        }
        if (v178 == 5)
        {
          uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v182, 1, 1, (char *)&v180 + 4, &v177);
          if ((v33 & 0x80000000) != 0) {
            goto LABEL_264;
          }
          uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t *, __int16 *))(v165 + 168))(a3, a4, (unsigned __int16)v182, 2, 1, &v180, &v177);
          if ((v33 & 0x80000000) != 0) {
            goto LABEL_264;
          }
          uint64_t v109 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, const char **, __int16 *))(v165 + 176))(a3, a4, (unsigned __int16)v182, 4, &v181, &v177);
          uint64_t v11 = v109;
          if ((v109 & 0x80000000) != 0)
          {
            uint64_t v5 = v109;
            goto LABEL_211;
          }
          if (!strcmp(v181, "phon"))
          {
            int v103 = 1;
            goto LABEL_177;
          }
          int v103 = 0;
        }
      }
    }
    *(_DWORD *)(v161 + 56 * v104 + 44) = 0;
LABEL_176:
    ++v104;
LABEL_177:
    if (v104 < v43) {
      continue;
    }
    break;
  }
  unsigned int v169 = v43;
  if ((v11 & 0x80000000) != 0) {
    goto LABEL_265;
  }
  uint64_t v33 = (*(uint64_t (**)(void, void, int *))(a1[16] + 40))(a1[19], a1[20], &v173);
  if ((v33 & 0x80000000) != 0) {
    goto LABEL_264;
  }
  int v122 = *((_DWORD *)a1 + 24);
  if (v122 != *((_DWORD *)a1 + 25) + v173)
  {
    log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_NNWS", 75000, 0, v118, v119, v120, v121, v149);
    uint64_t v11 = 2588942361;
    goto LABEL_265;
  }
  int v123 = *((_DWORD *)a1 + 50) ? v43 + 2 : v43;
  int v124 = (_DWORD *)heap_Alloc(*(void *)(*a1 + 8), 4 * (v122 * v123));
  uint64_t v167 = v124;
  if (!v124)
  {
LABEL_240:
    log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_NNWS", 75000, 0, v24, v25, v26, v27, v149);
    char v12 = 1;
    goto LABEL_241;
  }
  uint64_t v125 = v124;
  if (*((_DWORD *)a1 + 50))
  {
    *int v124 = 1120534528;
    uint64_t v125 = &v124[v173];
  }
  uint64_t v126 = 0;
  unint64_t v127 = 0;
  do
  {
    if (*((_DWORD *)a1 + 48))
    {
      unsigned __int16 v128 = (uint64_t (**)(void, void, uint64_t, _DWORD *))(a1[16] + 64);
    }
    else
    {
      uint64_t v129 = a1[16];
      if (*((_DWORD *)a1 + 50)) {
        unsigned __int16 v128 = (uint64_t (**)(void, void, uint64_t, _DWORD *))(v129 + 72);
      }
      else {
        unsigned __int16 v128 = (uint64_t (**)(void, void, uint64_t, _DWORD *))(v129 + 56);
      }
    }
    uint64_t v11 = (*v128)(a1[19], a1[20], v168[v126], v125);
    if ((v11 & 0x1FFF) == 0x14)
    {
      log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NNWS", 5, 0, (uint64_t)"No embedding vector for character %s . Fall back!", v131, v132, v133, v168[v126]);
      if (*((_DWORD *)a1 + 48))
      {
        uint64_t v134 = (uint64_t (**)(void, void, void, _DWORD *))(a1[16] + 64);
      }
      else
      {
        uint64_t v135 = a1[16];
        if (*((_DWORD *)a1 + 50)) {
          uint64_t v134 = (uint64_t (**)(void, void, void, _DWORD *))(v135 + 72);
        }
        else {
          uint64_t v134 = (uint64_t (**)(void, void, void, _DWORD *))(v135 + 56);
        }
      }
      uint64_t v11 = (*v134)(a1[19], a1[20], a1[14], v125);
    }
    uint64_t v136 = (uint64_t)&v125[v173];
    if (*((_DWORD *)a1 + 48) || *((_DWORD *)a1 + 50))
    {
      if ((v11 & 0x80000000) != 0) {
        goto LABEL_265;
      }
    }
    else
    {
      fe_nnws_dynamic_feat(a1, (uint64_t)v168, (unsigned __int16)v169, (unsigned __int16)v127, v136);
    }
    uint64_t v125 = (_DWORD *)(v136 + 4 * *((unsigned int *)a1 + 25));
    ++v127;
    uint64_t v137 = v169;
    v126 += 7;
  }
  while (v127 < v169);
  if (*((_DWORD *)a1 + 50))
  {
    *uint64_t v125 = 1120665600;
    uint64_t v138 = (uint64_t ***)a1[10];
    uint64_t v139 = (v137 + 2);
  }
  else
  {
    uint64_t v138 = (uint64_t ***)a1[10];
    uint64_t v139 = v169;
  }
  uint64_t v11 = fi_predict(v138, &v167, v139, &v170, v130, v131, v132, v133);
  if ((v11 & 0x80000000) != 0)
  {
    log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NNWS", 5, 0, (uint64_t)"FI Word Segmentation Prediction Failed", v140, v141, v142, 0);
    goto LABEL_265;
  }
  if (*((_DWORD *)a1 + 50)) {
    ++v170;
  }
  if ((paramc_ParamGetInt(*(void *)(*a1 + 40), (uint64_t)"nnwsAddonEnable", &v166) & 0x80000000) != 0)
  {
    int v143 = *((_DWORD *)a1 + 49);
  }
  else
  {
    int v143 = v166;
    *((_DWORD *)a1 + 49) = v166;
  }
  if (v143 < 1
    || (uint64_t v35 = v171,
        uint64_t v113 = fe_nnws_addon_lookup(a1, (uint64_t)v168, v137, (uint64_t)v171, (uint64_t *)&v170, (void *)a1[15], v143),
        (v113 & 0x80000000) == 0))
  {
    uint64_t v144 = *a1;
    uint64_t v161 = (uint64_t)v168;
    __int16 v145 = (uint64_t *)a1[15];
    if (*((_DWORD *)a1 + 50)) {
      fe_nnws_adjustBMES_Edge(v144, v137, (uint64_t)v168, v9, v145, &v170);
    }
    else {
      fe_nnws_adjustBMES(v144, v137, (uint64_t)v168, v9, v145, &v170);
    }
    uint64_t v33 = fe_nnws_IGTreeProcess(a1, v137, (uint64_t *)a1[15], v161, (uint64_t *)&v170, v146, v147, v148);
    if ((v33 & 0x80000000) == 0)
    {
      fe_nnws_retag_word_under_phon(&v170, (uint64_t *)&v168, &v169, (void *)a1[15]);
      uint64_t v33 = fe_nnws_group(*a1, (uint64_t)v170, (uint64_t *)&v168, &v169, (const char **)&v171);
      if ((v33 & 0x80000000) == 0)
      {
        unsigned int v112 = v169;
        goto LABEL_204;
      }
    }
    goto LABEL_264;
  }
LABEL_258:
  uint64_t v11 = v113;
  char v12 = 1;
  if (v35) {
    goto LABEL_21;
  }
LABEL_22:
  uint64_t v36 = (uint64_t)v168;
  if (v168)
  {
    uint64_t v37 = v169;
    if (v169)
    {
      uint64_t v38 = v168;
      do
      {
        if (*v38)
        {
          heap_Free(*(void **)(*a1 + 8), *v38);
          uint64_t *v38 = 0;
        }
        v38 += 7;
        --v37;
      }
      while (v37);
    }
    heap_Free(*(void **)(*a1 + 8), v36);
  }
  char v39 = v12 ^ 1;
  if ((int)v11 < 0) {
    char v39 = 1;
  }
  if ((v39 & 1) == 0)
  {
    LODWORD(v184) = 0;
    LODWORD(v181) = 0;
    LODWORD(v179) = 0;
    *(_WORD *)__src = 0;
    LOWORD(v185) = 0;
    uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *))(a1[6] + 104))(a3, a4, 3, v176, __src);
    if ((v11 & 0x80000000) == 0)
    {
      while (*(_WORD *)__src)
      {
        uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, const char **, int *))(a1[6] + 168))(a3, a4, *(unsigned __int16 *)__src, 0, 1, &v184, &v185);
        if ((v40 & 0x80000000) != 0) {
          return v40;
        }
        uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, const char **, int *))(a1[6] + 168))(a3, a4, *(unsigned __int16 *)__src, 1, 1, &v181, &v185);
        if ((v40 & 0x80000000) != 0) {
          return v40;
        }
        uint64_t v40 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t *, int *))(a1[6] + 168))(a3, a4, *(unsigned __int16 *)__src, 2, 1, &v179, &v185);
        if ((v40 & 0x80000000) != 0) {
          return v40;
        }
        if ((v184 - 7) >= 0xFFFFFFFD) {
          uint64_t v41 = 0;
        }
        else {
          uint64_t v41 = *(unsigned __int16 *)__src;
        }
        uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[6] + 120))(a3, a4);
        if ((v11 & 0x80000000) != 0) {
          return v11;
        }
        if (v41) {
          uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[6] + 192))(a3, a4, v41);
        }
      }
    }
  }
  return v11;
}

uint64_t fe_nnws_ProcessEnd(uint64_t a1, int a2)
{
  LODWORD(result) = safeh_HandleCheck(a1, a2, 62346, 208);
  if ((int)result >= 0) {
    return result;
  }
  else {
    return 2588942344;
  }
}

uint64_t fe_nnws_loadCfg(uint64_t a1)
{
  memset(__c, 0, sizeof(__c));
  *(_DWORD *)(a1 + 192) = 0;
  if (((*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 64), *(void *)(a1 + 72), "fecfg", "nnws_use_static_feat", &__c[3], &__c[1], __c) & 0x80000000) == 0&& *(_WORD *)&__c[1])
  {
    uint64_t v2 = **(const char ***)&__c[3];
    uint64_t v3 = strchr(**(char ***)&__c[3], __c[0]);
    if (v3)
    {
      *uint64_t v3 = 0;
      uint64_t v2 = **(const char ***)&__c[3];
    }
    if (!strcmp(v2, "yes")) {
      *(_DWORD *)(a1 + 192) = 1;
    }
  }
  uint64_t v4 = 2588943364;
  *(_WORD *)&__c[1] = 0;
  if (((*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 64), *(void *)(a1 + 72), "fecfg", "nnws_nn_null_fea", &__c[3], &__c[1], __c) & 0x80000000) == 0&& *(_WORD *)&__c[1])
  {
    *(void *)(a1 + 112) = 0;
    uint64_t v5 = **(const char ***)&__c[3];
    uint64_t v6 = strchr(**(char ***)&__c[3], __c[0]);
    if (v6)
    {
      *uint64_t v6 = 0;
      uint64_t v5 = **(const char ***)&__c[3];
    }
    size_t v7 = strlen(v5);
    uint64_t v8 = heap_Alloc(*(void *)(*(void *)a1 + 8), v7 + 1);
    *(void *)(a1 + 112) = v8;
    if (v8)
    {
      size_t v13 = (char *)v8;
      size_t v14 = strlen(**(const char ***)&__c[3]);
      strncpy(v13, **(const char ***)&__c[3], v14);
      *(unsigned char *)(*(void *)(a1 + 112) + strlen(**(const char ***)&__c[3])) = 0;
      *(_WORD *)&__c[1] = 0;
      if (((*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 64), *(void *)(a1 + 72), "fecfg", "nnws_nn_indim", &__c[3], &__c[1], __c) & 0x80000000) == 0)
      {
        if (*(_WORD *)&__c[1])
        {
          *(_DWORD *)(a1 + 96) = 0;
          *(_DWORD *)(a1 + 96) = (unsigned __int16)LH_atou(**(const char ***)&__c[3]);
          *(_WORD *)&__c[1] = 0;
          if (((*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 64), *(void *)(a1 + 72), "fecfg", "nnws_nn_ddim", &__c[3], &__c[1], __c) & 0x80000000) == 0)
          {
            if (*(_WORD *)&__c[1])
            {
              *(_DWORD *)(a1 + 100) = 0;
              *(_DWORD *)(a1 + 100) = (unsigned __int16)LH_atou(**(const char ***)&__c[3]);
              *(_WORD *)&__c[1] = 0;
              *(_DWORD *)(a1 + 196) = 0;
              if (((*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 64), *(void *)(a1 + 72), "fecfg", "nnws_use_force_ws", &__c[3], &__c[1], __c) & 0x80000000) == 0&& *(_WORD *)&__c[1])
              {
                *(_DWORD *)(a1 + 196) = LH_atou(**(const char ***)&__c[3]);
              }
              *(_WORD *)&__c[1] = 0;
              *(_DWORD *)(a1 + 200) = 0;
              uint64_t v15 = (*(uint64_t (**)(void, void, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 64), *(void *)(a1 + 72), "fecfg", "nnws_use_albert", &__c[3], &__c[1], __c);
              uint64_t v4 = 0;
              if ((v15 & 0x80000000) == 0 && *(_WORD *)&__c[1])
              {
                uint64_t v16 = v15;
                uint64_t v17 = **(const char ***)&__c[3];
                uint64_t v18 = strchr(**(char ***)&__c[3], __c[0]);
                if (v18)
                {
                  *uint64_t v18 = 0;
                  uint64_t v17 = **(const char ***)&__c[3];
                }
                if (!strcmp(v17, "yes")) {
                  *(_DWORD *)(a1 + 200) = 1;
                }
                return v16;
              }
            }
          }
        }
      }
    }
    else
    {
      log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_NNWS", 75000, 0, v9, v10, v11, v12, v20);
      return 2588942346;
    }
  }
  return v4;
}

uint64_t fe_nnws_CreateBrokerString(uint64_t a1, char *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v5 = 0;
  *(void *)uint64_t v6 = 0;
  memset(v7, 0, sizeof(v7));
  uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"langcode", v6);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"fecfg", &v5);
    if ((result & 0x80000000) == 0)
    {
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      __strcat_chk();
      return brokeraux_ComposeBrokerString(a1, (const char *)v7, 1, 1, *(char **)v6, 0, 0, a2, 0x100uLL);
    }
  }
  return result;
}

uint64_t fe_nnws_tagInit(uint64_t a1, uint64_t *a2)
{
  uint64_t v8 = heap_Calloc(*(void **)(a1 + 8), 4, 8);
  if (v8)
  {
    uint64_t v9 = 0;
    while (1)
    {
      uint64_t v10 = (unsigned char *)heap_Calloc(*(void **)(a1 + 8), 2, 1);
      *(void *)(v8 + 8 * v9) = v10;
      if (!v10) {
        break;
      }
      *uint64_t v10 = aSbme[v9++];
      if (v9 == 4)
      {
        uint64_t v15 = 0;
        goto LABEL_12;
      }
    }
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_NNWS", 75000, 0, v11, v12, v13, v14, v19);
    for (uint64_t i = 0; i != 32; i += 8)
    {
      uint64_t v17 = *(void *)(v8 + i);
      if (v17) {
        heap_Free(*(void **)(a1 + 8), v17);
      }
    }
    uint64_t v15 = 2588942346;
    heap_Free(*(void **)(a1 + 8), v8);
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v15 = 2588942346;
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_NNWS", 75000, 0, v4, v5, v6, v7, v19);
  }
LABEL_12:
  *a2 = v8;
  return v15;
}

uint64_t fe_nnws_tryLoadingIGTree(_WORD *a1, uint64_t a2, uint64_t a3, char **a4)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  memset(v27, 0, sizeof(v27));
  *(void *)uint64_t v26 = 0;
  *a4 = 0;
  uint64_t BrokerString = fe_nnws_CreateBrokerString(a3, (char *)v27);
  if ((BrokerString & 0x80000000) != 0
    || (uint64_t BrokerString = ssftriff_reader_ObjOpen(a1, a2, 2, (const char *)v27, "IGTR", 1031, (uint64_t *)v26),
        (BrokerString & 0x80000000) != 0))
  {
    uint64_t v21 = BrokerString;
  }
  else
  {
    uint64_t v16 = (char *)heap_Calloc(*(void **)(a3 + 8), 1, 1600);
    *a4 = v16;
    if (v16)
    {
      uint64_t v21 = igtree_Init(a1, a2, *(uint64_t *)v26, v16);
      ssftriff_reader_CloseChunk(*(uint64_t *)v26);
      if ((v21 & 0x80001FFF) == 0x14)
      {
        ssftriff_reader_CloseChunk(*(uint64_t *)v26);
        uint64_t v21 = 0;
      }
    }
    else
    {
      log_OutPublic(*(void *)(a3 + 32), (uint64_t)"FE_NNWS", 37000, 0, v17, v18, v19, v20, v25);
      uint64_t v21 = 2588942346;
    }
  }
  if (*(void *)v26)
  {
    int v22 = ssftriff_reader_ObjClose(*(void **)v26, v9, v10, v11, v12, v13, v14, v15);
    if (v22 >= 0 || (int)v21 <= -1) {
      return v21;
    }
    else {
      return v22;
    }
  }
  return v21;
}

uint64_t fe_nnws_dynamic_feat(void *a1, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5)
{
  unsigned int v6 = a4;
  uint64_t v63 = *MEMORY[0x263EF8340];
  char v62 = 0;
  long long v60 = 0u;
  long long v61 = 0u;
  uint64_t v56 = 0;
  uint64_t v57 = 0;
  int v59 = 0;
  uint64_t v58 = 0;
  uint64_t v10 = *(const char **)(a2 + 56 * a4);
  uint64_t result = strcmp(v10, "NUM");
  if (result && (uint64_t result = strcmp(v10, "ENG"), result))
  {
    uint64_t v53 = (float *)a5;
    uint64_t v54 = a1;
    uint64_t v12 = (const char **)(a2 + 56 * v6 - 56);
    uint64_t v13 = 8;
    unsigned int v14 = 1;
    do
    {
      if (v14 < v6)
      {
        uint64_t v15 = *v12;
        uint64_t result = strcmp(*v12, "NUM");
        if (result)
        {
          uint64_t result = strcmp(v15, "ENG");
          if (result) {
            *(_DWORD *)((char *)&v56 + v13) = 1;
          }
        }
      }
      ++v14;
      v13 -= 4;
      v12 -= 7;
    }
    while (v13 != -4);
    uint64_t v16 = 0;
    uint64_t v17 = (const char **)(a2 + 56 * v6 + 56);
    do
    {
      if ((unint64_t)v6 + 1 + v16 < a3)
      {
        uint64_t v18 = *v17;
        uint64_t result = strcmp(*v17, "NUM");
        if (result)
        {
          uint64_t result = strcmp(v18, "ENG");
          if (result) {
            *((_DWORD *)&v58 + v16) = 1;
          }
        }
      }
      ++v16;
      v17 += 7;
    }
    while (v16 != 3);
    int v19 = v57;
    if (v57 == 1)
    {
      uint64_t v21 = v53;
      uint64_t v20 = v54;
      if (v6)
      {
        unsigned int v22 = v6 - 1;
        do
        {
          __strcat_chk();
          ++v22;
        }
        while (v6 >= (unsigned __int16)v22);
      }
      uint64_t result = (*(uint64_t (**)(void, void, long long *, unsigned char *))(v54[16] + 56))(v54[21], v54[22], &v60, v55);
      float v23 = 0.0;
      if ((int)result >= 0) {
        float v23 = 1.0;
      }
      *uint64_t v53 = v23;
      long long v60 = 0u;
      long long v61 = 0u;
      char v62 = 0;
    }
    else
    {
      uint64_t v21 = v53;
      uint64_t v20 = v54;
      *uint64_t v53 = 0.0;
    }
    int v24 = v58;
    if (v58 == 1)
    {
      unsigned int v25 = v6;
      do
      {
        __strcat_chk();
        ++v25;
      }
      while (v6 + 2 > (unsigned __int16)v25);
      uint64_t result = (*(uint64_t (**)(void, void, long long *, unsigned char *))(v20[16] + 56))(v20[21], v20[22], &v60, v55);
      float v26 = 0.0;
      if ((int)result >= 0) {
        float v26 = 1.0;
      }
      v21[1] = v26;
      long long v60 = 0u;
      long long v61 = 0u;
      char v62 = 0;
    }
    else
    {
      v21[1] = 0.0;
    }
    BOOL v27 = v19 == 1 && HIDWORD(v56) == 1;
    char v28 = v27;
    if (v27)
    {
      unsigned int v29 = v6 - 2;
      if (v6 >= 2)
      {
        do
        {
          __strcat_chk();
          ++v29;
        }
        while (v6 >= (unsigned __int16)v29);
      }
      uint64_t result = (*(uint64_t (**)(void, void, long long *, unsigned char *))(v20[16] + 56))(v20[21], v20[22], &v60, v55);
      float v30 = 0.0;
      if ((int)result >= 0) {
        float v30 = 1.0;
      }
      _OWORD v21[2] = v30;
      long long v60 = 0u;
      long long v61 = 0u;
      char v62 = 0;
    }
    else
    {
      _OWORD v21[2] = 0.0;
    }
    BOOL v31 = v19 == 1 && v24 == 1;
    char v32 = v31;
    if (v31)
    {
      unsigned int v33 = v6 - 1;
      if (v6 + 2 > (unsigned __int16)(v6 - 1))
      {
        do
        {
          __strcat_chk();
          ++v33;
        }
        while (v6 + 2 > (unsigned __int16)v33);
      }
      uint64_t result = (*(uint64_t (**)(void, void, long long *, unsigned char *))(v20[16] + 56))(v20[21], v20[22], &v60, v55);
      float v34 = 0.0;
      if ((int)result >= 0) {
        float v34 = 1.0;
      }
      v21[3] = v34;
      long long v60 = 0u;
      long long v61 = 0u;
      char v62 = 0;
    }
    else
    {
      v21[3] = 0.0;
    }
    int v35 = HIDWORD(v58);
    BOOL v36 = v24 == 1 && HIDWORD(v58) == 1;
    char v37 = v36;
    if (v36)
    {
      unsigned int v38 = v6;
      do
      {
        __strcat_chk();
        ++v38;
      }
      while (v6 + 3 > (unsigned __int16)v38);
      uint64_t result = (*(uint64_t (**)(void, void, long long *, unsigned char *))(v54[16] + 56))(v54[21], v54[22], &v60, v55);
      float v39 = 0.0;
      if ((int)result >= 0) {
        float v39 = 1.0;
      }
      uint64_t v21 = v53;
      v53[4] = v39;
      long long v60 = 0u;
      long long v61 = 0u;
      char v62 = 0;
    }
    else
    {
      v21[4] = 0.0;
    }
    if (v56 == 1) {
      char v40 = v28;
    }
    else {
      char v40 = 0;
    }
    if (v40)
    {
      unsigned int v41 = v6 - 3;
      if (v6 >= 3)
      {
        do
        {
          __strcat_chk();
          ++v41;
        }
        while (v6 >= (unsigned __int16)v41);
      }
      uint64_t result = (*(uint64_t (**)(void, void, long long *, unsigned char *))(v54[16] + 56))(v54[21], v54[22], &v60, v55);
      float v42 = 0.0;
      if ((int)result >= 0) {
        float v42 = 1.0;
      }
      v21[5] = v42;
      long long v60 = 0u;
      long long v61 = 0u;
      char v62 = 0;
    }
    else
    {
      v21[5] = 0.0;
    }
    if (v24 == 1) {
      char v43 = v28;
    }
    else {
      char v43 = 0;
    }
    if (v43)
    {
      unsigned int v44 = v6 - 2;
      if (v6 + 2 > (unsigned __int16)(v6 - 2))
      {
        do
        {
          __strcat_chk();
          ++v44;
        }
        while (v6 + 2 > (unsigned __int16)v44);
      }
      uint64_t result = (*(uint64_t (**)(void, void, long long *, unsigned char *))(v54[16] + 56))(v54[21], v54[22], &v60, v55);
      float v45 = 0.0;
      if ((int)result >= 0) {
        float v45 = 1.0;
      }
      v21[6] = v45;
      long long v60 = 0u;
      long long v61 = 0u;
      char v62 = 0;
    }
    else
    {
      v21[6] = 0.0;
    }
    if (v35 == 1) {
      char v46 = v32;
    }
    else {
      char v46 = 0;
    }
    if (v46)
    {
      unsigned int v47 = v6 - 1;
      uint64_t v48 = v54;
      if (v6 + 3 > (unsigned __int16)(v6 - 1))
      {
        do
        {
          __strcat_chk();
          ++v47;
        }
        while (v6 + 3 > (unsigned __int16)v47);
      }
      uint64_t result = (*(uint64_t (**)(void, void, long long *, unsigned char *))(v54[16] + 56))(v54[21], v54[22], &v60, v55);
      float v49 = 0.0;
      if ((int)result >= 0) {
        float v49 = 1.0;
      }
      v21[7] = v49;
      long long v60 = 0u;
      long long v61 = 0u;
      char v62 = 0;
    }
    else
    {
      v21[7] = 0.0;
      uint64_t v48 = v54;
    }
    if (v59 == 1) {
      char v50 = v37;
    }
    else {
      char v50 = 0;
    }
    if (v50)
    {
      unsigned int v51 = v6 + 4;
      do
      {
        __strcat_chk();
        ++v6;
      }
      while (v51 > (unsigned __int16)v6);
      uint64_t result = (*(uint64_t (**)(void, void, long long *, unsigned char *))(v48[16] + 56))(v48[21], v48[22], &v60, v55);
      float v52 = 0.0;
      if ((int)result >= 0) {
        float v52 = 1.0;
      }
      v21[8] = v52;
    }
    else
    {
      v21[8] = 0.0;
    }
  }
  else
  {
    *(_DWORD *)(a5 + 32) = 0;
    *(_OWORD *)a5 = 0u;
    *(_OWORD *)(a5 + 16) = 0u;
  }
  return result;
}

uint64_t fe_nnws_addon_lookup(void *a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t *a5, void *a6, unsigned __int16 a7)
{
  uint64_t v11 = *a5;
  __int16 v62 = 0;
  uint64_t v61 = 0;
  char v60 = 0;
  unsigned int v59 = a7;
  unsigned int v55 = a7 + 1;
  int __dst = (unsigned char *)heap_Calloc(*(void **)(*a1 + 8), 1, v55);
  if (!__dst)
  {
    log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_NNWS", 75000, 0, v12, v13, v14, v15, v47);
    return 2588942346;
  }
  if (!a3)
  {
    uint64_t v17 = 1;
    goto LABEL_44;
  }
  uint64_t v48 = v11;
  float v49 = a6;
  unsigned int v16 = 0;
  char v50 = a6 + 1;
  unsigned int v51 = a6 + 3;
  unint64_t v58 = a3;
  uint64_t v17 = 1;
  uint64_t v52 = a4;
  unsigned int v53 = a3;
  while (1)
  {
    unsigned int v18 = 0;
    uint64_t v19 = 56 * v16;
    uint64_t v20 = *(unsigned int *)(a2 + v19 + 12);
    unsigned int v21 = v16 + 1;
    if (a3 <= v16 + 1) {
      unsigned int v22 = v16 + 1;
    }
    else {
      unsigned int v22 = a3;
    }
    float v23 = (_DWORD *)(a2 + 16 + v19);
    unint64_t v57 = v16;
    unint64_t v24 = v16;
    while (1)
    {
      unsigned int v25 = (const char *)*((void *)v23 - 2);
      if (!strcmp(v25, "NUM")) {
        break;
      }
      if (!strcmp(v25, "ENG")) {
        break;
      }
      unsigned int v26 = *v23 + v18;
      if (v26 > v59) {
        break;
      }
      ++v24;
      v23 += 14;
      unsigned int v18 = v26;
      if (v24 >= v58)
      {
        unsigned int v18 = v26;
        goto LABEL_14;
      }
    }
    unsigned int v22 = v24;
LABEL_14:
    int v27 = v57;
    if (v57 >= v22)
    {
      __dst[v18] = 0;
      goto LABEL_24;
    }
    memcpy(__dst, (const void *)(a4 + v20), v18 + 1);
    __dst[v18] = 0;
    if (v18) {
      break;
    }
LABEL_24:
    if (v27 == v22) {
      unsigned int v16 = v22 + 1;
    }
    else {
      unsigned int v16 = v22;
    }
    a3 = v53;
    if (v16 >= v53) {
      goto LABEL_44;
    }
  }
  int v28 = 0;
  uint64_t v29 = v22;
  float v30 = (int *)(a2 - 40 + 56 * v22);
  int v31 = v22 - v57 - 2;
  uint64_t v32 = -1;
  uint64_t v33 = 1;
  while (1)
  {
    bzero(&__dst[v18], v55 - v18);
    __dst[v18] = 0;
    __int16 v62 = 0;
    uint64_t v17 = (*(uint64_t (**)(void, void, const char *, unsigned char *, uint64_t *, __int16 *, char *, void))(a1[7] + 232))(a1[8], a1[9], "force_ws", __dst, &v61, &v62, &v60, 0);
    if ((v17 & 0x80000000) != 0) {
      break;
    }
    if (v62)
    {
      uint64_t v35 = *v50;
      int v27 = v57;
      if (v57)
      {
        uint64_t v36 = (v57 - 1);
        uint64_t v38 = v48;
        char v37 = v49;
        uint64_t v39 = *(void *)(v48 + 8 * v36);
        char v40 = v49;
        unsigned int v41 = v21;
        if (v39 == v35 || (char v40 = v51, v39 == v49[2]))
        {
          *(void *)(v48 + 8 * v36) = *v40;
          uint64_t v35 = v49[1];
        }
      }
      else
      {
        uint64_t v38 = v48;
        char v37 = v49;
        unsigned int v41 = v21;
      }
      unsigned int v22 = v29 - v28;
      unsigned int v42 = v29 - v33;
      *(void *)(v38 + 8 * v57) = v35;
      if ((int)v29 - v28 < v53)
      {
        uint64_t v43 = *(void *)(v38 + 8 * v22);
        unsigned int v44 = v50;
        if (v43 == v37[2] || (unsigned int v44 = v37, v43 == *v51)) {
          *(void *)(v38 + 8 * v42) = *v44;
        }
      }
      a4 = v52;
      *(void *)(v38 + 8 * v42) = *v51;
      if (v41 < v42)
      {
        float v45 = (void *)(v38 + 8 * v41);
        do
        {
          *v45++ = v37[2];
          --v31;
        }
        while (v31);
      }
      uint64_t v17 = 1;
      goto LABEL_24;
    }
    ++v28;
    if (v29 != v33 && v29 + v32 > v57)
    {
      int v34 = *v30;
      v30 -= 14;
      ++v33;
      --v32;
      --v31;
      v18 -= v34;
      if (v18) {
        continue;
      }
    }
    unsigned int v22 = v29 - v28;
    a4 = v52;
    int v27 = v57;
    goto LABEL_24;
  }
LABEL_44:
  heap_Free(*(void **)(*a1 + 8), (uint64_t)__dst);
  return v17;
}

uint64_t fe_nnws_adjustBMES_Edge(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t *a5, uint64_t **a6)
{
  unsigned int v7 = a2;
  uint64_t v9 = *a6;
  unint64_t v24 = *a6;
  if (a2 < 2) {
    goto LABEL_26;
  }
  uint64_t v10 = a2 - 2;
  for (uint64_t i = v9; ; ++i)
  {
    unsigned int v12 = *(unsigned __int8 *)i[1];
    if (v12 <= 0x4C)
    {
      if (v12 != 66)
      {
        if (v12 == 69)
        {
          int v13 = *(unsigned __int8 *)*i;
          uint64_t v14 = a5;
          if (v13 == 83) {
            goto LABEL_19;
          }
          uint64_t v14 = a5;
          if (v13 == 69) {
            goto LABEL_19;
          }
        }
        goto LABEL_20;
      }
      int v15 = *(unsigned __int8 *)*i;
      uint64_t v14 = a5 + 2;
      if (v15 == 66) {
        goto LABEL_19;
      }
      uint64_t v14 = a5 + 2;
LABEL_15:
      if (v15 == 77) {
        goto LABEL_19;
      }
      goto LABEL_20;
    }
    if (v12 != 77)
    {
      if (v12 != 83) {
        goto LABEL_20;
      }
      int v15 = *(unsigned __int8 *)*i;
      uint64_t v14 = a5 + 3;
      if (v15 == 66)
      {
LABEL_19:
        i[1] = *v14;
        goto LABEL_20;
      }
      uint64_t v14 = a5 + 3;
      goto LABEL_15;
    }
    int v16 = *(unsigned __int8 *)*i;
    uint64_t v14 = a5 + 1;
    if (v16 == 69) {
      goto LABEL_19;
    }
    uint64_t v14 = a5 + 1;
    if (v16 == 83) {
      goto LABEL_19;
    }
LABEL_20:
    if (!v10) {
      break;
    }
    --v10;
  }
  uint64_t v17 = a5 + 3;
  if (*(unsigned char *)*i == 77 || (uint64_t v17 = a5, *(unsigned char *)i[1] == 66)) {
    i[1] = *v17;
  }
LABEL_26:
  uint64_t result = fe_nnws_adjust_ENP_labels(a2, a3, a5, (uint64_t *)&v24);
  if (a4 == 1 && v7)
  {
    uint64_t v22 = v7;
    do
    {
      uint64_t v23 = *v9++;
      uint64_t result = log_OutText(*(void *)(a1 + 32), (uint64_t)"FE_NNWS", 5, 0, (uint64_t)"[NNWS][adjustBMES_Edge] Predicted Tag: %s", v19, v20, v21, v23);
      --v22;
    }
    while (v22);
  }
  return result;
}

uint64_t fe_nnws_adjustBMES(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t *a5, uint64_t **a6)
{
  unsigned int v7 = a2;
  uint64_t v9 = *a6;
  uint64_t v22 = *a6;
  if (a2)
  {
    uint64_t v10 = (unsigned __int8 **)(v9 + 1);
    for (uint64_t i = a2; i; --i)
    {
      int v12 = **(v10 - 1);
      if (i == 1)
      {
        int v13 = a5 + 3;
        if (v12 != 77)
        {
          int v13 = a5;
          if (v12 != 66) {
            goto LABEL_22;
          }
        }
        goto LABEL_21;
      }
      if (**(v10 - 1) > 0x4Cu)
      {
        if (v12 == 77)
        {
          int v15 = **v10;
          int v13 = a5 + 3;
          if (v15 == 66) {
            goto LABEL_21;
          }
          int v13 = a5 + 3;
LABEL_20:
          if (v15 == 83) {
            goto LABEL_21;
          }
          goto LABEL_22;
        }
        if (v12 == 83)
        {
          int v14 = **v10 | 8;
          int v13 = a5 + 1;
          goto LABEL_14;
        }
      }
      else
      {
        if (v12 == 66)
        {
          int v15 = **v10;
          int v13 = a5;
          if (v15 == 66) {
            goto LABEL_21;
          }
          int v13 = a5;
          goto LABEL_20;
        }
        if (v12 == 69)
        {
          int v14 = **v10 | 8;
          int v13 = a5 + 2;
LABEL_14:
          if (v14 != 77) {
            goto LABEL_22;
          }
LABEL_21:
          *(v10 - 1) = (unsigned __int8 *)*v13;
        }
      }
LABEL_22:
      ++v10;
    }
  }
  uint64_t result = fe_nnws_adjust_ENP_labels(a2, a3, a5, (uint64_t *)&v22);
  if (a4 == 1 && v7)
  {
    uint64_t v20 = v7;
    do
    {
      uint64_t v21 = *v9++;
      uint64_t result = log_OutText(*(void *)(a1 + 32), (uint64_t)"FE_NNWS", 5, 0, (uint64_t)"[NNWS] Predicted Tag: %s", v17, v18, v19, v21);
      --v20;
    }
    while (v20);
  }
  return result;
}

uint64_t fe_nnws_IGTreeProcess(uint64_t *a1, unsigned int a2, uint64_t *a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __s1 = 0;
  uint64_t v8 = *a1;
  uint64_t v9 = a1[23];
  if (!a2 || !v9)
  {
    log_OutText(*(void *)(v8 + 32), (uint64_t)"FE_NNWS", 5, 0, (uint64_t)"IGTree model for NNWS does not exist", a6, a7, a8, v49);
    return 0;
  }
  uint64_t v13 = heap_Alloc(*(void *)(v8 + 8), 8 * *(unsigned __int8 *)(v9 + 1296) - 8);
  if (!v13)
  {
    uint64_t v41 = 2588942346;
    log_OutPublic(*(void *)(v8 + 32), (uint64_t)"FE_NNWS", 750000, 0, v14, v15, v16, v17, v49);
    return v41;
  }
  uint64_t v18 = (char **)v13;
  uint64_t v54 = a5;
  if (*(unsigned char *)(v9 + 1296) != 1)
  {
    uint64_t v19 = (unsigned __int16)(*(unsigned __int8 *)(v9 + 1296) - 1);
    uint64_t v20 = (void *)v13;
    do
    {
      uint64_t v21 = (_WORD *)heap_Calloc(*(void **)(v8 + 8), 1, 65);
      *uint64_t v20 = v21;
      if (!v21)
      {
        uint64_t v41 = 2588942346;
        log_OutPublic(*(void *)(v8 + 32), (uint64_t)"FE_NNWS", 750000, 0, v22, v23, v24, v25, v49);
        goto LABEL_57;
      }
      _WORD *v21 = 61;
      ++v20;
      --v19;
    }
    while (v19);
  }
  uint64_t v26 = 0;
  uint64_t v52 = a3 + 2;
  unsigned int v53 = a3;
  char v50 = a3 + 3;
  unsigned int v51 = a3 + 1;
  int v27 = v54;
  do
  {
    int v28 = *(const char ***)(v9 + 1312);
    unsigned int v29 = *(unsigned __int8 *)(v9 + 1296);
    uint64_t v30 = fe_nnws_setFeature(v8, v28, v29, 0, v18, *(const char **)(*v27 + 8 * (unsigned __int16)v26));
    if ((v30 & 0x80000000) != 0) {
      goto LABEL_55;
    }
    int v31 = "=";
    if ((unsigned __int16)a2 > (unsigned __int16)v26) {
      int v31 = *(const char **)(a4 + 56 * (unsigned __int16)v26);
    }
    uint64_t v30 = fe_nnws_setFeature(v8, v28, v29, 1, v18, v31);
    if ((v30 & 0x80000000) != 0) {
      goto LABEL_55;
    }
    uint64_t v32 = "=";
    if ((unsigned __int16)v26 - 1 < (unsigned __int16)a2) {
      uint64_t v32 = *(const char **)(a4 + 56 * ((unsigned __int16)v26 - 1));
    }
    uint64_t v30 = fe_nnws_setFeature(v8, v28, v29, 2, v18, v32);
    if ((v30 & 0x80000000) != 0) {
      goto LABEL_55;
    }
    uint64_t v33 = "=";
    if ((unsigned __int16)v26 - 2 < (unsigned __int16)a2) {
      uint64_t v33 = *(const char **)(a4 + 56 * ((unsigned __int16)v26 - 2));
    }
    uint64_t v30 = fe_nnws_setFeature(v8, v28, v29, 3, v18, v33);
    if ((v30 & 0x80000000) != 0) {
      goto LABEL_55;
    }
    int v34 = "=";
    if ((unsigned __int16)v26 - 3 < (unsigned __int16)a2) {
      int v34 = *(const char **)(a4 + 56 * ((unsigned __int16)v26 - 3));
    }
    uint64_t v30 = fe_nnws_setFeature(v8, v28, v29, 4, v18, v34);
    if ((v30 & 0x80000000) != 0) {
      goto LABEL_55;
    }
    uint64_t v35 = "=";
    if ((unsigned __int16)v26 - 4 < (unsigned __int16)a2) {
      uint64_t v35 = *(const char **)(a4 + 56 * ((unsigned __int16)v26 - 4));
    }
    uint64_t v30 = fe_nnws_setFeature(v8, v28, v29, 5, v18, v35);
    if ((v30 & 0x80000000) != 0) {
      goto LABEL_55;
    }
    uint64_t v36 = "=";
    if ((unsigned __int16)v26 + 1 < (unsigned __int16)a2) {
      uint64_t v36 = *(const char **)(a4 + 56 * ((unsigned __int16)v26 + 1));
    }
    uint64_t v30 = fe_nnws_setFeature(v8, v28, v29, 6, v18, v36);
    if ((v30 & 0x80000000) != 0) {
      goto LABEL_55;
    }
    char v37 = "=";
    if ((unsigned __int16)v26 + 2 < (unsigned __int16)a2) {
      char v37 = *(const char **)(a4 + 56 * ((unsigned __int16)v26 + 2));
    }
    uint64_t v30 = fe_nnws_setFeature(v8, v28, v29, 7, v18, v37);
    if ((v30 & 0x80000000) != 0) {
      goto LABEL_55;
    }
    uint64_t v38 = "=";
    if ((unsigned __int16)v26 + 3 < (unsigned __int16)a2) {
      uint64_t v38 = *(const char **)(a4 + 56 * ((unsigned __int16)v26 + 3));
    }
    uint64_t v30 = fe_nnws_setFeature(v8, v28, v29, 8, v18, v38);
    if ((v30 & 0x80000000) != 0) {
      goto LABEL_55;
    }
    uint64_t v39 = "=";
    if ((unsigned __int16)v26 + 4 < (unsigned __int16)a2) {
      uint64_t v39 = *(const char **)(a4 + 56 * ((unsigned __int16)v26 + 4));
    }
    uint64_t v30 = fe_nnws_setFeature(v8, v28, v29, 9, v18, v39);
    if ((v30 & 0x80000000) != 0)
    {
LABEL_55:
      uint64_t v41 = v30;
      goto LABEL_57;
    }
    char v40 = "=";
    if ((unsigned __int16)v26 < a2)
    {
      char v40 = v57;
      LH_itoa((unsigned __int16)v26 + 1, v57, 0xAu);
    }
    uint64_t v41 = fe_nnws_setFeature(v8, v28, v29, 10, v18, v40);
    int v27 = v54;
    if ((v41 & 0x80000000) != 0) {
      goto LABEL_57;
    }
    igtree_Process(v9, (uint64_t)v18, &__s1);
    unsigned int v42 = __s1;
    if (strcmp(__s1, "NOMATCH"))
    {
      uint64_t v41 = 0;
      unsigned int v43 = *v42;
      if (v43 <= 0x4C)
      {
        unsigned int v44 = v51;
        if (v43 != 66)
        {
          if (v43 != 69) {
            goto LABEL_48;
          }
          unsigned int v44 = v50;
        }
LABEL_47:
        *(void *)(*v54 + 8 * v26) = *v44;
        fe_hlp_adjustBMES_basedSingleLabel(a2, v26, v53, v54);
        uint64_t v41 = 0;
        goto LABEL_48;
      }
      unsigned int v44 = v52;
      if (v43 == 77) {
        goto LABEL_47;
      }
      unsigned int v44 = v53;
      if (v43 == 83) {
        goto LABEL_47;
      }
    }
LABEL_48:
    ++v26;
  }
  while (a2 != v26);
  if (*(unsigned char *)(v9 + 1296) != 1)
  {
    uint64_t v45 = (unsigned __int16)(*(unsigned __int8 *)(v9 + 1296) - 1);
    char v46 = (uint64_t *)v18;
    do
    {
      uint64_t v47 = *v46++;
      heap_Free(*(void **)(v8 + 8), v47);
      --v45;
    }
    while (v45);
  }
LABEL_57:
  heap_Free(*(void **)(v8 + 8), (uint64_t)v18);
  return v41;
}

void **fe_nnws_retag_word_under_phon(void **result, uint64_t *a2, unsigned int *a3, void *a4)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *a3;
  unsigned int v6 = *result;
  if (v5 >= 2)
  {
    unsigned int v7 = (_DWORD *)(v4 + 96);
    uint64_t v8 = 8 * v5;
    uint64_t v9 = 8;
    while (1)
    {
      if (*(v7 - 13) != 1 || v7[1] != 1) {
        goto LABEL_19;
      }
      int v10 = *(v7 - 14);
      if (v10 == 1)
      {
        if (!*v7)
        {
          uint64_t v12 = a4[1];
LABEL_16:
          v6[(unint64_t)v9 / 8] = v12;
          uint64_t v13 = a4;
LABEL_17:
          if (v9 == 8) {
            *unsigned int v6 = *v13;
          }
          goto LABEL_19;
        }
        if (*v7 == 1)
        {
          uint64_t v12 = *a4;
          goto LABEL_16;
        }
      }
      else if (!v10)
      {
        if (!*v7)
        {
          uint64_t v11 = a4[2];
          goto LABEL_14;
        }
        if (*v7 == 1)
        {
          uint64_t v11 = a4[3];
LABEL_14:
          v6[(unint64_t)v9 / 8] = v11;
          uint64_t v13 = a4 + 1;
          goto LABEL_17;
        }
      }
LABEL_19:
      v9 += 8;
      v7 += 14;
      if (v8 == v9) {
        return result;
      }
    }
  }
  if (*(_DWORD *)(v4 + 44) == 1) {
    *unsigned int v6 = *a4;
  }
  return result;
}

uint64_t fe_nnws_group(uint64_t a1, uint64_t a2, uint64_t *a3, unsigned int *a4, const char **a5)
{
  uint64_t v7 = *a3;
  uint64_t v8 = *a5;
  uint64_t v9 = *a4;
  uint64_t v81 = (uint64_t)*a5;
  unsigned int v74 = strlen(*a5);
  uint64_t v75 = a4;
  if (v9)
  {
    uint64_t v14 = 0;
    int v15 = 0;
    uint64_t v16 = 0;
    unsigned int v17 = 0;
    uint64_t v18 = v7 + 32;
    uint64_t v78 = a2;
    uint64_t v79 = v9;
    while (1)
    {
      int v19 = **(unsigned __int8 **)(a2 + 8 * v14);
      switch(v19)
      {
        case 'B':
          uint64_t v41 = v7 + 56 * v17;
          *(void *)(v41 + 8) = *(void *)(v18 - 24);
          *(_DWORD *)(v41 + 32) = *(_DWORD *)v18;
          uint64_t v16 = v14;
          break;
        case 'S':
          uint64_t v77 = v16;
          uint64_t v42 = *(unsigned int *)(v18 - 16);
          unsigned int v43 = (const char **)(v7 + 56 * v17);
          unsigned int v44 = (char *)*v43;
          if (!strcmp(*v43, "NUM"))
          {
            if ((v42 - 4) < 0xFFFFFFFB) {
              goto LABEL_23;
            }
          }
          else if (!strcmp(v44, "ENG") && (v42 - 4) < 0xFFFFFFFB)
          {
LABEL_23:
            uint64_t v47 = heap_Realloc(*(uint64_t **)(a1 + 8), (uint64_t)v44, v42 + 1);
            *unsigned int v43 = (const char *)v47;
            if (!v47)
            {
LABEL_60:
              uint64_t v70 = 2588942346;
              uint64_t v71 = *(void *)(a1 + 32);
              goto LABEL_62;
            }
            unsigned int v44 = (char *)v47;
            unsigned int v48 = *(_DWORD *)(v18 - 16);
            goto LABEL_26;
          }
          if (*(_DWORD *)(v7 + 56 * v17 + 16) < (v42 + 1)) {
            goto LABEL_23;
          }
          unsigned int v48 = v42;
LABEL_26:
          strncpy(v44, &v8[*(unsigned int *)(v18 - 20)], v48);
          (*v43)[*(unsigned int *)(v18 - 16)] = 0;
          uint64_t v49 = v7 + 56 * v17;
          int v50 = *(_DWORD *)(v18 - 12);
          *(_DWORD *)(v49 + 16) = v42;
          *(_DWORD *)(v49 + 20) = v50;
          *(void *)(v49 + 8) = *(void *)(v18 - 24);
          *(_DWORD *)(v49 + 40) = *(_DWORD *)(v18 + 8);
          *(void *)(v49 + 32) = *(void *)v18;
          *(_DWORD *)(v49 + 48) = *(_DWORD *)(v18 + 16);
          v15 += v42;
          ++v17;
          a2 = v78;
          uint64_t v9 = v79;
          uint64_t v16 = v77;
          break;
        case 'E':
          uint64_t v20 = v7 + 56 * v16;
          unsigned int v22 = *(_DWORD *)(v20 + 12);
          uint64_t v21 = (unsigned int *)(v20 + 12);
          unsigned int v23 = *(_DWORD *)(v18 - 16) + *(_DWORD *)(v18 - 20);
          size_t v24 = v23 - v22;
          if (v23 < v22)
          {
            log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_NNWS", 75000, 0, v10, v11, v12, v13, a5);
            return 2588942343;
          }
          int v25 = v15;
          uint64_t v26 = (uint64_t *)(v7 + 56 * v17);
          int v27 = (char *)heap_Realloc(*(uint64_t **)(a1 + 8), *v26, (v24 + 1));
          *uint64_t v26 = (uint64_t)v27;
          if (!v27) {
            goto LABEL_60;
          }
          unsigned int v32 = v17;
          uint64_t v33 = v7;
          unsigned int v76 = v32;
          unsigned int v34 = v32;
          strncpy(v27, (const char *)(v81 + *v21), v24);
          unsigned int v35 = v34;
          uint64_t v7 = v33;
          *(unsigned char *)(*v26 + v24) = 0;
          uint64_t v36 = v33 + 56 * v35;
          int v38 = *(_DWORD *)(v36 + 32);
          uint64_t v37 = v36 + 32;
          *(_DWORD *)(v37 - 16) = v24;
          *(void *)(v37 + 4) = *(void *)(v18 + 4);
          int v39 = *(_DWORD *)v18;
          if (v38 == 1 && v39 == 2)
          {
            int v39 = 3;
            int v40 = v25;
            uint64_t v8 = (const char *)v81;
            uint64_t v9 = v79;
            goto LABEL_28;
          }
          int v40 = v25;
          uint64_t v9 = v79;
          if (v39 == 3)
          {
            uint64_t v8 = (const char *)v81;
LABEL_28:
            unsigned int v46 = v76;
          }
          else
          {
            uint64_t v8 = (const char *)v81;
            unsigned int v46 = v76;
            if (v39 != 2) {
              goto LABEL_30;
            }
          }
          *(_DWORD *)uint64_t v37 = v39;
          *(_DWORD *)(v7 + 56 * v35 + 20) = *(_DWORD *)(v18 - 12);
LABEL_30:
          int v15 = v24 + v40;
          unsigned int v17 = v46 + 1;
          uint64_t v16 = v14 + 1;
          a2 = v78;
          break;
      }
      ++v14;
      v18 += 56;
      if (v9 == v14) {
        goto LABEL_34;
      }
    }
  }
  unsigned int v17 = 0;
  int v15 = 0;
LABEL_34:
  int v51 = v15;
  if (v17 < v9)
  {
    uint64_t v52 = (uint64_t *)(v7 + 56 * v17);
    int v53 = v9 - v17;
    do
    {
      uint64_t v54 = *v52;
      v52 += 7;
      heap_Free(*(void **)(a1 + 8), v54);
      --v53;
    }
    while (v53);
  }
  *uint64_t v75 = v17;
  uint64_t v55 = v51 + v17;
  if ((int)v55 + 1 <= v74)
  {
    uint64_t v56 = v81;
    if (v17)
    {
LABEL_40:
      unsigned int v57 = 0;
      unint64_t v58 = (const void **)(v7 + 16);
      uint64_t v59 = v17;
      do
      {
        unsigned int v60 = v57;
        memcpy((void *)(v56 + v57), *(v58 - 2), *(unsigned int *)v58);
        *(unsigned char *)(v56 + *(_DWORD *)v58 + v60) = 32;
        int v62 = *(_DWORD *)v58;
        v58 += 7;
        int v61 = v62;
        unsigned int v57 = v60 + v62 + 1;
        --v59;
      }
      while (v59);
      if (v57) {
        *(unsigned char *)(v56 + v60 + v61) = 0;
      }
      LODWORD(v63) = 0;
      *a5 = (const char *)v56;
      do
      {
        if (*(_DWORD *)(v7 + 56 * v63 + 32) == 1)
        {
          uint64_t v64 = v63;
          uint64_t v65 = v63;
          if (v63 < v17)
          {
            uint64_t v66 = 0;
            int v67 = (int *)(v7 + 88 + 56 * v64);
            do
            {
              *(v67 - 14) = 4;
              ++v66;
              int v68 = *v67;
              v67 += 14;
            }
            while (v68 != 2 && v66 + v64 < (unint64_t)v17);
            uint64_t v63 = v64 + v66;
            uint64_t v65 = v63;
          }
          *(void *)(v7 + 56 * v65 + 8) = *(void *)(v7 + 56 * v64 + 8);
        }
        else
        {
          LODWORD(v63) = v63 + 1;
        }
      }
      while (v63 < v17);
      return 0;
    }
LABEL_59:
    uint64_t v70 = 0;
    *a5 = (const char *)v56;
    return v70;
  }
  uint64_t v56 = heap_Realloc(*(uint64_t **)(a1 + 8), v81, v55);
  if (v56)
  {
    if (v17) {
      goto LABEL_40;
    }
    goto LABEL_59;
  }
  uint64_t v70 = 2588942346;
  uint64_t v71 = *(void *)(a1 + 32);
LABEL_62:
  log_OutPublic(v71, (uint64_t)"FE_NNWS", 75000, 0, v28, v29, v30, v31, a5);
  return v70;
}

uint64_t fe_nnws_writeLDB_v2(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7)
{
  unsigned int v10 = a4;
  uint64_t v163 = 0;
  int v162 = 0;
  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, long long **, int *))(a1[6] + 176))(a2, a3, a4, 1, &v163, &v162);
  if ((v14 & 0x80000000) != 0) {
    return v14;
  }
  uint64_t v160 = a3;
  unsigned int v161 = v10;
  reorder_pMrk(&v163, (unsigned __int16)v162, 40);
  reorder_pMrk(&v163, (unsigned __int16)v162, 1);
  if (a6)
  {
    uint64_t v15 = heap_Calloc(*(void **)(*a1 + 8), a6, 32);
    uint64_t v20 = *a1;
    if (!v15)
    {
      uint64_t v27 = 2588942346;
      log_OutPublic(*(void *)(v20 + 32), (uint64_t)"FE_NNWS", 75000, 0, v16, v17, v18, v19, v159);
      return v27;
    }
    uint64_t v21 = v15;
    uint64_t v26 = heap_Calloc(*(void **)(v20 + 8), a6, 4);
    if (!v26)
    {
      uint64_t v27 = 2588942346;
      log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_NNWS", 75000, 0, v22, v23, v24, v25, v159);
      uint64_t v28 = 0;
LABEL_180:
      heap_Free(*(void **)(*a1 + 8), v21);
      goto LABEL_181;
    }
  }
  else
  {
    uint64_t v21 = 0;
    uint64_t v26 = 0;
  }
  int v29 = (unsigned __int16)v162;
  uint64_t v30 = v163;
  if ((_WORD)v162)
  {
    uint64_t v31 = 0;
    unsigned int v32 = v163;
    while (1)
    {
      int v34 = *(_DWORD *)v32;
      v32 += 2;
      int v33 = v34;
      if (v34 == 41 || v33 == 1) {
        break;
      }
      if ((unsigned __int16)v162 == ++v31)
      {
        LODWORD(v31) = -1;
        break;
      }
    }
    uint64_t v36 = 0;
    unsigned int v37 = v31 & ~((int)v31 >> 31);
    int v38 = v163;
    while (1)
    {
      int v39 = *(_DWORD *)v38;
      v38 += 2;
      if (v39 == 40) {
        break;
      }
      if ((unsigned __int16)v162 == ++v36) {
        goto LABEL_22;
      }
    }
    int v40 = v36;
    if (a6) {
      goto LABEL_50;
    }
LABEL_23:
    if (!(_WORD)v162) {
      goto LABEL_81;
    }
    goto LABEL_24;
  }
  unsigned int v37 = 0;
LABEL_22:
  int v40 = -1;
  if (!a6) {
    goto LABEL_23;
  }
LABEL_50:
  uint64_t v59 = 0;
  int v60 = 0;
  int v61 = *((_DWORD *)v163 + 3);
  int v62 = (_DWORD *)&v163[2 * v37] + 1;
  do
  {
    uint64_t v63 = a5 + 56 * v59;
    int v66 = *(_DWORD *)(v63 + 32);
    uint64_t v65 = (_DWORD *)(v63 + 32);
    int v64 = v66;
    uint64_t v67 = v21 + 32 * v59;
    if (v66 == 4)
    {
      v60 += *(_DWORD *)(a5 + 56 * v59 + 16) + 1;
      *(_DWORD *)uint64_t v67 = 0;
      goto LABEL_79;
    }
    *(_DWORD *)(v67 + 4) = *v62 + *(_DWORD *)(a5 + 56 * v59 + 8);
    if ((v64 & 0xFFFFFFFE) == 2)
    {
      int v68 = *(_DWORD *)(a5 + 56 * v59 + 20);
      int v69 = *(_DWORD *)(a5 + 56 * v59 + 16) + v60;
    }
    else
    {
      int v68 = *(_DWORD *)(a5 + 56 * v59 + 16);
      int v69 = v68;
    }
    uint64_t v70 = v21 + 32 * v59;
    *(_DWORD *)(v70 + 8) = v68;
    uint64_t v71 = (_DWORD *)(v70 + 8);
    int v72 = v61;
    if (v59) {
      int v72 = *(_DWORD *)(v70 - 20) + *(_DWORD *)(v70 - 16) + 1;
    }
    *(_DWORD *)(v70 + 12) = v72;
    int v73 = (int *)(v70 + 12);
    v73[1] = v69;
    unsigned int v74 = v73 + 1;
    if (v64 != 5 || v40 == -1)
    {
      *(_DWORD *)uint64_t v67 = 1;
      goto LABEL_73;
    }
    unsigned int v76 = &v30[2 * v40];
    long long v77 = v76[1];
    *(_OWORD *)uint64_t v67 = *v76;
    *(_OWORD *)(v67 + 16) = v77;
    int v78 = *(_DWORD *)(a5 + 56 * v59 + 16);
    _DWORD *v71 = v78;
    int v79 = v61;
    if (v59) {
      int v79 = *(_DWORD *)(v21 + 32 * v59 - 20) + *(_DWORD *)(v21 + 32 * v59 - 16) + 1;
    }
    int *v73 = v79;
    *unsigned int v74 = v78;
    if (v40 + 1 < v29)
    {
      uint64_t v80 = &v30[2 * ++v40];
      while (1)
      {
        int v81 = *(_DWORD *)v80;
        v80 += 2;
        if (v81 == 40) {
          break;
        }
        if (v29 == ++v40)
        {
          int v40 = -1;
          break;
        }
      }
    }
    int v82 = *(_DWORD *)v67;
    if (v82 != 40)
    {
      if (v82 != 1) {
        goto LABEL_75;
      }
LABEL_73:
      if (*(_DWORD *)(a5 + 56 * v59 + 36) != 1) {
        goto LABEL_75;
      }
    }
    *(_DWORD *)(v26 + 4 * v59) = 1;
LABEL_75:
    if ((*v65 & 0xFFFFFFFE) == 2 && !*(_DWORD *)(a5 + 56 * v59 + 40)) {
      *(_DWORD *)(v26 + 4 * v59) = 2;
    }
    int v60 = 0;
    int v83 = *v73 - *((_DWORD *)v30 + 3);
    uint64_t v84 = a5 + 56 * v59;
    *(_DWORD *)(v84 + 24) = v83;
    *(_DWORD *)(v84 + 28) = *v74 + v83;
LABEL_79:
    ++v59;
  }
  while (v59 != a6);
  uint64_t v30 = v163;
  if (!v29)
  {
LABEL_81:
    LOWORD(v162) = 0;
    goto LABEL_83;
  }
LABEL_24:
  unint64_t v41 = 0;
  unsigned __int16 v42 = v29;
  do
  {
    unint64_t v43 = v42;
    unsigned int v44 = &v30[2 * v41];
    if (*(_DWORD *)v44 == 40)
    {
      unint64_t v45 = v41 + 1;
      if (v42 > v41 + 1)
      {
        int v51 = &v30[2 * v45];
        if (*(_DWORD *)v51 == 1 && HIDWORD(v30[2 * v41]) == *((_DWORD *)v51 + 3))
        {
          memmove(v44, v51, 32 * (v42-- - v45));
          unint64_t v43 = v42;
        }
      }
    }
    else if (*(_DWORD *)v44 == 99)
    {
      unint64_t v45 = v41 + 1;
      if (v41 + 1 < v42)
      {
        unsigned int v46 = &v30[2 * v41];
        int v49 = *((_DWORD *)v46 + 3);
        uint64_t v47 = (_DWORD *)v46 + 3;
        int v48 = v49;
        int v50 = HIDWORD(v30[2 * v45]);
        if (v49 == v50 - 1 && *(unsigned char *)(a7 + (v48 - *((_DWORD *)v30 + 3))) == 32)
        {
          *uint64_t v47 = v50;
          DWORD1(v30[2 * v41]) = DWORD1(v30[2 * v45]);
        }
      }
    }
    else
    {
      unint64_t v45 = v41 + 1;
    }
    unint64_t v41 = v45;
  }
  while (v45 < v43);
  LOWORD(v162) = v42;
  if (v42)
  {
    int v52 = 0;
    int v29 = 0;
    int v53 = v163;
    uint64_t v54 = v42;
    do
    {
      int v56 = *(_DWORD *)v53;
      v53 += 2;
      int v55 = v56;
      if (v52) {
        int v57 = v29;
      }
      else {
        int v57 = v29 + 1;
      }
      if (v55 == 0x4000)
      {
        int v58 = 1;
      }
      else
      {
        int v57 = v29 + 1;
        int v58 = v52;
      }
      if (v55 != 1)
      {
        int v29 = v57;
        int v52 = v58;
      }
      --v54;
    }
    while (v54);
  }
  else
  {
    int v29 = 0;
  }
LABEL_83:
  unsigned int v85 = v29 + a6;
  unint64_t v86 = (_DWORD *)heap_Alloc(*(void *)(*a1 + 8), 32 * (v29 + a6));
  uint64_t v28 = v86;
  if (v86)
  {
    unsigned int v91 = (unsigned __int16)v162;
    if ((_WORD)v162)
    {
      int v92 = 0;
      int v93 = 0;
      unsigned int v94 = 0;
      unsigned int v95 = 0;
      int v96 = 0;
      int v97 = 0;
      unsigned int v98 = 0;
      unsigned int v99 = 0;
      uint64_t v100 = v163;
      unsigned int v159 = v86 + 36;
      int v101 = 1;
      int v102 = 1;
      while (1)
      {
        int v103 = &v100[2 * v99];
        if (*(_DWORD *)v103 == 0x4000)
        {
          if (!v93)
          {
            unsigned int v104 = &v86[8 * v95];
            long long v105 = v103[1];
            *(_OWORD *)unsigned int v104 = *v103;
            *((_OWORD *)v104 + 1) = v105;
            int v106 = v104[1];
            if (v106) {
              int v106 = *((_DWORD *)a1 + 27);
            }
            else {
              a1[13] = 0;
            }
            v86[8 * v95 + 3] = v106;
            int v96 = v106 - HIDWORD(v100[2 * v99]);
            ++v95;
          }
          ++v99;
          int v93 = 1;
          goto LABEL_141;
        }
        if (*(_DWORD *)v103 == 1)
        {
          if (v102 == 1) {
            int v92 = DWORD1(v100[2 * v99]);
          }
          int v102 = 0;
          goto LABEL_113;
        }
        if (v98 < a6)
        {
          uint64_t v107 = v21 + 32 * v98;
          uint64_t v108 = (_DWORD *)(v107 + 12);
          uint64_t v109 = &v100[2 * v99];
          int v111 = *((_DWORD *)v109 + 3);
          uint64_t v110 = (_DWORD *)v109 + 3;
          if (*(_DWORD *)(v107 + 12) < (v111 + v97))
          {
            unsigned int v112 = &v86[8 * v95];
            long long v113 = *(_OWORD *)(v107 + 16);
            *(_OWORD *)unsigned int v112 = *(_OWORD *)v107;
            *((_OWORD *)v112 + 1) = v113;
            unsigned int v114 = *v108 + v96;
            v112[3] = v114;
            if (v95)
            {
              uint64_t v115 = v95 - 1;
              if (v95 == 1)
              {
                int v116 = v86[1];
                goto LABEL_122;
              }
              unsigned int v123 = v86[8 * v95 - 8];
              if (v123 <= 0x28 && ((1 << v123) & 0x10020000002) != 0)
              {
                int v116 = v86[8 * v115 + 2] + v86[8 * v115 + 1];
LABEL_122:
                int v124 = &v86[8 * v95];
                v124[1] = v116;
                uint64_t v125 = v124 + 1;
                int v126 = *(_DWORD *)(v26 + 4 * v98);
                if (v126 == 2)
                {
                  if (*v108 - v97 != *v110) {
                    ++v97;
                  }
                  if (!v95) {
                    goto LABEL_136;
                  }
LABEL_126:
                  if (v86[8 * v95 - 8] == 29)
                  {
                    unint64_t v127 = &v86[8 * v95 - 8];
                    unsigned int v130 = v127[3];
                    unsigned __int16 v128 = v127 + 3;
                    unsigned int v129 = v130;
                    if (v114 > v130) {
                      _DWORD *v128 = v129 + 1;
                    }
                  }
                  if (v101 == 1)
                  {
                    *uint64_t v125 = v92;
                    if (v95 == 2)
                    {
                      uint64_t v125 = v86 + 9;
                      if (v86[8] == 36) {
LABEL_137:
                      }
                        *uint64_t v125 = v92;
                    }
                  }
                }
                else
                {
                  if (!v126) {
                    ++v97;
                  }
                  if (v95) {
                    goto LABEL_126;
                  }
LABEL_136:
                  if (v101 == 1) {
                    goto LABEL_137;
                  }
                }
                int v101 = 0;
                if (++v98 == a6) {
                  unsigned int v94 = v95;
                }
                ++v95;
                goto LABEL_141;
              }
            }
            else
            {
              uint64_t v115 = 0xFFFFFFFFLL;
            }
            int v116 = v86[8 * v115 + 1];
            goto LABEL_122;
          }
        }
        uint64_t v117 = &v86[8 * v95];
        long long v118 = v103[1];
        *(_OWORD *)uint64_t v117 = *v103;
        *((_OWORD *)v117 + 1) = v118;
        v117[3] = v97 + v96 + HIDWORD(v100[2 * v99]);
        uint64_t v119 = v117 + 3;
        if (v98 == a6 && v94) {
          *uint64_t v119 = v86[8 * v94 + 4] + v86[8 * v94 + 3];
        }
        uint64_t v120 = v95 - 1;
        if (v95 == 1) {
          break;
        }
        if (v98 != a6)
        {
          if (v95)
          {
            unsigned int v122 = v86[8 * v95 - 8];
            if (v122 <= 0x28 && ((1 << v122) & 0x10020000002) != 0)
            {
              int v121 = v86[8 * v120 + 2] + v86[8 * v120 + 1];
              goto LABEL_111;
            }
          }
        }
        if (v98 != a6)
        {
          int v121 = v86[8 * v120 + 1];
          goto LABEL_111;
        }
LABEL_112:
        ++v95;
LABEL_113:
        ++v99;
LABEL_141:
        if (v99 >= v91) {
          goto LABEL_145;
        }
      }
      int v121 = v86[1];
LABEL_111:
      v86[8 * v95 + 1] = v121;
      goto LABEL_112;
    }
    unsigned int v98 = 0;
    int v96 = 0;
    unsigned int v95 = 0;
LABEL_145:
    if (v98 < a6)
    {
      uint64_t v131 = v98;
      unint64_t v132 = a6 - (unint64_t)v98;
      uint64_t v133 = v21 + 32 * v131;
      while (1)
      {
        unsigned int v134 = v95;
        uint64_t v135 = &v86[8 * v95];
        long long v136 = *(_OWORD *)(v133 + 16);
        *(_OWORD *)uint64_t v135 = *(_OWORD *)v133;
        *((_OWORD *)v135 + 1) = v136;
        unsigned int v137 = *(_DWORD *)(v133 + 12) + v96;
        v135[3] = v137;
        if (v95 >= 3) {
          break;
        }
        if (v95)
        {
          uint64_t v138 = v95 - 1;
          goto LABEL_151;
        }
LABEL_154:
        v133 += 32;
        unsigned int v95 = v134 + 1;
        if (!--v132) {
          goto LABEL_155;
        }
      }
      uint64_t v138 = v95 - 1;
      v135[1] = v86[8 * v138 + 2] + v86[8 * v138 + 1];
LABEL_151:
      if (v86[8 * v138] == 29)
      {
        uint64_t v139 = &v86[8 * v138];
        unsigned int v142 = v139[3];
        uint64_t v140 = v139 + 3;
        unsigned int v141 = v142;
        if (v137 > v142) {
          *uint64_t v140 = v141 + 1;
        }
      }
      goto LABEL_154;
    }
LABEL_155:
    int v143 = &v86[8 * v95 - 8];
    v86[4] = v143[4] + v143[3] - v86[3];
    v86[2] = v143[2] + v143[1] - v86[1];
    if (v85)
    {
      unsigned int v144 = 0;
      LODWORD(v145) = -1;
      do
      {
        int v146 = v28[8 * v144];
        if (v146 == 51)
        {
          int v147 = (v85 - v144 > 1) & (strcmp(*(const char **)&v28[8 * v144 + 6], "R_CLASS") == 0);
          if (v147) {
            LODWORD(v145) = v144;
          }
          v144 += v147;
        }
        else if (v146 == 57 && v145 != -1)
        {
          unsigned int v149 = v144 - 1;
          do
          {
            unsigned int v150 = v149;
            if (!v149) {
              break;
            }
            int v151 = v28[8 * v149--];
          }
          while (v151 != 1);
          if (v145 < v150)
          {
            uint64_t v152 = v145;
            unint64_t v145 = v145 + 1;
            if (v145 < v150)
            {
              LODWORD(v145) = v150;
              uint64_t v153 = (uint64_t)&v28[8 * v152 + 8];
              uint64_t v154 = ~v152 + v150;
              do
              {
                long long v156 = *(_OWORD *)(v153 - 16);
                long long v164 = *(_OWORD *)(v153 - 32);
                long long v155 = v164;
                long long v165 = v156;
                long long v157 = *(_OWORD *)(v153 + 16);
                *(_OWORD *)(v153 - 32) = *(_OWORD *)v153;
                *(_OWORD *)(v153 - 16) = v157;
                *(_OWORD *)uint64_t v153 = v155;
                *(_OWORD *)(v153 + 16) = v156;
                *(_DWORD *)(v153 - 28) = *(_DWORD *)(v153 + 4);
                v153 += 32;
                --v154;
              }
              while (v154);
            }
          }
          if (v145) {
            v28[8 * (v145 - 1) + 3] = v28[8 * v145 + 3];
          }
          LODWORD(v145) = -1;
        }
        ++v144;
      }
      while (v144 < v85);
    }
    uint64_t v27 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, _DWORD *, char *))(a1[6] + 160))(a2, v160, v161, 1, (unsigned __int16)v85, v28, (char *)&v162 + 2);
    if ((v27 & 0x80000000) == 0)
    {
      *((_DWORD *)a1 + 26) = v28[2] + v28[1];
      *((_DWORD *)a1 + 27) = v28[4] + v28[3];
      if (!v21) {
        goto LABEL_181;
      }
      goto LABEL_180;
    }
  }
  else
  {
    uint64_t v27 = 2588942346;
  }
  log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_NNWS", 75000, 0, v87, v88, v89, v90, v159);
  if (v21) {
    goto LABEL_180;
  }
LABEL_181:
  if (v26) {
    heap_Free(*(void **)(*a1 + 8), v26);
  }
  if (v28) {
    heap_Free(*(void **)(*a1 + 8), (uint64_t)v28);
  }
  return v27;
}

uint64_t fe_nnws_adjustTokenRecordBND(uint64_t a1, unsigned int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v52 = 0;
  unsigned int v50 = 0;
  unsigned int v51 = 0;
  int v48 = 0;
  int v49 = 0;
  __s1 = 0;
  uint64_t v47 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *, int *))(*(void *)(a7 + 48) + 176))(a5, a6, a4, 1, &v47, &v48);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char *))(*(void *)(a7 + 48) + 104))(a5, a6, 3, a4, (char *)&v49 + 2);
    if ((result & 0x80000000) == 0)
    {
      unsigned __int16 v15 = HIWORD(v49);
      if (HIWORD(v49))
      {
        int v45 = 0;
        unsigned int v16 = 0;
        uint64_t v44 = a2;
        int v38 = (_DWORD *)(a1 + 48);
        uint64_t v39 = a1 + 32;
        unsigned int v42 = a2;
        uint64_t v40 = a1;
        long long __s = a3;
        while (1)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, int *, char *))(*(void *)(a7 + 48) + 168))(a5, a6, v15, 0, 1, &v52, (char *)&v48 + 2);
          if ((result & 0x80000000) != 0) {
            return result;
          }
          if (v52 == 5) {
            break;
          }
          if (v52 != 6)
          {
            uint64_t v33 = HIWORD(v49);
LABEL_54:
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, char *))(*(void *)(a7 + 48) + 120))(a5, a6, HIWORD(v49), (char *)&v49 + 2);
            if ((result & 0x80000000) != 0) {
              return result;
            }
            if (v33) {
              uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a7 + 48) + 192))(a5, a6, v33);
            }
            goto LABEL_57;
          }
          if (v16 < a2)
          {
            uint64_t v17 = v16;
            uint64_t v18 = (unsigned int *)(v39 + 56 * v16);
            do
            {
              unsigned int v19 = *v18;
              v18 += 14;
              int v20 = (1 << v19) & 0x2C;
              if (v19 <= 5 && v20 != 0)
              {
                unsigned int v16 = v17;
                goto LABEL_39;
              }
              ++v17;
            }
            while (v44 != v17);
            unsigned int v16 = v44;
          }
LABEL_39:
          uint64_t v34 = a1 + 56 * v16;
          unsigned int v35 = *(_DWORD *)(v34 + 24);
          unsigned int v50 = *(_DWORD *)(v34 + 28);
          unsigned int v51 = v35;
          ++v16;
          uint64_t v36 = *(void *)(a7 + 48);
          if (v50 > v35)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned int *, int *))(v36 + 160))(a5, a6, HIWORD(v49), 1, 1, &v51, &v49);
            if ((result & 0x80000000) != 0) {
              return result;
            }
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned int *, int *))(*(void *)(a7 + 48) + 160))(a5, a6, HIWORD(v49), 2, 1, &v50, &v49);
            if ((result & 0x80000000) != 0) {
              return result;
            }
            uint64_t v33 = 0;
            goto LABEL_54;
          }
          uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, char *))(v36 + 120))(a5, a6, HIWORD(v49), (char *)&v49 + 2);
          if ((result & 0x80000000) != 0) {
            return result;
          }
LABEL_57:
          unsigned __int16 v15 = HIWORD(v49);
          if (!HIWORD(v49)) {
            return result;
          }
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned int *, char *))(*(void *)(a7 + 48) + 168))(a5, a6, HIWORD(v49), 1, 1, &v51, (char *)&v48 + 2);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned int *, char *))(*(void *)(a7 + 48) + 168))(a5, a6, HIWORD(v49), 2, 1, &v50, (char *)&v48 + 2);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, char *))(*(void *)(a7 + 48)
                                                                                               + 176))(a5, a6, HIWORD(v49), 4, &__s1, (char *)&v48 + 2);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        unsigned int v43 = v16;
        unsigned int v22 = v50;
        unsigned int v23 = v51;
        uint64_t v24 = v47;
        int v25 = *(_DWORD *)(v47 + 16);
        if (v50 < v25 + v51)
        {
          v51 += v45;
          uint64_t v26 = v44;
          if (a2)
          {
            uint64_t v27 = 0;
            uint64_t v28 = __s1;
            int v29 = v38;
            while (1)
            {
              if (*(v29 - 2) == 1 && ((v30 = strcmp(v28, "prompt"), uint64_t v26 = v44, v30) || *(v29 - 4) == 5) && *v29 != 1)
              {
                unsigned int v31 = *(v29 - 9);
              }
              else
              {
                unsigned int v31 = *(v29 - 9);
                if (v31 >= v23 && *(v29 - 8) + v31 < v22)
                {
                  ++v45;
                  goto LABEL_36;
                }
              }
              unsigned int v32 = *(v29 - 8) + v31;
              if (v32 >= v22)
              {
                if (*v29 != 1)
                {
LABEL_46:
                  v22 += v45;
                  unsigned int v50 = v22;
                  a2 = v42;
                  goto LABEL_47;
                }
                v22 += ++v45;
                unsigned int v50 = v22;
              }
              else if (v32 == v25 + *(_DWORD *)(v24 + 12))
              {
                goto LABEL_46;
              }
LABEL_36:
              ++v27;
              v29 += 14;
              if (v26 == v27) {
                goto LABEL_48;
              }
            }
          }
          LODWORD(v27) = 0;
LABEL_47:
          if (v27 == a2)
          {
LABEL_48:
            v22 += v45;
            unsigned int v50 = v22;
          }
        }
        unsigned int v37 = strlen(__s);
        if (v22 > v37) {
          unsigned int v50 = v37;
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned int *, int *))(*(void *)(a7 + 48) + 160))(a5, a6, HIWORD(v49), 1, 1, &v51, &v49);
        a1 = v40;
        unsigned int v16 = v43;
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned int *, int *))(*(void *)(a7 + 48) + 160))(a5, a6, HIWORD(v49), 2, 1, &v50, &v49);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        uint64_t v33 = 0;
        a2 = v42;
        goto LABEL_54;
      }
    }
  }
  return result;
}

uint64_t fe_nnws_adjust_ENP_labels(uint64_t result, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  if (result)
  {
    uint64_t v6 = result;
    uint64_t v7 = (unsigned __int8 **)*a4;
    unsigned int v22 = a3 + 1;
    unsigned int v23 = a3 + 3;
    unint64_t v24 = result;
    uint64_t v8 = (_DWORD *)(a2 + 36);
    uint64_t v9 = -(uint64_t)result;
    unint64_t v10 = 1;
    do
    {
      uint64_t v11 = *(const char **)(v8 - 9);
      if (!strcmp(v11, "ENG") || (uint64_t result = strcmp(v11, "NUM"), !result))
      {
        *uint64_t v7 = (unsigned __int8 *)*a3;
        uint64_t result = fe_hlp_adjustBMES_basedSingleLabel(v6, (int)v10 - 1, a3, a4);
        goto LABEL_13;
      }
      if (v10 != 1 && !*(v8 - 13) && *(v8 - 5) == 1)
      {
        uint64_t result = strcmp(v11, "/");
        if (result)
        {
          *uint64_t v7 = (unsigned __int8 *)a3[3];
          uint64_t result = fe_hlp_adjustBMES_basedSingleLabel(v6, (int)v10 - 1, a3, a4);
          int v12 = *(v8 - 15);
          if (v12 == 3)
          {
            *(v8 - 15) = 1;
            goto LABEL_37;
          }
          if (v12 == 2)
          {
            *(v8 - 15) = 0;
LABEL_37:
            *(v8 - 1) = 2;
            *(v8 - 4) = *(v8 - 18) + 1;
            goto LABEL_13;
          }
          goto LABEL_13;
        }
      }
      if (!*v8)
      {
        int v13 = *(v8 - 1);
        if ((v13 - 2) >= 2)
        {
          if (v13 != 1) {
            goto LABEL_13;
          }
          int v18 = **v7;
          unsigned int v19 = a3;
          if (v18 == 69)
          {
LABEL_29:
            *uint64_t v7 = (unsigned __int8 *)*v19;
          }
          else if (v18 == 77)
          {
            unsigned int v19 = v22;
            goto LABEL_29;
          }
          if (v10 != 1)
          {
            int v20 = **(v7 - 1);
            if (v20 == 77)
            {
              uint64_t v21 = *v23;
              goto LABEL_39;
            }
            if (v20 == 66)
            {
              uint64_t v21 = *a3;
LABEL_39:
              *(v7 - 1) = (unsigned __int8 *)v21;
              goto LABEL_13;
            }
          }
          goto LABEL_13;
        }
      }
      int v14 = **v7;
      unsigned __int16 v15 = a3;
      if (v14 != 66)
      {
        if (v14 != 77) {
          goto LABEL_21;
        }
        unsigned __int16 v15 = v23;
      }
      *uint64_t v7 = (unsigned __int8 *)*v15;
LABEL_21:
      if (v10 < v24)
      {
        int v16 = *v7[1];
        if (v16 == 69)
        {
          uint64_t v17 = *a3;
          goto LABEL_35;
        }
        if (v16 == 77)
        {
          uint64_t v17 = *v22;
LABEL_35:
          v7[1] = (unsigned __int8 *)v17;
        }
      }
LABEL_13:
      ++v10;
      v8 += 14;
      ++v7;
    }
    while (v9 + v10 != 1);
  }
  return result;
}

uint64_t fe_hlp_adjustBMES_basedSingleLabel(uint64_t result, unsigned int a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4 = *a4;
  unsigned int v5 = **(unsigned __int8 **)(*a4 + 8 * a2);
  if (v5 > 0x4C)
  {
    if (v5 != 77)
    {
      if (v5 != 83) {
        return result;
      }
      if (a2)
      {
        uint64_t v6 = a2 - 1;
        int v9 = **(unsigned __int8 **)(v4 + 8 * v6);
        unint64_t v10 = a3;
        if (v9 != 66)
        {
          if (v9 != 77) {
            goto LABEL_27;
          }
          unint64_t v10 = a3 + 3;
        }
        uint64_t v11 = *v10;
        goto LABEL_26;
      }
LABEL_27:
      if (a2 + 1 >= result) {
        return result;
      }
      int v18 = (uint64_t *)(v4 + 8 * (a2 + 1));
      int v19 = *(unsigned __int8 *)*v18;
      if (v19 != 69)
      {
        if (v19 != 77) {
          return result;
        }
        ++a3;
      }
      goto LABEL_40;
    }
    if (a2)
    {
      uint64_t v12 = a2 - 1;
      int v16 = **(unsigned __int8 **)(v4 + 8 * v12);
      if (v16 == 69)
      {
        uint64_t v17 = 2;
      }
      else
      {
        if (v16 != 83) {
          goto LABEL_34;
        }
        uint64_t v17 = 1;
      }
      uint64_t v15 = a3[v17];
      goto LABEL_33;
    }
  }
  else
  {
    if (v5 != 66)
    {
      if (v5 != 69) {
        return result;
      }
      if (a2)
      {
        uint64_t v6 = a2 - 1;
        int v7 = **(unsigned __int8 **)(v4 + 8 * v6);
        if (v7 == 69)
        {
          uint64_t v8 = 2;
        }
        else
        {
          if (v7 != 83) {
            goto LABEL_27;
          }
          uint64_t v8 = 1;
        }
        uint64_t v11 = a3[v8];
LABEL_26:
        *(void *)(v4 + 8 * v6) = v11;
        goto LABEL_27;
      }
      goto LABEL_27;
    }
    if (a2)
    {
      uint64_t v12 = a2 - 1;
      int v13 = **(unsigned __int8 **)(v4 + 8 * v12);
      int v14 = a3;
      if (v13 == 66)
      {
LABEL_19:
        uint64_t v15 = *v14;
LABEL_33:
        *(void *)(v4 + 8 * v12) = v15;
        goto LABEL_34;
      }
      if (v13 == 77)
      {
        int v14 = a3 + 3;
        goto LABEL_19;
      }
    }
  }
LABEL_34:
  if (a2 + 1 >= result) {
    return result;
  }
  int v18 = (uint64_t *)(v4 + 8 * (a2 + 1));
  int v20 = *(unsigned __int8 *)*v18;
  if (v20 == 66)
  {
    uint64_t v21 = 2;
  }
  else
  {
    if (v20 != 83) {
      return result;
    }
    uint64_t v21 = 3;
  }
  a3 += v21;
LABEL_40:
  *int v18 = *a3;
  return result;
}

uint64_t fe_nnws_setFeature(uint64_t a1, const char **a2, unsigned int a3, int a4, char **a5, const char *a6)
{
  if (a3 < 2) {
    return 0;
  }
  unsigned int v20 = v6;
  uint64_t v11 = a3 - 1;
  uint64_t v12 = nnws_g_featureNames[a4];
  while (strcmp(*a2, v12))
  {
    ++a5;
    ++a2;
    if (!--v11) {
      return 0;
    }
  }
  if (*a6)
  {
    size_t v14 = strlen(a6);
    if (v14 < 0x41)
    {
LABEL_11:
      strcpy(*a5, a6);
      return 0;
    }
    uint64_t v15 = heap_Realloc(*(uint64_t **)(a1 + 8), (uint64_t)*a5, (unsigned __int16)v14 + 1);
    if (v15)
    {
      *a5 = (char *)v15;
      goto LABEL_11;
    }
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_NNWS", 37000, 0, v16, v17, v18, v19, v20);
    return 2588942346;
  }
  else
  {
    uint64_t result = 0;
    *(_WORD *)*a5 = 61;
  }
  return result;
}

long long **reorder_pMrk(long long **result, unsigned int a2, int a3)
{
  if (a2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = *result;
    do
    {
      if (++v3 < (unint64_t)a2 && *(_DWORD *)v4 == a3 && *((_DWORD *)v4 + 11) == *((_DWORD *)v4 + 3))
      {
        long long v5 = *v4;
        long long v7 = v4[1];
        long long v6 = v4[3];
        long long *v4 = v4[2];
        v4[1] = v6;
        v4[2] = v5;
        v4[3] = v7;
        *((_DWORD *)v4 + 1) = *((_DWORD *)v4 + 9);
      }
      v4 += 2;
    }
    while (a2 != v3);
  }
  return result;
}

uint64_t fe_initlingdb_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t LowerCasedMainLng3 = 2307923975;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  if (!a5) {
    return LowerCasedMainLng3;
  }
  *(void *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  uint64_t inited = InitRsrcFunction(a3, a4, &v33);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t inited = objc_GetObject(*(void *)(v33 + 48), (uint64_t)"LINGDB", &v31);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t Object = objc_GetObject(*(void *)(v33 + 48), (uint64_t)"SYNTHSTREAM", &v32);
  uint64_t v13 = *(void *)(v33 + 48);
  if ((Object & 0x80000000) != 0)
  {
    uint64_t v26 = "LINGDB";
LABEL_20:
    objc_ReleaseObject(v13, (uint64_t)v26);
    return Object;
  }
  uint64_t v14 = objc_GetObject(v13, (uint64_t)"FE_DCTLKP", &v30);
  if ((v14 & 0x80000000) != 0)
  {
    uint64_t Object = v14;
    objc_ReleaseObject(*(void *)(v33 + 48), (uint64_t)"LINGDB");
    uint64_t v13 = *(void *)(v33 + 48);
    uint64_t v26 = "SYNTHSTREAM";
    goto LABEL_20;
  }
  uint64_t v15 = heap_Calloc(*(void **)(v33 + 8), 1, 976);
  if (v15)
  {
    uint64_t v20 = v15;
    *(void *)a5 = v15;
    *(_DWORD *)(a5 + 8) = 62336;
    *(void *)(v15 + 32) = a1;
    *(void *)(v15 + 40) = a2;
    *(void *)uint64_t v15 = v33;
    *(void *)(v15 + 8) = a1;
    *(void *)(v15 + 16) = a3;
    *(void *)(v15 + 24) = a4;
    *(void *)(v15 + 72) = *(void *)(v31 + 8);
    *(void *)(v15 + 80) = *(void *)(v32 + 8);
    uint64_t v21 = v30;
    *(void *)(v15 + 64) = *(void *)(v30 + 8);
    *(_OWORD *)(v15 + 48) = *(_OWORD *)(v21 + 16);
    uint64_t v22 = objc_GetObject(*(void *)(v33 + 48), (uint64_t)"CLMOBJECT", &v29);
    if ((v22 & 0x80000000) != 0
      || (uint64_t v23 = v29,
          *(void *)(v20 + 968) = *(void *)(v29 + 8),
          *(_OWORD *)(v20 + 952) = *(_OWORD *)(v23 + 16),
          uint64_t v22 = (*(uint64_t (**)(void, void, char *, uint64_t *))(*(void *)(v20 + 64) + 88))(*(void *)(v20 + 48), *(void *)(v20 + 56), (char *)&v28 + 4, &v28), (v22 & 0x80000000) != 0))
    {
      uint64_t LowerCasedMainLng3 = v22;
LABEL_23:
      fe_initlingdb_ObjClose(*(void *)a5, *(void *)(a5 + 8));
      *(void *)a5 = 0;
      *(_DWORD *)(a5 + 8) = 0;
      return LowerCasedMainLng3;
    }
    BOOL v25 = v28 == 1 && HIDWORD(v28) == 1;
    *(_DWORD *)(v20 + 944) = v25;
    uint64_t LowerCasedMainLng3 = hlp_GetLowerCasedMainLng3(*(void *)v20, (char *)(v20 + 948));
    if ((LowerCasedMainLng3 & 0x80000000) != 0) {
      goto LABEL_23;
    }
  }
  else
  {
    log_OutPublic(*(void *)(v33 + 32), (uint64_t)"FE_INITLINGDB", 30000, 0, v16, v17, v18, v19, v28);
    objc_ReleaseObject(*(void *)(v33 + 48), (uint64_t)"LINGDB");
    objc_ReleaseObject(*(void *)(v33 + 48), (uint64_t)"SYNTHSTREAM");
    objc_ReleaseObject(*(void *)(v33 + 48), (uint64_t)"FE_DCTLKP");
    return 2307923978;
  }
  return LowerCasedMainLng3;
}

uint64_t hlp_GetLowerCasedMainLng3(uint64_t a1, char *a2)
{
  long long __s = 0;
  uint64_t Str = paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"langcode", &__s);
  if ((Str & 0x80000000) != 0) {
    return Str;
  }
  uint64_t v4 = 2307923968;
  if (__s && strlen(__s) == 3)
  {
    strcpy(a2, __s);
    if (*a2)
    {
      uint64_t v5 = 0;
      int v6 = 0;
      do
      {
        a2[v5] = ssft_tolower(a2[v5]);
        uint64_t v5 = ++v6;
      }
      while (strlen(a2) > v6);
    }
    return Str;
  }
  return v4;
}

uint64_t fe_initlingdb_ObjClose(uint64_t a1, int a2)
{
  uint64_t v3 = safeh_HandleCheck(a1, a2, 62336, 976);
  if ((v3 & 0x80000000) != 0) {
    return 2307923976;
  }
  uint64_t v4 = v3;
  if (a1)
  {
    objc_ReleaseObject(*(void *)(*(void *)a1 + 48), (uint64_t)"LINGDB");
    objc_ReleaseObject(*(void *)(*(void *)a1 + 48), (uint64_t)"SYNTHSTREAM");
    objc_ReleaseObject(*(void *)(*(void *)a1 + 48), (uint64_t)"FE_DCTLKP");
    objc_ReleaseObject(*(void *)(*(void *)a1 + 48), (uint64_t)"CLMOBJECT");
    heap_Free(*(void **)(*(void *)a1 + 8), a1);
  }
  return v4;
}

uint64_t fe_initlingdb_ObjReopen(uint64_t a1, int a2)
{
  uint64_t v6 = 0;
  uint64_t result = safeh_HandleCheck(a1, a2, 62336, 976);
  if ((result & 0x80000000) != 0) {
    return 2307923976;
  }
  if (a1)
  {
    uint64_t result = (*(uint64_t (**)(void, void, char *, uint64_t *))(*(void *)(a1 + 64) + 88))(*(void *)(a1 + 48), *(void *)(a1 + 56), (char *)&v6 + 4, &v6);
    if ((result & 0x80000000) == 0)
    {
      BOOL v5 = v6 == 1 && HIDWORD(v6) == 1;
      *(_DWORD *)(a1 + 944) = v5;
      return hlp_GetLowerCasedMainLng3(*(void *)a1, (char *)(a1 + 948));
    }
  }
  return result;
}

uint64_t fe_initlingdb_ProcessStart(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if ((safeh_HandleCheck(a1, a2, 62336, 976) & 0x80000000) != 0) {
    return 2307923976;
  }
  synstrmaux_InitStreamOpener(a1 + 88, *(void *)(*(void *)a1 + 32), (uint64_t)"FE_INITLINGDB");
  synstrmaux_RegisterInStream((_WORD *)(a1 + 88), (uint64_t)"text/plain;charset=utf-8", 0, a1 + 912);
  synstrmaux_RegisterInStream((_WORD *)(a1 + 88), (uint64_t)"application/x-realspeak-markers-pp;version=4.0",
    0,
    a1 + 928);
  uint64_t v7 = synstrmaux_OpenStreams((unsigned __int16 *)(a1 + 88), *(void *)(a1 + 80), a3, a4);
  if ((v7 & 0x80000000) != 0) {
    synstrmaux_CloseStreams((_WORD *)(a1 + 88), *(void *)(a1 + 80));
  }
  return v7;
}

uint64_t fe_initlingdb_Process(uint64_t *a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  memset(v217, 0, 12);
  uint64_t v9 = 2307923978;
  uint64_t v215 = 0;
  uint64_t v216 = 0;
  unsigned int v214 = 0;
  unsigned int v212 = 0;
  int v213 = 0;
  unsigned __int16 v209 = 0;
  int v207 = 0;
  int v206 = 0;
  *(void *)&__c[3] = 0;
  int v205 = 0;
  *(_WORD *)&__c[1] = -1;
  __c[0] = 0;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 62336, 976) & 0x80000000) != 0) {
    return 2307923976;
  }
  int v210 = 0;
  unsigned int v211 = 0;
  unsigned __int16 v208 = 0;
  *a5 = 1;
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, void *, void *))(a1[10] + 144))(a1[114], a1[115], &v217[1], v217);
  if ((v10 & 0x80000000) != 0) {
    return v10;
  }
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, char *, void *))(a1[10] + 144))(a1[116], a1[117], (char *)v217 + 4, v217);
  if ((v10 & 0x80000000) != 0) {
    return v10;
  }
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[9] + 56))(a3, a4);
  if ((v10 & 0x80000000) != 0) {
    return v10;
  }
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *))(a1[9] + 104))(a3, a4, 1, 0, (char *)&v210 + 2);
  if ((v10 & 0x80000000) != 0) {
    return v10;
  }
  if (!LODWORD(v217[1]))
  {
    int v22 = v217[0];
    if (v217[0])
    {
      if (HIDWORD(v217[0]))
      {
        uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned int **, unsigned int *))(a1[10] + 88))(a1[116], a1[117], &v213, &v211);
        if ((v10 & 0x80000000) != 0) {
          return v10;
        }
        if ((v211 & 0x1FFFE0) == 0 || !(unsigned __int16)(v211 >> 5)) {
          goto LABEL_32;
        }
        uint64_t v23 = v213;
        uint64_t v24 = (unsigned __int16)((unint64_t)v211 >> 5);
        int v25 = 1;
        do
        {
          unsigned int v27 = *v23;
          v23 += 8;
          unsigned int v26 = v27;
          uint64_t v28 = (1 << v27) & 0x1000001003070000;
          BOOL v29 = v27 > 0x3C || v28 == 0;
          if (v29 && v26 != 0x4000) {
            int v25 = 0;
          }
          --v24;
        }
        while (v24);
        if (!v25)
        {
          uint64_t v53 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, unsigned int *, int *))(a1[9] + 160))(a3, a4, HIWORD(v210), 1, (unsigned __int16)(v211 >> 5), v213, &v210);
          if ((v53 & 0x80000000) != 0)
          {
            uint64_t v9 = v53;
            log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_INITLINGDB", 30002, 0, v54, v55, v56, v57, v183);
            return v9;
          }
        }
        else
        {
LABEL_32:
          *a5 = 1;
        }
        uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t))(a1[10] + 96))(a1[116], a1[117]);
        if ((v10 & 0x80000000) != 0) {
          return v10;
        }
        int v22 = v217[0];
      }
      if (v22)
      {
        *a5 = 1;
        int v207 = 1;
      }
    }
    else
    {
      *(void *)__s2 = 0;
      if ((paramc_ParamGetStr(*(void *)(*a1 + 40), (uint64_t)"clcpppipelinemode", __s2) & 0x80000000) != 0
        || !*(void *)__s2
        || !**(unsigned char **)__s2)
      {
        *a5 = 0;
      }
    }
    return (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, int *))(a1[9] + 160))(a3, a4, HIWORD(v210), 3, 1, &v207, &v210);
  }
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, int *))(a1[9] + 160))(a3, a4, HIWORD(v210), 3, 1, &v207, &v210);
  if ((v10 & 0x80000000) != 0) {
    return v10;
  }
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, char **, unsigned int *))(a1[10] + 88))(a1[114], a1[115], &v215, &v214);
  if ((v10 & 0x80000000) != 0) {
    return v10;
  }
  uint64_t v11 = hlp_CopyString(*a1, (uint64_t *)&v216, v215, 0);
  if ((v11 & 0x80000000) != 0) {
    goto LABEL_79;
  }
  uint64_t v12 = a1[10];
  if (v214 != 1)
  {
    uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned int **, unsigned int *))(v12 + 88))(a1[116], a1[117], &v213, &v211);
    if ((v11 & 0x80000000) == 0)
    {
      unsigned int v31 = v211;
      unsigned int v32 = v211 >> 5;
      unsigned __int16 v209 = v211 >> 5;
      uint64_t v33 = (_DWORD *)heap_Alloc(*(void *)(*a1 + 8), v211);
      unsigned int v212 = v33;
      if (!v33)
      {
LABEL_82:
        uint64_t v51 = *(void *)(*a1 + 32);
        uint64_t v52 = 30000;
LABEL_100:
        log_OutPublic(v51, (uint64_t)"FE_INITLINGDB", v52, 0, v15, v16, v17, v18, v183);
        goto LABEL_101;
      }
      memcpy(v33, v213, v211);
      if ((unsigned __int16)(v31 >> 5))
      {
        unsigned int v34 = 0;
        unsigned __int16 v35 = 0;
        unsigned __int16 v36 = -1;
        unsigned int v37 = "normal";
        while (1)
        {
          uint64_t v38 = v35;
          int v39 = v212[8 * v35];
          if (v39 == 34) {
            unsigned __int16 v36 = v35;
          }
          if (v39 == 100)
          {
            if (*(void *)&v212[8 * v35 + 6])
            {
              if (v36 == 0xFFFF)
              {
                if ((unsigned __int16)v32 <= (unsigned __int16)(v35 + 1)) {
                  unsigned __int16 v40 = v35 + 1;
                }
                else {
                  unsigned __int16 v40 = v32;
                }
                unsigned __int16 v36 = v35;
                while (++v36 < (unsigned __int16)v32)
                {
                  if (v212[8 * v36] == 34) {
                    goto LABEL_63;
                  }
                }
                unsigned __int16 v36 = v40;
              }
LABEL_63:
              unint64_t v41 = (char **)&v212[8 * v36];
              if (*((_DWORD *)v41 + 3) == v212[8 * v35 + 3])
              {
                if ((hlp_ValidatePhoneticTranscription((uint64_t)a1, v37, v41[3]) & 0x80000000) != 0)
                {
                  __s1 = v37;
                  size_t v42 = strlen(v216);
                  uint64_t v43 = (uint64_t)v212;
                  uint64_t v44 = (const void **)&v212[8 * v38];
                  size_t v45 = *((unsigned int *)v44 + 2);
                  if (v42 >= v45)
                  {
                    if (v34 >= v36) {
                      uint64_t v48 = v36;
                    }
                    else {
                      uint64_t v48 = v34;
                    }
                    if (v34 <= v36) {
                      uint64_t v49 = v36;
                    }
                    else {
                      uint64_t v49 = v34;
                    }
                    memcpy(&v216[*((unsigned int *)v44 + 3) - v212[3]], v44[3], v45);
                    int v50 = v209;
                    memmove((void *)(v43 + 32 * v49), (const void *)(v43 + 32 * (v49 + 1)), 32 * (v209 + ~v49));
                    memmove((void *)(v43 + 32 * v48), (const void *)(v43 + 32 * (v48 + 1)), 32 * (~v48 + (unsigned __int16)(v50 - 1)));
                    unsigned int v32 = v50 - 2;
                    unsigned __int16 v209 = v50 - 2;
                    uint64_t v47 = heap_Realloc(*(uint64_t **)(*a1 + 8), v43, 32 * (unsigned __int16)(v50 - 2));
                    if (!v47) {
                      goto LABEL_82;
                    }
                  }
                  else
                  {
                    int v46 = v209;
                    memmove(v44, &v212[8 * v34 + 8], 32 * (int)(v209 + ~v34));
                    unsigned int v32 = v46 - 1;
                    unsigned __int16 v209 = v46 - 1;
                    uint64_t v47 = heap_Realloc(*(uint64_t **)(*a1 + 8), v43, 32 * (unsigned __int16)(v46 - 1));
                    if (!v47) {
                      goto LABEL_82;
                    }
                  }
                  unsigned int v37 = __s1;
                  unsigned __int16 v35 = 0;
                  unsigned int v212 = (_DWORD *)v47;
                  unsigned __int16 v36 = -1;
                }
                else
                {
                  unsigned __int16 v36 = -1;
                  unsigned int v32 = v209;
                }
              }
            }
          }
          else if (v39 == 36)
          {
            unsigned int v37 = *(char **)&v212[8 * v35 + 6];
          }
          unsigned int v34 = ++v35;
          if (v35 == (unsigned __int16)v32) {
            goto LABEL_86;
          }
        }
      }
      unsigned int v32 = 0;
      unsigned int v37 = "normal";
LABEL_86:
      __s1a = v37;
      int v58 = v216;
      __int16 v59 = strlen(v216);
      uint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, char *, int *))(a1[9] + 160))(a3, a4, HIWORD(v210), 0, (unsigned __int16)(v59 + 1), v216, &v210);
      uint64_t v65 = *(void *)(*a1 + 32);
      if ((v64 & 0x80000000) != 0)
      {
        log_OutPublic(v65, (uint64_t)"FE_INITLINGDB", 30002, 0, v60, v61, v62, v63, v183);
        uint64_t v20 = 0;
        uint64_t v21 = 0;
        uint64_t v9 = v64;
        goto LABEL_103;
      }
      log_OutText(v65, (uint64_t)"FE_INITLINGDB", 5, 0, (uint64_t)"Initializing LINGDB with %s", v61, v62, v63, (uint64_t)v58);
      uint64_t v20 = heap_Alloc(*(void *)(*a1 + 8), 4 * (unsigned __int16)v32);
      if (!v20)
      {
        log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_INITLINGDB", 30000, 0, v66, v67, v68, v69, v184);
        goto LABEL_102;
      }
      uint64_t v70 = (uint64_t)v212;
      if ((_WORD)v32)
      {
        uint64_t v71 = v212 + 4;
        uint64_t v72 = (unsigned __int16)v32;
        do
        {
          if (*(v71 - 4) == 1) {
            _DWORD *v71 = 0;
          }
          v71 += 8;
          --v72;
        }
        while (v72);
        int v73 = (unsigned int *)(v70 + 12);
        if ((_WORD)v32)
        {
          uint64_t v74 = 0;
          uint64_t v75 = (int *)(v70 + 12);
          while (1)
          {
            int v76 = *v75;
            v75 += 8;
            if (v76 != *(_DWORD *)(v70 + 12)) {
              break;
            }
            if ((unsigned __int16)v32 == ++v74)
            {
              unsigned __int16 v77 = v32;
              uint64_t v74 = (unsigned __int16)v32;
              goto LABEL_118;
            }
          }
          unsigned __int16 v77 = v74;
        }
        else
        {
          unsigned __int16 v77 = 0;
          uint64_t v74 = 0;
        }
      }
      else
      {
        unsigned __int16 v77 = 0;
        uint64_t v74 = 0;
        int v73 = v212 + 3;
      }
LABEL_118:
      uint64_t v78 = v70 + 32 * v74;
      uint64_t v197 = v70;
      if ((unsigned __int16)v32 == v77)
      {
        marker_sort(v78, (unsigned __int16)v32 - v74);
        uint64_t v79 = v197;
      }
      else
      {
        uint64_t v80 = 0;
        uint64_t v81 = (unsigned __int16)(v32 - v77);
        int v82 = (_DWORD *)(v78 + 4);
        do
        {
          *(_DWORD *)(v20 + 4 * v80) = *v82;
          *int v82 = v80;
          v82 += 8;
          ++v80;
        }
        while (v81 != v80);
        marker_sort(v78, (unsigned __int16)v32 - v74);
        uint64_t v79 = v197;
        int v83 = (_DWORD *)(v197 + 32 * v74 + 4);
        do
        {
          *int v83 = *(_DWORD *)(v20 + 4 * *v83);
          v83 += 8;
          --v81;
        }
        while (v81);
      }
      uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(a1[8] + 56))(a1[6], a1[7], a3, a4, v79, (unsigned __int16)v32);
      if ((v11 & 0x80000000) == 0)
      {
        uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, unsigned __int16 *))(a1[9] + 104))(a3, a4, 3, HIWORD(v210), &v208);
        if ((v11 & 0x80000000) == 0)
        {
          unsigned int v196 = *v73;
          uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(a1[8] + 96))(a1[6], a1[7], "fecfg", "normal", &__c[3], &__c[1], __c);
          if ((v11 & 0x80000000) == 0)
          {
            if (*(_WORD *)&__c[1])
            {
              uint64_t v84 = strchr(**(char ***)&__c[3], __c[0]);
              if (v84) {
                char *v84 = 0;
              }
              hlp_CreatePauseDurParam(*a1, "normal");
              unsigned int v85 = **(const char ***)&__c[3];
            }
            else
            {
              unsigned int v85 = "normal";
            }
            uint64_t v86 = v197;
            uint64_t v87 = __s1a;
            if (!(_WORD)v32)
            {
              uint64_t v194 = 0;
              uint64_t v89 = 0;
              int v195 = 0;
              uint64_t v92 = v196;
              goto LABEL_275;
            }
            int v88 = 0;
            int v195 = 0;
            uint64_t v89 = 0;
            uint64_t v194 = 0;
            uint64_t v90 = 0;
            unsigned int v91 = 0;
            uint64_t v92 = v196;
            long long __s = "normal";
            uint64_t v188 = v20;
            while (2)
            {
              int v93 = (int *)(v86 + 32 * (unsigned __int16)(v91 + 1));
              while (1)
              {
                uint64_t v94 = (unsigned __int16)v91;
                uint64_t v95 = 32 * (unsigned __int16)v91;
                unsigned int v96 = *(_DWORD *)(v86 + v95);
                if (v96 > 0x24 || ((1 << v96) & 0x1400200000) == 0) {
                  goto LABEL_272;
                }
                unsigned int v98 = v91 + 1;
                if ((unsigned __int16)(v91 + 1) < (unsigned __int16)v32
                  && (int v99 = *(_DWORD *)(v86 + 32 * (unsigned __int16)v91 + 12),
                      *(_DWORD *)(v86 + 32 * (unsigned __int16)(v91 + 1) + 12) == v99))
                {
                  unsigned __int16 v100 = 0;
                  unsigned __int16 v101 = 0;
                  int v102 = v93;
                  unsigned int v103 = v91;
                  unsigned int v104 = v91 + 1;
                  while (1)
                  {
                    unsigned int v91 = v104;
                    int v106 = *v102;
                    v102 += 8;
                    int v105 = v106;
                    if (v106 == 36)
                    {
                      unsigned __int16 v100 = v91;
                    }
                    else if (v105 == 34)
                    {
                      unsigned int v91 = v103;
                      goto LABEL_152;
                    }
                    if (v105 == 21) {
                      unsigned __int16 v101 = v91;
                    }
                    unsigned int v104 = v91 + 1;
                    if ((unsigned __int16)(v91 + 1) >= (unsigned __int16)v32) {
                      break;
                    }
                    unsigned int v103 = v91;
                    if (*(_DWORD *)(v86 + 32 * (unsigned __int16)(v91 + 1) + 12) != v99) {
                      goto LABEL_152;
                    }
                  }
                  unsigned int v91 = v32 - 1;
                }
                else
                {
                  unsigned __int16 v100 = 0;
                  unsigned __int16 v101 = 0;
                }
LABEL_152:
                if (!v88 || v96 != 36 || v101) {
                  break;
                }
                uint64_t v90 = *(const char **)(v86 + 32 * v94 + 24);
                v93 += 8;
                int v88 = 1;
                unsigned int v91 = v98;
                if ((unsigned __int16)v98 >= (unsigned __int16)v32) {
                  goto LABEL_275;
                }
              }
              uint64_t v107 = v86 + 32 * v94;
              int v109 = *(_DWORD *)(v107 + 12);
              uint64_t v108 = (_DWORD *)(v107 + 12);
              unsigned int v110 = v109 - v196;
              unsigned int v189 = v91;
              uint64_t v191 = v94;
              if (v109 != v196)
              {
                uint64_t v187 = v90;
                int v186 = v92;
                int v192 = v85;
                int v185 = (char *)v89;
                uint64_t v198 = v86;
                __s1b = v87;
                int v111 = v216;
                unsigned int v112 = strlen(v216);
                while (v111[v110] == 95 || utf8_BelongsToSet(0, v111, v110, v112))
                {
                  unsigned int NextUtf8Offset = utf8_GetNextUtf8Offset(v111, v110);
                  *v108 += NextUtf8Offset - v110;
                  unsigned int v110 = NextUtf8Offset;
                }
                uint64_t v90 = v187;
                uint64_t v20 = v188;
                uint64_t v86 = v198;
                uint64_t v87 = __s1b;
                uint64_t v94 = v191;
                if (v186 != *v108)
                {
                  log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_INITLINGDB", 5, 0, (uint64_t)"Creating USER TN %s token at pos  %u,%u in lingdb", v113, v114, v115, (uint64_t)v192);
                  uint64_t inserted = hlp_InsertUserTNToken((char *)a1, a3, a4, HIWORD(v210), &v208, (unsigned __int16)(v186 - v196), LOWORD(v212[8 * v191 + 3]) - (unsigned __int16)v196, v192, v185, __s1b, v216, v195, (uint64_t)v212, v209);
                  if ((inserted & 0x80000000) != 0) {
                    goto LABEL_286;
                  }
                  uint64_t v86 = (uint64_t)v212;
                  uint64_t v87 = __s1b;
                  uint64_t v94 = v191;
                  uint64_t v90 = v187;
                }
              }
              int v118 = *(_DWORD *)(v86 + v95);
              if (v118 == 36)
              {
                uint64_t v87 = *(char **)(v86 + 32 * v94 + 24);
              }
              else if (v118 == 21)
              {
                long long __s = *(char **)(v86 + 32 * v94 + 24);
              }
              if (v100) {
                uint64_t v87 = *(char **)(v86 + 32 * v100 + 24);
              }
              if (v101) {
                long long __s = *(char **)(v86 + 32 * v101 + 24);
              }
              if (v118 == 34)
              {
                uint64_t v119 = v90;
                uint64_t v120 = v94;
                uint64_t v121 = strlen(*(const char **)(v86 + 32 * v94 + 24)) + 1;
                uint64_t v122 = heap_Realloc(*(uint64_t **)(*a1 + 8), v194, v121);
                if (v122)
                {
                  uint64_t v89 = v122;
                  unsigned __int16 v127 = 0;
                  unsigned __int16 v128 = 0;
                  uint64_t v86 = (uint64_t)v212;
                  unsigned int v91 = v189;
                  uint64_t v129 = v120;
                  uint64_t v90 = v119;
                  while (1)
                  {
                    int v130 = *(unsigned __int8 *)(*(void *)(v86 + 32 * v120 + 24) + v128);
                    if (v130 != 32)
                    {
                      if (!*(unsigned char *)(*(void *)(v86 + 32 * v120 + 24) + v128))
                      {
                        int v195 = 0;
                        *(unsigned char *)(v122 + v127) = 0;
                        int v88 = 1;
                        unsigned int v85 = "phon";
                        uint64_t v194 = v122;
                        goto LABEL_271;
                      }
                      uint64_t v131 = v127++;
                      *(unsigned char *)(v122 + v131) = v130;
                    }
                    ++v128;
                  }
                }
                log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_INITLINGDB", 30000, 0, v123, v124, v125, v126, v184);
                uint64_t v21 = v194;
                goto LABEL_103;
              }
              if (v118 == 36 || v90 == 0) {
                uint64_t v133 = v87;
              }
              else {
                uint64_t v133 = v90;
              }
              int v134 = strlen(__s);
              __s1c = (char *)v133;
              unsigned int v135 = strlen(v133);
              if (v135 >= 6) {
                int v136 = v135;
              }
              else {
                int v136 = 6;
              }
              unsigned int v137 = (char *)heap_Realloc(*(uint64_t **)(*a1 + 8), (uint64_t)v206, (v134 + v136 + 2));
              if (!v137)
              {
                log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_INITLINGDB", 30000, 0, v138, v139, v140, v141, v184);
                goto LABEL_287;
              }
              unsigned int v142 = v137;
              int v206 = v137;
              if (!strcmp(__s, "normal") && !strcmp(v133, "normal"))
              {
                int v195 = 0;
                strcpy(v142, "normal");
                goto LABEL_264;
              }
              *unsigned int v142 = 0;
              if (!strcmp(__s, "normal"))
              {
                unsigned __int16 v146 = 0;
                goto LABEL_236;
              }
              LOBYTE(v143) = *__s;
              if (*__s)
              {
                int v144 = 0;
                do
                {
                  v142[(unsigned __int16)v144] = ssft_tolower(v143);
                  unsigned __int16 v145 = v144 + 1;
                  int v143 = __s[(unsigned __int16)++v144];
                }
                while (v143);
              }
              else
              {
                unsigned __int16 v145 = 0;
              }
              v142[v145] = 0;
              if (*((_DWORD *)a1 + 236) == 1 && strcmp(v142, "normal") && *v142)
              {
                *(_WORD *)&__c[1] = -1;
                BestTNint Type = (*(uint64_t (**)(uint64_t, uint64_t, const char *, char *, unsigned char *, unsigned char *, unsigned char *))(a1[8] + 96))(a1[6], a1[7], "fecfg", v142, &__c[3], &__c[1], __c);
                if ((BestTNType & 0x80000000) != 0) {
                  goto LABEL_294;
                }
                if (*(_WORD *)&__c[1])
                {
                  uint64_t v148 = **(char ***)&__c[3];
                  unsigned int v149 = strchr(**(char ***)&__c[3], __c[0]);
                  if (v149)
                  {
                    *unsigned int v149 = 0;
                    uint64_t v148 = **(char ***)&__c[3];
                  }
                  int v150 = strlen(__s1c);
                  BestTNint Type = hlp_CopyString(*a1, (uint64_t *)&v206, v148, v150 + 1);
                  if ((BestTNType & 0x80000000) != 0) {
                    goto LABEL_294;
                  }
                }
              }
              *(_WORD *)&__c[1] = -1;
              BestTNint Type = (*(uint64_t (**)(uint64_t, uint64_t, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(a1[8] + 96))(a1[6], a1[7], "fecfg", "esctn", &__c[3], &__c[1], __c);
              if ((BestTNType & 0x80000000) != 0) {
                goto LABEL_294;
              }
              if (*(_WORD *)&__c[1])
              {
                int v151 = v206;
                int v152 = strlen(__s1c);
                BestTNint Type = hlp_FindBestTNType(*a1, **(char ***)&__c[3], __c[0], v206, (const char **)&v205, v152 + 1);
                if ((BestTNType & 0x80000000) == 0)
                {
                  uint64_t v153 = v205;
                  if (v205 != v151)
                  {
                    if (hlp_LogUnsupportedTNType(*a1, v151)) {
                      log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_INITLINGDB", 30005, "%s%s%s%s", v154, v155, v156, v157, "OriginalTNType");
                    }
                    heap_Free(*(void **)(*a1 + 8), (uint64_t)v151);
                    int v206 = v153;
                  }
                  goto LABEL_231;
                }
                if ((BestTNType & 0x1FFF) != 0) {
                  goto LABEL_294;
                }
              }
              else
              {
                int v151 = v206;
                if (!strcmp(v206, "normal")
                  || !strcmp(v151, "sms")
                  || !strcmp(v151, "address")
                  || !strcmp(v151, "spell")
                  || !strcmp(v151, "NOR")
                  || !strcmp(v151, "SMS")
                  || !strcmp(v151, "ADR"))
                {
LABEL_231:
                  unsigned int v142 = v206;
                  unsigned __int16 v163 = strlen(v206);
                  if (!strcmp(__s1c, "normal") || !strcmp(v142, "normal") || !*v142)
                  {
                    unsigned __int16 v146 = v163;
                  }
                  else
                  {
                    unsigned __int16 v146 = v163 + 1;
                    v142[v163] = 95;
                  }
LABEL_236:
                  if (!strcmp(__s1c, "normal") || !strcmp(v142, "normal"))
                  {
                    int v195 = 0;
                    goto LABEL_261;
                  }
                  if (strlen(__s1c) == 7 && strstr(__s1c, "_lid"))
                  {
                    __s1c[3] = 0;
                    int v195 = 1;
                  }
                  else
                  {
                    int v195 = 0;
                  }
                  if (strlen(__s1c) == 3)
                  {
                    for (uint64_t i = 0; i != 3; ++i)
                      __s2[i] = ssft_tolower(__s1c[i]);
                    __s2[3] = 0;
                    *(_WORD *)&__c[1] = -1;
                    BestTNint Type = (*(uint64_t (**)(uint64_t, uint64_t, const char *, const char *, unsigned char *, unsigned char *, unsigned char *))(a1[8] + 96))(a1[6], a1[7], "fecfg", "esclang", &__c[3], &__c[1], __c);
                    if ((BestTNType & 0x80000000) != 0) {
                      goto LABEL_294;
                    }
                    if (*(_WORD *)&__c[1])
                    {
                      long long v165 = strstr(**(char ***)&__c[3], __s2);
                      unsigned int v142 = v206;
                      if (v165)
                      {
                        unsigned __int8 v166 = *__s1c;
                        if (*__s1c)
                        {
                          int v167 = 0;
                          do
                          {
                            v142[v146++] = ssft_tolower(v166);
                            unsigned __int8 v166 = __s1c[(unsigned __int16)++v167];
                          }
                          while (v166);
                        }
                        goto LABEL_261;
                      }
                      goto LABEL_255;
                    }
                  }
                  else if (!strcmp(__s1c, "latin"))
                  {
                    unsigned __int8 v168 = *__s1c;
                    unsigned int v142 = v206;
                    if (*__s1c)
                    {
                      int v169 = 0;
                      do
                      {
                        v142[v146++] = ssft_tolower(v168);
                        unsigned __int8 v168 = __s1c[(unsigned __int16)++v169];
                      }
                      while (v168);
                    }
                    goto LABEL_261;
                  }
                  unsigned int v142 = v206;
LABEL_255:
                  if (*v142) {
                    v142[v146 - 1] = 0;
                  }
                  else {
                    strcpy(v142, "normal");
                  }
LABEL_261:
                  if (strncmp(v142, "normal", 6uLL) && *v142)
                  {
                    v142[v146] = 0;
                    unsigned int v142 = v206;
                  }
LABEL_264:
                  *(_WORD *)&__c[1] = -1;
                  BestTNint Type = (*(uint64_t (**)(uint64_t, uint64_t, const char *, char *, unsigned char *, unsigned char *, unsigned char *))(a1[8] + 96))(a1[6], a1[7], "fecfg", v142, &__c[3], &__c[1], __c);
                  if ((BestTNType & 0x80000000) == 0)
                  {
                    if (*(_WORD *)&__c[1])
                    {
                      unsigned int v170 = strchr(**(char ***)&__c[3], __c[0]);
                      if (v170) {
                        *unsigned int v170 = 0;
                      }
                      hlp_CreatePauseDurParam(*a1, v142);
                      uint64_t v171 = *(const char ***)&__c[3];
                    }
                    else
                    {
                      uint64_t v171 = (const char **)&v206;
                    }
                    uint64_t v20 = v188;
                    unsigned int v91 = v189;
                    uint64_t v90 = 0;
                    uint64_t v89 = 0;
                    int v88 = 0;
                    unsigned int v85 = *v171;
                    uint64_t v86 = (uint64_t)v212;
                    uint64_t v87 = __s1c;
                    uint64_t v129 = v191;
LABEL_271:
                    uint64_t v92 = *(unsigned int *)(v86 + 32 * v129 + 12);
                    unsigned int v32 = v209;
LABEL_272:
                    if ((unsigned __int16)++v91 < (unsigned __int16)v32) {
                      continue;
                    }
LABEL_275:
                    __int16 v193 = v85;
                    uint64_t v172 = (char *)v89;
                    __int16 v173 = v92;
                    log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_INITLINGDB", 5, 0, (uint64_t)"Creating USER TN %s token in lingdb", v89, (uint64_t)v85, v92, (uint64_t)v85);
                    unsigned __int16 v174 = strlen(v216);
                    uint64_t inserted = hlp_InsertUserTNToken((char *)a1, a3, a4, HIWORD(v210), &v208, (unsigned __int16)(v173 - v196), v174, v193, v172, v87, v216, v195, (uint64_t)v212, v209);
                    if ((inserted & 0x80000000) != 0)
                    {
LABEL_286:
                      uint64_t v9 = inserted;
LABEL_287:
                      uint64_t v21 = v194;
                      goto LABEL_103;
                    }
                    uint64_t v175 = v209;
                    uint64_t v176 = 0;
                    if (v209)
                    {
                      uint64_t v177 = (uint64_t)v212;
                      unsigned __int16 v178 = v209;
                      while (*(_DWORD *)(v177 + 12) == v196)
                      {
                        ++v176;
                        --v178;
                        v177 += 32;
                        if (v209 == v176)
                        {
                          uint64_t v176 = v209;
                          goto LABEL_281;
                        }
                      }
                      if (v209 != (unsigned __int16)v176)
                      {
                        uint64_t v179 = 0;
                        uint64_t v180 = 0;
                        uint64_t v181 = (_DWORD *)(v177 + 4);
                        do
                        {
                          *(_DWORD *)(v20 + 4 * v180) = *(_DWORD *)(v177 + v179 + 4);
                          *(_DWORD *)(v177 + v179 + 4) = v180++;
                          v179 += 32;
                        }
                        while (v178 != v180);
                        marker_sort(v177, v175 - v176);
                        uint64_t v182 = v178;
                        do
                        {
                          *uint64_t v181 = *(_DWORD *)(v20 + 4 * *v181);
                          v181 += 8;
                          --v182;
                        }
                        while (v182);
LABEL_283:
                        uint64_t inserted = hlp_ReplacePauseZeroWithNluBndNo_And_WriteMarkersToLingDB(*a1, a1[9], a3, a4, HIWORD(v210), (uint64_t *)&v212, &v209);
                        if ((inserted & 0x80000000) == 0)
                        {
                          uint64_t inserted = (*(uint64_t (**)(uint64_t, uint64_t, void))(a1[10] + 96))(a1[114], a1[115], v214);
                          if ((inserted & 0x80000000) == 0) {
                            uint64_t inserted = (*(uint64_t (**)(uint64_t, uint64_t, void))(a1[10] + 96))(a1[116], a1[117], v211);
                          }
                        }
                        goto LABEL_286;
                      }
                    }
                    else
                    {
LABEL_281:
                      uint64_t v177 = (uint64_t)&v212[8 * v176];
                    }
                    marker_sort(v177, v209 - v176);
                    goto LABEL_283;
                  }
LABEL_294:
                  uint64_t v9 = BestTNType;
                  uint64_t v20 = v188;
                  goto LABEL_287;
                }
              }
              break;
            }
            if (hlp_LogUnsupportedTNType(*a1, v151)) {
              log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_INITLINGDB", 30004, "%s%s", v158, v159, v160, v161, "TNType");
            }
            if (!strcmp(__s1c, "normal"))
            {
              int v162 = strlen(__s1c);
              BestTNint Type = hlp_CopyString(*a1, (uint64_t *)&v206, "normal", v162 + 1);
              if ((BestTNType & 0x80000000) != 0) {
                goto LABEL_294;
              }
            }
            else
            {
              *int v151 = 0;
            }
            goto LABEL_231;
          }
        }
      }
LABEL_80:
      uint64_t v21 = 0;
      uint64_t v9 = v11;
      goto LABEL_103;
    }
LABEL_79:
    uint64_t v20 = 0;
    goto LABEL_80;
  }
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v12 + 96))(a1[114], a1[115], 1);
  if ((v13 & 0x80000000) != 0
    || (uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, unsigned int **, unsigned int *))(a1[10] + 88))(a1[116], a1[117], &v213, &v211), (v13 & 0x80000000) != 0))
  {
    uint64_t v9 = v13;
LABEL_101:
    uint64_t v20 = 0;
LABEL_102:
    uint64_t v21 = 0;
    goto LABEL_103;
  }
  if (HIDWORD(v217[0]))
  {
    unsigned __int16 v209 = v211 >> 5;
    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, unsigned int *, int *))(a1[9] + 160))(a3, a4, HIWORD(v210), 1, v209, v213, &v210);
    if ((v14 & 0x80000000) != 0)
    {
      uint64_t v9 = v14;
      uint64_t v51 = *(void *)(*a1 + 32);
      uint64_t v52 = 30002;
      goto LABEL_100;
    }
  }
  int v19 = (*(uint64_t (**)(uint64_t, uint64_t, void))(a1[10] + 96))(a1[116], a1[117], v211);
  uint64_t v20 = 0;
  uint64_t v21 = 0;
  uint64_t v9 = v19 & (v19 >> 31);
LABEL_103:
  if (v206)
  {
    heap_Free(*(void **)(*a1 + 8), (uint64_t)v206);
    int v206 = 0;
  }
  if (v21) {
    heap_Free(*(void **)(*a1 + 8), v21);
  }
  if (v212) {
    heap_Free(*(void **)(*a1 + 8), (uint64_t)v212);
  }
  if (v216) {
    heap_Free(*(void **)(*a1 + 8), (uint64_t)v216);
  }
  if (v20) {
    heap_Free(*(void **)(*a1 + 8), v20);
  }
  return v9;
}

uint64_t hlp_CopyString(uint64_t a1, uint64_t *a2, char *__s, int a4)
{
  if (__s) {
    int v8 = strlen(__s) + 1;
  }
  else {
    int v8 = 1;
  }
  uint64_t v9 = (char *)heap_Realloc(*(uint64_t **)(a1 + 8), *a2, (v8 + a4));
  if (v9)
  {
    if (__s) {
      uint64_t v9 = strcpy(v9, __s);
    }
    else {
      *uint64_t v9 = 0;
    }
    uint64_t v14 = 0;
    *a2 = (uint64_t)v9;
  }
  else
  {
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_INITLINGDB", 30000, 0, v10, v11, v12, v13, v16);
    return 2307923978;
  }
  return v14;
}

uint64_t hlp_ValidatePhoneticTranscription(uint64_t a1, char *a2, char *a3)
{
  uint64_t v3 = (uint64_t)a3;
  uint64_t v20 = *MEMORY[0x263EF8340];
  if (!a3) {
    return v3;
  }
  hlp_GetPhonSrcAndLanguageOfOriginFromPhonWithMetaData(a3, v19, v17);
  hlp_GetLowerCasedLng3FromLangTag(a1, a2, __s);
  if (strlen(__s) != 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 968);
  if (!v6 || !(*(unsigned int (**)(void, void))(v6 + 56))(*(void *)(a1 + 952), *(void *)(a1 + 960)))
  {
    if (!strcmp(__s, (const char *)(a1 + 948))) {
      return 0;
    }
    else {
      return 2307923968;
    }
  }
  uint64_t v7 = strstr((char *)v3, "_#_");
  if (v7)
  {
    int v8 = v7;
    do
    {
      *int v8 = 35;
      unsigned __int16 v9 = strlen((const char *)v3);
      memmove(v8 + 1, v8 + 3, v9 - (unint64_t)(unsigned __int16)((_WORD)v8 - v3) - 2);
      int v8 = strstr((char *)v3, "_#_");
    }
    while (v8);
  }
  if (hlp_checkDoClmInCurrentComponent((void *)a1)) {
    int v10 = hlp_checkDoClmForLng3((const char *)a1, __s);
  }
  else {
    int v10 = 0;
  }
  uint64_t v11 = strchr((char *)v3, 20);
  uint64_t v12 = v11;
  if (v11) {
    *uint64_t v11 = 0;
  }
  if (!v10)
  {
    uint64_t v14 = 0;
    uint64_t v3 = 0;
    if (!v11) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
  int v13 = strlen((const char *)v3);
  uint64_t v14 = heap_Alloc(*(void *)(*(void *)a1 + 8), (4 * v13 + 4));
  if (v14)
  {
    int v15 = strlen((const char *)v3);
    uint64_t v3 = (*(uint64_t (**)(void, void, char *, uint64_t, uint64_t, void, void, void))(*(void *)(a1 + 968) + 64))(*(void *)(a1 + 952), *(void *)(a1 + 960), __s, v3, v14, 0, 0, (4 * v15 + 4));
    if (!v12) {
      goto LABEL_23;
    }
LABEL_22:
    *uint64_t v12 = 20;
    goto LABEL_23;
  }
  uint64_t v3 = 2307923978;
  if (v12) {
    goto LABEL_22;
  }
LABEL_23:
  if (v14) {
    heap_Free(*(void **)(*(void *)a1 + 8), v14);
  }
  return v3;
}

uint64_t hlp_CreatePauseDurParam(uint64_t a1, char *__s)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  unsigned int v5 = 0;
  strcpy(__sa, "tnpausedur");
  size_t v3 = strlen(__s);
  uint64_t result = strlen(__sa);
  if (v3 < 255 - result)
  {
    __strcat_chk();
    uint64_t result = paramc_ParamGetUInt(*(void *)(a1 + 40), (uint64_t)__sa, &v5);
    if ((result & 0x80000000) == 0)
    {
      strcpy(__sa, "tnpausedur");
      __strcat_chk();
      return paramc_ParamSetUInt(*(void *)(a1 + 40), (uint64_t)__sa, v5);
    }
  }
  return result;
}

uint64_t hlp_InsertUserTNToken(char *a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned __int16 *a5, unsigned int a6, unsigned __int16 a7, const char *a8, char *a9, char *a10, const char *a11, int a12, uint64_t a13, unsigned __int16 a14)
{
  uint64_t v105 = *MEMORY[0x263EF8340];
  unsigned __int16 v102 = a7;
  __int16 v101 = 0;
  int v99 = 0;
  int v100 = 0;
  uint64_t v21 = *a5;
  BOOL v22 = hlp_checkDoClmInCurrentComponent(a1);
  hlp_GetLowerCasedLng3FromLangTag((uint64_t)a1, a10, __s);
  if (!*a5) {
    return 0;
  }
  unsigned __int16 v23 = *a5;
  unsigned int v92 = a4;
  __s2 = a1 + 948;
  do
  {
    uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, __int16 *))(*((void *)a1 + 9) + 168))(a2, a3, v23, 1, 1, (char *)&v100 + 2, &v101);
    if ((v28 & 0x80000000) != 0)
    {
LABEL_122:
      uint64_t v32 = *(void *)(*(void *)a1 + 32);
      uint64_t v84 = 30003;
      goto LABEL_127;
    }
    if (HIWORD(v100) < a6) {
      goto LABEL_8;
    }
    uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, int *, __int16 *))(*((void *)a1 + 9)
                                                                                                 + 168))(a2, a3, *a5, 0, 1, &v99, &v101);
    if ((v28 & 0x80000000) != 0) {
      goto LABEL_122;
    }
    if (v99 == 3 || HIWORD(v100) == v102)
    {
LABEL_8:
      char v29 = 1;
      goto LABEL_9;
    }
    uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t, void, unsigned __int16 *))(*((void *)a1 + 9) + 80))(a2, a3, *a5, a5);
    if ((v31 & 0x80000000) != 0) {
      return v31;
    }
    int v99 = 5;
    uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, int *, int *))(*((void *)a1 + 9)
                                                                                             + 160))(a2, a3, *a5, 0, 1, &v99, &v100);
    uint64_t v32 = *(void *)(*(void *)a1 + 32);
    if ((v28 & 0x80000000) != 0) {
      goto LABEL_126;
    }
    log_OutText(v32, (uint64_t)"FE_INITLINGDB", 5, 0, (uint64_t)"Creating token %u %u in lingdb", v25, v26, v27, HIWORD(v100));
    uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(*((void *)a1 + 9)
                                                                                               + 160))(a2, a3, *a5, 1, 1, (char *)&v100 + 2, &v100);
    if ((v33 & 0x80000000) != 0) {
      goto LABEL_124;
    }
    uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned __int16 *, int *))(*((void *)a1 + 9) + 160))(a2, a3, *a5, 2, 1, &v102, &v100);
    if ((v33 & 0x80000000) != 0) {
      goto LABEL_124;
    }
    __int16 v34 = strlen(a8);
    uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, const char *, int *))(*((void *)a1 + 9) + 160))(a2, a3, *a5, 4, (unsigned __int16)(v34 + 1), a8, &v100);
    if ((v28 & 0x80000000) != 0) {
      goto LABEL_125;
    }
    if (a12)
    {
      uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, const char *, int *))(*((void *)a1 + 9) + 160))(a2, a3, *a5, 6, 4, "lid", &v100);
      if ((v28 & 0x80000000) != 0) {
        return v28;
      }
    }
    if (!a9)
    {
      char v29 = 0;
      goto LABEL_9;
    }
    unsigned int v91 = v21;
    uint64_t v90 = a8;
    unsigned __int16 v35 = strstr(a9, "_#_");
    if (v35)
    {
      unsigned __int16 v36 = v35;
      do
      {
        *unsigned __int16 v36 = 35;
        unsigned __int16 v37 = strlen(a9);
        memmove(v36 + 1, v36 + 3, v37 - (unint64_t)(unsigned __int16)((_WORD)v36 - (_WORD)a9) - 2);
        unsigned __int16 v36 = strstr(a9, "_#_");
      }
      while (v36);
    }
    if (strlen(__s) != 3)
    {
      uint64_t v38 = a9;
      uint64_t v21 = v21;
      goto LABEL_110;
    }
    if (v22) {
      int v89 = hlp_checkDoClmForLng3(a1, __s);
    }
    else {
      int v89 = 0;
    }
    unsigned int v39 = strlen(a9);
    uint64_t v40 = heap_Alloc(*(void *)(*(void *)a1 + 8), 4 * v39 + 200);
    uint64_t v21 = v21;
    if (!v40)
    {
      log_OutPublic(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_INITLINGDB", 34000, 0, v41, v42, v43, v44, v86);
      return 2307923978;
    }
    uint64_t v38 = (char *)v40;
    hlp_GetPhonSrcAndLanguageOfOriginFromPhonWithMetaData(a9, v103, v97);
    __src[0] = 0;
    size_t v45 = strchr(a9, 20);
    if (v45)
    {
      int v46 = v45;
      __strcat_chk();
      *int v46 = 0;
    }
    uint64_t v47 = *((void *)a1 + 121);
    if (!v47
      || !(*(unsigned int (**)(void, void))(v47 + 56))(*((void *)a1 + 119), *((void *)a1 + 120)))
    {
      int v49 = strcmp(__s, __s2);
      if ((v28 & 0x80000000) != 0 || v49) {
        goto LABEL_49;
      }
      if (v89)
      {
LABEL_44:
        strcat(v38, __src);
      }
      else
      {
LABEL_46:
        int v50 = strcpy(v38, a9);
        strcat(v50, __src);
        if (strcmp(__s, __s2))
        {
          __int16 v51 = strlen(__s);
          uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, char *, int *))(*((void *)a1 + 9) + 160))(a2, a3, *a5, 6, (unsigned __int16)(v51 + 1), __s, &v100);
          if ((v31 & 0x80000000) != 0) {
            return v31;
          }
        }
      }
LABEL_110:
      __int16 v82 = strlen(v38);
      uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, char *, int *))(*((void *)a1 + 9)
                                                                                                + 160))(a2, a3, *a5, 3, (unsigned __int16)(v82 + 1), v38, &v100);
      if (v38 != a9) {
        heap_Free(*(void **)(*(void *)a1 + 8), (uint64_t)v38);
      }
      goto LABEL_112;
    }
    if (v89)
    {
      int v48 = strlen(a9);
      if (((*(uint64_t (**)(void, void, char *, char *, char *, void, void, void))(*((void *)a1 + 121) + 64))(*((void *)a1 + 119), *((void *)a1 + 120), __s, a9, v38, 0, 0, (4 * v48 + 4)) & 0x80000000) == 0)goto LABEL_44; {
    }
      }
    else if ((v28 & 0x80000000) == 0)
    {
      goto LABEL_46;
    }
LABEL_49:
    unsigned __int16 v96 = v102;
    uint64_t v52 = HIWORD(v100);
    uint64_t v53 = (char *)&a11[HIWORD(v100)];
    uint64_t v54 = strstr(v53, "§");
    if (v54 == v53)
    {
      strcpy(v38, __src);
      uint64_t v28 = 0;
    }
    else
    {
      uint64_t v55 = v54;
      if (v54)
      {
        uint64_t v56 = (char *)a11;
        do
        {
          unsigned int v57 = v96;
          if (v55 - v56 >= v96 || v55 == &v56[v52]) {
            goto LABEL_88;
          }
          if (v55 <= v56)
          {
            unsigned __int16 v87 = (_WORD)v55 - (_WORD)v56;
            unsigned __int16 v60 = 2;
          }
          else
          {
            unsigned __int16 v59 = (_WORD)v55 - (_WORD)v56 + 2;
            unsigned __int16 v60 = 2;
            uint64_t v61 = v55;
            while (1)
            {
              int v62 = *--v61;
              if (v62 != 32) {
                break;
              }
              ++v60;
              uint64_t v55 = v61;
              if (v61 <= v56)
              {
                unsigned __int16 v60 = v59;
                uint64_t v55 = v56;
                break;
              }
            }
            unsigned __int16 v87 = (_WORD)v55 - (_WORD)v56;
          }
          v96 -= v60;
          size_t v63 = strlen(&v55[v60]);
          memmove(v55, &v55[v60], v63 + 1);
          __int16 v64 = strlen(a11);
          uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, const char *, int *))(*((void *)a1 + 9) + 160))(a2, a3, v92, 0, (unsigned __int16)(v64 + 1), a11, &v100);
          if ((v31 & 0x80000000) != 0) {
            return v31;
          }
          uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned __int16 *, int *))(*((void *)a1 + 9) + 160))(a2, a3, *a5, 2, 1, &v96, &v100);
          if ((v31 & 0x80000000) != 0) {
            return v31;
          }
          int v94 = 0;
          unsigned __int16 v95 = *a5;
          uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t))(*((void *)a1 + 9) + 120))(a2, a3);
          if ((v31 & 0x80000000) != 0) {
            return v31;
          }
          unsigned __int16 v65 = v95;
          if (v95)
          {
            unsigned __int16 v88 = v60;
            unsigned int v66 = v60 + v87;
            do
            {
              uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, __int16 *))(*((void *)a1 + 9) + 168))(a2, a3, v65, 1, 1, (char *)&v94 + 2, &v101);
              if ((v31 & 0x80000000) != 0) {
                return v31;
              }
              uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, __int16 *))(*((void *)a1 + 9) + 168))(a2, a3, v95, 2, 1, &v94, &v101);
              if ((v31 & 0x80000000) != 0) {
                return v31;
              }
              BOOL v67 = v87 <= HIWORD(v94) && v66 >= HIWORD(v94);
              if (v67 && v87 <= (unsigned __int16)v94 && v66 >= (unsigned __int16)v94)
              {
                uint64_t v68 = v95;
                uint64_t v69 = v95;
              }
              else
              {
                uint64_t v68 = v95;
                if (v66 <= HIWORD(v94))
                {
                  HIWORD(v94) -= v88;
                  LOWORD(v94) = v94 - v88;
                  uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(*((void *)a1 + 9) + 160))(a2, a3, v95, 1, 1, (char *)&v94 + 2, &v100);
                  if ((v31 & 0x80000000) != 0) {
                    return v31;
                  }
                  uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, int *))(*((void *)a1 + 9) + 160))(a2, a3, v95, 2, 1, &v94, &v100);
                  if ((v31 & 0x80000000) != 0) {
                    return v31;
                  }
                  uint64_t v69 = 0;
                  uint64_t v68 = v95;
                }
                else
                {
                  uint64_t v69 = 0;
                }
              }
              uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unsigned __int16 *))(*((void *)a1 + 9)
                                                                                             + 120))(a2, a3, v68, &v95);
              if ((v31 & 0x80000000) != 0) {
                return v31;
              }
              if (v69)
              {
                uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*((void *)a1 + 9) + 192))(a2, a3, v69);
                if ((v31 & 0x80000000) != 0) {
                  return v31;
                }
              }
              unsigned __int16 v65 = v95;
            }
            while (v95);
          }
          uint64_t v52 = HIWORD(v100);
          uint64_t v56 = (char *)a11;
          uint64_t v55 = strstr((char *)&a11[HIWORD(v100)], "§");
        }
        while (v55);
        unsigned int v57 = v96;
LABEL_88:
        unsigned int v70 = v102;
        unsigned __int16 v71 = v102 - v57;
        if (v102 > v57)
        {
          if (a14)
          {
            int v73 = (int *)(a13 + 16);
            for (uint64_t i = a14; i; --i)
            {
              unsigned int v74 = *(v73 - 1);
              if (v74 <= v57)
              {
                int v79 = *v73;
                if (!*v73) {
                  goto LABEL_105;
                }
                unsigned __int16 v80 = v79 + v74;
                if (v57 >= v80) {
                  goto LABEL_105;
                }
                unsigned int v81 = (unsigned __int16)(v80 - v57);
                if (v81 >= v71) {
                  unsigned int v81 = v71;
                }
                int v78 = v79 - v81;
              }
              else
              {
                unsigned int v75 = (unsigned __int16)(v74 - v57);
                int v76 = *v73;
                unsigned int v77 = v70 - (unsigned __int16)v74;
                if (v70 < (unsigned __int16)v74) {
                  unsigned int v77 = 0;
                }
                if (!v76) {
                  unsigned int v77 = 0;
                }
                if (v75 >= v71) {
                  unsigned int v75 = v71;
                }
                *(v73 - 1) = v74 - v75;
                int v78 = v76 - v77;
              }
              int *v73 = v78;
LABEL_105:
              v73 += 8;
            }
          }
        }
      }
      uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, const char *, int *))(*((void *)a1 + 9) + 160))(a2, a3, *a5, 4, 7, "normal", &v100);
      heap_Free(*(void **)(*(void *)a1 + 8), (uint64_t)v38);
      if ((v28 & 0x80000000) != 0) {
        goto LABEL_125;
      }
      uint64_t v38 = 0;
    }
    uint64_t v21 = v91;
    if (v38) {
      goto LABEL_110;
    }
LABEL_112:
    if ((v28 & 0x80000000) != 0) {
      goto LABEL_125;
    }
    char v29 = 0;
    a8 = v90;
LABEL_9:
    if (HIWORD(v100) == v102) {
      return v28;
    }
    uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t, void, unsigned __int16 *))(*((void *)a1 + 9) + 120))(a2, a3, *a5, a5);
    char v30 = (int)v28 >= 0 ? v29 : 0;
    if ((v30 & 1) == 0) {
      return v28;
    }
    unsigned __int16 v23 = *a5;
  }
  while (*a5);
  if (HIWORD(v100) != a6) {
    return v28;
  }
  uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unsigned __int16 *))(*((void *)a1 + 9) + 80))(a2, a3, v21, a5);
  if ((v31 & 0x80000000) != 0) {
    return v31;
  }
  int v99 = 5;
  uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, int *, int *))(*((void *)a1 + 9) + 160))(a2, a3, *a5, 0, 1, &v99, &v100);
  uint64_t v32 = *(void *)(*(void *)a1 + 32);
  if ((v28 & 0x80000000) != 0) {
    goto LABEL_126;
  }
  log_OutText(v32, (uint64_t)"FE_INITLINGDB", 5, 0, (uint64_t)"Creating token %u %u in lingdb", v25, v26, v27, HIWORD(v100));
  uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(*((void *)a1 + 9)
                                                                                             + 160))(a2, a3, *a5, 1, 1, (char *)&v100 + 2, &v100);
  if ((v33 & 0x80000000) != 0
    || (uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned __int16 *, int *))(*((void *)a1 + 9) + 160))(a2, a3, *a5, 2, 1, &v102, &v100), (v33 & 0x80000000) != 0))
  {
LABEL_124:
    uint64_t v28 = v33;
    goto LABEL_125;
  }
  __int16 v83 = strlen(a8);
  uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, const char *, int *))(*((void *)a1 + 9)
                                                                                                  + 160))(a2, a3, *a5, 4, (unsigned __int16)(v83 + 1), a8, &v100);
  if ((v28 & 0x80000000) != 0)
  {
LABEL_125:
    uint64_t v32 = *(void *)(*(void *)a1 + 32);
LABEL_126:
    uint64_t v84 = 30002;
LABEL_127:
    log_OutPublic(v32, (uint64_t)"FE_INITLINGDB", v84, 0, v24, v25, v26, v27, v86);
  }
  return v28;
}

uint64_t hlp_LogUnsupportedTNType(uint64_t a1, char *__s)
{
  __s1 = 0;
  int v4 = strlen(__s);
  if ((paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"domainmngrtntypes", &__s1) & 0x80000000) != 0
    || (unsigned int v5 = __s1) == 0
    || !*__s1
    || (uint64_t v6 = strstr(__s1, __s)) == 0
    || (uint64_t v7 = v6, v6 != v5) && *(v6 - 1) != 124
    || (uint64_t result = 0, (v9 = v7[v4]) != 0) && v9 != 124)
  {
    if ((paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"extraesctn", &__s1) & 0x80000000) != 0) {
      return 1;
    }
    if (!__s1) {
      return 1;
    }
    uint64_t result = strcmp(__s1, __s);
    if (result) {
      return 1;
    }
  }
  return result;
}

uint64_t hlp_FindBestTNType(uint64_t a1, char *a2, int a3, char *__s1, const char **a5, int a6)
{
  *a5 = __s1;
  uint64_t result = strcmp(__s1, "internal-nuance-system-norm");
  if (result)
  {
    while (1)
    {
      int v13 = (char *)*a5;
      uint64_t v14 = strstr(a2, *a5);
      if (v14)
      {
        unsigned __int8 v15 = v14[strlen(v13)];
        if (a3 == v15) {
          return 0;
        }
        uint64_t result = 0;
        if (!v15 || v15 == 124) {
          return result;
        }
      }
      unsigned int v16 = strrchr(v13, 58);
      if (!v16) {
        break;
      }
      if (v13 == __s1)
      {
        *a5 = 0;
        uint64_t result = hlp_CopyString(a1, (uint64_t *)a5, __s1, a6);
        if ((result & 0x80000000) != 0) {
          return result;
        }
        unsigned int v16 = strrchr((char *)*a5, 58);
        if (!v16) {
          continue;
        }
      }
      *unsigned int v16 = 0;
    }
    if (v13 != __s1) {
      heap_Free(*(void **)(a1 + 8), (uint64_t)v13);
    }
    *a5 = 0;
    return 2307923968;
  }
  return result;
}

uint64_t hlp_ReplacePauseZeroWithNluBndNo_And_WriteMarkersToLingDB(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, unsigned __int16 *a7)
{
  uint64_t v7 = a7;
  __int16 v61 = 0;
  unsigned __int16 v14 = *a7;
  if (!*a7) {
    goto LABEL_36;
  }
  unsigned __int16 v15 = 0;
  unsigned int v16 = (_DWORD *)*a6;
  uint64_t v17 = *a7;
  uint64_t v18 = (_DWORD *)*a6;
  do
  {
    int v19 = *v18;
    v18 += 8;
    if (v19 == 8 && v16[6] == 1) {
      ++v15;
    }
    unsigned int v16 = v18;
    --v17;
  }
  while (v17);
  if (v15)
  {
    uint64_t v20 = 2307923978;
    uint64_t v21 = heap_Calloc(*(void **)(a1 + 8), 8, v15);
    if (!v21) {
      goto LABEL_46;
    }
    uint64_t v22 = v21;
    unsigned __int16 v14 = *v7;
    if (*v7)
    {
      uint64_t v53 = a2;
      uint64_t v54 = a3;
      uint64_t v55 = a4;
      unsigned int v56 = a5;
      unint64_t v23 = 0;
      unsigned __int16 v59 = v7;
      unsigned __int16 v60 = 0;
      int v24 = 0;
      unsigned int v25 = -1;
      uint64_t v57 = v21;
      while (1)
      {
        uint64_t v26 = *a6;
        uint64_t v27 = (_DWORD *)(*a6 + 32 * v23);
        if (*v27 == 1)
        {
          unsigned int v25 = v23;
        }
        else if ((v25 & 0x80000000) == 0 && *v27 == 8 && *(_DWORD *)(v26 + 32 * v23 + 24) == 1)
        {
          uint64_t v28 = v25;
          uint64_t v29 = v26 + 32 * v25;
          unsigned int v30 = *(_DWORD *)(v29 + 12);
          unsigned int v31 = v25;
          if (v14)
          {
            uint64_t v32 = 0;
            uint64_t v33 = (int *)*a6;
            unsigned int v31 = v25;
            do
            {
              unsigned int v34 = v33[3];
              BOOL v35 = v34 == v30;
              if (v34 > v30) {
                break;
              }
              int v37 = *v33;
              v33 += 8;
              int v36 = v37;
              BOOL v38 = v35 && v36 == 51;
              ++v32;
              if (v38) {
                unsigned int v31 = v32;
              }
            }
            while (v14 != v32);
            uint64_t v28 = v31;
          }
          int v39 = *(_DWORD *)(v29 + 4);
          if (v23 == v28)
          {
            uint64_t v7 = v59;
          }
          else
          {
            int v58 = v39;
            if (v23 + 1 == v14)
            {
              uint64_t v40 = v59;
            }
            else
            {
              memmove(v27, (const void *)(v26 + 32 * (v23 + 1)), 32 * (v14 + ~v24));
              uint64_t v40 = v59;
              unsigned __int16 v14 = *v59;
              uint64_t v26 = *a6;
            }
            unsigned __int16 v41 = v14 - 1;
            unsigned __int16 *v40 = v41;
            memmove((void *)(v26 + 32 * (int)(v31 + 1)), (const void *)(v26 + 32 * v28), 32 * (v41 - v31));
            ++*v40;
            uint64_t v26 = *a6;
            uint64_t v7 = v40;
            uint64_t v22 = v57;
            int v39 = v58;
          }
          uint64_t v42 = (_DWORD *)(v26 + 32 * v28);
          _DWORD *v42 = 51;
          v42[1] = v39;
          v42[2] = 0;
          v42[3] = v30;
          _OWORD v42[4] = 0;
          *(void *)(*a6 + 32 * v28 + 24) = heap_Alloc(*(void *)(a1 + 8), 6);
          uint64_t v43 = *(void *)(*a6 + 32 * v28 + 24);
          if (!v43)
          {
            uint64_t v20 = 2307923978;
            unsigned __int16 v44 = v60;
            goto LABEL_40;
          }
          *(void *)(v22 + 8 * v60) = v43;
          strcpy(*(char **)(*a6 + 32 * v28 + 24), "BND:N");
          unsigned __int16 v14 = *v7;
          ++v60;
        }
        ++v23;
        ++v24;
        if (v23 >= v14)
        {
          a5 = v56;
          a3 = v54;
          a4 = v55;
          a2 = v53;
          unsigned __int16 v44 = v60;
          goto LABEL_37;
        }
      }
    }
    unsigned __int16 v44 = 0;
  }
  else
  {
LABEL_36:
    unsigned __int16 v44 = 0;
    uint64_t v22 = 0;
  }
LABEL_37:
  uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, uint64_t, __int16 *))(a2 + 160))(a3, a4, a5, 1, v14, *a6, &v61);
  if ((v20 & 0x80000000) != 0) {
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"FE_INITLINGDB", 30002, 0, v45, v46, v47, v48, v52);
  }
  if (v22)
  {
LABEL_40:
    if (v44)
    {
      uint64_t v49 = v44;
      int v50 = (uint64_t *)v22;
      do
      {
        if (*v50) {
          heap_Free(*(void **)(a1 + 8), *v50);
        }
        ++v50;
        --v49;
      }
      while (v49);
    }
    heap_Free(*(void **)(a1 + 8), v22);
  }
LABEL_46:
  heap_Free(*(void **)(a1 + 8), *a6);
  *a6 = 0;
  *uint64_t v7 = 0;
  return v20;
}

uint64_t fe_initlingdb_ProcessEnd(uint64_t a1, int a2)
{
  if ((safeh_HandleCheck(a1, a2, 62336, 976) & 0x80000000) != 0) {
    return 2307923976;
  }
  uint64_t v3 = *(void *)(a1 + 80);
  return synstrmaux_CloseStreams((_WORD *)(a1 + 88), v3);
}

uint64_t fe_initlingdb_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2307923969;
  }
  uint64_t result = 0;
  *a2 = &IFeInitlingdb;
  return result;
}

size_t hlp_GetPhonSrcAndLanguageOfOriginFromPhonWithMetaData(char *a1, char *a2, unsigned char *a3)
{
  *(void *)a2 = 0x504B524D545845;
  *a3 = 0;
  size_t result = (size_t)strchr(a1, 20);
  if (result)
  {
    uint64_t v6 = (const char *)(result + 1);
    size_t result = (size_t)strchr((char *)(result + 1), 20);
    size_t v7 = result;
    if (result)
    {
      size_t v8 = result - (void)v6;
    }
    else
    {
      size_t result = strlen(v6);
      size_t v8 = result;
    }
    if (v8 <= 9)
    {
      size_t result = (size_t)strncpy(a2, v6, v8);
      a2[v8] = 0;
    }
    if (v7)
    {
      size_t v9 = v7 + 1;
      size_t result = strlen((const char *)(v7 + 1));
      if (result == 3 || result >= 4 && (size_t result = strcmp((const char *)(v7 + 4), "\x14"), !result))
      {
        for (uint64_t i = 0; i != 3; ++i)
        {
          size_t result = ssft_tolower(*(unsigned __int8 *)(v9 + i));
          a3[i] = result;
        }
        a3[3] = 0;
      }
    }
  }
  return result;
}

char *hlp_GetLowerCasedLng3FromLangTag(uint64_t a1, char *a2, char *__dst)
{
  if (*a2 && LH_stricmp(a2, "normal"))
  {
    size_t result = (char *)strlen(a2);
    if (result == (char *)3)
    {
      size_t result = strcpy(__dst, a2);
      if (*__dst)
      {
        uint64_t v7 = 0;
        int v8 = 0;
        do
        {
          __dst[v7] = ssft_tolower(__dst[v7]);
          uint64_t v7 = ++v8;
          size_t result = (char *)strlen(__dst);
        }
        while ((unint64_t)result > v8);
      }
    }
    else
    {
      unsigned char *__dst = 0;
    }
  }
  else
  {
    return strcpy(__dst, (const char *)(a1 + 948));
  }
  return result;
}

BOOL hlp_checkDoClmInCurrentComponent(void *a1)
{
  __s1 = 0;
  int v3 = 0;
  if (((*(uint64_t (**)(void, void, int *))(a1[121] + 96))(a1[119], a1[120], &v3) & 0x80000000) != 0) {
    return (paramc_ParamGetStr(*(void *)(*a1 + 40), (uint64_t)"clm", &__s1) & 0x80000000) != 0
  }
        || !__s1
        || !strcmp(__s1, "yes");
  BOOL result = 0;
  if (!v3) {
    return (paramc_ParamGetStr(*(void *)(*a1 + 40), (uint64_t)"clm", &__s1) & 0x80000000) != 0
  }
        || !__s1
        || !strcmp(__s1, "yes");
  return result;
}

uint64_t hlp_checkDoClmForLng3(const char *a1, char *__s1)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  __s1a = 0;
  uint64_t result = strcmp(__s1, a1 + 948);
  if (result)
  {
    v8[0] = 7171171;
    __strcat_chk();
    if ((paramc_ParamGetStr(*(void *)(*(void *)a1 + 40), (uint64_t)v8, &__s1a) & 0x80000000) != 0
      || (unsigned int v5 = __s1a) == 0)
    {
      __s1a = 0;
      int Str = paramc_ParamGetStr(*(void *)(*(void *)a1 + 40), (uint64_t)"noclmset", &__s1a);
      unsigned int v5 = __s1a;
      if (Str < 0 || !__s1a)
      {
        if (!__s1a) {
          return 1;
        }
      }
      else
      {
        if (strstr(__s1a, __s1)) {
          unsigned int v5 = "no";
        }
        else {
          unsigned int v5 = "yes";
        }
        __s1a = v5;
      }
    }
    return strcmp(v5, "yes") == 0;
  }
  return result;
}

uint64_t fe_initlingdb_ClassOpen(_WORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0;
  if (!a3) {
    return 2307923975;
  }
  *(void *)a3 = 0;
  *(_DWORD *)(a3 + 8) = 0;
  uint64_t result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *(void *)a3 = a1;
    *(void *)(a3 + 8) = a2;
  }
  return result;
}

uint64_t fe_initlingdb_ClassClose()
{
  return 0;
}

uint64_t CLM_InitFromCLMv2Lua(uint64_t a1, const char *a2)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v51 = 0;
  memset(v50, 0, sizeof(v50));
  uint64_t v49 = 0;
  int Allocator = ooc_utils_createAllocator((uint64_t)v50, *(_WORD **)(a1 + 32), *(void *)(a1 + 40));
  uint64_t v5 = LH_ERROR_to_VERROR(Allocator);
  if ((v5 & 0x80000000) != 0) {
    goto LABEL_35;
  }
  int v6 = luavmldoutil_initialize_lua_vm(*(_WORD **)(a1 + 32), *(void *)(a1 + 40), (uint64_t)v50, (uint64_t)"getForeignLangSupportForCLMv2", (uint64_t)hlp_lua_log_callback_2, &v49, "clm");
  uint64_t v7 = 0;
  uint64_t v8 = v49;
  if ((v6 & 0x80000000) == 0 && v49)
  {
    *(_DWORD *)(a1 + 200) = 0;
    int v9 = LuaVMLDO_RunFunctionReturningString(v8, (uint64_t)"getForeignLangSupportForCLMv2", (uint64_t)a2, 0x400u, __s1);
    uint64_t v5 = LH_ERROR_to_VERROR(v9);
    if ((v5 & 0x80000000) == 0)
    {
      if (__s1[0]
        || (int v47 = LuaVMLDO_RunFunctionReturningString(v8, (uint64_t)"getFeClmSupportedLanguages", (uint64_t)"all", 0x400u, __s1), (LH_ERROR_to_VERROR(v47) & 0x80000000) == 0)&& strstr(__s1, a2))
      {
        *(_DWORD *)(a1 + 200) = 1;
      }
      uint64_t v10 = v49;
      *(void *)__s1 = 0;
      int v11 = PNEW_LDOObject_Con((uint64_t)v50, (uint64_t)v50, (uint64_t *)__s1);
      uint64_t v12 = LH_ERROR_to_VERROR(v11);
      if ((v12 & 0x80000000) != 0)
      {
        uint64_t v7 = v12;
        log_OutText(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"Error creating LDOObject", v13, v14, v15, v48);
      }
      else
      {
        int v16 = LuaVMLDO_RunFunctionWithStringArgumentReturningTableWithStrings(v10, (uint64_t)"getLoanPhonemeSupport", (uint64_t)a2, *(uint64_t *)__s1);
        uint64_t v17 = LH_ERROR_to_VERROR(v16);
        if ((v17 & 0x80000000) != 0)
        {
          uint64_t v7 = 0;
        }
        else
        {
          uint64_t v7 = v17;
          uint64_t v18 = *(uint64_t **)(*(void *)__s1 + 32);
          unint64_t v19 = *(void *)(*(void *)__s1 + 40);
          *(_WORD *)(a1 + 204) = (v19 - (unint64_t)v18) >> 5;
          if (((v19 - (void)v18) & 0x1FFFE0) != 0)
          {
            uint64_t v20 = heap_Calloc(*(void **)(*(void *)(a1 + 24) + 8), (unsigned __int16)((v19 - (unint64_t)v18) >> 5), 16);
            *(void *)(a1 + 208) = v20;
            if (v20)
            {
              if ((unint64_t)v18 < v19)
              {
                unsigned __int16 v25 = 0;
                LODWORD(v48) = v19;
                while (1)
                {
                  uint64_t v26 = v18[3];
                  uint64_t v27 = (const char *)fst::FstImpl<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::Properties(*v18);
                  if (strlen(v27) != 3) {
                    goto LABEL_49;
                  }
                  for (uint64_t i = 0; i != 3; ++i)
                    *(unsigned char *)(*(void *)(a1 + 208) + 16 * v25 + i) = __tolower(v27[i]);
                  uint64_t v29 = (char *)fst::FstImpl<fst::ArcTpl<fst::TropicalWeightTpl<float>>>::Properties(v26);
                  if (!v29 || (unsigned int v30 = v29, !*v29))
                  {
LABEL_49:
                    uint64_t v7 = 2347769856;
                    goto LABEL_51;
                  }
                  unsigned int v31 = strstr(v29, "||");
                  for (unsigned __int16 j = 1; v31; ++j)
                  {
                    int v34 = v31[2];
                    uint64_t v33 = v31 + 2;
                    if (!v34) {
                      break;
                    }
                    unsigned int v31 = strstr(v33, "||");
                  }
                  *(_WORD *)(*(void *)(a1 + 208) + 16 * v25 + 4) = j;
                  uint64_t v35 = heap_Calloc(*(void **)(*(void *)(a1 + 24) + 8), j, 24);
                  *(void *)(*(void *)(a1 + 208) + 16 * v25 + 8) = v35;
                  if (!v35) {
                    goto LABEL_50;
                  }
                  int v36 = strchr(v30, 124);
                  if (v36) {
                    break;
                  }
LABEL_33:
                  ++v25;
                  v18 += 4;
                  if ((unint64_t)v18 >= v19) {
                    goto LABEL_51;
                  }
                }
                int v37 = v36;
                unsigned __int16 v38 = 0;
                while (1)
                {
                  unsigned int v39 = v38;
                  uint64_t v40 = hlp_AllocAndCopy(*(void *)(a1 + 24), (char **)(*(void *)(*(void *)(a1 + 208) + 16 * v25 + 8) + 24 * v38), v30, (uint64_t)v37);
                  if ((v40 & 0x80000000) != 0) {
                    break;
                  }
                  unsigned __int16 v41 = strchr(v37 + 1, 124);
                  if (!v41) {
                    goto LABEL_32;
                  }
                  uint64_t v42 = v41;
                  uint64_t v40 = hlp_AllocAndCopy(*(void *)(a1 + 24), (char **)(*(void *)(*(void *)(a1 + 208) + 16 * v25 + 8) + 24 * v39 + 8), v37 + 1, (uint64_t)v41);
                  if ((v40 & 0x80000000) != 0) {
                    break;
                  }
                  uint64_t v43 = v42 + 1;
                  unsigned __int16 v44 = strchr(v43, 124);
                  if (!v44) {
                    unsigned __int16 v44 = &v43[strlen(v43)];
                  }
                  uint64_t v40 = hlp_AllocAndCopy(*(void *)(a1 + 24), (char **)(*(void *)(*(void *)(a1 + 208) + 16 * v25 + 8) + 24 * v39 + 16), v43, (uint64_t)v44);
                  if ((v40 & 0x80000000) != 0) {
                    break;
                  }
                  uint64_t v45 = strstr(v43, "||");
                  if (v45)
                  {
                    unsigned int v30 = v45 + 2;
                    int v37 = strchr(v45 + 2, 124);
                    unsigned __int16 v38 = v39 + 1;
                    if (v37) {
                      continue;
                    }
                  }
LABEL_32:
                  uint64_t v7 = 0;
                  goto LABEL_33;
                }
                uint64_t v7 = v40;
              }
            }
            else
            {
LABEL_50:
              log_OutPublic(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 50000, 0, v21, v22, v23, v24, v48);
              uint64_t v7 = 2347769866;
            }
          }
        }
      }
LABEL_51:
      if (*(void *)__s1) {
        OOC_PlacementDeleteObject((uint64_t)v50, *(uint64_t *)__s1);
      }
      goto LABEL_36;
    }
LABEL_35:
    uint64_t v7 = v5;
LABEL_36:
    uint64_t v8 = v49;
  }
  if (v8) {
    luavmldoutil_destroy_lua_vm((uint64_t)v50, &v49);
  }
  kaldi::nnet1::Component::IsUpdatable((kaldi::nnet1::Component *)v50);
  if ((v7 & 0x80000000) != 0) {
    CLM_DeInitFromCLMv2Lua((void *)a1);
  }
  return v7;
}

uint64_t hlp_lua_log_callback_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return log_OutText(a1, (uint64_t)"CLM", 4, 0, a2, a6, a7, a8, 0);
}

void *CLM_DeInitFromCLMv2Lua(void *result)
{
  uint64_t v1 = result;
  *((_DWORD *)result + 50) = 0;
  uint64_t v2 = result[26];
  if (v2)
  {
    unsigned int v3 = *((unsigned __int16 *)result + 102);
    if (*((_WORD *)result + 102))
    {
      unint64_t v4 = 0;
      do
      {
        unint64_t v5 = v2 + 16 * v4;
        uint64_t v6 = *(void *)(v5 + 8);
        if (v6)
        {
          if (*(_WORD *)(v5 + 4))
          {
            uint64_t v7 = 0;
            unint64_t v8 = 0;
            do
            {
              uint64_t v9 = *(void *)(v2 + 16 * v4 + 8);
              uint64_t v10 = *(void *)(v9 + v7);
              if (v10)
              {
                heap_Free(*(void **)(v1[3] + 8), v10);
                uint64_t v2 = v1[26];
                uint64_t v9 = *(void *)(v2 + 16 * v4 + 8);
                *(void *)(v9 + v7) = 0;
              }
              uint64_t v11 = *(void *)(v9 + v7 + 8);
              if (v11)
              {
                heap_Free(*(void **)(v1[3] + 8), v11);
                uint64_t v2 = v1[26];
                uint64_t v9 = *(void *)(v2 + 16 * v4 + 8);
                *(void *)(v9 + v7 + 8) = 0;
              }
              uint64_t v12 = *(void *)(v9 + v7 + 16);
              if (v12)
              {
                heap_Free(*(void **)(v1[3] + 8), v12);
                uint64_t v2 = v1[26];
                *(void *)(*(void *)(v2 + 16 * v4 + 8) + v7 + 16) = 0;
              }
              ++v8;
              unint64_t v13 = v2 + 16 * v4;
              v7 += 24;
            }
            while (v8 < *(unsigned __int16 *)(v13 + 4));
            uint64_t v6 = *(void *)(v13 + 8);
          }
          heap_Free(*(void **)(v1[3] + 8), v6);
          uint64_t v2 = v1[26];
          *(void *)(v2 + 16 * v4 + 8) = 0;
          unsigned int v3 = *((unsigned __int16 *)v1 + 102);
        }
        ++v4;
      }
      while (v4 < v3);
    }
    uint64_t result = heap_Free(*(void **)(v1[3] + 8), v2);
    v1[26] = 0;
  }
  *((_WORD *)v1 + 102) = 0;
  return result;
}

uint64_t hlp_AllocAndCopy(uint64_t a1, char **a2, char *__s, uint64_t a4)
{
  if (a4) {
    size_t v7 = a4 - (void)__s;
  }
  else {
    size_t v7 = strlen(__s);
  }
  unint64_t v8 = (char *)heap_Calloc(*(void **)(a1 + 8), v7 + 1, 1);
  *a2 = v8;
  if (v8)
  {
    strncpy(v8, __s, v7);
    return 0;
  }
  else
  {
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"CLM", 50000, 0, v9, v10, v11, v12, v14);
    return 2347769866;
  }
}

uint64_t CLM_AlignPhonlists(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  if (!a3 || !a4) {
    return 2347769856;
  }
  int CountStrings = StringList_GetCountStrings(a3);
  int v9 = StringList_GetCountStrings(a4);
  uint64_t v46 = a1;
  if (a2 && StringList_GetCountStrings(a2) != CountStrings)
  {
    uint64_t v14 = 2347769856;
    goto LABEL_79;
  }
  unsigned int v10 = StringList_GetCountStrings(a3);
  unsigned int v11 = StringList_GetCountStrings(a4);
  unsigned int v12 = v11;
  if (CountStrings && v9)
  {
    unsigned __int16 v13 = 0;
    if (v10)
    {
      uint64_t v14 = 0;
      uint64_t v47 = a2;
      while (v13 < (unsigned __int16)v12)
      {
        uint64_t v15 = (const char *)StringList_GetAt(a3, v13);
        if (!strcmp(v15, "*"))
        {
          int v18 = StringList_InsertAt(a4, v13, "*");
          if (v18)
          {
            uint64_t v14 = LH_ERROR_to_VERROR(v18);
            if ((v14 & 0x80000000) != 0) {
              goto LABEL_79;
            }
          }
          else
          {
            uint64_t v14 = 0;
          }
          LOWORD(v12) = v12 + 1;
        }
        else
        {
          int v16 = (const char *)StringList_GetAt(a3, v13);
          a2 = v47;
          uint64_t v17 = (const char *)StringList_GetAt(a4, v13);
          if (strcmp(v16, v17)) {
            break;
          }
        }
        if (v10 <= ++v13)
        {
          unsigned __int16 v13 = v10;
          goto LABEL_58;
        }
      }
      if (v10 > v13)
      {
        while (1)
        {
          __int16 v25 = v12;
          __int16 v26 = v10;
          if ((unsigned __int16)v12 <= v13) {
            break;
          }
          LOWORD(v10) = v10 - 1;
          uint64_t v27 = (const char *)StringList_GetAt(a3, (unsigned __int16)(v26 - 1));
          if (!strcmp(v27, "*"))
          {
            int v31 = StringList_InsertAt(a4, (unsigned __int16)v12, "*");
            if (v31)
            {
              uint64_t v14 = LH_ERROR_to_VERROR(v31);
              a2 = v47;
              if ((v14 & 0x80000000) != 0) {
                goto LABEL_79;
              }
            }
            else
            {
              uint64_t v14 = 0;
              a2 = v47;
            }
          }
          else
          {
            uint64_t v28 = (const char *)StringList_GetAt(a3, (unsigned __int16)(v26 - 1));
            LOWORD(v12) = v12 - 1;
            uint64_t v29 = (const char *)StringList_GetAt(a4, (unsigned __int16)(v25 - 1));
            int v30 = strcmp(v28, v29);
            a2 = v47;
            if (v30) {
              break;
            }
          }
          if ((unsigned __int16)v10 <= v13) {
            goto LABEL_58;
          }
        }
        LOWORD(v10) = v26;
        LOWORD(v12) = v25;
      }
LABEL_58:
      uint64_t v21 = v14;
    }
    else
    {
      uint64_t v21 = 0;
    }
    int v32 = StringList_GetCountStrings(a3) - (unsigned __int16)v10;
    uint64_t v14 = 2347769856;
    if (v32 == StringList_GetCountStrings(a4) - (unsigned __int16)v12)
    {
      if ((v21 & 0x80000000) != 0)
      {
        uint64_t v14 = v21;
      }
      else if (v13 != (unsigned __int16)v10 || (uint64_t v14 = v21, v13 != (unsigned __int16)v12))
      {
        unsigned __int16 v50 = 0;
        uint64_t v33 = hlp_RecursiveAddBestAnchorsForSublist(v46, a3, v13, (unsigned __int16)v10, a4, v13, (unsigned __int16)v12, (unsigned __int16 *)&v48, &v50);
        if ((v33 & 0x80000000) != 0)
        {
          uint64_t v14 = v33;
        }
        else
        {
          if (v50 == 0xFFFF) {
            uint64_t v34 = 0;
          }
          else {
            uint64_t v34 = v48 + 16 * v50;
          }
          uint64_t v35 = hlp_Align(a2, a3, a4, (unsigned __int16)v10, (unsigned __int16)v12, v34);
          unsigned int v36 = v35;
          if ((v35 & 0x80000000) != 0)
          {
            uint64_t v14 = v35;
          }
          else
          {
            int v37 = StringList_GetCountStrings(a3);
            int v38 = StringList_GetCountStrings(a4);
            if (v37 == v38) {
              uint64_t v14 = v36;
            }
            else {
              uint64_t v14 = 2347769856;
            }
            if (a2 && v37 == v38)
            {
              if (StringList_GetCountStrings(a2) == v37) {
                uint64_t v14 = v36;
              }
              else {
                uint64_t v14 = 2347769856;
              }
            }
          }
        }
      }
    }
    goto LABEL_79;
  }
  if (v10)
  {
    if (!v11)
    {
      int v19 = 0;
      do
      {
        int v20 = StringList_Append(a4, "*");
        if (v20)
        {
          uint64_t v14 = LH_ERROR_to_VERROR(v20);
          if ((v14 & 0x80000000) != 0) {
            goto LABEL_79;
          }
        }
        else
        {
          uint64_t v14 = 0;
        }
        ++v19;
      }
      while (v10 > (unsigned __int16)v19);
      goto LABEL_79;
    }
    goto LABEL_45;
  }
  if (v11)
  {
    int v22 = 0;
    while (1)
    {
      int v23 = StringList_Append(a3, "*");
      if (v23)
      {
        uint64_t v14 = LH_ERROR_to_VERROR(v23);
        if ((v14 & 0x80000000) != 0) {
          goto LABEL_79;
        }
        if (a2)
        {
LABEL_39:
          int v24 = StringList_Append(a2, "*");
          if (v24)
          {
            uint64_t v14 = LH_ERROR_to_VERROR(v24);
            if ((v14 & 0x80000000) != 0) {
              goto LABEL_79;
            }
          }
          else
          {
            uint64_t v14 = 0;
          }
        }
      }
      else
      {
        uint64_t v14 = 0;
        if (a2) {
          goto LABEL_39;
        }
      }
      if (v12 <= (unsigned __int16)++v22) {
        goto LABEL_79;
      }
    }
  }
LABEL_45:
  uint64_t v14 = 0;
LABEL_79:
  uint64_t v39 = v48;
  if (v48)
  {
    unsigned int v40 = (unsigned __int16)v49;
    if ((_WORD)v49)
    {
      unint64_t v41 = 0;
      uint64_t v42 = 8;
      uint64_t v43 = v46;
      do
      {
        uint64_t v44 = *(void *)(v48 + v42);
        if (v44)
        {
          heap_Free(*(void **)(v46 + 8), v44);
          unsigned int v40 = (unsigned __int16)v49;
        }
        ++v41;
        v42 += 16;
      }
      while (v41 < v40);
      uint64_t v39 = v48;
    }
    else
    {
      uint64_t v43 = v46;
    }
    heap_Free(*(void **)(v43 + 8), v39);
  }
  return v14;
}

uint64_t hlp_RecursiveAddBestAnchorsForSublist(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5, unsigned int a6, uint64_t a7, unsigned __int16 *a8, _WORD *a9)
{
  uint64_t v10 = 0;
  uint64_t v68 = 0;
  *a9 = -1;
  if (a3 < a4 && a6 < a7)
  {
    if (!a8 || (uint64_t v15 = a8[4]) == 0)
    {
LABEL_9:
      int v67 = 0;
      uint64_t v68 = 0;
      unsigned __int16 v18 = a3 + 1;
      unsigned __int16 v19 = a6;
      do
      {
        int v20 = (const char *)StringList_GetAt(a2, a3);
        uint64_t v21 = (const char *)StringList_GetAt(a5, v19);
        unsigned __int16 v22 = v19 + 1;
        if (!strcmp(v20, v21))
        {
          uint64_t appended = hlp_RecursiveAddBestAnchorsForSublist(a1, a2, v18, a4, a5, (unsigned __int16)(v19 + 1), a7, a8, &v67);
          if ((appended & 0x80000000) != 0) {
            goto LABEL_20;
          }
          uint64_t v24 = (unsigned __int16)v67 == 0xFFFFLL ? 0 : *(void *)a8 + 16 * (unsigned __int16)v67;
          uint64_t appended = hlp_AppendCombinedResult(a1, a3, v19, v24, (uint64_t *)&v68, (unsigned __int16 *)&v67 + 1);
          if ((appended & 0x80000000) != 0) {
            goto LABEL_20;
          }
        }
        ++v19;
      }
      while (a7 > v22);
      __int16 v25 = a8;
      uint64_t appended = hlp_RecursiveAddBestAnchorsForSublist(a1, a2, v18, a4, a5, a6, a7, a8, &v67);
      if ((appended & 0x80000000) != 0)
      {
LABEL_20:
        uint64_t v10 = appended;
        goto LABEL_60;
      }
      if ((unsigned __int16)v67 == 0xFFFFLL) {
        uint64_t v26 = 0;
      }
      else {
        uint64_t v26 = *(void *)a8 + 16 * (unsigned __int16)v67;
      }
      uint64_t v27 = hlp_AppendCombinedResult(a1, 65534, 65534, v26, (uint64_t *)&v68, (unsigned __int16 *)&v67 + 1);
      if ((v27 & 0x80000000) == 0)
      {
        uint64_t v28 = v68;
        if (v68 && (uint64_t v29 = (unsigned __int16 *)*v68) != 0)
        {
          unsigned __int16 v30 = 0;
          unsigned __int16 v31 = 0;
          unsigned __int16 v32 = -1;
          unsigned __int16 v33 = -1;
          do
          {
            int v34 = 0;
            do
            {
              unsigned __int16 v35 = v34;
              int v36 = (__int16)v29[2 * (unsigned __int16)v34++];
            }
            while (v36 != -1);
            if (v35 <= v31)
            {
              if (v35 && v35 == v31)
              {
                int v41 = *v29;
                if (v41 == 0xFFFF)
                {
                  unsigned __int16 v44 = 0;
                }
                else
                {
                  uint64_t v42 = 0;
                  int v43 = 0;
                  unsigned __int16 v44 = 0;
                  do
                  {
                    __int16 v45 = v41 - v29[2 * v42 + 1];
                    v44 += v45 * v45;
                    uint64_t v42 = (unsigned __int16)++v43;
                    int v41 = v29[2 * (unsigned __int16)v43];
                  }
                  while (v41 != 0xFFFF);
                }
                if (v44 < v33)
                {
                  unsigned __int16 v32 = v30;
                  unsigned __int16 v33 = v44;
                }
              }
            }
            else
            {
              int v37 = *v29;
              if (v37 == 0xFFFF)
              {
                unsigned __int16 v33 = 0;
              }
              else
              {
                uint64_t v38 = 0;
                int v39 = 0;
                unsigned __int16 v33 = 0;
                do
                {
                  __int16 v40 = v37 - v29[2 * v38 + 1];
                  v33 += v40 * v40;
                  uint64_t v38 = (unsigned __int16)++v39;
                  int v37 = v29[2 * (unsigned __int16)v39];
                }
                while (v37 != 0xFFFF);
              }
              unsigned __int16 v32 = v30;
              unsigned __int16 v31 = v35;
            }
            uint64_t v29 = (unsigned __int16 *)v68[++v30];
          }
          while (v29);
        }
        else
        {
          unsigned __int16 v32 = -1;
        }
        uint64_t v46 = v25[4];
        if (v46 == v25[5])
        {
          uint64_t v10 = 2347769856;
          if (v46 > 0xFFFC) {
            goto LABEL_60;
          }
          uint64_t v47 = heap_Realloc(*(uint64_t **)(a1 + 8), *(void *)v25, 16 * v46 + 32);
          *(void *)__int16 v25 = v47;
          if (!v47)
          {
            log_OutPublic(*(void *)(a1 + 32), (uint64_t)"CLM", 50000, 0, v48, v49, v50, v51, v64);
            uint64_t v10 = 2347769866;
            goto LABEL_60;
          }
          v25[5] += 2;
          LODWORD(v46) = v25[4];
        }
        else
        {
          uint64_t v47 = *(void *)v25;
        }
        unsigned int v52 = (_WORD *)(v47 + 16 * v46);
        *unsigned int v52 = a3;
        v52[1] = a6;
        if (v32 == 0xFFFF)
        {
          uint64_t v59 = v47 + 16 * v46;
          *(_WORD *)(v59 + 4) = 0;
          *(void *)(v59 + 8) = 0;
        }
        else
        {
          int v53 = 0;
          do
          {
            __int16 v54 = v53;
            uint64_t v55 = (unsigned __int16)v53;
            int v56 = *(__int16 *)(v28[v32] + 4 * (unsigned __int16)v53++);
          }
          while (v56 != -1);
          *(_WORD *)(v47 + 16 * v46 + 4) = v54;
          uint64_t v57 = (void *)heap_Calloc(*(void **)(a1 + 8), 4, v55);
          uint64_t v58 = *(void *)v25 + 16 * v25[4];
          *(void *)(v58 + 8) = v57;
          memmove(v57, (const void *)v28[v32], 4 * *(unsigned __int16 *)(v58 + 4));
          LOWORD(v46) = v25[4];
        }
        *a9 = v46;
        ++v25[4];
      }
      uint64_t v10 = v27;
      goto LABEL_60;
    }
    int v16 = (unsigned __int16 *)(*(void *)a8 + 2);
    while (*(v16 - 1) != a3 || *v16 != a6)
    {
      v16 += 8;
      if (!--v15) {
        goto LABEL_9;
      }
    }
    uint64_t v10 = 0;
  }
LABEL_60:
  uint64_t v60 = (uint64_t)v68;
  if (v68)
  {
    uint64_t v61 = *v68;
    if (*v68)
    {
      int v62 = 0;
      do
      {
        heap_Free(*(void **)(a1 + 8), v61);
        uint64_t v61 = *(void *)(v60 + 8 * (unsigned __int16)++v62);
      }
      while (v61);
    }
    heap_Free(*(void **)(a1 + 8), v60);
  }
  return v10;
}

uint64_t hlp_Align(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6)
{
  StringList_GetCountStrings(a2);
  StringList_GetCountStrings(a3);
  uint64_t v24 = a6;
  if (a6) {
    unsigned int v25 = *(unsigned __int16 *)(a6 + 4);
  }
  else {
    unsigned int v25 = 0;
  }
  unsigned int v10 = 0;
  uint64_t result = 0;
  unsigned __int16 v12 = 0;
  int v13 = 0;
  int v26 = 0;
  int v14 = 0;
  int v15 = 0;
  while (1)
  {
    if (v24 && v25 > v10)
    {
      int v16 = (unsigned __int16 *)(*(void *)(v24 + 8) + 4 * v12);
      int v17 = *v16 + v26;
      int v18 = v16[1] + v13;
    }
    else
    {
      int v17 = v26 + a4;
      int v18 = v13 + a5;
    }
    if ((unsigned __int16)v15 < (unsigned __int16)v17)
    {
      unsigned int v19 = (unsigned __int16)(v18 + ~(_WORD)v14);
      if (v19 >= (unsigned __int16)(v17 + ~(_WORD)v15)) {
        unsigned int v19 = (unsigned __int16)(v17 + ~(_WORD)v15);
      }
      int v20 = v14 + v19;
      int v21 = v15 + v19;
      if ((unsigned __int16)v14 < (unsigned __int16)v18)
      {
        int v15 = v21 + 1;
        int v14 = v20 + 1;
      }
    }
    if ((unsigned __int16)v15 < (unsigned __int16)v17) {
      break;
    }
LABEL_20:
    if ((unsigned __int16)v14 < (unsigned __int16)v18)
    {
      int v26 = v18 + v26 - v14;
      while (1)
      {
        uint64_t result = StringList_InsertAt(a2, (unsigned __int16)v15, "*");
        if (result)
        {
          uint64_t result = LH_ERROR_to_VERROR(result);
          if ((result & 0x80000000) != 0) {
            return result;
          }
        }
        if (a1)
        {
          uint64_t result = StringList_InsertAt(a1, (unsigned __int16)v15, "*");
          if (result)
          {
            uint64_t result = LH_ERROR_to_VERROR(result);
            if ((result & 0x80000000) != 0) {
              return result;
            }
          }
        }
        ++v15;
        if ((unsigned __int16)++v14 >= (unsigned __int16)v18)
        {
          int v14 = v18;
          break;
        }
      }
    }
    ++v15;
    ++v14;
    unsigned int v10 = ++v12;
    if (v12 > v25) {
      return result;
    }
  }
  int v13 = v17 + v13 - v15;
  while (1)
  {
    uint64_t result = StringList_InsertAt(a3, (unsigned __int16)v14, "*");
    if (result)
    {
      uint64_t result = LH_ERROR_to_VERROR(result);
      if ((result & 0x80000000) != 0) {
        return result;
      }
    }
    ++v14;
    if ((unsigned __int16)++v15 >= (unsigned __int16)v17)
    {
      int v15 = v17;
      goto LABEL_20;
    }
  }
}

uint64_t CLM_MergeSubsequentInsertionAndDeletions(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 2347769856;
  int CountStrings = StringList_GetCountStrings(a1);
  if (CountStrings == StringList_GetCountStrings(a2))
  {
    if (StringList_GetCountStrings(a1))
    {
      int v6 = 0;
      unsigned __int16 v7 = 0;
      do
      {
        unint64_t v8 = (const char *)StringList_GetAt(a1, v7);
        if (!strcmp(v8, "*"))
        {
          int v9 = (const char *)StringList_GetAt(a2, v7);
          int v10 = strcmp(v9, "*");
          if (v10 && v7)
          {
            unsigned __int16 v11 = v7 - 1;
            unsigned __int16 v12 = (const char *)StringList_GetAt(a2, (unsigned __int16)(v7 - 1));
            if (!strcmp(v12, "*")) {
              goto LABEL_15;
            }
          }
          else
          {
            unsigned __int16 v11 = v7;
            if (!v10) {
              goto LABEL_15;
            }
          }
          unsigned __int16 v11 = v6 + 1;
          if (v6 + 1 < StringList_GetCountStrings(a2))
          {
            int v13 = (const char *)StringList_GetAt(a2, (unsigned __int16)(v6 + 1));
            if (!strcmp(v13, "*"))
            {
LABEL_15:
              StringList_RemoveAt(a1, v7);
              StringList_RemoveAt(a2, v11);
              goto LABEL_6;
            }
          }
        }
        ++v7;
LABEL_6:
        int v6 = v7;
      }
      while (v7 < StringList_GetCountStrings(a1));
    }
    int v14 = StringList_GetCountStrings(a1);
    if (v14 == StringList_GetCountStrings(a2)) {
      return 0;
    }
    else {
      return 2347769856;
    }
  }
  return v4;
}

uint64_t CLM_PhonList_InsertAt(uint64_t a1, unsigned int a2, char *a3)
{
  uint64_t result = StringList_InsertAt(a1, a2, a3);
  if (result)
  {
    return LH_ERROR_to_VERROR(result);
  }
  return result;
}

uint64_t CLM_PhonList_Append(uint64_t a1, char *a2)
{
  uint64_t result = StringList_Append(a1, a2);
  if (result)
  {
    return LH_ERROR_to_VERROR(result);
  }
  return result;
}

uint64_t hlp_AppendCombinedResult(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t *a5, unsigned __int16 *a6)
{
  uint64_t v12 = *a5;
  if (*a6)
  {
    int v13 = 0;
    do
      unsigned __int16 v14 = v13;
    while (*(void *)(v12 + 8 * (unsigned __int16)v13++));
    if (*a6 - 1 != v14) {
      goto LABEL_11;
    }
  }
  else
  {
    unsigned __int16 v14 = 0;
  }
  uint64_t v16 = heap_Realloc(*(uint64_t **)(a1 + 8), v12, 8 * *a6 + 16);
  *a5 = v16;
  if (v16)
  {
    unsigned __int16 v21 = *a6 + 2;
    *a6 = v21;
    if (v14 < v21)
    {
      uint64_t v22 = v14;
      do
        *(void *)(*a5 + 8 * v22++) = 0;
      while (v21 != v22);
    }
LABEL_11:
    BOOL v24 = a2 != 65534 && a3 != 65534;
    unsigned __int16 v25 = v24;
    if (a4) {
      unsigned __int16 v25 = *(_WORD *)(a4 + 4) + v24;
    }
    *(void *)(*a5 + 8 * v14) = heap_Calloc(*(void **)(a1 + 8), 1, 4 * v25 + 4);
    if (v24)
    {
      int v26 = *(_WORD **)(*a5 + 8 * v14);
      *int v26 = a2;
      v26[1] = a3;
      unsigned int v27 = 1;
      if (!a4) {
        goto LABEL_27;
      }
    }
    else
    {
      unsigned int v27 = 0;
      if (!a4)
      {
LABEL_27:
        uint64_t result = 0;
        *(_DWORD *)(*(void *)(*a5 + 8 * v14) + 4 * (unsigned __int16)v27) = -1;
        return result;
      }
    }
    if (*(_WORD *)(a4 + 4))
    {
      unint64_t v28 = 0;
      __int16 v29 = v27;
      uint64_t v30 = 4 * v27;
      do
      {
        *(_DWORD *)(*(void *)(*a5 + 8 * v14) + v30 + 4 * v28) = *(_DWORD *)(*(void *)(a4 + 8) + 4 * v28);
        ++v28;
      }
      while (v28 < *(unsigned __int16 *)(a4 + 4));
      LOWORD(v27) = v29 + v28;
    }
    goto LABEL_27;
  }
  log_OutPublic(*(void *)(a1 + 32), (uint64_t)"CLM", 50000, 0, v17, v18, v19, v20, v32);
  return 2347769866;
}

uint64_t CLM_EnumerateLanguages(uint64_t a1, uint64_t *a2, unsigned int *a3, unsigned int a4, uint64_t a5, unsigned int a6, unsigned int a7)
{
  unsigned int v7 = a7;
  unsigned int v8 = a6;
  uint64_t v57 = *MEMORY[0x263EF8340];
  unsigned int v53 = 0;
  unsigned int v52 = 0;
  uint64_t v14 = 2347769856;
  int v51 = 0;
  *a3 = 0;
  if (!CLM_FindNrOfLanguages(a1, a5, a6, a7, v56, 0x64u, v55, a3))
  {
    uint64_t v15 = *a3;
    if (v15)
    {
      uint64_t v16 = heap_Calloc(*(void **)(*(void *)(a1 + 24) + 8), v15, 24);
      *a2 = v16;
      if (!v16)
      {
        log_OutPublic(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 50000, 0, v17, v18, v19, v20, v43);
        return 2347769866;
      }
      if (*a3)
      {
        unsigned __int16 v44 = a3;
        unint64_t v21 = 0;
        unsigned int v46 = 0;
        unsigned int v47 = v8;
        unsigned int v45 = v7;
        while (1)
        {
          __strcpy_chk();
          if (a4 <= 1)
          {
            uint64_t v22 = &v55[v21];
            *(void *)(*a2 + 24 * v21 + 16) = heap_Calloc(*(void **)(*(void *)(a1 + 24) + 8), *v22, 24);
            uint64_t v27 = *a2 + 24 * v21;
            if (!*(void *)(v27 + 16))
            {
              uint64_t v40 = 2347769866;
              uint64_t v39 = 50000;
LABEL_30:
              log_OutPublic(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", v39, 0, v23, v24, v25, v26, v43);
              uint64_t v41 = v40;
              goto LABEL_31;
            }
            *(_DWORD *)(v27 + 8) = *v22;
          }
          unsigned int v53 = v7;
          if (v55[v21])
          {
            uint64_t v28 = 0;
            for (unint64_t i = 0; i < v55[v21]; ++i)
            {
              uint64_t v30 = *a2;
              LangRecord = (const char *)CLM_FindLangRecord(a5, v8, &v53, (const char *)(*a2 + 24 * v21));
              if (!LangRecord)
              {
                uint64_t v39 = 50003;
                uint64_t v40 = 2347769856;
                goto LABEL_30;
              }
              unsigned int v32 = (char *)LangRecord;
              if (a4)
              {
                if (a4 == 1)
                {
                  int v50 = 0;
                  *(void *)(*(void *)(v30 + 24 * v21 + 16) + v28) = LangRecord;
                  *(void *)(*(void *)(*a2 + 24 * v21 + 16) + v28 + 8) = &LangRecord[strlen(LangRecord) + 1];
                  unsigned int v8 = v47;
                  unsigned __int16 v33 = *(char **)(*(void *)(*a2 + 24 * v21 + 16) + v28 + 8);
                  if (*v33)
                  {
                    unsigned int v34 = CLM_SplitWordInPhonemes(*(void *)(a1 + 24), v33, v54, 0xC8u, 0, &v50);
                    if ((v34 & 0x80000000) != 0 || v50)
                    {
                      log_OutText(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 1, 0, (uint64_t)"WARNING CLM %s to %s : invalid mapping %s %s", v35, v36, v37, *a2 + 24 * v21);
                      unsigned int v34 = 0;
                      v54[0] = 0;
                    }
                    unsigned int v46 = v34;
                    uint64_t v49 = 0;
                    memset(v48, 0, sizeof(v48));
                    int Allocator = ooc_utils_createAllocator((uint64_t)v48, *(_WORD **)(a1 + 32), *(void *)(a1 + 40));
                    if (Allocator
                      || (int Allocator = PNEW_StringList_Con((uint64_t)v48, *(_WORD **)(a1 + 32), *(void *)(a1 + 40), (uint64_t *)(*(void *)(*a2 + 24 * v21 + 16) + v28 + 16))) != 0|| (int Allocator = StringList_FromSplitString(*(void *)(*(void *)(*a2 + 24 * v21 + 16) + v28 + 16), v54, 0x20u)) != 0)
                    {
                      unsigned int v46 = LH_ERROR_to_VERROR(Allocator);
                      goto LABEL_33;
                    }
                  }
                }
                else
                {
                  *(void *)(v30 + 24 * v21 + 8) = LangRecord;
                }
              }
              else
              {
                *(void *)(*(void *)(v30 + 24 * v21 + 16) + v28) = LangRecord;
                *(void *)(*(void *)(*a2 + 24 * v21 + 16) + v28 + 16) = &LangRecord[strlen(LangRecord) + 1];
                unsigned int v8 = v47;
                *(void *)(*(void *)(*a2 + 24 * v21 + 16) + v28 + 8) = nuance_pcre_compile(*(void *)(a1 + 168), *(void *)(a1 + 176), v32, 0, &v52, &v51, 0);
              }
              ++v53;
              v28 += 24;
            }
          }
          *(_DWORD *)(*a2 + 24 * v21++ + 4) = a4;
          unsigned int v7 = v45;
          if (v21 >= *v44)
          {
LABEL_33:
            uint64_t v41 = v46;
            uint64_t v14 = v46;
            if ((v46 & 0x80000000) == 0) {
              return v14;
            }
LABEL_31:
            uint64_t v14 = v41;
            CLM_EmptyLanguageStruct((void *)a1, a2, v21);
            return v14;
          }
        }
      }
    }
    return 0;
  }
  return v14;
}

BOOL CLM_FindNrOfLanguages(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, void *a5, unsigned int a6, void *a7, _DWORD *a8)
{
  *(void *)int __dst = 0;
  *a8 = 0;
  bzero(a5, 4 * a6);
  bzero(a7, 4 * a6);
  if (a4 <= a3)
  {
    do
    {
      if (a4 >= a3) {
        break;
      }
      strncpy(&__dst[4], (const char *)(a2 + a4), 3uLL);
      BOOL result = CLM_IsSeperationRecord(a2, a4);
      if (!result) {
        return result;
      }
      if (CLM_FindLanguageInArray((char *)a5, a6, (uint64_t)a7, &__dst[4], __dst))
      {
        if (*(_DWORD *)__dst >= a6) {
          goto LABEL_2;
        }
        strcpy((char *)a5 + 4 * *(unsigned int *)__dst, &__dst[4]);
        ++*a8;
      }
      unsigned int v21 = 0;
      uint64_t v22 = a4 <= a3 ? a3 : a4;
      uint64_t v23 = (unsigned __int8 *)(a2 + a4);
      uint64_t v24 = ~(unint64_t)a4 + v22;
      do
      {
        if (!*v23++) {
          ++v21;
        }
        ++a4;
      }
      while (v21 <= 1 && v24-- != 0);
    }
    while (a3 != a4);
    return 0;
  }
  else
  {
LABEL_2:
    log_OutPublic(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 50003, 0, v16, v17, v18, v19, v27);
    return 1;
  }
}

uint64_t CLM_FindLangRecord(uint64_t a1, unsigned int a2, _DWORD *a3, const char *a4)
{
  *(_DWORD *)int __dst = 0;
  uint64_t v8 = *a3;
  strncpy(__dst, (const char *)(a1 + v8), 3uLL);
  if (strcmp(a4, __dst))
  {
    BOOL v9 = 0;
    while (1)
    {
      int v10 = v8;
      if (v8 >= a2 || v9) {
        break;
      }
      uint64_t v11 = 0;
      unsigned int v12 = 0;
      uint64_t v13 = a1;
      do
      {
        BOOL v15 = *(unsigned char *)(v13 + v8) == 0;
        uint64_t v14 = 1 - a2 + v8 + v11;
        *a3 = v8 + v11 + 1;
        if (v15) {
          ++v12;
        }
        ++v13;
        ++v11;
        BOOL v15 = v12 > 1 || v14 == 0;
      }
      while (!v15);
      BOOL v9 = v8 - a2 + v11 == 0;
      LODWORD(v8) = v8 + v11;
      strncpy(__dst, (const char *)(a1 + (v10 + v11)), 3uLL);
      if (!strcmp(a4, __dst))
      {
        LODWORD(v8) = v10 + v11;
        break;
      }
    }
  }
  if (v8 >= a2) {
    return 0;
  }
  else {
    return a1 + (v8 + 3);
  }
}

void *CLM_EmptyLanguageStruct(void *result, uint64_t *a2, unsigned int a3)
{
  if (a2)
  {
    uint64_t v4 = *a2;
    if (*a2)
    {
      unint64_t v5 = result;
      if (a3)
      {
        uint64_t v6 = 0;
        uint64_t v7 = a3;
        while (1)
        {
          int v8 = *(_DWORD *)(v4 + 24 * v6 + 4);
          if (v8 == 1) {
            break;
          }
          if (!v8)
          {
            uint64_t v9 = v4 + 24 * v6;
            unsigned int v12 = *(_DWORD *)(v9 + 8);
            uint64_t v11 = (unsigned int *)(v9 + 8);
            unint64_t v10 = v12;
            uint64_t v13 = *((void *)v11 + 1);
            if (v12)
            {
              unint64_t v14 = 0;
              uint64_t v15 = 8;
              do
              {
                if (*(void *)(v13 + v15))
                {
                  heap_Free(*(void **)(v5[3] + 8), *(void *)(v13 + v15));
                  uint64_t v13 = *((void *)v11 + 1);
                  *(void *)(v13 + v15) = 0;
                  unint64_t v10 = *v11;
                }
                ++v14;
                v15 += 24;
              }
              while (v14 < v10);
            }
LABEL_20:
            heap_Free(*(void **)(v5[3] + 8), v13);
            *((void *)v11 + 1) = 0;
            *uint64_t v11 = 0;
          }
          if (++v6 == v7) {
            goto LABEL_22;
          }
        }
        uint64_t v16 = v4 + 24 * v6;
        unsigned int v18 = *(_DWORD *)(v16 + 8);
        uint64_t v11 = (unsigned int *)(v16 + 8);
        unint64_t v17 = v18;
        uint64_t v13 = *((void *)v11 + 1);
        if (v18)
        {
          unint64_t v19 = 0;
          uint64_t v20 = 16;
          do
          {
            if (*(void *)(v13 + v20))
            {
              uint64_t v22 = 0;
              memset(v21, 0, sizeof(v21));
              if (!ooc_utils_createAllocator((uint64_t)v21, (_WORD *)v5[4], v5[5])) {
                OOC_PlacementDeleteObject((uint64_t)v21, *(void *)(*((void *)v11 + 1) + v20));
              }
              uint64_t v13 = *((void *)v11 + 1);
              *(void *)(v13 + v20) = 0;
              unint64_t v17 = *v11;
            }
            ++v19;
            v20 += 24;
          }
          while (v19 < v17);
        }
        goto LABEL_20;
      }
LABEL_22:
      BOOL result = heap_Free(*(void **)(v5[3] + 8), v4);
      *a2 = 0;
    }
  }
  return result;
}

BOOL CLM_IsSeperationRecord(uint64_t a1, unsigned int a2)
{
  *(_DWORD *)int __dst = 0;
  strncpy(__dst, (const char *)(a1 + a2), 3uLL);
  return *(_DWORD *)__dst != 7173476 || *(unsigned char *)(a1 + a2 + 3) || *(unsigned char *)(a1 + a2 + 4);
}

BOOL CLM_FindLanguageInArray(char *__s2, unsigned int a2, uint64_t a3, char *__s1, _DWORD *a5)
{
  uint64_t v9 = 0;
  if (a2 <= 1) {
    uint64_t v10 = 1;
  }
  else {
    uint64_t v10 = a2;
  }
  while (strcmp(__s1, __s2) && *__s2)
  {
    ++v9;
    __s2 += 4;
    if (v10 == v9) {
      return 1;
    }
  }
  *a5 = v9;
  ++*(_DWORD *)(a3 + 4 * v9);
  return *__s2 == 0;
}

uint64_t CLM_FindSeperationRecord(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  unsigned int v6 = *a3;
  while (1)
  {
    uint64_t result = CLM_IsSeperationRecord(a1, v6);
    if (!result) {
      break;
    }
    if (v6 <= a2) {
      uint64_t v8 = a2;
    }
    else {
      uint64_t v8 = v6;
    }
    if (v6 < a2)
    {
      unsigned int v9 = 0;
      uint64_t v10 = (unsigned __int8 *)(a1 + v6);
      uint64_t v11 = ~(unint64_t)v6 + v8;
      do
      {
        int v12 = *v10++;
        *a3 = ++v6;
        if (!v12) {
          ++v9;
        }
      }
      while (v9 <= 1 && v11-- != 0);
    }
    if (v6 == a2) {
      return 2347769856;
    }
  }
  *a3 = v6 + 5;
  return result;
}

uint64_t CLM_PreCompileSplitWordRegEx(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  v13[1] = 0;
  strcpy(v16, "[\"#\\$&'\\.789=\\?@A-Z^_a-z]");
  strcpy((char *)v13, "\\*");
  strcpy(v15, "(\\\\)?[!\\?,\\.;:]");
  if (a1[23]
    || (unint64_t v14 = 0,
        __sprintf_chk(v19, 0, 0x1F4uLL, "(%s%s*(%%%s|%%\"%s+\"){0,}(&%s%s*(%%%s|%%\"%s+\"){0,}){0,})|(%s%s)", v16, v17, v18, v18, v16, v17, v18, v18, (const char *)v13, v15), v10 = nuance_pcre_compile(a1[21], a1[22], v19, 0, &v14, &v13[1], 0), uint64_t v9 = 0, (a1[23] = v10) == 0))
  {
    uint64_t v9 = 2347769856;
    log_OutPublic(*(void *)(a1[3] + 32), (uint64_t)"CLM", 50003, 0, a5, a6, a7, a8, v12);
  }
  return v9;
}

void *CLM_FreePreCompiledSplitWordRegEx(void *result)
{
  uint64_t v1 = result[23];
  if (v1)
  {
    uint64_t v2 = result;
    uint64_t result = heap_Free(*(void **)(result[3] + 8), v1);
    v2[23] = 0;
  }
  return result;
}

uint64_t CLM_PreCompileReplacementRegEx(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  int v13 = 0;
  strcpy(v15, "(^|[^\\\\])([\\$][0-9]+)");
  if (a1[24]
    || (v14 = 0, v10 = nuance_pcre_compile(a1[21], a1[22], v15, 0, &v14, &v13, 0), uint64_t v9 = 0, (a1[24] = v10) == 0))
  {
    uint64_t v9 = 2347769856;
    log_OutPublic(*(void *)(a1[3] + 32), (uint64_t)"CLM", 50003, 0, a5, a6, a7, a8, v12);
  }
  return v9;
}

void *CLM_FreePreCompiledReplacementRegEx(void *result)
{
  uint64_t v1 = result[24];
  if (v1)
  {
    uint64_t v2 = result;
    uint64_t result = heap_Free(*(void **)(result[3] + 8), v1);
    v2[24] = 0;
  }
  return result;
}

uint64_t CLM_DeleteNonPhoneChars(uint64_t a1, char *__s)
{
  uint64_t v4 = *(void **)(*(void *)(a1 + 24) + 8);
  size_t v5 = strlen(__s);
  unsigned int v6 = (char *)heap_Calloc(v4, 1, v5 + 1);
  if (v6)
  {
    uint64_t v11 = (uint64_t)v6;
    __lasts = 0;
    unsigned int v12 = strcpy(v6, __s);
    char *__s = 0;
    int v13 = strtok_r(v12, "\t ", &__lasts);
    if (v13)
    {
      unint64_t v14 = v13;
      do
      {
        strcat(__s, v14);
        unint64_t v14 = strtok_r(0, "\t ", &__lasts);
      }
      while (v14);
    }
    heap_Free(*(void **)(*(void *)(a1 + 24) + 8), v11);
    return 0;
  }
  else
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 50000, 0, v7, v8, v9, v10, v16);
    return 2347769866;
  }
}

uint64_t CLM_SplitWordInPhonemes(uint64_t a1, char *__s, char *a3, unsigned int a4, void *a5, _DWORD *a6)
{
  uint64_t v9 = __s;
  if (a6) {
    *a6 = 0;
  }
  if (a3)
  {
    if (((2 * strlen(__s)) | 1) > a4) {
      return 2347769865;
    }
    *a3 = 0;
  }
  if (a5) {
    StringList_Reset(a5);
  }
  size_t v12 = strlen(v9);
  uint64_t v27 = LhpuCreate(*(void *)(a1 + 8));
  if (!v27)
  {
    log_OutPublic(*(void *)(a1 + 32), (uint64_t)"CLM", 50000, 0, v13, v14, v15, v16, v25);
    return 2347769866;
  }
  uint64_t v11 = 0;
  __int16 v26 = 0;
  unint64_t v17 = (unint64_t)&v9[v12 + 1];
  if (v17 <= (unint64_t)v9) {
    goto LABEL_32;
  }
  uint64_t v11 = 0;
  int v18 = 1;
  do
  {
    if (*v9 == 18)
    {
      if (a3)
      {
        *(_WORD *)&a3[strlen(a3)] = 32;
        *(_WORD *)&a3[strlen(a3)] = 18;
      }
LABEL_19:
      uint64_t v20 = 1;
      goto LABEL_29;
    }
    int Symbol = LhplGetSymbol((unsigned __int8 *)v9, v27, (unsigned char *)&v26 + 1, &v26);
    if (Symbol)
    {
      if (Symbol == 1) {
        break;
      }
      if (a6) {
        *a6 = 1;
      }
      goto LABEL_19;
    }
    if (!v18)
    {
      if (!a3) {
        goto LABEL_26;
      }
      *(_WORD *)&a3[strlen(a3)] = 32;
LABEL_25:
      kaldi::CuMatrixBase<float>::~CuMatrixBase(v27);
      strcat(a3, v21);
      goto LABEL_26;
    }
    if (a3) {
      goto LABEL_25;
    }
LABEL_26:
    if (a5)
    {
      uint64_t v22 = v27;
      kaldi::CuMatrixBase<float>::~CuMatrixBase(v27);
      uint64_t v11 = CLM_PhonList_Append((uint64_t)a5, v23);
      if ((v11 & 0x80000000) != 0) {
        goto LABEL_31;
      }
    }
    int v18 = 0;
    uint64_t v20 = v26 + 1;
LABEL_29:
    v9 += v20;
  }
  while ((unint64_t)v9 < v17);
  uint64_t v22 = v27;
LABEL_31:
  if (v22) {
LABEL_32:
  }
    LhpuRemove(*(void **)(a1 + 8), &v27);
  return v11;
}

BOOL CLM_SearchAndReplace(uint64_t a1, unsigned char *a2, char *a3, uint64_t a4, char *__s, uint64_t a6, unsigned int a7)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  unsigned int v48 = 0;
  uint64_t v47 = 0;
  memset(v49, 0, sizeof(v49));
  uint64_t v50 = 0;
  unsigned int v43 = strlen(__s);
  if (v43)
  {
    LODWORD(v14) = 0;
    unsigned int v15 = 0;
    unsigned int v16 = 0;
    uint64_t v41 = (void *)a1;
    do
    {
      if (v16 && *a2 == 94) {
        break;
      }
      int v17 = strlen(__s);
      if ((int)nuance_pcre_exec(*(void **)(a1 + 168), *(void *)(a1 + 176), a4, 0, &__s[v16], v17 - v16, 0, 0, v49, 90) < 1)break; {
      uint64_t v18 = CLM_InterpretReplacementString(a1, a3, &v47, &v48);
      }
      if ((v18 & 0x80000000) != 0) {
        return v18;
      }
      uint64_t v19 = v48;
      if (!v48) {
        unsigned int v16 = *((_DWORD *)v49 + (v14 + 1)) + v16 - *((_DWORD *)v49 + v14);
      }
      uint64_t v20 = LODWORD(v49[0]);
      unsigned int v21 = v16;
      if (LODWORD(v49[0]))
      {
        do
        {
          *(unsigned char *)(a6 + v15++) = __s[v21++];
          --v20;
        }
        while (v20);
      }
      uint64_t v45 = v47;
      if (v19)
      {
        uint64_t v22 = (const char **)(v47 + 8);
        for (uint64_t i = v19; i; --i)
        {
          int v24 = *((_DWORD *)v22 - 2);
          if (v24 == 1)
          {
            int v25 = *((_DWORD *)v22 - 1);
            uint64_t v26 = (2 * v25) | 1u;
            uint64_t v14 = (2 * v25);
            int v27 = *((_DWORD *)v49 + v14);
            size_t v28 = (*((_DWORD *)v49 + v26) - v27);
            if (v28 + v15 >= a7)
            {
LABEL_23:
              uint64_t v29 = 2347769865;
              uint64_t v30 = v41[3];
              goto LABEL_37;
            }
            strncpy((char *)(a6 + v15), &__s[v27 + v16], v28);
            unsigned int v15 = *((_DWORD *)v49 + v26) + v15 - *((_DWORD *)v49 + v14);
          }
          else if (!v24 && *v22)
          {
            if (v15 + strlen(*v22) >= a7) {
              goto LABEL_23;
            }
            strcpy((char *)(a6 + v15), *v22);
            v15 += strlen(*v22);
          }
          v22 += 2;
        }
      }
      v16 += DWORD1(v49[0]);
      a1 = (uint64_t)v41;
      CLM_FreeListOfTypes(v41, v45, v19);
      uint64_t v47 = 0;
    }
    while (v16 < v43);
  }
  else
  {
    unsigned int v16 = 0;
    unsigned int v15 = 0;
  }
  unsigned int v31 = v43 - v16;
  if (v43 <= v16)
  {
    unsigned int v31 = 0;
LABEL_34:
    unsigned int v37 = v31 + v15;
    if (v37 < a7)
    {
      *(unsigned char *)(a6 + v37) = 0;
      return v16 == 0;
    }
  }
  else
  {
    LODWORD(v32) = a7 - v15;
    if (a7 >= v15) {
      uint64_t v32 = v32;
    }
    else {
      uint64_t v32 = 0;
    }
    unsigned __int16 v33 = (unsigned char *)(a6 + v15);
    unsigned int v34 = &__s[v16];
    unsigned int v35 = v43 - v16;
    while (v32)
    {
      char v36 = *v34++;
      *v33++ = v36;
      --v32;
      if (!--v35) {
        goto LABEL_34;
      }
    }
  }
  uint64_t v29 = 2347769865;
  uint64_t v30 = *(void *)(a1 + 24);
LABEL_37:
  log_OutPublic(*(void *)(v30 + 32), (uint64_t)"CLM", 50002, 0, v10, v11, v12, v13, v39);
  return v29;
}

uint64_t CLM_InterpretReplacementString(uint64_t a1, char *__s, uint64_t *a3, unsigned int *a4)
{
  uint64_t v69 = *MEMORY[0x263EF8340];
  __uint64_t n = 0;
  size_t v15 = strlen(__s);
  if (v15)
  {
    uint64_t v16 = *(void *)(a1 + 192);
    if (!v16)
    {
      uint64_t v17 = CLM_PreCompileReplacementRegEx((void *)a1, v8, v9, v10, v11, v12, v13, v14);
      if ((v17 & 0x80000000) != 0) {
        return v17;
      }
      uint64_t v16 = *(void *)(a1 + 192);
    }
    nuance_pcre_fullinfo(v16, 0, 1, (int *)&__n);
    uint64_t v22 = *(void *)(a1 + 24);
    if (__n)
    {
      uint64_t v23 = heap_Alloc(*(void *)(v22 + 8), __n);
      if (v23)
      {
        size_t v28 = (void *)v23;
        *a3 = 0;
        uint64_t v29 = (void *)heap_Alloc(*(void *)(*(void *)(a1 + 24) + 8), (32 * v15) & 0xFFFFFFFE0);
        *a3 = (uint64_t)v29;
        if (v29)
        {
          bzero(v29, (32 * v15) & 0xFFFFFFFE0);
          unsigned int v30 = 0;
          int v31 = 0;
          uint64_t v68 = 0;
          long long v66 = 0u;
          long long v67 = 0u;
          long long v64 = 0u;
          long long v65 = 0u;
          long long v62 = 0u;
          long long v63 = 0u;
          long long v60 = 0u;
          long long v61 = 0u;
          long long v58 = 0u;
          long long v59 = 0u;
          long long v56 = 0u;
          long long v57 = 0u;
          long long v54 = 0u;
          long long v55 = 0u;
          long long v52 = 0u;
          long long v53 = 0u;
          long long v50 = 0u;
          long long v51 = 0u;
          long long v48 = 0u;
          long long v49 = 0u;
          unsigned int v32 = v15;
          long long v46 = 0u;
          *(_OWORD *)uint64_t v47 = 0u;
          while (1)
          {
            memcpy(v28, *(const void **)(a1 + 192), __n);
            if (nuance_pcre_exec(*(void **)(a1 + 168), *(void *)(a1 + 176), (uint64_t)v28, 0, &__s[v31], v32, 0, 0, &v46, 90) != 3)break; {
            int v33 = v47[0];
            }
            if (LODWORD(v47[0]))
            {
              *(_DWORD *)(*a3 + 16 * v30) = 0;
              *(void *)(*a3 + 16 * v30 + 8) = heap_Alloc(*(void *)(*(void *)(a1 + 24) + 8), (v33 + 1));
              unsigned int v34 = *(char **)(*a3 + 16 * v30 + 8);
              if (!v34) {
                goto LABEL_26;
              }
              strncpy(v34, &__s[v31], LODWORD(v47[0]));
              *(unsigned char *)(*(void *)(*a3 + 16 * v30++ + 8) + SLODWORD(v47[0])) = 0;
            }
            *(_DWORD *)(*a3 + 16 * v30) = 1;
            __strncpy_chk();
            int v35 = 0;
            v43[HIDWORD(v47[0]) + ~LODWORD(v47[0])] = 0;
            int v36 = v43[0];
            if (v43[0] - 58 >= 0xFFFFFFF6)
            {
              int v35 = 0;
              unsigned int v37 = (unsigned __int8 *)&v44;
              do
              {
                int v35 = v36 + 10 * v35 - 48;
                int v38 = *v37++;
                int v36 = v38;
              }
              while ((v38 - 58) >= 0xFFFFFFF6);
            }
            *(_DWORD *)(*a3 + 16 * v30 + 4) = v35;
            v31 += DWORD1(v46);
            ++v30;
            unsigned int v32 = v15 - v31;
            if (v15 == v31) {
              goto LABEL_25;
            }
          }
          *(_DWORD *)(*a3 + 16 * v30) = 0;
          *(void *)(*a3 + 16 * v30 + 8) = heap_Alloc(*(void *)(*(void *)(a1 + 24) + 8), v32 + 1);
          uint64_t v40 = *(char **)(*a3 + 16 * v30 + 8);
          if (v40)
          {
            strncpy(v40, &__s[v31], v32);
            *(unsigned char *)(*(void *)(*a3 + 16 * v30++ + 8) + v32) = 0;
LABEL_25:
            *a4 = v30;
            heap_Free(*(void **)(*(void *)(a1 + 24) + 8), (uint64_t)v28);
            return 0;
          }
LABEL_26:
          uint64_t v39 = 2347769866;
          heap_Free(*(void **)(*(void *)(a1 + 24) + 8), (uint64_t)v28);
          heap_Free(*(void **)(*(void *)(a1 + 24) + 8), *a3);
          *a3 = 0;
        }
        else
        {
          uint64_t v39 = 2347769866;
          heap_Free(*(void **)(*(void *)(a1 + 24) + 8), (uint64_t)v28);
        }
      }
      else
      {
        uint64_t v39 = 2347769866;
      }
      log_OutPublic(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 50000, 0, v24, v25, v26, v27, v42);
    }
    else
    {
      log_OutPublic(*(void *)(v22 + 32), (uint64_t)"CLM", 50003, 0, v18, v19, v20, v21, v42);
      return 2347769856;
    }
  }
  else
  {
    uint64_t v39 = 0;
    *a4 = 0;
  }
  return v39;
}

void *CLM_FreeListOfTypes(void *result, uint64_t a2, unsigned int a3)
{
  if (a2)
  {
    uint64_t v4 = result;
    if (a3)
    {
      uint64_t v5 = a3;
      unsigned int v6 = (uint64_t *)(a2 + 8);
      do
      {
        if (*v6) {
          heap_Free(*(void **)(v4[3] + 8), *v6);
        }
        v6 += 2;
        --v5;
      }
      while (v5);
    }
    uint64_t v7 = *(void **)(v4[3] + 8);
    return heap_Free(v7, a2);
  }
  return result;
}

uint64_t CLM_RemoveInvalidPhonemes(uint64_t a1, int a2, char *a3, char *a4, _DWORD *a5)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  if (a5) {
    *a5 = 0;
  }
  uint64_t v9 = 2347769864;
  if ((safeh_HandleCheck(a1, a2, 63000, 216) & 0x80000000) == 0 && a1)
  {
    log_OutText(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"CLM RemoveInvalidPhonemes : Begin (%s)", v10, v11, v12, (uint64_t)a4);
    uint64_t v13 = CLM_GiveLanguageBuffer(a3, *(void *)(a1 + 152), *(_DWORD *)(a1 + 160), 2);
    if (v13)
    {
      uint64_t v14 = v13;
      uint64_t v15 = CLM_DeleteNonPhoneChars(a1, a4);
      if ((v15 & 0x80000000) != 0)
      {
        return v15;
      }
      else
      {
        size_t v16 = (2 * strlen(a4)) | 1;
        uint64_t v17 = (char *)heap_Alloc(*(void *)(*(void *)(a1 + 24) + 8), v16);
        if (v17)
        {
          uint64_t v22 = v17;
          bzero(v17, v16);
          uint64_t v9 = CLM_SplitWordInPhonemes(*(void *)(a1 + 24), a4, v22, v16, 0, 0);
          if ((v9 & 0x80000000) != 0)
          {
            heap_Free(*(void **)(*(void *)(a1 + 24) + 8), (uint64_t)v22);
          }
          else
          {
            __s1 = *(char **)(v14 + 8);
            __lasts = 0;
            if (!hlp_ShouldTempWorkAroundVO9614(a1, a3))
            {
              *a4 = 0;
              uint64_t v27 = strtok_r(v22, " ", &__lasts);
              if (v27)
              {
                size_t v28 = v27;
                do
                {
                  if (!strcmp(v28, "T") && !strcmp(a3, "spm"))
                  {
                    int v32 = strcmp((const char *)(a1 + 56), "SPE");
                    uint64_t v37 = 0;
                    uint64_t v38 = 0;
                    __int16 v39 = 0;
                    strcpy(__s2, " ");
                    __strcat_chk();
                    __strcat_chk();
                    if (!v32) {
                      goto LABEL_23;
                    }
                  }
                  else
                  {
                    uint64_t v37 = 0;
                    uint64_t v38 = 0;
                    __int16 v39 = 0;
                    strcpy(__s2, " ");
                    __strcat_chk();
                    __strcat_chk();
                  }
                  if (*v28 != 18 && !strstr(__s1, __s2))
                  {
                    log_OutText(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"Wrong L&H+ phoneme %s", v29, v30, v31, (uint64_t)v28);
                    if (a5) {
                      *a5 = 1;
                    }
                    goto LABEL_24;
                  }
LABEL_23:
                  strcat(a4, v28);
LABEL_24:
                  size_t v28 = strtok_r(0, " ", &__lasts);
                }
                while (v28);
              }
            }
            heap_Free(*(void **)(*(void *)(a1 + 24) + 8), (uint64_t)v22);
            log_OutText(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"CLM RemoveInvalidPhonemes : End (%s)", v23, v24, v25, (uint64_t)a4);
          }
        }
        else
        {
          log_OutPublic(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 50000, 0, v18, v19, v20, v21, v33);
          return 2347769866;
        }
      }
    }
    else
    {
      return 2347777677;
    }
  }
  return v9;
}

uint64_t CLM_GiveLanguageBuffer(char *a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t result = 0;
  if (a2 && a3)
  {
    uint64_t v7 = a2;
    uint64_t v8 = a3;
    while (LH_stricmp((char *)v7, a1))
    {
      v7 += 24;
      if (!--v8) {
        return 0;
      }
    }
    if (*(_DWORD *)(v7 + 4) == a4) {
      return v7;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t hlp_ShouldTempWorkAroundVO9614(uint64_t a1, char *__s1)
{
  if (strcmp(__s1, "mnc") && strcmp(__s1, "mnt") && strcmp(__s1, "cah") && strcmp(__s1, "sic")) {
    return 0;
  }
  log_OutText(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"VO-9614 lang code don't check phonemes against phoneme set (%s).", v4, v5, v6, (uint64_t)__s1);
  return 1;
}

uint64_t CLM_ObjOpen(_WORD *a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v5 = 2347769863;
  if (a5)
  {
    *(void *)a5 = 0;
    *(_DWORD *)(a5 + 8) = 0;
    uint64_t inited = InitRsrcFunction(a3, a4, &v23);
    if ((inited & 0x80000000) != 0) {
      return inited;
    }
    uint64_t NullHandle = safeh_GetNullHandle();
    if (!safeh_HandlesEqual((uint64_t)a1, a2, NullHandle, v13))
    {
      uint64_t inited = InitRsrcFunction(a1, a2, &v22);
      if ((inited & 0x80000000) == 0)
      {
        uint64_t v14 = (void *)heap_Calloc(*(void **)(v23 + 8), 1, 216);
        uint64_t v19 = v23;
        if (!v14)
        {
          log_OutPublic(*(void *)(v23 + 32), (uint64_t)"CLM", 50000, 0, v15, v16, v17, v18, v22);
          return 2347769866;
        }
        uint64_t v20 = (uint64_t)v14;
        v14[4] = a3;
        v14[5] = a4;
        v14[2] = a2;
        void v14[3] = v19;
        *uint64_t v14 = v22;
        v14[1] = a1;
        uint64_t inited = nuance_pcre_ObjOpen(a3, a4, (uint64_t)(v14 + 21));
        if ((inited & 0x80000000) == 0)
        {
          uint64_t inited = nuance_pcre_Init(*(void **)(v20 + 168), *(void *)(v20 + 176), 0xAu, 10);
          if ((inited & 0x80000000) == 0)
          {
            *(void *)a5 = v20;
            *(_DWORD *)(a5 + 8) = 63000;
            return CLM_ObjReopen(v20, *(void *)(a5 + 8));
          }
        }
      }
      return inited;
    }
  }
  return v5;
}

uint64_t CLM_ObjReopen(uint64_t a1, int a2)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  uint64_t v3 = safeh_HandleCheck(a1, a2, 63000, 216);
  uint64_t v4 = 2347769864;
  if ((v3 & 0x80000000) != 0 || !a1) {
    return v4;
  }
  uint64_t v5 = v3;
  if ((hlp_GetLanguage(*(void *)(*(void *)(a1 + 24) + 40), v36) & 0x80000000) == 0
    && !LH_stricmp((char *)(a1 + 56), v36))
  {
    return v5;
  }
  CLM_DeInitFromCLMv2Lua((void *)a1);
  uint64_t Language = CLM_DeInit((uint64_t *)a1);
  if ((Language & 0x80000000) != 0) {
    return Language;
  }
  memset(v41, 0, 256);
  uint64_t v37 = 0;
  uint64_t Language = hlp_GetLanguage(*(void *)(*(void *)(a1 + 24) + 40), v38);
  if ((Language & 0x80000000) != 0) {
    return Language;
  }
  __strcat_chk();
  __strcat_chk();
  int v7 = brokeraux_ComposeBrokerString(*(void *)(a1 + 24), v41, 0, 1, v38, 0, 0, v40, 0x100uLL);
  if (v7 < 0) {
    return v7 | 0x8BF02000;
  }
  uint64_t ObjcForThisApi_0 = getObjcForThisApi_0(*(void *)(a1 + 24), *(void *)a1);
  if (!ObjcForThisApi_0) {
    return 2347769856;
  }
  if ((objc_GetAddRefCountedObject(ObjcForThisApi_0, (uint64_t)v40, (uint64_t (*)(void, void, uint64_t, long long *, uint64_t))IRefCnt_ObjcLoadCLMData, (void (*)(void, void, long long *))IRefCnt_ObjcUnloadCLMData, a1, &v37) & 0x80000000) != 0)
  {
    uint64_t v4 = 0;
    *(void *)(a1 + 48) = 0;
    *(_DWORD *)(a1 + 200) = 0;
    return v4;
  }
  uint64_t v4 = 2347777666;
  uint64_t v9 = *(void *)(v37 + 32);
  *(void *)(a1 + 48) = v9;
  CLM_UnloadSettings(a1);
  unsigned int v14 = *(_DWORD *)(v9 + 40);
  if (!v14) {
    return 2347777673;
  }
  uint64_t v15 = *(void *)(v9 + 32);
  if (!v15) {
    return 2347777665;
  }
  if (v14 <= 0x12)
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 50003, 0, v10, v11, v12, v13, v35);
    return CLM_InitFromCLMv2Lua(a1, v38);
  }
  strncpy((char *)(a1 + 56), (const char *)(v15 + 14), 3uLL);
  *(unsigned char *)(a1 + 59) = 0;
  *(unsigned char *)(a1 + 60) = *(unsigned char *)(v15 + 17);
  *(unsigned char *)(a1 + 61) = *(unsigned char *)(v15 + 18);
  int v39 = 19;
  if ((CLM_EnumerateLanguages(a1, (uint64_t *)(a1 + 72), (unsigned int *)(a1 + 80), 1u, *(void *)(v9 + 32), *(_DWORD *)(v9 + 40), 0x13u) & 0x80000000) != 0)return 2347777667; {
  if (!*(_DWORD *)(a1 + 80))
  }
  {
    log_OutPublic(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 50003, 0, v16, v17, v18, v19, v35);
    return 2347777667;
  }
  if ((CLM_FindSeperationRecord(*(void *)(v9 + 32), *(_DWORD *)(v9 + 40), (unsigned int *)&v39) & 0x80000000) != 0) {
    return 2347777667;
  }
  if ((CLM_LoadRules(a1, *(void *)(v9 + 32), *(_DWORD *)(v9 + 40), 0, (unsigned int *)&v39) & 0x80000000) != 0
    || (CLM_FindSeperationRecord(*(void *)(v9 + 32), *(_DWORD *)(v9 + 40), (unsigned int *)&v39) & 0x80000000) != 0
    || (CLM_LoadRules(a1, *(void *)(v9 + 32), *(_DWORD *)(v9 + 40), 1, (unsigned int *)&v39) & 0x80000000) != 0)
  {
    return v4;
  }
  uint64_t v5 = 2347777668;
  if ((CLM_FindSeperationRecord(*(void *)(v9 + 32), *(_DWORD *)(v9 + 40), (unsigned int *)&v39) & 0x80000000) != 0
    || (CLM_EnumerateLanguages(a1, (uint64_t *)(a1 + 152), (unsigned int *)(a1 + 160), 2u, *(void *)(v9 + 32), *(_DWORD *)(v9 + 40), v39) & 0x80000000) != 0)
  {
    return v5;
  }
  uint64_t v4 = 2347777671;
  if ((CLM_PreCompileSplitWordRegEx((void *)a1, v20, v21, v22, v23, v24, v25, v26) & 0x80000000) == 0
    && (CLM_PreCompileReplacementRegEx((void *)a1, v27, v28, v29, v30, v31, v32, v33) & 0x80000000) == 0)
  {
    *(_DWORD *)(a1 + 64) = 1;
    return CLM_InitFromCLMv2Lua(a1, v38);
  }
  return v4;
}

uint64_t CLM_ObjClose(uint64_t *a1, int a2)
{
  uint64_t v3 = 2347769864;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 63000, 216) & 0x80000000) == 0 && a1)
  {
    CLM_DeInitFromCLMv2Lua(a1);
    uint64_t v4 = CLM_DeInit(a1);
    if ((v4 & 0x80000000) == 0)
    {
      uint64_t v4 = nuance_pcre_DeInit((void *)a1[21], a1[22]);
      if ((v4 & 0x80000000) == 0) {
        uint64_t v4 = nuance_pcre_ObjClose(a1[21], a1[22]);
      }
    }
    uint64_t v3 = v4;
    heap_Free(*(void **)(a1[3] + 8), (uint64_t)a1);
  }
  return v3;
}

uint64_t CLM_DeInit(uint64_t *a1)
{
  CLM_UnloadSettings((uint64_t)a1);
  if (!a1[6]) {
    return 0;
  }
  uint64_t ObjcForThisApi_0 = getObjcForThisApi_0(a1[3], *a1);
  if (!ObjcForThisApi_0) {
    return 2347769856;
  }
  uint64_t v3 = a1[6] + 48;
  return objc_ReleaseObject(ObjcForThisApi_0, v3);
}

uint64_t CLM_ConvertTranscription(uint64_t a1, int a2, char *a3, const char *a4, char *a5, char *a6, char *a7, unsigned int a8)
{
  uint64_t v64 = 0;
  strcpy(__s2, "ANY");
  int v67 = 0;
  uint64_t v65 = 0;
  long long v66 = 0;
  int v15 = -1947197430;
  int v16 = safeh_HandleCheck(a1, a2, 63000, 216);
  uint64_t v17 = 2347769864;
  if ((v16 & 0x80000000) == 0 && a1)
  {
    if (!*(_DWORD *)(a1 + 64)) {
      return 2347777672;
    }
    uint64_t v17 = 2347777674;
    if (a4)
    {
      int v18 = v16;
      size_t v19 = strlen(a4);
      if (v19)
      {
        if (a8 && v19 + 1 > a8) {
          return 2347777673;
        }
        if (a8)
        {
          uint64_t v20 = (char *)heap_Alloc(*(void *)(*(void *)(a1 + 24) + 8), (v19 + 1));
          if (v20)
          {
            uint64_t v25 = v20;
            strcpy(v20, a4);
            __src = v25;
            int v26 = CLM_RemoveInvalidPhonemes(a1, a2, a3, v25, &v67);
            int v27 = v26;
            if (v26 < 0)
            {
              int v28 = v26;
              if ((v26 & 0x1FFF) != 0x1E8D)
              {
                uint64_t v29 = 0;
                a8 = 0;
                int v15 = v26;
                goto LABEL_31;
              }
            }
            else if (v67)
            {
              int v28 = -1947189627;
            }
            else
            {
              int v28 = 0;
            }
            unsigned int v61 = v28;
            if (!strcmp(a3, __s2))
            {
              uint64_t v29 = 0;
              int v15 = -1947189621;
              goto LABEL_23;
            }
            size_t v59 = a8;
            if ((v61 & 0x1FFF) != 0x1E8D && strcmp((const char *)(a1 + 56), a3))
            {
              int __dst = (char *)heap_Alloc(*(void *)(*(void *)(a1 + 24) + 8), a8 + 1);
              if (__dst)
              {
                if (a6 && a7)
                {
                  size_t v35 = a8 + 1;
                  *a6 = 0;
                  *a7 = 0;
                  if (strlen(a4) <= 0x95)
                  {
                    int v36 = &v65;
                    if ((int)hlp_AllocateAndInitializePhonlists(a1, __src, (uint64_t *)&v66, &v65, &v64) >= 0)
                    {
                      uint64_t v37 = &v64;
                    }
                    else
                    {
                      int v36 = 0;
                      uint64_t v37 = 0;
                    }
                  }
                  else
                  {
                    a6 = 0;
                    a7 = 0;
                    int v36 = 0;
                    uint64_t v37 = 0;
                  }
                }
                else
                {
                  size_t v35 = a8 + 1;
                  uint64_t v37 = 0;
                  int v36 = 0;
                }
                bzero(__dst, v35);
                strcpy(__dst, __src);
                strcpy(a5, __src);
                int v39 = CLM_ApplyRules(a1, *(void *)(a1 + 88), *(_DWORD *)(a1 + 96), a3, __dst, a5, a8, v66, (void **)v36, (void **)v37);
                if (v39)
                {
                  if (v39 < 0) {
                    goto LABEL_69;
                  }
                }
                else
                {
                  strcpy(__dst, a5);
                }
                int v39 = CLM_ApplyRules(a1, *(void *)(a1 + 120), *(_DWORD *)(a1 + 128), a3, __dst, a5, a8, v66, (void **)v37, (void **)v36);
                if (v39)
                {
                  if (v39 < 0) {
                    goto LABEL_69;
                  }
                }
                else
                {
                  strcpy(__dst, a5);
                }
                int v39 = CLM_ApplyRules(a1, *(void *)(a1 + 88), *(_DWORD *)(a1 + 96), __s2, __dst, a5, a8, v66, (void **)v36, (void **)v37);
                if (v39)
                {
                  if (v39 < 0) {
                    goto LABEL_69;
                  }
                }
                else
                {
                  strcpy(__dst, a5);
                }
                int v40 = CLM_ApplyPhonemeMapping(a1, *(void *)(a1 + 72), *(_DWORD *)(a1 + 80), a3, __dst, a5, a8, v66, (void **)v37, (void **)v36);
                if (v40 < 0)
                {
                  if ((v40 & 0x1FFF) != 0) {
                    int v15 = v40;
                  }
                  else {
                    int v15 = -1947189621;
                  }
                  a8 = v61;
                  uint64_t v30 = (uint64_t)__src;
                  uint64_t v29 = (uint64_t)__dst;
                  goto LABEL_32;
                }
                strcpy(__dst, a5);
                int v39 = CLM_ApplyRules(a1, *(void *)(a1 + 104), *(_DWORD *)(a1 + 112), a3, __dst, a5, a8, v66, (void **)v36, (void **)v37);
                if (v39)
                {
                  if (v39 < 0)
                  {
                    BOOL v41 = (v39 & 0x1FFF) == 0;
                    int v42 = 7819;
LABEL_70:
                    if (v41) {
                      int v15 = v42;
                    }
                    else {
                      int v15 = v39;
                    }
                    a8 = v61;
LABEL_74:
                    uint64_t v30 = (uint64_t)__src;
                    uint64_t v29 = (uint64_t)__dst;
                    goto LABEL_32;
                  }
                }
                else
                {
                  strcpy(__dst, a5);
                }
                int v39 = CLM_ApplyRules(a1, *(void *)(a1 + 104), *(_DWORD *)(a1 + 112), __s2, __dst, a5, a8, v66, (void **)v37, (void **)v36);
                if (v39)
                {
                  if (v39 < 0)
                  {
LABEL_69:
                    BOOL v41 = (v39 & 0x1FFF) == 0;
                    int v42 = -1947189621;
                    goto LABEL_70;
                  }
                }
                else
                {
                  strcpy(__dst, a5);
                }
                unsigned int v43 = a3;
                uint64_t v29 = (uint64_t)__dst;
                int v44 = CLM_ApplyRules(a1, *(void *)(a1 + 136), *(_DWORD *)(a1 + 144), v43, __dst, a5, a8, v66, (void **)v36, (void **)v37);
                if (v44)
                {
                  if (v44 < 0)
                  {
                    if ((v44 & 0x1FFF) != 0) {
                      int v15 = v44;
                    }
                    else {
                      int v15 = -1947189621;
                    }
                    goto LABEL_23;
                  }
                }
                else
                {
                  strcpy(__dst, a5);
                }
                int v45 = CLM_RemoveInvalidPhonemes(a1, a2, (char *)(a1 + 56), a5, &v67);
                int v15 = v45;
                if ((v45 & 0x80000000) == 0)
                {
                  a8 = v61;
                  if (v67)
                  {
                    a8 = -1947189626;
                    goto LABEL_31;
                  }
LABEL_86:
                  if (a6 && a7)
                  {
                    *a6 = 0;
                    *a7 = 0;
                    int CountStrings = StringList_GetCountStrings((uint64_t)v66);
                    if (v37) {
                      int v47 = StringList_GetCountStrings(*v37);
                    }
                    else {
                      int v47 = 0;
                    }
                    if (CountStrings)
                    {
                      if (v47 == CountStrings
                        && (CLM_MergeSubsequentInsertionAndDeletions((uint64_t)v66, *v37) & 0x80000000) == 0)
                      {
                        unsigned int v48 = StringList_GetCountStrings((uint64_t)v66);
                        if (v48 == StringList_GetCountStrings(*v37))
                        {
                          if (v48)
                          {
                            unsigned __int16 v49 = 0;
                            while (1)
                            {
                              size_t v50 = strlen(a6);
                              long long v51 = (const char *)StringList_GetAt((uint64_t)v66, v49);
                              if (v50 + strlen(v51) + 1 >= v59) {
                                break;
                              }
                              size_t v52 = strlen(a7);
                              long long v53 = (const char *)StringList_GetAt(*v37, v49);
                              if (v52 + strlen(v53) + 1 >= v59) {
                                break;
                              }
                              long long v54 = (const char *)StringList_GetAt((uint64_t)v66, v49);
                              long long v55 = strcat(a6, v54);
                              *(_WORD *)&a6[strlen(v55)] = 32;
                              long long v56 = (const char *)StringList_GetAt(*v37, v49);
                              long long v57 = strcat(a7, v56);
                              *(_WORD *)&a7[strlen(v57)] = 32;
                              if (v48 <= ++v49) {
                                goto LABEL_74;
                              }
                            }
                            *a6 = 0;
                            *a7 = 0;
                          }
                        }
                      }
                    }
                    goto LABEL_74;
                  }
                  goto LABEL_31;
                }
                a8 = 7821;
                if ((v45 & 0x1FFF) == 0x1E8D) {
                  goto LABEL_86;
                }
              }
              else
              {
                log_OutPublic(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 50000, 0, v31, v32, v33, v34, v58);
                uint64_t v29 = 0;
              }
LABEL_23:
              a8 = v61;
LABEL_31:
              uint64_t v30 = (uint64_t)__src;
              goto LABEL_32;
            }
            uint64_t v30 = (uint64_t)__src;
            strcpy(a5, __src);
            uint64_t v29 = 0;
            int v15 = v27;
            a8 = v61;
          }
          else
          {
            log_OutPublic(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 50000, 0, v21, v22, v23, v24, v58);
            uint64_t v29 = 0;
            uint64_t v30 = 0;
            a8 = 0;
          }
        }
        else
        {
          uint64_t v29 = 0;
          uint64_t v30 = 0;
          int v15 = v18;
        }
LABEL_32:
        hlp_FreePhonlist(a1, (uint64_t *)&v66);
        hlp_FreePhonlist(a1, &v65);
        hlp_FreePhonlist(a1, &v64);
        if (v30) {
          heap_Free(*(void **)(*(void *)(a1 + 24) + 8), v30);
        }
        if (v29) {
          heap_Free(*(void **)(*(void *)(a1 + 24) + 8), v29);
        }
        if (v15 >= 0) {
          return a8;
        }
        else {
          return v15;
        }
      }
    }
  }
  return v17;
}

uint64_t hlp_AllocateAndInitializePhonlists(uint64_t a1, char *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v15 = 0;
  memset(v14, 0, sizeof(v14));
  int v13 = 0;
  *a3 = 0;
  *a4 = 0;
  *a5 = 0;
  int Allocator = ooc_utils_createAllocator((uint64_t)v14, *(_WORD **)(a1 + 32), *(void *)(a1 + 40));
  if (Allocator) {
    return LH_ERROR_to_VERROR(Allocator);
  }
  int Allocator = PNEW_StringList_Con((uint64_t)v14, *(_WORD **)(a1 + 32), *(void *)(a1 + 40), a3);
  if (Allocator) {
    return LH_ERROR_to_VERROR(Allocator);
  }
  int Allocator = PNEW_StringList_Con((uint64_t)v14, *(_WORD **)(a1 + 32), *(void *)(a1 + 40), a4);
  if (Allocator) {
    return LH_ERROR_to_VERROR(Allocator);
  }
  int Allocator = PNEW_StringList_Con((uint64_t)v14, *(_WORD **)(a1 + 32), *(void *)(a1 + 40), a5);
  if (Allocator) {
    return LH_ERROR_to_VERROR(Allocator);
  }
  LODWORD(result) = CLM_SplitWordInPhonemes(*(void *)(a1 + 24), a2, 0, 0, (void *)*a3, &v13);
  if ((result & 0x80000000) != 0 || v13)
  {
    if ((int)result < 0) {
      return result;
    }
    else {
      return 2347769856;
    }
  }
  else
  {
    LODWORD(result) = CLM_SplitWordInPhonemes(*(void *)(a1 + 24), a2, 0, 0, (void *)*a4, &v13);
    if (v13) {
      BOOL v12 = (int)result <= -1;
    }
    else {
      BOOL v12 = 1;
    }
    if (v12) {
      return result;
    }
    else {
      return 2347769856;
    }
  }
}

uint64_t CLM_ApplyRules(uint64_t a1, uint64_t a2, unsigned int a3, char *a4, char *a5, char *a6, unsigned int a7, void *a8, void **a9, void **a10)
{
  int v32 = 0;
  unsigned int v17 = hlp_CheckDoAlignment(a8, a9, a10);
  uint64_t v18 = CLM_GiveLanguageBuffer(a4, a2, a3, 0);
  if (v18)
  {
    uint64_t v19 = v18;
    if (*(_DWORD *)(v18 + 8))
    {
      unsigned int v31 = v17;
      uint64_t v20 = 0;
      unint64_t v21 = 0;
      int v22 = 0;
      do
      {
        BOOL v23 = CLM_SearchAndReplace(a1, *(unsigned char **)(*(void *)(v19 + 16) + v20), *(char **)(*(void *)(v19 + 16) + v20 + 16), *(void *)(*(void *)(v19 + 16) + v20 + 8), a5, (uint64_t)a6, a7);
        BOOL v24 = v23;
        if (v23)
        {
          if (v23 & 0x80000000) {
            break;
          }
        }
        else
        {
          strcpy(a5, a6);
          if (v31)
          {
            if (!v22)
            {
              int v22 = 1;
              if ((CLM_SplitWordInPhonemes(*(void *)(a1 + 24), a6, 0, 0, *a10, &v32) & 0x80000000) == 0 && !v32)
              {
                if ((CLM_AlignPhonlists(*(void *)(a1 + 24), (uint64_t)a8, (uint64_t)*a9, (uint64_t)*a10) & 0x80000000) != 0)
                {
                  int v22 = 1;
                }
                else
                {
                  uint64_t v25 = *a9;
                  *a9 = *a10;
                  *a10 = v25;
                  StringList_Reset(v25);
                  int v22 = 0;
                }
              }
            }
          }
        }
        ++v21;
        v20 += 24;
      }
      while (v21 < *(unsigned int *)(v19 + 8));
      if (v31)
      {
        int v26 = *a10;
        *a10 = *a9;
        *a9 = v26;
        if (v22)
        {
          StringList_Reset(a8);
          StringList_Reset(*a9);
          StringList_Reset(*a10);
        }
      }
    }
    else
    {
      BOOL v24 = 0;
      if (v17)
      {
        int v28 = *a10;
        *a10 = *a9;
        *a9 = v28;
      }
    }
  }
  else
  {
    if (v17)
    {
      int v27 = *a10;
      *a10 = *a9;
      *a9 = v27;
    }
    return 1;
  }
  return v24;
}

uint64_t CLM_ApplyPhonemeMapping(uint64_t a1, uint64_t a2, unsigned int a3, char *a4, char *a5, char *a6, unsigned int a7, void *a8, void **a9, void **a10)
{
  uint64_t v69 = 0;
  unsigned int v70 = 0;
  uint64_t v16 = 2347769856;
  uint64_t v17 = CLM_GiveLanguageBuffer(a4, a2, a3, 1);
  if (!v17)
  {
    log_OutText(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"Invalid Language : %s", v18, v19, v20, (uint64_t)a4);
    return v16;
  }
  if (a6)
  {
    uint64_t v21 = v17;
    uint64_t v72 = 0;
    memset(v71, 0, sizeof(v71));
    int Allocator = ooc_utils_createAllocator((uint64_t)v71, *(_WORD **)(a1 + 32), *(void *)(a1 + 40));
    if (Allocator
      || (int Allocator = PNEW_StringList_Con((uint64_t)v71, *(_WORD **)(a1 + 32), *(void *)(a1 + 40), (uint64_t *)&v70)) != 0)
    {
      uint64_t v23 = LH_ERROR_to_VERROR(Allocator);
    }
    else
    {
      uint64_t v23 = CLM_SplitWordInPhonemes(*(void *)(a1 + 24), a5, 0, 0, v70, 0);
    }
    uint64_t v24 = v23;
    if ((v23 & 0x80000000) == 0)
    {
      unsigned int v68 = v23;
      uint64_t v25 = v21 + 8;
      *(void *)&v71[0] = 0;
      uint64_t v67 = (uint64_t)a8;
      unsigned int v26 = hlp_CheckDoAlignment(a8, a9, a10);
      *a6 = 0;
      if (StringList_GetCountStrings((uint64_t)v70))
      {
        unsigned __int16 v27 = 0;
        size_t v28 = a7;
        while (1)
        {
          uint64_t v29 = (char *)StringList_GetAt((uint64_t)v70, v27);
          hlp_FindPhonemeMapping(v25, v29, v71, &v69);
          if (*(void *)&v71[0]) {
            uint64_t v29 = *(char **)&v71[0];
          }
          size_t v30 = strlen(a6);
          if (v30 + strlen(v29) + 1 > v28) {
            break;
          }
          strcat(a6, v29);
          if (StringList_GetCountStrings((uint64_t)v70) <= ++v27) {
            goto LABEL_13;
          }
        }
        log_OutPublic(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 50003, 0, v31, v32, v33, v34, v63);
        return v16;
      }
LABEL_13:
      if (!v26) {
        goto LABEL_30;
      }
      size_t v35 = v70;
      uint64_t v24 = v68;
      if (v70)
      {
        int v36 = *a9;
        if (*a9)
        {
          unsigned int CountStrings = StringList_GetCountStrings((uint64_t)v70);
          unsigned int v38 = StringList_GetCountStrings((uint64_t)v36);
          unsigned int v39 = v38;
          BOOL v40 = CountStrings != 0;
          if (v38 && CountStrings)
          {
            uint64_t v64 = (uint64_t)v35;
            int v41 = 0;
            unsigned __int16 v42 = 0;
            while (2)
            {
              BOOL v65 = CountStrings > v42;
              while (1)
              {
                unsigned int v43 = (const char *)StringList_GetAt((uint64_t)v36, (unsigned __int16)v41);
                if (strcmp(v43, "*")) {
                  break;
                }
                if (v39 <= (unsigned __int16)++v41 || CountStrings <= v42)
                {
                  uint64_t v24 = v68;
                  BOOL v40 = v65;
                  if (v39 > (unsigned __int16)v41) {
                    goto LABEL_39;
                  }
LABEL_45:
                  if (!v40)
                  {
LABEL_46:
                    if (!StringList_GetCountStrings((uint64_t)*a9)) {
                      goto LABEL_31;
                    }
                    int v50 = 0;
                    int v51 = 0;
                    uint64_t v66 = v25;
                    while (2)
                    {
                      size_t v52 = (char *)StringList_GetAt((uint64_t)*a9, (unsigned __int16)v51);
                      hlp_FindPhonemeMapping(v25, v52, v71, &v69);
                      long long v53 = *a9;
                      if (v50)
                      {
                        int v50 = 1;
                        goto LABEL_66;
                      }
                      long long v54 = *(unsigned char **)&v71[0];
                      uint64_t v55 = v69;
                      long long v56 = *a10;
                      if (!strcmp(v52, "*")) {
                        goto LABEL_62;
                      }
                      if (v54)
                      {
                        if (*v54)
                        {
                          if (v55)
                          {
                            if (StringList_GetCountStrings(v55))
                            {
                              unsigned __int16 v57 = 0;
                              while (1)
                              {
                                unsigned int v58 = (char *)StringList_GetAt(v55, v57);
                                int v59 = CLM_PhonList_Append((uint64_t)v56, v58);
                                if (v59 < 0) {
                                  break;
                                }
                                if (v57)
                                {
                                  int v60 = CLM_PhonList_InsertAt((uint64_t)v53, (unsigned __int16)++v51, "*");
                                  if (v60 < 0)
                                  {
                                    int v59 = v60;
                                    uint64_t v25 = v66;
                                    goto LABEL_65;
                                  }
                                  int v59 = CLM_PhonList_InsertAt(v67, (unsigned __int16)v51, "*");
                                  uint64_t v25 = v66;
                                  if (v59 < 0) {
                                    goto LABEL_65;
                                  }
                                }
                                if (StringList_GetCountStrings(v55) <= ++v57) {
                                  goto LABEL_65;
                                }
                              }
                            }
                            else
                            {
                              int v59 = 0;
                            }
                          }
                          else
                          {
                            int v59 = -1947197440;
                          }
                          goto LABEL_65;
                        }
LABEL_62:
                        uint64_t v61 = (uint64_t)v56;
                        long long v62 = "*";
                      }
                      else
                      {
                        uint64_t v61 = (uint64_t)v56;
                        long long v62 = v52;
                      }
                      int v59 = CLM_PhonList_Append(v61, v62);
LABEL_65:
                      int v50 = v59 >> 31;
                      long long v53 = *a9;
                      uint64_t v24 = v59 & ~(v59 >> 31);
LABEL_66:
                      if (StringList_GetCountStrings((uint64_t)v53) <= (unsigned __int16)++v51) {
                        goto LABEL_31;
                      }
                      continue;
                    }
                  }
                  goto LABEL_31;
                }
              }
              int v44 = (const char *)StringList_GetAt((uint64_t)v36, (unsigned __int16)v41);
              int v45 = (const char *)StringList_GetAt(v64, v42);
              int v46 = strcmp(v44, v45);
              if (!v46) {
                ++v42;
              }
              ++v41;
              BOOL v40 = CountStrings > v42;
              if (!v46 && v39 > (unsigned __int16)v41 && CountStrings > v42) {
                continue;
              }
              break;
            }
            if (!v46)
            {
              uint64_t v24 = v68;
              if (v39 > (unsigned __int16)v41) {
                goto LABEL_39;
              }
              goto LABEL_45;
            }
LABEL_30:
            uint64_t v24 = v68;
          }
          else
          {
            if (!v38) {
              goto LABEL_45;
            }
            LOWORD(v41) = 0;
LABEL_39:
            if (v39 <= (unsigned __int16)v41) {
              goto LABEL_46;
            }
            do
            {
              unsigned int v48 = (const char *)StringList_GetAt((uint64_t)v36, (unsigned __int16)v41);
              int v49 = strcmp(v48, "*");
              if (v49) {
                break;
              }
              LOWORD(v41) = v41 + 1;
            }
            while (v39 > (unsigned __int16)v41);
            if (!v49) {
              goto LABEL_46;
            }
          }
        }
      }
    }
LABEL_31:
    hlp_FreePhonlist(a1, (uint64_t *)&v70);
    return v24;
  }
  return v16;
}

uint64_t hlp_FreePhonlist(uint64_t a1, uint64_t *a2)
{
  uint64_t v5 = 0;
  memset(v4, 0, sizeof(v4));
  uint64_t result = ooc_utils_createAllocator((uint64_t)v4, *(_WORD **)(a1 + 32), *(void *)(a1 + 40));
  if (result) {
    return LH_ERROR_to_VERROR(result);
  }
  if (a2)
  {
    if (*a2)
    {
      uint64_t result = OOC_PlacementDeleteObject((uint64_t)v4, *a2);
      *a2 = 0;
    }
  }
  return result;
}

uint64_t CLM_TokenizeTranscription(uint64_t a1, int a2, char *a3, char *a4, unsigned int a5, _DWORD *a6)
{
  if ((safeh_HandleCheck(a1, a2, 63000, 216) & 0x80000000) != 0 || !a1) {
    return 2347769864;
  }
  uint64_t v11 = *(void *)(a1 + 24);
  return CLM_SplitWordInPhonemes(v11, a3, a4, a5, 0, a6);
}

uint64_t CLM_GetFeClmCompInfo(uint64_t a1, int a2, _DWORD *a3)
{
  *a3 = 0;
  uint64_t v5 = safeh_HandleCheck(a1, a2, 63000, 216);
  uint64_t result = 2347769864;
  if ((v5 & 0x80000000) == 0 && a1)
  {
    if (*(_DWORD *)(a1 + 200))
    {
      unsigned int v7 = 0;
      uint64_t result = paramc_ParamGetUInt(*(void *)(*(void *)(a1 + 24) + 40), (uint64_t)"fe_clm_component", &v7);
      if ((result & 0x80000000) == 0) {
        *a3 = v7;
      }
    }
    else
    {
      return v5;
    }
  }
  return result;
}

BOOL CLM_HasData(uint64_t a1, int a2)
{
  int v3 = safeh_HandleCheck(a1, a2, 63000, 216);
  BOOL result = 0;
  if ((v3 & 0x80000000) == 0)
  {
    if (a1) {
      return *(void *)(a1 + 48) != 0;
    }
  }
  return result;
}

uint64_t CLM_ClassOpen(_WORD *a1, uint64_t a2, void *a3)
{
  uint64_t v7 = 0;
  if (!a3) {
    return 2347769863;
  }
  uint64_t result = InitRsrcFunction(a1, a2, &v7);
  if ((result & 0x80000000) == 0)
  {
    *a3 = a1;
    a3[1] = a2;
  }
  return result;
}

uint64_t CLM_ClassClose()
{
  return 0;
}

uint64_t hlp_GetLanguage(uint64_t a1, char *a2)
{
  long long __s = 0;
  *a2 = 0;
  uint64_t Str = paramc_ParamGetStr(a1, (uint64_t)"langcode", &__s);
  if ((Str & 0x80000000) == 0)
  {
    uint64_t v5 = __s;
    if (*__s)
    {
      size_t v6 = 0;
      do
      {
        unint64_t v7 = v6;
        a2[v6] = __tolower(v5[v6]);
        ++v6;
        uint64_t v5 = __s;
        size_t v8 = strlen(__s);
      }
      while (v7 <= 1 && v6 < v8);
    }
    else
    {
      size_t v6 = 0;
    }
    a2[v6] = 0;
    if (strcmp(v5, a2)) {
      return paramc_ParamSetStr(a1, (uint64_t)"langcode", a2);
    }
  }
  return Str;
}

uint64_t CLM_GetSuitableLocationOfFeCLMComponent(uint64_t a1, int a2, _DWORD *a3)
{
  uint64_t result = safeh_HandleCheck(a1, a2, 63000, 216);
  if ((result & 0x80000000) != 0) {
    return 2347769864;
  }
  *a3 = *(_DWORD *)(a1 + 200) != 0;
  return result;
}

uint64_t CLM_ValidateTranscriptionEx(uint64_t a1, int a2, char *a3, char *a4, char *a5, _DWORD *a6, int a7)
{
  uint64_t v14 = 2347769864;
  uint64_t v15 = safeh_HandleCheck(a1, a2, 63000, 216);
  if ((v15 & 0x80000000) != 0 || !a1) {
    return v14;
  }
  uint64_t v16 = v15;
  int ShouldTempWorkAroundVO9614 = hlp_ShouldTempWorkAroundVO9614(a1, a3);
  if ((safeh_HandleCheck(a1, a2, 63000, 216) & 0x80000000) != 0 || !*(void *)(a1 + 48))
  {
    log_OutText(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"CLM_ValidateTranscriptionEx : CLM data not available, assume valid transcription", v18, v19, v20, v52);
    *a6 = 1;
    return v16;
  }
  int v58 = ShouldTempWorkAroundVO9614;
  uint64_t v21 = CLM_GiveLanguageBuffer(a3, *(void *)(a1 + 152), *(_DWORD *)(a1 + 160), 2);
  if (!v21)
  {
    log_OutText(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"CLM_ValidateTranscriptionEx : CLM data not available for %s", v22, v23, v24, (uint64_t)a3);
    *a6 = 0;
    return v16;
  }
  uint64_t v25 = v21;
  int v59 = 0;
  log_OutText(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"CLM_ValidateTranscriptionEx : Begin (%s)", v22, v23, v24, (uint64_t)a5);
  CLM_GetFeClmCompInfo(a1, a2, &v59);
  int v26 = v59;
  if (v59)
  {
    int v27 = LH_stricmp((char *)(a1 + 56), a3);
    uint64_t v28 = 0;
    if (!a4 || v27) {
      goto LABEL_20;
    }
    if (*a4 && *(_WORD *)(a1 + 204))
    {
      int v56 = v26;
      uint64_t v29 = 0;
      unint64_t v30 = 0;
      while (LH_stricmp((char *)(*(void *)(a1 + 208) + v29), a4))
      {
        ++v30;
        v29 += 16;
        if (v30 >= *(unsigned __int16 *)(a1 + 204))
        {
          uint64_t v28 = 0;
          goto LABEL_41;
        }
      }
      uint64_t v28 = *(void *)(a1 + 208) + v29;
LABEL_41:
      int v26 = v56;
      goto LABEL_20;
    }
  }
  uint64_t v28 = 0;
LABEL_20:
  *a6 = 1;
  uint64_t v32 = CLM_DeleteNonPhoneChars(a1, a5);
  if ((v32 & 0x80000000) != 0)
  {
    uint64_t v44 = 0;
    uint64_t v14 = v32;
  }
  else
  {
    int v57 = v26;
    size_t v36 = (2 * strlen(a5)) | 1;
    uint64_t v37 = (char *)heap_Calloc(*(void **)(*(void *)(a1 + 24) + 8), v36, 1);
    if (v37)
    {
      unsigned __int16 v42 = *(char **)(v25 + 8);
      unsigned int v43 = v37;
      long long v54 = v42;
      unsigned int v55 = v36;
      uint64_t v14 = CLM_ValidateInForeignLooLoanSet(a1, a5, v37, v36, v42, v58, v28, a6);
      if ((v14 & 0x80000000) != 0)
      {
        uint64_t v44 = (uint64_t)v43;
      }
      else
      {
        uint64_t v44 = (uint64_t)v43;
        if (a7 == 1)
        {
          if (v57)
          {
            if (!*a6)
            {
              int v45 = LH_stricmp((char *)(a1 + 56), a3);
              if (a4)
              {
                if (!v45 && !*a4 && *(_WORD *)(a1 + 204))
                {
                  uint64_t v46 = 0;
                  for (unint64_t i = 0; i < *(unsigned __int16 *)(a1 + 204); ++i)
                  {
                    uint64_t v48 = *(void *)(a1 + 208);
                    *a6 = 1;
                    uint64_t v14 = CLM_ValidateInForeignLooLoanSet(a1, a5, v43, v55, v54, v58, v48 + v46, a6);
                    if ((v14 & 0x80000000) != 0) {
                      break;
                    }
                    if (*a6 == 1)
                    {
                      strcpy(a4, (const char *)(v48 + v46));
                      log_OutText(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"Extended phoneme set %s valid, so returned as foreign loan phoneme set", v49, v50, v51, (uint64_t)a4);
                      break;
                    }
                    v46 += 16;
                  }
                }
              }
            }
          }
        }
      }
    }
    else
    {
      log_OutPublic(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 50000, 0, v38, v39, v40, v41, v53);
      uint64_t v44 = 0;
      uint64_t v14 = 2347769866;
    }
  }
  log_OutText(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"CLM_ValidateTranscriptionEx : End (%s)", v33, v34, v35, (uint64_t)a5);
  if (v44) {
    heap_Free(*(void **)(*(void *)(a1 + 24) + 8), v44);
  }
  return v14;
}

uint64_t CLM_ValidateInForeignLooLoanSet(uint64_t a1, char *a2, char *a3, unsigned int a4, char *a5, int a6, uint64_t a7, _DWORD *a8)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint64_t v13 = CLM_SplitWordInPhonemes(*(void *)(a1 + 24), a2, a3, a4, 0, 0);
  if ((v13 & 0x80000000) == 0)
  {
    __lasts = 0;
    uint64_t v14 = strtok_r(a3, " ", &__lasts);
    *a2 = 0;
    if (v14)
    {
      uint64_t v15 = v14;
      do
      {
        strcat(a2, v15);
        strcpy(__s2, " ");
        __strcat_chk();
        __strcat_chk();
        if (!a6 && *v15 != 18 && !strstr(a5, __s2))
        {
          if (a7 && (uint64_t v19 = *(unsigned __int16 *)(a7 + 4), *(_WORD *)(a7 + 4)))
          {
            uint64_t v20 = *(const char ***)(a7 + 8);
            while (strcmp(v15, *v20))
            {
              v20 += 3;
              if (!--v19) {
                goto LABEL_12;
              }
            }
          }
          else
          {
LABEL_12:
            log_OutText(*(void *)(*(void *)(a1 + 24) + 32), (uint64_t)"CLM", 4, 0, (uint64_t)"Wrong L&H+ phoneme %s", v16, v17, v18, (uint64_t)v15);
            *a8 = 0;
          }
        }
        uint64_t v15 = strtok_r(0, " ", &__lasts);
      }
      while (v15);
    }
  }
  return v13;
}

uint64_t CLM_ValidateTranscription(uint64_t a1, int a2, char *a3, uint64_t a4, char *a5, _DWORD *a6)
{
  if (a4)
  {
    uint64_t v11 = &v13;
    __strcpy_chk();
  }
  else
  {
    uint64_t v11 = 0;
  }
  return CLM_ValidateTranscriptionEx(a1, a2, a3, v11, a5, a6, 0);
}

uint64_t CLM_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2347769857;
  }
  uint64_t result = 0;
  *a2 = &ICLM;
  return result;
}

void *hlp_CheckDoAlignment(void *result, void **a2, void **a3)
{
  if (result)
  {
    int CountStrings = StringList_GetCountStrings((uint64_t)result);
    uint64_t result = 0;
    if (a2)
    {
      if (CountStrings)
      {
        uint64_t result = *a2;
        if (*a2)
        {
          int v6 = StringList_GetCountStrings((uint64_t)result);
          uint64_t result = 0;
          if (a3)
          {
            if (v6)
            {
              uint64_t result = *a3;
              if (*a3)
              {
                StringList_Reset(result);
                return (void *)(CountStrings == v6);
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t hlp_FindPhonemeMapping(uint64_t result, char *__s2, void *a3, void *a4)
{
  *a3 = 0;
  *a4 = 0;
  uint64_t v4 = *(unsigned int *)result;
  if (v4)
  {
    uint64_t v8 = result;
    uint64_t v9 = 0;
    uint64_t v10 = *(void *)(result + 8);
    uint64_t v11 = 24 * v4;
    while (1)
    {
      uint64_t result = *(void *)(v10 + v9);
      if (result)
      {
        uint64_t v12 = *(void *)(v10 + v9 + 8);
        if (v12)
        {
          uint64_t result = strcmp((const char *)result, __s2);
          if (!result) {
            break;
          }
        }
      }
      v9 += 24;
      if (v11 == v9) {
        return result;
      }
    }
    *a3 = v12;
    *a4 = *(void *)(*(void *)(v8 + 8) + v9 + 16);
  }
  return result;
}

void *CLM_UnloadSettings(uint64_t a1)
{
  CLM_EmptyLanguageStruct((void *)a1, (uint64_t *)(a1 + 88), *(_DWORD *)(a1 + 96));
  *(_DWORD *)(a1 + 96) = 0;
  CLM_EmptyLanguageStruct((void *)a1, (uint64_t *)(a1 + 104), *(_DWORD *)(a1 + 112));
  *(_DWORD *)(a1 + 112) = 0;
  CLM_EmptyLanguageStruct((void *)a1, (uint64_t *)(a1 + 120), *(_DWORD *)(a1 + 128));
  *(_DWORD *)(a1 + 128) = 0;
  CLM_EmptyLanguageStruct((void *)a1, (uint64_t *)(a1 + 136), *(_DWORD *)(a1 + 144));
  *(_DWORD *)(a1 + 144) = 0;
  CLM_EmptyLanguageStruct((void *)a1, (uint64_t *)(a1 + 72), *(_DWORD *)(a1 + 80));
  *(_DWORD *)(a1 + 80) = 0;
  CLM_EmptyLanguageStruct((void *)a1, (uint64_t *)(a1 + 152), *(_DWORD *)(a1 + 160));
  *(_DWORD *)(a1 + 160) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  CLM_FreePreCompiledSplitWordRegEx((void *)a1);
  return CLM_FreePreCompiledReplacementRegEx((void *)a1);
}

uint64_t getObjcForThisApi_0(uint64_t a1, uint64_t a2)
{
  uint64_t result = 0;
  __s1 = 0;
  if (a1 && a2)
  {
    if ((paramc_ParamGetStr(*(void *)(a1 + 40), (uint64_t)"clcpppipelinemode", &__s1) & 0x80000000) != 0
      || !__s1
      || !*__s1
      || !strcmp(__s1, "internal"))
    {
      a1 = a2;
    }
    return *(void *)(a1 + 48);
  }
  return result;
}

uint64_t IRefCnt_ObjcLoadCLMData(_WORD *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v77 = *MEMORY[0x263EF8340];
  uint64_t v50 = 0;
  uint64_t inited = InitRsrcFunction(a1, a2, &v50);
  if ((inited & 0x80000000) != 0) {
    goto LABEL_38;
  }
  uint64_t v11 = 2347769856;
  uint64_t v12 = (void *)heap_Calloc(*(void **)(v50 + 8), 1, 304);
  *(void *)(a5 + 48) = v12;
  if (!v12)
  {
    log_OutPublic(*(void *)(*(void *)(a5 + 24) + 32), (uint64_t)"CLM", 50000, 0, v13, v14, v15, v16, v49);
    uint64_t v11 = 2347769866;
    goto LABEL_39;
  }
  *uint64_t v12 = v50;
  v12[1] = a1;
  int v12[2] = a2;
  if (strlen(a3) - 256 < 0xFFFFFFFFFFFFFEFFLL) {
    goto LABEL_39;
  }
  strcpy((char *)(*(void *)(a5 + 48) + 48), a3);
  unsigned __int8 v59 = 0;
  int v58 = 0;
  uint64_t v56 = 0;
  int v57 = 0;
  int v55 = 0;
  strcpy(v54, "CLMP");
  memset(v76, 0, sizeof(v76));
  long long v75 = 0u;
  long long v74 = 0u;
  long long v73 = 0u;
  long long v72 = 0u;
  long long v71 = 0u;
  long long v70 = 0u;
  long long v69 = 0u;
  long long v68 = 0u;
  long long v67 = 0u;
  long long v66 = 0u;
  long long v65 = 0u;
  long long v64 = 0u;
  long long v63 = 0u;
  *(_OWORD *)&v62[5] = 0u;
  uint64_t v52 = 0;
  uint64_t v17 = *(uint64_t **)(a5 + 48);
  uint64_t inited = hlp_GetLanguage(*(void *)(*(void *)(a5 + 24) + 40), __s2);
  if ((inited & 0x80000000) != 0) {
    goto LABEL_38;
  }
  if ((paramc_ParamGetStr(*(void *)(*(void *)(a5 + 24) + 40), (uint64_t)"clcpppipelinemode", &v52) & 0x80000000) != 0)
  {
    BOOL v18 = 1;
  }
  else
  {
    BOOL v18 = 1;
    if (v52) {
      BOOL v18 = *v52 == 0;
    }
  }
  uint64_t v19 = *(void *)(*v17 + 24);
  if (v19) {
    uint64_t v20 = "clm";
  }
  else {
    uint64_t v20 = "clm.dat";
  }
  if (v19) {
    uint64_t v21 = 2;
  }
  else {
    uint64_t v21 = 1;
  }
  uint64_t v22 = ssftriff_reader_ObjOpen((_WORD *)v17[1], v17[2], v21, v20, v54, 1031, (uint64_t *)&v57);
  if ((v22 & 0x80000000) == 0)
  {
    int v30 = 0;
    while (!v30
         && (ssftriff_reader_OpenChunk((uint64_t)v57, &v58, (unsigned int *)&v55, &v56, v26, v27, v28, v29) & 0x80000000) == 0)
    {
      if (v58 ^ 0x504D4C43 | v59) {
        goto LABEL_21;
      }
      unsigned int v51 = 256;
      uint64_t v31 = ssftriff_reader_ReadStringZ((uint64_t)v57, v56, v55, 0, __s1, &v51);
      if ((v31 & 0x80000000) != 0) {
        goto LABEL_42;
      }
      if (!strstr(__s1, __s2))
      {
LABEL_21:
        int v30 = 0;
      }
      else
      {
        uint64_t v31 = ssftriff_reader_DetachChunkData((uint64_t)v57, v17 + 3, v17 + 4, v32, v33, v34, v35, v36);
        if ((v31 & 0x80000000) != 0)
        {
LABEL_42:
          uint64_t v11 = v31;
          ssftriff_reader_CloseChunk((uint64_t)v57);
          ssftriff_reader_ObjClose(v57, v42, v43, v44, v45, v46, v47, v48);
          goto LABEL_39;
        }
        unsigned int v37 = v51 | 0xFFFFFFFC;
        if ((v51 & 3) == 0) {
          unsigned int v37 = 0;
        }
        uint64_t v38 = v51 - v37;
        v17[4] += v38;
        int v30 = 1;
        *((_DWORD *)v17 + 10) = v55 - v38;
        *((_DWORD *)v17 + 11) = 1;
      }
      uint64_t v39 = ssftriff_reader_CloseChunk((uint64_t)v57);
      if ((v39 & 0x80000000) != 0)
      {
        uint64_t v11 = v39;
        ssftriff_reader_ObjClose(v57, v23, v24, v25, v26, v27, v28, v29);
        v17[3] = 0;
        goto LABEL_39;
      }
    }
    uint64_t v11 = ssftriff_reader_ObjClose(v57, v23, v24, v25, v26, v27, v28, v29);
    if ((v11 & 0x80000000) != 0) {
      goto LABEL_39;
    }
    goto LABEL_33;
  }
  if (v18)
  {
    uint64_t v11 = v22;
    log_OutPublic(*(void *)(*(void *)(a5 + 24) + 32), (uint64_t)"CLM", 30006, "%s", v26, v27, v28, v29, "clm.dat not found");
    goto LABEL_39;
  }
  strcpy(v62, "clm/");
  __strcat_chk();
  uint64_t inited = brokeraux_ComposeBrokerString(*(void *)(a5 + 24), v62, 0, 1, __s2, 0, 0, v61, 0x100uLL);
  if ((inited & 0x80000000) != 0
    || (uint64_t inited = brk_DataOpenEx(*(void *)(*v17 + 24), (uint64_t)v61, 1, (uint64_t)(v17 + 3)),
        (inited & 0x80000000) != 0))
  {
LABEL_38:
    uint64_t v11 = inited;
  }
  else
  {
    *((_DWORD *)v17 + 10) = 0;
    uint64_t v11 = brk_DataMapEx(*(void *)(*v17 + 24), v17[3], 0, (uint64_t)(v17 + 5), (uint64_t)(v17 + 4));
    if ((v11 & 0x80000000) == 0)
    {
LABEL_33:
      *(void *)(a4 + 32) = *(void *)(a5 + 48);
      return v11;
    }
    brk_DataClose(*(void *)(*v17 + 24), v17[3]);
  }
LABEL_39:
  uint64_t v40 = *(void *)(a5 + 48);
  if (v40)
  {
    heap_Free(*(void **)(v50 + 8), v40);
    *(void *)(a5 + 48) = 0;
  }
  return v11;
}

uint64_t IRefCnt_ObjcUnloadCLMData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a3 + 32);
  if (v8)
  {
    if (*(_DWORD *)(v8 + 44))
    {
      ssftriff_reader_ReleaseChunkData(*(void **)(v8 + 24), a2, a3, a4, a5, a6, a7, a8);
    }
    else
    {
      brk_DataUnmap(*(void *)(*(void *)v8 + 24), *(void *)(v8 + 24), *(void *)(v8 + 32));
      brk_DataClose(*(void *)(*(void *)v8 + 24), *(void *)(v8 + 24));
    }
    *(void *)(v8 + 24) = 0;
    *(void *)(v8 + 32) = 0;
    *(_DWORD *)(v8 + 40) = 0;
    heap_Free(*(void **)(*(void *)v8 + 8), v8);
  }
  return 0;
}

uint64_t CLM_LoadRules(uint64_t a1, uint64_t a2, unsigned int a3, int a4, unsigned int *a5)
{
  if (a4) {
    uint64_t v9 = (uint64_t *)(a1 + 120);
  }
  else {
    uint64_t v9 = (uint64_t *)(a1 + 88);
  }
  if (a4) {
    uint64_t v10 = (uint64_t *)(a1 + 136);
  }
  else {
    uint64_t v10 = (uint64_t *)(a1 + 104);
  }
  if (a4) {
    uint64_t v11 = (unsigned int *)(a1 + 128);
  }
  else {
    uint64_t v11 = (unsigned int *)(a1 + 96);
  }
  if (a4) {
    uint64_t v12 = (unsigned int *)(a1 + 144);
  }
  else {
    uint64_t v12 = (unsigned int *)(a1 + 112);
  }
  uint64_t result = CLM_EnumerateLanguages(a1, v9, v11, 0, a2, a3, *a5);
  if ((result & 0x80000000) == 0)
  {
    if ((CLM_FindSeperationRecord(a2, a3, a5) & 0x80000000) != 0)
    {
      return 2347777666;
    }
    else
    {
      int v14 = CLM_EnumerateLanguages(a1, v10, v12, 0, a2, a3, *a5);
      return v14 & (v14 >> 31);
    }
  }
  return result;
}

uint64_t CLM_GetForeignLoanPhonemeSets(uint64_t a1, int a2, _WORD *a3, void *a4)
{
  int v7 = safeh_HandleCheck(a1, a2, 63000, 216);
  uint64_t result = 2347769864;
  if ((v7 & 0x80000000) == 0)
  {
    if (a1)
    {
      uint64_t result = 0;
      *a3 = *(_WORD *)(a1 + 204);
      *a4 = *(void *)(a1 + 208);
    }
  }
  return result;
}

uint64_t fe_normout_ObjClose(void *a1, int a2)
{
  uint64_t result = safeh_HandleCheck((uint64_t)a1, a2, 62387, 120);
  if ((result & 0x80000000) != 0) {
    return 2340429832;
  }
  if (a1)
  {
    uint64_t v4 = a1[14];
    if (v4) {
      heap_Free(*(void **)(*a1 + 8), v4);
    }
    a1[14] = 0;
    objc_ReleaseObject(*(void *)(*a1 + 48), (uint64_t)"LINGDB");
    objc_ReleaseObject(*(void *)(*a1 + 48), (uint64_t)"FE_DEPES");
    objc_ReleaseObject(*(void *)(*a1 + 48), (uint64_t)"FE_DCTLKP");
    heap_Free(*(void **)(*a1 + 8), (uint64_t)a1);
    return 0;
  }
  return result;
}

uint64_t fe_normout_ObjReopen(uint64_t a1, int a2)
{
  uint64_t result = safeh_HandleCheck(a1, a2, 62387, 120);
  if ((result & 0x80000000) != 0) {
    return 2340429832;
  }
  if (a1)
  {
    return fe_normout_get_fecfg(a1);
  }
  return result;
}

uint64_t fe_normout_get_fecfg(uint64_t a1)
{
  uint64_t v5 = 0;
  __int16 v4 = 0;
  char v3 = 0;
  *(void *)(a1 + 104) = 0;
  uint64_t result = (*(uint64_t (**)(void, void, const char *, const char *, unsigned char ***, __int16 *, char *))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 40), *(void *)(a1 + 48), "fecfg", "usetntag", &v5, &v4, &v3);
  if ((result & 0x80000000) == 0)
  {
    if (v4 == 1 && v5 && **v5 == 49) {
      *(_DWORD *)(a1 + 104) = 1;
    }
    __int16 v4 = 0;
    uint64_t result = (*(uint64_t (**)(void, void, const char *, const char *, unsigned char ***, __int16 *, char *))(*(void *)(a1 + 56) + 96))(*(void *)(a1 + 40), *(void *)(a1 + 48), "fecfg", "mdesegpos_morpheme_processing", &v5, &v4, &v3);
    if ((result & 0x80000000) == 0 && v4 == 1 && v5 && **v5 == 49) {
      *(_DWORD *)(a1 + 108) = 1;
    }
  }
  return result;
}

uint64_t fe_normout_ProcessStart(uint64_t a1, int a2)
{
  LODWORD(result) = safeh_HandleCheck(a1, a2, 62387, 120);
  if ((int)result >= 0) {
    return result;
  }
  else {
    return 2340429832;
  }
}

uint64_t fe_normout_Process(void *a1, int a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  v223[16] = *MEMORY[0x263EF8340];
  long long __s = 0;
  int v217 = 0;
  int v215 = 0;
  int v214 = 0;
  LOWORD(v213) = 0;
  int v212 = 0;
  __int16 v211 = 0;
  unint64_t v209 = 0;
  int v210 = 0;
  int v207 = 0;
  int v206 = 0;
  int v205 = 0;
  __int16 v202 = 0;
  int v201 = 1;
  unsigned __int16 v200 = 1;
  unsigned __int16 v199 = 1;
  __int16 v198 = 0;
  v223[0] = 0x74756F6D726F6ELL;
  if ((safeh_HandleCheck((uint64_t)a1, a2, 62387, 120) & 0x80000000) != 0) {
    return 2340429832;
  }
  int v216 = 0;
  HIWORD(v213) = 0;
  int v208 = 0;
  uint64_t v204 = 0;
  int v203 = 0;
  long long v186 = 0u;
  long long v187 = 0u;
  long long v188 = 0u;
  long long v189 = 0u;
  long long v190 = 0u;
  long long v191 = 0u;
  long long v192 = 0u;
  long long v193 = 0u;
  long long v194 = 0u;
  long long v195 = 0u;
  long long v196 = 0u;
  long long v197 = 0u;
  *a5 = 1;
  uint64_t v9 = (*(uint64_t (**)(void, void, int *, void))(a1[4] + 112))(a1[2], a1[3], &v203, 0);
  if ((v9 & 0x80000000) != 0) {
    return v9;
  }
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *))(a1[1] + 104))(a3, a4, 1, 0, (char *)&v217 + 2);
  if ((v10 & 0x80000000) == 0
    && ((*(uint64_t (**)(uint64_t, uint64_t, void, void, char *))(a1[1] + 184))(a3, a4, HIWORD(v217), 0, (char *)&v207 + 2) & 0x80000000) == 0&& HIWORD(v207) == 1)
  {
    uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, char **, int *))(a1[1] + 176))(a3, a4, HIWORD(v217), 0, &__s, &v215);
    if ((v10 & 0x80000000) == 0 && (unsigned __int16)v215 >= 2u)
    {
      size_t v11 = strlen(__s);
      uint64_t v12 = (char *)heap_Calloc(*(void **)(*a1 + 8), 1, v11 + 1);
      if (!v12)
      {
        log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 43000, 0, v13, v14, v15, v16, v170);
        return 2340429834;
      }
      uint64_t v17 = (uint64_t)v12;
      strcpy(v12, __s);
      uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t *, char *))(a1[1] + 176))(a3, a4, HIWORD(v217), 1, &v204, (char *)&v216 + 2);
      if ((v18 & 0x80000000) == 0)
      {
        uint64_t v23 = HIWORD(v216);
        int v24 = *(_DWORD *)(v204 + 12);
        log_Markers((uint64_t)a1, (uint64_t)"Markers IN", v204, HIWORD(v216), v19, v20, v21, v22);
        unsigned __int16 v222 = 0;
        int v220 = 0;
        unsigned int v221 = 0;
        unsigned __int16 v219 = 0;
        uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, unsigned __int16 *))(a1[1] + 104))(a3, a4, 2, HIWORD(v217), &v222);
        uint64_t v10 = v25;
        if ((v25 & 0x80000000) == 0)
        {
          unsigned __int16 v29 = v222;
          if (v222)
          {
            __src = (char *)v17;
            unsigned __int16 v30 = 0;
            while (1)
            {
              uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, unsigned int *, char *))(a1[1] + 168))(a3, a4, v29, 0, 1, &v221, (char *)&v220 + 2);
              if ((v31 & 0x80000000) != 0) {
                break;
              }
              if (v221 > 0xA || ((1 << v221) & 0x610) == 0)
              {
                uint64_t v36 = 0;
                uint64_t v35 = v222;
              }
              else
              {
                uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, char *))(a1[1] + 168))(a3, a4, v222, 1, 1, &v220, (char *)&v220 + 2);
                if ((v31 & 0x80000000) != 0) {
                  break;
                }
                uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned __int16 *, char *))(a1[1] + 168))(a3, a4, v222, 2, 1, &v219, (char *)&v220 + 2);
                if ((v31 & 0x80000000) != 0) {
                  break;
                }
                BOOL v34 = (unsigned __int16)v220 > v30 || v219 > v30;
                uint64_t v35 = v222;
                if (v34)
                {
                  unsigned __int16 v30 = v219;
                  uint64_t v36 = 0;
                }
                else
                {
                  uint64_t v36 = v222;
                }
              }
              uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unsigned __int16 *))(a1[1] + 120))(a3, a4, v35, &v222);
              if ((v31 & 0x80000000) != 0) {
                break;
              }
              if (v36)
              {
                log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 1, 0, (uint64_t)"%s", v26, v27, v28, (uint64_t)"Dropping nested word record");
                uint64_t v31 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1[1] + 192))(a3, a4, v36);
                if ((v31 & 0x80000000) != 0) {
                  break;
                }
              }
              unsigned __int16 v29 = v222;
              if (!v222)
              {
                uint64_t v17 = (uint64_t)__src;
                goto LABEL_40;
              }
            }
            uint64_t v10 = v31;
            int v143 = 0;
            uint64_t v43 = 0;
            goto LABEL_121;
          }
        }
        if ((v25 & 0x80000000) != 0) {
          goto LABEL_118;
        }
LABEL_40:
        log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)" ", v26, v27, v28, v170);
        *((void *)&v187 + 1) = &v200;
        *(void *)&long long v188 = &v199;
        *(void *)&long long v187 = &v207;
        *(void *)&long long v186 = a1;
        *((void *)&v189 + 1) = v17;
        *(void *)&long long v190 = 0;
        *((void *)&v190 + 1) = &v202;
        *(void *)&long long v191 = (char *)&v215 + 2;
        *((void *)&v188 + 1) = (char *)&v206 + 2;
        *(void *)&long long v189 = &v201;
        *((void *)&v191 + 1) = &v205;
        *(void *)&long long v192 = &v206;
        *((void *)&v192 + 1) = (char *)&v205 + 2;
        uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t (*)(uint64_t, uint64_t, _WORD *, uint64_t), uint64_t (*)(uint64_t, uint64_t, unsigned __int16 *, uint64_t *), void, uint64_t (*)(), long long *))(a1[1] + 288))(a3, a4, HIWORD(v217), getSentenceAndInsertedCGNLengthPre, getSentenceAndInsertedCGNLength, 0, getSentenceAndInsertedCGNLengthPost, &v186);
        if ((v18 & 0x80000000) == 0)
        {
          LOWORD(v217) = WORD4(v186);
          uint64_t v38 = (void *)heap_Calloc(*(void **)(*a1 + 8), 1, (16 * (unsigned __int16)v207) | 1);
          uint64_t v43 = (uint64_t)v38;
          if (v38)
          {
            void *v38 = 0;
            v38[1] = 0;
            uint64_t v44 = (unsigned char *)heap_Alloc(*(void *)(*a1 + 8), v199 + 128);
            a1[8] = v44;
            if (v44)
            {
              unsigned char *v44 = 0;
              uint64_t v45 = (unsigned char *)heap_Alloc(*(void *)(*a1 + 8), v200);
              a1[9] = v45;
              if (v45)
              {
                *uint64_t v45 = 0;
                uint64_t v46 = (unsigned char *)heap_Alloc(*(void *)(*a1 + 8), v200);
                a1[10] = v46;
                if (v46)
                {
                  *uint64_t v46 = 0;
                  uint64_t v47 = (unsigned char *)heap_Alloc(*(void *)(*a1 + 8), v199 + 128);
                  a1[11] = v47;
                  if (v47)
                  {
                    *uint64_t v47 = 0;
                    if (!*((_DWORD *)a1 + 26)) {
                      goto LABEL_49;
                    }
                    uint64_t v48 = (unsigned char *)heap_Alloc(*(void *)(*a1 + 8), v200);
                    a1[12] = v48;
                    if (v48)
                    {
                      *uint64_t v48 = 0;
LABEL_49:
                      int v201 = 1;
                      *((void *)&v194 + 1) = v43;
                      uint64_t v49 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t (*)(uint64_t, uint64_t, _WORD *, uint64_t *), void, uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t), long long *))(a1[1] + 288))(a3, a4, HIWORD(v217), 0, normOutFnc, 0, normOutFncPost, &v186);
                      if ((v49 & 0x80000000) == 0)
                      {
                        int v183 = v24;
                        uint64_t v184 = v23;
                        log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"ORIG   : %s", v50, v51, v52, v17);
                        log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)" ", v53, v54, v55, v172);
                        log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"L1: %s", v56, v57, v58, a1[8]);
                        unsigned __int16 v59 = strlen((const char *)a1[8]);
                        uint64_t v49 = (*(uint64_t (**)(void, void, void, void, void))(a1[4] + 120))(a1[2], a1[3], 0, a1[8], v59);
                        if ((v49 & 0x80000000) == 0)
                        {
                          log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"L2: %s", v60, v61, v62, a1[9]);
                          unsigned __int16 v63 = strlen((const char *)a1[9]);
                          uint64_t v49 = (*(uint64_t (**)(void, void, uint64_t, void, void))(a1[4] + 120))(a1[2], a1[3], 1, a1[9], v63);
                          if ((v49 & 0x80000000) == 0)
                          {
                            log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"L3: %s", v64, v65, v66, a1[10]);
                            unsigned __int16 v67 = strlen((const char *)a1[10]);
                            uint64_t v49 = (*(uint64_t (**)(void, void, uint64_t, void, void))(a1[4] + 120))(a1[2], a1[3], 2, a1[10], v67);
                            if ((v49 & 0x80000000) == 0)
                            {
                              __src = (char *)v17;
                              log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"L4: %s", v68, v69, v70, a1[11]);
                              unsigned __int16 v71 = strlen((const char *)a1[11]);
                              uint64_t v72 = (*(uint64_t (**)(void, void, uint64_t, void, void))(a1[4] + 120))(a1[2], a1[3], 3, a1[11], v71);
                              if ((v72 & 0x80000000) == 0)
                              {
                                if (!*((_DWORD *)a1 + 26)
                                  || (log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"L5: %s", v73, v74, v75, a1[12]), v76 = strlen((const char *)a1[12]), uint64_t v72 = (*(uint64_t (**)(void, void, uint64_t, void, void))(a1[4] + 136))(a1[2], a1[3], 4, a1[12], v76), (v72 & 0x80000000) == 0))
                                {
                                  log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)" ", v73, v74, v75, v173);
                                  if (((*(uint64_t (**)(void, void, void *))(a1[4] + 80))(a1[2], a1[3], v223) & 0x80000000) != 0)
                                  {
                                    uint64_t v10 = 0;
                                    goto LABEL_143;
                                  }
                                  uint64_t v72 = (*(uint64_t (**)(void, void, void, char **, int *))(a1[4] + 128))(a1[2], a1[3], 0, &v210, &v208);
                                  if ((v72 & 0x80000000) == 0)
                                  {
                                    v210[(unsigned __int16)v208] = 0;
                                    log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"O1     : %s", v77, v78, v79, (uint64_t)v210);
                                    uint64_t v72 = (*(uint64_t (**)(void, void, uint64_t, unint64_t *, char *))(a1[4] + 128))(a1[2], a1[3], 3, &v209, (char *)&v208 + 2);
                                    if ((v72 & 0x80000000) == 0)
                                    {
                                      *(unsigned char *)(v209 + HIWORD(v208)) = 0;
                                      log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"O4     : %s", v80, v81, v82, v209);
                                      log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"ORIGL1 : %s", v83, v84, v85, v17);
                                      unsigned int v86 = HIWORD(v208);
                                      if (HIWORD(v208))
                                      {
                                        unint64_t v87 = 0;
                                        unsigned __int16 v88 = 0;
                                        do
                                        {
                                          unint64_t v89 = v209;
                                          if (!strncmp((const char *)(v209 + v87), "▬", 3uLL)
                                            && strncmp(&v210[v88], "▬", 3uLL))
                                          {
                                            unsigned __int16 v90 = Utf8_LengthInUtf8chars(v89, v87);
                                            unsigned __int16 v88 = Utf8_LengthInBytes((unsigned __int8 *)v210, v90);
                                            memmove(&v210[v88 + 3], &v210[v88 + 1], (unsigned __int16)v208 - (unint64_t)v88);
                                            unsigned int v91 = &v210[v88];
                                            *(_WORD *)unsigned int v91 = -26910;
                                            v91[2] = -84;
                                            LOWORD(v208) = v208 + 2;
                                            unsigned int v86 = HIWORD(v208);
                                          }
                                          ++v87;
                                          ++v88;
                                        }
                                        while (v87 < v86);
                                      }
                                      unsigned __int16 v92 = v208;
                                      if ((_WORD)v208)
                                      {
                                        int v93 = 0;
                                        do
                                        {
                                          unint64_t v94 = (unsigned __int16)v93;
                                          if (v210[(unsigned __int16)v93] == 126)
                                          {
                                            if ((unsigned __int16)v93 < v92)
                                            {
                                              do
                                              {
                                                v210[v94] = v210[v94 + 1];
                                                unsigned __int16 v92 = v208;
                                                ++v94;
                                              }
                                              while (v94 < (unsigned __int16)v208);
                                            }
                                            LOWORD(v208) = --v92;
                                            --v93;
                                          }
                                          ++v93;
                                        }
                                        while ((unsigned __int16)v93 < v92);
                                      }
                                      v210[v92] = 0;
                                      int __dst = (char *)heap_Calloc(*(void **)(*a1 + 8), 1, (unsigned __int16)v215 + 1);
                                      if (!__dst)
                                      {
                                        log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 43000, 0, v95, v96, v97, v98, v174);
                                        int v143 = 0;
                                        uint64_t v144 = 0;
                                        uint64_t v10 = 2340429834;
                                        goto LABEL_122;
                                      }
                                      int v99 = strcpy(__dst, __src);
                                      unsigned __int16 v100 = strlen(v99);
                                      __int16 v101 = (_OWORD *)a1[14];
                                      *__int16 v101 = 0u;
                                      v101[1] = 0u;
                                      v101[2] = 0u;
                                      v101[3] = 0u;
                                      v101[4] = 0u;
                                      v101[5] = 0u;
                                      v101[6] = 0u;
                                      v101[7] = 0u;
                                      uint64_t v102 = fe_normout_split_words(a1, a3, a4, v210, a1[14], (unsigned __int16 *)&v212);
                                      if ((v102 & 0x80000000) != 0) {
                                        goto LABEL_154;
                                      }
                                      uint64_t v102 = fe_normout_split_words(a1, a3, a4, __src, 0, (unsigned __int16 *)&v212 + 1);
                                      if ((v102 & 0x80000000) != 0) {
                                        goto LABEL_154;
                                      }
                                      log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)" ", v103, v104, v105, v174);
                                      int v106 = (unsigned __int16)v212;
                                      int v107 = HIWORD(v212);
                                      log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"comparing O1 (%d words) and ORIGL1 (%d words) ", v108, v109, v110, (unsigned __int16)v212);
                                      if (v107 != v106)
                                      {
                                        log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"Mismatch number of orthographic words and number of phonetic words : abandon processing", v111, v112, v113, v175);
                                        uint64_t v10 = 0;
LABEL_155:
                                        uint64_t v144 = 0;
LABEL_156:
                                        int v143 = __dst;
                                        goto LABEL_122;
                                      }
                                      int v213 = 0;
                                      unsigned __int16 v114 = v215;
                                      if (!(_WORD)v215)
                                      {
                                        __int16 v180 = 0;
LABEL_147:
                                        log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)" ", v111, v112, v113, v175);
                                        __int16 v198 = 0;
                                        LOWORD(v212) = 0;
                                        long long v197 = (unint64_t)__dst;
                                        *(void *)&long long v193 = &v212;
                                        *((void *)&v193 + 1) = &v211;
                                        *(void *)&long long v195 = 0;
                                        *(void *)&long long v194 = &v198;
                                        uint64_t v102 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t (*)(uint64_t, uint64_t, _WORD *, uint64_t), void, void, long long *))(a1[1] + 288))(a3, a4, HIWORD(v217), 0, MvToEqWordRecUpdFieldsFnc, 0, 0, &v186);
                                        if ((v102 & 0x80000000) == 0)
                                        {
                                          uint64_t v144 = *((void *)&v197 + 1);
                                          uint64_t v150 = v197;
                                          __int16 v151 = strlen((const char *)v197);
                                          uint64_t v152 = a4;
                                          int v143 = (const char *)v197;
                                          uint64_t v153 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void, void, int *))(a1[1] + 160))(a3, v152, HIWORD(v217), 0, (unsigned __int16)(v151 + 1), v197, &v216);
                                          if ((v153 & 0x80000000) != 0)
                                          {
                                            uint64_t v10 = v153;
                                          }
                                          else
                                          {
                                            log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"new SE_TEXT : %s", v154, v155, v156, v150);
                                            log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)" ", v157, v158, v159, v176);
                                            if ((_WORD)v207)
                                            {
                                              unint64_t v163 = 0;
                                              uint64_t v164 = v43 + 14;
                                              do
                                              {
                                                uint64_t v165 = *(unsigned __int16 *)(v164 - 14);
                                                v164 += 16;
                                                log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"WORDREC[%d] %d,%d --> %d,%d", v160, v161, v162, v165);
                                                ++v163;
                                              }
                                              while (v163 < (unsigned __int16)v207);
                                            }
                                            *(_DWORD *)(v204 + 16) = (unsigned __int16)strlen(v143);
                                            v203 += v180;
                                            uint64_t v10 = (*(uint64_t (**)(void, void))(a1[4] + 104))(a1[2], a1[3]);
                                            if ((v10 & 0x80000000) == 0) {
                                              log_Markers((uint64_t)a1, (uint64_t)"Markers OUT", v204, v184, v166, v167, v168, v169);
                                            }
                                          }
                                          goto LABEL_122;
                                        }
                                        goto LABEL_154;
                                      }
                                      __int16 v180 = 0;
                                      unsigned __int16 v181 = 0;
                                      int v177 = v100;
                                      while (1)
                                      {
                                        if (getNextWord((_WORD *)&v213 + 1, (_WORD *)&v214 + 1, (uint64_t)__src, v114))
                                        {
                                          int NextWord = getNextWord(&v213, &v214, (uint64_t)v210, (unsigned __int16)v208);
                                          __int16 v116 = HIWORD(v213);
                                          if (NextWord)
                                          {
                                            uint64_t v117 = (unsigned __int16)v213;
                                            log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"COMPARE WORD[%d] \"%s\" and \"%s\"", v111, v112, v113, v181);
                                            if (strcmp(&__src[HIWORD(v213)], &v210[v117]))
                                            {
                                              log_OutText(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"   UPDATE WORD[%d] \"%s\" and \"%s\"", v111, v112, v113, v181);
                                              int v118 = v210;
                                              uint64_t v119 = strstr(&v210[v117], "▲");
                                              if (v119)
                                              {
                                                uint64_t v120 = 0;
                                                while (1)
                                                {
                                                  *((void *)&v195 + 1) = v119;
                                                  *(void *)&long long v196 = v120;
                                                  *((void *)&v196 + 1) = (char *)&v213 + 2;
                                                  uint64_t v102 = (*(uint64_t (**)(uint64_t, uint64_t, int *, uint64_t (*)(uint64_t, uint64_t, unsigned __int16 *, uint64_t), long long *))(a1[1] + 280))(a3, a4, &v217, updateWordRecFnc, &v186);
                                                  if ((v102 & 0x80000000) != 0) {
                                                    break;
                                                  }
                                                  uint64_t v125 = (void *)*((void *)&v195 + 1);
                                                  uint64_t v120 = v196;
                                                  HIWORD(v213) = **((_WORD **)&v196 + 1);
                                                  **((unsigned char **)&v195 + 1) = 0;
                                                  if (!v120)
                                                  {
                                                    log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 43001, "%s%s", v121, v122, v123, v124, "message");
                                                    uint64_t v144 = 0;
                                                    uint64_t v10 = 2340429831;
                                                    goto LABEL_156;
                                                  }
                                                  size_t v126 = strlen((const char *)(v120 + 3));
                                                  memmove(v125, (const void *)(v120 + 3), v126 + 1);
                                                  int v118 = v210;
                                                  uint64_t v119 = strstr(&v210[v117], "▲");
                                                  if (!v119) {
                                                    goto LABEL_86;
                                                  }
                                                }
LABEL_154:
                                                uint64_t v10 = v102;
                                                goto LABEL_155;
                                              }
LABEL_86:
                                              unsigned __int16 v127 = strlen(&v118[v117]);
                                              unsigned __int16 v128 = strlen(&__src[HIWORD(v213)]);
                                              unsigned __int16 v178 = strlen(__dst);
                                              unsigned __int16 v179 = v127;
                                              unsigned int v129 = v127;
                                              if (v127 > v128)
                                              {
                                                uint64_t v130 = (unsigned __int16)(v127 - v128 + v178);
                                                uint64_t v131 = heap_Realloc(*(uint64_t **)(*a1 + 8), (uint64_t)__dst, (v130 + 1));
                                                if (!v131)
                                                {
                                                  uint64_t v144 = 0;
                                                  uint64_t v10 = 2340429834;
                                                  goto LABEL_156;
                                                }
                                                *(unsigned char *)(v131 + v130) = 0;
                                                int __dst = (char *)v131;
                                              }
                                              unsigned int v132 = v129 - v128;
                                              if (v129 == v128)
                                              {
                                                memcpy(&__dst[HIWORD(v213) + (uint64_t)v180], &v210[(unsigned __int16)v213], v179);
                                                goto LABEL_106;
                                              }
                                              memmove(&__dst[v129 + v180 + HIWORD(v213)], &__dst[v128 + HIWORD(v213) + v180], v177 - (v128 + HIWORD(v213)));
                                              memcpy(&__dst[HIWORD(v213) + (uint64_t)v180], &v210[(unsigned __int16)v213], v179);
                                              updateWordRecs((uint64_t)a1, a3, a4, v43, (unsigned __int16)v207, HIWORD(v213), v128, v179);
                                              if (v184)
                                              {
                                                uint64_t v133 = 0;
                                                int v134 = (int *)(v204 + 12);
                                                while (1)
                                                {
                                                  int v135 = *v134;
                                                  v134 += 8;
                                                  if (v135 - v183 > (unsigned __int16)(HIWORD(v213) + v180)) {
                                                    break;
                                                  }
                                                  if (v184 == ++v133) {
                                                    goto LABEL_106;
                                                  }
                                                }
                                              }
                                              else
                                              {
                                                LOWORD(v133) = 0;
                                              }
                                              if (v184 > (unsigned __int16)v133)
                                              {
                                                uint64_t v136 = v204;
                                                uint64_t v133 = (unsigned __int16)v133;
                                                unsigned int v137 = (unsigned int *)(v204 + 32 * (unsigned __int16)v133 + 12);
                                                do
                                                {
                                                  if (v133)
                                                  {
                                                    unsigned int v138 = v132 + *v137;
                                                    if (*(_DWORD *)(v136 + 32 * (v133 - 1) + 12) > v138) {
                                                      goto LABEL_105;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    unsigned int v138 = v132 + *(_DWORD *)(v136 + 12);
                                                  }
                                                  *unsigned int v137 = v138;
LABEL_105:
                                                  ++v133;
                                                  v137 += 8;
                                                }
                                                while (v184 != v133);
                                              }
LABEL_106:
                                              v180 += v179 - v128;
                                              if (v129 < v128 && (int)(v128 - v129) >= 1)
                                              {
                                                unsigned int v139 = 0;
                                                uint32x2_t v140 = (uint32x2_t)vdup_n_s32(v128 - v129 - 1);
                                                int v141 = v178 - 1;
                                                do
                                                {
                                                  uint32x2_t v142 = vcge_u32(v140, (uint32x2_t)vorr_s8((int8x8_t)vdup_n_s32(v139), (int8x8_t)0x100000000));
                                                  if (v142.i8[0]) {
                                                    __dst[v141] = 0;
                                                  }
                                                  if (v142.i8[4]) {
                                                    __dst[v178 + (v139 ^ 0xFFFFFFFE)] = 0;
                                                  }
                                                  v139 += 2;
                                                  v141 -= 2;
                                                }
                                                while (((v128 - v129 + 1) & 0xFFFFFFFE) != v139);
                                              }
                                            }
                                            __int16 v116 = HIWORD(v214);
                                            LOWORD(v213) = v214;
                                            ++v181;
                                            unsigned __int16 v114 = v215;
                                          }
                                        }
                                        else
                                        {
                                          __int16 v116 = HIWORD(v213);
                                        }
                                        HIWORD(v213) = v116 + 1;
                                        if ((unsigned __int16)(v116 + 1) >= v114) {
                                          goto LABEL_147;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              uint64_t v10 = v72;
LABEL_143:
                              int v143 = 0;
LABEL_121:
                              uint64_t v144 = 0;
LABEL_122:
                              uint64_t v17 = (uint64_t)__src;
                              goto LABEL_124;
                            }
                          }
                        }
                      }
                      uint64_t v10 = v49;
                      int v143 = 0;
LABEL_119:
                      uint64_t v144 = 0;
LABEL_124:
                      heap_Free(*(void **)(*a1 + 8), v17);
                      if (v144) {
                        heap_Free(*(void **)(*a1 + 8), v144);
                      }
                      if (v43) {
                        heap_Free(*(void **)(*a1 + 8), v43);
                      }
                      if (v143) {
                        heap_Free(*(void **)(*a1 + 8), (uint64_t)v143);
                      }
                      uint64_t v145 = a1[8];
                      if (v145)
                      {
                        heap_Free(*(void **)(*a1 + 8), v145);
                        a1[8] = 0;
                      }
                      uint64_t v146 = a1[9];
                      if (v146)
                      {
                        heap_Free(*(void **)(*a1 + 8), v146);
                        a1[9] = 0;
                      }
                      uint64_t v147 = a1[10];
                      if (v147)
                      {
                        heap_Free(*(void **)(*a1 + 8), v147);
                        a1[10] = 0;
                      }
                      uint64_t v148 = a1[11];
                      if (v148)
                      {
                        heap_Free(*(void **)(*a1 + 8), v148);
                        a1[11] = 0;
                      }
                      uint64_t v149 = a1[12];
                      if (v149)
                      {
                        heap_Free(*(void **)(*a1 + 8), v149);
                        a1[12] = 0;
                      }
                      return v10;
                    }
                  }
                }
              }
            }
          }
          log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 43000, 0, v39, v40, v41, v42, v171);
          int v143 = 0;
          uint64_t v144 = 0;
          uint64_t v10 = 2340429834;
          goto LABEL_124;
        }
      }
      uint64_t v10 = v18;
LABEL_118:
      int v143 = 0;
      uint64_t v43 = 0;
      goto LABEL_119;
    }
  }
  return v10;
}

uint64_t log_Markers(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = log_OutText(*(void *)(*(void *)a1 + 32), (uint64_t)"FE_NORMOUT", 5, 0, a2, a6, a7, a8, v19);
  if (a4)
  {
    uint64_t v15 = a4;
    uint64_t v16 = a3 + 8;
    do
    {
      uint64_t v17 = *(void *)(*(void *)a1 + 32);
      uint64_t v18 = *(unsigned int *)(v16 - 8);
      if (v18 == 0x4000) {
        uint64_t result = log_OutText(v17, (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"Marker [type=SYNC] Ref (%d,%d) Cur(%d,%d)", v12, v13, v14, *(unsigned int *)(v16 - 4));
      }
      else {
        uint64_t result = log_OutText(v17, (uint64_t)"FE_NORMOUT", 5, 0, (uint64_t)"Marker [type=%5u] Ref (%d,%d) Cur(%d,%d)", v12, v13, v14, v18);
      }
      v16 += 32;
      --v15;
    }
    while (v15);
  }
  return result;
}

uint64_t getSentenceAndInsertedCGNLengthPre(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4)
{
  *(_WORD *)(a4 + 8) = *a3;
  return 0;
}

uint64_t getSentenceAndInsertedCGNLength(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t *a4)
{
  int v19 = 0;
  unsigned int v20 = 0;
  unsigned __int16 v18 = 0;
  long long __s = 0;
  uint64_t v8 = *a4;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, unsigned int *, char *))(*(void *)(*a4 + 8) + 168))(a1, a2, *a3, 0, 1, &v20, (char *)&v19 + 2);
  if ((v9 & 0x80000000) != 0) {
    return v9;
  }
  ++*(_WORD *)a4[2];
  unsigned int v10 = v20;
  if (v20 <= 0xA && ((1 << v20) & 0x610) != 0)
  {
    size_t v11 = (_DWORD *)a4[6];
    if (!*v11)
    {
      ++*(_WORD *)a4[3];
      ++*(_WORD *)a4[4];
    }
    *size_t v11 = 0;
    uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, char *))(*(void *)(v8 + 8)
                                                                                               + 168))(a1, a2, *a3, 1, 1, &v19, (char *)&v19 + 2);
    if ((v12 & 0x80000000) != 0) {
      return v12;
    }
    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned __int16 *, char *))(*(void *)(v8 + 8) + 168))(a1, a2, *a3, 2, 1, &v18, (char *)&v19 + 2);
    if ((v9 & 0x80000000) != 0) {
      return v9;
    }
    *(_WORD *)a4[3] += Utf8_LengthInUtf8chars(a4[7] + (unsigned __int16)v19, v18 - (unsigned __int16)v19);
    *(_WORD *)a4[4] = v18 + *(_WORD *)a4[4] - v19;
    unsigned int v10 = v20;
  }
  if (v10 == 7)
  {
    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, char *))(*(void *)(v8 + 8) + 176))(a1, a2, *a3, 4, &__s, (char *)&v19 + 2);
    if ((v9 & 0x80000000) != 0) {
      return v9;
    }
    uint64_t v13 = __s;
    *(_WORD *)a4[4] += strlen(__s) + 6;
    *(_WORD *)a4[3] += strlen(v13) + 2;
    unsigned int v10 = v20;
  }
  if (*(_DWORD *)(*a4 + 104)) {
    BOOL v14 = v10 == 6;
  }
  else {
    BOOL v14 = 0;
  }
  if (v14)
  {
    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, char *))(*(void *)(v8 + 8) + 176))(a1, a2, *a3, 4, &__s, (char *)&v19 + 2);
    if ((v9 & 0x80000000) == 0)
    {
      uint64_t v15 = __s;
      *(_WORD *)a4[3] = *(_WORD *)a4[3] + 2 * strlen(__s) - 2;
      *(_WORD *)a4[4] = *(_WORD *)a4[4] + 2 * strlen(v15) - 2;
    }
  }
  return v9;
}

uint64_t getSentenceAndInsertedCGNLengthPost()
{
  return 0;
}

uint64_t normOutFnc(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t *a4)
{
  uint64_t v6 = a2;
  int v77 = 0;
  unsigned int v78 = 0;
  unsigned __int16 v76 = 0;
  BOOL v75 = 0;
  uint64_t v72 = 0;
  __s2 = 0;
  long long __s = 0;
  uint64_t v8 = *a4;
  *(_WORD *)(a4[17] + 16 * *(unsigned __int16 *)a4[10]) = *a3;
  uint64_t BacktransPOS = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, unsigned int *, char *))(*(void *)(v8 + 8) + 168))(a1, a2, (unsigned __int16)*a3, 0, 1, &v78, (char *)&v77 + 2);
  if ((BacktransPOS & 0x80000000) != 0) {
    return BacktransPOS;
  }
  *(_DWORD *)(a4[17] + 16 * *(unsigned __int16 *)a4[10] + 4) = v78;
  uint64_t BacktransPOS = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, char *))(*(void *)(v8 + 8) + 168))(a1, v6, (unsigned __int16)*a3, 1, 1, &v77, (char *)&v77 + 2);
  if ((BacktransPOS & 0x80000000) != 0) {
    return BacktransPOS;
  }
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned __int16 *, char *))(*(void *)(v8 + 8) + 168))(a1, v6, (unsigned __int16)*a3, 2, 1, &v76, (char *)&v77 + 2);
  if ((v10 & 0x80000000) != 0) {
    return v10;
  }
  __int16 v11 = v77;
  uint64_t v12 = a4[17];
  uint64_t v13 = (unsigned __int16 *)a4[10];
  *(_WORD *)(v12 + 16 * *v13 + 12) = v77;
  *(_WORD *)(v12 + 16 * *v13 + 8) = v11;
  unsigned __int16 v14 = v76;
  *(_WORD *)(v12 + 16 * *v13 + 14) = v76;
  *(_WORD *)(v12 + 16 * *v13 + 10) = v14;
  unsigned __int16 v15 = Utf8_LengthInUtf8chars(a4[7] + (unsigned __int16)v77, v76 - (unsigned __int16)v77);
  unsigned int v16 = v78;
  if (v78 <= 0xA && ((1 << v78) & 0x610) != 0)
  {
    *(_WORD *)a4[5] = v76;
    uint64_t BacktransPOS = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, char *))(*(void *)(v8 + 8)
                                                                                                 + 176))(a1, v6, (unsigned __int16)*a3, 5, &__s2, (char *)&v77 + 2);
    if ((BacktransPOS & 0x80000000) != 0) {
      return BacktransPOS;
    }
    uint64_t BacktransPOS = com_mosynt_UseMosynt(*(void *)(v8 + 40), *(void *)(v8 + 48), *(void *)(v8 + 56), &v75);
    if ((BacktransPOS & 0x80000000) != 0) {
      return BacktransPOS;
    }
    if (v75)
    {
      uint64_t BacktransPOS = com_mosynt_GetBacktransPOS(*(void *)(v8 + 40), *(void *)(v8 + 48), *(void *)(v8 + 56), __s2, &v74);
      if ((BacktransPOS & 0x80000000) != 0) {
        return BacktransPOS;
      }
      __s2 = (char *)&v74;
    }
    uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, char *))(*(void *)(v8 + 8) + 176))(a1, v6, (unsigned __int16)*a3, 6, &v72, (char *)&v77 + 2);
    if ((v10 & 0x80000000) != 0) {
      return v10;
    }
    if (*(_DWORD *)(v8 + 104) && !*(_DWORD *)a4[6])
    {
      uint64_t v17 = (const char *)a4[8];
      if (v17 && (unsigned __int16)v77 != *(unsigned __int16 *)a4[13])
      {
        if ((unsigned __int16)v77 > *(unsigned __int16 *)a4[12])
        {
          size_t v19 = *(unsigned __int16 *)a4[11];
          size_t v20 = 2 * strlen(v17) - 2;
          *(_WORD *)(*(void *)(v8 + 96) + strlen(*(const char **)(v8 + 96))) = 88;
          uint64_t v21 = (const char *)a4[8];
          uint64_t v22 = v21 + 1;
          size_t v23 = strlen(v21);
          strncat(*(char **)(v8 + 96), v22, v23 - 2);
          if (v20 >= v19)
          {
            *(_WORD *)(*(void *)(v8 + 96) + strlen(*(const char **)(v8 + 96))) = 89;
            uint64_t v28 = (const char *)a4[8];
            unsigned __int16 v29 = v28 + 1;
            size_t v30 = strlen(v28);
            strncat(*(char **)(v8 + 96), v29, v30 - 2);
            size_t v31 = *(unsigned __int16 *)a4[11];
            if (2 * strlen((const char *)a4[8]) - 2 > v31)
            {
              do
              {
                *(_WORD *)(*(void *)(v8 + 64) + strlen(*(const char **)(v8 + 64))) = 126;
                *(_WORD *)(*(void *)(v8 + 72) + strlen(*(const char **)(v8 + 72))) = 126;
                *(_WORD *)(*(void *)(v8 + 80) + strlen(*(const char **)(v8 + 80))) = 126;
                *(_WORD *)(*(void *)(v8 + 88) + strlen(*(const char **)(v8 + 88))) = 126;
                LODWORD(v31) = v31 + 1;
              }
              while (2 * strlen((const char *)a4[8]) - 2 > (unsigned __int16)v31);
            }
          }
          else
          {
            int v24 = 2 * strlen((const char *)a4[8]) - 2;
            if ((v24 & 0xFFFEu) < *(unsigned __int16 *)a4[11])
            {
              do
              {
                *(_WORD *)(*(void *)(v8 + 96) + strlen(*(const char **)(v8 + 96))) = 126;
                ++v24;
              }
              while (*(unsigned __int16 *)a4[11] > (unsigned __int16)v24);
            }
            *(_WORD *)(*(void *)(v8 + 96) + strlen(*(const char **)(v8 + 96))) = 89;
            uint64_t v25 = (const char *)a4[8];
            uint64_t v26 = v25 + 1;
            size_t v27 = strlen(v25);
            strncat(*(char **)(v8 + 96), v26, v27 - 2);
          }
          a4[8] = 0;
        }
      }
      else if (*(_WORD *)a4[9])
      {
        unsigned int v18 = 0;
        do
        {
          *(_WORD *)(*(void *)(v8 + 96) + strlen(*(const char **)(v8 + 96))) = 32;
          ++v18;
        }
        while (v18 < *(unsigned __int16 *)a4[9]);
      }
    }
    int v32 = *(_DWORD *)a4[6];
    unsigned int v33 = (unsigned __int16)v77;
    if (v32)
    {
      __int16 v34 = 0;
    }
    else
    {
      unsigned __int16 v35 = v33 - utf8_GetPreviousUtf8Offset(a4[7], (unsigned __int16)v77);
      strncat(*(char **)(v8 + 64), (const char *)(a4[7] + (unsigned __int16)v77 - v35), v35);
      *(_WORD *)(*(void *)(v8 + 72) + strlen(*(const char **)(v8 + 72))) = 32;
      *(_WORD *)(*(void *)(v8 + 80) + strlen(*(const char **)(v8 + 80))) = 32;
      strncat(*(char **)(v8 + 88), (const char *)(a4[7] + (unsigned __int16)v77 - v35), v35);
      __int16 v34 = 1;
      unsigned int v33 = (unsigned __int16)v77;
    }
    strncat(*(char **)(v8 + 64), (const char *)(a4[7] + v33), v76 - (unint64_t)v33);
    strncat(*(char **)(v8 + 88), (const char *)(a4[7] + (unsigned __int16)v77), v76 - (unint64_t)(unsigned __int16)v77);
    unsigned __int16 v15 = Utf8_LengthInUtf8chars(a4[7] + (unsigned __int16)v77, v76 - (unsigned __int16)v77);
    int v36 = v15;
    if (v15)
    {
      do
      {
        strncat(*(char **)(v8 + 72), __s2, 1uLL);
        strncat(*(char **)(v8 + 80), v72, 1uLL);
        --v36;
      }
      while (v36);
    }
    *(_WORD *)a4[9] = v15;
    if (*(_DWORD *)(v8 + 104))
    {
      uint64_t v37 = a4[8];
      if (v37 && (unsigned __int16)v77 != *(unsigned __int16 *)a4[13])
      {
        *(_WORD *)a4[11] += v34 + v15;
      }
      else
      {
        if (!v32)
        {
          *(_WORD *)(*(void *)(v8 + 96) + strlen(*(const char **)(v8 + 96))) = 32;
          uint64_t v37 = a4[8];
        }
        if (v37) {
          *(_WORD *)a4[11] = *(_WORD *)a4[9];
        }
      }
    }
    *(_DWORD *)a4[6] = 0;
    unsigned int v16 = v78;
  }
  if (v16 == 7)
  {
    unsigned __int16 v38 = strlen(*(const char **)(v8 + 64));
    uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, char *))(*(void *)(v8 + 8) + 176))(a1, v6, (unsigned __int16)*a3, 4, &__s, (char *)&v77 + 2);
    if ((v10 & 0x80000000) != 0) {
      return v10;
    }
    uint64_t v70 = v6;
    unsigned __int16 v39 = strlen(__s);
    uint64_t v40 = (unsigned __int16)Utf8_LengthInUtf8chars(*(void *)(v8 + 64), v38);
    unsigned __int16 v69 = Utf8_LengthInBytes(*(unsigned __int8 **)(v8 + 88), v40);
    if ((unsigned __int16)v77 >= *(unsigned __int16 *)a4[5])
    {
      *(_DWORD *)(*(void *)(v8 + 64) + strlen(*(const char **)(v8 + 64))) = 11704034;
      strcat(*(char **)(v8 + 64), __s);
      int v51 = 0;
      *(_DWORD *)(*(void *)(v8 + 64) + strlen(*(const char **)(v8 + 64))) = 12359394;
      unsigned int v52 = v39 + 2;
      do
      {
        *(_WORD *)(*(void *)(v8 + 72) + strlen(*(const char **)(v8 + 72))) = 32;
        *(_WORD *)(*(void *)(v8 + 80) + strlen(*(const char **)(v8 + 80))) = 32;
        *(_WORD *)(*(void *)(v8 + 88) + strlen(*(const char **)(v8 + 88))) = 126;
        ++v51;
      }
      while (v52 > (unsigned __int16)v51);
    }
    else
    {
      memmove((void *)(*(void *)(v8 + 64) + v38 + (unsigned __int16)v77 - *(unsigned __int16 *)a4[5] + v39 + 6), (const void *)(*(void *)(v8 + 64) + v38 - *(unsigned __int16 *)a4[5] + (unsigned __int16)v77), *(unsigned __int16 *)a4[5] - (unsigned __int16)v77 + 1);
      uint64_t v41 = (char *)(*(void *)(v8 + 72) + v40 - v15);
      memmove(&v41[v39 + 2], v41, v15 + 1);
      uint64_t v42 = (char *)(*(void *)(v8 + 80) + v40 - v15);
      memmove(&v42[v39 + 2], v42, v15 + 1);
      uint64_t v43 = *(unsigned __int16 *)a4[5];
      uint64_t v44 = (char *)(*(void *)(v8 + 88) + v69 - v43 + (unsigned __int16)v77);
      memmove(&v44[v39 + 2], v44, v43 - (unsigned __int16)v77 + 1);
      uint64_t v45 = *(void *)(v8 + 64) + (unsigned __int16)(v38 - *(_WORD *)a4[5] + v77);
      *(unsigned char *)(v45 + 2) = -78;
      *(_WORD *)uint64_t v45 = -26910;
      uint64_t v46 = v40 - v15;
      *(unsigned char *)(*(void *)(v8 + 72) + v46) = 32;
      *(unsigned char *)(*(void *)(v8 + 80) + v46) = 32;
      *(unsigned char *)(*(void *)(v8 + 88) + v69 - (unint64_t)*(unsigned __int16 *)a4[5] + (unsigned __int16)v77) = 126;
      if (v39)
      {
        uint64_t v47 = 0;
        uint64_t v48 = v46 + 1;
        do
        {
          if (__s[v47]) {
            *(unsigned char *)(*(void *)(v8 + 64) + (int)(v38 + 3 + v47 - *(unsigned __int16 *)a4[5] + (unsigned __int16)v77)) = __s[v47];
          }
          *(unsigned char *)(*(void *)(v8 + 72) + v48 + v47) = 32;
          *(unsigned char *)(*(void *)(v8 + 80) + v48 + v47) = 32;
          *(unsigned char *)(*(void *)(v8 + 88) + (int)(v69 + 1 + v47++ - *(unsigned __int16 *)a4[5] + (unsigned __int16)v77)) = 126;
        }
        while (v39 != v47);
      }
      uint64_t v49 = *(void *)(v8 + 64) + (unsigned __int16)(v38 + v39 - *(_WORD *)a4[5] + v77 + 3);
      *(unsigned char *)(v49 + 2) = -68;
      *(_WORD *)uint64_t v49 = -26910;
      uint64_t v50 = v39 + 1 + v46;
      *(unsigned char *)(*(void *)(v8 + 72) + v50) = 32;
      *(unsigned char *)(*(void *)(v8 + 80) + v50) = 32;
      *(unsigned char *)(*(void *)(v8 + 88)
               + (unsigned __int16)v77
               - (unint64_t)*(unsigned __int16 *)a4[5]
               + v39
               + 1
               + v69) = 126;
    }
    uint64_t v53 = __s;
    if (a4[8]) {
      *(_WORD *)a4[11] += strlen(__s) + 2;
    }
    *(_WORD *)a4[9] += strlen(v53) + 2;
    unsigned int v16 = v78;
    uint64_t v6 = v70;
  }
  if (v16 != 6)
  {
LABEL_71:
    ++*(_WORD *)a4[10];
    return v10;
  }
  uint64_t BacktransPOS = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, char *))(*(void *)(v8 + 8) + 168))(a1, v6, (unsigned __int16)*a3, 1, 1, a4[13], (char *)&v77 + 2);
  if ((BacktransPOS & 0x80000000) != 0) {
    return BacktransPOS;
  }
  if (*(_DWORD *)(v8 + 104))
  {
    uint64_t v54 = (const char *)a4[8];
    if (v54)
    {
      if (*(unsigned __int16 *)a4[13] > *(unsigned __int16 *)a4[12])
      {
        size_t v55 = *(unsigned __int16 *)a4[11];
        size_t v56 = 2 * strlen(v54) - 2;
        *(_WORD *)(*(void *)(v8 + 96) + strlen(*(const char **)(v8 + 96))) = 88;
        uint64_t v57 = (const char *)a4[8];
        uint64_t v58 = v57 + 1;
        size_t v59 = strlen(v57);
        strncat(*(char **)(v8 + 96), v58, v59 - 2);
        if (v56 >= v55)
        {
          *(_WORD *)(*(void *)(v8 + 96) + strlen(*(const char **)(v8 + 96))) = 89;
          uint64_t v64 = (const char *)a4[8];
          uint64_t v65 = v64 + 1;
          size_t v66 = strlen(v64);
          strncat(*(char **)(v8 + 96), v65, v66 - 2);
          size_t v67 = *(unsigned __int16 *)a4[11];
          if (2 * strlen((const char *)a4[8]) - 2 > v67)
          {
            do
            {
              *(_WORD *)(*(void *)(v8 + 64) + strlen(*(const char **)(v8 + 64))) = 126;
              *(_WORD *)(*(void *)(v8 + 72) + strlen(*(const char **)(v8 + 72))) = 126;
              *(_WORD *)(*(void *)(v8 + 80) + strlen(*(const char **)(v8 + 80))) = 126;
              *(_WORD *)(*(void *)(v8 + 88) + strlen(*(const char **)(v8 + 88))) = 126;
              LODWORD(v67) = v67 + 1;
            }
            while (2 * strlen((const char *)a4[8]) - 2 > (unsigned __int16)v67);
          }
        }
        else
        {
          int v60 = 2 * strlen((const char *)a4[8]) - 2;
          if ((v60 & 0xFFFEu) < *(unsigned __int16 *)a4[11])
          {
            do
            {
              *(_WORD *)(*(void *)(v8 + 96) + strlen(*(const char **)(v8 + 96))) = 126;
              ++v60;
            }
            while (*(unsigned __int16 *)a4[11] > (unsigned __int16)v60);
          }
          *(_WORD *)(*(void *)(v8 + 96) + strlen(*(const char **)(v8 + 96))) = 89;
          uint64_t v61 = (const char *)a4[8];
          uint64_t v62 = v61 + 1;
          size_t v63 = strlen(v61);
          strncat(*(char **)(v8 + 96), v62, v63 - 2);
        }
        a4[8] = 0;
        *(_WORD *)a4[9] = 0;
      }
    }
  }
  uint64_t BacktransPOS = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t *, char *))(*(void *)(v8 + 8)
                                                                                                 + 176))(a1, v6, (unsigned __int16)*a3, 4, a4 + 8, (char *)&v77 + 2);
  if ((BacktransPOS & 0x80000000) != 0) {
    return BacktransPOS;
  }
  uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, char *))(*(void *)(v8 + 8)
                                                                                               + 168))(a1, v6, (unsigned __int16)*a3, 2, 1, a4[12], (char *)&v77 + 2);
  if ((v10 & 0x80000000) == 0)
  {
    *(_WORD *)a4[11] = *(_WORD *)a4[9];
    goto LABEL_71;
  }
  return v10;
}

uint64_t normOutFncPost(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __int16 v4 = *(const char ***)a4;
  if (*(_DWORD *)(*(void *)a4 + 104) && !**(_DWORD **)(a4 + 48))
  {
    int v7 = *(const char **)(a4 + 64);
    if (v7)
    {
      size_t v8 = **(unsigned __int16 **)(a4 + 88);
      size_t v9 = 2 * strlen(v7) - 2;
      *(_WORD *)&v4[12][strlen(v4[12])] = 88;
      uint64_t v10 = *(const char **)(a4 + 64);
      __int16 v11 = v10 + 1;
      size_t v12 = strlen(v10);
      strncat((char *)v4[12], v11, v12 - 2);
      if (v9 >= v8)
      {
        *(_WORD *)&v4[12][strlen(v4[12])] = 89;
        unsigned int v18 = *(const char **)(a4 + 64);
        size_t v19 = v18 + 1;
        size_t v20 = strlen(v18);
        strncat((char *)v4[12], v19, v20 - 2);
        size_t v21 = **(unsigned __int16 **)(a4 + 88);
        if (2 * strlen(*(const char **)(a4 + 64)) - 2 > v21)
        {
          do
          {
            *(_WORD *)&v4[8][strlen(v4[8])] = 126;
            *(_WORD *)&v4[9][strlen(v4[9])] = 126;
            *(_WORD *)&v4[10][strlen(v4[10])] = 126;
            *(_WORD *)&v4[11][strlen(v4[11])] = 126;
            LODWORD(v21) = v21 + 1;
          }
          while (2 * strlen(*(const char **)(a4 + 64)) - 2 > (unsigned __int16)v21);
        }
      }
      else
      {
        int v13 = 2 * strlen(*(const char **)(a4 + 64)) - 2;
        if ((v13 & 0xFFFEu) < **(unsigned __int16 **)(a4 + 88))
        {
          do
          {
            *(_WORD *)&v4[12][strlen(v4[12])] = 126;
            ++v13;
          }
          while (**(unsigned __int16 **)(a4 + 88) > (unsigned __int16)v13);
        }
        *(_WORD *)&v4[12][strlen(v4[12])] = 89;
        unsigned __int16 v14 = *(const char **)(a4 + 64);
        unsigned __int16 v15 = v14 + 1;
        size_t v16 = strlen(v14);
        strncat((char *)v4[12], v15, v16 - 2);
      }
    }
    else if (**(_WORD **)(a4 + 72))
    {
      unsigned int v17 = 0;
      do
      {
        *(_WORD *)&v4[12][strlen(v4[12])] = 32;
        ++v17;
      }
      while (v17 < **(unsigned __int16 **)(a4 + 72));
    }
  }
  return 0;
}

uint64_t fe_normout_split_words(void *a1, uint64_t a2, uint64_t a3, char *__s, uint64_t a5, unsigned __int16 *a6)
{
  unsigned __int16 v10 = strlen(__s);
  *a6 = 0;
  unsigned int v11 = v10;
  if (!v10)
  {
    unsigned __int16 v49 = 0;
    goto LABEL_87;
  }
  unsigned __int16 v54 = 0;
  uint64_t v55 = a2;
  int v51 = a6;
  int v12 = 0;
  unsigned __int16 v13 = 0;
  int v14 = 0;
  do
  {
    unsigned __int16 v15 = &__s[(unsigned __int16)v14];
    int v16 = *v15;
    if (v16 != 32 && v16 != 95 && strncmp(&__s[(unsigned __int16)v14], "▬", 3uLL)) {
      goto LABEL_81;
    }
    if (a5 && v54 >= 0x80u)
    {
      uint64_t v17 = heap_Realloc(*(uint64_t **)(*a1 + 8), a1[14], (v54 & 0xFF80u) + 128);
      if (!v17)
      {
        log_OutPublic(*(void *)(*a1 + 32), (uint64_t)"FE_NORMOUT", 43000, 0, v18, v19, v20, v21, v51);
        return 2340429834;
      }
      a1[14] = v17;
      bzero((void *)(v17 + v54), (v54 & 0xFF80) + 128 - v54);
      uint64_t v22 = a3;
    }
    else
    {
      uint64_t v22 = a3;
      if (!a5) {
        goto LABEL_69;
      }
    }
    if (strncmp(&__s[(unsigned __int16)v14], "▬", 3uLL)) {
      goto LABEL_69;
    }
    unsigned __int16 v65 = 0;
    int v64 = 0;
    unsigned __int16 v63 = 0;
    unsigned __int16 v62 = -1;
    unsigned __int16 v61 = -1;
    __int16 v60 = 0;
    unsigned int v59 = 11;
    uint64_t v58 = 0;
    int v57 = 0;
    if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, unsigned __int16 *))(a1[1] + 104))(v55, v22, 1, 0, &v65) & 0x80000000) != 0)goto LABEL_65; {
    if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, __int16 *))(a1[1] + 152))(v55, v22, 2, v65, &v60) & 0x80000000) != 0)goto LABEL_65;
    }
    if (!v60) {
      goto LABEL_65;
    }
    if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *))(a1[1] + 104))(v55, v22, 2, v65, (char *)&v64 + 2) & 0x80000000) != 0)goto LABEL_65; {
    unsigned __int16 v23 = HIWORD(v64);
    }
    if (!HIWORD(v64)) {
      goto LABEL_65;
    }
    unsigned __int16 v24 = 0;
    while (1)
    {
      int v25 = v62;
      int v26 = v61;
      if (v62 != 0xFFFF && v61 != 0xFFFF) {
        break;
      }
      if (((*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, unsigned int *, int *))(a1[1] + 168))(v55, v22, v23, 0, 1, &v59, &v64) & 0x80000000) != 0)goto LABEL_65; {
      if (v59 > 0xA || ((1 << v59) & 0x610) == 0)
      }
        goto LABEL_34;
      if (v24 == v13)
      {
        int v29 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned __int16 *, int *))(a1[1] + 168))(v55, v22, HIWORD(v64), 1, 1, &v62, &v64);
        goto LABEL_32;
      }
      if (v13 + 1 == v24)
      {
        int v29 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned __int16 *, int *))(a1[1] + 168))(v55, v22, HIWORD(v64), 2, 1, &v61, &v64);
LABEL_32:
        if (v29 < 0) {
          goto LABEL_65;
        }
      }
      ++v24;
LABEL_34:
      if (((*(uint64_t (**)(uint64_t, uint64_t, void, char *))(a1[1] + 120))(v55, v22, HIWORD(v64), (char *)&v64 + 2) & 0x80000000) != 0)goto LABEL_65; {
      unsigned __int16 v23 = HIWORD(v64);
      }
      if (!HIWORD(v64))
      {
        int v25 = v62;
        int v26 = v61;
        break;
      }
    }
    BOOL v30 = v25 == 0xFFFF || v26 == 0xFFFF;
    if (!v30
      && ((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t *, unsigned __int16 *))(a1[1] + 176))(v55, v22, v65, 1, &v58, &v63) & 0x80000000) == 0)
    {
      unsigned int v31 = v63;
      if (v63 < 2u)
      {
        unsigned int v35 = 1;
      }
      else
      {
        int v32 = (int *)(v58 + 44);
        uint64_t v33 = 1;
        while (1)
        {
          int v34 = *v32;
          v32 += 8;
          if (v34 - *(_DWORD *)(v58 + 12) > v62) {
            break;
          }
          if (v63 == ++v33) {
            goto LABEL_65;
          }
        }
        unsigned int v35 = (unsigned __int16)v33;
      }
      if (v35 < v63 && !v57)
      {
        unint64_t v36 = v35 + 1;
        uint64_t v37 = 32 * v35;
        while (1)
        {
          unsigned __int16 v38 = (unsigned int *)(v58 + v37);
          if (*(_DWORD *)(v58 + v37 + 12) - *(_DWORD *)(v58 + 12) >= v61) {
            break;
          }
          uint64_t v39 = *v38;
          uint64_t v40 = (char *)*((void *)v38 + 3);
          uint64_t v67 = 0;
          unsigned __int16 v66 = 0;
          if (v39 <= 0x39)
          {
            if (v39 == 51)
            {
              unint64_t v52 = v36;
              uint64_t v41 = hlp_NLUStrFind(v40, "PUNC", &v67, &v66);
              unint64_t v36 = v52;
              if (!v41) {
                goto LABEL_64;
              }
              int v42 = v57;
              unsigned int v31 = v63;
              goto LABEL_60;
            }
            if (((1 << v39) & 0x3C0010124001140) != 0) {
              goto LABEL_64;
            }
          }
          if (v39 == 17)
          {
LABEL_64:
            int v57 = 1;
            break;
          }
          int v42 = 0;
LABEL_60:
          if (!v42)
          {
            v37 += 32;
            if (v36++ < v31) {
              continue;
            }
          }
          break;
        }
      }
    }
LABEL_65:
    if (!v57)
    {
      fe_normout_check_if_word_in_prompt((uint64_t)a1, v55, v22, v13, &v57);
      if (!v57)
      {
        fe_normout_check_if_word_in_prompt((uint64_t)a1, v55, v22, (unsigned __int16)(v13 + 1), &v57);
        if (!v57) {
          *(unsigned char *)(a1[14] + v54++) = v13 + 1;
        }
      }
    }
LABEL_69:
    if (!strncmp(&__s[(unsigned __int16)v14], "▬", 3uLL))
    {
      *unsigned __int16 v15 = 0;
      __s[v12 + 1] = 0;
      v14 += 2;
    }
    __s[(unsigned __int16)v14] = 0;
    int v44 = v14 + 1;
    if (v11 > (unsigned __int16)(v14 + 1))
    {
      int v45 = (unsigned __int16)(v14 + 1);
      do
      {
        uint64_t v46 = &__s[(unsigned __int16)v44];
        int v47 = *v46;
        if (v47 != 32 && v47 != 95 && strncmp(&__s[(unsigned __int16)v44], "▬", 3uLL)) {
          break;
        }
        if (!strncmp(&__s[(unsigned __int16)v44], "▬", 3uLL))
        {
          *uint64_t v46 = 0;
          __s[v45 + 1] = 0;
          int v44 = v14 + 3;
          uint64_t v48 = (unsigned __int16)(v14 + 3);
        }
        else
        {
          uint64_t v48 = (unsigned __int16)v44;
        }
        int v14 = v44;
        __s[v48] = 0;
        int v45 = (unsigned __int16)++v44;
      }
      while (v11 > (unsigned __int16)v44);
    }
    ++v13;
LABEL_81:
    int v12 = (unsigned __int16)++v14;
  }
  while (v11 > (unsigned __int16)v14);
  if (__s[(unsigned __int16)v14 - 1]) {
    unsigned __int16 v49 = v13 + 1;
  }
  else {
    unsigned __int16 v49 = v13;
  }
  a6 = v51;
LABEL_87:
  uint64_t result = 0;
  *a6 = v49;
  return result;
}

uint64_t getNextWord(_WORD *a1, _WORD *a2, uint64_t a3, unsigned int a4)
{
  *a2 = *a1;
  uint64_t v4 = (unsigned __int16)*a1;
  if (v4 >= a4) {
    return 0;
  }
  while (!*(unsigned char *)(a3 + v4))
  {
    *a1 = ++v4;
    if (a4 == (unsigned __int16)v4) {
      return 0;
    }
  }
  int v6 = (unsigned __int16)*a2;
  uint64_t v7 = a3 + (unsigned __int16)(v6 + 1) + 1;
  do
  {
    size_t v8 = (unsigned __int8 *)v7;
    *a2 = ++v6;
    if (a4 <= (unsigned __int16)v6) {
      break;
    }
    ++v7;
  }
  while (*(unsigned char *)(a3 + (unsigned __int16)v6));
  for (unsigned int i = (unsigned __int16)v6 + 1; i < a4; unsigned int i = v11 + 2)
  {
    if (*v8++) {
      break;
    }
    int v11 = (unsigned __int16)v6++;
    *a2 = v6;
  }
  return 1;
}

uint64_t updateWordRecFnc(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4)
{
  int v19 = 0;
  int v20 = 0;
  unsigned __int16 v18 = 0;
  size_t v8 = *(void **)a4;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, int *, char *))(*(void *)(*(void *)a4 + 8)
                                                                                               + 168))(a1, a2, *a3, 0, 1, &v20, (char *)&v19 + 2);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned __int16 *, char *))(v8[1] + 168))(a1, a2, *a3, 1, 1, &v18, (char *)&v19 + 2);
    if ((result & 0x80000000) == 0 && v18 > **(unsigned __int16 **)(a4 + 168) && v20 == 7)
    {
      int v11 = strstr((char *)(*(void *)(a4 + 152) + 3), "▼");
      *(void *)(a4 + 160) = v11;
      if (v11)
      {
        *int v11 = 0;
        int v16 = *(const char **)(a4 + 152);
        unsigned __int16 v17 = strlen(v16);
        LODWORD(result) = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, const char *, int *))(v8[1] + 160))(a1, a2, *a3, 4, v17, v16 + 3, &v19);
        if ((int)result >= 0) {
          return 2340437532;
        }
        else {
          return result;
        }
      }
      else
      {
        log_OutPublic(*(void *)(*v8 + 32), (uint64_t)"FE_NORMOUT", 43001, "%s%s", v12, v13, v14, v15, "message");
        return 2340429831;
      }
    }
  }
  return result;
}

uint64_t updateWordRecs(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7, __int16 a8)
{
  uint64_t v39 = result;
  if (a5)
  {
    uint64_t v8 = 0;
    int v9 = (__int16)(a8 - a7);
    int v10 = a7 + a6;
    unint64_t v11 = a5;
    unsigned int v35 = (_WORD *)(a4 + 14);
    int v38 = a6;
    uint64_t v37 = a4;
    int v36 = a7 + a6;
    do
    {
      uint64_t v12 = a4 + 16 * v8;
      unsigned int v14 = *(_DWORD *)(v12 + 4);
      uint64_t v13 = (_DWORD *)(v12 + 4);
      int v15 = (1 << v14) & 0x610;
      if (v14 <= 0xA && v15 != 0)
      {
        int v18 = *(unsigned __int16 *)(v12 + 8);
        unsigned __int16 v17 = (unsigned __int16 *)(v12 + 8);
        if (v18 == a6)
        {
          uint64_t v19 = a4 + 16 * v8;
          int v20 = (unsigned __int16 *)(v19 + 10);
          if (v10 == *(unsigned __int16 *)(v19 + 10))
          {
            uint64_t v21 = 0;
            __int16 v23 = *(_WORD *)(v19 + 14);
            uint64_t v22 = (_WORD *)(v19 + 14);
            *uint64_t v22 = v23 + v9;
            int v42 = v22;
            unsigned __int16 v24 = v22 - 1;
            int v25 = v35;
            do
            {
              if (v8 != v21)
              {
                unsigned int v26 = (unsigned __int16)*(v25 - 1);
                if (v26 > *v24)
                {
                  *(v25 - 1) = (v26 + v9) & ~((__int16)(v26 + v9) >> 15);
                  *v25 += v9;
                }
                unsigned int v27 = *(_DWORD *)(v25 - 5);
                if (v27 <= 0xF && ((1 << v27) & 0x8060) != 0)
                {
                  unsigned int v29 = *v17;
                  if (v29 >= (unsigned __int16)*(v25 - 3))
                  {
                    unsigned int v30 = (unsigned __int16)*(v25 - 2);
                    if (v29 < v30 && v30 + 1 >= *v20)
                    {
                      if (v27 != 6
                        || (memset(__n, 0, sizeof(__n)),
                            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, _WORD *, _WORD *))(*(void *)(v39 + 8) + 176))(a2, a3, (unsigned __int16)*(v25 - 7), 4, &__n[1], __n), !__n[0])|| (uint64_t result = strncmp(*(const char **)&__n[1], "_PR_", __n[0]), (v9 & 0x80000000) == 0)|| result)
                      {
                        *v25 += v9;
                      }
                    }
                  }
                }
              }
              ++v21;
              v25 += 8;
            }
            while (v11 != v21);
            uint64_t v31 = v8 + 1;
            a4 = v37;
            if (v8 + 1 < v11 && *v13 == 4)
            {
              uint64_t v32 = v37 + 16 * v31;
              if (*(_DWORD *)(v32 + 4) == 16 && *(unsigned __int16 *)(v32 + 12) == *v24) {
                *(_WORD *)(v37 + 16 * v31 + 14) = *v42;
              }
            }
            a6 = v38;
            int v10 = v36;
            if (v8)
            {
              if (*v13 == 4)
              {
                uint64_t v33 = (v8 - 1);
                uint64_t v34 = v37 + 16 * v33;
                if (*(_DWORD *)(v34 + 4) == 16 && *(unsigned __int16 *)(v34 + 12) == *v24) {
                  *(_WORD *)(v37 + 16 * v33 + 14) = *v42;
                }
              }
            }
          }
        }
      }
      ++v8;
    }
    while (v8 != v11);
  }
  return result;
}

uint64_t MvToEqWordRecUpdFieldsFnc(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4)
{
  int v36 = 0;
  unsigned int v37 = 0;
  int v34 = 0;
  int v35 = 0;
  uint64_t v8 = *(void **)a4;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, unsigned int *, char *))(*(void *)(*(void *)a4 + 8) + 168))(a1, a2, (unsigned __int16)*a3, 0, 1, &v37, (char *)&v36 + 2);
  if ((v9 & 0x80000000) == 0)
  {
    unsigned __int16 v10 = **(_WORD **)(a4 + 16);
    if (v10)
    {
      unsigned __int16 v11 = 0;
      uint64_t v12 = "-*";
      do
      {
        uint64_t v13 = (unsigned __int16 *)(*(void *)(a4 + 136) + 16 * v11);
        *(void *)(a4 + 144) = v13;
        if (*v13 == (unsigned __int16)*a3)
        {
          uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t))(v8[1] + 160))(a1, a2);
          if ((v14 & 0x80000000) != 0) {
            return v14;
          }
          uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, int *))(v8[1] + 160))(a1, a2, (unsigned __int16)*a3, 2, 1, *(void *)(a4 + 144) + 14, &v36);
          if ((v9 & 0x80000000) != 0) {
            return v9;
          }
          if (v37 <= 0xA && ((1 << v37) & 0x610) != 0)
          {
            long long __s = 0;
            int v15 = *(_WORD **)(a4 + 112);
            int v16 = (unsigned __int16)*v15;
            if (*v15)
            {
              unsigned __int16 v17 = *(_WORD **)(a4 + 128);
              if (v16 == *(unsigned __int8 *)(v8[14] + (unsigned __int16)*v17))
              {
                if (**(_WORD **)(a4 + 120))
                {
                  __src = 0;
                  ++*v17;
                  *(unsigned char *)(*(unsigned __int16 *)(*(void *)(a4 + 144) + 12) + *(void *)(a4 + 176) - 1) = 45;
                  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, char *))(v8[1] + 176))(a1, a2, (unsigned __int16)*a3, 3, &__s, (char *)&v36 + 2);
                  if ((v14 & 0x80000000) != 0) {
                    return v14;
                  }
                  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, char *))(v8[1] + 176))(a1, a2, **(unsigned __int16 **)(a4 + 120), 3, &__src, (char *)&v36 + 2);
                  if ((v14 & 0x80000000) != 0) {
                    return v14;
                  }
                  int v18 = v12;
                  int v19 = strlen(__s);
                  int v20 = strlen(__src);
                  uint64_t v21 = (char *)heap_Realloc(*(uint64_t **)(*v8 + 8), *(void *)(a4 + 184), (v19 + v20 + 2));
                  if (!v21)
                  {
                    log_OutPublic(*(void *)(*v8 + 32), (uint64_t)"FE_NORMOUT", 43000, 0, v22, v23, v24, v25, __src);
                    return 2340429834;
                  }
                  *(void *)(a4 + 184) = v21;
                  strcpy(v21, __src);
                  size_t v26 = strlen(*(const char **)(a4 + 184));
                  if (*((_DWORD *)v8 + 27)) {
                    __int16 v27 = 61;
                  }
                  else {
                    __int16 v27 = 45;
                  }
                  *(_WORD *)(*(void *)(a4 + 184) + v26) = v27;
                  strcat(*(char **)(a4 + 184), __s);
                  __int16 v28 = strlen(*(const char **)(a4 + 184));
                  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, void, int *))(v8[1] + 160))(a1, a2, **(unsigned __int16 **)(a4 + 120), 3, (unsigned __int16)(v28 + 1), *(void *)(a4 + 184), &v36);
                  if ((v14 & 0x80000000) != 0) {
                    return v14;
                  }
                  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, uint64_t, int *))(v8[1] + 160))(a1, a2, **(unsigned __int16 **)(a4 + 120), 2, 1, *(void *)(a4 + 144) + 14, &v36);
                  if ((v14 & 0x80000000) != 0) {
                    return v14;
                  }
                  uint64_t v12 = v18;
                  if (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, int *))(v8[1] + 184))(a1, a2, **(unsigned __int16 **)(a4 + 144), 8, &v34) & 0x80000000) == 0&& (unsigned __int16)v34 == 1)
                  {
                    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, char *))(v8[1] + 168))(a1, a2, **(unsigned __int16 **)(a4 + 144), 8, 1, (char *)&v34 + 2, (char *)&v36 + 2);
                    if ((v14 & 0x80000000) != 0) {
                      return v14;
                    }
                    uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, int *))(v8[1] + 160))(a1, a2, **(unsigned __int16 **)(a4 + 120), 8, 1, (char *)&v34 + 2, &v36);
                    if ((v14 & 0x80000000) != 0) {
                      return v14;
                    }
                  }
                  if (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, int *))(v8[1] + 184))(a1, a2, **(unsigned __int16 **)(a4 + 144), 14, &v34) & 0x80000000) == 0&& (unsigned __int16)v34 == 1)
                  {
                    uint64_t v14 = MvToEqWordRecUpdNLU(a1, a2, v8, a4);
                    if ((v14 & 0x80000000) != 0) {
                      return v14;
                    }
                  }
                  uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, void))(v8[1] + 192))(a1, a2, (unsigned __int16)*a3);
                  if ((v14 & 0x80000000) != 0) {
                    return v14;
                  }
                  *a3 = **(_WORD **)(a4 + 120);
                }
              }
            }
            uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, char *))(v8[1] + 176))(a1, a2, (unsigned __int16)*a3, 3, &__s, (char *)&v36 + 2);
            if ((v9 & 0x80000000) != 0) {
              return v9;
            }
            if (*__s && strstr(__s, v12))
            {
              uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, char *, char *))(v8[1] + 168))(a1, a2, (unsigned __int16)*a3, 1, 1, (char *)&v35 + 2, (char *)&v36 + 2);
              if ((v14 & 0x80000000) != 0) {
                return v14;
              }
              uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, int *, char *))(v8[1] + 168))(a1, a2, (unsigned __int16)*a3, 2, 1, &v35, (char *)&v36 + 2);
              if ((v9 & 0x80000000) != 0) {
                return v9;
              }
              for (unsigned int i = (char *)(*(void *)(a4 + 176) + HIWORD(v35)); ; unsigned int i = v30 + 1)
              {
                unsigned int v30 = strchr(i, 45);
                if (!v30 || (unint64_t)v30 >= *(void *)(a4 + 176) + (unint64_t)(unsigned __int16)v35) {
                  break;
                }
                *unsigned int v30 = 95;
              }
            }
            ++**(_WORD **)(a4 + 112);
            **(_WORD **)(a4 + 120) = *a3;
          }
          unsigned __int16 v10 = **(_WORD **)(a4 + 16);
          unsigned __int16 v11 = v10;
        }
        ++v11;
      }
      while (v11 < v10);
    }
  }
  return v9;
}

uint64_t fe_normout_ProcessEnd(uint64_t a1, int a2)
{
  LODWORD(result) = safeh_HandleCheck(a1, a2, 62387, 120);
  if ((int)result >= 0) {
    return result;
  }
  else {
    return 2340429832;
  }
}

uint64_t fe_normout_GetInterface(unsigned int a1, void *a2)
{
  if (a1 > 1) {
    return 2340429825;
  }
  uint64_t result = 0;
  *a2 = &IFeNormout;
  return result;
}

uint64_t fe_normout_check_if_word_in_prompt(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, _DWORD *a5)
{
  int v15 = 0;
  int v16 = 0;
  unsigned int v14 = 11;
  unsigned __int16 v13 = -1;
  *a5 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, char *))(*(void *)(a1 + 8) + 104))(a2, a3, 1, 0, (char *)&v16 + 2);
  if ((result & 0x80000000) == 0)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, int *))(*(void *)(a1 + 8) + 152))(a2, a3, 2, HIWORD(v16), &v15);
    if ((result & 0x80000000) == 0)
    {
      if ((_WORD)v15)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, int *))(*(void *)(a1 + 8) + 104))(a2, a3, 2, HIWORD(v16), &v16);
        if ((result & 0x80000000) == 0)
        {
          unsigned __int16 v10 = v16;
          if ((_WORD)v16)
          {
            unsigned __int16 v11 = 0;
            while (1)
            {
              uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, unsigned int *, char *))(*(void *)(a1 + 8) + 168))(a2, a3, v10, 0, 1, &v14, (char *)&v15 + 2);
              if ((result & 0x80000000) != 0) {
                break;
              }
              if (v14 <= 0xA && ((1 << v14) & 0x610) != 0)
              {
                if (a4 == v11)
                {
                  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, unsigned __int16 *, char *))(*(void *)(a1 + 8) + 168))(a2, a3, (unsigned __int16)v16, 1, 1, &v13, (char *)&v15 + 2);
                  if ((result & 0x80000000) != 0) {
                    return result;
                  }
                }
                ++v11;
              }
              uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, int *))(*(void *)(a1 + 8) + 120))(a2, a3, (unsigned __int16)v16, &v16);
              if ((result & 0x80000000) != 0) {
                return result;
              }
              unsigned __int16 v10 = v16;
              if (!(_WORD)v16 || a4 < v11)
              {
                if (v13 != 0xFFFF) {
                  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 + 8) + 312))(a2, a3);
                }
                return result;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t MvToEqWordRecUpdNLU(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  unsigned __int16 v49 = 0;
  long long __s = 0;
  memset(v47, 0, sizeof(v47));
  *(void *)&__n[1] = 0;
  __n[0] = 0;
  int v45 = 0;
  unsigned __int16 v44 = 0;
  uint64_t v43 = 0;
  unsigned __int16 v42 = 0;
  uint64_t v41 = 0;
  unsigned int v39 = 0;
  int v40 = 0;
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, int *))(a3[1] + 176))(a1, a2, **(unsigned __int16 **)(a4 + 144), 14, &v49, &v40);
  if ((v8 & 0x80000000) != 0) {
    return v8;
  }
  if (!hlp_NLUStrFind(v49, "POS", (uint64_t *)&v47[1], v47))
  {
    if (!hlp_NLUStrFind(v49, "PUNC", (uint64_t *)&v41, (unsigned __int16 *)&v40 + 1)) {
      return v8;
    }
    int v23 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, unsigned int *))(a3[1] + 184))(a1, a2, **(unsigned __int16 **)(a4 + 120), 14, &v39);
    uint64_t v24 = a3[1];
    uint64_t v25 = **(unsigned __int16 **)(a4 + 120);
    if (v23 < 0 || (unsigned __int16)v39 != 1)
    {
      unsigned int v30 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, void, char *, char *))(v24 + 160);
      __int16 v31 = strlen(v49);
      return v30(a1, a2, v25, 14, (unsigned __int16)(v31 + 1), v49, (char *)&v39 + 2);
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, char **, int *))(v24 + 176))(a1, a2, v25, 14, &__s, &v40);
    __int16 v26 = strlen(__s);
    __int16 v27 = strlen(v49);
    __int16 v28 = (char *)heap_Calloc(*(void **)(*a3 + 8), 1, (unsigned __int16)(v26 + v27 + 2));
    if (v28)
    {
      uint64_t v21 = v28;
      strcpy(v28, __s);
      hlp_NLUStrRemoveKeyVal(__s, "BND");
      hlp_NLUStrJoin(v21, v49);
      __int16 v29 = strlen(v21);
      uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, char *, char *))(a3[1] + 160))(a1, a2, **(unsigned __int16 **)(a4 + 120), 14, (unsigned __int16)(v29 + 1), v21, (char *)&v39 + 2);
LABEL_32:
      heap_Free(*(void **)(*a3 + 8), (uint64_t)v21);
      return v8;
    }
    goto LABEL_18;
  }
  hlp_NLUStrFind(v49, "BNDSHAPE", (uint64_t *)&v45, &v44);
  hlp_NLUStrFind(v49, "BND", (uint64_t *)&v43, &v42);
  hlp_NLUStrFind(v49, "PUNC", (uint64_t *)&v41, (unsigned __int16 *)&v40 + 1);
  if (((*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, unsigned int *))(a3[1] + 184))(a1, a2, **(unsigned __int16 **)(a4 + 120), 14, &v39) & 0x80000000) != 0)return v8; {
  if ((unsigned __int16)v39 != 1)
  }
    return v8;
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, char **, int *))(a3[1] + 176))(a1, a2, **(unsigned __int16 **)(a4 + 120), 14, &__s, &v40);
  if (!hlp_NLUStrFind(__s, "POS", (uint64_t *)&__n[1], __n)) {
    return v8;
  }
  uint64_t v9 = heap_Calloc(*(void **)(*a3 + 8), 1, __n[0] + (unint64_t)v47[0] + 2);
  if (!v9)
  {
LABEL_18:
    uint64_t v8 = 2340429834;
    log_OutPublic(*(void *)(*a3 + 32), (uint64_t)"FE_NORMOUT", 43000, 0, v10, v11, v12, v13, v39);
    return v8;
  }
  unsigned int v14 = (char *)v9;
  uint64_t v15 = (unsigned __int16)(strlen(__s) + v47[0] + v44 + v42 + HIWORD(v40) + 24);
  int v16 = (char *)heap_Calloc(*(void **)(*a3 + 8), 1, v15);
  uint64_t v21 = v16;
  if (v16)
  {
    strcpy(v16, __s);
    strncpy(v14, *(const char **)&__n[1], __n[0]);
    if (!*((_DWORD *)a3 + 27)) {
      *(_WORD *)&v14[strlen(v14)] = 45;
    }
    strncat(v14, *(const char **)&v47[1], v47[0]);
    hlp_NLUStrSet(v21, "POS", v14);
    if (v45)
    {
      char v22 = v45[v44];
      v45[v44] = 0;
      hlp_NLUStrSet(v21, "BNDSHAPE", v45);
      v45[v44] = v22;
    }
    else
    {
      hlp_NLUStrRemoveKeyVal(v21, "BNDSHAPE");
    }
    if (v43)
    {
      char v32 = v43[v44];
      v43[v44] = 0;
      hlp_NLUStrSet(v21, "BND", v43);
      v43[v44] = v32;
    }
    else
    {
      hlp_NLUStrRemoveKeyVal(v21, "BND");
    }
    if (v41)
    {
      char v33 = v41[HIWORD(v40)];
      v41[HIWORD(v40)] = 0;
      hlp_NLUStrSet(v21, "PUNC", v41);
      v41[HIWORD(v40)] = v33;
    }
    else
    {
      hlp_NLUStrRemoveKeyVal(v21, "PUNC");
    }
    hlp_NLUStrRemoveKeyVal(v49, "POS");
    hlp_NLUStrRemoveKeyVal(v49, "PHR");
    hlp_NLUStrRemoveKeyVal(v49, "PUNC");
    hlp_NLUStrRemoveKeyVal(v49, "BNDSHAPE");
    hlp_NLUStrRemoveKeyVal(v49, "BND");
    if (!*v49) {
      goto LABEL_29;
    }
    size_t v34 = strlen(v49);
    int v35 = (const char *)heap_Realloc(*(uint64_t **)(*a3 + 8), (uint64_t)v21, v34 + v15);
    if (v35)
    {
      int v36 = (char *)v35;
      hlp_NLUStrJoin(v35, v49);
      uint64_t v21 = v36;
LABEL_29:
      __int16 v37 = strlen(v21);
      uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void, char *, char *))(a3[1] + 160))(a1, a2, **(unsigned __int16 **)(a4 + 120), 14, (unsigned __int16)(v37 + 1), v21, (char *)&v39 + 2);
      goto LABEL_31;
    }
  }
  uint64_t v8 = 2340429834;
  log_OutPublic(*(void *)(*a3 + 32), (uint64_t)"FE_NORMOUT", 43000, 0, v17, v18, v19, v20, v39);
LABEL_31:
  heap_Free(*(void **)(*a3 + 8), (uint64_t)v14);
  if (v21) {
    goto LABEL_32;
  }
  return v8;
}

uint64_t fe_normout_ObjOpen(uint64_t a1, uint64_t a2, _WORD *a3, int a4, uint64_t a5)
{
  uint64_t v29 = 0;
  unsigned int v30 = 0;
  uint64_t fecfg = 2340429834;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  if (!a5) {
    return 2340429831;
  }
  *(void *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  uint64_t inited = InitRsrcFunction(a3, a4, &v30);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t inited = objc_GetObject(v30[6], (uint64_t)"LINGDB", &v29);
  if ((inited & 0x80000000) != 0) {
    return inited;
  }
  uint64_t Object = objc_GetObject(v30[6], (uint64_t)"FE_DEPES", &v28);
  uint64_t v9 = v30[6];
  if ((Object & 0x80000000) != 0)
  {
    uint64_t v25 = "LINGDB";
LABEL_15:
    objc_ReleaseObject(v9, (uint64_t)v25);
    return Object;
  }
  uint64_t v10 = objc_GetObject(v9, (uint64_t)"FE_DCTLKP", &v27);
  if ((v10 & 0x80000000) != 0)
  {
    uint64_t Object = v10;
    objc_ReleaseObject(v30[6], (uint64_t)"LINGDB");
    uint64_t v9 = v30[6];
    uint64_t v25 = "FE_DEPES";
    goto LABEL_15;
  }
  uint64_t v11 = heap_Alloc(v30[1], 120);
  int v16 = v30;
  if (v11)
  {
    uint64_t v17 = (void *)v11;
    *(void *)uint64_t v11 = v30;
    *(void *)(v11 + 8) = *(void *)(v29 + 8);
    uint64_t v18 = v28;
    *(void *)(v11 + 32) = *(void *)(v28 + 8);
    *(_OWORD *)(v11 + 16) = *(_OWORD *)(v18 + 16);
    uint64_t v19 = v27;
    *(void *)(v11 + 56) = *(void *)(v27 + 8);
    *(_OWORD *)(v11 + 40) = *(_OWORD *)(v19 + 16);
    *(void *)(v11 + 112) = 0;
    *(void *)(v11 + 96) = 0;
    *(_OWORD *)(v11 + 64) = 0u;
    *(_OWORD *)(v11 + 80) = 0u;
    uint64_t v20 = heap_Alloc(v16[1], 128);
    v17[14] = v20;
    if (v20)
    {
      uint64_t fecfg = fe_normout_get_fecfg((uint64_t)v17);
      if ((fecfg & 0x80000000) != 0) {
        fe_normout_ObjClose(*(void **)a5, *(void *)(a5 + 8));
      }
      *(void *)a5 = v17;
      *(_DWORD *)(a5 + 8) = 62387;
    }
    else
    {
      log_OutPublic(*(void *)(*v17 + 32), (uint64_t)"FE_NORMOUT", 43000, 0, v21, v22, v23, v24, v27);
      objc_ReleaseObject(v30[6], (uint64_t)"LINGDB");
      objc_ReleaseObject(v30[6], (uint64_t)"FE_DEPES");
      objc_ReleaseObject(v30[6], (uint64_t)"FE_DCTLKP");
      heap_Free(*(void **)(*v17 + 8), (uint64_t)v17);
    }
  }
  else
  {
    log_OutPublic(v30[4], (uint64_t)"FE_NORMOUT", 43000, 0, v12, v13, v14, v15, v27);
    objc_ReleaseObject(v30[6], (uint64_t)"LINGDB");
    objc_ReleaseObject(v30[6], (uint64_t)"FE_DEPES");
    objc_ReleaseObject(v30[6], (uint64_t)"FE_DCTLKP");
  }
  return fecfg;
}